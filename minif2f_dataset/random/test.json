[{"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.IsBoundedUnder.isCoboundedUnder_ge", "start": [245, 1], "end": [247, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.preimage_iInter", "start": [1742, 1], "end": [1743, 12], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2\ns : \u03b9 \u2192 Set \u03b2\n\u22a2 f \u207b\u00b9' \u22c2 i, s i = \u22c2 i, f \u207b\u00b9' s i", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2\ns : \u03b9 \u2192 Set \u03b2\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 f \u207b\u00b9' \u22c2 i, s i \u2194 x\u271d \u2208 \u22c2 i, f \u207b\u00b9' s i"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2\ns : \u03b9 \u2192 Set \u03b2\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 f \u207b\u00b9' \u22c2 i, s i \u2194 x\u271d \u2208 \u22c2 i, f \u207b\u00b9' s i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Basic.lean", "full_name": "lt_of_not_le", "start": [462, 1], "end": [463, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.mul_mem", "start": [566, 11], "end": [567, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.congr_sets", "start": [181, 1], "end": [183, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Opposite.lean", "full_name": "AlgEquiv.toRingEquiv_opOp", "start": [64, 9], "end": [64, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.update_piecewise_of_not_mem", "start": [2669, 1], "end": [2673, 29], "traced_tactics": [{"tactic": "rw [update_piecewise]", "annotated_tactic": ["rw [<a>update_piecewise</a>]", [{"full_name": "Finset.update_piecewise", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2656, 9], "def_end_pos": [2656, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : \u03b1 \u2192 Sort u_4\ns : Finset \u03b1\nf g : (i : \u03b1) \u2192 \u03b4 i\ninst\u271d\u00b9 : (j : \u03b1) \u2192 Decidable (j \u2208 s)\ninst\u271d : DecidableEq \u03b1\ni : \u03b1\nhi : i \u2209 s\nv : \u03b4 i\n\u22a2 update (piecewise s f g) i v = piecewise s f (update g i v)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : \u03b1 \u2192 Sort u_4\ns : Finset \u03b1\nf g : (i : \u03b1) \u2192 \u03b4 i\ninst\u271d\u00b9 : (j : \u03b1) \u2192 Decidable (j \u2208 s)\ninst\u271d : DecidableEq \u03b1\ni : \u03b1\nhi : i \u2209 s\nv : \u03b4 i\n\u22a2 piecewise s (update f i v) (update g i v) = piecewise s f (update g i v)"}, {"tactic": "refine' s.piecewise_congr (fun j hj => update_noteq _ _ _) fun _ _ => rfl", "annotated_tactic": ["refine' s.piecewise_congr (fun j hj => <a>update_noteq</a> _ _ _) fun _ _ => <a>rfl</a>", [{"full_name": "Function.update_noteq", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [566, 9], "def_end_pos": [566, 21]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : \u03b1 \u2192 Sort u_4\ns : Finset \u03b1\nf g : (i : \u03b1) \u2192 \u03b4 i\ninst\u271d\u00b9 : (j : \u03b1) \u2192 Decidable (j \u2208 s)\ninst\u271d : DecidableEq \u03b1\ni : \u03b1\nhi : i \u2209 s\nv : \u03b4 i\n\u22a2 piecewise s (update f i v) (update g i v) = piecewise s f (update g i v)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : \u03b1 \u2192 Sort u_4\ns : Finset \u03b1\nf g : (i : \u03b1) \u2192 \u03b4 i\ninst\u271d\u00b9 : (j : \u03b1) \u2192 Decidable (j \u2208 s)\ninst\u271d : DecidableEq \u03b1\ni : \u03b1\nhi : i \u2209 s\nv : \u03b4 i\nj : \u03b1\nhj : j \u2208 s\n\u22a2 j \u2260 i"}, {"tactic": "exact fun h => hi (h \u25b8 hj)", "annotated_tactic": ["exact fun h => hi (h \u25b8 hj)", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : \u03b1 \u2192 Sort u_4\ns : Finset \u03b1\nf g : (i : \u03b1) \u2192 \u03b4 i\ninst\u271d\u00b9 : (j : \u03b1) \u2192 Decidable (j \u2208 s)\ninst\u271d : DecidableEq \u03b1\ni : \u03b1\nhi : i \u2209 s\nv : \u03b4 i\nj : \u03b1\nhj : j \u2208 s\n\u22a2 j \u2260 i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Hom.lean", "full_name": "NormedAddGroupHom.Equalizer.norm_lift_le", "start": [982, 1], "end": [984, 5], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Sum/Lemmas.lean", "full_name": "Sum.getLeft?_map", "start": [145, 9], "end": [147, 18], "traced_tactics": [{"tactic": "cases x <;> rfl", "annotated_tactic": ["cases x <;> rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b3 \u2192 \u03b4\nx : \u03b1 \u2295 \u03b3\n\u22a2 getLeft? (Sum.map f g x) = Option.map f (getLeft? x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.addOrderOf_coe'", "start": [126, 1], "end": [127, 74], "traced_tactics": [{"tactic": "rw [\u2190 Nat.smul_one_eq_coe, addOrderOf_nsmul' _ a0, ZMod.addOrderOf_one]", "annotated_tactic": ["rw [\u2190 <a>Nat.smul_one_eq_coe</a>, <a>addOrderOf_nsmul'</a> _ a0, <a>ZMod.addOrderOf_one</a>]", [{"full_name": "Nat.smul_one_eq_coe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [764, 9], "def_end_pos": [764, 28]}, {"full_name": "addOrderOf_nsmul'", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [401, 3], "def_end_pos": [401, 14]}, {"full_name": "ZMod.addOrderOf_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [109, 9], "def_end_pos": [109, 23]}]], "state_before": "a n : \u2115\na0 : a \u2260 0\n\u22a2 addOrderOf \u2191a = n / Nat.gcd n a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Finite.injective_iff_surjective", "start": [652, 1], "end": [656, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.get_extract_loop_ge", "start": [639, 1], "end": [668, 73], "traced_tactics": [{"tactic": "induction size using Nat.recAux generalizing start bs with\n| zero =>\n  rw [size_extract_loop, Nat.zero_min, Nat.add_zero] at h\n  absurd h; exact Nat.not_lt_of_ge hge\n| succ size ih =>\n  have : start < as.size := by\n    apply Nat.lt_of_le_of_lt (Nat.le_add_right start (i - bs.size))\n    rwa [\u2190 Nat.add_sub_assoc hge]\n  have : i < (extract.loop as size (start+1) (bs.push as[start])).size := by\n    rwa [\u2190 extract_loop_succ]\n  have heq : (extract.loop as (size+1) start bs)[i] =\n      (extract.loop as size (start+1) (bs.push as[start]))[i] := by\n    congr 1; rw [extract_loop_succ]\n  rw [heq]\n  if hi : bs.size = i then\n    cases hi\n    have h\u2081 : bs.size < (bs.push as[start]).size := by rw [size_push]; exact Nat.lt_succ_self ..\n    have h\u2082 : bs.size < (extract.loop as size (start+1) (bs.push as[start])).size := by\n      rw [size_extract_loop]; apply Nat.lt_of_lt_of_le h\u2081; exact Nat.le_add_right ..\n    have h : (extract.loop as size (start + 1) (push bs as[start]))[bs.size] = as[start] := by\n      rw [get_extract_loop_lt as (bs.push as[start]) size (start+1) h\u2081 h\u2082, get_push_eq]\n    rw [h]; congr; rw [Nat.add_sub_cancel]\n  else\n    have hge : bs.size + 1 \u2264 i := Nat.lt_of_le_of_ne hge hi\n    rw [ih (bs.push as[start]) (start+1) ((size_push ..).symm \u25b8 hge)]\n    congr 1; rw [size_push, Nat.add_right_comm, Nat.add_sub_add_right]", "annotated_tactic": ["induction size using <a>Nat.recAux</a> generalizing start bs with\n  | <a>zero</a> =>\n    rw [<a>size_extract_loop</a>, <a>Nat.zero_min</a>, <a>Nat.add_zero</a>] at h\n    absurd h; exact <a>Nat.not_lt_of_ge</a> hge\n  | <a>succ</a> size ih =>\n    have : start < as.size := by\n      apply <a>Nat.lt_of_le_of_lt</a> (<a>Nat.le_add_right</a> start (i - bs.size))\n      rwa [\u2190 <a>Nat.add_sub_assoc</a> hge]\n    have : i < (<a>extract.loop</a> as size (start+1) (bs.push as[start])).<a>size</a> := by\n      rwa [\u2190 <a>extract_loop_succ</a>]\n    have heq : (<a>extract.loop</a> as (size+1) start bs)[i] =\n        (<a>extract.loop</a> as size (start+1) (bs.push as[start]))[i] := by\n      congr 1; rw [<a>extract_loop_succ</a>]\n    rw [heq]\n    if hi : bs.size = i then\n      cases hi\n      have h\u2081 : bs.size < (bs.push as[start]).<a>size</a> := by rw [<a>size_push</a>]; exact <a>Nat.lt_succ_self</a> ..\n      have h\u2082 : bs.size < (<a>extract.loop</a> as size (start+1) (bs.push as[start])).<a>size</a> := by\n        rw [<a>size_extract_loop</a>]; apply <a>Nat.lt_of_lt_of_le</a> h\u2081; exact <a>Nat.le_add_right</a> ..\n      have h : (<a>extract.loop</a> as size (start + 1) (<a>push</a> bs as[start]))[bs.size] = as[start] := by\n        rw [<a>get_extract_loop_lt</a> as (bs.push as[start]) size (start+1) h\u2081 h\u2082, <a>get_push_eq</a>]\n      rw [h]; congr; rw [<a>Nat.add_sub_cancel</a>]\n    else\n      have hge : bs.size + 1 \u2264 i := <a>Nat.lt_of_le_of_ne</a> hge hi\n      rw [ih (bs.push as[start]) (start+1) ((<a>size_push</a> ..).<a>symm</a> \u25b8 hge)]\n      congr 1; rw [<a>size_push</a>, <a>Nat.add_right_comm</a>, <a>Nat.add_sub_add_right</a>]", [{"full_name": "Nat.recAux", "def_path": ".lake/packages/std/Std/Data/Nat/Basic.lean", "def_pos": [13, 15], "def_end_pos": [13, 21]}, {"full_name": "Nat.zero", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1068, 5], "def_end_pos": [1068, 9]}, {"full_name": "Array.size_extract_loop", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [598, 9], "def_end_pos": [598, 26]}, {"full_name": "Nat.zero_min", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [340, 27], "def_end_pos": [340, 35]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}, {"full_name": "Nat.not_lt_of_ge", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [360, 19], "def_end_pos": [360, 31]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Nat.lt_of_le_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1728, 19], "def_end_pos": [1728, 37]}, {"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}, {"full_name": "Nat.add_sub_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [643, 19], "def_end_pos": [643, 32]}, {"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.size", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2612, 5], "def_end_pos": [2612, 15]}, {"full_name": "Array.extract_loop_succ", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}, {"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.extract_loop_succ", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}, {"full_name": "Array.size", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2612, 5], "def_end_pos": [2612, 15]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Nat.lt_succ_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 21]}, {"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.size", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2612, 5], "def_end_pos": [2612, 15]}, {"full_name": "Array.size_extract_loop", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [598, 9], "def_end_pos": [598, 26]}, {"full_name": "Nat.lt_of_lt_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [262, 19], "def_end_pos": [262, 33]}, {"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}, {"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.push", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2637, 5], "def_end_pos": [2637, 15]}, {"full_name": "Array.get_extract_loop_lt", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [621, 9], "def_end_pos": [621, 28]}, {"full_name": "Array.get_push_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [110, 17], "def_end_pos": [110, 28]}, {"full_name": "Nat.add_sub_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [635, 27], "def_end_pos": [635, 41]}, {"full_name": "Nat.lt_of_le_of_ne", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1736, 19], "def_end_pos": [1736, 37]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Nat.add_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}, {"full_name": "Nat.add_sub_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [627, 19], "def_end_pos": [627, 36]}]], "state_before": "\u03b1 : Type u_1\ni : Nat\nas bs : Array \u03b1\nsize start : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as size start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\n\u22a2 (extract.loop as size start bs)[i] = as[start + i - Array.size bs]", "state_after": "no goals"}, {"tactic": "rw [size_extract_loop, Nat.zero_min, Nat.add_zero] at h", "annotated_tactic": ["rw [<a>size_extract_loop</a>, <a>Nat.zero_min</a>, <a>Nat.add_zero</a>] at h", [{"full_name": "Array.size_extract_loop", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [598, 9], "def_end_pos": [598, 26]}, {"full_name": "Nat.zero_min", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [340, 27], "def_end_pos": [340, 35]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}]], "state_before": "case zero\n\u03b1 : Type u_1\ni : Nat\nas bs : Array \u03b1\nstart : Nat\nhge : i \u2265 size bs\nh : i < size (extract.loop as 0 start bs)\nh' : optParam (start + i - size bs < size as) \u22ef\n\u22a2 (extract.loop as 0 start bs)[i] = as[start + i - size bs]", "state_after": "case zero\n\u03b1 : Type u_1\ni : Nat\nas bs : Array \u03b1\nstart : Nat\nhge : i \u2265 size bs\nh\u271d : i < size (extract.loop as 0 start bs)\nh : i < size bs\nh' : optParam (start + i - size bs < size as) \u22ef\n\u22a2 (extract.loop as 0 start bs)[i] = as[start + i - size bs]"}, {"tactic": "absurd h", "annotated_tactic": ["absurd h", []], "state_before": "case zero\n\u03b1 : Type u_1\ni : Nat\nas bs : Array \u03b1\nstart : Nat\nhge : i \u2265 size bs\nh\u271d : i < size (extract.loop as 0 start bs)\nh : i < size bs\nh' : optParam (start + i - size bs < size as) \u22ef\n\u22a2 (extract.loop as 0 start bs)[i] = as[start + i - size bs]", "state_after": "case zero\n\u03b1 : Type u_1\ni : Nat\nas bs : Array \u03b1\nstart : Nat\nhge : i \u2265 size bs\nh\u271d : i < size (extract.loop as 0 start bs)\nh : i < size bs\nh' : optParam (start + i - size bs < size as) \u22ef\n\u22a2 \u00aci < size bs"}, {"tactic": "exact Nat.not_lt_of_ge hge", "annotated_tactic": ["exact <a>Nat.not_lt_of_ge</a> hge", [{"full_name": "Nat.not_lt_of_ge", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [360, 19], "def_end_pos": [360, 31]}]], "state_before": "case zero\n\u03b1 : Type u_1\ni : Nat\nas bs : Array \u03b1\nstart : Nat\nhge : i \u2265 size bs\nh\u271d : i < size (extract.loop as 0 start bs)\nh : i < size bs\nh' : optParam (start + i - size bs < size as) \u22ef\n\u22a2 \u00aci < size bs", "state_after": "no goals"}, {"tactic": "have : start < as.size := by\n  apply Nat.lt_of_le_of_lt (Nat.le_add_right start (i - bs.size))\n  rwa [\u2190 Nat.add_sub_assoc hge]", "annotated_tactic": ["have : start < as.size := by\n      apply <a>Nat.lt_of_le_of_lt</a> (<a>Nat.le_add_right</a> start (i - bs.size))\n      rwa [\u2190 <a>Nat.add_sub_assoc</a> hge]", [{"full_name": "Nat.lt_of_le_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1728, 19], "def_end_pos": [1728, 37]}, {"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}, {"full_name": "Nat.add_sub_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [643, 19], "def_end_pos": [643, 32]}]], "state_before": "case succ\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\n\u22a2 (extract.loop as (size + 1) start bs)[i] = as[start + i - Array.size bs]", "state_after": "case succ\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis : start < Array.size as\n\u22a2 (extract.loop as (size + 1) start bs)[i] = as[start + i - Array.size bs]"}, {"tactic": "have : i < (extract.loop as size (start+1) (bs.push as[start])).size := by\n  rwa [\u2190 extract_loop_succ]", "annotated_tactic": ["have : i < (<a>extract.loop</a> as size (start+1) (bs.push as[start])).<a>size</a> := by\n      rwa [\u2190 <a>extract_loop_succ</a>]", [{"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.size", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2612, 5], "def_end_pos": [2612, 15]}, {"full_name": "Array.extract_loop_succ", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}]], "state_before": "case succ\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis : start < Array.size as\n\u22a2 (extract.loop as (size + 1) start bs)[i] = as[start + i - Array.size bs]", "state_after": "case succ\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\n\u22a2 (extract.loop as (size + 1) start bs)[i] = as[start + i - Array.size bs]"}, {"tactic": "have heq : (extract.loop as (size+1) start bs)[i] =\n    (extract.loop as size (start+1) (bs.push as[start]))[i] := by\n  congr 1; rw [extract_loop_succ]", "annotated_tactic": ["have heq : (<a>extract.loop</a> as (size+1) start bs)[i] =\n        (<a>extract.loop</a> as size (start+1) (bs.push as[start]))[i] := by\n      congr 1; rw [<a>extract_loop_succ</a>]", [{"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.extract_loop_succ", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}]], "state_before": "case succ\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\n\u22a2 (extract.loop as (size + 1) start bs)[i] = as[start + i - Array.size bs]", "state_after": "case succ\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\n\u22a2 (extract.loop as (size + 1) start bs)[i] = as[start + i - Array.size bs]"}, {"tactic": "rw [heq]", "annotated_tactic": ["rw [heq]", []], "state_before": "case succ\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\n\u22a2 (extract.loop as (size + 1) start bs)[i] = as[start + i - Array.size bs]", "state_after": "case succ\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[i] = as[start + i - Array.size bs]"}, {"tactic": "if hi : bs.size = i then\n  cases hi\n  have h\u2081 : bs.size < (bs.push as[start]).size := by rw [size_push]; exact Nat.lt_succ_self ..\n  have h\u2082 : bs.size < (extract.loop as size (start+1) (bs.push as[start])).size := by\n    rw [size_extract_loop]; apply Nat.lt_of_lt_of_le h\u2081; exact Nat.le_add_right ..\n  have h : (extract.loop as size (start + 1) (push bs as[start]))[bs.size] = as[start] := by\n    rw [get_extract_loop_lt as (bs.push as[start]) size (start+1) h\u2081 h\u2082, get_push_eq]\n  rw [h]; congr; rw [Nat.add_sub_cancel]\nelse\n  have hge : bs.size + 1 \u2264 i := Nat.lt_of_le_of_ne hge hi\n  rw [ih (bs.push as[start]) (start+1) ((size_push ..).symm \u25b8 hge)]\n  congr 1; rw [size_push, Nat.add_right_comm, Nat.add_sub_add_right]", "annotated_tactic": ["if hi : bs.size = i then\n      cases hi\n      have h\u2081 : bs.size < (bs.push as[start]).<a>size</a> := by rw [<a>size_push</a>]; exact <a>Nat.lt_succ_self</a> ..\n      have h\u2082 : bs.size < (<a>extract.loop</a> as size (start+1) (bs.push as[start])).<a>size</a> := by\n        rw [<a>size_extract_loop</a>]; apply <a>Nat.lt_of_lt_of_le</a> h\u2081; exact <a>Nat.le_add_right</a> ..\n      have h : (<a>extract.loop</a> as size (start + 1) (<a>push</a> bs as[start]))[bs.size] = as[start] := by\n        rw [<a>get_extract_loop_lt</a> as (bs.push as[start]) size (start+1) h\u2081 h\u2082, <a>get_push_eq</a>]\n      rw [h]; congr; rw [<a>Nat.add_sub_cancel</a>]\n    else\n      have hge : bs.size + 1 \u2264 i := <a>Nat.lt_of_le_of_ne</a> hge hi\n      rw [ih (bs.push as[start]) (start+1) ((<a>size_push</a> ..).<a>symm</a> \u25b8 hge)]\n      congr 1; rw [<a>size_push</a>, <a>Nat.add_right_comm</a>, <a>Nat.add_sub_add_right</a>]", [{"full_name": "Array.size", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2612, 5], "def_end_pos": [2612, 15]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Nat.lt_succ_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 21]}, {"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.size", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2612, 5], "def_end_pos": [2612, 15]}, {"full_name": "Array.size_extract_loop", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [598, 9], "def_end_pos": [598, 26]}, {"full_name": "Nat.lt_of_lt_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [262, 19], "def_end_pos": [262, 33]}, {"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}, {"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.push", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2637, 5], "def_end_pos": [2637, 15]}, {"full_name": "Array.get_extract_loop_lt", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [621, 9], "def_end_pos": [621, 28]}, {"full_name": "Array.get_push_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [110, 17], "def_end_pos": [110, 28]}, {"full_name": "Nat.add_sub_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [635, 27], "def_end_pos": [635, 41]}, {"full_name": "Nat.lt_of_le_of_ne", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1736, 19], "def_end_pos": [1736, 37]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Nat.add_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}, {"full_name": "Nat.add_sub_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [627, 19], "def_end_pos": [627, 36]}]], "state_before": "case succ\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[i] = as[start + i - Array.size bs]", "state_after": "no goals"}, {"tactic": "apply Nat.lt_of_le_of_lt (Nat.le_add_right start (i - bs.size))", "annotated_tactic": ["apply <a>Nat.lt_of_le_of_lt</a> (<a>Nat.le_add_right</a> start (i - bs.size))", [{"full_name": "Nat.lt_of_le_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1728, 19], "def_end_pos": [1728, 37]}, {"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}]], "state_before": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\n\u22a2 start < Array.size as", "state_after": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\n\u22a2 start + (i - Array.size bs) < Array.size as"}, {"tactic": "rwa [\u2190 Nat.add_sub_assoc hge]", "annotated_tactic": ["rwa [\u2190 <a>Nat.add_sub_assoc</a> hge]", [{"full_name": "Nat.add_sub_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [643, 19], "def_end_pos": [643, 32]}]], "state_before": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\n\u22a2 start + (i - Array.size bs) < Array.size as", "state_after": "no goals"}, {"tactic": "rwa [\u2190 extract_loop_succ]", "annotated_tactic": ["rwa [\u2190 <a>extract_loop_succ</a>]", [{"full_name": "Array.extract_loop_succ", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}]], "state_before": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis : start < Array.size as\n\u22a2 i < Array.size (extract.loop as size (start + 1) (push bs as[start]))", "state_after": "no goals"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\n\u22a2 (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]", "state_after": "case e_xs\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\n\u22a2 extract.loop as (size + 1) start bs = extract.loop as size (start + 1) (push bs as[start])"}, {"tactic": "rw [extract_loop_succ]", "annotated_tactic": ["rw [<a>extract_loop_succ</a>]", [{"full_name": "Array.extract_loop_succ", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}]], "state_before": "case e_xs\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\n\u22a2 extract.loop as (size + 1) start bs = extract.loop as size (start + 1) (push bs as[start])", "state_after": "no goals"}, {"tactic": "cases hi", "annotated_tactic": ["cases hi", []], "state_before": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\nhi : Array.size bs = i\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[i] = as[start + i - Array.size bs]", "state_after": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start + Array.size bs - Array.size bs]"}, {"tactic": "have h\u2081 : bs.size < (bs.push as[start]).size := by rw [size_push]; exact Nat.lt_succ_self ..", "annotated_tactic": ["have h\u2081 : bs.size < (bs.push as[start]).<a>size</a> := by rw [<a>size_push</a>]; exact <a>Nat.lt_succ_self</a> ..", [{"full_name": "Array.size", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2612, 5], "def_end_pos": [2612, 15]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Nat.lt_succ_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 21]}]], "state_before": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start + Array.size bs - Array.size bs]", "state_after": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start + Array.size bs - Array.size bs]"}, {"tactic": "have h\u2082 : bs.size < (extract.loop as size (start+1) (bs.push as[start])).size := by\n  rw [size_extract_loop]; apply Nat.lt_of_lt_of_le h\u2081; exact Nat.le_add_right ..", "annotated_tactic": ["have h\u2082 : bs.size < (<a>extract.loop</a> as size (start+1) (bs.push as[start])).<a>size</a> := by\n        rw [<a>size_extract_loop</a>]; apply <a>Nat.lt_of_lt_of_le</a> h\u2081; exact <a>Nat.le_add_right</a> ..", [{"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.size", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2612, 5], "def_end_pos": [2612, 15]}, {"full_name": "Array.size_extract_loop", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [598, 9], "def_end_pos": [598, 26]}, {"full_name": "Nat.lt_of_lt_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [262, 19], "def_end_pos": [262, 33]}, {"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}]], "state_before": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start + Array.size bs - Array.size bs]", "state_after": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\nh\u2082 : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start + Array.size bs - Array.size bs]"}, {"tactic": "have h : (extract.loop as size (start + 1) (push bs as[start]))[bs.size] = as[start] := by\n  rw [get_extract_loop_lt as (bs.push as[start]) size (start+1) h\u2081 h\u2082, get_push_eq]", "annotated_tactic": ["have h : (<a>extract.loop</a> as size (start + 1) (<a>push</a> bs as[start]))[bs.size] = as[start] := by\n        rw [<a>get_extract_loop_lt</a> as (bs.push as[start]) size (start+1) h\u2081 h\u2082, <a>get_push_eq</a>]", [{"full_name": "Array.extract.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2722, 11], "def_end_pos": [2722, 15]}, {"full_name": "Array.push", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2637, 5], "def_end_pos": [2637, 15]}, {"full_name": "Array.get_extract_loop_lt", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [621, 9], "def_end_pos": [621, 28]}, {"full_name": "Array.get_push_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [110, 17], "def_end_pos": [110, 28]}]], "state_before": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\nh\u2082 : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start + Array.size bs - Array.size bs]", "state_after": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh\u271d : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\nh\u2082 : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nh : (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start]\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start + Array.size bs - Array.size bs]"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh\u271d : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\nh\u2082 : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nh : (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start]\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start + Array.size bs - Array.size bs]", "state_after": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh\u271d : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\nh\u2082 : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nh : (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start]\n\u22a2 as[start] = as[start + Array.size bs - Array.size bs]"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case refl\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh\u271d : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\nh\u2082 : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nh : (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start]\n\u22a2 as[start] = as[start + Array.size bs - Array.size bs]", "state_after": "case refl.e_i\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh\u271d : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\nh\u2082 : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nh : (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start]\n\u22a2 start = start + Array.size bs - Array.size bs"}, {"tactic": "rw [Nat.add_sub_cancel]", "annotated_tactic": ["rw [<a>Nat.add_sub_cancel</a>]", [{"full_name": "Nat.add_sub_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [635, 27], "def_end_pos": [635, 41]}]], "state_before": "case refl.e_i\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh\u271d : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\nh\u2082 : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nh : (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start]\n\u22a2 start = start + Array.size bs - Array.size bs", "state_after": "no goals"}, {"tactic": "rw [size_push]", "annotated_tactic": ["rw [<a>size_push</a>]", [{"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\n\u22a2 Array.size bs < Array.size (push bs as[start])", "state_after": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\n\u22a2 Array.size bs < Array.size bs + 1"}, {"tactic": "exact Nat.lt_succ_self ..", "annotated_tactic": ["exact <a>Nat.lt_succ_self</a> ..", [{"full_name": "Nat.lt_succ_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 21]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\n\u22a2 Array.size bs < Array.size bs + 1", "state_after": "no goals"}, {"tactic": "rw [size_extract_loop]", "annotated_tactic": ["rw [<a>size_extract_loop</a>]", [{"full_name": "Array.size_extract_loop", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [598, 9], "def_end_pos": [598, 26]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\n\u22a2 Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))", "state_after": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\n\u22a2 Array.size bs < Array.size (push bs as[start]) + min size (Array.size as - (start + 1))"}, {"tactic": "apply Nat.lt_of_lt_of_le h\u2081", "annotated_tactic": ["apply <a>Nat.lt_of_lt_of_le</a> h\u2081", [{"full_name": "Nat.lt_of_lt_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [262, 19], "def_end_pos": [262, 33]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\n\u22a2 Array.size bs < Array.size (push bs as[start]) + min size (Array.size as - (start + 1))", "state_after": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\n\u22a2 Array.size (push bs as[start]) \u2264 Array.size (push bs as[start]) + min size (Array.size as - (start + 1))"}, {"tactic": "exact Nat.le_add_right ..", "annotated_tactic": ["exact <a>Nat.le_add_right</a> ..", [{"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\n\u22a2 Array.size (push bs as[start]) \u2264 Array.size (push bs as[start]) + min size (Array.size as - (start + 1))", "state_after": "no goals"}, {"tactic": "rw [get_extract_loop_lt as (bs.push as[start]) size (start+1) h\u2081 h\u2082, get_push_eq]", "annotated_tactic": ["rw [<a>get_extract_loop_lt</a> as (bs.push as[start]) size (start+1) h\u2081 h\u2082, <a>get_push_eq</a>]", [{"full_name": "Array.get_extract_loop_lt", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [621, 9], "def_end_pos": [621, 28]}, {"full_name": "Array.get_push_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [110, 17], "def_end_pos": [110, 28]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nbs : Array \u03b1\nstart : Nat\nthis\u271d : start < Array.size as\nih :\n  \u2200 (bs_1 : Array \u03b1) (start : Nat) (hge : Array.size bs \u2265 Array.size bs_1)\n    (h : Array.size bs < Array.size (extract.loop as size start bs_1))\n    (h' : optParam (start + Array.size bs - Array.size bs_1 < Array.size as) \u22ef),\n    (extract.loop as size start bs_1)[Array.size bs] = as[start + Array.size bs - Array.size bs_1]\nhge : Array.size bs \u2265 Array.size bs\nh : Array.size bs < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + Array.size bs - Array.size bs < Array.size as) \u22ef\nthis : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq :\n  (extract.loop as (size + 1) start bs)[Array.size bs] =\n    (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs]\nh\u2081 : Array.size bs < Array.size (push bs as[start])\nh\u2082 : Array.size bs < Array.size (extract.loop as size (start + 1) (push bs as[start]))\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[Array.size bs] = as[start]", "state_after": "no goals"}, {"tactic": "have hge : bs.size + 1 \u2264 i := Nat.lt_of_le_of_ne hge hi", "annotated_tactic": ["have hge : bs.size + 1 \u2264 i := <a>Nat.lt_of_le_of_ne</a> hge hi", [{"full_name": "Nat.lt_of_le_of_ne", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1736, 19], "def_end_pos": [1736, 37]}]], "state_before": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\nhi : \u00acArray.size bs = i\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[i] = as[start + i - Array.size bs]", "state_after": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge\u271d : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\nhi : \u00acArray.size bs = i\nhge : Array.size bs + 1 \u2264 i\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[i] = as[start + i - Array.size bs]"}, {"tactic": "rw [ih (bs.push as[start]) (start+1) ((size_push ..).symm \u25b8 hge)]", "annotated_tactic": ["rw [ih (bs.push as[start]) (start+1) ((<a>size_push</a> ..).<a>symm</a> \u25b8 hge)]", [{"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge\u271d : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\nhi : \u00acArray.size bs = i\nhge : Array.size bs + 1 \u2264 i\n\u22a2 (extract.loop as size (start + 1) (push bs as[start]))[i] = as[start + i - Array.size bs]", "state_after": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge\u271d : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\nhi : \u00acArray.size bs = i\nhge : Array.size bs + 1 \u2264 i\n\u22a2 as[start + 1 + i - Array.size (push bs as[start])] = as[start + i - Array.size bs]"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge\u271d : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\nhi : \u00acArray.size bs = i\nhge : Array.size bs + 1 \u2264 i\n\u22a2 as[start + 1 + i - Array.size (push bs as[start])] = as[start + i - Array.size bs]", "state_after": "case e_i\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge\u271d : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\nhi : \u00acArray.size bs = i\nhge : Array.size bs + 1 \u2264 i\n\u22a2 start + 1 + i - Array.size (push bs as[start]) = start + i - Array.size bs"}, {"tactic": "rw [size_push, Nat.add_right_comm, Nat.add_sub_add_right]", "annotated_tactic": ["rw [<a>size_push</a>, <a>Nat.add_right_comm</a>, <a>Nat.add_sub_add_right</a>]", [{"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Nat.add_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}, {"full_name": "Nat.add_sub_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [627, 19], "def_end_pos": [627, 36]}]], "state_before": "case e_i\n\u03b1 : Type u_1\ni : Nat\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat) (hge : i \u2265 Array.size bs) (h : i < Array.size (extract.loop as size start bs))\n    (h' : optParam (start + i - Array.size bs < Array.size as) \u22ef),\n    (extract.loop as size start bs)[i] = as[start + i - Array.size bs]\nbs : Array \u03b1\nstart : Nat\nhge\u271d : i \u2265 Array.size bs\nh : i < Array.size (extract.loop as (size + 1) start bs)\nh' : optParam (start + i - Array.size bs < Array.size as) \u22ef\nthis\u271d : start < Array.size as\nthis : i < Array.size (extract.loop as size (start + 1) (push bs as[start]))\nheq : (extract.loop as (size + 1) start bs)[i] = (extract.loop as size (start + 1) (push bs as[start]))[i]\nhi : \u00acArray.size bs = i\nhge : Array.size bs + 1 \u2264 i\n\u22a2 start + 1 + i - Array.size (push bs as[start]) = start + i - Array.size bs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidHom.ext_iff", "start": [701, 1], "end": [702, 19], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "amc12b_2020_p5", "start": [583, 1], "end": [585, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "a b : \u2115\nh\u2080 : 5 / 8 * \u2191b = 2 / 3 * \u2191a + 7\nh\u2081 : \u2191b - 5 / 8 * \u2191b = \u2191a - 2 / 3 * \u2191a + 7\n\u22a2 a = 42", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "Irreducible.dvd_iff_not_coprime", "start": [464, 1], "end": [465, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Finite/Basic.lean", "full_name": "Nat.ModEq.pow_totient", "start": [471, 1], "end": [477, 49], "traced_tactics": [{"tactic": "rw [\u2190 ZMod.eq_iff_modEq_nat]", "annotated_tactic": ["rw [\u2190 <a>ZMod.eq_iff_modEq_nat</a>]", [{"full_name": "ZMod.eq_iff_modEq_nat", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [753, 9], "def_end_pos": [753, 25]}]], "state_before": "K : Type u_1\nR : Type u_2\nx n : \u2115\nh : Coprime x n\n\u22a2 x ^ \u03c6 n \u2261 1 [MOD n]", "state_after": "K : Type u_1\nR : Type u_2\nx n : \u2115\nh : Coprime x n\n\u22a2 \u2191(x ^ \u03c6 n) = \u21911"}, {"tactic": "let x' : Units (ZMod n) := ZMod.unitOfCoprime _ h", "annotated_tactic": ["let x' : <a>Units</a> (<a>ZMod</a> n) := <a>ZMod.unitOfCoprime</a> _ h", [{"full_name": "Units", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [49, 11], "def_end_pos": [49, 16]}, {"full_name": "ZMod", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Defs.lean", "def_pos": [94, 5], "def_end_pos": [94, 9]}, {"full_name": "ZMod.unitOfCoprime", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [768, 5], "def_end_pos": [768, 18]}]], "state_before": "K : Type u_1\nR : Type u_2\nx n : \u2115\nh : Coprime x n\n\u22a2 \u2191(x ^ \u03c6 n) = \u21911", "state_after": "K : Type u_1\nR : Type u_2\nx n : \u2115\nh : Coprime x n\nx' : (ZMod n)\u02e3 := unitOfCoprime x h\n\u22a2 \u2191(x ^ \u03c6 n) = \u21911"}, {"tactic": "have := ZMod.pow_totient x'", "annotated_tactic": ["have := <a>ZMod.pow_totient</a> x'", [{"full_name": "ZMod.pow_totient", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finite/Basic.lean", "def_pos": [463, 9], "def_end_pos": [463, 25]}]], "state_before": "K : Type u_1\nR : Type u_2\nx n : \u2115\nh : Coprime x n\nx' : (ZMod n)\u02e3 := unitOfCoprime x h\n\u22a2 \u2191(x ^ \u03c6 n) = \u21911", "state_after": "K : Type u_1\nR : Type u_2\nx n : \u2115\nh : Coprime x n\nx' : (ZMod n)\u02e3 := unitOfCoprime x h\nthis : x' ^ \u03c6 n = 1\n\u22a2 \u2191(x ^ \u03c6 n) = \u21911"}, {"tactic": "apply_fun ((fun (x : Units (ZMod n)) => (x : ZMod n)) : Units (ZMod n) \u2192 ZMod n) at this", "annotated_tactic": ["apply_fun ((fun (x : <a>Units</a> (<a>ZMod</a> n)) => (x : <a>ZMod</a> n)) : <a>Units</a> (<a>ZMod</a> n) \u2192 <a>ZMod</a> n) at this", [{"full_name": "Units", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [49, 11], "def_end_pos": [49, 16]}, {"full_name": "ZMod", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Defs.lean", "def_pos": [94, 5], "def_end_pos": [94, 9]}, {"full_name": "ZMod", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Defs.lean", "def_pos": [94, 5], "def_end_pos": [94, 9]}, {"full_name": "Units", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [49, 11], "def_end_pos": [49, 16]}, {"full_name": "ZMod", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Defs.lean", "def_pos": [94, 5], "def_end_pos": [94, 9]}, {"full_name": "ZMod", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Defs.lean", "def_pos": [94, 5], "def_end_pos": [94, 9]}]], "state_before": "K : Type u_1\nR : Type u_2\nx n : \u2115\nh : Coprime x n\nx' : (ZMod n)\u02e3 := unitOfCoprime x h\nthis : x' ^ \u03c6 n = 1\n\u22a2 \u2191(x ^ \u03c6 n) = \u21911", "state_after": "K : Type u_1\nR : Type u_2\nx n : \u2115\nh : Coprime x n\nx' : (ZMod n)\u02e3 := unitOfCoprime x h\nthis : \u2191(x' ^ \u03c6 n) = \u21911\n\u22a2 \u2191(x ^ \u03c6 n) = \u21911"}, {"tactic": "simpa only [Nat.succ_eq_add_one, Nat.cast_pow, Units.val_one, Nat.cast_one,\n  coe_unitOfCoprime, Units.val_pow_eq_pow_val]", "annotated_tactic": ["simpa only [<a>Nat.succ_eq_add_one</a>, <a>Nat.cast_pow</a>, <a>Units.val_one</a>, <a>Nat.cast_one</a>,\n    <a>coe_unitOfCoprime</a>, <a>Units.val_pow_eq_pow_val</a>]", [{"full_name": "Nat.succ_eq_add_one", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 24]}, {"full_name": "Nat.cast_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [83, 7], "def_end_pos": [83, 15]}, {"full_name": "Units.val_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [222, 9], "def_end_pos": [222, 16]}, {"full_name": "Nat.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [150, 9], "def_end_pos": [150, 17]}, {"full_name": "ZMod.coe_unitOfCoprime", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [773, 9], "def_end_pos": [773, 26]}, {"full_name": "Units.val_pow_eq_pow_val", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [408, 7], "def_end_pos": [408, 25]}]], "state_before": "K : Type u_1\nR : Type u_2\nx n : \u2115\nh : Coprime x n\nx' : (ZMod n)\u02e3 := unitOfCoprime x h\nthis : \u2191(x' ^ \u03c6 n) = \u21911\n\u22a2 \u2191(x ^ \u03c6 n) = \u21911", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.smul_mem", "start": [126, 1], "end": [127, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.submatrix_map", "start": [2514, 1], "end": [2516, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Eisenstein/Basic.lean", "full_name": "Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem", "start": [201, 1], "end": [206, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/DirectSum/Module.lean", "full_name": "DirectSum.single_eq_lof", "start": [76, 1], "end": [76, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image2_nonempty_iff", "start": [136, 1], "end": [137, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/OrdConnected.lean", "full_name": "OrderEmbedding.image_Ico", "start": [93, 1], "end": [96, 78], "traced_tactics": [{"tactic": "rw [\u2190 e.preimage_Ico, image_preimage_eq_inter_range,\n  inter_eq_left.2 <| Ico_subset_Icc_self.trans <| he.out \u27e8_, rfl\u27e9 \u27e8_, rfl\u27e9]", "annotated_tactic": ["rw [\u2190 e.preimage_Ico, <a>image_preimage_eq_inter_range</a>,\n    <a>inter_eq_left</a>.2 <| Ico_subset_Icc_self.trans <| he.out \u27e8_, <a>rfl</a>\u27e9 \u27e8_, <a>rfl</a>\u27e9]", [{"full_name": "Set.image_preimage_eq_inter_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [777, 9], "def_end_pos": [777, 38]}, {"full_name": "Set.inter_eq_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [949, 15], "def_end_pos": [949, 28]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u21aao \u03b2\nhe : OrdConnected (range \u21d1e)\nx y : \u03b1\n\u22a2 \u21d1e '' Ico x y = Ico (e x) (e y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Function/Indicator.lean", "full_name": "Set.mulIndicator_self_mul_compl", "start": [430, 1], "end": [432, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Adjoin.lean", "full_name": "IntermediateField.extendScalars_adjoin", "start": [488, 1], "end": [492, 43], "traced_tactics": [{"tactic": "rw [extendScalars_restrictScalars, restrictScalars_adjoin]", "annotated_tactic": ["rw [<a>extendScalars_restrictScalars</a>, <a>restrictScalars_adjoin</a>]", [{"full_name": "IntermediateField.extendScalars_restrictScalars", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/IntermediateField.lean", "def_pos": [711, 9], "def_end_pos": [711, 38]}, {"full_name": "IntermediateField.restrictScalars_adjoin", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [483, 9], "def_end_pos": [483, 31]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS\u271d : Set E\nK : IntermediateField F E\nS : Set E\nh : K \u2264 adjoin F S\n\u22a2 restrictScalars F (extendScalars h) = restrictScalars F (adjoin (\u21a5K) S)", "state_after": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS\u271d : Set E\nK : IntermediateField F E\nS : Set E\nh : K \u2264 adjoin F S\n\u22a2 adjoin F S = adjoin F (\u2191K \u222a S)"}, {"tactic": "exact le_antisymm (adjoin.mono F S _ <| Set.subset_union_right _ S) <| adjoin_le_iff.2 <|\n  Set.union_subset h (subset_adjoin F S)", "annotated_tactic": ["exact <a>le_antisymm</a> (<a>adjoin.mono</a> F S _ <| <a>Set.subset_union_right</a> _ S) <| <a>adjoin_le_iff</a>.2 <|\n    <a>Set.union_subset</a> h (<a>subset_adjoin</a> F S)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "IntermediateField.adjoin.mono", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [367, 9], "def_end_pos": [367, 20]}, {"full_name": "Set.subset_union_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [803, 9], "def_end_pos": [803, 27]}, {"full_name": "IntermediateField.adjoin_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [75, 9], "def_end_pos": [75, 22]}, {"full_name": "Set.union_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [806, 9], "def_end_pos": [806, 21]}, {"full_name": "IntermediateField.subset_adjoin", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [360, 9], "def_end_pos": [360, 22]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS\u271d : Set E\nK : IntermediateField F E\nS : Set E\nh : K \u2264 adjoin F S\n\u22a2 adjoin F S = adjoin F (\u2191K \u222a S)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Maps.lean", "full_name": "Inducing.isOpenMap", "start": [435, 11], "end": [436, 100], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Real.lean", "full_name": "ENNReal.ofReal_inv_of_pos", "start": [357, 1], "end": [359, 25], "traced_tactics": [{"tactic": "rw [ENNReal.ofReal, ENNReal.ofReal, \u2190 @coe_inv (Real.toNNReal x) (by simp [hx]), coe_inj,\n  \u2190 Real.toNNReal_inv]", "annotated_tactic": ["rw [<a>ENNReal.ofReal</a>, <a>ENNReal.ofReal</a>, \u2190 @<a>coe_inv</a> (<a>Real.toNNReal</a> x) (by simp [hx]), <a>coe_inj</a>,\n    \u2190 <a>Real.toNNReal_inv</a>]", [{"full_name": "ENNReal.ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [198, 29], "def_end_pos": [198, 35]}, {"full_name": "ENNReal.ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [198, 29], "def_end_pos": [198, 35]}, {"full_name": "ENNReal.coe_inv", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Inv.lean", "def_pos": [63, 9], "def_end_pos": [63, 16]}, {"full_name": "Real.toNNReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [118, 19], "def_end_pos": [118, 39]}, {"full_name": "ENNReal.coe_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [181, 26], "def_end_pos": [181, 33]}, {"full_name": "Real.toNNReal_inv", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [990, 9], "def_end_pos": [990, 33]}]], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx : \u211d\nhx : 0 < x\n\u22a2 ENNReal.ofReal x\u207b\u00b9 = (ENNReal.ofReal x)\u207b\u00b9", "state_after": "no goals"}, {"tactic": "simp [hx]", "annotated_tactic": ["simp [hx]", []], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx : \u211d\nhx : 0 < x\n\u22a2 Real.toNNReal x \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.comp_symm_eq", "start": [612, 1], "end": [613, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Atoms.lean", "full_name": "Set.Iic.isCoatom_iff", "start": [224, 1], "end": [227, 98], "traced_tactics": [{"tactic": "rw [\u2190 covBy_top_iff]", "annotated_tactic": ["rw [\u2190 <a>covBy_top_iff</a>]", [{"full_name": "covBy_top_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Atoms.lean", "def_pos": [196, 9], "def_end_pos": [196, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na\u271d b : \u03b1\na : \u2191(Iic b)\n\u22a2 IsCoatom a \u2194 \u2191a \u22d6 b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na\u271d b : \u03b1\na : \u2191(Iic b)\n\u22a2 a \u22d6 \u22a4 \u2194 \u2191a \u22d6 b"}, {"tactic": "refine' (Set.OrdConnected.apply_covBy_apply_iff (OrderEmbedding.subtype fun c => c \u2264 b) _).symm", "annotated_tactic": ["refine' (<a>Set.OrdConnected.apply_covBy_apply_iff</a> (<a>OrderEmbedding.subtype</a> fun c => c \u2264 b) _).<a>symm</a>", [{"full_name": "Set.OrdConnected.apply_covBy_apply_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Cover.lean", "def_pos": [362, 9], "def_end_pos": [362, 47]}, {"full_name": "OrderEmbedding.subtype", "def_path": ".lake/packages/mathlib/Mathlib/Order/Hom/Basic.lean", "def_pos": [726, 5], "def_end_pos": [726, 12]}, {"full_name": "Iff.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [808, 9], "def_end_pos": [808, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na\u271d b : \u03b1\na : \u2191(Iic b)\n\u22a2 a \u22d6 \u22a4 \u2194 \u2191a \u22d6 b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na\u271d b : \u03b1\na : \u2191(Iic b)\n\u22a2 OrdConnected (range \u21d1(OrderEmbedding.subtype fun c => c \u2264 b))"}, {"tactic": "simpa only [OrderEmbedding.subtype_apply, Subtype.range_coe_subtype] using Set.ordConnected_Iic", "annotated_tactic": ["simpa only [<a>OrderEmbedding.subtype_apply</a>, <a>Subtype.range_coe_subtype</a>] using <a>Set.ordConnected_Iic</a>", [{"full_name": "OrderEmbedding.subtype_apply", "def_path": ".lake/packages/mathlib/Mathlib/Order/Hom/Basic.lean", "def_pos": [725, 3], "def_end_pos": [725, 27]}, {"full_name": "Subtype.range_coe_subtype", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1385, 9], "def_end_pos": [1385, 26]}, {"full_name": "Set.ordConnected_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/OrdConnected.lean", "def_pos": [192, 9], "def_end_pos": [192, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na\u271d b : \u03b1\na : \u2191(Iic b)\n\u22a2 OrdConnected (range \u21d1(OrderEmbedding.subtype fun c => c \u2264 b))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "iteratedFDeriv_succ_apply_left", "start": [1550, 1], "end": [1553, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.card_subtype", "start": [878, 1], "end": [881, 7], "traced_tactics": [{"tactic": "refine' Fintype.card_of_subtype _ _", "annotated_tactic": ["refine' <a>Fintype.card_of_subtype</a> _ _", [{"full_name": "Fintype.card_of_subtype", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [124, 9], "def_end_pos": [124, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 card { x // p x } = (filter p univ).card", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 \u2200 (x : \u03b1), x \u2208 filter p univ \u2194 p x"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 \u2200 (x : \u03b1), x \u2208 filter p univ \u2194 p x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "full_name": "MulAut.conjNormal_apply", "start": [347, 1], "end": [349, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/RelIso/Basic.lean", "full_name": "RelEmbedding.coe_mk", "start": [274, 1], "end": [275, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Perfect.lean", "full_name": "coe_iterateFrobeniusEquiv", "start": [92, 1], "end": [92, 99], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/InfiniteSum.lean", "full_name": "Summable.of_norm_bounded_eventually", "start": [163, 1], "end": [165, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Defs.lean", "full_name": "Nat.succ_succ_ne_one", "start": [61, 1], "end": [61, 60], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "a b c d m n\u271d k : \u2115\np q : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 succ (succ n) \u2260 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.zero_mul_subset", "start": [1209, 1], "end": [1209, 84], "traced_tactics": [{"tactic": "simp [subset_iff, mem_mul]", "annotated_tactic": ["simp [<a>subset_iff</a>, <a>mem_mul</a>]", [{"full_name": "Finset.subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [376, 9], "def_end_pos": [376, 19]}, {"full_name": "Finset.mem_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Pointwise.lean", "def_pos": [375, 9], "def_end_pos": [375, 16]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : MulZeroClass \u03b1\ns\u271d t s : Finset \u03b1\n\u22a2 0 * s \u2286 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.preimage_setOf_eq", "start": [106, 1], "end": [107, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Pow.lean", "full_name": "derivWithin_pow'", "start": [105, 1], "end": [107, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Prod.lean", "full_name": "Prod.swap_inv", "start": [154, 1], "end": [155, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "full_name": "Summable.map_iff_of_leftInverse", "start": [183, 11], "end": [189, 70], "traced_tactics": [{"tactic": "have := h.map _ hg'", "annotated_tactic": ["have := h.map _ hg'", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\nf g\u271d : \u03b2 \u2192 \u03b1\na b : \u03b1\ns : Finset \u03b2\ninst\u271d\u2075 : AddCommMonoid \u03b3\ninst\u271d\u2074 : TopologicalSpace \u03b3\nG : Type u_5\nG' : Type u_6\ninst\u271d\u00b3 : FunLike G \u03b1 \u03b3\ninst\u271d\u00b2 : AddMonoidHomClass G \u03b1 \u03b3\ninst\u271d\u00b9 : FunLike G' \u03b3 \u03b1\ninst\u271d : AddMonoidHomClass G' \u03b3 \u03b1\ng : G\ng' : G'\nhg : Continuous \u21d1g\nhg' : Continuous \u21d1g'\nhinv : LeftInverse \u21d1g' \u21d1g\nh : Summable (\u21d1g \u2218 f)\n\u22a2 Summable f", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\nf g\u271d : \u03b2 \u2192 \u03b1\na b : \u03b1\ns : Finset \u03b2\ninst\u271d\u2075 : AddCommMonoid \u03b3\ninst\u271d\u2074 : TopologicalSpace \u03b3\nG : Type u_5\nG' : Type u_6\ninst\u271d\u00b3 : FunLike G \u03b1 \u03b3\ninst\u271d\u00b2 : AddMonoidHomClass G \u03b1 \u03b3\ninst\u271d\u00b9 : FunLike G' \u03b3 \u03b1\ninst\u271d : AddMonoidHomClass G' \u03b3 \u03b1\ng : G\ng' : G'\nhg : Continuous \u21d1g\nhg' : Continuous \u21d1g'\nhinv : LeftInverse \u21d1g' \u21d1g\nh : Summable (\u21d1g \u2218 f)\nthis : Summable (\u21d1g' \u2218 \u21d1g \u2218 f)\n\u22a2 Summable f"}, {"tactic": "rwa [\u2190 Function.comp.assoc, hinv.id] at this", "annotated_tactic": ["rwa [\u2190 <a>Function.comp.assoc</a>, hinv.id] at this", [{"full_name": "Function.comp.assoc", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [103, 9], "def_end_pos": [103, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\nf g\u271d : \u03b2 \u2192 \u03b1\na b : \u03b1\ns : Finset \u03b2\ninst\u271d\u2075 : AddCommMonoid \u03b3\ninst\u271d\u2074 : TopologicalSpace \u03b3\nG : Type u_5\nG' : Type u_6\ninst\u271d\u00b3 : FunLike G \u03b1 \u03b3\ninst\u271d\u00b2 : AddMonoidHomClass G \u03b1 \u03b3\ninst\u271d\u00b9 : FunLike G' \u03b3 \u03b1\ninst\u271d : AddMonoidHomClass G' \u03b3 \u03b1\ng : G\ng' : G'\nhg : Continuous \u21d1g\nhg' : Continuous \u21d1g'\nhinv : LeftInverse \u21d1g' \u21d1g\nh : Summable (\u21d1g \u2218 f)\nthis : Summable (\u21d1g' \u2218 \u21d1g \u2218 f)\n\u22a2 Summable f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rat/Cast/Order.lean", "full_name": "Rat.preimage_cast_Iio", "start": [136, 1], "end": [137, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.card_disjUnion", "start": [441, 1], "end": [442, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.univ_pi_update", "start": [892, 1], "end": [895, 62], "traced_tactics": [{"tactic": "rw [compl_eq_univ_diff, \u2190 pi_update_of_mem (mem_univ _)]", "annotated_tactic": ["rw [<a>compl_eq_univ_diff</a>, \u2190 <a>pi_update_of_mem</a> (<a>mem_univ</a> _)]", [{"full_name": "Set.compl_eq_univ_diff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1886, 9], "def_end_pos": [1886, 27]}, {"full_name": "Set.pi_update_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [882, 9], "def_end_pos": [882, 25]}, {"full_name": "Set.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [82, 29], "def_end_pos": [82, 37]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2\u271d : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt\u271d t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni\u271d : \u03b9\ninst\u271d : DecidableEq \u03b9\n\u03b2 : \u03b9 \u2192 Type u_4\ni : \u03b9\nf : (j : \u03b9) \u2192 \u03b1 j\na : \u03b1 i\nt : (j : \u03b9) \u2192 \u03b1 j \u2192 Set (\u03b2 j)\n\u22a2 (pi univ fun j => t j (update f i a j)) = {x | x i \u2208 t i a} \u2229 pi {i}\u1d9c fun j => t j (f j)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "isClosed_univ", "start": [178, 9], "end": [178, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Types.lean", "full_name": "CategoryTheory.uliftFunctor_map", "start": [223, 1], "end": [225, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.foldl_map'", "start": [2465, 1], "end": [2470, 16], "traced_tactics": [{"tactic": "induction l generalizing a", "annotated_tactic": ["induction l generalizing a", []], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 \u03b2 : Type u\ng : \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nf' : \u03b2 \u2192 \u03b2 \u2192 \u03b2\na : \u03b1\nl : List \u03b1\nh : \u2200 (x y : \u03b1), f' (g x) (g y) = g (f x y)\n\u22a2 foldl f' (g a) (map g l) = g (foldl f a l)", "state_after": "case nil\n\u03b9 : Type u_1\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 \u03b2 : Type u\ng : \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nf' : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nh : \u2200 (x y : \u03b1), f' (g x) (g y) = g (f x y)\na : \u03b1\n\u22a2 foldl f' (g a) (map g []) = g (foldl f a [])\n\ncase cons\n\u03b9 : Type u_1\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 \u03b2 : Type u\ng : \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nf' : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nh : \u2200 (x y : \u03b1), f' (g x) (g y) = g (f x y)\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : \u2200 (a : \u03b1), foldl f' (g a) (map g tail\u271d) = g (foldl f a tail\u271d)\na : \u03b1\n\u22a2 foldl f' (g a) (map g (head\u271d :: tail\u271d)) = g (foldl f a (head\u271d :: tail\u271d))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 \u03b2 : Type u\ng : \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nf' : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nh : \u2200 (x y : \u03b1), f' (g x) (g y) = g (f x y)\na : \u03b1\n\u22a2 foldl f' (g a) (map g []) = g (foldl f a [])", "state_after": "no goals"}, {"tactic": "simp [*, h]", "annotated_tactic": ["simp [*, h]", []], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 \u03b2 : Type u\ng : \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nf' : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nh : \u2200 (x y : \u03b1), f' (g x) (g y) = g (f x y)\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : \u2200 (a : \u03b1), foldl f' (g a) (map g tail\u271d) = g (foldl f a tail\u271d)\na : \u03b1\n\u22a2 foldl f' (g a) (map g (head\u271d :: tail\u271d)) = g (foldl f a (head\u271d :: tail\u271d))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Finiteness.lean", "full_name": "IsNoetherian.iff_fg", "start": [108, 1], "end": [117, 67], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "K : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\n\u22a2 IsNoetherian K V \u2194 Module.Finite K V", "state_after": "case mp\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\n\u22a2 IsNoetherian K V \u2192 Module.Finite K V\n\ncase mpr\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\n\u22a2 Module.Finite K V \u2192 IsNoetherian K V"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mp\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\n\u22a2 IsNoetherian K V \u2192 Module.Finite K V", "state_after": "case mp\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nh : IsNoetherian K V\n\u22a2 Module.Finite K V"}, {"tactic": "exact\n  \u27e8\u27e8finsetBasisIndex K V, by\n      convert (finsetBasis K V).span_eq\n      simp\u27e9\u27e9", "annotated_tactic": ["exact\n      \u27e8\u27e8<a>finsetBasisIndex</a> K V, by\n          convert (<a>finsetBasis</a> K V).<a>span_eq</a>\n          simp\u27e9\u27e9", [{"full_name": "IsNoetherian.finsetBasisIndex", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finiteness.lean", "def_pos": [74, 19], "def_end_pos": [74, 35]}, {"full_name": "IsNoetherian.finsetBasis", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finiteness.lean", "def_pos": [95, 19], "def_end_pos": [95, 30]}, {"full_name": "Basis.span_eq", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [573, 19], "def_end_pos": [573, 26]}]], "state_before": "case mp\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nh : IsNoetherian K V\n\u22a2 Module.Finite K V", "state_after": "no goals"}, {"tactic": "convert (finsetBasis K V).span_eq", "annotated_tactic": ["convert (<a>finsetBasis</a> K V).<a>span_eq</a>", [{"full_name": "IsNoetherian.finsetBasis", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finiteness.lean", "def_pos": [95, 19], "def_end_pos": [95, 30]}, {"full_name": "Basis.span_eq", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [573, 19], "def_end_pos": [573, 26]}]], "state_before": "K : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nh : IsNoetherian K V\n\u22a2 span K \u2191(finsetBasisIndex K V) = \u22a4", "state_after": "case h.e'_2.h.e'_6\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nh : IsNoetherian K V\n\u22a2 \u2191(finsetBasisIndex K V) = Set.range \u21d1(finsetBasis K V)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.e'_2.h.e'_6\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nh : IsNoetherian K V\n\u22a2 \u2191(finsetBasisIndex K V) = Set.range \u21d1(finsetBasis K V)", "state_after": "no goals"}, {"tactic": "rintro \u27e8s, hs\u27e9", "annotated_tactic": ["rintro \u27e8s, hs\u27e9", []], "state_before": "case mpr\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\n\u22a2 Module.Finite K V \u2192 IsNoetherian K V", "state_after": "case mpr.mk.intro\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Finset V\nhs : span K \u2191s = \u22a4\n\u22a2 IsNoetherian K V"}, {"tactic": "rw [IsNoetherian.iff_rank_lt_aleph0, \u2190 rank_top, \u2190 hs]", "annotated_tactic": ["rw [<a>IsNoetherian.iff_rank_lt_aleph0</a>, \u2190 <a>rank_top</a>, \u2190 hs]", [{"full_name": "IsNoetherian.iff_rank_lt_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finiteness.lean", "def_pos": [32, 9], "def_end_pos": [32, 27]}, {"full_name": "rank_top", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Basic.lean", "def_pos": [328, 9], "def_end_pos": [328, 17]}]], "state_before": "case mpr.mk.intro\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Finset V\nhs : span K \u2191s = \u22a4\n\u22a2 IsNoetherian K V", "state_after": "case mpr.mk.intro\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Finset V\nhs : span K \u2191s = \u22a4\n\u22a2 Module.rank K \u21a5(span K \u2191s) < \u2135\u2080"}, {"tactic": "exact lt_of_le_of_lt (rank_span_le _) s.finite_toSet.lt_aleph0", "annotated_tactic": ["exact <a>lt_of_le_of_lt</a> (<a>rank_span_le</a> _) s.finite_toSet.lt_aleph0", [{"full_name": "lt_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}, {"full_name": "rank_span_le", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "def_pos": [429, 9], "def_end_pos": [429, 21]}]], "state_before": "case mpr.mk.intro\nK : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Finset V\nhs : span K \u2191s = \u22a4\n\u22a2 Module.rank K \u21a5(span K \u2191s) < \u2135\u2080", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.lintegral_congr", "start": [309, 1], "end": [310, 16], "traced_tactics": [{"tactic": "simp only [h]", "annotated_tactic": ["simp only [h]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf g : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2200 (a : \u03b1), f a = g a\n\u22a2 \u222b\u207b (a : \u03b1), f a \u2202\u03bc = \u222b\u207b (a : \u03b1), g a \u2202\u03bc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.coe_ofNat_eq_mod", "start": [1664, 1], "end": [1666, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.domLCongr_trans", "start": [907, 1], "end": [910, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.iUnion_vsub_left_image", "start": [715, 1], "end": [716, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Hom.lean", "full_name": "DistribMulActionHom.map_smul", "start": [336, 11], "end": [337, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecificLimits/Basic.lean", "full_name": "tendsto_nat_ceil_atTop", "start": [646, 1], "end": [649, 40], "traced_tactics": [{"tactic": "refine Nat.ceil_mono.tendsto_atTop_atTop (fun x \u21a6 \u27e8x, ?_\u27e9)", "annotated_tactic": ["refine Nat.ceil_mono.tendsto_atTop_atTop (fun x \u21a6 \u27e8x, ?_\u27e9)", []], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\n\u22a2 Tendsto (fun x => \u2308x\u2309\u208a) atTop atTop", "state_after": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\nx : \u2115\n\u22a2 x \u2264 \u2308\u2191x\u2309\u208a"}, {"tactic": "simp only [Nat.ceil_natCast, le_refl]", "annotated_tactic": ["simp only [<a>Nat.ceil_natCast</a>, <a>le_refl</a>]", [{"full_name": "Nat.ceil_natCast", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [317, 9], "def_end_pos": [317, 21]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\nx : \u2115\n\u22a2 x \u2264 \u2308\u2191x\u2309\u208a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.convex_closedBall", "start": [1104, 1], "end": [1106, 52], "traced_tactics": [{"tactic": "rw [closedBall_eq_biInter_ball]", "annotated_tactic": ["rw [<a>closedBall_eq_biInter_ball</a>]", [{"full_name": "Seminorm.closedBall_eq_biInter_ball", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [708, 9], "def_end_pos": [708, 35]}]], "state_before": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d \ud835\udd5c\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Module \u211d E\ninst\u271d : IsScalarTower \u211d \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\n\u22a2 Convex \u211d (closedBall p x r)", "state_after": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d \ud835\udd5c\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Module \u211d E\ninst\u271d : IsScalarTower \u211d \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\n\u22a2 Convex \u211d (\u22c2 \u03c1, \u22c2 (_ : \u03c1 > r), ball p x \u03c1)"}, {"tactic": "exact convex_iInter\u2082 fun _ _ => convex_ball _ _ _", "annotated_tactic": ["exact <a>convex_iInter\u2082</a> fun _ _ => <a>convex_ball</a> _ _ _", [{"full_name": "convex_iInter\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Convex/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 23]}, {"full_name": "Seminorm.convex_ball", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [1096, 9], "def_end_pos": [1096, 20]}]], "state_before": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d \ud835\udd5c\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Module \u211d E\ninst\u271d : IsScalarTower \u211d \ud835\udd5c E\np : Seminorm \ud835\udd5c E\nx : E\nr : \u211d\n\u22a2 Convex \u211d (\u22c2 \u03c1, \u22c2 (_ : \u03c1 > r), ball p x \u03c1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Equivalence.lean", "full_name": "CategoryTheory.Functor.inv_inv", "start": [558, 1], "end": [559, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean", "full_name": "range_pow_padicValNat_subset_divisors'", "start": [634, 1], "end": [643, 62], "traced_tactics": [{"tactic": "rcases eq_or_ne n 0 with (rfl | hn)", "annotated_tactic": ["rcases <a>eq_or_ne</a> n 0 with (rfl | hn)", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "p n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Finset.image (fun t => p ^ (t + 1)) (Finset.range (padicValNat p n)) \u2286 Finset.erase (divisors n) 1", "state_after": "case inl\np : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Finset.image (fun t => p ^ (t + 1)) (Finset.range (padicValNat p 0)) \u2286 Finset.erase (divisors 0) 1\n\ncase inr\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\n\u22a2 Finset.image (fun t => p ^ (t + 1)) (Finset.range (padicValNat p n)) \u2286 Finset.erase (divisors n) 1"}, {"tactic": "intro t ht", "annotated_tactic": ["intro t ht", []], "state_before": "case inr\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\n\u22a2 Finset.image (fun t => p ^ (t + 1)) (Finset.range (padicValNat p n)) \u2286 Finset.erase (divisors n) 1", "state_after": "case inr\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nt : \u2115\nht : t \u2208 Finset.image (fun t => p ^ (t + 1)) (Finset.range (padicValNat p n))\n\u22a2 t \u2208 Finset.erase (divisors n) 1"}, {"tactic": "simp only [exists_prop, Finset.mem_image, Finset.mem_range] at ht", "annotated_tactic": ["simp only [<a>exists_prop</a>, <a>Finset.mem_image</a>, <a>Finset.mem_range</a>] at ht", [{"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}, {"full_name": "Finset.mem_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3127, 9], "def_end_pos": [3127, 18]}]], "state_before": "case inr\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nt : \u2115\nht : t \u2208 Finset.image (fun t => p ^ (t + 1)) (Finset.range (padicValNat p n))\n\u22a2 t \u2208 Finset.erase (divisors n) 1", "state_after": "case inr\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nt : \u2115\nht : \u2203 a < padicValNat p n, p ^ (a + 1) = t\n\u22a2 t \u2208 Finset.erase (divisors n) 1"}, {"tactic": "obtain \u27e8k, hk, rfl\u27e9 := ht", "annotated_tactic": ["obtain \u27e8k, hk, rfl\u27e9 := ht", []], "state_before": "case inr\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nt : \u2115\nht : \u2203 a < padicValNat p n, p ^ (a + 1) = t\n\u22a2 t \u2208 Finset.erase (divisors n) 1", "state_after": "case inr.intro.intro\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nk : \u2115\nhk : k < padicValNat p n\n\u22a2 p ^ (k + 1) \u2208 Finset.erase (divisors n) 1"}, {"tactic": "rw [Finset.mem_erase, Nat.mem_divisors]", "annotated_tactic": ["rw [<a>Finset.mem_erase</a>, <a>Nat.mem_divisors</a>]", [{"full_name": "Finset.mem_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1922, 9], "def_end_pos": [1922, 18]}, {"full_name": "Nat.mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [96, 9], "def_end_pos": [96, 21]}]], "state_before": "case inr.intro.intro\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nk : \u2115\nhk : k < padicValNat p n\n\u22a2 p ^ (k + 1) \u2208 Finset.erase (divisors n) 1", "state_after": "case inr.intro.intro\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nk : \u2115\nhk : k < padicValNat p n\n\u22a2 p ^ (k + 1) \u2260 1 \u2227 p ^ (k + 1) \u2223 n \u2227 n \u2260 0"}, {"tactic": "refine' \u27e8_, (pow_dvd_pow p <| succ_le_iff.2 hk).trans pow_padicValNat_dvd, hn\u27e9", "annotated_tactic": ["refine' \u27e8_, (<a>pow_dvd_pow</a> p <| <a>succ_le_iff</a>.2 hk).<a>trans</a> <a>pow_padicValNat_dvd</a>, hn\u27e9", [{"full_name": "pow_dvd_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [156, 7], "def_end_pos": [156, 18]}, {"full_name": "Nat.succ_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [81, 7], "def_end_pos": [81, 18]}, {"full_name": "Dvd.dvd.trans", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [75, 7], "def_end_pos": [75, 20]}, {"full_name": "pow_padicValNat_dvd", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [558, 9], "def_end_pos": [558, 28]}]], "state_before": "case inr.intro.intro\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nk : \u2115\nhk : k < padicValNat p n\n\u22a2 p ^ (k + 1) \u2260 1 \u2227 p ^ (k + 1) \u2223 n \u2227 n \u2260 0", "state_after": "case inr.intro.intro\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nk : \u2115\nhk : k < padicValNat p n\n\u22a2 p ^ (k + 1) \u2260 1"}, {"tactic": "exact (Nat.one_lt_pow _ _ k.succ_ne_zero hp.out.one_lt).ne'", "annotated_tactic": ["exact (<a>Nat.one_lt_pow</a> _ _ k.succ_ne_zero hp.out.one_lt).<a>ne'</a>", [{"full_name": "Nat.one_lt_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Pow.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}, {"full_name": "LT.lt.ne'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 12]}]], "state_before": "case inr.intro.intro\np n : \u2115\nhp : Fact (Nat.Prime p)\nhn : n \u2260 0\nk : \u2115\nhk : k < padicValNat p n\n\u22a2 p ^ (k + 1) \u2260 1", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inl\np : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 Finset.image (fun t => p ^ (t + 1)) (Finset.range (padicValNat p 0)) \u2286 Finset.erase (divisors 0) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "full_name": "affineIndependent_of_ne_of_mem_of_mem_of_not_mem", "start": [699, 1], "end": [712, 63], "traced_tactics": [{"tactic": "have ha : AffineIndependent k fun x : { x : Fin 3 // x \u2260 2 } => ![p\u2081, p\u2082, p\u2083] x := by\n  rw [\u2190 affineIndependent_equiv (finSuccAboveEquiv (2 : Fin 3)).toEquiv]\n  convert affineIndependent_of_ne k hp\u2081p\u2082\n  ext x\n  fin_cases x <;> rfl", "annotated_tactic": ["have ha : <a>AffineIndependent</a> k fun x : { x : <a>Fin</a> 3 // x \u2260 2 } => ![p\u2081, p\u2082, p\u2083] x := by\n    rw [\u2190 <a>affineIndependent_equiv</a> (<a>finSuccAboveEquiv</a> (2 : <a>Fin</a> 3)).toEquiv]\n    convert <a>affineIndependent_of_ne</a> k hp\u2081p\u2082\n    ext x\n    fin_cases x <;> rfl", [{"full_name": "AffineIndependent", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "def_pos": [51, 5], "def_end_pos": [51, 22]}, {"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}, {"full_name": "affineIndependent_equiv", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "def_pos": [326, 9], "def_end_pos": [326, 32]}, {"full_name": "finSuccAboveEquiv", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Fin.lean", "def_pos": [240, 5], "def_end_pos": [240, 22]}, {"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}, {"full_name": "affineIndependent_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "def_pos": [633, 9], "def_end_pos": [633, 32]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\n\u22a2 AffineIndependent k ![p\u2081, p\u2082, p\u2083]", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\n\u22a2 AffineIndependent k ![p\u2081, p\u2082, p\u2083]"}, {"tactic": "refine' ha.affineIndependent_of_not_mem_span _", "annotated_tactic": ["refine' ha.affineIndependent_of_not_mem_span _", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\n\u22a2 AffineIndependent k ![p\u2081, p\u2082, p\u2083]", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\n\u22a2 ![p\u2081, p\u2082, p\u2083] 2 \u2209 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\n\u22a2 ![p\u2081, p\u2082, p\u2083] 2 \u2209 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\nh : ![p\u2081, p\u2082, p\u2083] 2 \u2208 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})\n\u22a2 False"}, {"tactic": "refine' hp\u2083 ((AffineSubspace.le_def' _ s).1 _ p\u2083 h)", "annotated_tactic": ["refine' hp\u2083 ((<a>AffineSubspace.le_def'</a> _ s).1 _ p\u2083 h)", [{"full_name": "AffineSubspace.le_def'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [632, 9], "def_end_pos": [632, 16]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\nh : ![p\u2081, p\u2082, p\u2083] 2 \u2208 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})\n\u22a2 False", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\nh : ![p\u2081, p\u2082, p\u2083] 2 \u2208 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})\n\u22a2 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2}) \u2264 s"}, {"tactic": "simp_rw [affineSpan_le, Set.image_subset_iff, Set.subset_def, Set.mem_preimage]", "annotated_tactic": ["simp_rw [<a>affineSpan_le</a>, <a>Set.image_subset_iff</a>, <a>Set.subset_def</a>, <a>Set.mem_preimage</a>]", [{"full_name": "affineSpan_le", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [700, 9], "def_end_pos": [700, 29]}, {"full_name": "Set.image_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [480, 9], "def_end_pos": [480, 25]}, {"full_name": "Set.subset_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [326, 9], "def_end_pos": [326, 19]}, {"full_name": "Set.mem_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 21]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\nh : ![p\u2081, p\u2082, p\u2083] 2 \u2208 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})\n\u22a2 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2}) \u2264 s", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\nh : ![p\u2081, p\u2082, p\u2083] 2 \u2208 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})\n\u22a2 \u2200 x \u2208 {x | x \u2260 2}, ![p\u2081, p\u2082, p\u2083] x \u2208 \u2191s"}, {"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\nh : ![p\u2081, p\u2082, p\u2083] 2 \u2208 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})\n\u22a2 \u2200 x \u2208 {x | x \u2260 2}, ![p\u2081, p\u2082, p\u2083] x \u2208 \u2191s", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\nh : ![p\u2081, p\u2082, p\u2083] 2 \u2208 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})\nx : Fin 3\n\u22a2 x \u2208 {x | x \u2260 2} \u2192 ![p\u2081, p\u2082, p\u2083] x \u2208 \u2191s"}, {"tactic": "fin_cases x <;> simp (config := {decide := true}) [hp\u2081, hp\u2082]", "annotated_tactic": ["fin_cases x <;> simp (config := {decide := <a>true</a>}) [hp\u2081, hp\u2082]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nha : AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x\nh : ![p\u2081, p\u2082, p\u2083] 2 \u2208 affineSpan k (![p\u2081, p\u2082, p\u2083] '' {x | x \u2260 2})\nx : Fin 3\n\u22a2 x \u2208 {x | x \u2260 2} \u2192 ![p\u2081, p\u2082, p\u2083] x \u2208 \u2191s", "state_after": "no goals"}, {"tactic": "rw [\u2190 affineIndependent_equiv (finSuccAboveEquiv (2 : Fin 3)).toEquiv]", "annotated_tactic": ["rw [\u2190 <a>affineIndependent_equiv</a> (<a>finSuccAboveEquiv</a> (2 : <a>Fin</a> 3)).toEquiv]", [{"full_name": "affineIndependent_equiv", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "def_pos": [326, 9], "def_end_pos": [326, 32]}, {"full_name": "finSuccAboveEquiv", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Fin.lean", "def_pos": [240, 5], "def_end_pos": [240, 22]}, {"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\n\u22a2 AffineIndependent k fun x => ![p\u2081, p\u2082, p\u2083] \u2191x", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\n\u22a2 AffineIndependent k ((fun x => ![p\u2081, p\u2082, p\u2083] \u2191x) \u2218 \u21d1(finSuccAboveEquiv 2).toEquiv)"}, {"tactic": "convert affineIndependent_of_ne k hp\u2081p\u2082", "annotated_tactic": ["convert <a>affineIndependent_of_ne</a> k hp\u2081p\u2082", [{"full_name": "affineIndependent_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "def_pos": [633, 9], "def_end_pos": [633, 32]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\n\u22a2 AffineIndependent k ((fun x => ![p\u2081, p\u2082, p\u2083] \u2191x) \u2218 \u21d1(finSuccAboveEquiv 2).toEquiv)", "state_after": "case h.e'_9\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\n\u22a2 (fun x => ![p\u2081, p\u2082, p\u2083] \u2191x) \u2218 \u21d1(finSuccAboveEquiv 2).toEquiv = ![p\u2081, p\u2082]"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "case h.e'_9\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\n\u22a2 (fun x => ![p\u2081, p\u2082, p\u2083] \u2191x) \u2218 \u21d1(finSuccAboveEquiv 2).toEquiv = ![p\u2081, p\u2082]", "state_after": "case h.e'_9.h\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nx : Fin 2\n\u22a2 ((fun x => ![p\u2081, p\u2082, p\u2083] \u2191x) \u2218 \u21d1(finSuccAboveEquiv 2).toEquiv) x = ![p\u2081, p\u2082] x"}, {"tactic": "fin_cases x <;> rfl", "annotated_tactic": ["fin_cases x <;> rfl", []], "state_before": "case h.e'_9.h\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : AffineSubspace k P\np\u2081 p\u2082 p\u2083 : P\nhp\u2081p\u2082 : p\u2081 \u2260 p\u2082\nhp\u2081 : p\u2081 \u2208 s\nhp\u2082 : p\u2082 \u2208 s\nhp\u2083 : p\u2083 \u2209 s\nx : Fin 2\n\u22a2 ((fun x => ![p\u2081, p\u2082, p\u2083] \u2191x) \u2218 \u21d1(finSuccAboveEquiv 2).toEquiv) x = ![p\u2081, p\u2082] x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Abs.lean", "full_name": "abs_le_iff_mul_self_le", "start": [91, 1], "end": [93, 63], "traced_tactics": [{"tactic": "rw [\u2190 abs_mul_abs_self, \u2190 abs_mul_abs_self b]", "annotated_tactic": ["rw [\u2190 <a>abs_mul_abs_self</a>, \u2190 <a>abs_mul_abs_self</a> b]", [{"full_name": "abs_mul_abs_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Abs.lean", "def_pos": [73, 15], "def_end_pos": [73, 31]}, {"full_name": "abs_mul_abs_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Abs.lean", "def_pos": [73, 15], "def_end_pos": [73, 31]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedRing \u03b1\nn : \u2115\na b c : \u03b1\n\u22a2 |a| \u2264 |b| \u2194 a * a \u2264 b * b", "state_after": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedRing \u03b1\nn : \u2115\na b c : \u03b1\n\u22a2 |a| \u2264 |b| \u2194 |a| * |a| \u2264 |b| * |b|"}, {"tactic": "exact mul_self_le_mul_self_iff (abs_nonneg a) (abs_nonneg b)", "annotated_tactic": ["exact <a>mul_self_le_mul_self_iff</a> (<a>abs_nonneg</a> a) (<a>abs_nonneg</a> b)", [{"full_name": "mul_self_le_mul_self_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [1051, 9], "def_end_pos": [1051, 33]}, {"full_name": "abs_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [121, 30], "def_end_pos": [121, 40]}, {"full_name": "abs_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [121, 30], "def_end_pos": [121, 40]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedRing \u03b1\nn : \u2115\na b c : \u03b1\n\u22a2 |a| \u2264 |b| \u2194 |a| * |a| \u2264 |b| * |b|", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/Subalgebra.lean", "full_name": "Subalgebra.star_mono", "start": [368, 1], "end": [368, 96], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Sets/Opens.lean", "full_name": "TopologicalSpace.Opens.openEmbedding_of_le", "start": [266, 1], "end": [271, 55], "traced_tactics": [{"tactic": "rw [Set.range_inclusion i]", "annotated_tactic": ["rw [<a>Set.range_inclusion</a> i]", [{"full_name": "Set.range_inclusion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1118, 9], "def_end_pos": [1118, 24]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : TopologicalSpace \u03b3\nU V : Opens \u03b1\ni : U \u2264 V\n\u22a2 IsOpen (range (inclusion \u22ef))", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : TopologicalSpace \u03b3\nU V : Opens \u03b1\ni : U \u2264 V\n\u22a2 IsOpen {x | \u2191x \u2208 \u2191U}"}, {"tactic": "exact U.isOpen.preimage continuous_subtype_val", "annotated_tactic": ["exact U.isOpen.preimage <a>continuous_subtype_val</a>", [{"full_name": "continuous_subtype_val", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [1068, 9], "def_end_pos": [1068, 31]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : TopologicalSpace \u03b3\nU V : Opens \u03b1\ni : U \u2264 V\n\u22a2 IsOpen {x | \u2191x \u2208 \u2191U}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/OrderClosed.lean", "full_name": "Dense.Iio_eq_biUnion", "start": [937, 1], "end": [939, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/Basic.lean", "full_name": "CategoryTheory.Comma.id_left", "start": [117, 1], "end": [118, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Intervals.lean", "full_name": "Finset.mul_prod_Ioi_eq_prod_Ici", "start": [51, 1], "end": [53, 34], "traced_tactics": [{"tactic": "rw [Ici_eq_cons_Ioi, prod_cons]", "annotated_tactic": ["rw [<a>Ici_eq_cons_Ioi</a>, <a>prod_cons</a>]", [{"full_name": "Finset.Ici_eq_cons_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/LocallyFinite/Basic.lean", "def_pos": [708, 9], "def_end_pos": [708, 24]}, {"full_name": "Finset.prod_cons", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [306, 9], "def_end_pos": [306, 18]}]], "state_before": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : CommMonoid M\nf : \u03b1 \u2192 M\na\u271d b : \u03b1\ninst\u271d : LocallyFiniteOrderTop \u03b1\na : \u03b1\n\u22a2 f a * \u220f x in Ioi a, f x = \u220f x in Ici a, f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "bddBelow_range_pi", "start": [1636, 1], "end": [1638, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Homeomorph.lean", "full_name": "Homeomorph.isCompact_image", "start": [277, 1], "end": [278, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/Asymptotics.lean", "full_name": "ContinuousLinearMap.isBigO_id", "start": [32, 1], "end": [33, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.prod_sUnion", "start": [1787, 1], "end": [1788, 59], "traced_tactics": [{"tactic": "simp_rw [sUnion_eq_biUnion, biUnion_image, prod_iUnion\u2082]", "annotated_tactic": ["simp_rw [<a>sUnion_eq_biUnion</a>, <a>biUnion_image</a>, <a>prod_iUnion\u2082</a>]", [{"full_name": "Set.sUnion_eq_biUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1316, 9], "def_end_pos": [1316, 26]}, {"full_name": "Set.biUnion_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1711, 9], "def_end_pos": [1711, 22]}, {"full_name": "Set.prod_iUnion\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1781, 9], "def_end_pos": [1781, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ns : Set \u03b1\nC : Set (Set \u03b2)\n\u22a2 s \u00d7\u02e2 \u22c3\u2080 C = \u22c3\u2080 ((fun t => s \u00d7\u02e2 t) '' C)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "Subgroup.orderOf_dvd_natCard", "start": [1048, 1], "end": [1050, 77], "traced_tactics": [{"tactic": "simpa using orderOf_dvd_natCard (\u27e8x, hx\u27e9 : s)", "annotated_tactic": ["simpa using <a>orderOf_dvd_natCard</a> (\u27e8x, hx\u27e9 : s)", [{"full_name": "orderOf_dvd_natCard", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [1041, 9], "def_end_pos": [1041, 28]}]], "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Group G\ninst\u271d : Fintype G\nx : G\nn : \u2115\ns : Subgroup G\nhx : x \u2208 s\n\u22a2 orderOf x \u2223 Nat.card \u21a5s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/DMatrix.lean", "full_name": "DMatrix.map_apply", "start": [52, 1], "end": [53, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Basic.lean", "full_name": "pow_three", "start": [99, 1], "end": [99, 77], "traced_tactics": [{"tactic": "rw [pow_succ, pow_two]", "annotated_tactic": ["rw [<a>pow_succ</a>, <a>pow_two</a>]", [{"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}, {"full_name": "pow_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [86, 32], "def_end_pos": [86, 39]}]], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\n\u22a2 a ^ 3 = a * (a * a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Control/ULift.lean", "full_name": "ULift.bind_up", "start": [123, 1], "end": [124, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Tower.lean", "full_name": "Polynomial.aeval_algebraMap_apply", "start": [54, 1], "end": [56, 70], "traced_tactics": [{"tactic": "rw [aeval_def, aeval_def, hom_eval\u2082, \u2190 IsScalarTower.algebraMap_eq]", "annotated_tactic": ["rw [<a>aeval_def</a>, <a>aeval_def</a>, <a>hom_eval\u2082</a>, \u2190 <a>IsScalarTower.algebraMap_eq</a>]", [{"full_name": "Polynomial.aeval_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/AlgebraMap.lean", "def_pos": [192, 9], "def_end_pos": [192, 18]}, {"full_name": "Polynomial.aeval_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/AlgebraMap.lean", "def_pos": [192, 9], "def_end_pos": [192, 18]}, {"full_name": "Polynomial.hom_eval\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [1035, 9], "def_end_pos": [1035, 18]}, {"full_name": "IsScalarTower.algebraMap_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Tower.lean", "def_pos": [125, 9], "def_end_pos": [125, 22]}]], "state_before": "R : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Semiring B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R A B\nx : A\np : R[X]\n\u22a2 (aeval ((algebraMap A B) x)) p = (algebraMap A B) ((aeval x) p)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Denumerable.lean", "full_name": "Denumerable.prod_ofNat_val", "start": [173, 1], "end": [174, 10], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Denumerable \u03b1\ninst\u271d : Denumerable \u03b2\nn : \u2115\n\u22a2 ofNat (\u03b1 \u00d7 \u03b2) n = (ofNat \u03b1 (unpair n).1, ofNat \u03b2 (unpair n).2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean", "full_name": "real_inner_self_abs", "start": [595, 1], "end": [596, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean", "full_name": "padicValRat.div", "start": [372, 11], "end": [374, 94], "traced_tactics": [{"tactic": "rw [div_eq_mul_inv, padicValRat.mul hq (inv_ne_zero hr), padicValRat.inv r, sub_eq_add_neg]", "annotated_tactic": ["rw [<a>div_eq_mul_inv</a>, <a>padicValRat.mul</a> hq (<a>inv_ne_zero</a> hr), <a>padicValRat.inv</a> r, <a>sub_eq_add_neg</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "padicValRat.mul", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [342, 19], "def_end_pos": [342, 22]}, {"full_name": "inv_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NeZero.lean", "def_pos": [47, 9], "def_end_pos": [47, 20]}, {"full_name": "padicValRat.inv", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [364, 19], "def_end_pos": [364, 22]}, {"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}]], "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nq r : \u211a\nhq : q \u2260 0\nhr : r \u2260 0\n\u22a2 padicValRat p (q / r) = padicValRat p q - padicValRat p r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.inf_image", "start": [345, 1], "end": [347, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.map_snd'", "start": [79, 1], "end": [80, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/Constructions.lean", "full_name": "rank_matrix", "start": [188, 1], "end": [195, 21], "traced_tactics": [{"tactic": "cases nonempty_fintype m", "annotated_tactic": ["cases <a>nonempty_fintype</a> m", [{"full_name": "nonempty_fintype", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [442, 9], "def_end_pos": [442, 25]}]], "state_before": "R S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M\u2081\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R M'\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Free R M\ninst\u271d\u00b2 : Module.Free R M'\nm : Type v\nn : Type w\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\n\u22a2 Module.rank R (Matrix m n R) = lift.{max v w u, v} #m * lift.{max v w u, w} #n", "state_after": "case intro\nR S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M\u2081\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R M'\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Free R M\ninst\u271d\u00b2 : Module.Free R M'\nm : Type v\nn : Type w\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\nval\u271d : Fintype m\n\u22a2 Module.rank R (Matrix m n R) = lift.{max v w u, v} #m * lift.{max v w u, w} #n"}, {"tactic": "cases nonempty_fintype n", "annotated_tactic": ["cases <a>nonempty_fintype</a> n", [{"full_name": "nonempty_fintype", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [442, 9], "def_end_pos": [442, 25]}]], "state_before": "case intro\nR S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M\u2081\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R M'\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Free R M\ninst\u271d\u00b2 : Module.Free R M'\nm : Type v\nn : Type w\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\nval\u271d : Fintype m\n\u22a2 Module.rank R (Matrix m n R) = lift.{max v w u, v} #m * lift.{max v w u, w} #n", "state_after": "case intro.intro\nR S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M\u2081\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R M'\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Free R M\ninst\u271d\u00b2 : Module.Free R M'\nm : Type v\nn : Type w\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\nval\u271d\u00b9 : Fintype m\nval\u271d : Fintype n\n\u22a2 Module.rank R (Matrix m n R) = lift.{max v w u, v} #m * lift.{max v w u, w} #n"}, {"tactic": "have h := (Matrix.stdBasis R m n).mk_eq_rank", "annotated_tactic": ["have h := (<a>Matrix.stdBasis</a> R m n).<a>mk_eq_rank</a>", [{"full_name": "Matrix.stdBasis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [329, 19], "def_end_pos": [329, 27]}, {"full_name": "Basis.mk_eq_rank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "def_pos": [351, 9], "def_end_pos": [351, 25]}]], "state_before": "case intro.intro\nR S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M\u2081\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R M'\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Free R M\ninst\u271d\u00b2 : Module.Free R M'\nm : Type v\nn : Type w\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\nval\u271d\u00b9 : Fintype m\nval\u271d : Fintype n\n\u22a2 Module.rank R (Matrix m n R) = lift.{max v w u, v} #m * lift.{max v w u, w} #n", "state_after": "case intro.intro\nR S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M\u2081\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R M'\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Free R M\ninst\u271d\u00b2 : Module.Free R M'\nm : Type v\nn : Type w\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\nval\u271d\u00b9 : Fintype m\nval\u271d : Fintype n\nh : lift.{max (max u v) w, max v w} #(m \u00d7 n) = lift.{max v w, max (max u v) w} (Module.rank R (Matrix m n R))\n\u22a2 Module.rank R (Matrix m n R) = lift.{max v w u, v} #m * lift.{max v w u, w} #n"}, {"tactic": "rw [\u2190 lift_lift.{max v w u, max v w}, lift_inj] at h", "annotated_tactic": ["rw [\u2190 <a>lift_lift</a>.{max v w u, max v w}, <a>lift_inj</a>] at h", [{"full_name": "Cardinal.lift_lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [236, 9], "def_end_pos": [236, 18]}, {"full_name": "Cardinal.lift_inj", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [358, 9], "def_end_pos": [358, 17]}]], "state_before": "case intro.intro\nR S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M\u2081\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R M'\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Free R M\ninst\u271d\u00b2 : Module.Free R M'\nm : Type v\nn : Type w\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\nval\u271d\u00b9 : Fintype m\nval\u271d : Fintype n\nh : lift.{max (max u v) w, max v w} #(m \u00d7 n) = lift.{max v w, max (max u v) w} (Module.rank R (Matrix m n R))\n\u22a2 Module.rank R (Matrix m n R) = lift.{max v w u, v} #m * lift.{max v w u, w} #n", "state_after": "case intro.intro\nR S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M\u2081\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R M'\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Free R M\ninst\u271d\u00b2 : Module.Free R M'\nm : Type v\nn : Type w\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\nval\u271d\u00b9 : Fintype m\nval\u271d : Fintype n\nh : lift.{max v w u, max v w} #(m \u00d7 n) = Module.rank R (Matrix m n R)\n\u22a2 Module.rank R (Matrix m n R) = lift.{max v w u, v} #m * lift.{max v w u, w} #n"}, {"tactic": "simpa using h.symm", "annotated_tactic": ["simpa using h.symm", []], "state_before": "case intro.intro\nR S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M\u2081\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R M'\ninst\u271d\u2075 : Module R M\u2081\ninst\u271d\u2074 : StrongRankCondition R\ninst\u271d\u00b3 : Module.Free R M\ninst\u271d\u00b2 : Module.Free R M'\nm : Type v\nn : Type w\ninst\u271d\u00b9 : Finite m\ninst\u271d : Finite n\nval\u271d\u00b9 : Fintype m\nval\u271d : Fintype n\nh : lift.{max v w u, max v w} #(m \u00d7 n) = Module.rank R (Matrix m n R)\n\u22a2 Module.rank R (Matrix m n R) = lift.{max v w u, v} #m * lift.{max v w u, w} #n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "full_name": "PartialEquiv.map_source''", "start": [202, 1], "end": [204, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.IsLittleO.eventuallyLE", "start": [202, 1], "end": [203, 32], "traced_tactics": [{"tactic": "simpa using h.def zero_lt_one", "annotated_tactic": ["simpa using h.def <a>zero_lt_one</a>", [{"full_name": "zero_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\nh : f =o[l] g\n\u22a2 \u2200\u1da0 (x : \u03b1) in l, \u2016f x\u2016 \u2264 \u2016g x\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "ciInf_mono", "start": [823, 1], "end": [824, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/LegendreSymbol.lean", "full_name": "Mathlib.Meta.NormNum.LegendreSym.to_jacobiSym", "start": [92, 1], "end": [94, 51], "traced_tactics": [{"tactic": "rwa [@jacobiSym.legendreSym.to_jacobiSym p pp a]", "annotated_tactic": ["rwa [@<a>jacobiSym.legendreSym.to_jacobiSym</a> p pp a]", [{"full_name": "jacobiSym.legendreSym.to_jacobiSym", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "def_pos": [116, 9], "def_end_pos": [116, 33]}]], "state_before": "p : \u2115\npp : Fact (Nat.Prime p)\na r : \u2124\nhr : IsInt (jacobiSym a p) r\n\u22a2 IsInt (legendreSym p a) r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Units.coe_prod", "start": [2572, 1], "end": [2574, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/MonotoneConvergence.lean", "full_name": "Monotone.le_of_tendsto", "start": [269, 1], "end": [272, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Finite/Basic.lean", "full_name": "FiniteField.expand_card", "start": [390, 1], "end": [396, 76], "traced_tactics": [{"tactic": "cases' CharP.exists K with p hp", "annotated_tactic": ["cases' <a>CharP.exists</a> K with p hp", [{"full_name": "CharP.exists", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharP/Basic.lean", "def_pos": [192, 9], "def_end_pos": [192, 21]}]], "state_before": "K : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Algebra (ZMod p) K\nf : K[X]\n\u22a2 (expand K q) f = f ^ q", "state_after": "case intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp : CharP K p\n\u22a2 (expand K q) f = f ^ q"}, {"tactic": "letI := hp", "annotated_tactic": ["letI := hp", []], "state_before": "case intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp : CharP K p\n\u22a2 (expand K q) f = f ^ q", "state_after": "case intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp : CharP K p\nthis : CharP K p := hp\n\u22a2 (expand K q) f = f ^ q"}, {"tactic": "rcases FiniteField.card K p with \u27e8\u27e8n, npos\u27e9, \u27e8hp, hn\u27e9\u27e9", "annotated_tactic": ["rcases <a>FiniteField.card</a> K p with \u27e8\u27e8n, npos\u27e9, \u27e8hp, hn\u27e9\u27e9", [{"full_name": "FiniteField.card", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finite/Basic.lean", "def_pos": [245, 9], "def_end_pos": [245, 13]}]], "state_before": "case intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp : CharP K p\nthis : CharP K p := hp\n\u22a2 (expand K q) f = f ^ q", "state_after": "case intro.intro.mk.intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp\u271d : CharP K p\nthis : CharP K p := hp\u271d\nn : \u2115\nnpos : 0 < n\nhp : Nat.Prime p\nhn : q = p ^ \u2191{ val := n, property := npos }\n\u22a2 (expand K q) f = f ^ q"}, {"tactic": "haveI : Fact p.Prime := \u27e8hp\u27e9", "annotated_tactic": ["haveI : <a>Fact</a> p.Prime := \u27e8hp\u27e9", [{"full_name": "Fact", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [114, 7], "def_end_pos": [114, 11]}]], "state_before": "case intro.intro.mk.intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp\u271d : CharP K p\nthis : CharP K p := hp\u271d\nn : \u2115\nnpos : 0 < n\nhp : Nat.Prime p\nhn : q = p ^ \u2191{ val := n, property := npos }\n\u22a2 (expand K q) f = f ^ q", "state_after": "case intro.intro.mk.intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp\u271d : CharP K p\nthis\u271d : CharP K p := hp\u271d\nn : \u2115\nnpos : 0 < n\nhp : Nat.Prime p\nhn : q = p ^ \u2191{ val := n, property := npos }\nthis : Fact (Nat.Prime p)\n\u22a2 (expand K q) f = f ^ q"}, {"tactic": "dsimp at hn", "annotated_tactic": ["dsimp at hn", []], "state_before": "case intro.intro.mk.intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp\u271d : CharP K p\nthis\u271d : CharP K p := hp\u271d\nn : \u2115\nnpos : 0 < n\nhp : Nat.Prime p\nhn : q = p ^ \u2191{ val := n, property := npos }\nthis : Fact (Nat.Prime p)\n\u22a2 (expand K q) f = f ^ q", "state_after": "case intro.intro.mk.intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp\u271d : CharP K p\nthis\u271d : CharP K p := hp\u271d\nn : \u2115\nnpos : 0 < n\nhp : Nat.Prime p\nhn : q = p ^ n\nthis : Fact (Nat.Prime p)\n\u22a2 (expand K q) f = f ^ q"}, {"tactic": "rw [hn, \u2190 map_expand_pow_char, frobenius_pow hn, RingHom.one_def, map_id]", "annotated_tactic": ["rw [hn, \u2190 <a>map_expand_pow_char</a>, <a>frobenius_pow</a> hn, <a>RingHom.one_def</a>, <a>map_id</a>]", [{"full_name": "Polynomial.map_expand_pow_char", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Expand.lean", "def_pos": [271, 9], "def_end_pos": [271, 28]}, {"full_name": "FiniteField.frobenius_pow", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finite/Basic.lean", "def_pos": [379, 9], "def_end_pos": [379, 22]}, {"full_name": "RingHom.one_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [691, 9], "def_end_pos": [691, 16]}, {"full_name": "Polynomial.map_id", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [831, 9], "def_end_pos": [831, 15]}]], "state_before": "case intro.intro.mk.intro\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Fintype K\np\u271d : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p\u271d)\ninst\u271d : Algebra (ZMod p\u271d) K\nf : K[X]\np : \u2115\nhp\u271d : CharP K p\nthis\u271d : CharP K p := hp\u271d\nn : \u2115\nnpos : 0 < n\nhp : Nat.Prime p\nhn : q = p ^ n\nthis : Fact (Nat.Prime p)\n\u22a2 (expand K q) f = f ^ q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "full_name": "Subgroup.center_eq_infi'", "start": [263, 1], "end": [265, 48], "traced_tactics": [{"tactic": "rw [center_eq_iInf S hS, \u2190 iInf_subtype'']", "annotated_tactic": ["rw [<a>center_eq_iInf</a> S hS, \u2190 <a>iInf_subtype''</a>]", [{"full_name": "Subgroup.center_eq_iInf", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/ZPowers.lean", "def_pos": [256, 9], "def_end_pos": [256, 23]}, {"full_name": "iInf_subtype''", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1167, 9], "def_end_pos": [1167, 23]}]], "state_before": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\ns : Set G\ng : G\nS : Set G\nhS : closure S = \u22a4\n\u22a2 center G = \u2a05 g, centralizer \u2191(zpowers \u2191g)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "AddCommGroup.modEq_iff_toIcoDiv_eq_toIocDiv_add_one", "start": [667, 1], "end": [670, 90], "traced_tactics": [{"tactic": "rw [modEq_iff_toIcoMod_add_period_eq_toIocMod hp, toIcoMod, toIocMod, \u2190 eq_sub_iff_add_eq,\n  sub_sub, sub_right_inj, \u2190 add_one_zsmul, (zsmul_strictMono_left hp).injective.eq_iff]", "annotated_tactic": ["rw [<a>modEq_iff_toIcoMod_add_period_eq_toIocMod</a> hp, <a>toIcoMod</a>, <a>toIocMod</a>, \u2190 <a>eq_sub_iff_add_eq</a>,\n    <a>sub_sub</a>, <a>sub_right_inj</a>, \u2190 <a>add_one_zsmul</a>, (<a>zsmul_strictMono_left</a> hp).injective.eq_iff]", [{"full_name": "AddCommGroup.modEq_iff_toIcoMod_add_period_eq_toIocMod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [652, 9], "def_end_pos": [652, 50]}, {"full_name": "toIcoMod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [74, 5], "def_end_pos": [74, 13]}, {"full_name": "toIocMod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [79, 5], "def_end_pos": [79, 13]}, {"full_name": "eq_sub_iff_add_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [903, 15], "def_end_pos": [903, 32]}, {"full_name": "sub_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [601, 3], "def_end_pos": [601, 14]}, {"full_name": "sub_right_inj", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [855, 3], "def_end_pos": [855, 14]}, {"full_name": "add_one_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [426, 15], "def_end_pos": [426, 28]}, {"full_name": "zsmul_strictMono_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [34, 15], "def_end_pos": [34, 36]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\n\u22a2 a \u2261 b [PMOD p] \u2194 toIcoDiv hp a b = toIocDiv hp a b + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.count_cons_self", "start": [2443, 1], "end": [2444, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearMap.lean", "full_name": "LinearMap.mk\u2082_apply", "start": [255, 1], "end": [256, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Equiv.bijOn'", "start": [1828, 1], "end": [1829, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Pairwise.lean", "full_name": "Function.injective_iff_pairwise_ne", "start": [48, 1], "end": [49, 46], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "amc12a_2017_p7", "start": [411, 1], "end": [413, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "f : \u2115 \u2192 \u211d\nh\u2080 : f 1 = 2\nh\u2081 : \u2200 (n : \u2115), 1 < n \u2227 Even n \u2192 f n = f (n - 1) + 1\nh\u2082 : \u2200 (n : \u2115), 1 < n \u2227 Odd n \u2192 f n = f (n - 2) + 2\n\u22a2 f 2017 = 2018", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/CauSeq/Basic.lean", "full_name": "CauSeq.le_of_eq_of_le", "start": [754, 1], "end": [755, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "sdiff_le_sdiff_right", "start": [612, 1], "end": [613, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.single_mem_supported", "start": [325, 1], "end": [327, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Ioo_subset_Icc_self", "start": [254, 1], "end": [255, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Antichain.lean", "full_name": "isAntichain_iff_forall_not_lt", "start": [263, 1], "end": [265, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/W/Basic.lean", "full_name": "WType.elim_injective", "start": [93, 1], "end": [98, 75], "traced_tactics": [{"tactic": "obtain \u27e8rfl, h\u27e9 := Sigma.mk.inj_iff.mp (f\u03b3_injective h)", "annotated_tactic": ["obtain \u27e8rfl, h\u27e9 := Sigma.mk.inj_iff.mp (f\u03b3_injective h)", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\n\u03b3 : Type u_3\nf\u03b3 : (a : \u03b1) \u00d7 (\u03b2 a \u2192 \u03b3) \u2192 \u03b3\nf\u03b3_injective : Function.Injective f\u03b3\na\u2081 : \u03b1\nf\u2081 : \u03b2 a\u2081 \u2192 WType fun a => \u03b2 a\na\u2082 : \u03b1\nf\u2082 : \u03b2 a\u2082 \u2192 WType fun a => \u03b2 a\nh : elim \u03b3 f\u03b3 (mk a\u2081 f\u2081) = elim \u03b3 f\u03b3 (mk a\u2082 f\u2082)\n\u22a2 mk a\u2081 f\u2081 = mk a\u2082 f\u2082", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\n\u03b3 : Type u_3\nf\u03b3 : (a : \u03b1) \u00d7 (\u03b2 a \u2192 \u03b3) \u2192 \u03b3\nf\u03b3_injective : Function.Injective f\u03b3\na\u2081 : \u03b1\nf\u2081 f\u2082 : \u03b2 a\u2081 \u2192 WType fun a => \u03b2 a\nh\u271d : elim \u03b3 f\u03b3 (mk a\u2081 f\u2081) = elim \u03b3 f\u03b3 (mk a\u2081 f\u2082)\nh : HEq (fun b => elim \u03b3 f\u03b3 (f\u2081 b)) fun b => elim \u03b3 f\u03b3 (f\u2082 b)\n\u22a2 mk a\u2081 f\u2081 = mk a\u2081 f\u2082"}, {"tactic": "congr with x", "annotated_tactic": ["congr with x", []], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\n\u03b3 : Type u_3\nf\u03b3 : (a : \u03b1) \u00d7 (\u03b2 a \u2192 \u03b3) \u2192 \u03b3\nf\u03b3_injective : Function.Injective f\u03b3\na\u2081 : \u03b1\nf\u2081 f\u2082 : \u03b2 a\u2081 \u2192 WType fun a => \u03b2 a\nh\u271d : elim \u03b3 f\u03b3 (mk a\u2081 f\u2081) = elim \u03b3 f\u03b3 (mk a\u2081 f\u2082)\nh : HEq (fun b => elim \u03b3 f\u03b3 (f\u2081 b)) fun b => elim \u03b3 f\u03b3 (f\u2082 b)\n\u22a2 mk a\u2081 f\u2081 = mk a\u2081 f\u2082", "state_after": "case intro.e_f.h\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\n\u03b3 : Type u_3\nf\u03b3 : (a : \u03b1) \u00d7 (\u03b2 a \u2192 \u03b3) \u2192 \u03b3\nf\u03b3_injective : Function.Injective f\u03b3\na\u2081 : \u03b1\nf\u2081 f\u2082 : \u03b2 a\u2081 \u2192 WType fun a => \u03b2 a\nh\u271d : elim \u03b3 f\u03b3 (mk a\u2081 f\u2081) = elim \u03b3 f\u03b3 (mk a\u2081 f\u2082)\nh : HEq (fun b => elim \u03b3 f\u03b3 (f\u2081 b)) fun b => elim \u03b3 f\u03b3 (f\u2082 b)\nx : \u03b2 a\u2081\n\u22a2 f\u2081 x = f\u2082 x"}, {"tactic": "exact elim_injective \u03b3 f\u03b3 f\u03b3_injective (congr_fun (eq_of_heq h) x : _)", "annotated_tactic": ["exact elim_injective \u03b3 f\u03b3 f\u03b3_injective (<a>congr_fun</a> (<a>eq_of_heq</a> h) x : _)", [{"full_name": "congr_fun", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [74, 7], "def_end_pos": [74, 16]}, {"full_name": "eq_of_heq", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [464, 9], "def_end_pos": [464, 18]}]], "state_before": "case intro.e_f.h\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\n\u03b3 : Type u_3\nf\u03b3 : (a : \u03b1) \u00d7 (\u03b2 a \u2192 \u03b3) \u2192 \u03b3\nf\u03b3_injective : Function.Injective f\u03b3\na\u2081 : \u03b1\nf\u2081 f\u2082 : \u03b2 a\u2081 \u2192 WType fun a => \u03b2 a\nh\u271d : elim \u03b3 f\u03b3 (mk a\u2081 f\u2081) = elim \u03b3 f\u03b3 (mk a\u2081 f\u2082)\nh : HEq (fun b => elim \u03b3 f\u03b3 (f\u2081 b)) fun b => elim \u03b3 f\u03b3 (f\u2082 b)\nx : \u03b2 a\u2081\n\u22a2 f\u2081 x = f\u2082 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_atTop_of_add_const_left", "start": [754, 1], "end": [756, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Equiv.lean", "full_name": "MvPolynomial.coeff_eval_eq_eval_coeff", "start": [414, 1], "end": [416, 35], "traced_tactics": [{"tactic": "simp only [Polynomial.coeff_map]", "annotated_tactic": ["simp only [<a>Polynomial.coeff_map</a>]", [{"full_name": "Polynomial.coeff_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [807, 9], "def_end_pos": [807, 18]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\nn : \u2115\ns' : Fin n \u2192 R\nf : (MvPolynomial (Fin n) R)[X]\ni : \u2115\n\u22a2 Polynomial.coeff (Polynomial.map (eval s') f) i = (eval s') (Polynomial.coeff f i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean", "full_name": "ArithmeticFunction.zeta_apply", "start": [443, 1], "end": [444, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "associated_normalize", "start": [111, 1], "end": [112, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/EMetricSpace/Lipschitz.lean", "full_name": "LipschitzOnWith.continuousOn", "start": [308, 11], "end": [309, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Pairwise.lean", "full_name": "Pairwise.set_pairwise", "start": [91, 1], "end": [91, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "full_name": "BilinForm.toMatrix_symm", "start": [261, 1], "end": [262, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Membership.lean", "full_name": "Submonoid.induction_of_closure_eq_top_right", "start": [455, 1], "end": [460, 50], "traced_tactics": [{"tactic": "have : x \u2208 closure s := by simp [hs]", "annotated_tactic": ["have : x \u2208 <a>closure</a> s := by simp [hs]", [{"full_name": "Submonoid.closure", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [384, 5], "def_end_pos": [384, 12]}]], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : Monoid M\na : M\ns : Set M\np : M \u2192 Prop\nhs : closure s = \u22a4\nx : M\nH1 : p 1\nHmul : \u2200 (x y : M), y \u2208 s \u2192 p x \u2192 p (x * y)\n\u22a2 p x", "state_after": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : Monoid M\na : M\ns : Set M\np : M \u2192 Prop\nhs : closure s = \u22a4\nx : M\nH1 : p 1\nHmul : \u2200 (x y : M), y \u2208 s \u2192 p x \u2192 p (x * y)\nthis : x \u2208 closure s\n\u22a2 p x"}, {"tactic": "induction this using closure_induction_right with\n| one => exact H1\n| mul_right x _ y hy ih => exact Hmul x y hy ih", "annotated_tactic": ["induction this using <a>closure_induction_right</a> with\n  | <a>one</a> => exact H1\n  | mul_right x _ y hy ih => exact Hmul x y hy ih", [{"full_name": "Submonoid.closure_induction_right", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [442, 9], "def_end_pos": [442, 32]}, {"full_name": "Submonoid.one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [629, 10], "def_end_pos": [629, 13]}]], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : Monoid M\na : M\ns : Set M\np : M \u2192 Prop\nhs : closure s = \u22a4\nx : M\nH1 : p 1\nHmul : \u2200 (x y : M), y \u2208 s \u2192 p x \u2192 p (x * y)\nthis : x \u2208 closure s\n\u22a2 p x", "state_after": "no goals"}, {"tactic": "simp [hs]", "annotated_tactic": ["simp [hs]", []], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : Monoid M\na : M\ns : Set M\np : M \u2192 Prop\nhs : closure s = \u22a4\nx : M\nH1 : p 1\nHmul : \u2200 (x y : M), y \u2208 s \u2192 p x \u2192 p (x * y)\n\u22a2 x \u2208 closure s", "state_after": "no goals"}, {"tactic": "exact H1", "annotated_tactic": ["exact H1", []], "state_before": "case one\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : Monoid M\na : M\ns : Set M\np : M \u2192 Prop\nhs : closure s = \u22a4\nx : M\nH1 : p 1\nHmul : \u2200 (x y : M), y \u2208 s \u2192 p x \u2192 p (x * y)\n\u22a2 p 1", "state_after": "no goals"}, {"tactic": "exact Hmul x y hy ih", "annotated_tactic": ["exact Hmul x y hy ih", []], "state_before": "case mul_right\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : Monoid M\na : M\ns : Set M\np : M \u2192 Prop\nhs : closure s = \u22a4\nx\u271d : M\nH1 : p 1\nHmul : \u2200 (x y : M), y \u2208 s \u2192 p x \u2192 p (x * y)\nx : M\nhx\u271d : x \u2208 closure s\ny : M\nhy : y \u2208 s\nih : p x\n\u22a2 p (x * y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/Lemmas.lean", "full_name": "Std.RBNode.depthLB_le", "start": [47, 1], "end": [49, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousOn.lean", "full_name": "ContinuousOn.mono", "start": [950, 1], "end": [951, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.cosh_two_mul", "start": [1129, 8], "end": [1130, 41], "traced_tactics": [{"tactic": "rw [\u2190 ofReal_inj]", "annotated_tactic": ["rw [\u2190 <a>ofReal_inj</a>]", [{"full_name": "Complex.ofReal_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [109, 9], "def_end_pos": [109, 19]}]], "state_before": "x y : \u211d\n\u22a2 cosh (2 * x) = cosh x ^ 2 + sinh x ^ 2", "state_after": "x y : \u211d\n\u22a2 \u2191(cosh (2 * x)) = \u2191(cosh x ^ 2 + sinh x ^ 2)"}, {"tactic": "simp [cosh_two_mul]", "annotated_tactic": ["simp [<a>cosh_two_mul</a>]", [{"full_name": "Complex.cosh_two_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [450, 9], "def_end_pos": [450, 21]}]], "state_before": "x y : \u211d\n\u22a2 \u2191(cosh (2 * x)) = \u2191(cosh x ^ 2 + sinh x ^ 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Dynamics/FixedPoints/Basic.lean", "full_name": "Function.IsFixedPt.equiv_symm", "start": [107, 11], "end": [108, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Finite/Basic.lean", "full_name": "FiniteField.X_pow_card_sub_X_ne_zero", "start": [343, 1], "end": [347, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/AddTorsor.lean", "full_name": "Equiv.constVAdd_add", "start": [410, 1], "end": [411, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/OrderClosed.lean", "full_name": "upperBounds_closure", "start": [141, 1], "end": [142, 91], "traced_tactics": [{"tactic": "simp_rw [mem_upperBounds_iff_subset_Iic, isClosed_Iic.closure_subset_iff]", "annotated_tactic": ["simp_rw [<a>mem_upperBounds_iff_subset_Iic</a>, isClosed_Iic.closure_subset_iff]", [{"full_name": "mem_upperBounds_iff_subset_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [93, 7], "def_end_pos": [93, 37]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : ClosedIicTopology \u03b1\nf : \u03b2 \u2192 \u03b1\na\u271d b : \u03b1\ns\u271d s : Set \u03b1\na : \u03b1\n\u22a2 a \u2208 upperBounds (closure s) \u2194 a \u2208 upperBounds s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Ker.lean", "full_name": "Filter.ker_comap", "start": [52, 1], "end": [55, 78], "traced_tactics": [{"tactic": "ext a", "annotated_tactic": ["ext a", []], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf\u271d g : Filter \u03b1\ns : Set \u03b1\na : \u03b1\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b2\n\u22a2 ker (comap m f) = m \u207b\u00b9' ker f", "state_after": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf\u271d g : Filter \u03b1\ns : Set \u03b1\na\u271d : \u03b1\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b2\na : \u03b1\n\u22a2 a \u2208 ker (comap m f) \u2194 a \u2208 m \u207b\u00b9' ker f"}, {"tactic": "simp only [mem_ker, mem_comap, forall_exists_index, and_imp, @forall_swap (Set \u03b1), mem_preimage]", "annotated_tactic": ["simp only [<a>mem_ker</a>, <a>mem_comap</a>, <a>forall_exists_index</a>, <a>and_imp</a>, @<a>forall_swap</a> (<a>Set</a> \u03b1), <a>mem_preimage</a>]", [{"full_name": "Filter.mem_ker", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Ker.lean", "def_pos": [29, 15], "def_end_pos": [29, 22]}, {"full_name": "Filter.mem_comap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2219, 17], "def_end_pos": [2219, 26]}, {"full_name": "forall_exists_index", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [122, 17], "def_end_pos": [122, 36]}, {"full_name": "and_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [108, 17], "def_end_pos": [108, 24]}, {"full_name": "forall_swap", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [654, 9], "def_end_pos": [654, 20]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "Set.mem_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 21]}]], "state_before": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf\u271d g : Filter \u03b1\ns : Set \u03b1\na\u271d : \u03b1\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b2\na : \u03b1\n\u22a2 a \u2208 ker (comap m f) \u2194 a \u2208 m \u207b\u00b9' ker f", "state_after": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf\u271d g : Filter \u03b1\ns : Set \u03b1\na\u271d : \u03b1\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b2\na : \u03b1\n\u22a2 (\u2200 y \u2208 f, \u2200 (x : Set \u03b1), m \u207b\u00b9' y \u2286 x \u2192 a \u2208 x) \u2194 \u2200 s \u2208 f, m a \u2208 s"}, {"tactic": "exact forall\u2082_congr fun s _ \u21a6 \u27e8fun h \u21a6 h _ Subset.rfl, fun ha t ht \u21a6 ht ha\u27e9", "annotated_tactic": ["exact <a>forall\u2082_congr</a> fun s _ \u21a6 \u27e8fun h \u21a6 h _ <a>Subset.rfl</a>, fun ha t ht \u21a6 ht ha\u27e9", [{"full_name": "forall\u2082_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [148, 9], "def_end_pos": [148, 22]}, {"full_name": "Set.Subset.rfl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [338, 9], "def_end_pos": [338, 19]}]], "state_before": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf\u271d g : Filter \u03b1\ns : Set \u03b1\na\u271d : \u03b1\nm : \u03b1 \u2192 \u03b2\nf : Filter \u03b2\na : \u03b1\n\u22a2 (\u2200 y \u2208 f, \u2200 (x : Set \u03b1), m \u207b\u00b9' y \u2286 x \u2192 a \u2208 x) \u2194 \u2200 s \u2208 f, m a \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "full_name": "AffineMap.ext_iff", "start": [146, 1], "end": [147, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Ordinal.IsNormal.isFundamentalSequence", "start": [655, 11], "end": [680, 41], "traced_tactics": [{"tactic": "refine' \u27e8_, @fun i j _ _ h => hf.strictMono (hg.2.1 _ _ h), _\u27e9", "annotated_tactic": ["refine' \u27e8_, @fun i j _ _ h => hf.strictMono (hg.2.1 _ _ h), _\u27e9", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u22a2 IsFundamentalSequence (f a) o fun b hb => f (g b hb)", "state_after": "case refine'_1\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u22a2 o \u2264 ord (cof (f a))\n\ncase refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u22a2 (blsub o fun b hb => f (g b hb)) = f a"}, {"tactic": "rcases exists_lsub_cof (f a) with \u27e8\u03b9, f', hf', h\u03b9\u27e9", "annotated_tactic": ["rcases <a>exists_lsub_cof</a> (f a) with \u27e8\u03b9, f', hf', h\u03b9\u27e9", [{"full_name": "Ordinal.exists_lsub_cof", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Cofinality.lean", "def_pos": [298, 9], "def_end_pos": [298, 24]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u22a2 o \u2264 ord (cof (f a))", "state_after": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\n\u22a2 o \u2264 ord (cof (f a))"}, {"tactic": "rw [\u2190 hg.cof_eq, ord_le_ord, \u2190 h\u03b9]", "annotated_tactic": ["rw [\u2190 hg.cof_eq, <a>ord_le_ord</a>, \u2190 h\u03b9]", [{"full_name": "Cardinal.ord_le_ord", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1406, 9], "def_end_pos": [1406, 19]}]], "state_before": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\n\u22a2 o \u2264 ord (cof (f a))", "state_after": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\n\u22a2 cof a \u2264 #\u03b9"}, {"tactic": "suffices (lsub.{u, u} fun i => sInf { b : Ordinal | f' i \u2264 f b }) = a by\n  rw [\u2190 this]\n  apply cof_lsub_le", "annotated_tactic": ["suffices (<a>lsub</a>.{u, u} fun i => <a>sInf</a> { b : <a>Ordinal</a> | f' i \u2264 f b }) = a by\n      rw [\u2190 this]\n      apply <a>cof_lsub_le</a>", [{"full_name": "Ordinal.lsub", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1578, 5], "def_end_pos": [1578, 9]}, {"full_name": "InfSet.sInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [48, 3], "def_end_pos": [48, 7]}, {"full_name": "Ordinal", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [153, 5], "def_end_pos": [153, 12]}, {"full_name": "Ordinal.cof_lsub_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Cofinality.lean", "def_pos": [304, 9], "def_end_pos": [304, 20]}]], "state_before": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\n\u22a2 cof a \u2264 #\u03b9", "state_after": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\n\u22a2 (lsub fun i => sInf {b | f' i \u2264 f b}) = a"}, {"tactic": "have H : \u2200 i, \u2203 b < a, f' i \u2264 f b := fun i => by\n  have := lt_lsub.{u, u} f' i\n  rw [hf', \u2190 IsNormal.blsub_eq.{u, u} hf ha, lt_blsub_iff] at this\n  simpa using this", "annotated_tactic": ["have H : \u2200 i, \u2203 b < a, f' i \u2264 f b := fun i => by\n      have := <a>lt_lsub</a>.{u, u} f' i\n      rw [hf', \u2190 <a>IsNormal.blsub_eq</a>.{u, u} hf ha, <a>lt_blsub_iff</a>] at this\n      simpa using this", [{"full_name": "Ordinal.lt_lsub", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1599, 9], "def_end_pos": [1599, 16]}, {"full_name": "Ordinal.IsNormal.blsub_eq", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1967, 9], "def_end_pos": [1967, 26]}, {"full_name": "Ordinal.lt_blsub_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1819, 9], "def_end_pos": [1819, 21]}]], "state_before": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\n\u22a2 (lsub fun i => sInf {b | f' i \u2264 f b}) = a", "state_after": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\n\u22a2 (lsub fun i => sInf {b | f' i \u2264 f b}) = a"}, {"tactic": "refine' (lsub_le fun i => _).antisymm (le_of_forall_lt fun b hb => _)", "annotated_tactic": ["refine' (<a>lsub_le</a> fun i => _).<a>antisymm</a> (<a>le_of_forall_lt</a> fun b hb => _)", [{"full_name": "Ordinal.lsub_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1595, 9], "def_end_pos": [1595, 16]}, {"full_name": "LE.le.antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [125, 7], "def_end_pos": [125, 21]}, {"full_name": "le_of_forall_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [534, 9], "def_end_pos": [534, 24]}]], "state_before": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\n\u22a2 (lsub fun i => sInf {b | f' i \u2264 f b}) = a", "state_after": "case refine'_1.intro.intro.intro.refine'_1\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\ni : \u03b9\n\u22a2 sInf {b | f' i \u2264 f b} < a\n\ncase refine'_1.intro.intro.intro.refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb : Ordinal.{u}\nhb : b < a\n\u22a2 b < lsub fun i => sInf {b | f' i \u2264 f b}"}, {"tactic": "rw [\u2190 this]", "annotated_tactic": ["rw [\u2190 this]", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nthis : (lsub fun i => sInf {b | f' i \u2264 f b}) = a\n\u22a2 cof a \u2264 #\u03b9", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nthis : (lsub fun i => sInf {b | f' i \u2264 f b}) = a\n\u22a2 cof (lsub fun i => sInf {b | f' i \u2264 f b}) \u2264 #\u03b9"}, {"tactic": "apply cof_lsub_le", "annotated_tactic": ["apply <a>cof_lsub_le</a>", [{"full_name": "Ordinal.cof_lsub_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Cofinality.lean", "def_pos": [304, 9], "def_end_pos": [304, 20]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nthis : (lsub fun i => sInf {b | f' i \u2264 f b}) = a\n\u22a2 cof (lsub fun i => sInf {b | f' i \u2264 f b}) \u2264 #\u03b9", "state_after": "no goals"}, {"tactic": "have := lt_lsub.{u, u} f' i", "annotated_tactic": ["have := <a>lt_lsub</a>.{u, u} f' i", [{"full_name": "Ordinal.lt_lsub", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1599, 9], "def_end_pos": [1599, 16]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\ni : \u03b9\n\u22a2 \u2203 b < a, f' i \u2264 f b", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\ni : \u03b9\nthis : f' i < lsub f'\n\u22a2 \u2203 b < a, f' i \u2264 f b"}, {"tactic": "rw [hf', \u2190 IsNormal.blsub_eq.{u, u} hf ha, lt_blsub_iff] at this", "annotated_tactic": ["rw [hf', \u2190 <a>IsNormal.blsub_eq</a>.{u, u} hf ha, <a>lt_blsub_iff</a>] at this", [{"full_name": "Ordinal.IsNormal.blsub_eq", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1967, 9], "def_end_pos": [1967, 26]}, {"full_name": "Ordinal.lt_blsub_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1819, 9], "def_end_pos": [1819, 21]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\ni : \u03b9\nthis : f' i < lsub f'\n\u22a2 \u2203 b < a, f' i \u2264 f b", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\ni : \u03b9\nthis : \u2203 i_1, \u2203 (_ : i_1 < a), f' i \u2264 f i_1\n\u22a2 \u2203 b < a, f' i \u2264 f b"}, {"tactic": "simpa using this", "annotated_tactic": ["simpa using this", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\ni : \u03b9\nthis : \u2203 i_1, \u2203 (_ : i_1 < a), f' i \u2264 f i_1\n\u22a2 \u2203 b < a, f' i \u2264 f b", "state_after": "no goals"}, {"tactic": "rcases H i with \u27e8b, hb, hb'\u27e9", "annotated_tactic": ["rcases H i with \u27e8b, hb, hb'\u27e9", []], "state_before": "case refine'_1.intro.intro.intro.refine'_1\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\ni : \u03b9\n\u22a2 sInf {b | f' i \u2264 f b} < a", "state_after": "case refine'_1.intro.intro.intro.refine'_1.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\ni : \u03b9\nb : Ordinal.{u}\nhb : b < a\nhb' : f' i \u2264 f b\n\u22a2 sInf {b | f' i \u2264 f b} < a"}, {"tactic": "exact lt_of_le_of_lt (csInf_le' hb') hb", "annotated_tactic": ["exact <a>lt_of_le_of_lt</a> (<a>csInf_le'</a> hb') hb", [{"full_name": "lt_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}, {"full_name": "csInf_le'", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [1234, 9], "def_end_pos": [1234, 18]}]], "state_before": "case refine'_1.intro.intro.intro.refine'_1.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\ni : \u03b9\nb : Ordinal.{u}\nhb : b < a\nhb' : f' i \u2264 f b\n\u22a2 sInf {b | f' i \u2264 f b} < a", "state_after": "no goals"}, {"tactic": "have := hf.strictMono hb", "annotated_tactic": ["have := hf.strictMono hb", []], "state_before": "case refine'_1.intro.intro.intro.refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb : Ordinal.{u}\nhb : b < a\n\u22a2 b < lsub fun i => sInf {b | f' i \u2264 f b}", "state_after": "case refine'_1.intro.intro.intro.refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb : Ordinal.{u}\nhb : b < a\nthis : f b < f a\n\u22a2 b < lsub fun i => sInf {b | f' i \u2264 f b}"}, {"tactic": "rw [\u2190 hf', lt_lsub_iff] at this", "annotated_tactic": ["rw [\u2190 hf', <a>lt_lsub_iff</a>] at this", [{"full_name": "Ordinal.lt_lsub_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1603, 9], "def_end_pos": [1603, 20]}]], "state_before": "case refine'_1.intro.intro.intro.refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb : Ordinal.{u}\nhb : b < a\nthis : f b < f a\n\u22a2 b < lsub fun i => sInf {b | f' i \u2264 f b}", "state_after": "case refine'_1.intro.intro.intro.refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb : Ordinal.{u}\nhb : b < a\nthis : \u2203 i, f b \u2264 f' i\n\u22a2 b < lsub fun i => sInf {b | f' i \u2264 f b}"}, {"tactic": "cases' this with i hi", "annotated_tactic": ["cases' this with i hi", []], "state_before": "case refine'_1.intro.intro.intro.refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb : Ordinal.{u}\nhb : b < a\nthis : \u2203 i, f b \u2264 f' i\n\u22a2 b < lsub fun i => sInf {b | f' i \u2264 f b}", "state_after": "case refine'_1.intro.intro.intro.refine'_2.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb : Ordinal.{u}\nhb : b < a\ni : \u03b9\nhi : f b \u2264 f' i\n\u22a2 b < lsub fun i => sInf {b | f' i \u2264 f b}"}, {"tactic": "rcases H i with \u27e8b, _, hb\u27e9", "annotated_tactic": ["rcases H i with \u27e8b, _, hb\u27e9", []], "state_before": "case refine'_1.intro.intro.intro.refine'_2.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb : Ordinal.{u}\nhb : b < a\ni : \u03b9\nhi : f b \u2264 f' i\n\u22a2 b < lsub fun i => sInf {b | f' i \u2264 f b}", "state_after": "case refine'_1.intro.intro.intro.refine'_2.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb\u271d : Ordinal.{u}\nhb\u271d : b\u271d < a\ni : \u03b9\nhi : f b\u271d \u2264 f' i\nb : Ordinal.{u}\nleft\u271d : b < a\nhb : f' i \u2264 f b\n\u22a2 b\u271d < lsub fun i => sInf {b | f' i \u2264 f b}"}, {"tactic": "exact\n  ((le_csInf_iff'' \u27e8b, by exact hb\u27e9).2 fun c hc =>\n    hf.strictMono.le_iff_le.1 (hi.trans hc)).trans_lt (lt_lsub _ i)", "annotated_tactic": ["exact\n        ((<a>le_csInf_iff''</a> \u27e8b, by exact hb\u27e9).2 fun c hc =>\n          hf.strictMono.le_iff_le.1 (hi.trans hc)).<a>trans_lt</a> (<a>lt_lsub</a> _ i)", [{"full_name": "le_csInf_iff''", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [1225, 9], "def_end_pos": [1225, 23]}, {"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}, {"full_name": "Ordinal.lt_lsub", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1599, 9], "def_end_pos": [1599, 16]}]], "state_before": "case refine'_1.intro.intro.intro.refine'_2.intro.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb\u271d : Ordinal.{u}\nhb\u271d : b\u271d < a\ni : \u03b9\nhi : f b\u271d \u2264 f' i\nb : Ordinal.{u}\nleft\u271d : b < a\nhb : f' i \u2264 f b\n\u22a2 b\u271d < lsub fun i => sInf {b | f' i \u2264 f b}", "state_after": "no goals"}, {"tactic": "exact hb", "annotated_tactic": ["exact hb", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u03b9 : Type u\nf' : \u03b9 \u2192 Ordinal.{u}\nhf' : lsub f' = f a\nh\u03b9 : #\u03b9 = cof (f a)\nH : \u2200 (i : \u03b9), \u2203 b < a, f' i \u2264 f b\nb\u271d : Ordinal.{u}\nhb\u271d : b\u271d < a\ni : \u03b9\nhi : f b\u271d \u2264 f' i\nb : Ordinal.{u}\nleft\u271d : b < a\nhb : f' i \u2264 f b\n\u22a2 b \u2208 fun c =>\n    Quot.lift\n      (fun a\u2081 =>\n        Quotient.lift\n          ((fun x x_1 =>\n              match x with\n              | { \u03b1 := \u03b1, r := r, wo := wo } =>\n                match x_1 with\n                | { \u03b1 := \u03b1_1, r := s, wo := wo } => Nonempty (r \u227ci s))\n            a\u2081)\n          \u22ef (f c))\n      \u22ef (f' i)", "state_after": "no goals"}, {"tactic": "rw [@blsub_comp.{u, u, u} a _ (fun b _ => f b) (@fun i j _ _ h => hf.strictMono.monotone h) g\n    hg.2.2]", "annotated_tactic": ["rw [@<a>blsub_comp</a>.{u, u, u} a _ (fun b _ => f b) (@fun i j _ _ h => hf.strictMono.monotone h) g\n        hg.2.2]", [{"full_name": "Ordinal.blsub_comp", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1954, 9], "def_end_pos": [1954, 19]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u22a2 (blsub o fun b hb => f (g b hb)) = f a", "state_after": "case refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u22a2 (blsub a fun b x => f b) = f a"}, {"tactic": "exact IsNormal.blsub_eq.{u, u} hf ha", "annotated_tactic": ["exact <a>IsNormal.blsub_eq</a>.{u, u} hf ha", [{"full_name": "Ordinal.IsNormal.blsub_eq", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1967, 9], "def_end_pos": [1967, 26]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\na o : Ordinal.{u}\nha : IsLimit a\ng : (b : Ordinal.{u}) \u2192 b < o \u2192 Ordinal.{u}\nhg : IsFundamentalSequence a o g\n\u22a2 (blsub a fun b x => f b) = f a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.infinite_of_forall_exists_gt", "start": [1466, 1], "end": [1471, 74], "traced_tactics": [{"tactic": "inhabit \u03b1", "annotated_tactic": ["inhabit \u03b1", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 s, a < b\n\u22a2 Set.Infinite s", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 s, a < b\ninhabited_h : Inhabited \u03b1\n\u22a2 Set.Infinite s"}, {"tactic": "set f : \u2115 \u2192 \u03b1 := fun n => Nat.recOn n (h default).choose fun _ a => (h a).choose", "annotated_tactic": ["set f : \u2115 \u2192 \u03b1 := fun n => <a>Nat.recOn</a> n (h <a>default</a>).<a>choose</a> fun _ a => (h a).<a>choose</a>", [{"full_name": "Nat.recOn", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1065, 11], "def_end_pos": [1065, 14]}, {"full_name": "Inhabited.default", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [692, 3], "def_end_pos": [692, 10]}, {"full_name": "Exists.choose", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [154, 32], "def_end_pos": [154, 45]}, {"full_name": "Exists.choose", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [154, 32], "def_end_pos": [154, 45]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 s, a < b\ninhabited_h : Inhabited \u03b1\n\u22a2 Set.Infinite s", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 s, a < b\ninhabited_h : Inhabited \u03b1\nf : \u2115 \u2192 \u03b1 := fun n => Nat.recOn n (Exists.choose \u22ef) fun x a => Exists.choose \u22ef\n\u22a2 Set.Infinite s"}, {"tactic": "have hf : \u2200 n, f n \u2208 s := by rintro (_ | _) <;> exact (h _).choose_spec.1", "annotated_tactic": ["have hf : \u2200 n, f n \u2208 s := by rintro (_ | _) <;> exact (h _).<a>choose_spec</a>.1", [{"full_name": "Exists.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [157, 9], "def_end_pos": [157, 27]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 s, a < b\ninhabited_h : Inhabited \u03b1\nf : \u2115 \u2192 \u03b1 := fun n => Nat.recOn n (Exists.choose \u22ef) fun x a => Exists.choose \u22ef\n\u22a2 Set.Infinite s", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 s, a < b\ninhabited_h : Inhabited \u03b1\nf : \u2115 \u2192 \u03b1 := fun n => Nat.recOn n (Exists.choose \u22ef) fun x a => Exists.choose \u22ef\nhf : \u2200 (n : \u2115), f n \u2208 s\n\u22a2 Set.Infinite s"}, {"tactic": "exact infinite_of_injective_forall_mem\n  (strictMono_nat_of_lt_succ fun n => (h _).choose_spec.2).injective hf", "annotated_tactic": ["exact <a>infinite_of_injective_forall_mem</a>\n    (<a>strictMono_nat_of_lt_succ</a> fun n => (h _).<a>choose_spec</a>.2).<a>injective</a> hf", [{"full_name": "Set.infinite_of_injective_forall_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1444, 9], "def_end_pos": [1444, 41]}, {"full_name": "strictMono_nat_of_lt_succ", "def_path": ".lake/packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [1033, 9], "def_end_pos": [1033, 34]}, {"full_name": "Exists.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [157, 9], "def_end_pos": [157, 27]}, {"full_name": "StrictMono.injective", "def_path": ".lake/packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [880, 9], "def_end_pos": [880, 29]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 s, a < b\ninhabited_h : Inhabited \u03b1\nf : \u2115 \u2192 \u03b1 := fun n => Nat.recOn n (Exists.choose \u22ef) fun x a => Exists.choose \u22ef\nhf : \u2200 (n : \u2115), f n \u2208 s\n\u22a2 Set.Infinite s", "state_after": "no goals"}, {"tactic": "rintro (_ | _) <;> exact (h _).choose_spec.1", "annotated_tactic": ["rintro (_ | _) <;> exact (h _).<a>choose_spec</a>.1", [{"full_name": "Exists.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [157, 9], "def_end_pos": [157, 27]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 s, a < b\ninhabited_h : Inhabited \u03b1\nf : \u2115 \u2192 \u03b1 := fun n => Nat.recOn n (Exists.choose \u22ef) fun x a => Exists.choose \u22ef\n\u22a2 \u2200 (n : \u2115), f n \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Fold.lean", "full_name": "Finset.fold_op_rel_iff_and", "start": [164, 1], "end": [179, 61], "traced_tactics": [{"tactic": "induction' s using Finset.induction_on with a s ha IH", "annotated_tactic": ["induction' s using <a>Finset.induction_on</a> with a s ha IH", [{"full_name": "Finset.induction_on", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1283, 19], "def_end_pos": [1283, 31]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\n\u22a2 r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)", "state_after": "case empty\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\n\u22a2 r c (fold op b f \u2205) \u2194 r c b \u2227 \u2200 x \u2208 \u2205, r c (f x)\n\ncase insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 r c (fold op b f (insert a s)) \u2194 r c b \u2227 \u2200 x \u2208 insert a s, r c (f x)"}, {"tactic": "rw [Finset.fold_insert ha, hr, IH, \u2190 and_assoc, @and_comm (r c (f a)), and_assoc]", "annotated_tactic": ["rw [<a>Finset.fold_insert</a> ha, hr, IH, \u2190 <a>and_assoc</a>, @<a>and_comm</a> (r c (f a)), <a>and_assoc</a>]", [{"full_name": "Finset.fold_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Fold.lean", "def_pos": [52, 9], "def_end_pos": [52, 20]}, {"full_name": "and_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [136, 9], "def_end_pos": [136, 18]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}, {"full_name": "and_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [136, 9], "def_end_pos": [136, 18]}]], "state_before": "case insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 r c (fold op b f (insert a s)) \u2194 r c b \u2227 \u2200 x \u2208 insert a s, r c (f x)", "state_after": "case insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 (r c b \u2227 r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)) \u2194 r c b \u2227 \u2200 x \u2208 insert a s, r c (f x)"}, {"tactic": "apply and_congr Iff.rfl", "annotated_tactic": ["apply <a>and_congr</a> <a>Iff.rfl</a>", [{"full_name": "and_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [28, 9], "def_end_pos": [28, 18]}, {"full_name": "Iff.rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [791, 19], "def_end_pos": [791, 26]}]], "state_before": "case insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 (r c b \u2227 r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)) \u2194 r c b \u2227 \u2200 x \u2208 insert a s, r c (f x)", "state_after": "case insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 (r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)) \u2194 \u2200 x \u2208 insert a s, r c (f x)"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 (r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)) \u2194 \u2200 x \u2208 insert a s, r c (f x)", "state_after": "case insert.mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 (r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)) \u2192 \u2200 x \u2208 insert a s, r c (f x)\n\ncase insert.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 (\u2200 x \u2208 insert a s, r c (f x)) \u2192 r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case empty\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\n\u22a2 r c (fold op b f \u2205) \u2194 r c b \u2227 \u2200 x \u2208 \u2205, r c (f x)", "state_after": "no goals"}, {"tactic": "rintro \u27e8h\u2081, h\u2082\u27e9", "annotated_tactic": ["rintro \u27e8h\u2081, h\u2082\u27e9", []], "state_before": "case insert.mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 (r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)) \u2192 \u2200 x \u2208 insert a s, r c (f x)", "state_after": "case insert.mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\nh\u2081 : r c (f a)\nh\u2082 : \u2200 x \u2208 s, r c (f x)\n\u22a2 \u2200 x \u2208 insert a s, r c (f x)"}, {"tactic": "intro b hb", "annotated_tactic": ["intro b hb", []], "state_before": "case insert.mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\nh\u2081 : r c (f a)\nh\u2082 : \u2200 x \u2208 s, r c (f x)\n\u22a2 \u2200 x \u2208 insert a s, r c (f x)", "state_after": "case insert.mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb\u271d : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b\u271d f s) \u2194 r c b\u271d \u2227 \u2200 x \u2208 s, r c (f x)\nh\u2081 : r c (f a)\nh\u2082 : \u2200 x \u2208 s, r c (f x)\nb : \u03b1\nhb : b \u2208 insert a s\n\u22a2 r c (f b)"}, {"tactic": "rw [Finset.mem_insert] at hb", "annotated_tactic": ["rw [<a>Finset.mem_insert</a>] at hb", [{"full_name": "Finset.mem_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1116, 9], "def_end_pos": [1116, 19]}]], "state_before": "case insert.mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb\u271d : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b\u271d f s) \u2194 r c b\u271d \u2227 \u2200 x \u2208 s, r c (f x)\nh\u2081 : r c (f a)\nh\u2082 : \u2200 x \u2208 s, r c (f x)\nb : \u03b1\nhb : b \u2208 insert a s\n\u22a2 r c (f b)", "state_after": "case insert.mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb\u271d : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b\u271d f s) \u2194 r c b\u271d \u2227 \u2200 x \u2208 s, r c (f x)\nh\u2081 : r c (f a)\nh\u2082 : \u2200 x \u2208 s, r c (f x)\nb : \u03b1\nhb : b = a \u2228 b \u2208 s\n\u22a2 r c (f b)"}, {"tactic": "rcases hb with (rfl | hb) <;> solve_by_elim", "annotated_tactic": ["rcases hb with (rfl | hb) <;> solve_by_elim", []], "state_before": "case insert.mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb\u271d : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b\u271d f s) \u2194 r c b\u271d \u2227 \u2200 x \u2208 s, r c (f x)\nh\u2081 : r c (f a)\nh\u2082 : \u2200 x \u2208 s, r c (f x)\nb : \u03b1\nhb : b = a \u2228 b \u2208 s\n\u22a2 r c (f b)", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case insert.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\n\u22a2 (\u2200 x \u2208 insert a s, r c (f x)) \u2192 r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)", "state_after": "case insert.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\nh : \u2200 x \u2208 insert a s, r c (f x)\n\u22a2 r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case insert.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\nh : \u2200 x \u2208 insert a s, r c (f x)\n\u22a2 r c (f a) \u2227 \u2200 x \u2208 s, r c (f x)", "state_after": "case insert.mpr.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\nh : \u2200 x \u2208 insert a s, r c (f x)\n\u22a2 r c (f a)\n\ncase insert.mpr.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\nh : \u2200 x \u2208 insert a s, r c (f x)\n\u22a2 \u2200 x \u2208 s, r c (f x)"}, {"tactic": "exact h a (Finset.mem_insert_self _ _)", "annotated_tactic": ["exact h a (<a>Finset.mem_insert_self</a> _ _)", [{"full_name": "Finset.mem_insert_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1120, 9], "def_end_pos": [1120, 24]}]], "state_before": "case insert.mpr.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\nh : \u2200 x \u2208 insert a s, r c (f x)\n\u22a2 r c (f a)", "state_after": "no goals"}, {"tactic": "exact fun b hb => h b <| Finset.mem_insert_of_mem hb", "annotated_tactic": ["exact fun b hb => h b <| <a>Finset.mem_insert_of_mem</a> hb", [{"full_name": "Finset.mem_insert_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1124, 9], "def_end_pos": [1124, 26]}]], "state_before": "case insert.mpr.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : Std.Commutative op\nha\u271d : Std.Associative op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na\u271d : \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nhr : \u2200 {x y z : \u03b2}, r x (op y z) \u2194 r x y \u2227 r x z\nc : \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nIH : r c (fold op b f s) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)\nh : \u2200 x \u2208 insert a s, r c (f x)\n\u22a2 \u2200 x \u2208 s, r c (f x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Defs.lean", "full_name": "Finsupp.embDomain_injective", "start": [910, 1], "end": [911, 95], "traced_tactics": [{"tactic": "simpa only [embDomain_apply] using DFunLike.ext_iff.1 h (f a)", "annotated_tactic": ["simpa only [<a>embDomain_apply</a>] using <a>DFunLike.ext_iff</a>.1 h (f a)", [{"full_name": "Finsupp.embDomain_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [893, 9], "def_end_pos": [893, 24]}, {"full_name": "DFunLike.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/FunLike/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b9 : Zero M\ninst\u271d : Zero N\nf : \u03b1 \u21aa \u03b2\nl\u2081 l\u2082 : \u03b1 \u2192\u2080 M\nh : embDomain f l\u2081 = embDomain f l\u2082\na : \u03b1\n\u22a2 l\u2081 a = l\u2082 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Trace.lean", "full_name": "Algebra.trace_surjective", "start": [648, 1], "end": [653, 34], "traced_tactics": [{"tactic": "rw [\u2190 LinearMap.range_eq_top]", "annotated_tactic": ["rw [\u2190 <a>LinearMap.range_eq_top</a>]", [{"full_name": "LinearMap.range_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [174, 9], "def_end_pos": [174, 21]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\ninst\u271d\u00b9\u2074 : CommRing S\ninst\u271d\u00b9\u00b3 : CommRing T\ninst\u271d\u00b9\u00b2 : Algebra R S\ninst\u271d\u00b9\u00b9 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u2070 : Field K\ninst\u271d\u2079 : Field L\ninst\u271d\u2078 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u2077 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Algebra R L\ninst\u271d\u2074 : Algebra L F\ninst\u271d\u00b3 : Algebra R F\ninst\u271d\u00b2 : IsScalarTower R L F\npb : PowerBasis K L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\n\u22a2 Function.Surjective \u21d1(trace K L)", "state_after": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\ninst\u271d\u00b9\u2074 : CommRing S\ninst\u271d\u00b9\u00b3 : CommRing T\ninst\u271d\u00b9\u00b2 : Algebra R S\ninst\u271d\u00b9\u00b9 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u2070 : Field K\ninst\u271d\u2079 : Field L\ninst\u271d\u2078 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u2077 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Algebra R L\ninst\u271d\u2074 : Algebra L F\ninst\u271d\u00b3 : Algebra R F\ninst\u271d\u00b2 : IsScalarTower R L F\npb : PowerBasis K L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\n\u22a2 range (trace K L) = \u22a4"}, {"tactic": "apply (IsSimpleOrder.eq_bot_or_eq_top (\u03b1 := Ideal K) _).resolve_left", "annotated_tactic": ["apply (<a>IsSimpleOrder.eq_bot_or_eq_top</a> (\u03b1 := <a>Ideal</a> K) _).<a>resolve_left</a>", [{"full_name": "IsSimpleOrder.eq_bot_or_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/Order/Atoms.lean", "def_pos": [520, 3], "def_end_pos": [520, 19]}, {"full_name": "Ideal", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [40, 5], "def_end_pos": [40, 10]}, {"full_name": "Or.resolve_left", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [551, 9], "def_end_pos": [551, 24]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\ninst\u271d\u00b9\u2074 : CommRing S\ninst\u271d\u00b9\u00b3 : CommRing T\ninst\u271d\u00b9\u00b2 : Algebra R S\ninst\u271d\u00b9\u00b9 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u2070 : Field K\ninst\u271d\u2079 : Field L\ninst\u271d\u2078 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u2077 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Algebra R L\ninst\u271d\u2074 : Algebra L F\ninst\u271d\u00b3 : Algebra R F\ninst\u271d\u00b2 : IsScalarTower R L F\npb : PowerBasis K L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\n\u22a2 range (trace K L) = \u22a4", "state_after": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\ninst\u271d\u00b9\u2074 : CommRing S\ninst\u271d\u00b9\u00b3 : CommRing T\ninst\u271d\u00b9\u00b2 : Algebra R S\ninst\u271d\u00b9\u00b9 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u2070 : Field K\ninst\u271d\u2079 : Field L\ninst\u271d\u2078 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u2077 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Algebra R L\ninst\u271d\u2074 : Algebra L F\ninst\u271d\u00b3 : Algebra R F\ninst\u271d\u00b2 : IsScalarTower R L F\npb : PowerBasis K L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\n\u22a2 \u00acrange (trace K L) = \u22a5"}, {"tactic": "rw [LinearMap.range_eq_bot]", "annotated_tactic": ["rw [<a>LinearMap.range_eq_bot</a>]", [{"full_name": "LinearMap.range_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [309, 9], "def_end_pos": [309, 21]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\ninst\u271d\u00b9\u2074 : CommRing S\ninst\u271d\u00b9\u00b3 : CommRing T\ninst\u271d\u00b9\u00b2 : Algebra R S\ninst\u271d\u00b9\u00b9 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u2070 : Field K\ninst\u271d\u2079 : Field L\ninst\u271d\u2078 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u2077 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Algebra R L\ninst\u271d\u2074 : Algebra L F\ninst\u271d\u00b3 : Algebra R F\ninst\u271d\u00b2 : IsScalarTower R L F\npb : PowerBasis K L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\n\u22a2 \u00acrange (trace K L) = \u22a5", "state_after": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\ninst\u271d\u00b9\u2074 : CommRing S\ninst\u271d\u00b9\u00b3 : CommRing T\ninst\u271d\u00b9\u00b2 : Algebra R S\ninst\u271d\u00b9\u00b9 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u2070 : Field K\ninst\u271d\u2079 : Field L\ninst\u271d\u2078 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u2077 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Algebra R L\ninst\u271d\u2074 : Algebra L F\ninst\u271d\u00b3 : Algebra R F\ninst\u271d\u00b2 : IsScalarTower R L F\npb : PowerBasis K L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\n\u22a2 \u00actrace K L = 0"}, {"tactic": "exact Algebra.trace_ne_zero K L", "annotated_tactic": ["exact <a>Algebra.trace_ne_zero</a> K L", [{"full_name": "Algebra.trace_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Trace.lean", "def_pos": [639, 9], "def_end_pos": [639, 30]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2075 : CommRing R\ninst\u271d\u00b9\u2074 : CommRing S\ninst\u271d\u00b9\u00b3 : CommRing T\ninst\u271d\u00b9\u00b2 : Algebra R S\ninst\u271d\u00b9\u00b9 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u2070 : Field K\ninst\u271d\u2079 : Field L\ninst\u271d\u2078 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u2077 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Algebra R L\ninst\u271d\u2074 : Algebra L F\ninst\u271d\u00b3 : Algebra R F\ninst\u271d\u00b2 : IsScalarTower R L F\npb : PowerBasis K L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\n\u22a2 \u00actrace K L = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Sets/Opens.lean", "full_name": "TopologicalSpace.Opens.nonempty_coeSort", "start": [99, 11], "end": [100, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/HasLimits.lean", "full_name": "CategoryTheory.Limits.colimit.cocone_x", "start": [752, 1], "end": [753, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "isOpen_biUnion", "start": [111, 1], "end": [113, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.div_one", "start": [97, 19], "end": [99, 48], "traced_tactics": [{"tactic": "simp [Int.div, neg_ofNat_succ]", "annotated_tactic": ["simp [<a>Int.div</a>, <a>neg_ofNat_succ</a>]", [{"full_name": "Int.div", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivMod.lean", "def_pos": [56, 5], "def_end_pos": [56, 8]}, {"full_name": "Int.neg_ofNat_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [30, 23], "def_end_pos": [30, 37]}]], "state_before": "n : Nat\n\u22a2 div -[n+1] 1 = -[n+1]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "full_name": "mem_nonZeroDivisors_of_ne_zero", "start": [198, 1], "end": [199, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Sqrt.lean", "full_name": "Nat.lt_succ_sqrt", "start": [72, 1], "end": [73, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "isComplemented_top", "start": [680, 1], "end": [681, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Yoneda.lean", "full_name": "CategoryTheory.yonedaEquiv_naturality", "start": [412, 1], "end": [417, 7], "traced_tactics": [{"tactic": "change (f.app (op X) \u226b F.map g.op) (\ud835\udfd9 X) = f.app (op Y) (\ud835\udfd9 Y \u226b g)", "annotated_tactic": ["change (f.app (<a>op</a> X) \u226b F.map g.op) (\ud835\udfd9 X) = f.app (<a>op</a> Y) (\ud835\udfd9 Y \u226b g)", [{"full_name": "Opposite.op", "def_path": ".lake/packages/mathlib/Mathlib/Data/Opposite.lean", "def_pos": [53, 5], "def_end_pos": [53, 7]}, {"full_name": "Opposite.op", "def_path": ".lake/packages/mathlib/Mathlib/Data/Opposite.lean", "def_pos": [53, 5], "def_end_pos": [53, 7]}]], "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y : C\nF : C\u1d52\u1d56 \u2964 Type v\u2081\nf : yoneda.obj X \u27f6 F\ng : Y \u27f6 X\n\u22a2 F.map g.op (yonedaEquiv f) = yonedaEquiv (yoneda.map g \u226b f)", "state_after": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y : C\nF : C\u1d52\u1d56 \u2964 Type v\u2081\nf : yoneda.obj X \u27f6 F\ng : Y \u27f6 X\n\u22a2 (f.app (op X) \u226b F.map g.op) (\ud835\udfd9 X) = f.app (op Y) (\ud835\udfd9 Y \u226b g)"}, {"tactic": "rw [\u2190 f.naturality]", "annotated_tactic": ["rw [\u2190 f.naturality]", []], "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y : C\nF : C\u1d52\u1d56 \u2964 Type v\u2081\nf : yoneda.obj X \u27f6 F\ng : Y \u27f6 X\n\u22a2 (f.app (op X) \u226b F.map g.op) (\ud835\udfd9 X) = f.app (op Y) (\ud835\udfd9 Y \u226b g)", "state_after": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y : C\nF : C\u1d52\u1d56 \u2964 Type v\u2081\nf : yoneda.obj X \u27f6 F\ng : Y \u27f6 X\n\u22a2 ((yoneda.obj X).map g.op \u226b f.app (op Y)) (\ud835\udfd9 X) = f.app (op Y) (\ud835\udfd9 Y \u226b g)"}, {"tactic": "dsimp", "annotated_tactic": ["dsimp", []], "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y : C\nF : C\u1d52\u1d56 \u2964 Type v\u2081\nf : yoneda.obj X \u27f6 F\ng : Y \u27f6 X\n\u22a2 ((yoneda.obj X).map g.op \u226b f.app (op Y)) (\ud835\udfd9 X) = f.app (op Y) (\ud835\udfd9 Y \u226b g)", "state_after": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y : C\nF : C\u1d52\u1d56 \u2964 Type v\u2081\nf : yoneda.obj X \u27f6 F\ng : Y \u27f6 X\n\u22a2 f.app (op Y) (g \u226b \ud835\udfd9 X) = f.app (op Y) (\ud835\udfd9 Y \u226b g)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y : C\nF : C\u1d52\u1d56 \u2964 Type v\u2081\nf : yoneda.obj X \u27f6 F\ng : Y \u27f6 X\n\u22a2 f.app (op Y) (g \u226b \ud835\udfd9 X) = f.app (op Y) (\ud835\udfd9 Y \u226b g)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "full_name": "Submodule.disjoint_def'", "start": [379, 1], "end": [382, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.sup_h_of_disjoint", "start": [371, 1], "end": [376, 11], "traced_tactics": [{"tactic": "rw [disjoint_def] at h", "annotated_tactic": ["rw [<a>disjoint_def</a>] at h", [{"full_name": "Submodule.disjoint_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [375, 9], "def_end_pos": [375, 21]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf g : E \u2192\u2097.[R] F\nh : Disjoint f.domain g.domain\nx : \u21a5f.domain\ny : \u21a5g.domain\nhxy : \u2191x = \u2191y\n\u22a2 \u2191f x = \u2191g y", "state_after": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf g : E \u2192\u2097.[R] F\nh : \u2200 x \u2208 f.domain, x \u2208 g.domain \u2192 x = 0\nx : \u21a5f.domain\ny : \u21a5g.domain\nhxy : \u2191x = \u2191y\n\u22a2 \u2191f x = \u2191g y"}, {"tactic": "have hy : y = 0 := Subtype.eq (h y (hxy \u25b8 x.2) y.2)", "annotated_tactic": ["have hy : y = 0 := <a>Subtype.eq</a> (h y (hxy \u25b8 x.2) y.2)", [{"full_name": "Subtype.eq", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1105, 19], "def_end_pos": [1105, 21]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf g : E \u2192\u2097.[R] F\nh : \u2200 x \u2208 f.domain, x \u2208 g.domain \u2192 x = 0\nx : \u21a5f.domain\ny : \u21a5g.domain\nhxy : \u2191x = \u2191y\n\u22a2 \u2191f x = \u2191g y", "state_after": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf g : E \u2192\u2097.[R] F\nh : \u2200 x \u2208 f.domain, x \u2208 g.domain \u2192 x = 0\nx : \u21a5f.domain\ny : \u21a5g.domain\nhxy : \u2191x = \u2191y\nhy : y = 0\n\u22a2 \u2191f x = \u2191g y"}, {"tactic": "have hx : x = 0 := Subtype.eq (hxy.trans <| congr_arg _ hy)", "annotated_tactic": ["have hx : x = 0 := <a>Subtype.eq</a> (hxy.trans <| <a>congr_arg</a> _ hy)", [{"full_name": "Subtype.eq", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1105, 19], "def_end_pos": [1105, 21]}, {"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf g : E \u2192\u2097.[R] F\nh : \u2200 x \u2208 f.domain, x \u2208 g.domain \u2192 x = 0\nx : \u21a5f.domain\ny : \u21a5g.domain\nhxy : \u2191x = \u2191y\nhy : y = 0\n\u22a2 \u2191f x = \u2191g y", "state_after": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf g : E \u2192\u2097.[R] F\nh : \u2200 x \u2208 f.domain, x \u2208 g.domain \u2192 x = 0\nx : \u21a5f.domain\ny : \u21a5g.domain\nhxy : \u2191x = \u2191y\nhy : y = 0\nhx : x = 0\n\u22a2 \u2191f x = \u2191g y"}, {"tactic": "simp [*]", "annotated_tactic": ["simp [*]", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf g : E \u2192\u2097.[R] F\nh : \u2200 x \u2208 f.domain, x \u2208 g.domain \u2192 x = 0\nx : \u21a5f.domain\ny : \u21a5g.domain\nhxy : \u2191x = \u2191y\nhy : y = 0\nhx : x = 0\n\u22a2 \u2191f x = \u2191g y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Defs.lean", "full_name": "mul_inv_rev", "start": [1070, 1], "end": [1071, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean", "full_name": "SimpleGraph.sInf_adj", "start": [297, 1], "end": [298, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Hom.lean", "full_name": "AlgHom.ext_iff", "start": [222, 1], "end": [223, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.exists_ne_of_one_lt_card", "start": [597, 1], "end": [599, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/TransferInstance.lean", "full_name": "Equiv.mulEquiv_apply", "start": [171, 1], "end": [172, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "StrictMono.imp", "start": [406, 1], "end": [407, 7], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupClosed.lean", "full_name": "InfClosed.finsetInf'_mem", "start": [154, 1], "end": [156, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.InjOn.image_biInter_eq", "start": [1559, 1], "end": [1565, 45], "traced_tactics": [{"tactic": "simp only [iInter, iInf_subtype']", "annotated_tactic": ["simp only [<a>iInter</a>, <a>iInf_subtype'</a>]", [{"full_name": "Set.iInter", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [199, 5], "def_end_pos": [199, 11]}, {"full_name": "iInf_subtype'", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1158, 9], "def_end_pos": [1158, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\n\u22a2 f '' \u22c2 i, \u22c2 (hi : p i), s i hi = \u22c2 i, \u22c2 (hi : p i), f '' s i hi", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\n\u22a2 f '' \u2a05 x, s \u2191x \u22ef = \u2a05 x, f '' s \u2191x \u22ef"}, {"tactic": "haveI : Nonempty { i // p i } := nonempty_subtype.2 hp", "annotated_tactic": ["haveI : <a>Nonempty</a> { i // p i } := <a>nonempty_subtype</a>.2 hp", [{"full_name": "Nonempty", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [704, 17], "def_end_pos": [704, 25]}, {"full_name": "nonempty_subtype", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nonempty.lean", "def_pos": [71, 9], "def_end_pos": [71, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\n\u22a2 f '' \u2a05 x, s \u2191x \u22ef = \u2a05 x, f '' s \u2191x \u22ef", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\nthis : Nonempty { i // p i }\n\u22a2 f '' \u2a05 x, s \u2191x \u22ef = \u2a05 x, f '' s \u2191x \u22ef"}, {"tactic": "apply InjOn.image_iInter_eq", "annotated_tactic": ["apply <a>InjOn.image_iInter_eq</a>", [{"full_name": "Set.InjOn.image_iInter_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1541, 9], "def_end_pos": [1541, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\nthis : Nonempty { i // p i }\n\u22a2 f '' \u2a05 x, s \u2191x \u22ef = \u2a05 x, f '' s \u2191x \u22ef", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\nthis : Nonempty { i // p i }\n\u22a2 InjOn f (\u22c3 i, s \u2191i \u22ef)"}, {"tactic": "simpa only [iUnion, iSup_subtype'] using h", "annotated_tactic": ["simpa only [<a>iUnion</a>, <a>iSup_subtype'</a>] using h", [{"full_name": "Set.iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [194, 5], "def_end_pos": [194, 11]}, {"full_name": "iSup_subtype'", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1153, 9], "def_end_pos": [1153, 22]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\nthis : Nonempty { i // p i }\n\u22a2 InjOn f (\u22c3 i, s \u2191i \u22ef)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.right_eq_union", "start": [1549, 1], "end": [1549, 84], "traced_tactics": [{"tactic": "rw [eq_comm, union_eq_right]", "annotated_tactic": ["rw [<a>eq_comm</a>, <a>union_eq_right</a>]", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "Finset.union_eq_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1546, 15], "def_end_pos": [1546, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u v : Finset \u03b1\na b : \u03b1\n\u22a2 s = t \u222a s \u2194 t \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Complex.cos_periodic", "start": [1179, 1], "end": [1180, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/MinMax.lean", "full_name": "List.minimum_le_of_mem'", "start": [369, 1], "end": [370, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "bddBelow_def", "start": [103, 1], "end": [104, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.SameCycle.symm", "start": [70, 1], "end": [71, 47], "traced_tactics": [{"tactic": "rw [zpow_neg, \u2190 hi, inv_apply_self]", "annotated_tactic": ["rw [<a>zpow_neg</a>, \u2190 hi, <a>inv_apply_self</a>]", [{"full_name": "zpow_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [293, 9], "def_end_pos": [293, 17]}, {"full_name": "Equiv.Perm.inv_apply_self", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [76, 9], "def_end_pos": [76, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\np : \u03b1 \u2192 Prop\nx y z : \u03b1\nx\u271d : SameCycle f x y\ni : \u2124\nhi : (f ^ i) x = y\n\u22a2 (f ^ (-i)) y = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.univ_inter", "start": [988, 1], "end": [988, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "full_name": "SeminormFamily.comp_apply", "start": [896, 1], "end": [898, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "Ideal.IsPrincipal.of_comap", "start": [391, 1], "end": [395, 78], "traced_tactics": [{"tactic": "rw [Ideal.submodule_span_eq, \u2190 Set.image_singleton, \u2190 Ideal.map_span,\n  Ideal.span_singleton_generator, Ideal.map_comap_of_surjective f hf]", "annotated_tactic": ["rw [<a>Ideal.submodule_span_eq</a>, \u2190 <a>Set.image_singleton</a>, \u2190 <a>Ideal.map_span</a>,\n        <a>Ideal.span_singleton_generator</a>, <a>Ideal.map_comap_of_surjective</a> f hf]", [{"full_name": "Ideal.submodule_span_eq", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [119, 9], "def_end_pos": [119, 26]}, {"full_name": "Set.image_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [335, 9], "def_end_pos": [335, 24]}, {"full_name": "Ideal.map_span", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [1514, 9], "def_end_pos": [1514, 17]}, {"full_name": "Ideal.span_singleton_generator", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean", "def_pos": [97, 9], "def_end_pos": [97, 46]}, {"full_name": "Ideal.map_comap_of_surjective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [1659, 9], "def_end_pos": [1659, 32]}]], "state_before": "R : Type u\nM : Type v\nS : Type u_1\nN : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nf : R \u2192+* S\nhf : Surjective \u21d1f\nI : Ideal S\nhI : IsPrincipal (comap f I)\n\u22a2 I = Submodule.span S {f (IsPrincipal.generator (comap f I))}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "full_name": "quadraticChar_neg_one", "start": [303, 1], "end": [310, 85], "traced_tactics": [{"tactic": "have h := quadraticChar_eq_pow_of_char_ne_two hF (neg_ne_zero.mpr one_ne_zero)", "annotated_tactic": ["have h := <a>quadraticChar_eq_pow_of_char_ne_two</a> hF (neg_ne_zero.mpr <a>one_ne_zero</a>)", [{"full_name": "quadraticChar_eq_pow_of_char_ne_two", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [203, 9], "def_end_pos": [203, 44]}, {"full_name": "one_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\n\u22a2 (quadraticChar F) (-1) = \u03c7\u2084 \u2191(Fintype.card F)", "state_after": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nh : (quadraticChar F) (-1) = if (-1) ^ (Fintype.card F / 2) = 1 then 1 else -1\n\u22a2 (quadraticChar F) (-1) = \u03c7\u2084 \u2191(Fintype.card F)"}, {"tactic": "rw [h, \u03c7\u2084_eq_neg_one_pow (FiniteField.odd_card_of_char_ne_two hF)]", "annotated_tactic": ["rw [h, <a>\u03c7\u2084_eq_neg_one_pow</a> (<a>FiniteField.odd_card_of_char_ne_two</a> hF)]", [{"full_name": "ZMod.\u03c7\u2084_eq_neg_one_pow", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/ZModChar.lean", "def_pos": [80, 9], "def_end_pos": [80, 26]}, {"full_name": "FiniteField.odd_card_of_char_ne_two", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finite/Basic.lean", "def_pos": [606, 9], "def_end_pos": [606, 32]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nh : (quadraticChar F) (-1) = if (-1) ^ (Fintype.card F / 2) = 1 then 1 else -1\n\u22a2 (quadraticChar F) (-1) = \u03c7\u2084 \u2191(Fintype.card F)", "state_after": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nh : (quadraticChar F) (-1) = if (-1) ^ (Fintype.card F / 2) = 1 then 1 else -1\n\u22a2 (if (-1) ^ (Fintype.card F / 2) = 1 then 1 else -1) = (-1) ^ (Fintype.card F / 2)"}, {"tactic": "set n := Fintype.card F / 2", "annotated_tactic": ["set n := <a>Fintype.card</a> F / 2", [{"full_name": "Fintype.card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [61, 5], "def_end_pos": [61, 9]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nh : (quadraticChar F) (-1) = if (-1) ^ (Fintype.card F / 2) = 1 then 1 else -1\n\u22a2 (if (-1) ^ (Fintype.card F / 2) = 1 then 1 else -1) = (-1) ^ (Fintype.card F / 2)", "state_after": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nn : \u2115 := Fintype.card F / 2\nh : (quadraticChar F) (-1) = if (-1) ^ n = 1 then 1 else -1\n\u22a2 (if (-1) ^ n = 1 then 1 else -1) = (-1) ^ n"}, {"tactic": "cases' Nat.even_or_odd n with h\u2082 h\u2082", "annotated_tactic": ["cases' <a>Nat.even_or_odd</a> n with h\u2082 h\u2082", [{"full_name": "Nat.even_or_odd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Parity.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nn : \u2115 := Fintype.card F / 2\nh : (quadraticChar F) (-1) = if (-1) ^ n = 1 then 1 else -1\n\u22a2 (if (-1) ^ n = 1 then 1 else -1) = (-1) ^ n", "state_after": "case inl\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nn : \u2115 := Fintype.card F / 2\nh : (quadraticChar F) (-1) = if (-1) ^ n = 1 then 1 else -1\nh\u2082 : Even n\n\u22a2 (if (-1) ^ n = 1 then 1 else -1) = (-1) ^ n\n\ncase inr\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nn : \u2115 := Fintype.card F / 2\nh : (quadraticChar F) (-1) = if (-1) ^ n = 1 then 1 else -1\nh\u2082 : Odd n\n\u22a2 (if (-1) ^ n = 1 then 1 else -1) = (-1) ^ n"}, {"tactic": "simp only [Even.neg_one_pow h\u2082, eq_self_iff_true, if_true]", "annotated_tactic": ["simp only [<a>Even.neg_one_pow</a> h\u2082, <a>eq_self_iff_true</a>, <a>if_true</a>]", [{"full_name": "Even.neg_one_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Parity.lean", "def_pos": [172, 9], "def_end_pos": [172, 25]}, {"full_name": "eq_self_iff_true", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1368, 9], "def_end_pos": [1368, 25]}, {"full_name": "if_true", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [24, 17], "def_end_pos": [24, 24]}]], "state_before": "case inl\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nn : \u2115 := Fintype.card F / 2\nh : (quadraticChar F) (-1) = if (-1) ^ n = 1 then 1 else -1\nh\u2082 : Even n\n\u22a2 (if (-1) ^ n = 1 then 1 else -1) = (-1) ^ n", "state_after": "no goals"}, {"tactic": "simp only [Odd.neg_one_pow h\u2082, Ring.neg_one_ne_one_of_char_ne_two hF, ite_false]", "annotated_tactic": ["simp only [<a>Odd.neg_one_pow</a> h\u2082, <a>Ring.neg_one_ne_one_of_char_ne_two</a> hF, <a>ite_false</a>]", [{"full_name": "Odd.neg_one_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Parity.lean", "def_pos": [439, 9], "def_end_pos": [439, 24]}, {"full_name": "Ring.neg_one_ne_one_of_char_ne_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharP/Basic.lean", "def_pos": [523, 9], "def_end_pos": [523, 43]}, {"full_name": "ite_false", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [89, 17], "def_end_pos": [89, 26]}]], "state_before": "case inr\nF : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\nhF : ringChar F \u2260 2\nn : \u2115 := Fintype.card F / 2\nh : (quadraticChar F) (-1) = if (-1) ^ n = 1 then 1 else -1\nh\u2082 : Odd n\n\u22a2 (if (-1) ^ n = 1 then 1 else -1) = (-1) ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/PathConnected.lean", "full_name": "Path.trans_apply", "start": [334, 1], "end": [338, 58], "traced_tactics": [{"tactic": "split_ifs <;> rw [extend_extends]", "annotated_tactic": ["split_ifs <;> rw [<a>extend_extends</a>]", [{"full_name": "Path.extend_extends", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/PathConnected.lean", "def_pos": [268, 9], "def_end_pos": [268, 23]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\n\u03b3' : Path y z\nt : \u2191I\n\u22a2 (if \u2191t \u2264 1 / 2 then extend \u03b3 (2 * \u2191t) else extend \u03b3' (2 * \u2191t - 1)) =\n    if h : \u2191t \u2264 1 / 2 then \u03b3 { val := 2 * \u2191t, property := \u22ef } else \u03b3' { val := 2 * \u2191t - 1, property := \u22ef }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Inv.lean", "full_name": "ENNReal.div_le_div_right", "start": [375, 21], "end": [376, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Perfect.lean", "full_name": "iterateFrobeniusEquiv_add", "start": [100, 1], "end": [102, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.coe_zero", "start": [357, 11], "end": [357, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "isGLB_empty_iff", "start": [889, 9], "end": [890, 15], "traced_tactics": [{"tactic": "simp [IsGLB]", "annotated_tactic": ["simp [<a>IsGLB</a>]", [{"full_name": "IsGLB", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [81, 5], "def_end_pos": [81, 10]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns t : Set \u03b1\na b : \u03b1\n\u22a2 IsGLB \u2205 a \u2194 IsTop a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.preimage_const_mul_Ioc_of_neg", "start": [755, 1], "end": [757, 66], "traced_tactics": [{"tactic": "simpa only [mul_comm] using preimage_mul_const_Ioc_of_neg a b h", "annotated_tactic": ["simpa only [<a>mul_comm</a>] using <a>preimage_mul_const_Ioc_of_neg</a> a b h", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Set.preimage_mul_const_Ioc_of_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Interval.lean", "def_pos": [668, 9], "def_end_pos": [668, 38]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\na\u271d a b c : \u03b1\nh : c < 0\n\u22a2 (fun x => c * x) \u207b\u00b9' Ioc a b = Ico (b / c) (a / c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.coe_sumElim", "start": [1308, 1], "end": [1310, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/CharP/Basic.lean", "full_name": "ringChar.of_eq", "start": [253, 1], "end": [254, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/MeanValue.lean", "full_name": "antitone_of_hasDerivAt_nonpos", "start": [1043, 1], "end": [1048, 35], "traced_tactics": [{"tactic": "rw [(hf _).deriv]", "annotated_tactic": ["rw [(hf _).<a>deriv</a>]", [{"full_name": "HasDerivAt.deriv", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "def_pos": [452, 9], "def_end_pos": [452, 25]}]], "state_before": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf f' : \u211d \u2192 \u211d\nhf : \u2200 (x : \u211d), HasDerivAt f (f' x) x\nhf' : f' \u2264 0\nx : \u211d\n\u22a2 deriv f x \u2264 0", "state_after": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf f' : \u211d \u2192 \u211d\nhf : \u2200 (x : \u211d), HasDerivAt f (f' x) x\nhf' : f' \u2264 0\nx : \u211d\n\u22a2 f' x \u2264 0"}, {"tactic": "exact hf' _", "annotated_tactic": ["exact hf' _", []], "state_before": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf f' : \u211d \u2192 \u211d\nhf : \u2200 (x : \u211d), HasDerivAt f (f' x) x\nhf' : f' \u2264 0\nx : \u211d\n\u22a2 f' x \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Ray.lean", "full_name": "SameRay.of_subsingleton'", "start": [69, 1], "end": [71, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousFunction/Basic.lean", "full_name": "ContinuousMap.copy_eq", "start": [128, 1], "end": [129, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Reverse.lean", "full_name": "Polynomial.coeff_one_reverse", "start": [341, 1], "end": [347, 51], "traced_tactics": [{"tactic": "rw [coeff_reverse, nextCoeff]", "annotated_tactic": ["rw [<a>coeff_reverse</a>, <a>nextCoeff</a>]", [{"full_name": "Polynomial.coeff_reverse", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [255, 9], "def_end_pos": [255, 22]}, {"full_name": "Polynomial.nextCoeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [570, 5], "def_end_pos": [570, 14]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\n\u22a2 coeff (reverse f) 1 = nextCoeff f", "state_after": "R : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\n\u22a2 coeff f ((revAt (natDegree f)) 1) = if natDegree f = 0 then 0 else coeff f (natDegree f - 1)"}, {"tactic": "split_ifs with hf", "annotated_tactic": ["split_ifs with hf", []], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\n\u22a2 coeff f ((revAt (natDegree f)) 1) = if natDegree f = 0 then 0 else coeff f (natDegree f - 1)", "state_after": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\nhf : natDegree f = 0\n\u22a2 coeff f ((revAt (natDegree f)) 1) = 0\n\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\nhf : \u00acnatDegree f = 0\n\u22a2 coeff f ((revAt (natDegree f)) 1) = coeff f (natDegree f - 1)"}, {"tactic": "have : coeff f 1 = 0 := coeff_eq_zero_of_natDegree_lt (by simp only [hf, zero_lt_one])", "annotated_tactic": ["have : <a>coeff</a> f 1 = 0 := <a>coeff_eq_zero_of_natDegree_lt</a> (by simp only [hf, <a>zero_lt_one</a>])", [{"full_name": "Polynomial.coeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [666, 5], "def_end_pos": [666, 10]}, {"full_name": "Polynomial.coeff_eq_zero_of_natDegree_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [350, 9], "def_end_pos": [350, 38]}, {"full_name": "zero_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}]], "state_before": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\nhf : natDegree f = 0\n\u22a2 coeff f ((revAt (natDegree f)) 1) = 0", "state_after": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\nhf : natDegree f = 0\nthis : coeff f 1 = 0\n\u22a2 coeff f ((revAt (natDegree f)) 1) = 0"}, {"tactic": "simp [*, revAt]", "annotated_tactic": ["simp [*, <a>revAt</a>]", [{"full_name": "Polynomial.revAt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [59, 5], "def_end_pos": [59, 10]}]], "state_before": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\nhf : natDegree f = 0\nthis : coeff f 1 = 0\n\u22a2 coeff f ((revAt (natDegree f)) 1) = 0", "state_after": "no goals"}, {"tactic": "simp only [hf, zero_lt_one]", "annotated_tactic": ["simp only [hf, <a>zero_lt_one</a>]", [{"full_name": "zero_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\nhf : natDegree f = 0\n\u22a2 natDegree f < 1", "state_after": "no goals"}, {"tactic": "rw [revAt_le]", "annotated_tactic": ["rw [<a>revAt_le</a>]", [{"full_name": "Polynomial.revAt_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [77, 9], "def_end_pos": [77, 17]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\nhf : \u00acnatDegree f = 0\n\u22a2 coeff f ((revAt (natDegree f)) 1) = coeff f (natDegree f - 1)", "state_after": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\nhf : \u00acnatDegree f = 0\n\u22a2 1 \u2264 natDegree f"}, {"tactic": "exact Nat.succ_le_iff.2 (pos_iff_ne_zero.2 hf)", "annotated_tactic": ["exact <a>Nat.succ_le_iff</a>.2 (<a>pos_iff_ne_zero</a>.2 hf)", [{"full_name": "Nat.succ_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [81, 7], "def_end_pos": [81, 18]}, {"full_name": "pos_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [230, 3], "def_end_pos": [230, 14]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf\u271d f : R[X]\nhf : \u00acnatDegree f = 0\n\u22a2 1 \u2264 natDegree f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Equiv.lean", "full_name": "UniformEquiv.trans_apply", "start": [121, 1], "end": [122, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.nontrivial_of_image", "start": [1235, 1], "end": [1237, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "sup_sInf_le_iInf_sup", "start": [1912, 1], "end": [1913, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Relation.lean", "full_name": "swap_eq_iff", "start": [97, 1], "end": [98, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Subsemiring.mem_mk'", "start": [247, 1], "end": [249, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.inter_univ", "start": [984, 1], "end": [984, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.eval\u2082_zero'_apply", "start": [1539, 1], "end": [1541, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.image_span_subset", "start": [111, 1], "end": [112, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.support_eq_empty_iff", "start": [310, 1], "end": [312, 35], "traced_tactics": [{"tactic": "simp_rw [Finset.ext_iff, mem_support, Finset.not_mem_empty, iff_false_iff, not_not,\n  Equiv.Perm.ext_iff, one_apply]", "annotated_tactic": ["simp_rw [<a>Finset.ext_iff</a>, <a>mem_support</a>, <a>Finset.not_mem_empty</a>, <a>iff_false_iff</a>, <a>not_not</a>,\n    <a>Equiv.Perm.ext_iff</a>, <a>one_apply</a>]", [{"full_name": "Finset.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 16]}, {"full_name": "Equiv.Perm.mem_support", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [297, 9], "def_end_pos": [297, 20]}, {"full_name": "Finset.not_mem_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [554, 9], "def_end_pos": [554, 22]}, {"full_name": "iff_false_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [192, 9], "def_end_pos": [192, 22]}, {"full_name": "Classical.not_not", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [128, 24], "def_end_pos": [128, 31]}, {"full_name": "Equiv.Perm.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [155, 9], "def_end_pos": [155, 21]}, {"full_name": "Equiv.Perm.one_apply", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [71, 9], "def_end_pos": [71, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g \u03c3 : Perm \u03b1\n\u22a2 support \u03c3 = \u2205 \u2194 \u03c3 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Module.lean", "full_name": "Complex.rank_rat_complex", "start": [614, 1], "end": [617, 34], "traced_tactics": [{"tactic": "refine (Free.rank_eq_mk_of_infinite_lt \u211a \u2102 ?_).trans mk_complex", "annotated_tactic": ["refine (<a>Free.rank_eq_mk_of_infinite_lt</a> \u211a \u2102 ?_).<a>trans</a> <a>mk_complex</a>", [{"full_name": "Module.Free.rank_eq_mk_of_infinite_lt", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Free.lean", "def_pos": [95, 7], "def_end_pos": [95, 32]}, {"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}, {"full_name": "mk_complex", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Cardinality.lean", "def_pos": [25, 9], "def_end_pos": [25, 19]}]], "state_before": "\u22a2 Module.rank \u211a \u2102 = \ud835\udd20", "state_after": "\u22a2 Cardinal.lift.{0, 0} #\u211a < Cardinal.lift.{0, 0} #\u2102"}, {"tactic": "simpa using aleph0_lt_continuum", "annotated_tactic": ["simpa using <a>aleph0_lt_continuum</a>", [{"full_name": "Cardinal.aleph0_lt_continuum", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Continuum.lean", "def_pos": [75, 9], "def_end_pos": [75, 28]}]], "state_before": "\u22a2 Cardinal.lift.{0, 0} #\u211a < Cardinal.lift.{0, 0} #\u2102", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/NNReal.lean", "full_name": "Real.toNNReal_eq_one", "start": [665, 1], "end": [666, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Minpoly/Field.lean", "full_name": "minpoly.coeff_zero_ne_zero", "start": [271, 1], "end": [273, 46], "traced_tactics": [{"tactic": "contrapose! h", "annotated_tactic": ["contrapose! h", []], "state_before": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b3 : Field A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\nh : x \u2260 0\n\u22a2 coeff (minpoly A x) 0 \u2260 0", "state_after": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b3 : Field A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\nh : coeff (minpoly A x) 0 = 0\n\u22a2 x = 0"}, {"tactic": "simpa only [hx, coeff_zero_eq_zero] using h", "annotated_tactic": ["simpa only [hx, <a>coeff_zero_eq_zero</a>] using h", [{"full_name": "minpoly.coeff_zero_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Field.lean", "def_pos": [260, 9], "def_end_pos": [260, 27]}]], "state_before": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b3 : Field A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\nh : coeff (minpoly A x) 0 = 0\n\u22a2 x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "full_name": "MeasureTheory.Measure.map_mono_of_aemeasurable", "start": [391, 1], "end": [393, 77], "traced_tactics": [{"tactic": "simpa [hf, hs, hf.mono_measure h] using h (f \u207b\u00b9' s)", "annotated_tactic": ["simpa [hf, hs, hf.mono_measure h] using h (f \u207b\u00b9' s)", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nR : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\nf\u271d g : \u03b1 \u2192 \u03b2\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u03b4\nh : \u03bc \u2264 \u03bd\nhf : AEMeasurable f \u03bd\ns : Set \u03b4\nhs : MeasurableSet s\n\u22a2 \u2191\u2191(map f \u03bc) s \u2264 \u2191\u2191(map f \u03bd) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.pow_mem_pow", "start": [946, 1], "end": [952, 44], "traced_tactics": [{"tactic": "rw [pow_zero]", "annotated_tactic": ["rw [<a>pow_zero</a>]", [{"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : Monoid \u03b1\ns t : Set \u03b1\na : \u03b1\nm n : \u2115\nha : a \u2208 s\n\u22a2 a ^ 0 \u2208 s ^ 0", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : Monoid \u03b1\ns t : Set \u03b1\na : \u03b1\nm n : \u2115\nha : a \u2208 s\n\u22a2 1 \u2208 s ^ 0"}, {"tactic": "exact one_mem_one", "annotated_tactic": ["exact <a>one_mem_one</a>", [{"full_name": "Set.one_mem_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 20]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : Monoid \u03b1\ns t : Set \u03b1\na : \u03b1\nm n : \u2115\nha : a \u2208 s\n\u22a2 1 \u2208 s ^ 0", "state_after": "no goals"}, {"tactic": "rw [pow_succ]", "annotated_tactic": ["rw [<a>pow_succ</a>]", [{"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : Monoid \u03b1\ns t : Set \u03b1\na : \u03b1\nm n\u271d : \u2115\nha : a \u2208 s\nn : \u2115\n\u22a2 a ^ (n + 1) \u2208 s ^ (n + 1)", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : Monoid \u03b1\ns t : Set \u03b1\na : \u03b1\nm n\u271d : \u2115\nha : a \u2208 s\nn : \u2115\n\u22a2 a * a ^ n \u2208 s ^ (n + 1)"}, {"tactic": "exact mul_mem_mul ha (pow_mem_pow ha _)", "annotated_tactic": ["exact <a>mul_mem_mul</a> ha (pow_mem_pow ha _)", [{"full_name": "Set.mul_mem_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [347, 9], "def_end_pos": [347, 20]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : Monoid \u03b1\ns t : Set \u03b1\na : \u03b1\nm n\u271d : \u2115\nha : a \u2208 s\nn : \u2115\n\u22a2 a * a ^ n \u2208 s ^ (n + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/MeanValue.lean", "full_name": "constant_of_derivWithin_zero", "start": [403, 1], "end": [408, 60], "traced_tactics": [{"tactic": "have H : \u2200 x \u2208 Ico a b, \u2016derivWithin f (Icc a b) x\u2016 \u2264 0 := by\n  simpa only [norm_le_zero_iff] using fun x hx => hderiv x hx", "annotated_tactic": ["have H : \u2200 x \u2208 <a>Ico</a> a b, \u2016<a>derivWithin</a> f (<a>Icc</a> a b) x\u2016 \u2264 0 := by\n    simpa only [<a>norm_le_zero_iff</a>] using fun x hx => hderiv x hx", [{"full_name": "Set.Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [49, 5], "def_end_pos": [49, 8]}, {"full_name": "derivWithin", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "def_pos": [140, 5], "def_end_pos": [140, 16]}, {"full_name": "Set.Icc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [59, 5], "def_end_pos": [59, 8]}, {"full_name": "norm_le_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2112, 30], "def_end_pos": [2112, 46]}]], "state_before": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 E\na b : \u211d\nhdiff : DifferentiableOn \u211d f (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, derivWithin f (Icc a b) x = 0\n\u22a2 \u2200 x \u2208 Icc a b, f x = f a", "state_after": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 E\na b : \u211d\nhdiff : DifferentiableOn \u211d f (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, derivWithin f (Icc a b) x = 0\nH : \u2200 x \u2208 Ico a b, \u2016derivWithin f (Icc a b) x\u2016 \u2264 0\n\u22a2 \u2200 x \u2208 Icc a b, f x = f a"}, {"tactic": "simpa only [zero_mul, norm_le_zero_iff, sub_eq_zero] using fun x hx =>\n  norm_image_sub_le_of_norm_deriv_le_segment hdiff H x hx", "annotated_tactic": ["simpa only [<a>zero_mul</a>, <a>norm_le_zero_iff</a>, <a>sub_eq_zero</a>] using fun x hx =>\n    <a>norm_image_sub_le_of_norm_deriv_le_segment</a> hdiff H x hx", [{"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}, {"full_name": "norm_le_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2112, 30], "def_end_pos": [2112, 46]}, {"full_name": "sub_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [880, 3], "def_end_pos": [880, 14]}, {"full_name": "norm_image_sub_le_of_norm_deriv_le_segment", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/MeanValue.lean", "def_pos": [370, 9], "def_end_pos": [370, 51]}]], "state_before": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 E\na b : \u211d\nhdiff : DifferentiableOn \u211d f (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, derivWithin f (Icc a b) x = 0\nH : \u2200 x \u2208 Ico a b, \u2016derivWithin f (Icc a b) x\u2016 \u2264 0\n\u22a2 \u2200 x \u2208 Icc a b, f x = f a", "state_after": "no goals"}, {"tactic": "simpa only [norm_le_zero_iff] using fun x hx => hderiv x hx", "annotated_tactic": ["simpa only [<a>norm_le_zero_iff</a>] using fun x hx => hderiv x hx", [{"full_name": "norm_le_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2112, 30], "def_end_pos": [2112, 46]}]], "state_before": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : \u211d \u2192 E\na b : \u211d\nhdiff : DifferentiableOn \u211d f (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, derivWithin f (Icc a b) x = 0\n\u22a2 \u2200 x \u2208 Ico a b, \u2016derivWithin f (Icc a b) x\u2016 \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/LiminfLimsup.lean", "full_name": "Antitone.map_limsup_of_continuousAt", "start": [391, 1], "end": [396, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Directed.lean", "full_name": "Directed.mono_comp", "start": [105, 1], "end": [107, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Add.lean", "full_name": "deriv_neg", "start": [253, 1], "end": [254, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Function/Support.lean", "full_name": "Set.image_inter_mulSupport_eq", "start": [378, 1], "end": [380, 61], "traced_tactics": [{"tactic": "rw [mulSupport_comp_eq_preimage f g, image_inter_preimage]", "annotated_tactic": ["rw [<a>mulSupport_comp_eq_preimage</a> f g, <a>image_inter_preimage</a>]", [{"full_name": "Function.mulSupport_comp_eq_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Support.lean", "def_pos": [195, 9], "def_end_pos": [195, 36]}, {"full_name": "Set.image_inter_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [516, 9], "def_end_pos": [516, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Type u_3\ninst\u271d : One M\nf : \u03b1 \u2192 M\ns : Set \u03b2\ng : \u03b2 \u2192 \u03b1\n\u22a2 g '' s \u2229 mulSupport f = g '' (s \u2229 mulSupport (f \u2218 g))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Quotient.lean", "full_name": "MulAction.Quotient.mk_smul_out'", "start": [110, 1], "end": [111, 95], "traced_tactics": [{"tactic": "rw [\u2190 Quotient.smul_mk, QuotientGroup.out_eq']", "annotated_tactic": ["rw [\u2190 <a>Quotient.smul_mk</a>, <a>QuotientGroup.out_eq'</a>]", [{"full_name": "MulAction.Quotient.smul_mk", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Quotient.lean", "def_pos": [96, 9], "def_end_pos": [96, 25]}, {"full_name": "QuotientGroup.out_eq'", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Coset.lean", "def_pos": [512, 9], "def_end_pos": [512, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : MulAction \u03b2 \u03b1\nH : Subgroup \u03b1\ninst\u271d : QuotientAction \u03b2 H\nb : \u03b2\nq : \u03b1 \u29f8 H\n\u22a2 \u2191(b \u2022 Quotient.out' q) = b \u2022 q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/CauSeq/Basic.lean", "full_name": "IsCauSeq.cauchy\u2082", "start": [102, 1], "end": [107, 34], "traced_tactics": [{"tactic": "refine' (hf _ (half_pos \u03b50)).imp fun i hi j ij k ik => _", "annotated_tactic": ["refine' (hf _ (<a>half_pos</a> \u03b50)).<a>imp</a> fun i hi j ij k ik => _", [{"full_name": "half_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [524, 9], "def_end_pos": [524, 17]}, {"full_name": "Exists.imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [126, 9], "def_end_pos": [126, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nhf : IsCauSeq abv f\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\n\u22a2 \u2203 i, \u2200 j \u2265 i, \u2200 k \u2265 i, abv (f j - f k) < \u03b5", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nhf : IsCauSeq abv f\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\ni : \u2115\nhi : \u2200 j \u2265 i, abv (f j - f i) < \u03b5 / 2\nj : \u2115\nij : j \u2265 i\nk : \u2115\nik : k \u2265 i\n\u22a2 abv (f j - f k) < \u03b5"}, {"tactic": "rw [\u2190 add_halves \u03b5]", "annotated_tactic": ["rw [\u2190 <a>add_halves</a> \u03b5]", [{"full_name": "add_halves", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [515, 9], "def_end_pos": [515, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nhf : IsCauSeq abv f\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\ni : \u2115\nhi : \u2200 j \u2265 i, abv (f j - f i) < \u03b5 / 2\nj : \u2115\nij : j \u2265 i\nk : \u2115\nik : k \u2265 i\n\u22a2 abv (f j - f k) < \u03b5", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nhf : IsCauSeq abv f\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\ni : \u2115\nhi : \u2200 j \u2265 i, abv (f j - f i) < \u03b5 / 2\nj : \u2115\nij : j \u2265 i\nk : \u2115\nik : k \u2265 i\n\u22a2 abv (f j - f k) < \u03b5 / 2 + \u03b5 / 2"}, {"tactic": "refine' lt_of_le_of_lt (abv_sub_le abv _ _ _) (add_lt_add (hi _ ij) _)", "annotated_tactic": ["refine' <a>lt_of_le_of_lt</a> (<a>abv_sub_le</a> abv _ _ _) (<a>add_lt_add</a> (hi _ ij) _)", [{"full_name": "lt_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}, {"full_name": "IsAbsoluteValue.abv_sub_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/AbsoluteValue.lean", "def_pos": [403, 9], "def_end_pos": [403, 19]}, {"full_name": "add_lt_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [167, 7], "def_end_pos": [167, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nhf : IsCauSeq abv f\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\ni : \u2115\nhi : \u2200 j \u2265 i, abv (f j - f i) < \u03b5 / 2\nj : \u2115\nij : j \u2265 i\nk : \u2115\nik : k \u2265 i\n\u22a2 abv (f j - f k) < \u03b5 / 2 + \u03b5 / 2", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nhf : IsCauSeq abv f\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\ni : \u2115\nhi : \u2200 j \u2265 i, abv (f j - f i) < \u03b5 / 2\nj : \u2115\nij : j \u2265 i\nk : \u2115\nik : k \u2265 i\n\u22a2 abv (f i - f k) < \u03b5 / 2"}, {"tactic": "rw [abv_sub abv]", "annotated_tactic": ["rw [<a>abv_sub</a> abv]", [{"full_name": "IsAbsoluteValue.abv_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/AbsoluteValue.lean", "def_pos": [422, 9], "def_end_pos": [422, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nhf : IsCauSeq abv f\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\ni : \u2115\nhi : \u2200 j \u2265 i, abv (f j - f i) < \u03b5 / 2\nj : \u2115\nij : j \u2265 i\nk : \u2115\nik : k \u2265 i\n\u22a2 abv (f i - f k) < \u03b5 / 2", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nhf : IsCauSeq abv f\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\ni : \u2115\nhi : \u2200 j \u2265 i, abv (f j - f i) < \u03b5 / 2\nj : \u2115\nij : j \u2265 i\nk : \u2115\nik : k \u2265 i\n\u22a2 abv (f k - f i) < \u03b5 / 2"}, {"tactic": "exact hi _ ik", "annotated_tactic": ["exact hi _ ik", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\nhf : IsCauSeq abv f\n\u03b5 : \u03b1\n\u03b50 : 0 < \u03b5\ni : \u2115\nhi : \u2200 j \u2265 i, abv (f j - f i) < \u03b5 / 2\nj : \u2115\nij : j \u2265 i\nk : \u2115\nik : k \u2265 i\n\u22a2 abv (f k - f i) < \u03b5 / 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean", "full_name": "Filter.Tendsto.continuous_of_equicontinuous", "start": [963, 1], "end": [965, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Nat.xgcdAux_succ", "start": [54, 1], "end": [55, 96], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Monoid.lean", "full_name": "tendsto_list_prod", "start": [528, 1], "end": [537, 74], "traced_tactics": [{"tactic": "simp [tendsto_const_nhds]", "annotated_tactic": ["simp [<a>tendsto_const_nhds</a>]", [{"full_name": "tendsto_const_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [975, 9], "def_end_pos": [975, 27]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\nf : \u03b9 \u2192 \u03b1 \u2192 M\nx : Filter \u03b1\na : \u03b9 \u2192 M\nx\u271d : \u2200 i \u2208 [], Tendsto (f i) x (\ud835\udcdd (a i))\n\u22a2 Tendsto (fun b => List.prod (List.map (fun c => f c b) [])) x (\ud835\udcdd (List.prod (List.map a [])))", "state_after": "no goals"}, {"tactic": "simp only [List.map_cons, List.prod_cons]", "annotated_tactic": ["simp only [<a>List.map_cons</a>, <a>List.prod_cons</a>]", [{"full_name": "List.map_cons", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [118, 17], "def_end_pos": [118, 25]}, {"full_name": "List.prod_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [43, 9], "def_end_pos": [43, 18]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\nf\u271d : \u03b9 \u2192 \u03b1 \u2192 M\nx : Filter \u03b1\na : \u03b9 \u2192 M\nf : \u03b9\nl : List \u03b9\nh : \u2200 i \u2208 f :: l, Tendsto (f\u271d i) x (\ud835\udcdd (a i))\n\u22a2 Tendsto (fun b => List.prod (List.map (fun c => f\u271d c b) (f :: l))) x (\ud835\udcdd (List.prod (List.map a (f :: l))))", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\nf\u271d : \u03b9 \u2192 \u03b1 \u2192 M\nx : Filter \u03b1\na : \u03b9 \u2192 M\nf : \u03b9\nl : List \u03b9\nh : \u2200 i \u2208 f :: l, Tendsto (f\u271d i) x (\ud835\udcdd (a i))\n\u22a2 Tendsto (fun b => f\u271d f b * List.prod (List.map (fun c => f\u271d c b) l)) x (\ud835\udcdd (a f * List.prod (List.map a l)))"}, {"tactic": "exact\n  (h f (List.mem_cons_self _ _)).mul\n    (tendsto_list_prod l fun c hc => h c (List.mem_cons_of_mem _ hc))", "annotated_tactic": ["exact\n      (h f (<a>List.mem_cons_self</a> _ _)).<a>mul</a>\n        (tendsto_list_prod l fun c hc => h c (<a>List.mem_cons_of_mem</a> _ hc))", [{"full_name": "List.mem_cons_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [67, 9], "def_end_pos": [67, 22]}, {"full_name": "Filter.Tendsto.mul", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Monoid.lean", "def_pos": [121, 9], "def_end_pos": [121, 27]}, {"full_name": "List.mem_cons_of_mem", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [69, 9], "def_end_pos": [69, 24]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\nf\u271d : \u03b9 \u2192 \u03b1 \u2192 M\nx : Filter \u03b1\na : \u03b9 \u2192 M\nf : \u03b9\nl : List \u03b9\nh : \u2200 i \u2208 f :: l, Tendsto (f\u271d i) x (\ud835\udcdd (a i))\n\u22a2 Tendsto (fun b => f\u271d f b * List.prod (List.map (fun c => f\u271d c b) l)) x (\ud835\udcdd (a f * List.prod (List.map a l)))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Prod/PProd.lean", "full_name": "Function.Injective.pprod_map", "start": [46, 1], "end": [50, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Comp.lean", "full_name": "HasDerivAt.scomp_hasDerivWithinAt", "start": [98, 1], "end": [100, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/TypeTags.lean", "full_name": "Additive.ofMul_symm_eq", "start": [61, 1], "end": [62, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "eq_bot_of_bot_eq_top", "start": [638, 1], "end": [639, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.sInter_eq_univ", "start": [1095, 1], "end": [1096, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/Inv.lean", "full_name": "Mathlib.Meta.NormNum.isRat_mkRat", "start": [56, 1], "end": [58, 85], "traced_tactics": [{"tactic": "rw [Rat.mkRat_eq_div]", "annotated_tactic": ["rw [<a>Rat.mkRat_eq_div</a>]", [{"full_name": "Rat.mkRat_eq_div", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [562, 9], "def_end_pos": [562, 21]}]], "state_before": "n\u271d\u00b9 num\u271d : \u2124\nn\u271d denom\u271d : \u2115\ninv\u271d : Invertible \u2191denom\u271d\nh : \u2191n\u271d\u00b9 / \u2191n\u271d = \u2191num\u271d * \u215f\u2191denom\u271d\n\u22a2 IsRat (mkRat \u2191n\u271d\u00b9 \u2191n\u271d) num\u271d denom\u271d", "state_after": "n\u271d\u00b9 num\u271d : \u2124\nn\u271d denom\u271d : \u2115\ninv\u271d : Invertible \u2191denom\u271d\nh : \u2191n\u271d\u00b9 / \u2191n\u271d = \u2191num\u271d * \u215f\u2191denom\u271d\n\u22a2 IsRat (\u2191\u2191n\u271d\u00b9 / \u2191\u2191n\u271d) num\u271d denom\u271d"}, {"tactic": "exact \u27e8_, h\u27e9", "annotated_tactic": ["exact \u27e8_, h\u27e9", []], "state_before": "n\u271d\u00b9 num\u271d : \u2124\nn\u271d denom\u271d : \u2115\ninv\u271d : Invertible \u2191denom\u271d\nh : \u2191n\u271d\u00b9 / \u2191n\u271d = \u2191num\u271d * \u215f\u2191denom\u271d\n\u22a2 IsRat (\u2191\u2191n\u271d\u00b9 / \u2191\u2191n\u271d) num\u271d denom\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "Real.nndist_eq'", "start": [1351, 1], "end": [1352, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Defs.lean", "full_name": "AddLECancellable.add_tsub_cancel_left", "start": [306, 11], "end": [307, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Hom/Ring.lean", "full_name": "OrderRingHom.copy_eq", "start": [235, 1], "end": [236, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Torsion.lean", "full_name": "Submodule.noZeroSMulDivisors_iff_torsion_eq_bot", "start": [720, 1], "end": [737, 66], "traced_tactics": [{"tactic": "constructor <;> intro h", "annotated_tactic": ["constructor <;> intro h", []], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\n\u22a2 NoZeroSMulDivisors R M \u2194 torsion R M = \u22a5", "state_after": "case mp\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : NoZeroSMulDivisors R M\n\u22a2 torsion R M = \u22a5\n\ncase mpr\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\n\u22a2 NoZeroSMulDivisors R M"}, {"tactic": "haveI : NoZeroSMulDivisors R M := h", "annotated_tactic": ["haveI : <a>NoZeroSMulDivisors</a> R M := h", [{"full_name": "NoZeroSMulDivisors", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [569, 7], "def_end_pos": [569, 25]}]], "state_before": "case mp\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : NoZeroSMulDivisors R M\n\u22a2 torsion R M = \u22a5", "state_after": "case mp\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\n\u22a2 torsion R M = \u22a5"}, {"tactic": "rw [eq_bot_iff]", "annotated_tactic": ["rw [<a>eq_bot_iff</a>]", [{"full_name": "eq_bot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [331, 9], "def_end_pos": [331, 19]}]], "state_before": "case mp\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\n\u22a2 torsion R M = \u22a5", "state_after": "case mp\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\n\u22a2 torsion R M \u2264 \u22a5"}, {"tactic": "rintro x \u27e8a, hax\u27e9", "annotated_tactic": ["rintro x \u27e8a, hax\u27e9", []], "state_before": "case mp\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\n\u22a2 torsion R M \u2264 \u22a5", "state_after": "case mp.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : a \u2022 x = 0\n\u22a2 x \u2208 \u22a5"}, {"tactic": "change (a : R) \u2022 x = 0 at hax", "annotated_tactic": ["change (a : R) \u2022 x = 0 at hax", []], "state_before": "case mp.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : a \u2022 x = 0\n\u22a2 x \u2208 \u22a5", "state_after": "case mp.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : \u2191a \u2022 x = 0\n\u22a2 x \u2208 \u22a5"}, {"tactic": "cases' eq_zero_or_eq_zero_of_smul_eq_zero hax with h0 h0", "annotated_tactic": ["cases' <a>eq_zero_or_eq_zero_of_smul_eq_zero</a> hax with h0 h0", [{"full_name": "NoZeroSMulDivisors.eq_zero_or_eq_zero_of_smul_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [571, 3], "def_end_pos": [571, 37]}]], "state_before": "case mp.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : \u2191a \u2022 x = 0\n\u22a2 x \u2208 \u22a5", "state_after": "case mp.intro.inl\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : \u2191a \u2022 x = 0\nh0 : \u2191a = 0\n\u22a2 x \u2208 \u22a5\n\ncase mp.intro.inr\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : \u2191a \u2022 x = 0\nh0 : x = 0\n\u22a2 x \u2208 \u22a5"}, {"tactic": "exfalso", "annotated_tactic": ["exfalso", []], "state_before": "case mp.intro.inl\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : \u2191a \u2022 x = 0\nh0 : \u2191a = 0\n\u22a2 x \u2208 \u22a5", "state_after": "case mp.intro.inl\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : \u2191a \u2022 x = 0\nh0 : \u2191a = 0\n\u22a2 False"}, {"tactic": "exact nonZeroDivisors.coe_ne_zero a h0", "annotated_tactic": ["exact <a>nonZeroDivisors.coe_ne_zero</a> a h0", [{"full_name": "nonZeroDivisors.coe_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "def_pos": [166, 9], "def_end_pos": [166, 36]}]], "state_before": "case mp.intro.inl\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : \u2191a \u2022 x = 0\nh0 : \u2191a = 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "exact h0", "annotated_tactic": ["exact h0", []], "state_before": "case mp.intro.inr\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh this : NoZeroSMulDivisors R M\nx : M\na : \u21a5R\u2070\nhax : \u2191a \u2022 x = 0\nh0 : x = 0\n\u22a2 x \u2208 \u22a5", "state_after": "no goals"}, {"tactic": "by_cases ha : a = 0", "annotated_tactic": ["by_cases ha : a = 0", []], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\n\u22a2 a = 0 \u2228 x = 0", "state_after": "case pos\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : a = 0\n\u22a2 a = 0 \u2228 x = 0\n\ncase neg\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : \u00aca = 0\n\u22a2 a = 0 \u2228 x = 0"}, {"tactic": "left", "annotated_tactic": ["left", []], "state_before": "case pos\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : a = 0\n\u22a2 a = 0 \u2228 x = 0", "state_after": "case pos.h\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : a = 0\n\u22a2 a = 0"}, {"tactic": "exact ha", "annotated_tactic": ["exact ha", []], "state_before": "case pos.h\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : a = 0\n\u22a2 a = 0", "state_after": "no goals"}, {"tactic": "right", "annotated_tactic": ["right", []], "state_before": "case neg\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : \u00aca = 0\n\u22a2 a = 0 \u2228 x = 0", "state_after": "case neg.h\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : \u00aca = 0\n\u22a2 x = 0"}, {"tactic": "rw [\u2190 mem_bot R, \u2190 h]", "annotated_tactic": ["rw [\u2190 <a>mem_bot</a> R, \u2190 h]", [{"full_name": "Submodule.mem_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [72, 9], "def_end_pos": [72, 16]}]], "state_before": "case neg.h\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : \u00aca = 0\n\u22a2 x = 0", "state_after": "case neg.h\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : \u00aca = 0\n\u22a2 x \u2208 torsion R M"}, {"tactic": "exact \u27e8\u27e8a, mem_nonZeroDivisors_of_ne_zero ha\u27e9, hax\u27e9", "annotated_tactic": ["exact \u27e8\u27e8a, <a>mem_nonZeroDivisors_of_ne_zero</a> ha\u27e9, hax\u27e9", [{"full_name": "mem_nonZeroDivisors_of_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "def_pos": [198, 9], "def_end_pos": [198, 39]}]], "state_before": "case neg.h\nR : Type u_1\nM : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nh : torsion R M = \u22a5\na : R\nx : M\nhax : a \u2022 x = 0\nha : \u00aca = 0\n\u22a2 x \u2208 torsion R M", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "IsUnit.div", "start": [1038, 1], "end": [1039, 43], "traced_tactics": [{"tactic": "rw [div_eq_mul_inv]", "annotated_tactic": ["rw [<a>div_eq_mul_inv</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}]], "state_before": "\u03b1 : Type u\nM : Type u_1\nN : Type u_2\ninst\u271d : DivisionMonoid \u03b1\na b c : \u03b1\nha : IsUnit a\nhb : IsUnit b\n\u22a2 IsUnit (a / b)", "state_after": "\u03b1 : Type u\nM : Type u_1\nN : Type u_2\ninst\u271d : DivisionMonoid \u03b1\na b c : \u03b1\nha : IsUnit a\nhb : IsUnit b\n\u22a2 IsUnit (a * b\u207b\u00b9)"}, {"tactic": "exact ha.mul hb.inv", "annotated_tactic": ["exact ha.mul hb.inv", []], "state_before": "\u03b1 : Type u\nM : Type u_1\nN : Type u_2\ninst\u271d : DivisionMonoid \u03b1\na b c : \u03b1\nha : IsUnit a\nhb : IsUnit b\n\u22a2 IsUnit (a * b\u207b\u00b9)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Defs.lean", "full_name": "add_tsub_add_eq_tsub_left", "start": [397, 1], "end": [398, 62], "traced_tactics": [{"tactic": "rw [add_comm a b, add_comm a c, add_tsub_add_eq_tsub_right]", "annotated_tactic": ["rw [<a>add_comm</a> a b, <a>add_comm</a> a c, <a>add_tsub_add_eq_tsub_right</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "add_tsub_add_eq_tsub_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [390, 9], "def_end_pos": [390, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : AddCommSemigroup \u03b1\ninst\u271d\u00b3 : Sub \u03b1\ninst\u271d\u00b2 : OrderedSub \u03b1\na\u271d b\u271d c\u271d d : \u03b1\ninst\u271d\u00b9 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\na b c : \u03b1\n\u22a2 a + b - (a + c) = b - c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.lintegral_const_mul_le", "start": [698, 1], "end": [707, 34], "traced_tactics": [{"tactic": "rw [lintegral, ENNReal.mul_iSup]", "annotated_tactic": ["rw [<a>lintegral</a>, <a>ENNReal.mul_iSup</a>]", [{"full_name": "MeasureTheory.lintegral", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [62, 17], "def_end_pos": [62, 26]}, {"full_name": "ENNReal.mul_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [648, 9], "def_end_pos": [648, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\n\u22a2 r * \u222b\u207b (a : \u03b1), f a \u2202\u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\n\u22a2 \u2a06 i, r * \u2a06 (_ : \u2191i \u2264 fun a => f a), SimpleFunc.lintegral i \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc"}, {"tactic": "refine' iSup_le fun s => _", "annotated_tactic": ["refine' <a>iSup_le</a> fun s => _", [{"full_name": "iSup_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [764, 9], "def_end_pos": [764, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\n\u22a2 \u2a06 i, r * \u2a06 (_ : \u2191i \u2264 fun a => f a), SimpleFunc.lintegral i \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\n\u22a2 r * \u2a06 (_ : \u2191s \u2264 fun a => f a), SimpleFunc.lintegral s \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc"}, {"tactic": "rw [ENNReal.mul_iSup]", "annotated_tactic": ["rw [<a>ENNReal.mul_iSup</a>]", [{"full_name": "ENNReal.mul_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [648, 9], "def_end_pos": [648, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\n\u22a2 r * \u2a06 (_ : \u2191s \u2264 fun a => f a), SimpleFunc.lintegral s \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\n\u22a2 \u2a06 (_ : \u2191s \u2264 fun a => f a), r * SimpleFunc.lintegral s \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc"}, {"tactic": "simp only [iSup_le_iff]", "annotated_tactic": ["simp only [<a>iSup_le_iff</a>]", [{"full_name": "iSup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [853, 9], "def_end_pos": [853, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\n\u22a2 \u2a06 (_ : \u2191s \u2264 fun a => f a), r * SimpleFunc.lintegral s \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\n\u22a2 (\u2191s \u2264 fun a => f a) \u2192 r * SimpleFunc.lintegral s \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc"}, {"tactic": "intro hs", "annotated_tactic": ["intro hs", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\n\u22a2 (\u2191s \u2264 fun a => f a) \u2192 r * SimpleFunc.lintegral s \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhs : \u2191s \u2264 fun a => f a\n\u22a2 r * SimpleFunc.lintegral s \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc"}, {"tactic": "rw [\u2190 SimpleFunc.const_mul_lintegral, lintegral]", "annotated_tactic": ["rw [\u2190 <a>SimpleFunc.const_mul_lintegral</a>, <a>lintegral</a>]", [{"full_name": "MeasureTheory.SimpleFunc.const_mul_lintegral", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [1018, 9], "def_end_pos": [1018, 28]}, {"full_name": "MeasureTheory.lintegral", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [62, 17], "def_end_pos": [62, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhs : \u2191s \u2264 fun a => f a\n\u22a2 r * SimpleFunc.lintegral s \u03bc \u2264 \u222b\u207b (a : \u03b1), r * f a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhs : \u2191s \u2264 fun a => f a\n\u22a2 SimpleFunc.lintegral (const \u03b1 r * s) \u03bc \u2264 \u2a06 g, \u2a06 (_ : \u2191g \u2264 fun a => r * f a), SimpleFunc.lintegral g \u03bc"}, {"tactic": "refine' le_iSup_of_le (const \u03b1 r * s) (le_iSup_of_le (fun x => _) le_rfl)", "annotated_tactic": ["refine' <a>le_iSup_of_le</a> (<a>const</a> \u03b1 r * s) (<a>le_iSup_of_le</a> (fun x => _) <a>le_rfl</a>)", [{"full_name": "le_iSup_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [738, 9], "def_end_pos": [738, 22]}, {"full_name": "MeasureTheory.SimpleFunc.const", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [144, 5], "def_end_pos": [144, 10]}, {"full_name": "le_iSup_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [738, 9], "def_end_pos": [738, 22]}, {"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhs : \u2191s \u2264 fun a => f a\n\u22a2 SimpleFunc.lintegral (const \u03b1 r * s) \u03bc \u2264 \u2a06 g, \u2a06 (_ : \u2191g \u2264 fun a => r * f a), SimpleFunc.lintegral g \u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhs : \u2191s \u2264 fun a => f a\nx : \u03b1\n\u22a2 \u2191(const \u03b1 r * s) x \u2264 (fun a => r * f a) x"}, {"tactic": "exact mul_le_mul_left' (hs x) _", "annotated_tactic": ["exact <a>mul_le_mul_left'</a> (hs x) _", [{"full_name": "mul_le_mul_left'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [50, 9], "def_end_pos": [50, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhs : \u2191s \u2264 fun a => f a\nx : \u03b1\n\u22a2 \u2191(const \u03b1 r * s) x \u2264 (fun a => r * f a) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.congr_arg", "start": [516, 11], "end": [517, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "full_name": "Submodule.inf_coe", "start": [226, 1], "end": [227, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bases.lean", "full_name": "TopologicalSpace.nonempty_of_mem_countableBasis", "start": [772, 1], "end": [774, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "subset_upperBounds_lowerBounds", "start": [266, 1], "end": [267, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "Xor'.or", "start": [320, 11], "end": [320, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Hom.lean", "full_name": "NormedAddGroupHom.toAddMonoidHom_injective", "start": [152, 1], "end": [154, 71], "traced_tactics": [{"tactic": "rw [\u2190 coe_toAddMonoidHom f, \u2190 coe_toAddMonoidHom g, h]", "annotated_tactic": ["rw [\u2190 <a>coe_toAddMonoidHom</a> f, \u2190 <a>coe_toAddMonoidHom</a> g, h]", [{"full_name": "NormedAddGroupHom.coe_toAddMonoidHom", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Hom.lean", "def_pos": [148, 9], "def_end_pos": [148, 27]}, {"full_name": "NormedAddGroupHom.coe_toAddMonoidHom", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Hom.lean", "def_pos": [148, 9], "def_end_pos": [148, 27]}]], "state_before": "V : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf\u271d g\u271d f g : NormedAddGroupHom V\u2081 V\u2082\nh : toAddMonoidHom f = toAddMonoidHom g\n\u22a2 \u21d1f = \u21d1g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Divisibility/Basic.lean", "full_name": "dvd_mul_of_dvd_right", "start": [202, 1], "end": [203, 37], "traced_tactics": [{"tactic": "rw [mul_comm]", "annotated_tactic": ["rw [<a>mul_comm</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : CommSemigroup \u03b1\na b c\u271d : \u03b1\nh : a \u2223 b\nc : \u03b1\n\u22a2 a \u2223 c * b", "state_after": "\u03b1 : Type u_1\ninst\u271d : CommSemigroup \u03b1\na b c\u271d : \u03b1\nh : a \u2223 b\nc : \u03b1\n\u22a2 a \u2223 b * c"}, {"tactic": "exact h.mul_right _", "annotated_tactic": ["exact h.mul_right _", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : CommSemigroup \u03b1\na b c\u271d : \u03b1\nh : a \u2223 b\nc : \u03b1\n\u22a2 a \u2223 b * c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Bool/Basic.lean", "full_name": "Bool.not_ne_id", "start": [138, 1], "end": [138, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Pairwise.lean", "full_name": "List.Pairwise.imp\u2082", "start": [68, 1], "end": [70, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/Compact.lean", "full_name": "IsCompact.lt_sInf_iff_of_continuous", "start": [448, 1], "end": [451, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.maximum?_eq_none_iff", "start": [2278, 9], "end": [2279, 31], "traced_tactics": [{"tactic": "cases xs <;> simp [maximum?]", "annotated_tactic": ["cases xs <;> simp [<a>maximum?</a>]", [{"full_name": "List.maximum?", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [878, 5], "def_end_pos": [878, 13]}]], "state_before": "\u03b1 : Type u_1\nxs : List \u03b1\ninst\u271d : Max \u03b1\n\u22a2 maximum? xs = none \u2194 xs = []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Archimedean.lean", "full_name": "Real.iInf_of_isEmpty", "start": [211, 1], "end": [212, 35], "traced_tactics": [{"tactic": "rw [iInf_of_isEmpty, sInf_empty]", "annotated_tactic": ["rw [<a>iInf_of_isEmpty</a>, <a>sInf_empty</a>]", [{"full_name": "iInf_of_isEmpty", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1473, 9], "def_end_pos": [1473, 24]}, {"full_name": "Real.sInf_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Archimedean.lean", "def_pos": [208, 9], "def_end_pos": [208, 19]}]], "state_before": "\u03b1 : Sort u_1\ninst\u271d : IsEmpty \u03b1\nf : \u03b1 \u2192 \u211d\n\u22a2 \u2a05 i, f i = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "AddLECancellable.tsub_lt_iff_tsub_lt", "start": [129, 11], "end": [131, 55], "traced_tactics": [{"tactic": "rw [hb.tsub_lt_iff_left h\u2081, hc.tsub_lt_iff_right h\u2082]", "annotated_tactic": ["rw [hb.tsub_lt_iff_left h\u2081, hc.tsub_lt_iff_right h\u2082]", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : AddCommSemigroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nhb : AddLECancellable b\nhc : AddLECancellable c\nh\u2081 : b \u2264 a\nh\u2082 : c \u2264 a\n\u22a2 a - b < c \u2194 a - c < b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupClosed.lean", "full_name": "Set.Finite.latticeClosure", "start": [443, 1], "end": [444, 63], "traced_tactics": [{"tactic": "rw [\u2190 supClosure_infClosure]", "annotated_tactic": ["rw [\u2190 <a>supClosure_infClosure</a>]", [{"full_name": "supClosure_infClosure", "def_path": ".lake/packages/mathlib/Mathlib/Order/SupClosed.lean", "def_pos": [433, 15], "def_end_pos": [433, 36]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : DistribLattice \u03b2\ns : Set \u03b1\nhs : Set.Finite s\n\u22a2 Set.Finite (_root_.latticeClosure s)", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : DistribLattice \u03b2\ns : Set \u03b1\nhs : Set.Finite s\n\u22a2 Set.Finite (supClosure (infClosure s))"}, {"tactic": "exact hs.infClosure.supClosure", "annotated_tactic": ["exact hs.infClosure.supClosure", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : DistribLattice \u03b2\ns : Set \u03b1\nhs : Set.Finite s\n\u22a2 Set.Finite (supClosure (infClosure s))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/FieldDivision.lean", "full_name": "Polynomial.isRoot_iterate_derivative_of_lt_rootMultiplicity", "start": [59, 1], "end": [62, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Operations.lean", "full_name": "ENNReal.coe_finset_sum", "start": [291, 1], "end": [292, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Topology.lean", "full_name": "Convex.openSegment_self_interior_subset_interior", "start": [208, 1], "end": [210, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.extendDomain_subtypeDomain", "start": [1752, 1], "end": [1760, 16], "traced_tactics": [{"tactic": "ext a", "annotated_tactic": ["ext a", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\n\u22a2 extendDomain (subtypeDomain P f) = f", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\n\u22a2 (extendDomain (subtypeDomain P f)) a = f a"}, {"tactic": "by_cases h : P a", "annotated_tactic": ["by_cases h : P a", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\n\u22a2 (extendDomain (subtypeDomain P f)) a = f a", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : P a\n\u22a2 (extendDomain (subtypeDomain P f)) a = f a\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : \u00acP a\n\u22a2 (extendDomain (subtypeDomain P f)) a = f a"}, {"tactic": "exact dif_pos h", "annotated_tactic": ["exact <a>dif_pos</a> h", [{"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : P a\n\u22a2 (extendDomain (subtypeDomain P f)) a = f a", "state_after": "no goals"}, {"tactic": "dsimp", "annotated_tactic": ["dsimp", []], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : \u00acP a\n\u22a2 (extendDomain (subtypeDomain P f)) a = f a", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : \u00acP a\n\u22a2 (if P a then f a else 0) = f a"}, {"tactic": "rw [if_neg h, eq_comm, \u2190 not_mem_support_iff]", "annotated_tactic": ["rw [<a>if_neg</a> h, <a>eq_comm</a>, \u2190 <a>not_mem_support_iff</a>]", [{"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "Finsupp.not_mem_support_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [194, 9], "def_end_pos": [194, 28]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : \u00acP a\n\u22a2 (if P a then f a else 0) = f a", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : \u00acP a\n\u22a2 a \u2209 f.support"}, {"tactic": "refine mt ?_ h", "annotated_tactic": ["refine <a>mt</a> ?_ h", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : \u00acP a\n\u22a2 a \u2209 f.support", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : \u00acP a\n\u22a2 a \u2208 f.support \u2192 P a"}, {"tactic": "exact @hf _", "annotated_tactic": ["exact @hf _", []], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP\u271d : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\nM : Type u_13\ninst\u271d\u00b9 : Zero M\nP : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred P\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 a \u2208 f.support, P a\na : \u03b1\nh : \u00acP a\n\u22a2 a \u2208 f.support \u2192 P a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/GDelta.lean", "full_name": "isNowhereDense_empty", "start": [289, 1], "end": [292, 53], "traced_tactics": [{"tactic": "rw [IsNowhereDense, closure_empty, interior_empty]", "annotated_tactic": ["rw [<a>IsNowhereDense</a>, <a>closure_empty</a>, <a>interior_empty</a>]", [{"full_name": "IsNowhereDense", "def_path": ".lake/packages/mathlib/Mathlib/Topology/GDelta.lean", "def_pos": [287, 5], "def_end_pos": [287, 19]}, {"full_name": "closure_empty", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [466, 9], "def_end_pos": [466, 22]}, {"full_name": "interior_empty", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [298, 9], "def_end_pos": [298, 23]}]], "state_before": "X\u271d : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\nX : Type u_5\ninst\u271d : TopologicalSpace X\n\u22a2 IsNowhereDense \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "IsUnit.mul_iff", "start": [786, 1], "end": [788, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.setOf_bijective", "start": [266, 1], "end": [267, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "full_name": "Real.strictMonoOn_logb", "start": [261, 1], "end": [262, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Algebra.lean", "full_name": "algebraMap_mono", "start": [25, 1], "end": [27, 98], "traced_tactics": [{"tactic": "simpa only [Algebra.algebraMap_eq_smul_one] using smul_le_smul_of_nonneg_right ha zero_le_one", "annotated_tactic": ["simpa only [<a>Algebra.algebraMap_eq_smul_one</a>] using <a>smul_le_smul_of_nonneg_right</a> ha <a>zero_le_one</a>", [{"full_name": "Algebra.algebraMap_eq_smul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [344, 9], "def_end_pos": [344, 31]}, {"full_name": "smul_le_smul_of_nonneg_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Module/Defs.lean", "def_pos": [301, 17], "def_end_pos": [301, 45]}, {"full_name": "zero_le_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [26, 15], "def_end_pos": [26, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : OrderedCommSemiring \u03b1\ninst\u271d\u00b2 : OrderedSemiring \u03b2\ninst\u271d\u00b9 : Algebra \u03b1 \u03b2\ninst\u271d : SMulPosMono \u03b1 \u03b2\na a\u2081 a\u2082 : \u03b1\nha : a\u2081 \u2264 a\u2082\n\u22a2 (algebraMap \u03b1 \u03b2) a\u2081 \u2264 (algebraMap \u03b1 \u03b2) a\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/EMetricSpace/Basic.lean", "full_name": "edist_toMul", "start": [1212, 1], "end": [1213, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rel.lean", "full_name": "Rel.image_inter", "start": [174, 1], "end": [175, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Associates.exists_non_zero_rep", "start": [1056, 1], "end": [1057, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "full_name": "HasSum.tsum_fiberwise", "start": [159, 1], "end": [162, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "full_name": "NonUnitalSubring.coe_map", "start": [429, 1], "end": [430, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "full_name": "hasFDerivWithinAt_of_isOpen", "start": [415, 1], "end": [417, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.generate_eq_generate_inter", "start": [331, 1], "end": [333, 95], "traced_tactics": [{"tactic": "rw [\u2190 FilterBasis.ofSets_sets, FilterBasis.generate, \u2190 (hasBasis_generate s).filter_eq]", "annotated_tactic": ["rw [\u2190 <a>FilterBasis.ofSets_sets</a>, <a>FilterBasis.generate</a>, \u2190 (<a>hasBasis_generate</a> s).<a>filter_eq</a>]", [{"full_name": "Filter.FilterBasis.ofSets_sets", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [258, 7], "def_end_pos": [258, 30]}, {"full_name": "FilterBasis.generate", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [196, 19], "def_end_pos": [196, 27]}, {"full_name": "Filter.hasBasis_generate", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [243, 9], "def_end_pos": [243, 26]}, {"full_name": "Filter.HasBasis.filter_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [322, 9], "def_end_pos": [322, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns\u271d : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\ns : Set (Set \u03b1)\n\u22a2 generate s = generate (sInter '' {t | Set.Finite t \u2227 t \u2286 s})", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns\u271d : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\ns : Set (Set \u03b1)\n\u22a2 IsBasis.filter \u22ef = FilterBasis.filter (FilterBasis.ofSets s)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns\u271d : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\ns : Set (Set \u03b1)\n\u22a2 IsBasis.filter \u22ef = FilterBasis.filter (FilterBasis.ofSets s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "bddAbove_prod", "start": [1574, 1], "end": [1579, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/LocalRing.lean", "full_name": "LocalRing.maximal_ideal_unique", "start": [125, 1], "end": [127, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Basic.lean", "full_name": "Algebra.id.smul_eq_mul", "start": [463, 1], "end": [464, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.partition_eq_filter_filter", "start": [1305, 9], "end": [1310, 89], "traced_tactics": [{"tactic": "simp [partition, aux]", "annotated_tactic": ["simp [<a>partition</a>, aux]", [{"full_name": "List.partition", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [307, 15], "def_end_pos": [307, 24]}]], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\n\u22a2 partition p l = (filter p l, filter (not \u2218 p) l)", "state_after": "no goals"}, {"tactic": "simp [partition.loop, filter]", "annotated_tactic": ["simp [<a>partition.loop</a>, <a>filter</a>]", [{"full_name": "List.partition.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [310, 17], "def_end_pos": [310, 21]}, {"full_name": "List.filter", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [267, 5], "def_end_pos": [267, 11]}]], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl as\u271d bs\u271d : List \u03b1\n\u22a2 partition.loop p [] (as\u271d, bs\u271d) = (reverse as\u271d ++ filter p [], reverse bs\u271d ++ filter (not \u2218 p) [])", "state_after": "no goals"}, {"tactic": "cases pa : p a <;> simp [partition.loop, pa, aux, filter, append_assoc]", "annotated_tactic": ["cases pa : p a <;> simp [<a>partition.loop</a>, pa, aux, <a>filter</a>, <a>append_assoc</a>]", [{"full_name": "List.partition.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [310, 17], "def_end_pos": [310, 21]}, {"full_name": "List.filter", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [267, 5], "def_end_pos": [267, 11]}, {"full_name": "List.append_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [143, 9], "def_end_pos": [143, 21]}]], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u271d as\u271d bs\u271d : List \u03b1\na : \u03b1\nl : List \u03b1\n\u22a2 partition.loop p (a :: l) (as\u271d, bs\u271d) = (reverse as\u271d ++ filter p (a :: l), reverse bs\u271d ++ filter (not \u2218 p) (a :: l))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "full_name": "Cardinal.aleph'_succ", "start": [204, 1], "end": [207, 16], "traced_tactics": [{"tactic": "apply (succ_le_of_lt <| aleph'_lt.2 <| lt_succ o).antisymm' (Cardinal.alephIdx_le.1 <| _)", "annotated_tactic": ["apply (<a>succ_le_of_lt</a> <| <a>aleph'_lt</a>.2 <| <a>lt_succ</a> o).<a>antisymm'</a> (<a>Cardinal.alephIdx_le</a>.1 <| _)", [{"full_name": "Order.succ_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [221, 9], "def_end_pos": [221, 22]}, {"full_name": "Cardinal.aleph'_lt", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [178, 9], "def_end_pos": [178, 18]}, {"full_name": "Order.lt_succ", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 16]}, {"full_name": "LE.le.antisymm'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [127, 7], "def_end_pos": [127, 22]}, {"full_name": "Cardinal.alephIdx_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [111, 9], "def_end_pos": [111, 20]}]], "state_before": "o : Ordinal.{u_1}\n\u22a2 aleph' (succ o) = succ (aleph' o)", "state_after": "o : Ordinal.{u_1}\n\u22a2 alephIdx (aleph' (succ o)) \u2264 alephIdx (succ (aleph' o))"}, {"tactic": "rw [alephIdx_aleph', succ_le_iff, \u2190 aleph'_lt, aleph'_alephIdx]", "annotated_tactic": ["rw [<a>alephIdx_aleph'</a>, <a>succ_le_iff</a>, \u2190 <a>aleph'_lt</a>, <a>aleph'_alephIdx</a>]", [{"full_name": "Cardinal.alephIdx_aleph'", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [193, 9], "def_end_pos": [193, 24]}, {"full_name": "Order.succ_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [343, 9], "def_end_pos": [343, 20]}, {"full_name": "Cardinal.aleph'_lt", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [178, 9], "def_end_pos": [178, 18]}, {"full_name": "Cardinal.aleph'_alephIdx", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [188, 9], "def_end_pos": [188, 24]}]], "state_before": "o : Ordinal.{u_1}\n\u22a2 alephIdx (aleph' (succ o)) \u2264 alephIdx (succ (aleph' o))", "state_after": "o : Ordinal.{u_1}\n\u22a2 aleph' o < succ (aleph' o)"}, {"tactic": "apply lt_succ", "annotated_tactic": ["apply <a>lt_succ</a>", [{"full_name": "Order.lt_succ", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 16]}]], "state_before": "o : Ordinal.{u_1}\n\u22a2 aleph' o < succ (aleph' o)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Opposite.lean", "full_name": "Opposite.unop_inj_iff", "start": [80, 1], "end": [81, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Lipschitz.lean", "full_name": "lipschitzOnWith_iff_dist_le_mul", "start": [51, 1], "end": [55, 12], "traced_tactics": [{"tactic": "simp only [LipschitzOnWith, edist_nndist, dist_nndist]", "annotated_tactic": ["simp only [<a>LipschitzOnWith</a>, <a>edist_nndist</a>, <a>dist_nndist</a>]", [{"full_name": "LipschitzOnWith", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Lipschitz.lean", "def_pos": [58, 5], "def_end_pos": [58, 20]}, {"full_name": "edist_nndist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [308, 9], "def_end_pos": [308, 21]}, {"full_name": "dist_nndist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [300, 9], "def_end_pos": [300, 20]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : \u211d\u22650\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 LipschitzOnWith K f s \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 \u2191K * dist x y", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : \u211d\u22650\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)"}, {"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : \u211d\u22650\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)) \u2194\n    \u2200 x \u2208 s, \u2200 y \u2208 s, \u2191(nndist (f x) (f y)) \u2264 \u2191K * \u2191(nndist x y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "full_name": "CategoryTheory.Limits.\u03b9_colimitConstInitial_hom", "start": [500, 1], "end": [503, 35], "traced_tactics": [{"tactic": "aesop_cat", "annotated_tactic": ["aesop_cat", []], "state_before": "C\u271d : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\u271d\nJ : Type u_1\ninst\u271d\u00b2 : Category.{u_3, u_1} J\nC : Type u_2\ninst\u271d\u00b9 : Category.{u_4, u_2} C\ninst\u271d : HasInitial C\nj : J\n\u22a2 colimit.\u03b9 ((Functor.const J).obj (\u22a5_ C)) j \u226b colimitConstInitial.hom = initial.to (\u22a5_ C)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Module.lean", "full_name": "HasSum.smul_eq", "start": [96, 1], "end": [101, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Quotient.lean", "full_name": "Submodule.Quotient.equiv_refl", "start": [653, 1], "end": [656, 6], "traced_tactics": [{"tactic": "simpa using hf", "annotated_tactic": ["simpa using hf", []], "state_before": "R : Type u_1\nM : Type u_2\nr : R\nx y : M\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np p' P Q : Submodule R M\nhf : map (\u2191(LinearEquiv.refl R M)) P = Q\n\u22a2 P = Q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/BigOperators.lean", "full_name": "Fintype.card_piFinset", "start": [134, 1], "end": [135, 95], "traced_tactics": [{"tactic": "simp [Fintype.piFinset, card_map]", "annotated_tactic": ["simp [<a>Fintype.piFinset</a>, <a>card_map</a>]", [{"full_name": "Fintype.piFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Pi.lean", "def_pos": [28, 5], "def_end_pos": [28, 13]}, {"full_name": "Finset.card_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [295, 9], "def_end_pos": [295, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\n\u03b4 : \u03b1 \u2192 Type u_4\nt : (a : \u03b1) \u2192 Finset (\u03b4 a)\n\u22a2 (piFinset t).card = \u220f a : \u03b1, (t a).card", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Fib/Basic.lean", "full_name": "Nat.fib_lt_fib", "start": [133, 1], "end": [136, 54], "traced_tactics": [{"tactic": "simp [hm]", "annotated_tactic": ["simp [hm]", []], "state_before": "m : \u2115\nhm : 2 \u2264 m\n\u22a2 fib m < fib 0 \u2194 m < 0", "state_after": "no goals"}, {"tactic": "simp [hm]", "annotated_tactic": ["simp [hm]", []], "state_before": "m : \u2115\nhm : 2 \u2264 m\n\u22a2 fib m < fib 1 \u2194 m < 1", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "m : \u2115\nhm : 2 \u2264 m\nn : \u2115\n\u22a2 n + 2 \u2208 Set.Ici 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.cospanCompIso_app_left", "start": [289, 1], "end": [289, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Cast/Order.lean", "full_name": "Nat.ofNat_lt", "start": [166, 1], "end": [169, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "MeasureTheory.Measure.ext_of_Iic", "start": [869, 1], "end": [880, 34], "traced_tactics": [{"tactic": "refine' ext_of_Ioc_finite \u03bc \u03bd _ fun a b hlt => _", "annotated_tactic": ["refine' <a>ext_of_Ioc_finite</a> \u03bc \u03bd _ fun a b hlt => _", [{"full_name": "MeasureTheory.Measure.ext_of_Ioc_finite", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "def_pos": [804, 9], "def_end_pos": [804, 26]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\n\u22a2 \u03bc = \u03bd", "state_after": "case refine'_1\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\n\u22a2 \u2191\u2191\u03bc univ = \u2191\u2191\u03bd univ\n\ncase refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na\u271d b\u271d x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\na b : \u03b1\nhlt : a < b\n\u22a2 \u2191\u2191\u03bc (Ioc a b) = \u2191\u2191\u03bd (Ioc a b)"}, {"tactic": "rw [\u2190 Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic,\n  measure_diff (Iic_subset_Iic.2 hlt.le) measurableSet_Iic, h a, h b]", "annotated_tactic": ["rw [\u2190 <a>Iic_diff_Iic</a>, <a>measure_diff</a> (<a>Iic_subset_Iic</a>.2 hlt.le) <a>measurableSet_Iic</a>,\n    <a>measure_diff</a> (<a>Iic_subset_Iic</a>.2 hlt.le) <a>measurableSet_Iic</a>, h a, h b]", [{"full_name": "Set.Iic_diff_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1114, 9], "def_end_pos": [1114, 21]}, {"full_name": "MeasureTheory.measure_diff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "def_pos": [246, 9], "def_end_pos": [246, 21]}, {"full_name": "Set.Iic_subset_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [419, 9], "def_end_pos": [419, 23]}, {"full_name": "measurableSet_Iic", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "def_pos": [549, 9], "def_end_pos": [549, 26]}, {"full_name": "MeasureTheory.measure_diff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "def_pos": [246, 9], "def_end_pos": [246, 21]}, {"full_name": "Set.Iic_subset_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [419, 9], "def_end_pos": [419, 23]}, {"full_name": "measurableSet_Iic", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "def_pos": [549, 9], "def_end_pos": [549, 26]}]], "state_before": "case refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na\u271d b\u271d x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\na b : \u03b1\nhlt : a < b\n\u22a2 \u2191\u2191\u03bc (Ioc a b) = \u2191\u2191\u03bd (Ioc a b)", "state_after": "case refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na\u271d b\u271d x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\na b : \u03b1\nhlt : a < b\n\u22a2 \u2191\u2191\u03bd (Iic a) \u2260 \u22a4\n\ncase refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na\u271d b\u271d x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\na b : \u03b1\nhlt : a < b\n\u22a2 \u2191\u2191\u03bc (Iic a) \u2260 \u22a4"}, {"tactic": "rcases exists_countable_dense_bot_top \u03b1 with \u27e8s, hsc, hsd, -, hst\u27e9", "annotated_tactic": ["rcases <a>exists_countable_dense_bot_top</a> \u03b1 with \u27e8s, hsc, hsd, -, hst\u27e9", [{"full_name": "exists_countable_dense_bot_top", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bases.lean", "def_pos": [653, 9], "def_end_pos": [653, 39]}]], "state_before": "case refine'_1\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\n\u22a2 \u2191\u2191\u03bc univ = \u2191\u2191\u03bd univ", "state_after": "case refine'_1.intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhst : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\n\u22a2 \u2191\u2191\u03bc univ = \u2191\u2191\u03bd univ"}, {"tactic": "simp only [\u2190 biSup_measure_Iic hsc (hsd.exists_ge' hst) this, h]", "annotated_tactic": ["simp only [\u2190 <a>biSup_measure_Iic</a> hsc (hsd.exists_ge' hst) this, h]", [{"full_name": "MeasureTheory.biSup_measure_Iic", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "def_pos": [1984, 9], "def_end_pos": [1984, 26]}]], "state_before": "case refine'_1.intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhst : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : DirectedOn (fun x x_1 => x \u2264 x_1) s\n\u22a2 \u2191\u2191\u03bc univ = \u2191\u2191\u03bd univ", "state_after": "no goals"}, {"tactic": "rw [\u2190 h a]", "annotated_tactic": ["rw [\u2190 h a]", []], "state_before": "case refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na\u271d b\u271d x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\na b : \u03b1\nhlt : a < b\n\u22a2 \u2191\u2191\u03bd (Iic a) \u2260 \u22a4", "state_after": "case refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na\u271d b\u271d x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\na b : \u03b1\nhlt : a < b\n\u22a2 \u2191\u2191\u03bc (Iic a) \u2260 \u22a4"}, {"tactic": "exact (measure_lt_top \u03bc _).ne", "annotated_tactic": ["exact (<a>measure_lt_top</a> \u03bc _).<a>ne</a>", [{"full_name": "MeasureTheory.measure_lt_top", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Typeclasses.lean", "def_pos": [52, 9], "def_end_pos": [52, 23]}, {"full_name": "LT.lt.ne", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [149, 7], "def_end_pos": [149, 15]}]], "state_before": "case refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na\u271d b\u271d x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : \u2200 (a : \u03b1), \u2191\u2191\u03bc (Iic a) = \u2191\u2191\u03bd (Iic a)\na b : \u03b1\nhlt : a < b\n\u22a2 \u2191\u2191\u03bc (Iic a) \u2260 \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "Disjoint.sup_sdiff_cancel_right", "start": [654, 1], "end": [655, 58], "traced_tactics": [{"tactic": "rw [sup_sdiff, sdiff_self, sup_bot_eq, h.sdiff_eq_left]", "annotated_tactic": ["rw [<a>sup_sdiff</a>, <a>sdiff_self</a>, <a>sup_bot_eq</a>, h.sdiff_eq_left]", [{"full_name": "sup_sdiff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [599, 9], "def_end_pos": [599, 18]}, {"full_name": "sdiff_self", "def_path": ".lake/packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [475, 9], "def_end_pos": [475, 19]}, {"full_name": "sup_bot_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [427, 9], "def_end_pos": [427, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na b c d : \u03b1\nh : Disjoint a b\n\u22a2 (a \u2294 b) \\ b = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Pi/Lex.lean", "full_name": "Pi.toLex_strictMono", "start": [129, 1], "end": [134, 45], "traced_tactics": [{"tactic": "contrapose! hl", "annotated_tactic": ["contrapose! hl", []], "state_before": "\u03b9 : Type u_1\n\u03b2 : \u03b9 \u2192 Type u_2\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ns : {i : \u03b9} \u2192 \u03b2 i \u2192 \u03b2 i \u2192 Prop\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : IsWellOrder \u03b9 fun x x_1 => x < x_1\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\ni\u271d : \u03b9\na\u271d : \u03b2 i\u271d\na b : (i : \u03b9) \u2192 \u03b2 i\nh : a < b\ni : \u03b9\nhi : i \u2208 {i | a i \u2260 b i}\nhl : \u2200 x \u2208 {i | a i \u2260 b i}, \u00acx < i\nj : \u03b9\nhj : (fun x x_1 => x < x_1) j i\n\u22a2 toLex a j = toLex b j", "state_after": "\u03b9 : Type u_1\n\u03b2 : \u03b9 \u2192 Type u_2\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ns : {i : \u03b9} \u2192 \u03b2 i \u2192 \u03b2 i \u2192 Prop\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : IsWellOrder \u03b9 fun x x_1 => x < x_1\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\ni\u271d : \u03b9\na\u271d : \u03b2 i\u271d\na b : (i : \u03b9) \u2192 \u03b2 i\nh : a < b\ni : \u03b9\nhi : i \u2208 {i | a i \u2260 b i}\nj : \u03b9\nhj : (fun x x_1 => x < x_1) j i\nhl : toLex a j \u2260 toLex b j\n\u22a2 \u2203 x \u2208 {i | a i \u2260 b i}, x < i"}, {"tactic": "exact \u27e8j, hl, hj\u27e9", "annotated_tactic": ["exact \u27e8j, hl, hj\u27e9", []], "state_before": "\u03b9 : Type u_1\n\u03b2 : \u03b9 \u2192 Type u_2\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ns : {i : \u03b9} \u2192 \u03b2 i \u2192 \u03b2 i \u2192 Prop\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : IsWellOrder \u03b9 fun x x_1 => x < x_1\ninst\u271d : (i : \u03b9) \u2192 PartialOrder (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\ni\u271d : \u03b9\na\u271d : \u03b2 i\u271d\na b : (i : \u03b9) \u2192 \u03b2 i\nh : a < b\ni : \u03b9\nhi : i \u2208 {i | a i \u2260 b i}\nj : \u03b9\nhj : (fun x x_1 => x < x_1) j i\nhl : toLex a j \u2260 toLex b j\n\u22a2 \u2203 x \u2208 {i | a i \u2260 b i}, x < i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Basic.lean", "full_name": "LinearMap.ext_iff", "start": [327, 1], "end": [328, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Size.lean", "full_name": "Nat.size_zero", "start": [51, 1], "end": [51, 49], "traced_tactics": [{"tactic": "simp [size]", "annotated_tactic": ["simp [<a>size</a>]", [{"full_name": "Nat.size", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [229, 5], "def_end_pos": [229, 9]}]], "state_before": "\u22a2 size 0 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/OrderClosed.lean", "full_name": "not_tendsto_atTop_of_tendsto_nhds", "start": [442, 1], "end": [443, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.hasBasis_nhds_of_ne_top", "start": [259, 1], "end": [261, 65], "traced_tactics": [{"tactic": "simpa only [pos_iff_ne_zero] using hasBasis_nhds_of_ne_top' xt", "annotated_tactic": ["simpa only [<a>pos_iff_ne_zero</a>] using <a>hasBasis_nhds_of_ne_top'</a> xt", [{"full_name": "pos_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [230, 3], "def_end_pos": [230, 14]}, {"full_name": "ENNReal.hasBasis_nhds_of_ne_top'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [244, 9], "def_end_pos": [244, 33]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nxt : x \u2260 \u22a4\n\u22a2 HasBasis (\ud835\udcdd x) (fun x => 0 < x) fun \u03b5 => Icc (x - \u03b5) (x + \u03b5)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Fin.lean", "full_name": "Equiv.Perm.decomposeFin_symm_apply_succ", "start": [46, 1], "end": [54, 35], "traced_tactics": [{"tactic": "refine' Fin.cases _ _ p", "annotated_tactic": ["refine' <a>Fin.cases</a> _ _ p", [{"full_name": "Fin.cases", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [636, 21], "def_end_pos": [636, 26]}]], "state_before": "n : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx : Fin n\n\u22a2 (decomposeFin.symm (p, e)) (Fin.succ x) = (swap 0 p) (Fin.succ (e x))", "state_after": "case refine'_1\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx : Fin n\n\u22a2 (decomposeFin.symm (0, e)) (Fin.succ x) = (swap 0 0) (Fin.succ (e x))\n\ncase refine'_2\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx : Fin n\n\u22a2 \u2200 (i : Fin n), (decomposeFin.symm (Fin.succ i, e)) (Fin.succ x) = (swap 0 (Fin.succ i)) (Fin.succ (e x))"}, {"tactic": "simp [Equiv.Perm.decomposeFin, EquivFunctor.map]", "annotated_tactic": ["simp [<a>Equiv.Perm.decomposeFin</a>, <a>EquivFunctor.map</a>]", [{"full_name": "Equiv.Perm.decomposeFin", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Fin.lean", "def_pos": [23, 5], "def_end_pos": [23, 28]}, {"full_name": "EquivFunctor.map", "def_path": ".lake/packages/mathlib/Mathlib/Control/EquivFunctor.lean", "def_pos": [33, 3], "def_end_pos": [33, 6]}]], "state_before": "case refine'_1\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx : Fin n\n\u22a2 (decomposeFin.symm (0, e)) (Fin.succ x) = (swap 0 0) (Fin.succ (e x))", "state_after": "no goals"}, {"tactic": "intro i", "annotated_tactic": ["intro i", []], "state_before": "case refine'_2\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx : Fin n\n\u22a2 \u2200 (i : Fin n), (decomposeFin.symm (Fin.succ i, e)) (Fin.succ x) = (swap 0 (Fin.succ i)) (Fin.succ (e x))", "state_after": "case refine'_2\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx i : Fin n\n\u22a2 (decomposeFin.symm (Fin.succ i, e)) (Fin.succ x) = (swap 0 (Fin.succ i)) (Fin.succ (e x))"}, {"tactic": "by_cases h : i = e x", "annotated_tactic": ["by_cases h : i = e x", []], "state_before": "case refine'_2\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx i : Fin n\n\u22a2 (decomposeFin.symm (Fin.succ i, e)) (Fin.succ x) = (swap 0 (Fin.succ i)) (Fin.succ (e x))", "state_after": "case pos\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx i : Fin n\nh : i = e x\n\u22a2 (decomposeFin.symm (Fin.succ i, e)) (Fin.succ x) = (swap 0 (Fin.succ i)) (Fin.succ (e x))\n\ncase neg\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx i : Fin n\nh : \u00aci = e x\n\u22a2 (decomposeFin.symm (Fin.succ i, e)) (Fin.succ x) = (swap 0 (Fin.succ i)) (Fin.succ (e x))"}, {"tactic": "simp [h, Equiv.Perm.decomposeFin, EquivFunctor.map]", "annotated_tactic": ["simp [h, <a>Equiv.Perm.decomposeFin</a>, <a>EquivFunctor.map</a>]", [{"full_name": "Equiv.Perm.decomposeFin", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Fin.lean", "def_pos": [23, 5], "def_end_pos": [23, 28]}, {"full_name": "EquivFunctor.map", "def_path": ".lake/packages/mathlib/Mathlib/Control/EquivFunctor.lean", "def_pos": [33, 3], "def_end_pos": [33, 6]}]], "state_before": "case pos\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx i : Fin n\nh : i = e x\n\u22a2 (decomposeFin.symm (Fin.succ i, e)) (Fin.succ x) = (swap 0 (Fin.succ i)) (Fin.succ (e x))", "state_after": "no goals"}, {"tactic": "simp [h, Fin.succ_ne_zero, Equiv.Perm.decomposeFin, EquivFunctor.map,\n  swap_apply_def, Ne.symm h]", "annotated_tactic": ["simp [h, <a>Fin.succ_ne_zero</a>, <a>Equiv.Perm.decomposeFin</a>, <a>EquivFunctor.map</a>,\n        <a>swap_apply_def</a>, <a>Ne.symm</a> h]", [{"full_name": "Fin.succ_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [237, 9], "def_end_pos": [237, 21]}, {"full_name": "Equiv.Perm.decomposeFin", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Fin.lean", "def_pos": [23, 5], "def_end_pos": [23, 28]}, {"full_name": "EquivFunctor.map", "def_path": ".lake/packages/mathlib/Mathlib/Control/EquivFunctor.lean", "def_pos": [33, 3], "def_end_pos": [33, 6]}, {"full_name": "Equiv.swap_apply_def", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [1632, 9], "def_end_pos": [1632, 23]}, {"full_name": "Ne.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [702, 9], "def_end_pos": [702, 16]}]], "state_before": "case neg\nn : \u2115\ne : Perm (Fin n)\np : Fin (n + 1)\nx i : Fin n\nh : \u00aci = e x\n\u22a2 (decomposeFin.symm (Fin.succ i, e)) (Fin.succ x) = (swap 0 (Fin.succ i)) (Fin.succ (e x))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.triangle_assoc_comp_right", "start": [579, 1], "end": [581, 40], "traced_tactics": [{"tactic": "rw [\u2190 triangle, Iso.inv_hom_id_assoc]", "annotated_tactic": ["rw [\u2190 <a>triangle</a>, <a>Iso.inv_hom_id_assoc</a>]", [{"full_name": "CategoryTheory.MonoidalCategory.triangle", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Monoidal/Category.lean", "def_pos": [203, 3], "def_end_pos": [203, 11]}, {"full_name": "CategoryTheory.Iso.inv_hom_id_assoc", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [67, 12], "def_end_pos": [67, 34]}]], "state_before": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b2 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nU V W X\u271d Y\u271d Z X Y : C\n\u22a2 (\u03b1_ X (\ud835\udfd9_ C) Y).inv \u226b (\u03c1_ X).hom \u25b7 Y = X \u25c1 (\u03bb_ Y).hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "full_name": "ofAdd_image_zmultiples_eq_zpowers_ofAdd", "start": [193, 1], "end": [198, 48], "traced_tactics": [{"tactic": "symm", "annotated_tactic": ["symm", []], "state_before": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd '' \u2191(AddSubgroup.zmultiples x) = \u2191(Subgroup.zpowers (Multiplicative.ofAdd x))", "state_after": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u21d1Multiplicative.ofAdd '' \u2191(AddSubgroup.zmultiples x)"}, {"tactic": "rw [Equiv.eq_image_iff_symm_image_eq]", "annotated_tactic": ["rw [<a>Equiv.eq_image_iff_symm_image_eq</a>]", [{"full_name": "Equiv.eq_image_iff_symm_image_eq", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Set.lean", "def_pos": [87, 9], "def_end_pos": [87, 35]}]], "state_before": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u21d1Multiplicative.ofAdd '' \u2191(AddSubgroup.zmultiples x)", "state_after": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd.symm '' \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u2191(AddSubgroup.zmultiples x)"}, {"tactic": "exact ofMul_image_zpowers_eq_zmultiples_ofMul", "annotated_tactic": ["exact <a>ofMul_image_zpowers_eq_zmultiples_ofMul</a>", [{"full_name": "ofMul_image_zpowers_eq_zmultiples_ofMul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/ZPowers.lean", "def_pos": [180, 9], "def_end_pos": [180, 48]}]], "state_before": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd.symm '' \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u2191(AddSubgroup.zmultiples x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Extr.lean", "full_name": "IsMaxOn.on_preimage", "start": [415, 1], "end": [417, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Determinant.lean", "full_name": "AlternatingMap.eq_smul_basis_det", "start": [567, 1], "end": [571, 49], "traced_tactics": [{"tactic": "refine' Basis.ext_alternating e fun i h => _", "annotated_tactic": ["refine' <a>Basis.ext_alternating</a> e fun i h => _", [{"full_name": "Basis.ext_alternating", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Alternating/Basic.lean", "def_pos": [964, 9], "def_end_pos": [964, 30]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nf : M [\u22c0^\u03b9]\u2192\u2097[R] R\n\u22a2 f = f \u21d1e \u2022 Basis.det e", "state_after": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nf : M [\u22c0^\u03b9]\u2192\u2097[R] R\ni : \u03b9 \u2192 \u03b9\nh : Injective i\n\u22a2 (f fun i_1 => e (i i_1)) = (f \u21d1e \u2022 Basis.det e) fun i_1 => e (i i_1)"}, {"tactic": "let \u03c3 : Equiv.Perm \u03b9 := Equiv.ofBijective i (Finite.injective_iff_bijective.1 h)", "annotated_tactic": ["let \u03c3 : <a>Equiv.Perm</a> \u03b9 := <a>Equiv.ofBijective</a> i (<a>Finite.injective_iff_bijective</a>.1 h)", [{"full_name": "Equiv.Perm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [91, 5], "def_end_pos": [91, 15]}, {"full_name": "Equiv.ofBijective", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [943, 19], "def_end_pos": [943, 30]}, {"full_name": "Finite.injective_iff_bijective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [659, 9], "def_end_pos": [659, 32]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nf : M [\u22c0^\u03b9]\u2192\u2097[R] R\ni : \u03b9 \u2192 \u03b9\nh : Injective i\n\u22a2 (f fun i_1 => e (i i_1)) = (f \u21d1e \u2022 Basis.det e) fun i_1 => e (i i_1)", "state_after": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nf : M [\u22c0^\u03b9]\u2192\u2097[R] R\ni : \u03b9 \u2192 \u03b9\nh : Injective i\n\u03c3 : Equiv.Perm \u03b9 := Equiv.ofBijective i \u22ef\n\u22a2 (f fun i_1 => e (i i_1)) = (f \u21d1e \u2022 Basis.det e) fun i_1 => e (i i_1)"}, {"tactic": "change f (e \u2218 \u03c3) = (f e \u2022 e.det) (e \u2218 \u03c3)", "annotated_tactic": ["change f (e \u2218 \u03c3) = (f e \u2022 e.det) (e \u2218 \u03c3)", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nf : M [\u22c0^\u03b9]\u2192\u2097[R] R\ni : \u03b9 \u2192 \u03b9\nh : Injective i\n\u03c3 : Equiv.Perm \u03b9 := Equiv.ofBijective i \u22ef\n\u22a2 (f fun i_1 => e (i i_1)) = (f \u21d1e \u2022 Basis.det e) fun i_1 => e (i i_1)", "state_after": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nf : M [\u22c0^\u03b9]\u2192\u2097[R] R\ni : \u03b9 \u2192 \u03b9\nh : Injective i\n\u03c3 : Equiv.Perm \u03b9 := Equiv.ofBijective i \u22ef\n\u22a2 f (\u21d1e \u2218 \u21d1\u03c3) = (f \u21d1e \u2022 Basis.det e) (\u21d1e \u2218 \u21d1\u03c3)"}, {"tactic": "simp [AlternatingMap.map_perm, Basis.det_self]", "annotated_tactic": ["simp [<a>AlternatingMap.map_perm</a>, <a>Basis.det_self</a>]", [{"full_name": "AlternatingMap.map_perm", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Alternating/Basic.lean", "def_pos": [698, 9], "def_end_pos": [698, 17]}, {"full_name": "Basis.det_self", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [529, 9], "def_end_pos": [529, 23]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nf : M [\u22c0^\u03b9]\u2192\u2097[R] R\ni : \u03b9 \u2192 \u03b9\nh : Injective i\n\u03c3 : Equiv.Perm \u03b9 := Equiv.ofBijective i \u22ef\n\u22a2 f (\u21d1e \u2218 \u21d1\u03c3) = (f \u21d1e \u2022 Basis.det e) (\u21d1e \u2218 \u21d1\u03c3)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean", "full_name": "ArithmeticFunction.zeta_apply_ne", "start": [447, 1], "end": [448, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/CompactOpen.lean", "full_name": "ContinuousMap.compactOpen_le_induced", "start": [222, 1], "end": [225, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "Metric.continuousAt_iff'", "start": [1082, 1], "end": [1084, 34], "traced_tactics": [{"tactic": "rw [ContinuousAt, tendsto_nhds]", "annotated_tactic": ["rw [<a>ContinuousAt</a>, <a>tendsto_nhds</a>]", [{"full_name": "ContinuousAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [156, 5], "def_end_pos": [156, 17]}, {"full_name": "Metric.tendsto_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1077, 9], "def_end_pos": [1077, 21]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx y z : \u03b1\n\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\ns : Set \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\n\u22a2 ContinuousAt f b \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b2) in \ud835\udcdd b, dist (f x) (f b) < \u03b5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/NormalClosure.lean", "full_name": "IntermediateField.normal_iff_forall_fieldRange_le", "start": [267, 1], "end": [268, 68], "traced_tactics": [{"tactic": "rw [normal_iff_normalClosure_le, normalClosure_def, iSup_le_iff]", "annotated_tactic": ["rw [<a>normal_iff_normalClosure_le</a>, <a>normalClosure_def</a>, <a>iSup_le_iff</a>]", [{"full_name": "IntermediateField.normal_iff_normalClosure_le", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/NormalClosure.lean", "def_pos": [264, 7], "def_end_pos": [264, 34]}, {"full_name": "normalClosure_def", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/NormalClosure.lean", "def_pos": [47, 7], "def_end_pos": [47, 24]}, {"full_name": "iSup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [853, 9], "def_end_pos": [853, 20]}]], "state_before": "F : Type u_1\nK\u271d\u00b9 : Type u_2\nL : Type u_3\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Field K\u271d\u00b9\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra F K\u271d\u00b9\ninst\u271d\u00b9 : Algebra F L\nK\u271d K' : IntermediateField F L\ninst\u271d : Normal F L\nK : IntermediateField F L\n\u22a2 Normal F \u21a5K \u2194 \u2200 (\u03c3 : \u21a5K \u2192\u2090[F] L), AlgHom.fieldRange \u03c3 \u2264 K", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "full_name": "Polynomial.natTrailingDegree_eq_support_min'", "start": [321, 1], "end": [328, 72], "traced_tactics": [{"tactic": "apply le_antisymm", "annotated_tactic": ["apply <a>le_antisymm</a>", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "R : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\n\u22a2 natTrailingDegree p = min' (support p) \u22ef", "state_after": "case a\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\n\u22a2 natTrailingDegree p \u2264 min' (support p) \u22ef\n\ncase a\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\n\u22a2 min' (support p) \u22ef \u2264 natTrailingDegree p"}, {"tactic": "apply le_min'", "annotated_tactic": ["apply <a>le_min'</a>", [{"full_name": "Finset.le_min'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1528, 9], "def_end_pos": [1528, 16]}]], "state_before": "case a\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\n\u22a2 natTrailingDegree p \u2264 min' (support p) \u22ef", "state_after": "case a.H2\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\n\u22a2 \u2200 y \u2208 support p, natTrailingDegree p \u2264 y"}, {"tactic": "intro y hy", "annotated_tactic": ["intro y hy", []], "state_before": "case a.H2\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\n\u22a2 \u2200 y \u2208 support p, natTrailingDegree p \u2264 y", "state_after": "case a.H2\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\ny : \u2115\nhy : y \u2208 support p\n\u22a2 natTrailingDegree p \u2264 y"}, {"tactic": "exact natTrailingDegree_le_of_mem_supp y hy", "annotated_tactic": ["exact <a>natTrailingDegree_le_of_mem_supp</a> y hy", [{"full_name": "Polynomial.natTrailingDegree_le_of_mem_supp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "def_pos": [317, 9], "def_end_pos": [317, 41]}]], "state_before": "case a.H2\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\ny : \u2115\nhy : y \u2208 support p\n\u22a2 natTrailingDegree p \u2264 y", "state_after": "no goals"}, {"tactic": "apply Finset.min'_le", "annotated_tactic": ["apply <a>Finset.min'_le</a>", [{"full_name": "Finset.min'_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1524, 9], "def_end_pos": [1524, 16]}]], "state_before": "case a\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\n\u22a2 min' (support p) \u22ef \u2264 natTrailingDegree p", "state_after": "case a.H2\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\n\u22a2 natTrailingDegree p \u2208 support p"}, {"tactic": "exact mem_support_iff.mpr (trailingCoeff_nonzero_iff_nonzero.mpr h)", "annotated_tactic": ["exact mem_support_iff.mpr (trailingCoeff_nonzero_iff_nonzero.mpr h)", []], "state_before": "case a.H2\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : p \u2260 0\n\u22a2 natTrailingDegree p \u2208 support p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.iUnion_op_smul_set", "start": [424, 1], "end": [425, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Star.lean", "full_name": "StarConvex.preimage_smul", "start": [293, 1], "end": [295, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/Over.lean", "full_name": "CategoryTheory.Under.isoMk_hom_right", "start": [408, 1], "end": [410, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Thickening.lean", "full_name": "Metric.thickening_mono", "start": [91, 1], "end": [93, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bornology/Constructions.lean", "full_name": "Bornology.cobounded_prod", "start": [54, 1], "end": [55, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_of_empty", "start": [300, 1], "end": [301, 41], "traced_tactics": [{"tactic": "rw [eq_empty_of_isEmpty s, prod_empty]", "annotated_tactic": ["rw [<a>eq_empty_of_isEmpty</a> s, <a>prod_empty</a>]", [{"full_name": "Finset.eq_empty_of_isEmpty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [641, 9], "def_end_pos": [641, 28]}, {"full_name": "Finset.prod_empty", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [294, 9], "def_end_pos": [294, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : IsEmpty \u03b1\ns : Finset \u03b1\n\u22a2 \u220f i in s, f i = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.mem_iff_get?", "start": [744, 1], "end": [745, 51], "traced_tactics": [{"tactic": "simp [get?_eq_some, Fin.exists_iff, mem_iff_get]", "annotated_tactic": ["simp [<a>get?_eq_some</a>, <a>Fin.exists_iff</a>, <a>mem_iff_get</a>]", [{"full_name": "List.get?_eq_some", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [199, 9], "def_end_pos": [199, 21]}, {"full_name": "List.Fin.exists_iff", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [741, 9], "def_end_pos": [741, 23]}, {"full_name": "List.mem_iff_get", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [188, 9], "def_end_pos": [188, 20]}]], "state_before": "\u03b1 : Type u_1\na : \u03b1\nl : List \u03b1\n\u22a2 a \u2208 l \u2194 \u2203 n, get? l n = some a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Data/Bool/Lemmas.lean", "full_name": "Bool.decide_false", "start": [138, 1], "end": [139, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Cast/Lemmas.lean", "full_name": "Int.cast_pos", "start": [157, 1], "end": [158, 28], "traced_tactics": [{"tactic": "rw [\u2190 cast_zero, cast_lt]", "annotated_tactic": ["rw [\u2190 <a>cast_zero</a>, <a>cast_lt</a>]", [{"full_name": "Int.cast_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 18]}, {"full_name": "Int.cast_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [147, 9], "def_end_pos": [147, 16]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : OrderedRing \u03b1\ninst\u271d : Nontrivial \u03b1\nn : \u2124\n\u22a2 0 < \u2191n \u2194 0 < n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rat/Floor.lean", "full_name": "Rat.floor_def", "start": [54, 11], "end": [54, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Divisibility/Units.lean", "full_name": "IsUnit.mul_left_dvd", "start": [118, 1], "end": [120, 27], "traced_tactics": [{"tactic": "rcases hu with \u27e8u, rfl\u27e9", "annotated_tactic": ["rcases hu with \u27e8u, rfl\u27e9", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\na b u : \u03b1\nhu : IsUnit u\n\u22a2 u * a \u2223 b \u2194 a \u2223 b", "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\na b : \u03b1\nu : \u03b1\u02e3\n\u22a2 \u2191u * a \u2223 b \u2194 a \u2223 b"}, {"tactic": "apply Units.mul_left_dvd", "annotated_tactic": ["apply <a>Units.mul_left_dvd</a>", [{"full_name": "Units.mul_left_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Units.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}]], "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\na b : \u03b1\nu : \u03b1\u02e3\n\u22a2 \u2191u * a \u2223 b \u2194 a \u2223 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.Nonempty.smul", "start": [128, 1], "end": [129, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "vsub_mem_vectorSpan", "start": [95, 1], "end": [97, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Pi.lean", "full_name": "Pi.uniformContinuous_postcomp", "start": [71, 1], "end": [73, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Block.lean", "full_name": "Matrix.BlockTriangular.add", "start": [91, 1], "end": [92, 98], "traced_tactics": [{"tactic": "simp_rw [Matrix.add_apply, hM h, hN h, zero_add]", "annotated_tactic": ["simp_rw [<a>Matrix.add_apply</a>, hM h, hN h, <a>zero_add</a>]", [{"full_name": "Matrix.add_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [281, 9], "def_end_pos": [281, 18]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u00b9 : CommRing R\nM N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d : LT \u03b1\nhM : BlockTriangular M b\nhN : BlockTriangular N b\ni j : m\nh : b j < b i\n\u22a2 (M + N) i j = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Operations.lean", "full_name": "MonoidHom.mrangeRestrict_surjective", "start": [1072, 1], "end": [1073, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units/Equiv.lean", "full_name": "Group.mulRight_bijective", "start": [180, 1], "end": [181, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/PNat/Prime.lean", "full_name": "PNat.gcd_eq_right_iff_dvd", "start": [216, 1], "end": [218, 28], "traced_tactics": [{"tactic": "rw [gcd_comm]", "annotated_tactic": ["rw [<a>gcd_comm</a>]", [{"full_name": "PNat.gcd_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/PNat/Prime.lean", "def_pos": [203, 9], "def_end_pos": [203, 17]}]], "state_before": "m n : \u2115+\n\u22a2 m \u2223 n \u2194 gcd n m = m", "state_after": "m n : \u2115+\n\u22a2 m \u2223 n \u2194 gcd m n = m"}, {"tactic": "apply gcd_eq_left_iff_dvd", "annotated_tactic": ["apply <a>gcd_eq_left_iff_dvd</a>", [{"full_name": "PNat.gcd_eq_left_iff_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/PNat/Prime.lean", "def_pos": [209, 9], "def_end_pos": [209, 28]}]], "state_before": "m n : \u2115+\n\u22a2 m \u2223 n \u2194 gcd m n = m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "vectorSpan_eq_span_vsub_set_left", "start": [1039, 1], "end": [1049, 31], "traced_tactics": [{"tactic": "rw [vectorSpan_def]", "annotated_tactic": ["rw [<a>vectorSpan_def</a>]", [{"full_name": "vectorSpan_def", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [65, 9], "def_end_pos": [65, 23]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\n\u22a2 vectorSpan k s = Submodule.span k ((fun x => p -\u1d65 x) '' s)", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\n\u22a2 Submodule.span k (s -\u1d65 s) = Submodule.span k ((fun x => p -\u1d65 x) '' s)"}, {"tactic": "refine' le_antisymm _ (Submodule.span_mono _)", "annotated_tactic": ["refine' <a>le_antisymm</a> _ (<a>Submodule.span_mono</a> _)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Submodule.span_mono", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [83, 9], "def_end_pos": [83, 18]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\n\u22a2 Submodule.span k (s -\u1d65 s) = Submodule.span k ((fun x => p -\u1d65 x) '' s)", "state_after": "case refine'_1\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\n\u22a2 Submodule.span k (s -\u1d65 s) \u2264 Submodule.span k ((fun x => p -\u1d65 x) '' s)\n\ncase refine'_2\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\n\u22a2 (fun x => p -\u1d65 x) '' s \u2286 s -\u1d65 s"}, {"tactic": "rw [Submodule.span_le]", "annotated_tactic": ["rw [<a>Submodule.span_le</a>]", [{"full_name": "Submodule.span_le", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [79, 9], "def_end_pos": [79, 16]}]], "state_before": "case refine'_1\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\n\u22a2 Submodule.span k (s -\u1d65 s) \u2264 Submodule.span k ((fun x => p -\u1d65 x) '' s)", "state_after": "case refine'_1\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\n\u22a2 s -\u1d65 s \u2286 \u2191(Submodule.span k ((fun x => p -\u1d65 x) '' s))"}, {"tactic": "rintro v \u27e8p1, hp1, p2, hp2, hv\u27e9", "annotated_tactic": ["rintro v \u27e8p1, hp1, p2, hp2, hv\u27e9", []], "state_before": "case refine'_1\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\n\u22a2 s -\u1d65 s \u2286 \u2191(Submodule.span k ((fun x => p -\u1d65 x) '' s))", "state_after": "case refine'_1.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\nv : V\np1 : P\nhp1 : p1 \u2208 s\np2 : P\nhp2 : p2 \u2208 s\nhv : (fun x x_1 => x -\u1d65 x_1) p1 p2 = v\n\u22a2 v \u2208 \u2191(Submodule.span k ((fun x => p -\u1d65 x) '' s))"}, {"tactic": "simp_rw [\u2190 vsub_sub_vsub_cancel_left p1 p2 p] at hv", "annotated_tactic": ["simp_rw [\u2190 <a>vsub_sub_vsub_cancel_left</a> p1 p2 p] at hv", [{"full_name": "vsub_sub_vsub_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [250, 9], "def_end_pos": [250, 34]}]], "state_before": "case refine'_1.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\nv : V\np1 : P\nhp1 : p1 \u2208 s\np2 : P\nhp2 : p2 \u2208 s\nhv : (fun x x_1 => x -\u1d65 x_1) p1 p2 = v\n\u22a2 v \u2208 \u2191(Submodule.span k ((fun x => p -\u1d65 x) '' s))", "state_after": "case refine'_1.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\nv : V\np1 : P\nhp1 : p1 \u2208 s\np2 : P\nhp2 : p2 \u2208 s\nhv : p -\u1d65 p2 - (p -\u1d65 p1) = v\n\u22a2 v \u2208 \u2191(Submodule.span k ((fun x => p -\u1d65 x) '' s))"}, {"tactic": "rw [\u2190 hv, SetLike.mem_coe, Submodule.mem_span]", "annotated_tactic": ["rw [\u2190 hv, <a>SetLike.mem_coe</a>, <a>Submodule.mem_span</a>]", [{"full_name": "SetLike.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [180, 9], "def_end_pos": [180, 16]}, {"full_name": "Submodule.mem_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [71, 9], "def_end_pos": [71, 17]}]], "state_before": "case refine'_1.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\nv : V\np1 : P\nhp1 : p1 \u2208 s\np2 : P\nhp2 : p2 \u2208 s\nhv : p -\u1d65 p2 - (p -\u1d65 p1) = v\n\u22a2 v \u2208 \u2191(Submodule.span k ((fun x => p -\u1d65 x) '' s))", "state_after": "case refine'_1.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\nv : V\np1 : P\nhp1 : p1 \u2208 s\np2 : P\nhp2 : p2 \u2208 s\nhv : p -\u1d65 p2 - (p -\u1d65 p1) = v\n\u22a2 \u2200 (p_1 : Submodule k V), (fun x => p -\u1d65 x) '' s \u2286 \u2191p_1 \u2192 p -\u1d65 p2 - (p -\u1d65 p1) \u2208 p_1"}, {"tactic": "exact fun m hm => Submodule.sub_mem _ (hm \u27e8p2, hp2, rfl\u27e9) (hm \u27e8p1, hp1, rfl\u27e9)", "annotated_tactic": ["exact fun m hm => <a>Submodule.sub_mem</a> _ (hm \u27e8p2, hp2, <a>rfl</a>\u27e9) (hm \u27e8p1, hp1, <a>rfl</a>\u27e9)", [{"full_name": "Submodule.sub_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [436, 19], "def_end_pos": [436, 26]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case refine'_1.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\nv : V\np1 : P\nhp1 : p1 \u2208 s\np2 : P\nhp2 : p2 \u2208 s\nhv : p -\u1d65 p2 - (p -\u1d65 p1) = v\n\u22a2 \u2200 (p_1 : Submodule k V), (fun x => p -\u1d65 x) '' s \u2286 \u2191p_1 \u2192 p -\u1d65 p2 - (p -\u1d65 p1) \u2208 p_1", "state_after": "no goals"}, {"tactic": "rintro v \u27e8p2, hp2, hv\u27e9", "annotated_tactic": ["rintro v \u27e8p2, hp2, hv\u27e9", []], "state_before": "case refine'_2\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\n\u22a2 (fun x => p -\u1d65 x) '' s \u2286 s -\u1d65 s", "state_after": "case refine'_2.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\nv : V\np2 : P\nhp2 : p2 \u2208 s\nhv : (fun x => p -\u1d65 x) p2 = v\n\u22a2 v \u2208 s -\u1d65 s"}, {"tactic": "exact \u27e8p, hp, p2, hp2, hv\u27e9", "annotated_tactic": ["exact \u27e8p, hp, p2, hp2, hv\u27e9", []], "state_before": "case refine'_2.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Set P\np : P\nhp : p \u2208 s\nv : V\np2 : P\nhp2 : p2 \u2208 s\nhv : (fun x => p -\u1d65 x) p2 = v\n\u22a2 v \u2208 s -\u1d65 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/UniqueProds.lean", "full_name": "UniqueProds.of_injective_mulHom", "start": [335, 1], "end": [336, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean", "full_name": "Submonoid.LocalizationMap.symm_comp_ofMulEquivOfLocalizations_apply'", "start": [1485, 1], "end": [1486, 99], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "isClosed_empty", "start": [175, 9], "end": [175, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LocallyFinite.lean", "full_name": "Finset.coe_Ioo", "start": [362, 1], "end": [363, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.eraseIdx_eq_eraseIdxTR", "start": [57, 10], "end": [68, 35], "traced_tactics": [{"tactic": "funext \u03b1 l n", "annotated_tactic": ["funext \u03b1 l n", []], "state_before": "\u22a2 @eraseIdx = @eraseIdxTR", "state_after": "case h.h.h\n\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\n\u22a2 eraseIdx l n = eraseIdxTR l n"}, {"tactic": "simp [eraseIdxTR]", "annotated_tactic": ["simp [<a>eraseIdxTR</a>]", [{"full_name": "List.eraseIdxTR", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [49, 15], "def_end_pos": [49, 25]}]], "state_before": "case h.h.h\n\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\n\u22a2 eraseIdx l n = eraseIdxTR l n", "state_after": "case h.h.h\n\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\n\u22a2 eraseIdx l n = eraseIdxTR.go l l n #[]"}, {"tactic": "suffices \u2200 xs acc, l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ xs.eraseIdx n from\n  (this l #[] (by simp)).symm", "annotated_tactic": ["suffices \u2200 xs acc, l = acc.data ++ xs \u2192 <a>eraseIdxTR.go</a> l xs n acc = acc.data ++ xs.eraseIdx n from\n    (this l #[] (by simp)).<a>symm</a>", [{"full_name": "List.eraseIdxTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [52, 3], "def_end_pos": [52, 5]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case h.h.h\n\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\n\u22a2 eraseIdx l n = eraseIdxTR.go l l n #[]", "state_after": "case h.h.h\n\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\n\u22a2 \u2200 (xs : List \u03b1) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n"}, {"tactic": "intro xs", "annotated_tactic": ["intro xs", []], "state_before": "case h.h.h\n\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\n\u22a2 \u2200 (xs : List \u03b1) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n", "state_after": "case h.h.h\n\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\nxs : List \u03b1\n\u22a2 \u2200 (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n"}, {"tactic": "induction xs generalizing n with intro acc h\n| nil => simp [eraseIdx, eraseIdxTR.go, h]\n| cons x xs IH =>\nmatch n with\n| 0 => simp [eraseIdx, eraseIdxTR.go]\n| n+1 =>\nsimp [eraseIdx, eraseIdxTR.go]\nrw [IH]; simp; simp; exact h", "annotated_tactic": ["induction xs generalizing n with intro acc h\n  | <a>nil</a> => simp [<a>eraseIdx</a>, <a>eraseIdxTR.go</a>, h]\n  | <a>cons</a> x xs IH =>\n    match n with\n    | 0 => simp [<a>eraseIdx</a>, <a>eraseIdxTR.go</a>]\n    | n+1 =>\n      simp [<a>eraseIdx</a>, <a>eraseIdxTR.go</a>]\n      rw [IH]; simp; simp; exact h", [{"full_name": "List.nil", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2268, 5], "def_end_pos": [2268, 8]}, {"full_name": "List.eraseIdx", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [172, 5], "def_end_pos": [172, 13]}, {"full_name": "List.eraseIdxTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [52, 3], "def_end_pos": [52, 5]}, {"full_name": "List.cons", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2271, 5], "def_end_pos": [2271, 9]}, {"full_name": "List.eraseIdx", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [172, 5], "def_end_pos": [172, 13]}, {"full_name": "List.eraseIdxTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [52, 3], "def_end_pos": [52, 5]}, {"full_name": "List.eraseIdx", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [172, 5], "def_end_pos": [172, 13]}, {"full_name": "List.eraseIdxTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [52, 3], "def_end_pos": [52, 5]}]], "state_before": "case h.h.h\n\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\nxs : List \u03b1\n\u22a2 \u2200 (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\nthis : \u2200 (xs : List \u03b1) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\n\u22a2 l = #[].data ++ l", "state_after": "no goals"}, {"tactic": "simp [eraseIdx, eraseIdxTR.go, h]", "annotated_tactic": ["simp [<a>eraseIdx</a>, <a>eraseIdxTR.go</a>, h]", [{"full_name": "List.eraseIdx", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [172, 5], "def_end_pos": [172, 13]}, {"full_name": "List.eraseIdxTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [52, 3], "def_end_pos": [52, 5]}]], "state_before": "case h.h.h.nil\n\u03b1 : Type u_1\nl : List \u03b1\nn : Nat\nacc : Array \u03b1\nh : l = acc.data ++ []\n\u22a2 eraseIdxTR.go l [] n acc = acc.data ++ eraseIdx [] n", "state_after": "no goals"}, {"tactic": "match n with\n| 0 => simp [eraseIdx, eraseIdxTR.go]\n| n+1 =>\n  simp [eraseIdx, eraseIdxTR.go]\n  rw [IH]; simp; simp; exact h", "annotated_tactic": ["match n with\n    | 0 => simp [<a>eraseIdx</a>, <a>eraseIdxTR.go</a>]\n    | n+1 =>\n      simp [<a>eraseIdx</a>, <a>eraseIdxTR.go</a>]\n      rw [IH]; simp; simp; exact h", [{"full_name": "List.eraseIdx", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [172, 5], "def_end_pos": [172, 13]}, {"full_name": "List.eraseIdxTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [52, 3], "def_end_pos": [52, 5]}, {"full_name": "List.eraseIdx", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [172, 5], "def_end_pos": [172, 13]}, {"full_name": "List.eraseIdxTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [52, 3], "def_end_pos": [52, 5]}]], "state_before": "case h.h.h.cons\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\n\u22a2 eraseIdxTR.go l (x :: xs) n acc = acc.data ++ eraseIdx (x :: xs) n", "state_after": "no goals"}, {"tactic": "simp [eraseIdx, eraseIdxTR.go]", "annotated_tactic": ["simp [<a>eraseIdx</a>, <a>eraseIdxTR.go</a>]", [{"full_name": "List.eraseIdx", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [172, 5], "def_end_pos": [172, 13]}, {"full_name": "List.eraseIdxTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [52, 3], "def_end_pos": [52, 5]}]], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\n\u22a2 eraseIdxTR.go l (x :: xs) 0 acc = acc.data ++ eraseIdx (x :: xs) 0", "state_after": "no goals"}, {"tactic": "simp [eraseIdx, eraseIdxTR.go]", "annotated_tactic": ["simp [<a>eraseIdx</a>, <a>eraseIdxTR.go</a>]", [{"full_name": "List.eraseIdx", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [172, 5], "def_end_pos": [172, 13]}, {"full_name": "List.eraseIdxTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [52, 3], "def_end_pos": [52, 5]}]], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 eraseIdxTR.go l (x :: xs) (n + 1) acc = acc.data ++ eraseIdx (x :: xs) (n + 1)", "state_after": "\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 eraseIdxTR.go l xs n (Array.push acc x) = acc.data ++ x :: eraseIdx xs n"}, {"tactic": "rw [IH]", "annotated_tactic": ["rw [IH]", []], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 eraseIdxTR.go l xs n (Array.push acc x) = acc.data ++ x :: eraseIdx xs n", "state_after": "\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 (Array.push acc x).data ++ eraseIdx xs n = acc.data ++ x :: eraseIdx xs n\n\ncase a\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 l = (Array.push acc x).data ++ xs"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 (Array.push acc x).data ++ eraseIdx xs n = acc.data ++ x :: eraseIdx xs n\n\ncase a\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 l = (Array.push acc x).data ++ xs", "state_after": "case a\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 l = (Array.push acc x).data ++ xs"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 l = (Array.push acc x).data ++ xs", "state_after": "case a\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 l = acc.data ++ x :: xs"}, {"tactic": "exact h", "annotated_tactic": ["exact h", []], "state_before": "case a\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nIH : \u2200 (n : Nat) (acc : Array \u03b1), l = acc.data ++ xs \u2192 eraseIdxTR.go l xs n acc = acc.data ++ eraseIdx xs n\nn\u271d : Nat\nacc : Array \u03b1\nh : l = acc.data ++ x :: xs\nn : Nat\n\u22a2 l = acc.data ++ x :: xs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "mul_one_div", "start": [368, 1], "end": [369, 50], "traced_tactics": [{"tactic": "rw [div_eq_mul_inv, one_mul, div_eq_mul_inv]", "annotated_tactic": ["rw [<a>div_eq_mul_inv</a>, <a>one_mul</a>, <a>div_eq_mul_inv</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivInvMonoid G\na b c x y : G\n\u22a2 x * (1 / y) = x / y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LocallyFinite.lean", "full_name": "Finset.map_subtype_embedding_Iio", "start": [1387, 1], "end": [1389, 74], "traced_tactics": [{"tactic": "rw [subtype_Iio_eq]", "annotated_tactic": ["rw [<a>subtype_Iio_eq</a>]", [{"full_name": "Finset.subtype_Iio_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [1376, 9], "def_end_pos": [1376, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : LocallyFiniteOrderBot \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, x \u2264 a \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Iio a) = Iio \u2191a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : LocallyFiniteOrderBot \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, x \u2264 a \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Finset.subtype p (Iio \u2191a)) = Iio \u2191a"}, {"tactic": "exact Finset.subtype_map_of_mem fun x hx => hp (mem_Iio.1 hx).le a.prop", "annotated_tactic": ["exact <a>Finset.subtype_map_of_mem</a> fun x hx => hp (<a>mem_Iio</a>.1 hx).<a>le</a> a.prop", [{"full_name": "Finset.subtype_map_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [778, 9], "def_end_pos": [778, 27]}, {"full_name": "Finset.mem_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [424, 9], "def_end_pos": [424, 16]}, {"full_name": "LT.lt.le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [139, 7], "def_end_pos": [139, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : LocallyFiniteOrderBot \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, x \u2264 a \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Finset.subtype p (Iio \u2191a)) = Iio \u2191a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.Sublist.subset", "start": [582, 1], "end": [586, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Real.lean", "full_name": "ENNReal.toReal_div", "start": [499, 1], "end": [500, 62], "traced_tactics": [{"tactic": "rw [div_eq_mul_inv, toReal_mul, toReal_inv, div_eq_mul_inv]", "annotated_tactic": ["rw [<a>div_eq_mul_inv</a>, <a>toReal_mul</a>, <a>toReal_inv</a>, <a>div_eq_mul_inv</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "ENNReal.toReal_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [410, 9], "def_end_pos": [410, 19]}, {"full_name": "ENNReal.toReal_inv", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [495, 9], "def_end_pos": [495, 19]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}]], "state_before": "a\u271d b\u271d c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\na b : \u211d\u22650\u221e\n\u22a2 (a / b).toReal = a.toReal / b.toReal", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/ByteArray.lean", "full_name": "ByteArray.mkEmpty_data", "start": [25, 9], "end": [25, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/SesquilinearForm.lean", "full_name": "LinearMap.IsRefl.nondegenerate_of_separatingRight", "start": [754, 1], "end": [758, 46], "traced_tactics": [{"tactic": "refine' \u27e8_, hB'\u27e9", "annotated_tactic": ["refine' \u27e8_, hB'\u27e9", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\nM\u2097\u2081 : Type u_9\nM\u2097\u2081' : Type u_10\nM\u2097\u2082 : Type u_11\nM\u2097\u2082' : Type u_12\nK : Type u_13\nK\u2081 : Type u_14\nK\u2082 : Type u_15\nV : Type u_16\nV\u2081 : Type u_17\nV\u2082 : Type u_18\nn : Type u_19\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup M\u2081\ninst\u271d : Module R M\u2081\nI I' : R \u2192+* R\nB : M \u2192\u2097[R] M \u2192\u2097[R] M\u2081\nhB : IsRefl B\nhB' : SeparatingRight B\n\u22a2 Nondegenerate B", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\nM\u2097\u2081 : Type u_9\nM\u2097\u2081' : Type u_10\nM\u2097\u2082 : Type u_11\nM\u2097\u2082' : Type u_12\nK : Type u_13\nK\u2081 : Type u_14\nK\u2082 : Type u_15\nV : Type u_16\nV\u2081 : Type u_17\nV\u2082 : Type u_18\nn : Type u_19\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup M\u2081\ninst\u271d : Module R M\u2081\nI I' : R \u2192+* R\nB : M \u2192\u2097[R] M \u2192\u2097[R] M\u2081\nhB : IsRefl B\nhB' : SeparatingRight B\n\u22a2 SeparatingLeft B"}, {"tactic": "rw [separatingLeft_iff_ker_eq_bot, hB.ker_eq_bot_iff_ker_flip_eq_bot.mpr]", "annotated_tactic": ["rw [<a>separatingLeft_iff_ker_eq_bot</a>, hB.ker_eq_bot_iff_ker_flip_eq_bot.mpr]", [{"full_name": "LinearMap.separatingLeft_iff_ker_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/SesquilinearForm.lean", "def_pos": [730, 9], "def_end_pos": [730, 38]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\nM\u2097\u2081 : Type u_9\nM\u2097\u2081' : Type u_10\nM\u2097\u2082 : Type u_11\nM\u2097\u2082' : Type u_12\nK : Type u_13\nK\u2081 : Type u_14\nK\u2082 : Type u_15\nV : Type u_16\nV\u2081 : Type u_17\nV\u2082 : Type u_18\nn : Type u_19\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup M\u2081\ninst\u271d : Module R M\u2081\nI I' : R \u2192+* R\nB : M \u2192\u2097[R] M \u2192\u2097[R] M\u2081\nhB : IsRefl B\nhB' : SeparatingRight B\n\u22a2 SeparatingLeft B", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\nM\u2097\u2081 : Type u_9\nM\u2097\u2081' : Type u_10\nM\u2097\u2082 : Type u_11\nM\u2097\u2082' : Type u_12\nK : Type u_13\nK\u2081 : Type u_14\nK\u2082 : Type u_15\nV : Type u_16\nV\u2081 : Type u_17\nV\u2082 : Type u_18\nn : Type u_19\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup M\u2081\ninst\u271d : Module R M\u2081\nI I' : R \u2192+* R\nB : M \u2192\u2097[R] M \u2192\u2097[R] M\u2081\nhB : IsRefl B\nhB' : SeparatingRight B\n\u22a2 ker (flip B) = \u22a5"}, {"tactic": "rwa [\u2190 separatingRight_iff_flip_ker_eq_bot]", "annotated_tactic": ["rwa [\u2190 <a>separatingRight_iff_flip_ker_eq_bot</a>]", [{"full_name": "LinearMap.separatingRight_iff_flip_ker_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/SesquilinearForm.lean", "def_pos": [736, 9], "def_end_pos": [736, 44]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\nM\u2097\u2081 : Type u_9\nM\u2097\u2081' : Type u_10\nM\u2097\u2082 : Type u_11\nM\u2097\u2082' : Type u_12\nK : Type u_13\nK\u2081 : Type u_14\nK\u2082 : Type u_15\nV : Type u_16\nV\u2081 : Type u_17\nV\u2082 : Type u_18\nn : Type u_19\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup M\u2081\ninst\u271d : Module R M\u2081\nI I' : R \u2192+* R\nB : M \u2192\u2097[R] M \u2192\u2097[R] M\u2081\nhB : IsRefl B\nhB' : SeparatingRight B\n\u22a2 ker (flip B) = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.smul_finset_subset_smul", "start": [1790, 1], "end": [1791, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/FractionRing.lean", "full_name": "IsFractionRing.nontrivial", "start": [271, 11], "end": [278, 80], "traced_tactics": [{"tactic": "apply nontrivial_of_ne", "annotated_tactic": ["apply <a>nontrivial_of_ne</a>", [{"full_name": "nontrivial_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [57, 9], "def_end_pos": [57, 25]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 Nontrivial S", "state_after": "case h\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 ?x \u2260 ?y\n\ncase x\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S\n\ncase y\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case h\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 ?x \u2260 ?y\n\ncase x\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S\n\ncase y\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S", "state_after": "case h\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\nh : ?x = ?y\n\u22a2 False\n\ncase x\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S\n\ncase y\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S"}, {"tactic": "apply @zero_ne_one R", "annotated_tactic": ["apply @<a>zero_ne_one</a> R", [{"full_name": "zero_ne_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [55, 15], "def_end_pos": [55, 26]}]], "state_before": "case h\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\nh : ?x = ?y\n\u22a2 False\n\ncase x\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S\n\ncase y\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S", "state_after": "case h.a\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\nh : ?x = ?y\n\u22a2 0 = 1\n\ncase x\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S\n\ncase y\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S"}, {"tactic": "exact\n  IsLocalization.injective S (le_of_eq rfl)\n    (((algebraMap R S).map_zero.trans h).trans (algebraMap R S).map_one.symm)", "annotated_tactic": ["exact\n    <a>IsLocalization.injective</a> S (<a>le_of_eq</a> <a>rfl</a>)\n      (((<a>algebraMap</a> R S).map_zero.trans h).<a>trans</a> (<a>algebraMap</a> R S).map_one.symm)", [{"full_name": "IsLocalization.injective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [1235, 19], "def_end_pos": [1235, 28]}, {"full_name": "le_of_eq", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [66, 9], "def_end_pos": [66, 17]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}]], "state_before": "case h.a\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\nh : ?x = ?y\n\u22a2 0 = 1\n\ncase x\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S\n\ncase y\nR\u271d : Type u_1\ninst\u271d\u00b9\u2076 : CommRing R\u271d\nM : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u00b9\u2075 : CommRing S\u271d\ninst\u271d\u00b9\u2074 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u00b9\u00b3 : CommRing P\nA : Type u_4\ninst\u271d\u00b9\u00b2 : CommRing A\ninst\u271d\u00b9\u00b9 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u00b9\u2070 : CommRing B\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Field K\nL : Type u_7\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Algebra A K\ninst\u271d\u2075 : IsFractionRing A K\ng : A \u2192+* L\nR : Type u_8\nS : Type u_9\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsFractionRing R S\n\u22a2 S", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "lowerClosure_eq_bot_iff", "start": [1569, 1], "end": [1570, 61], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Test.lean", "full_name": "mathd_numbertheory_343", "start": [509, 1], "end": [510, 60], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "\u22a2 (\u220f k in Finset.range 6, (2 * k + 1)) % 10 = 5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/DirectLimit.lean", "full_name": "AddCommGroup.DirectLimit.map_comp", "start": [488, 1], "end": [499, 37], "traced_tactics": [{"tactic": "rw [AddMonoidHom.comp_assoc, hg\u2081 i, \u2190 AddMonoidHom.comp_assoc, hg\u2082 i,\n  AddMonoidHom.comp_assoc]", "annotated_tactic": ["rw [<a>AddMonoidHom.comp_assoc</a>, hg\u2081 i, \u2190 <a>AddMonoidHom.comp_assoc</a>, hg\u2082 i,\n        <a>AddMonoidHom.comp_assoc</a>]", [{"full_name": "AddMonoidHom.comp_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [967, 3], "def_end_pos": [967, 14]}, {"full_name": "AddMonoidHom.comp_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [967, 3], "def_end_pos": [967, 14]}, {"full_name": "AddMonoidHom.comp_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [967, 3], "def_end_pos": [967, 14]}]], "state_before": "R : Type u\ninst\u271d\u2077 : Ring R\n\u03b9 : Type v\ninst\u271d\u2076 : Preorder \u03b9\nG : \u03b9 \u2192 Type w\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommGroup (G i)\nf : (i j : \u03b9) \u2192 i \u2264 j \u2192 G i \u2192+ G j\nP : Type u\u2081\ninst\u271d\u00b3 : AddCommGroup P\ng : (i : \u03b9) \u2192 G i \u2192+ P\nHg : \u2200 (i j : \u03b9) (hij : i \u2264 j) (x : G i), (g j) ((f i j hij) x) = (g i) x\nG' : \u03b9 \u2192 Type v'\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommGroup (G' i)\nf' : (i j : \u03b9) \u2192 i \u2264 j \u2192 G' i \u2192+ G' j\nG'' : \u03b9 \u2192 Type v''\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommGroup (G'' i)\nf'' : (i j : \u03b9) \u2192 i \u2264 j \u2192 G'' i \u2192+ G'' j\ninst\u271d : IsDirected \u03b9 fun x x_1 => x \u2264 x_1\ng\u2081 : (i : \u03b9) \u2192 G i \u2192+ G' i\ng\u2082 : (i : \u03b9) \u2192 G' i \u2192+ G'' i\nhg\u2081 : \u2200 (i j : \u03b9) (h : i \u2264 j), AddMonoidHom.comp (g\u2081 j) (f i j h) = AddMonoidHom.comp (f' i j h) (g\u2081 i)\nhg\u2082 : \u2200 (i j : \u03b9) (h : i \u2264 j), AddMonoidHom.comp (g\u2082 j) (f' i j h) = AddMonoidHom.comp (f'' i j h) (g\u2082 i)\ni j : \u03b9\nh : i \u2264 j\n\u22a2 AddMonoidHom.comp ((fun i => AddMonoidHom.comp (g\u2082 i) (g\u2081 i)) j) (f i j h) =\n    AddMonoidHom.comp (f'' i j h) ((fun i => AddMonoidHom.comp (g\u2082 i) (g\u2081 i)) i)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\ninst\u271d\u2077 : Ring R\n\u03b9 : Type v\ninst\u271d\u2076 : Preorder \u03b9\nG : \u03b9 \u2192 Type w\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommGroup (G i)\nf : (i j : \u03b9) \u2192 i \u2264 j \u2192 G i \u2192+ G j\nP : Type u\u2081\ninst\u271d\u00b3 : AddCommGroup P\ng\u271d : (i : \u03b9) \u2192 G i \u2192+ P\nHg : \u2200 (i j : \u03b9) (hij : i \u2264 j) (x : G i), (g\u271d j) ((f i j hij) x) = (g\u271d i) x\nG' : \u03b9 \u2192 Type v'\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommGroup (G' i)\nf' : (i j : \u03b9) \u2192 i \u2264 j \u2192 G' i \u2192+ G' j\nG'' : \u03b9 \u2192 Type v''\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommGroup (G'' i)\nf'' : (i j : \u03b9) \u2192 i \u2264 j \u2192 G'' i \u2192+ G'' j\ninst\u271d : IsDirected \u03b9 fun x x_1 => x \u2264 x_1\ng\u2081 : (i : \u03b9) \u2192 G i \u2192+ G' i\ng\u2082 : (i : \u03b9) \u2192 G' i \u2192+ G'' i\nhg\u2081 : \u2200 (i j : \u03b9) (h : i \u2264 j), AddMonoidHom.comp (g\u2081 j) (f i j h) = AddMonoidHom.comp (f' i j h) (g\u2081 i)\nhg\u2082 : \u2200 (i j : \u03b9) (h : i \u2264 j), AddMonoidHom.comp (g\u2082 j) (f' i j h) = AddMonoidHom.comp (f'' i j h) (g\u2082 i)\nx : DirectLimit G f\nx\u271d : Nonempty \u03b9\ni : \u03b9\ng : G i\n\u22a2 (AddMonoidHom.comp (map g\u2082 hg\u2082) (map g\u2081 hg\u2081)) ((of G f i) g) =\n    (map (fun i => AddMonoidHom.comp (g\u2082 i) (g\u2081 i)) \u22ef) ((of G f i) g)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean", "full_name": "Polynomial.natDegree_prod'", "start": [193, 1], "end": [195, 70], "traced_tactics": [{"tactic": "simpa using natDegree_multiset_prod' (s.1.map f) (by simpa using h)", "annotated_tactic": ["simpa using <a>natDegree_multiset_prod'</a> (s.1.<a>map</a> f) (by simpa using h)", [{"full_name": "Polynomial.natDegree_multiset_prod'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Polynomial/BigOperators.lean", "def_pos": [176, 9], "def_end_pos": [176, 33]}, {"full_name": "Multiset.map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1185, 5], "def_end_pos": [1185, 8]}]], "state_before": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nh : \u220f i in s, leadingCoeff (f i) \u2260 0\n\u22a2 natDegree (\u220f i in s, f i) = \u2211 i in s, natDegree (f i)", "state_after": "no goals"}, {"tactic": "simpa using h", "annotated_tactic": ["simpa using h", []], "state_before": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nh : \u220f i in s, leadingCoeff (f i) \u2260 0\n\u22a2 prod (Multiset.map (fun f => leadingCoeff f) (Multiset.map f s.val)) \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousOn.lean", "full_name": "continuousOn_to_generateFrom_iff", "start": [1126, 1], "end": [1132, 45], "traced_tactics": [{"tactic": "delta ContinuousWithinAt", "annotated_tactic": ["delta <a>ContinuousWithinAt</a>", [{"full_name": "ContinuousWithinAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [163, 5], "def_end_pos": [163, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\ns : Set \u03b1\nT : Set (Set \u03b2)\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\nx\u271d : x \u2208 s\n\u22a2 ContinuousWithinAt f s x \u2194 \u2200 t \u2208 T, f x \u2208 t \u2192 f \u207b\u00b9' t \u2208 \ud835\udcdd[s] x", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\ns : Set \u03b1\nT : Set (Set \u03b2)\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\nx\u271d : x \u2208 s\n\u22a2 Tendsto f (\ud835\udcdd[s] x) (\ud835\udcdd (f x)) \u2194 \u2200 t \u2208 T, f x \u2208 t \u2192 f \u207b\u00b9' t \u2208 \ud835\udcdd[s] x"}, {"tactic": "simp only [TopologicalSpace.nhds_generateFrom, tendsto_iInf, tendsto_principal, mem_setOf_eq,\n  and_imp]", "annotated_tactic": ["simp only [<a>TopologicalSpace.nhds_generateFrom</a>, <a>tendsto_iInf</a>, <a>tendsto_principal</a>, <a>mem_setOf_eq</a>,\n      <a>and_imp</a>]", [{"full_name": "TopologicalSpace.nhds_generateFrom", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [78, 9], "def_end_pos": [78, 26]}, {"full_name": "Filter.tendsto_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3163, 9], "def_end_pos": [3163, 21]}, {"full_name": "Filter.tendsto_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3198, 17], "def_end_pos": [3198, 34]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}, {"full_name": "and_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [108, 17], "def_end_pos": [108, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\ns : Set \u03b1\nT : Set (Set \u03b2)\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\nx\u271d : x \u2208 s\n\u22a2 Tendsto f (\ud835\udcdd[s] x) (\ud835\udcdd (f x)) \u2194 \u2200 t \u2208 T, f x \u2208 t \u2192 f \u207b\u00b9' t \u2208 \ud835\udcdd[s] x", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\ns : Set \u03b1\nT : Set (Set \u03b2)\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\nx\u271d : x \u2208 s\n\u22a2 (\u2200 (i : Set \u03b2), f x \u2208 i \u2192 i \u2208 T \u2192 \u2200\u1da0 (a : \u03b1) in \ud835\udcdd[s] x, f a \u2208 i) \u2194 \u2200 t \u2208 T, f x \u2208 t \u2192 f \u207b\u00b9' t \u2208 \ud835\udcdd[s] x"}, {"tactic": "exact forall_congr' fun t => forall_swap", "annotated_tactic": ["exact <a>forall_congr'</a> fun t => <a>forall_swap</a>", [{"full_name": "forall_congr'", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}, {"full_name": "forall_swap", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [654, 9], "def_end_pos": [654, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\ns : Set \u03b1\nT : Set (Set \u03b2)\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\nx\u271d : x \u2208 s\n\u22a2 (\u2200 (i : Set \u03b2), f x \u2208 i \u2192 i \u2208 T \u2192 \u2200\u1da0 (a : \u03b1) in \ud835\udcdd[s] x, f a \u2208 i) \u2194 \u2200 t \u2208 T, f x \u2208 t \u2192 f \u207b\u00b9' t \u2208 \ud835\udcdd[s] x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "full_name": "MeasureTheory.SimpleFunc.range_comp_subset_range", "start": [352, 1], "end": [354, 89], "traced_tactics": [{"tactic": "simp only [coe_range, coe_comp, Set.range_comp_subset_range]", "annotated_tactic": ["simp only [<a>coe_range</a>, <a>coe_comp</a>, <a>Set.range_comp_subset_range</a>]", [{"full_name": "MeasureTheory.SimpleFunc.coe_range", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [116, 9], "def_end_pos": [116, 18]}, {"full_name": "MeasureTheory.SimpleFunc.coe_comp", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [347, 9], "def_end_pos": [347, 17]}, {"full_name": "Set.range_comp_subset_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [739, 9], "def_end_pos": [739, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b2 \u2192\u209b \u03b3\ng : \u03b1 \u2192 \u03b2\nhgm : Measurable g\n\u22a2 \u2191(SimpleFunc.range (comp f g hgm)) \u2286 \u2191(SimpleFunc.range f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "MeasurableSet.measurableSet_limsup", "start": [2187, 1], "end": [2189, 74], "traced_tactics": [{"tactic": "simpa only [\u2190 blimsup_true] using measurableSet_blimsup fun n _ => hs n", "annotated_tactic": ["simpa only [\u2190 <a>blimsup_true</a>] using <a>measurableSet_blimsup</a> fun n _ => hs n", [{"full_name": "Filter.blimsup_true", "def_path": ".lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean", "def_pos": [491, 9], "def_end_pos": [491, 21]}, {"full_name": "MeasurableSet.measurableSet_blimsup", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [2173, 9], "def_end_pos": [2173, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : \u2115 \u2192 Set \u03b1\nhs : \u2200 (n : \u2115), MeasurableSet (s n)\n\u22a2 MeasurableSet (limsup s atTop)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.HasBasis.prod", "start": [921, 1], "end": [924, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.ofNat'_one", "start": [575, 1], "end": [575, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "full_name": "AffineIsometry.coe_toAffineIsometryEquiv", "start": [107, 1], "end": [109, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounded.lean", "full_name": "Set.bounded_le_iff_bounded_lt", "start": [108, 1], "end": [113, 53], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, bounded_le_of_bounded_lt\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, <a>bounded_le_of_bounded_lt</a>\u27e9", [{"full_name": "Set.bounded_le_of_bounded_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounded.lean", "def_pos": [94, 9], "def_end_pos": [94, 33]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u22a2 Bounded (fun x x_1 => x \u2264 x_1) s \u2194 Bounded (fun x x_1 => x < x_1) s", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : Bounded (fun x x_1 => x \u2264 x_1) s\n\u22a2 Bounded (fun x x_1 => x < x_1) s"}, {"tactic": "cases' h with a ha", "annotated_tactic": ["cases' h with a ha", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : Bounded (fun x x_1 => x \u2264 x_1) s\n\u22a2 Bounded (fun x x_1 => x < x_1) s", "state_after": "case intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na : \u03b1\nha : \u2200 b \u2208 s, (fun x x_1 => x \u2264 x_1) b a\n\u22a2 Bounded (fun x x_1 => x < x_1) s"}, {"tactic": "cases' exists_gt a with b hb", "annotated_tactic": ["cases' <a>exists_gt</a> a with b hb", [{"full_name": "NoMaxOrder.exists_gt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Max.lean", "def_pos": [61, 3], "def_end_pos": [61, 12]}]], "state_before": "case intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na : \u03b1\nha : \u2200 b \u2208 s, (fun x x_1 => x \u2264 x_1) b a\n\u22a2 Bounded (fun x x_1 => x < x_1) s", "state_after": "case intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na : \u03b1\nha : \u2200 b \u2208 s, (fun x x_1 => x \u2264 x_1) b a\nb : \u03b1\nhb : a < b\n\u22a2 Bounded (fun x x_1 => x < x_1) s"}, {"tactic": "exact \u27e8b, fun c hc => lt_of_le_of_lt (ha c hc) hb\u27e9", "annotated_tactic": ["exact \u27e8b, fun c hc => <a>lt_of_le_of_lt</a> (ha c hc) hb\u27e9", [{"full_name": "lt_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na : \u03b1\nha : \u2200 b \u2208 s, (fun x x_1 => x \u2264 x_1) b a\nb : \u03b1\nhb : a < b\n\u22a2 Bounded (fun x x_1 => x < x_1) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Index.lean", "full_name": "Subgroup.relindex_ne_zero_trans", "start": [409, 1], "end": [412, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Fin.lean", "full_name": "Fin.prod_univ_six", "start": [144, 1], "end": [147, 6], "traced_tactics": [{"tactic": "rw [prod_univ_castSucc, prod_univ_five]", "annotated_tactic": ["rw [<a>prod_univ_castSucc</a>, <a>prod_univ_five</a>]", [{"full_name": "Fin.prod_univ_castSucc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [92, 9], "def_end_pos": [92, 27]}, {"full_name": "Fin.prod_univ_five", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [136, 9], "def_end_pos": [136, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 6 \u2192 \u03b2\n\u22a2 \u220f i : Fin 6, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 6 \u2192 \u03b2\n\u22a2 f (castSucc 0) * f (castSucc 1) * f (castSucc 2) * f (castSucc 3) * f (castSucc 4) * f (last 5) =\n    f 0 * f 1 * f 2 * f 3 * f 4 * f 5"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 6 \u2192 \u03b2\n\u22a2 f (castSucc 0) * f (castSucc 1) * f (castSucc 2) * f (castSucc 3) * f (castSucc 4) * f (last 5) =\n    f 0 * f 1 * f 2 * f 3 * f 4 * f 5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Hull.lean", "full_name": "mem_convexHull_iff", "start": [62, 1], "end": [63, 45], "traced_tactics": [{"tactic": "simp_rw [convexHull_eq_iInter, mem_iInter]", "annotated_tactic": ["simp_rw [<a>convexHull_eq_iInter</a>, <a>mem_iInter</a>]", [{"full_name": "convexHull_eq_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Convex/Hull.lean", "def_pos": [56, 9], "def_end_pos": [56, 29]}, {"full_name": "Set.mem_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [278, 9], "def_end_pos": [278, 19]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\ns t : Set E\nx y : E\n\u22a2 x \u2208 (convexHull \ud835\udd5c) s \u2194 \u2200 (t : Set E), s \u2286 t \u2192 Convex \ud835\udd5c t \u2192 x \u2208 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/DirectSum/Basic.lean", "full_name": "DirectSum.sub_apply", "start": [85, 1], "end": [86, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Hom.lean", "full_name": "NormedAddGroupHom.ofLipschitz_norm_le", "start": [303, 1], "end": [305, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Pointwise.lean", "full_name": "Submonoid.smul_mem_pointwise_smul_iff\u2080", "start": [307, 1], "end": [309, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.imLm_coe", "start": [1030, 1], "end": [1031, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "Disjoint.le_of_codisjoint", "start": [459, 1], "end": [461, 39], "traced_tactics": [{"tactic": "rw [\u2190 @inf_top_eq _ _ _ a, \u2190 @bot_sup_eq _ _ _ c, \u2190 hab.eq_bot, \u2190 hbc.eq_top, sup_inf_right]", "annotated_tactic": ["rw [\u2190 @<a>inf_top_eq</a> _ _ _ a, \u2190 @<a>bot_sup_eq</a> _ _ _ c, \u2190 hab.eq_bot, \u2190 hbc.eq_top, <a>sup_inf_right</a>]", [{"full_name": "inf_top_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [446, 7], "def_end_pos": [446, 17]}, {"full_name": "bot_sup_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [422, 9], "def_end_pos": [422, 19]}, {"full_name": "sup_inf_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [726, 9], "def_end_pos": [726, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : BoundedOrder \u03b1\na b c : \u03b1\nhab : Disjoint a b\nhbc : Codisjoint b c\n\u22a2 a \u2264 c", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : BoundedOrder \u03b1\na b c : \u03b1\nhab : Disjoint a b\nhbc : Codisjoint b c\n\u22a2 a \u2293 (b \u2294 c) \u2264 (a \u2294 c) \u2293 (b \u2294 c)"}, {"tactic": "exact inf_le_inf_right _ le_sup_left", "annotated_tactic": ["exact <a>inf_le_inf_right</a> _ <a>le_sup_left</a>", [{"full_name": "inf_le_inf_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [451, 9], "def_end_pos": [451, 25]}, {"full_name": "le_sup_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [112, 9], "def_end_pos": [112, 20]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : BoundedOrder \u03b1\na b c : \u03b1\nhab : Disjoint a b\nhbc : Codisjoint b c\n\u22a2 a \u2293 (b \u2294 c) \u2264 (a \u2294 c) \u2293 (b \u2294 c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.eventually_bot", "start": [1228, 1], "end": [1229, 5], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Extr.lean", "full_name": "IsMaxOn.bicomp_mono", "start": [386, 1], "end": [389, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.exp_sum", "start": [834, 1], "end": [836, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Module.lean", "full_name": "LinearMap.extendScalarsOfIsLocalization_apply", "start": [215, 1], "end": [216, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.coe_smul", "start": [169, 1], "end": [171, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Monoid.lean", "full_name": "Set.image_add_const_Ioc", "start": [98, 1], "end": [99, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Equiv.lean", "full_name": "LinearEquiv.eq_symm_apply", "start": [397, 1], "end": [398, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Alternating/Basic.lean", "full_name": "AlternatingMap.coe_multilinearMap_mk", "start": [165, 1], "end": [168, 10], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2070 : Semiring R\nM : Type u_2\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\nN : Type u_3\ninst\u271d\u2077 : AddCommMonoid N\ninst\u271d\u2076 : Module R N\nP : Type u_4\ninst\u271d\u2075 : AddCommMonoid P\ninst\u271d\u2074 : Module R P\nM' : Type u_5\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\nN' : Type u_6\ninst\u271d\u00b9 : AddCommGroup N'\ninst\u271d : Module R N'\n\u03b9 : Type u_7\n\u03b9' : Type u_8\n\u03b9'' : Type u_9\nf\u271d f' : M [\u22c0^\u03b9]\u2192\u2097[R] N\ng g\u2082 : M [\u22c0^\u03b9]\u2192\u2097[R] N'\ng' : M' [\u22c0^\u03b9]\u2192\u2097[R] N'\nv : \u03b9 \u2192 M\nv' : \u03b9 \u2192 M'\nf : (\u03b9 \u2192 M) \u2192 N\nh\u2081 :\n  \u2200 [inst : DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) (x y : M), f (update m i (x + y)) = f (update m i x) + f (update m i y)\nh\u2082 : \u2200 [inst : DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) (c : R) (x : M), f (update m i (c \u2022 x)) = c \u2022 f (update m i x)\nh\u2083 : \u2200 (v : \u03b9 \u2192 M) (i j : \u03b9), v i = v j \u2192 i \u2260 j \u2192 { toFun := f, map_add' := \u22ef, map_smul' := \u22ef }.toFun v = 0\n\u22a2 \u2191{ toMultilinearMap := { toFun := f, map_add' := \u22ef, map_smul' := \u22ef }, map_eq_zero_of_eq' := h\u2083 } =\n    { toFun := f, map_add' := h\u2081, map_smul' := h\u2082 }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.smul_subset_smul_right", "start": [176, 1], "end": [177, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.floor_sub_one", "start": [821, 9], "end": [821, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.lawfulMonad", "start": [2184, 11], "end": [2193, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isBigOWith_norm_norm", "start": [841, 1], "end": [843, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "full_name": "MulChar.coe_toMonoidHom", "start": [238, 1], "end": [240, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.right_dom_of_inter_dom", "start": [830, 1], "end": [830, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.sup_liminf", "start": [1142, 1], "end": [1145, 44], "traced_tactics": [{"tactic": "simp only [liminf_eq_iSup_iInf]", "annotated_tactic": ["simp only [<a>liminf_eq_iSup_iInf</a>]", [{"full_name": "Filter.liminf_eq_iSup_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean", "def_pos": [877, 9], "def_end_pos": [877, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ninst\u271d : CompleteDistribLattice \u03b1\nf : Filter \u03b2\np q : \u03b2 \u2192 Prop\nu : \u03b2 \u2192 \u03b1\na : \u03b1\n\u22a2 a \u2294 liminf u f = liminf (fun x => a \u2294 u x) f", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ninst\u271d : CompleteDistribLattice \u03b1\nf : Filter \u03b2\np q : \u03b2 \u2192 Prop\nu : \u03b2 \u2192 \u03b1\na : \u03b1\n\u22a2 a \u2294 \u2a06 s \u2208 f, \u2a05 a \u2208 s, u a = \u2a06 s \u2208 f, \u2a05 a_1 \u2208 s, a \u2294 u a_1"}, {"tactic": "rw [sup_comm, biSup_sup (\u27e8univ, univ_mem\u27e9 : \u2203 i : Set \u03b2, i \u2208 f)]", "annotated_tactic": ["rw [<a>sup_comm</a>, <a>biSup_sup</a> (\u27e8<a>univ</a>, <a>univ_mem</a>\u27e9 : \u2203 i : <a>Set</a> \u03b2, i \u2208 f)]", [{"full_name": "sup_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}, {"full_name": "biSup_sup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1229, 9], "def_end_pos": [1229, 18]}, {"full_name": "Set.univ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [153, 5], "def_end_pos": [153, 9]}, {"full_name": "Filter.univ_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [148, 9], "def_end_pos": [148, 17]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ninst\u271d : CompleteDistribLattice \u03b1\nf : Filter \u03b2\np q : \u03b2 \u2192 Prop\nu : \u03b2 \u2192 \u03b1\na : \u03b1\n\u22a2 a \u2294 \u2a06 s \u2208 f, \u2a05 a \u2208 s, u a = \u2a06 s \u2208 f, \u2a05 a_1 \u2208 s, a \u2294 u a_1", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ninst\u271d : CompleteDistribLattice \u03b1\nf : Filter \u03b2\np q : \u03b2 \u2192 Prop\nu : \u03b2 \u2192 \u03b1\na : \u03b1\n\u22a2 \u2a06 i \u2208 f, (\u2a05 a \u2208 i, u a) \u2294 a = \u2a06 s \u2208 f, \u2a05 a_1 \u2208 s, a \u2294 u a_1"}, {"tactic": "simp_rw [iInf\u2082_sup_eq, sup_comm (a := a)]", "annotated_tactic": ["simp_rw [<a>iInf\u2082_sup_eq</a>, <a>sup_comm</a> (a := a)]", [{"full_name": "iInf\u2082_sup_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteBooleanAlgebra.lean", "def_pos": [325, 9], "def_end_pos": [325, 21]}, {"full_name": "sup_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ninst\u271d : CompleteDistribLattice \u03b1\nf : Filter \u03b2\np q : \u03b2 \u2192 Prop\nu : \u03b2 \u2192 \u03b1\na : \u03b1\n\u22a2 \u2a06 i \u2208 f, (\u2a05 a \u2208 i, u a) \u2294 a = \u2a06 s \u2208 f, \u2a05 a_1 \u2208 s, a \u2294 u a_1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "strictMono_dual_iff", "start": [255, 1], "end": [256, 62], "traced_tactics": [{"tactic": "rw [strictMono_toDual_comp_iff, strictAnti_comp_ofDual_iff]", "annotated_tactic": ["rw [<a>strictMono_toDual_comp_iff</a>, <a>strictAnti_comp_ofDual_iff</a>]", [{"full_name": "strictMono_toDual_comp_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [214, 9], "def_end_pos": [214, 35]}, {"full_name": "strictAnti_comp_ofDual_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 35]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 StrictMono (\u21d1toDual \u2218 f \u2218 \u21d1ofDual) \u2194 StrictMono f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Isometry.lean", "full_name": "IsometryEquiv.image_sphere", "start": [632, 1], "end": [634, 60], "traced_tactics": [{"tactic": "rw [\u2190 h.preimage_symm, h.symm.preimage_sphere, symm_symm]", "annotated_tactic": ["rw [\u2190 h.preimage_symm, h.symm.preimage_sphere, <a>symm_symm</a>]", [{"full_name": "IsometryEquiv.symm_symm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Isometry.lean", "def_pos": [419, 9], "def_end_pos": [419, 18]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nh\u271d h : \u03b1 \u2243\u1d62 \u03b2\nx : \u03b1\nr : \u211d\n\u22a2 \u21d1h '' Metric.sphere x r = Metric.sphere (h x) r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Countable/Basic.lean", "full_name": "nonempty_embedding_nat", "start": [41, 1], "end": [42, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "eq_of_prime_pow_eq'", "start": [778, 1], "end": [781, 50], "traced_tactics": [{"tactic": "rw [\u2190 associated_iff_eq] at h \u22a2", "annotated_tactic": ["rw [\u2190 <a>associated_iff_eq</a>] at h \u22a2", [{"full_name": "associated_iff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [748, 9], "def_end_pos": [748, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR : Type u_5\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Unique R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082\n\u22a2 p\u2081 = p\u2082", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR : Type u_5\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Unique R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh : p\u2081 ^ k\u2081 ~\u1d64 p\u2082 ^ k\u2082\n\u22a2 p\u2081 ~\u1d64 p\u2082"}, {"tactic": "apply h.of_pow_associated_of_prime' hp\u2081 hp\u2082 hk\u2081", "annotated_tactic": ["apply h.of_pow_associated_of_prime' hp\u2081 hp\u2082 hk\u2081", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR : Type u_5\ninst\u271d\u00b9 : CancelCommMonoidWithZero R\ninst\u271d : Unique R\u02e3\np\u2081 p\u2082 : R\nk\u2081 k\u2082 : \u2115\nhp\u2081 : Prime p\u2081\nhp\u2082 : Prime p\u2082\nhk\u2081 : 0 < k\u2082\nh : p\u2081 ^ k\u2081 ~\u1d64 p\u2082 ^ k\u2082\n\u22a2 p\u2081 ~\u1d64 p\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.sep_inter", "start": [1455, 1], "end": [1456, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.equiv_iff_eq", "start": [839, 1], "end": [841, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AddTorsor.lean", "full_name": "dist_left_lineMap", "start": [104, 1], "end": [105, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/CharZero.lean", "full_name": "Int.cast_eq_zero", "start": [24, 1], "end": [31, 35], "traced_tactics": [{"tactic": "cases n", "annotated_tactic": ["cases n", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\nn : \u2124\nh : \u2191n = 0\n\u22a2 n = 0", "state_after": "case ofNat\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na\u271d : \u2115\nh : \u2191(ofNat a\u271d) = 0\n\u22a2 ofNat a\u271d = 0\n\ncase negSucc\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na\u271d : \u2115\nh : \u2191-[a\u271d+1] = 0\n\u22a2 -[a\u271d+1] = 0"}, {"tactic": "erw [Int.cast_ofNat] at h", "annotated_tactic": ["erw [<a>Int.cast_ofNat</a>] at h", [{"full_name": "Int.cast_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}]], "state_before": "case ofNat\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na\u271d : \u2115\nh : \u2191(ofNat a\u271d) = 0\n\u22a2 ofNat a\u271d = 0", "state_after": "case ofNat\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na\u271d : \u2115\nh : \u2191a\u271d = 0\n\u22a2 ofNat a\u271d = 0"}, {"tactic": "exact congr_arg _ (Nat.cast_eq_zero.1 h)", "annotated_tactic": ["exact <a>congr_arg</a> _ (<a>Nat.cast_eq_zero</a>.1 h)", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "Nat.cast_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharZero/Defs.lean", "def_pos": [79, 9], "def_end_pos": [79, 21]}]], "state_before": "case ofNat\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na\u271d : \u2115\nh : \u2191a\u271d = 0\n\u22a2 ofNat a\u271d = 0", "state_after": "no goals"}, {"tactic": "rw [cast_negSucc, neg_eq_zero, Nat.cast_eq_zero] at h", "annotated_tactic": ["rw [<a>cast_negSucc</a>, <a>neg_eq_zero</a>, <a>Nat.cast_eq_zero</a>] at h", [{"full_name": "Int.cast_negSucc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [53, 9], "def_end_pos": [53, 21]}, {"full_name": "neg_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [497, 3], "def_end_pos": [497, 14]}, {"full_name": "Nat.cast_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharZero/Defs.lean", "def_pos": [79, 9], "def_end_pos": [79, 21]}]], "state_before": "case negSucc\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na\u271d : \u2115\nh : \u2191-[a\u271d+1] = 0\n\u22a2 -[a\u271d+1] = 0", "state_after": "case negSucc\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na\u271d : \u2115\nh : a\u271d + 1 = 0\n\u22a2 -[a\u271d+1] = 0"}, {"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "case negSucc\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na\u271d : \u2115\nh : a\u271d + 1 = 0\n\u22a2 -[a\u271d+1] = 0", "state_after": "no goals"}, {"tactic": "rw [h, cast_zero]", "annotated_tactic": ["rw [h, <a>cast_zero</a>]", [{"full_name": "Int.cast_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\nn : \u2124\nh : n = 0\n\u22a2 \u2191n = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.pow_sup_eq_top", "start": [783, 1], "end": [785, 37], "traced_tactics": [{"tactic": "rw [\u2190 Finset.card_range n, \u2190 Finset.prod_const]", "annotated_tactic": ["rw [\u2190 <a>Finset.card_range</a> n, \u2190 <a>Finset.prod_const</a>]", [{"full_name": "Finset.card_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [199, 9], "def_end_pos": [199, 19]}, {"full_name": "Finset.prod_const", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1665, 9], "def_end_pos": [1665, 19]}]], "state_before": "R : Type u\n\u03b9 : Type u_1\ninst\u271d : CommSemiring R\nI J K L : Ideal R\nn : \u2115\nh : I \u2294 J = \u22a4\n\u22a2 I ^ n \u2294 J = \u22a4", "state_after": "R : Type u\n\u03b9 : Type u_1\ninst\u271d : CommSemiring R\nI J K L : Ideal R\nn : \u2115\nh : I \u2294 J = \u22a4\n\u22a2 (\u220f _x in Finset.range n, I) \u2294 J = \u22a4"}, {"tactic": "exact prod_sup_eq_top fun _ _ => h", "annotated_tactic": ["exact <a>prod_sup_eq_top</a> fun _ _ => h", [{"full_name": "Ideal.prod_sup_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [770, 9], "def_end_pos": [770, 24]}]], "state_before": "R : Type u\n\u03b9 : Type u_1\ninst\u271d : CommSemiring R\nI J K L : Ideal R\nn : \u2115\nh : I \u2294 J = \u22a4\n\u22a2 (\u220f _x in Finset.range n, I) \u2294 J = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/ModEq.lean", "full_name": "Nat.ModEq.mul_right'", "start": [122, 11], "end": [123, 63], "traced_tactics": [{"tactic": "rw [mul_comm a, mul_comm b, mul_comm n]", "annotated_tactic": ["rw [<a>mul_comm</a> a, <a>mul_comm</a> b, <a>mul_comm</a> n]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "m n a b c\u271d d c : \u2115\nh : a \u2261 b [MOD n]\n\u22a2 a * c \u2261 b * c [MOD n * c]", "state_after": "m n a b c\u271d d c : \u2115\nh : a \u2261 b [MOD n]\n\u22a2 c * a \u2261 c * b [MOD c * n]"}, {"tactic": "exact h.mul_left' c", "annotated_tactic": ["exact h.mul_left' c", []], "state_before": "m n a b c\u271d d c : \u2115\nh : a \u2261 b [MOD n]\n\u22a2 c * a \u2261 c * b [MOD c * n]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.aroots_def", "start": [1081, 1], "end": [1083, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/FinitePresentation.lean", "full_name": "AlgHom.FiniteType.of_finitePresentation", "start": [489, 1], "end": [490, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.constantCoeff_eq", "start": [890, 1], "end": [891, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Lift.lean", "full_name": "Filter.lift_iInf_of_directed", "start": [216, 1], "end": [220, 63], "traced_tactics": [{"tactic": "simp only [mem_lift_sets hg, exists_imp, and_imp, mem_iInf_of_directed hf]", "annotated_tactic": ["simp only [<a>mem_lift_sets</a> hg, <a>exists_imp</a>, <a>and_imp</a>, <a>mem_iInf_of_directed</a> hf]", [{"full_name": "Filter.mem_lift_sets", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Lift.lean", "def_pos": [73, 9], "def_end_pos": [73, 22]}, {"full_name": "exists_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [133, 9], "def_end_pos": [133, 19]}, {"full_name": "and_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [108, 17], "def_end_pos": [108, 24]}, {"full_name": "Filter.mem_iInf_of_directed", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [847, 9], "def_end_pos": [847, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng\u271d g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhf : Directed (fun x x_1 => x \u2265 x_1) f\nhg : Monotone g\ns : Set \u03b2\n\u22a2 s \u2208 Filter.lift (iInf f) g \u2192 s \u2208 \u2a05 i, Filter.lift (f i) g", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng\u271d g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhf : Directed (fun x x_1 => x \u2265 x_1) f\nhg : Monotone g\ns : Set \u03b2\n\u22a2 \u2200 (x : Set \u03b1) (x_1 : \u03b9), x \u2208 f x_1 \u2192 s \u2208 g x \u2192 s \u2208 \u2a05 i, Filter.lift (f i) g"}, {"tactic": "exact fun t i ht hs => mem_iInf_of_mem i <| mem_lift ht hs", "annotated_tactic": ["exact fun t i ht hs => <a>mem_iInf_of_mem</a> i <| <a>mem_lift</a> ht hs", [{"full_name": "Filter.mem_iInf_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [609, 9], "def_end_pos": [609, 24]}, {"full_name": "Filter.mem_lift", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Lift.lean", "def_pos": [84, 9], "def_end_pos": [84, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng\u271d g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Filter \u03b1\ng : Set \u03b1 \u2192 Filter \u03b2\nhf : Directed (fun x x_1 => x \u2265 x_1) f\nhg : Monotone g\ns : Set \u03b2\n\u22a2 \u2200 (x : Set \u03b1) (x_1 : \u03b9), x \u2208 f x_1 \u2192 s \u2208 g x \u2192 s \u2208 \u2a05 i, Filter.lift (f i) g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean", "full_name": "tsum_eq_zero_add", "start": [212, 1], "end": [214, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "AffineSubspace.coe_direction_eq_vsub_set_right", "start": [283, 1], "end": [290, 32], "traced_tactics": [{"tactic": "rw [coe_direction_eq_vsub_set \u27e8p, hp\u27e9]", "annotated_tactic": ["rw [<a>coe_direction_eq_vsub_set</a> \u27e8p, hp\u27e9]", [{"full_name": "AffineSubspace.coe_direction_eq_vsub_set", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [234, 9], "def_end_pos": [234, 34]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\n\u22a2 \u2191(direction s) = (fun x => x -\u1d65 p) '' \u2191s", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\n\u22a2 \u2191s -\u1d65 \u2191s = (fun x => x -\u1d65 p) '' \u2191s"}, {"tactic": "refine' le_antisymm _ _", "annotated_tactic": ["refine' <a>le_antisymm</a> _ _", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\n\u22a2 \u2191s -\u1d65 \u2191s = (fun x => x -\u1d65 p) '' \u2191s", "state_after": "case refine'_1\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\n\u22a2 \u2191s -\u1d65 \u2191s \u2264 (fun x => x -\u1d65 p) '' \u2191s\n\ncase refine'_2\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\n\u22a2 (fun x => x -\u1d65 p) '' \u2191s \u2264 \u2191s -\u1d65 \u2191s"}, {"tactic": "rintro v \u27e8p1, hp1, p2, hp2, rfl\u27e9", "annotated_tactic": ["rintro v \u27e8p1, hp1, p2, hp2, rfl\u27e9", []], "state_before": "case refine'_1\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\n\u22a2 \u2191s -\u1d65 \u2191s \u2264 (fun x => x -\u1d65 p) '' \u2191s", "state_after": "case refine'_1.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\np1 : P\nhp1 : p1 \u2208 \u2191s\np2 : P\nhp2 : p2 \u2208 \u2191s\n\u22a2 (fun x x_1 => x -\u1d65 x_1) p1 p2 \u2208 (fun x => x -\u1d65 p) '' \u2191s"}, {"tactic": "exact \u27e8p1 -\u1d65 p2 +\u1d65 p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, vadd_vsub _ _\u27e9", "annotated_tactic": ["exact \u27e8p1 -\u1d65 p2 +\u1d65 p, <a>vadd_mem_of_mem_direction</a> (<a>vsub_mem_direction</a> hp1 hp2) hp, <a>vadd_vsub</a> _ _\u27e9", [{"full_name": "AffineSubspace.vadd_mem_of_mem_direction", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [249, 9], "def_end_pos": [249, 34]}, {"full_name": "AffineSubspace.vsub_mem_direction", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [260, 9], "def_end_pos": [260, 27]}, {"full_name": "vadd_vsub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [91, 9], "def_end_pos": [91, 18]}]], "state_before": "case refine'_1.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\np1 : P\nhp1 : p1 \u2208 \u2191s\np2 : P\nhp2 : p2 \u2208 \u2191s\n\u22a2 (fun x x_1 => x -\u1d65 x_1) p1 p2 \u2208 (fun x => x -\u1d65 p) '' \u2191s", "state_after": "no goals"}, {"tactic": "rintro v \u27e8p2, hp2, rfl\u27e9", "annotated_tactic": ["rintro v \u27e8p2, hp2, rfl\u27e9", []], "state_before": "case refine'_2\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\n\u22a2 (fun x => x -\u1d65 p) '' \u2191s \u2264 \u2191s -\u1d65 \u2191s", "state_after": "case refine'_2.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\np2 : P\nhp2 : p2 \u2208 \u2191s\n\u22a2 (fun x => x -\u1d65 p) p2 \u2208 \u2191s -\u1d65 \u2191s"}, {"tactic": "exact \u27e8p2, hp2, p, hp, rfl\u27e9", "annotated_tactic": ["exact \u27e8p2, hp2, p, hp, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case refine'_2.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : AffineSubspace k P\np : P\nhp : p \u2208 s\np2 : P\nhp2 : p2 \u2208 \u2191s\n\u22a2 (fun x => x -\u1d65 p) p2 \u2208 \u2191s -\u1d65 \u2191s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.biUnion_mono", "start": [3807, 1], "end": [3810, 73], "traced_tactics": [{"tactic": "have : \u2200 b a, a \u2208 s \u2192 b \u2208 t\u2081 a \u2192 \u2203 a : \u03b1, a \u2208 s \u2227 b \u2208 t\u2082 a := fun b a ha hb =>\n  \u27e8a, ha, Finset.mem_of_subset (h a ha) hb\u27e9", "annotated_tactic": ["have : \u2200 b a, a \u2208 s \u2192 b \u2208 t\u2081 a \u2192 \u2203 a : \u03b1, a \u2208 s \u2227 b \u2208 t\u2082 a := fun b a ha hb =>\n    \u27e8a, ha, <a>Finset.mem_of_subset</a> (h a ha) hb\u27e9", [{"full_name": "Finset.mem_of_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [364, 9], "def_end_pos": [364, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ns s\u2081 s\u2082 : Finset \u03b1\nt t\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2\nh : \u2200 a \u2208 s, t\u2081 a \u2286 t\u2082 a\n\u22a2 Finset.biUnion s t\u2081 \u2286 Finset.biUnion s t\u2082", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ns s\u2081 s\u2082 : Finset \u03b1\nt t\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2\nh : \u2200 a \u2208 s, t\u2081 a \u2286 t\u2082 a\nthis : \u2200 (b : \u03b2), \u2200 a \u2208 s, b \u2208 t\u2081 a \u2192 \u2203 a \u2208 s, b \u2208 t\u2082 a\n\u22a2 Finset.biUnion s t\u2081 \u2286 Finset.biUnion s t\u2082"}, {"tactic": "simpa only [subset_iff, mem_biUnion, exists_imp, and_imp, exists_prop]", "annotated_tactic": ["simpa only [<a>subset_iff</a>, <a>mem_biUnion</a>, <a>exists_imp</a>, <a>and_imp</a>, <a>exists_prop</a>]", [{"full_name": "Finset.subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [376, 9], "def_end_pos": [376, 19]}, {"full_name": "Finset.mem_biUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3741, 9], "def_end_pos": [3741, 20]}, {"full_name": "exists_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [133, 9], "def_end_pos": [133, 19]}, {"full_name": "and_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [108, 17], "def_end_pos": [108, 24]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ns s\u2081 s\u2082 : Finset \u03b1\nt t\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2\nh : \u2200 a \u2208 s, t\u2081 a \u2286 t\u2082 a\nthis : \u2200 (b : \u03b2), \u2200 a \u2208 s, b \u2208 t\u2081 a \u2192 \u2203 a \u2208 s, b \u2208 t\u2082 a\n\u22a2 Finset.biUnion s t\u2081 \u2286 Finset.biUnion s t\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "isOpen_pi_iff", "start": [1415, 1], "end": [1439, 81], "traced_tactics": [{"tactic": "rw [isOpen_iff_nhds]", "annotated_tactic": ["rw [<a>isOpen_iff_nhds</a>]", [{"full_name": "isOpen_iff_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1171, 9], "def_end_pos": [1171, 24]}]], "state_before": "X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\n\u22a2 IsOpen s \u2194 \u2200 f \u2208 s, \u2203 I u, (\u2200 a \u2208 I, IsOpen (u a) \u2227 f a \u2208 u a) \u2227 Set.pi (\u2191I) u \u2286 s", "state_after": "X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\n\u22a2 (\u2200 x \u2208 s, \ud835\udcdd x \u2264 \ud835\udcdf s) \u2194 \u2200 f \u2208 s, \u2203 I u, (\u2200 a \u2208 I, IsOpen (u a) \u2227 f a \u2208 u a) \u2227 Set.pi (\u2191I) u \u2286 s"}, {"tactic": "simp_rw [le_principal_iff, nhds_pi, Filter.mem_pi', mem_nhds_iff]", "annotated_tactic": ["simp_rw [<a>le_principal_iff</a>, <a>nhds_pi</a>, <a>Filter.mem_pi'</a>, <a>mem_nhds_iff</a>]", [{"full_name": "Filter.le_principal_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [669, 9], "def_end_pos": [669, 25]}, {"full_name": "nhds_pi", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [1302, 9], "def_end_pos": [1302, 16]}, {"full_name": "Filter.mem_pi'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Pi.lean", "def_pos": [86, 9], "def_end_pos": [86, 16]}, {"full_name": "mem_nhds_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [824, 9], "def_end_pos": [824, 21]}]], "state_before": "X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\n\u22a2 (\u2200 x \u2208 s, \ud835\udcdd x \u2264 \ud835\udcdf s) \u2194 \u2200 f \u2208 s, \u2203 I u, (\u2200 a \u2208 I, IsOpen (u a) \u2227 f a \u2208 u a) \u2227 Set.pi (\u2191I) u \u2286 s", "state_after": "X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\n\u22a2 (\u2200 x \u2208 s, \u2203 I t, (\u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 x i \u2208 t_1) \u2227 Set.pi (\u2191I) t \u2286 s) \u2194\n    \u2200 f \u2208 s, \u2203 I u, (\u2200 a \u2208 I, IsOpen (u a) \u2227 f a \u2208 u a) \u2227 Set.pi (\u2191I) u \u2286 s"}, {"tactic": "refine ball_congr fun a _ => \u27e8?_, ?_\u27e9", "annotated_tactic": ["refine <a>ball_congr</a> fun a _ => \u27e8?_, ?_\u27e9", [{"full_name": "ball_congr", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [1035, 9], "def_end_pos": [1035, 19]}]], "state_before": "X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\n\u22a2 (\u2200 x \u2208 s, \u2203 I t, (\u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 x i \u2208 t_1) \u2227 Set.pi (\u2191I) t \u2286 s) \u2194\n    \u2200 f \u2208 s, \u2203 I u, (\u2200 a \u2208 I, IsOpen (u a) \u2227 f a \u2208 u a) \u2227 Set.pi (\u2191I) u \u2286 s", "state_after": "case refine_1\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\n\u22a2 (\u2203 I t, (\u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1) \u2227 Set.pi (\u2191I) t \u2286 s) \u2192\n    \u2203 I u, (\u2200 a_2 \u2208 I, IsOpen (u a_2) \u2227 a a_2 \u2208 u a_2) \u2227 Set.pi (\u2191I) u \u2286 s\n\ncase refine_2\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\n\u22a2 (\u2203 I u, (\u2200 a_1 \u2208 I, IsOpen (u a_1) \u2227 a a_1 \u2208 u a_1) \u2227 Set.pi (\u2191I) u \u2286 s) \u2192\n    \u2203 I t, (\u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1) \u2227 Set.pi (\u2191I) t \u2286 s"}, {"tactic": "rintro \u27e8I, t, \u27e8h1, h2\u27e9\u27e9", "annotated_tactic": ["rintro \u27e8I, t, \u27e8h1, h2\u27e9\u27e9", []], "state_before": "case refine_1\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\n\u22a2 (\u2203 I t, (\u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1) \u2227 Set.pi (\u2191I) t \u2286 s) \u2192\n    \u2203 I u, (\u2200 a_2 \u2208 I, IsOpen (u a_2) \u2227 a a_2 \u2208 u a_2) \u2227 Set.pi (\u2191I) u \u2286 s", "state_after": "case refine_1.intro.intro.intro\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (i : \u03b9) \u2192 Set (\u03c0 i)\nh1 : \u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 \u2203 I u, (\u2200 a_1 \u2208 I, IsOpen (u a_1) \u2227 a a_1 \u2208 u a_1) \u2227 Set.pi (\u2191I) u \u2286 s"}, {"tactic": "refine \u27e8I, fun a => eval a '' (I : Set \u03b9).pi fun a => (h1 a).choose, fun i hi => ?_, ?_\u27e9", "annotated_tactic": ["refine \u27e8I, fun a => <a>eval</a> a '' (I : <a>Set</a> \u03b9).<a>pi</a> fun a => (h1 a).<a>choose</a>, fun i hi => ?_, ?_\u27e9", [{"full_name": "Function.eval", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [30, 24], "def_end_pos": [30, 28]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "Set.pi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [249, 5], "def_end_pos": [249, 7]}, {"full_name": "Exists.choose", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [154, 32], "def_end_pos": [154, 45]}]], "state_before": "case refine_1.intro.intro.intro\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (i : \u03b9) \u2192 Set (\u03c0 i)\nh1 : \u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 \u2203 I u, (\u2200 a_1 \u2208 I, IsOpen (u a_1) \u2227 a a_1 \u2208 u a_1) \u2227 Set.pi (\u2191I) u \u2286 s", "state_after": "case refine_1.intro.intro.intro.refine_1\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (i : \u03b9) \u2192 Set (\u03c0 i)\nh1 : \u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 IsOpen ((fun a_1 => eval a_1 '' Set.pi \u2191I fun a_2 => Exists.choose \u22ef) i) \u2227\n    a i \u2208 (fun a_1 => eval a_1 '' Set.pi \u2191I fun a_2 => Exists.choose \u22ef) i\n\ncase refine_1.intro.intro.intro.refine_2\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (i : \u03b9) \u2192 Set (\u03c0 i)\nh1 : \u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 (Set.pi \u2191I fun a_1 => eval a_1 '' Set.pi \u2191I fun a_2 => Exists.choose \u22ef) \u2286 s"}, {"tactic": "simp_rw [Set.eval_image_pi (Finset.mem_coe.mpr hi)\n    (pi_nonempty_iff.mpr fun i => \u27e8_, fun _ => (h1 i).choose_spec.2.2\u27e9)]", "annotated_tactic": ["simp_rw [<a>Set.eval_image_pi</a> (Finset.mem_coe.mpr hi)\n          (pi_nonempty_iff.mpr fun i => \u27e8_, fun _ => (h1 i).<a>choose_spec</a>.2.2\u27e9)]", [{"full_name": "Set.eval_image_pi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [918, 9], "def_end_pos": [918, 22]}, {"full_name": "Exists.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [157, 9], "def_end_pos": [157, 27]}]], "state_before": "case refine_1.intro.intro.intro.refine_1\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (i : \u03b9) \u2192 Set (\u03c0 i)\nh1 : \u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 IsOpen ((fun a_1 => eval a_1 '' Set.pi \u2191I fun a_2 => Exists.choose \u22ef) i) \u2227\n    a i \u2208 (fun a_1 => eval a_1 '' Set.pi \u2191I fun a_2 => Exists.choose \u22ef) i", "state_after": "case refine_1.intro.intro.intro.refine_1\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (i : \u03b9) \u2192 Set (\u03c0 i)\nh1 : \u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 IsOpen (Exists.choose \u22ef) \u2227 a i \u2208 Exists.choose \u22ef"}, {"tactic": "exact (h1 i).choose_spec.2", "annotated_tactic": ["exact (h1 i).<a>choose_spec</a>.2", [{"full_name": "Exists.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [157, 9], "def_end_pos": [157, 27]}]], "state_before": "case refine_1.intro.intro.intro.refine_1\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (i : \u03b9) \u2192 Set (\u03c0 i)\nh1 : \u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 IsOpen (Exists.choose \u22ef) \u2227 a i \u2208 Exists.choose \u22ef", "state_after": "no goals"}, {"tactic": "exact Subset.trans\n  (Set.pi_mono fun i hi => (Set.eval_image_pi_subset hi).trans (h1 i).choose_spec.1) h2", "annotated_tactic": ["exact <a>Subset.trans</a>\n        (<a>Set.pi_mono</a> fun i hi => (<a>Set.eval_image_pi_subset</a> hi).<a>trans</a> (h1 i).<a>choose_spec</a>.1) h2", [{"full_name": "Set.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [343, 9], "def_end_pos": [343, 21]}, {"full_name": "Set.pi_mono", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [727, 9], "def_end_pos": [727, 16]}, {"full_name": "Set.eval_image_pi_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [903, 9], "def_end_pos": [903, 29]}, {"full_name": "HasSubset.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [667, 7], "def_end_pos": [667, 29]}, {"full_name": "Exists.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [157, 9], "def_end_pos": [157, 27]}]], "state_before": "case refine_1.intro.intro.intro.refine_2\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (i : \u03b9) \u2192 Set (\u03c0 i)\nh1 : \u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 (Set.pi \u2191I fun a_1 => eval a_1 '' Set.pi \u2191I fun a_2 => Exists.choose \u22ef) \u2286 s", "state_after": "no goals"}, {"tactic": "rintro \u27e8I, t, \u27e8h1, h2\u27e9\u27e9", "annotated_tactic": ["rintro \u27e8I, t, \u27e8h1, h2\u27e9\u27e9", []], "state_before": "case refine_2\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\n\u22a2 (\u2203 I u, (\u2200 a_1 \u2208 I, IsOpen (u a_1) \u2227 a a_1 \u2208 u a_1) \u2227 Set.pi (\u2191I) u \u2286 s) \u2192\n    \u2203 I t, (\u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1) \u2227 Set.pi (\u2191I) t \u2286 s", "state_after": "case refine_2.intro.intro.intro\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 \u2203 I t, (\u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1) \u2227 Set.pi (\u2191I) t \u2286 s"}, {"tactic": "refine \u27e8I, fun a => ite (a \u2208 I) (t a) Set.univ, fun i => ?_, ?_\u27e9", "annotated_tactic": ["refine \u27e8I, fun a => <a>ite</a> (a \u2208 I) (t a) <a>Set.univ</a>, fun i => ?_, ?_\u27e9", [{"full_name": "ite", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [962, 21], "def_end_pos": [962, 24]}, {"full_name": "Set.univ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [153, 5], "def_end_pos": [153, 9]}]], "state_before": "case refine_2.intro.intro.intro\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 \u2203 I t, (\u2200 (i : \u03b9), \u2203 t_1 \u2286 t i, IsOpen t_1 \u2227 a i \u2208 t_1) \u2227 Set.pi (\u2191I) t \u2286 s", "state_after": "case refine_2.intro.intro.intro.refine_1\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\n\u22a2 \u2203 t_1 \u2286 (fun a => if a \u2208 I then t a else univ) i, IsOpen t_1 \u2227 a i \u2208 t_1\n\ncase refine_2.intro.intro.intro.refine_2\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 (Set.pi \u2191I fun a => if a \u2208 I then t a else univ) \u2286 s"}, {"tactic": "by_cases hi : i \u2208 I", "annotated_tactic": ["by_cases hi : i \u2208 I", []], "state_before": "case refine_2.intro.intro.intro.refine_1\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\n\u22a2 \u2203 t_1 \u2286 (fun a => if a \u2208 I then t a else univ) i, IsOpen t_1 \u2227 a i \u2208 t_1", "state_after": "case pos\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 \u2203 t_1 \u2286 (fun a => if a \u2208 I then t a else univ) i, IsOpen t_1 \u2227 a i \u2208 t_1\n\ncase neg\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2209 I\n\u22a2 \u2203 t_1 \u2286 (fun a => if a \u2208 I then t a else univ) i, IsOpen t_1 \u2227 a i \u2208 t_1"}, {"tactic": "use t i", "annotated_tactic": ["use t i", []], "state_before": "case pos\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 \u2203 t_1 \u2286 (fun a => if a \u2208 I then t a else univ) i, IsOpen t_1 \u2227 a i \u2208 t_1", "state_after": "case h\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 t i \u2286 (fun a => if a \u2208 I then t a else univ) i \u2227 IsOpen (t i) \u2227 a i \u2208 t i"}, {"tactic": "simp_rw [if_pos hi]", "annotated_tactic": ["simp_rw [<a>if_pos</a> hi]", [{"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}]], "state_before": "case h\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 t i \u2286 (fun a => if a \u2208 I then t a else univ) i \u2227 IsOpen (t i) \u2227 a i \u2208 t i", "state_after": "case h\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 t i \u2286 t i \u2227 IsOpen (t i) \u2227 a i \u2208 t i"}, {"tactic": "exact \u27e8Subset.rfl, (h1 i) hi\u27e9", "annotated_tactic": ["exact \u27e8<a>Subset.rfl</a>, (h1 i) hi\u27e9", [{"full_name": "Set.Subset.rfl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [338, 9], "def_end_pos": [338, 19]}]], "state_before": "case h\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2208 I\n\u22a2 t i \u2286 t i \u2227 IsOpen (t i) \u2227 a i \u2208 t i", "state_after": "no goals"}, {"tactic": "use Set.univ", "annotated_tactic": ["use <a>Set.univ</a>", [{"full_name": "Set.univ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [153, 5], "def_end_pos": [153, 9]}]], "state_before": "case neg\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2209 I\n\u22a2 \u2203 t_1 \u2286 (fun a => if a \u2208 I then t a else univ) i, IsOpen t_1 \u2227 a i \u2208 t_1", "state_after": "case h\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2209 I\n\u22a2 univ \u2286 (fun a => if a \u2208 I then t a else univ) i \u2227 IsOpen univ \u2227 a i \u2208 univ"}, {"tactic": "simp_rw [if_neg hi]", "annotated_tactic": ["simp_rw [<a>if_neg</a> hi]", [{"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}]], "state_before": "case h\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2209 I\n\u22a2 univ \u2286 (fun a => if a \u2208 I then t a else univ) i \u2227 IsOpen univ \u2227 a i \u2208 univ", "state_after": "case h\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2209 I\n\u22a2 univ \u2286 univ \u2227 IsOpen univ \u2227 a i \u2208 univ"}, {"tactic": "exact \u27e8Subset.rfl, isOpen_univ, mem_univ _\u27e9", "annotated_tactic": ["exact \u27e8<a>Subset.rfl</a>, <a>isOpen_univ</a>, <a>mem_univ</a> _\u27e9", [{"full_name": "Set.Subset.rfl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [338, 9], "def_end_pos": [338, 19]}, {"full_name": "isOpen_univ", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [88, 17], "def_end_pos": [88, 28]}, {"full_name": "Set.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [82, 29], "def_end_pos": [82, 37]}]], "state_before": "case h\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\ni : \u03b9\nhi : i \u2209 I\n\u22a2 univ \u2286 univ \u2227 IsOpen univ \u2227 a i \u2208 univ", "state_after": "no goals"}, {"tactic": "rw [\u2190 Set.univ_pi_ite]", "annotated_tactic": ["rw [\u2190 <a>Set.univ_pi_ite</a>]", [{"full_name": "Set.univ_pi_ite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [974, 9], "def_end_pos": [974, 20]}]], "state_before": "case refine_2.intro.intro.intro.refine_2\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 (Set.pi \u2191I fun a => if a \u2208 I then t a else univ) \u2286 s", "state_after": "case refine_2.intro.intro.intro.refine_2\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 (Set.pi univ fun i => if i \u2208 \u2191I then if i \u2208 I then t i else univ else univ) \u2286 s"}, {"tactic": "simp only [\u2190 ite_and, \u2190 Finset.mem_coe, and_self_iff, Set.univ_pi_ite, h2]", "annotated_tactic": ["simp only [\u2190 <a>ite_and</a>, \u2190 <a>Finset.mem_coe</a>, <a>and_self_iff</a>, <a>Set.univ_pi_ite</a>, h2]", [{"full_name": "ite_and", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [1240, 9], "def_end_pos": [1240, 16]}, {"full_name": "Finset.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}, {"full_name": "and_self_iff", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [20, 9], "def_end_pos": [20, 21]}, {"full_name": "Set.univ_pi_ite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [974, 9], "def_end_pos": [974, 20]}]], "state_before": "case refine_2.intro.intro.intro.refine_2\nX : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\n\u03ba : Type u_7\ninst\u271d : TopologicalSpace X\nT : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : X \u2192 (i : \u03b9) \u2192 \u03c0 i\ns : Set ((a : \u03b9) \u2192 \u03c0 a)\na : (a : \u03b9) \u2192 \u03c0 a\nx\u271d : a \u2208 s\nI : Finset \u03b9\nt : (a : \u03b9) \u2192 Set (\u03c0 a)\nh1 : \u2200 a_1 \u2208 I, IsOpen (t a_1) \u2227 a a_1 \u2208 t a_1\nh2 : Set.pi (\u2191I) t \u2286 s\n\u22a2 (Set.pi univ fun i => if i \u2208 \u2191I then if i \u2208 I then t i else univ else univ) \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AddTorsor.lean", "full_name": "dist_left_midpoint", "start": [167, 1], "end": [168, 72], "traced_tactics": [{"tactic": "rw [midpoint, dist_comm, dist_lineMap_left, invOf_eq_inv, \u2190 norm_inv]", "annotated_tactic": ["rw [<a>midpoint</a>, <a>dist_comm</a>, <a>dist_lineMap_left</a>, <a>invOf_eq_inv</a>, \u2190 <a>norm_inv</a>]", [{"full_name": "midpoint", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Midpoint.lean", "def_pos": [43, 5], "def_end_pos": [43, 13]}, {"full_name": "dist_comm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [179, 9], "def_end_pos": [179, 18]}, {"full_name": "dist_lineMap_left", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/AddTorsor.lean", "def_pos": [91, 9], "def_end_pos": [91, 26]}, {"full_name": "invOf_eq_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Invertible/GroupWithZero.lean", "def_pos": [43, 9], "def_end_pos": [43, 21]}, {"full_name": "norm_inv", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Field/Basic.lean", "def_pos": [740, 9], "def_end_pos": [740, 17]}]], "state_before": "\u03b1 : Type u_1\nV : Type u_2\nP : Type u_3\nW : Type u_4\nQ : Type u_5\ninst\u271d\u2079 : SeminormedAddCommGroup V\ninst\u271d\u2078 : PseudoMetricSpace P\ninst\u271d\u2077 : NormedAddTorsor V P\ninst\u271d\u2076 : NormedAddCommGroup W\ninst\u271d\u2075 : MetricSpace Q\ninst\u271d\u2074 : NormedAddTorsor W Q\n\ud835\udd5c : Type u_6\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c V\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c W\ninst\u271d : Invertible 2\np\u2081 p\u2082 : P\n\u22a2 dist p\u2081 (midpoint \ud835\udd5c p\u2081 p\u2082) = \u20162\u2016\u207b\u00b9 * dist p\u2081 p\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "full_name": "mem_nonZeroDivisors_iff_ne_zero", "start": [202, 1], "end": [203, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "List.prev_nthLe", "start": [314, 1], "end": [353, 22], "traced_tactics": [{"tactic": "cases' l with x l", "annotated_tactic": ["cases' l with x l", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nn : \u2115\nhn : n < length l\n\u22a2 prev l (nthLe l n hn) \u22ef = nthLe l ((n + (length l - 1)) % length l) \u22ef", "state_after": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nn : \u2115\nh : Nodup []\nhn : n < length []\n\u22a2 prev [] (nthLe [] n hn) \u22ef = nthLe [] ((n + (length [] - 1)) % length []) \u22ef\n\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d : \u03b1\nn : \u2115\nx : \u03b1\nl : List \u03b1\nh : Nodup (x :: l)\nhn : n < length (x :: l)\n\u22a2 prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef"}, {"tactic": "induction' l with y l hl generalizing n x", "annotated_tactic": ["induction' l with y l hl generalizing n x", []], "state_before": "case cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d : \u03b1\nn : \u2115\nx : \u03b1\nl : List \u03b1\nh : Nodup (x :: l)\nhn : n < length (x :: l)\n\u22a2 prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef", "state_after": "case cons.nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d : \u03b1\nn : \u2115\nx : \u03b1\nh : Nodup [x]\nhn : n < length [x]\n\u22a2 prev [x] (nthLe [x] n hn) \u22ef = nthLe [x] ((n + (length [x] - 1)) % length [x]) \u22ef\n\ncase cons.cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nn : \u2115\nx : \u03b1\nh : Nodup (x :: y :: l)\nhn : n < length (x :: y :: l)\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) n hn) \u22ef =\n    nthLe (x :: y :: l) ((n + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef"}, {"tactic": "simp at hn", "annotated_tactic": ["simp at hn", []], "state_before": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nn : \u2115\nh : Nodup []\nhn : n < length []\n\u22a2 prev [] (nthLe [] n hn) \u22ef = nthLe [] ((n + (length [] - 1)) % length []) \u22ef", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case cons.nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d : \u03b1\nn : \u2115\nx : \u03b1\nh : Nodup [x]\nhn : n < length [x]\n\u22a2 prev [x] (nthLe [x] n hn) \u22ef = nthLe [x] ((n + (length [x] - 1)) % length [x]) \u22ef", "state_after": "no goals"}, {"tactic": "rcases n with (_ | _ | n)", "annotated_tactic": ["rcases n with (_ | _ | n)", []], "state_before": "case cons.cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nn : \u2115\nx : \u03b1\nh : Nodup (x :: y :: l)\nhn : n < length (x :: y :: l)\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) n hn) \u22ef =\n    nthLe (x :: y :: l) ((n + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef", "state_after": "case cons.cons.zero\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nhn : Nat.zero < length (x :: y :: l)\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) Nat.zero hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.zero + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef\n\ncase cons.cons.succ.zero\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nhn : Nat.succ Nat.zero < length (x :: y :: l)\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) (Nat.succ Nat.zero) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ Nat.zero + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef\n\ncase cons.cons.succ.succ\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef"}, {"tactic": "simp [Nat.add_succ_sub_one, add_zero, List.prev_cons_cons_eq, Nat.zero_eq, List.length,\n  List.nthLe, Nat.succ_add_sub_one, zero_add, getLast_eq_get,\n  Nat.mod_eq_of_lt (Nat.succ_lt_succ l.length.lt_succ_self)]", "annotated_tactic": ["simp [<a>Nat.add_succ_sub_one</a>, <a>add_zero</a>, <a>List.prev_cons_cons_eq</a>, <a>Nat.zero_eq</a>, <a>List.length</a>,\n        <a>List.nthLe</a>, <a>Nat.succ_add_sub_one</a>, <a>zero_add</a>, <a>getLast_eq_get</a>,\n        <a>Nat.mod_eq_of_lt</a> (<a>Nat.succ_lt_succ</a> l.length.lt_succ_self)]", [{"full_name": "Nat.add_succ_sub_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [189, 15], "def_end_pos": [189, 31]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "List.prev_cons_cons_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [222, 9], "def_end_pos": [222, 26]}, {"full_name": "Nat.zero_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [83, 17], "def_end_pos": [83, 24]}, {"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}, {"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}, {"full_name": "Nat.succ_add_sub_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [193, 7], "def_end_pos": [193, 23]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}, {"full_name": "List.getLast_eq_get", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [223, 9], "def_end_pos": [223, 23]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}, {"full_name": "Nat.succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [216, 9], "def_end_pos": [216, 21]}]], "state_before": "case cons.cons.zero\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nhn : Nat.zero < length (x :: y :: l)\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) Nat.zero hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.zero + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef", "state_after": "no goals"}, {"tactic": "simp only [mem_cons, nodup_cons] at h", "annotated_tactic": ["simp only [<a>mem_cons</a>, <a>nodup_cons</a>] at h", [{"full_name": "List.mem_cons", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [63, 17], "def_end_pos": [63, 25]}, {"full_name": "List.nodup_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Nodup.lean", "def_pos": [39, 9], "def_end_pos": [39, 19]}]], "state_before": "case cons.cons.succ.zero\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nhn : Nat.succ Nat.zero < length (x :: y :: l)\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) (Nat.succ Nat.zero) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ Nat.zero + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef", "state_after": "case cons.cons.succ.zero\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nhn : Nat.succ Nat.zero < length (x :: y :: l)\nh : \u00ac(x = y \u2228 x \u2208 l) \u2227 y \u2209 l \u2227 Nodup l\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) (Nat.succ Nat.zero) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ Nat.zero + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef"}, {"tactic": "push_neg at h", "annotated_tactic": ["push_neg at h", []], "state_before": "case cons.cons.succ.zero\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nhn : Nat.succ Nat.zero < length (x :: y :: l)\nh : \u00ac(x = y \u2228 x \u2208 l) \u2227 y \u2209 l \u2227 Nodup l\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) (Nat.succ Nat.zero) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ Nat.zero + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef", "state_after": "case cons.cons.succ.zero\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nhn : Nat.succ Nat.zero < length (x :: y :: l)\nh : (x \u2260 y \u2227 x \u2209 l) \u2227 y \u2209 l \u2227 Nodup l\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) (Nat.succ Nat.zero) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ Nat.zero + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef"}, {"tactic": "simp only [List.prev_cons_cons_of_ne _ _ _ _ h.left.left.symm, Nat.zero_eq, List.length,\n  List.nthLe, add_comm, eq_self_iff_true, Nat.succ_add_sub_one, Nat.mod_self, zero_add,\n  List.get]", "annotated_tactic": ["simp only [<a>List.prev_cons_cons_of_ne</a> _ _ _ _ h.left.left.symm, <a>Nat.zero_eq</a>, <a>List.length</a>,\n        <a>List.nthLe</a>, <a>add_comm</a>, <a>eq_self_iff_true</a>, <a>Nat.succ_add_sub_one</a>, <a>Nat.mod_self</a>, <a>zero_add</a>,\n        <a>List.get</a>]", [{"full_name": "List.prev_cons_cons_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [234, 9], "def_end_pos": [234, 29]}, {"full_name": "Nat.zero_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [83, 17], "def_end_pos": [83, 24]}, {"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}, {"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "eq_self_iff_true", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1368, 9], "def_end_pos": [1368, 25]}, {"full_name": "Nat.succ_add_sub_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [193, 7], "def_end_pos": [193, 23]}, {"full_name": "Nat.mod_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [155, 17], "def_end_pos": [155, 25]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}, {"full_name": "List.get", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2345, 5], "def_end_pos": [2345, 13]}]], "state_before": "case cons.cons.succ.zero\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nhn : Nat.succ Nat.zero < length (x :: y :: l)\nh : (x \u2260 y \u2227 x \u2209 l) \u2227 y \u2209 l \u2227 Nodup l\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) (Nat.succ Nat.zero) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ Nat.zero + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef", "state_after": "no goals"}, {"tactic": "rw [prev_ne_cons_cons]", "annotated_tactic": ["rw [<a>prev_ne_cons_cons</a>]", [{"full_name": "List.prev_ne_cons_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [239, 9], "def_end_pos": [239, 26]}]], "state_before": "case cons.cons.succ.succ\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 prev (x :: y :: l) (nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef", "state_after": "case cons.cons.succ.succ\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 prev (y :: l) (nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef\n\ncase cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn \u2260 x\n\ncase cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn \u2260 y"}, {"tactic": "convert hl n.succ y h.of_cons (Nat.le_of_succ_le_succ hn) using 1", "annotated_tactic": ["convert hl n.succ y h.of_cons (<a>Nat.le_of_succ_le_succ</a> hn) using 1", [{"full_name": "Nat.le_of_succ_le_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1694, 9], "def_end_pos": [1694, 31]}]], "state_before": "case cons.cons.succ.succ\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 prev (y :: l) (nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef", "state_after": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef =\n    nthLe (y :: l) ((Nat.succ n + (length (y :: l) - 1)) % length (y :: l)) \u22ef"}, {"tactic": "have : \u2200 k hk, (y :: l).nthLe k hk = (x :: y :: l).nthLe (k + 1) (Nat.succ_lt_succ hk) := by\n  intros\n  simp [List.nthLe]", "annotated_tactic": ["have : \u2200 k hk, (y :: l).<a>nthLe</a> k hk = (x :: y :: l).<a>nthLe</a> (k + 1) (<a>Nat.succ_lt_succ</a> hk) := by\n          intros\n          simp [<a>List.nthLe</a>]", [{"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}, {"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}, {"full_name": "Nat.succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [216, 9], "def_end_pos": [216, 21]}, {"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}]], "state_before": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef =\n    nthLe (y :: l) ((Nat.succ n + (length (y :: l) - 1)) % length (y :: l)) \u22ef", "state_after": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\n\u22a2 nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef =\n    nthLe (y :: l) ((Nat.succ n + (length (y :: l) - 1)) % length (y :: l)) \u22ef"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\n\u22a2 nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef =\n    nthLe (y :: l) ((Nat.succ n + (length (y :: l) - 1)) % length (y :: l)) \u22ef", "state_after": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\n\u22a2 nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ n + (length (y :: l) - 1)) % length (y :: l) + 1) \u22ef"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case h.e'_3\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\n\u22a2 nthLe (x :: y :: l) ((Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l)) \u22ef =\n    nthLe (x :: y :: l) ((Nat.succ n + (length (y :: l) - 1)) % length (y :: l) + 1) \u22ef", "state_after": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\n\u22a2 (Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l) =\n    (Nat.succ n + (length (y :: l) - 1)) % length (y :: l) + 1"}, {"tactic": "simp only [Nat.add_succ_sub_one, add_zero, length]", "annotated_tactic": ["simp only [<a>Nat.add_succ_sub_one</a>, <a>add_zero</a>, <a>length</a>]", [{"full_name": "Nat.add_succ_sub_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [189, 15], "def_end_pos": [189, 31]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}]], "state_before": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\n\u22a2 (Nat.succ (Nat.succ n) + (length (x :: y :: l) - 1)) % length (x :: y :: l) =\n    (Nat.succ n + (length (y :: l) - 1)) % length (y :: l) + 1", "state_after": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\n\u22a2 (Nat.succ (Nat.succ n) + (length l + 1)) % (length l + 1 + 1) = (Nat.succ n + length l) % (length l + 1) + 1"}, {"tactic": "simp only [length, Nat.succ_lt_succ_iff] at hn", "annotated_tactic": ["simp only [<a>length</a>, <a>Nat.succ_lt_succ_iff</a>] at hn", [{"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}, {"full_name": "Nat.succ_lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [106, 9], "def_end_pos": [106, 25]}]], "state_before": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\n\u22a2 (Nat.succ (Nat.succ n) + (length l + 1)) % (length l + 1 + 1) = (Nat.succ n + length l) % (length l + 1) + 1", "state_after": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\nhn : n < length l\n\u22a2 (Nat.succ (Nat.succ n) + (length l + 1)) % (length l + 1 + 1) = (Nat.succ n + length l) % (length l + 1) + 1"}, {"tactic": "set k := l.length", "annotated_tactic": ["set k := l.length", []], "state_before": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\nhn : n < length l\n\u22a2 (Nat.succ (Nat.succ n) + (length l + 1)) % (length l + 1 + 1) = (Nat.succ n + length l) % (length l + 1) + 1", "state_after": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\nk : \u2115 := length l\nhn : n < k\n\u22a2 (Nat.succ (Nat.succ n) + (k + 1)) % (k + 1 + 1) = (Nat.succ n + k) % (k + 1) + 1"}, {"tactic": "rw [Nat.succ_add, \u2190 Nat.add_succ, Nat.add_mod_right, Nat.succ_add, \u2190 Nat.add_succ _ k,\n  Nat.add_mod_right, Nat.mod_eq_of_lt, Nat.mod_eq_of_lt]", "annotated_tactic": ["rw [<a>Nat.succ_add</a>, \u2190 <a>Nat.add_succ</a>, <a>Nat.add_mod_right</a>, <a>Nat.succ_add</a>, \u2190 <a>Nat.add_succ</a> _ k,\n          <a>Nat.add_mod_right</a>, <a>Nat.mod_eq_of_lt</a>, <a>Nat.mod_eq_of_lt</a>]", [{"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.add_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 17]}, {"full_name": "Nat.add_mod_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [229, 17], "def_end_pos": [229, 30]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.add_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 17]}, {"full_name": "Nat.add_mod_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [229, 17], "def_end_pos": [229, 30]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}]], "state_before": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\nk : \u2115 := length l\nhn : n < k\n\u22a2 (Nat.succ (Nat.succ n) + (k + 1)) % (k + 1 + 1) = (Nat.succ n + k) % (k + 1) + 1", "state_after": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\nk : \u2115 := length l\nhn : n < k\n\u22a2 n < Nat.succ k\n\ncase h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\nk : \u2115 := length l\nhn : n < k\n\u22a2 n + 1 < Nat.succ (k + 1)"}, {"tactic": "intros", "annotated_tactic": ["intros", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef", "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nk\u271d : \u2115\nhk\u271d : k\u271d < length (y :: l)\n\u22a2 nthLe (y :: l) k\u271d hk\u271d = nthLe (x :: y :: l) (k\u271d + 1) \u22ef"}, {"tactic": "simp [List.nthLe]", "annotated_tactic": ["simp [<a>List.nthLe</a>]", [{"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nk\u271d : \u2115\nhk\u271d : k\u271d < length (y :: l)\n\u22a2 nthLe (y :: l) k\u271d hk\u271d = nthLe (x :: y :: l) (k\u271d + 1) \u22ef", "state_after": "no goals"}, {"tactic": "exact Nat.lt_succ_of_lt hn", "annotated_tactic": ["exact <a>Nat.lt_succ_of_lt</a> hn", [{"full_name": "Nat.lt_succ_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [93, 9], "def_end_pos": [93, 22]}]], "state_before": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\nk : \u2115 := length l\nhn : n < k\n\u22a2 n < Nat.succ k", "state_after": "no goals"}, {"tactic": "exact Nat.succ_lt_succ (Nat.lt_succ_of_lt hn)", "annotated_tactic": ["exact <a>Nat.succ_lt_succ</a> (<a>Nat.lt_succ_of_lt</a> hn)", [{"full_name": "Nat.succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [216, 9], "def_end_pos": [216, 21]}, {"full_name": "Nat.lt_succ_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [93, 9], "def_end_pos": [93, 22]}]], "state_before": "case h.e'_3.e_n\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nthis : \u2200 (k : \u2115) (hk : k < length (y :: l)), nthLe (y :: l) k hk = nthLe (x :: y :: l) (k + 1) \u22ef\nk : \u2115 := length l\nhn : n < k\n\u22a2 n + 1 < Nat.succ (k + 1)", "state_after": "no goals"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "case cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn \u2260 x", "state_after": "case cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = x\n\u22a2 False"}, {"tactic": "suffices n.succ.succ = 0 by simpa", "annotated_tactic": ["suffices n.succ.succ = 0 by simpa", []], "state_before": "case cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = x\n\u22a2 False", "state_after": "case cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = x\n\u22a2 Nat.succ (Nat.succ n) = 0"}, {"tactic": "rw [nodup_iff_nthLe_inj] at h", "annotated_tactic": ["rw [<a>nodup_iff_nthLe_inj</a>] at h", [{"full_name": "List.nodup_iff_nthLe_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Nodup.lean", "def_pos": [105, 9], "def_end_pos": [105, 28]}]], "state_before": "case cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = x\n\u22a2 Nat.succ (Nat.succ n) = 0", "state_after": "case cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh :\n  \u2200 (i j : \u2115) (h\u2081 : i < length (x :: y :: l)) (h\u2082 : j < length (x :: y :: l)),\n    nthLe (x :: y :: l) i h\u2081 = nthLe (x :: y :: l) j h\u2082 \u2192 i = j\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = x\n\u22a2 Nat.succ (Nat.succ n) = 0"}, {"tactic": "refine' h _ _ hn Nat.succ_pos' _", "annotated_tactic": ["refine' h _ _ hn <a>Nat.succ_pos'</a> _", [{"full_name": "Nat.succ_pos'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [48, 7], "def_end_pos": [48, 16]}]], "state_before": "case cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh :\n  \u2200 (i j : \u2115) (h\u2081 : i < length (x :: y :: l)) (h\u2082 : j < length (x :: y :: l)),\n    nthLe (x :: y :: l) i h\u2081 = nthLe (x :: y :: l) j h\u2082 \u2192 i = j\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = x\n\u22a2 Nat.succ (Nat.succ n) = 0", "state_after": "case cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh :\n  \u2200 (i j : \u2115) (h\u2081 : i < length (x :: y :: l)) (h\u2082 : j < length (x :: y :: l)),\n    nthLe (x :: y :: l) i h\u2081 = nthLe (x :: y :: l) j h\u2082 \u2192 i = j\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = x\n\u22a2 nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = nthLe (x :: y :: l) 0 \u22ef"}, {"tactic": "simpa using H", "annotated_tactic": ["simpa using H", []], "state_before": "case cons.cons.succ.succ.hy\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh :\n  \u2200 (i j : \u2115) (h\u2081 : i < length (x :: y :: l)) (h\u2082 : j < length (x :: y :: l)),\n    nthLe (x :: y :: l) i h\u2081 = nthLe (x :: y :: l) j h\u2082 \u2192 i = j\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = x\n\u22a2 nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = nthLe (x :: y :: l) 0 \u22ef", "state_after": "no goals"}, {"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = x\nthis : Nat.succ (Nat.succ n) = 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "case cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\n\u22a2 nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn \u2260 y", "state_after": "case cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = y\n\u22a2 False"}, {"tactic": "suffices n.succ.succ = 1 by simpa", "annotated_tactic": ["suffices n.succ.succ = 1 by simpa", []], "state_before": "case cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = y\n\u22a2 False", "state_after": "case cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = y\n\u22a2 Nat.succ (Nat.succ n) = 1"}, {"tactic": "rw [nodup_iff_nthLe_inj] at h", "annotated_tactic": ["rw [<a>nodup_iff_nthLe_inj</a>] at h", [{"full_name": "List.nodup_iff_nthLe_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Nodup.lean", "def_pos": [105, 9], "def_end_pos": [105, 28]}]], "state_before": "case cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = y\n\u22a2 Nat.succ (Nat.succ n) = 1", "state_after": "case cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh :\n  \u2200 (i j : \u2115) (h\u2081 : i < length (x :: y :: l)) (h\u2082 : j < length (x :: y :: l)),\n    nthLe (x :: y :: l) i h\u2081 = nthLe (x :: y :: l) j h\u2082 \u2192 i = j\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = y\n\u22a2 Nat.succ (Nat.succ n) = 1"}, {"tactic": "refine' h _ _ hn (Nat.succ_lt_succ Nat.succ_pos') _", "annotated_tactic": ["refine' h _ _ hn (<a>Nat.succ_lt_succ</a> <a>Nat.succ_pos'</a>) _", [{"full_name": "Nat.succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [216, 9], "def_end_pos": [216, 21]}, {"full_name": "Nat.succ_pos'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [48, 7], "def_end_pos": [48, 16]}]], "state_before": "case cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh :\n  \u2200 (i j : \u2115) (h\u2081 : i < length (x :: y :: l)) (h\u2082 : j < length (x :: y :: l)),\n    nthLe (x :: y :: l) i h\u2081 = nthLe (x :: y :: l) j h\u2082 \u2192 i = j\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = y\n\u22a2 Nat.succ (Nat.succ n) = 1", "state_after": "case cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh :\n  \u2200 (i j : \u2115) (h\u2081 : i < length (x :: y :: l)) (h\u2082 : j < length (x :: y :: l)),\n    nthLe (x :: y :: l) i h\u2081 = nthLe (x :: y :: l) j h\u2082 \u2192 i = j\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = y\n\u22a2 nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = nthLe (x :: y :: l) 1 \u22ef"}, {"tactic": "simpa using H", "annotated_tactic": ["simpa using H", []], "state_before": "case cons.cons.succ.succ.hz\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh :\n  \u2200 (i j : \u2115) (h\u2081 : i < length (x :: y :: l)) (h\u2082 : j < length (x :: y :: l)),\n    nthLe (x :: y :: l) i h\u2081 = nthLe (x :: y :: l) j h\u2082 \u2192 i = j\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = y\n\u22a2 nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = nthLe (x :: y :: l) 1 \u22ef", "state_after": "no goals"}, {"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d y : \u03b1\nl : List \u03b1\nhl :\n  \u2200 (n : \u2115) (x : \u03b1),\n    Nodup (x :: l) \u2192\n      \u2200 (hn : n < length (x :: l)),\n        prev (x :: l) (nthLe (x :: l) n hn) \u22ef = nthLe (x :: l) ((n + (length (x :: l) - 1)) % length (x :: l)) \u22ef\nx : \u03b1\nh : Nodup (x :: y :: l)\nn : \u2115\nhn : Nat.succ (Nat.succ n) < length (x :: y :: l)\nH : nthLe (x :: y :: l) (Nat.succ (Nat.succ n)) hn = y\nthis : Nat.succ (Nat.succ n) = 1\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "continuousAt_zpow", "start": [522, 1], "end": [523, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupClosed.lean", "full_name": "supClosed_iInter", "start": [54, 1], "end": [55, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Conj.lean", "full_name": "mem_conjugatesOf_self", "start": [284, 1], "end": [285, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Equiv.lean", "full_name": "RingEquiv.toOpposite_apply", "start": [426, 1], "end": [427, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/Constructions.lean", "full_name": "rank_fun", "start": [291, 1], "end": [293, 57], "traced_tactics": [{"tactic": "rw [rank_pi, Cardinal.sum_const', Cardinal.mk_fintype]", "annotated_tactic": ["rw [<a>rank_pi</a>, <a>Cardinal.sum_const'</a>, <a>Cardinal.mk_fintype</a>]", [{"full_name": "rank_pi", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "def_pos": [261, 9], "def_end_pos": [261, 16]}, {"full_name": "Cardinal.sum_const'", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [898, 9], "def_end_pos": [898, 19]}, {"full_name": "Cardinal.mk_fintype", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [461, 9], "def_end_pos": [461, 19]}]], "state_before": "R S : Type u\nM\u271d : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7\u271d : Type u\u2081'\n\u03c6 : \u03b7\u271d \u2192 Type u_1\ninst\u271d\u00b9\u2077 : Ring R\ninst\u271d\u00b9\u2076 : CommRing S\ninst\u271d\u00b9\u2075 : AddCommGroup M\u271d\ninst\u271d\u00b9\u2074 : AddCommGroup M'\ninst\u271d\u00b9\u00b3 : AddCommGroup M\u2081\ninst\u271d\u00b9\u00b2 : Module R M\u271d\ninst\u271d\u00b9\u00b9 : Module R M'\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Free R M\u271d\ninst\u271d\u2077 : (i : \u03b7\u271d) \u2192 AddCommGroup (\u03c6 i)\ninst\u271d\u2076 : (i : \u03b7\u271d) \u2192 Module R (\u03c6 i)\ninst\u271d\u2075 : \u2200 (i : \u03b7\u271d), Module.Free R (\u03c6 i)\ninst\u271d\u2074 : Fintype \u03b7\u271d\nM \u03b7 : Type u\ninst\u271d\u00b3 : Fintype \u03b7\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module.Free R M\n\u22a2 Module.rank R (\u03b7 \u2192 M) = \u2191(Fintype.card \u03b7) * Module.rank R M", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/PiSystem.lean", "full_name": "MeasurableSpace.DynkinSystem.has_univ", "start": [572, 1], "end": [572, 72], "traced_tactics": [{"tactic": "simpa using d.has_compl d.has_empty", "annotated_tactic": ["simpa using d.has_compl d.has_empty", []], "state_before": "\u03b1 : Type u_1\nd : DynkinSystem \u03b1\n\u22a2 d.Has univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/AlgebraTower.lean", "full_name": "Basis.isScalarTower_of_nonempty", "start": [128, 1], "end": [130, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.self_trans_symm", "start": [483, 1], "end": [484, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Operations.lean", "full_name": "Submonoid.mrange_inl", "start": [1217, 1], "end": [1217, 98], "traced_tactics": [{"tactic": "simpa only [mrange_eq_map] using map_inl \u22a4", "annotated_tactic": ["simpa only [<a>mrange_eq_map</a>] using <a>map_inl</a> \u22a4", [{"full_name": "MonoidHom.mrange_eq_map", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [979, 9], "def_end_pos": [979, 22]}, {"full_name": "Submonoid.map_inl", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [830, 9], "def_end_pos": [830, 16]}]], "state_before": "M : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : MulOneClass M\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : MulOneClass P\nS : Submonoid M\nA : Type u_4\ninst\u271d : SetLike A M\nhA : SubmonoidClass A M\nS' : A\n\u22a2 mrange (inl M N) = prod \u22a4 \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "full_name": "CategoryTheory.Limits.WalkingPair.equivBool_apply_left", "start": [93, 1], "end": [94, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.Subsingleton.eq_empty_or_singleton", "start": [2370, 1], "end": [2371, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.symm_injective", "start": [891, 1], "end": [892, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.inductionOn\u2082", "start": [132, 1], "end": [134, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/InitialSeg.lean", "full_name": "PrincipalSeg.trans_apply", "start": [323, 1], "end": [324, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.equivProdDFinsupp_smul", "start": [1706, 1], "end": [1708, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.meas_ge_le_lintegral_div", "start": [899, 1], "end": [903, 41], "traced_tactics": [{"tactic": "rw [mul_comm]", "annotated_tactic": ["rw [<a>mul_comm</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : AEMeasurable f \u03bc\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh\u03b5' : \u03b5 \u2260 \u22a4\n\u22a2 \u2191\u2191\u03bc {x | \u03b5 \u2264 f x} * \u03b5 \u2264 \u222b\u207b (a : \u03b1), f a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : AEMeasurable f \u03bc\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh\u03b5' : \u03b5 \u2260 \u22a4\n\u22a2 \u03b5 * \u2191\u2191\u03bc {x | \u03b5 \u2264 f x} \u2264 \u222b\u207b (a : \u03b1), f a \u2202\u03bc"}, {"tactic": "exact mul_meas_ge_le_lintegral\u2080 hf \u03b5", "annotated_tactic": ["exact <a>mul_meas_ge_le_lintegral\u2080</a> hf \u03b5", [{"full_name": "MeasureTheory.mul_meas_ge_le_lintegral\u2080", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [848, 9], "def_end_pos": [848, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : AEMeasurable f \u03bc\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh\u03b5' : \u03b5 \u2260 \u22a4\n\u22a2 \u03b5 * \u2191\u2191\u03bc {x | \u03b5 \u2264 f x} \u2264 \u222b\u207b (a : \u03b1), f a \u2202\u03bc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "one_div_pow_anti", "start": [655, 1], "end": [656, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Ideal.lean", "full_name": "IsLocalization.mem_map_algebraMap_iff", "start": [53, 1], "end": [64, 46], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\n\u22a2 z \u2208 Ideal.map (algebraMap R S) I \u2194 \u2203 x, z * (algebraMap R S) \u2191x.2 = (algebraMap R S) \u2191x.1", "state_after": "case mp\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\n\u22a2 z \u2208 Ideal.map (algebraMap R S) I \u2192 \u2203 x, z * (algebraMap R S) \u2191x.2 = (algebraMap R S) \u2191x.1\n\ncase mpr\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\n\u22a2 (\u2203 x, z * (algebraMap R S) \u2191x.2 = (algebraMap R S) \u2191x.1) \u2192 z \u2208 Ideal.map (algebraMap R S) I"}, {"tactic": "change _ \u2192 z \u2208 map_ideal M S I", "annotated_tactic": ["change _ \u2192 z \u2208 <a>map_ideal</a> M S I", [{"full_name": "_private.\u00ab.lake\u00bb.packages.mathlib.Mathlib.RingTheory.Localization.Ideal.0.IsLocalization.map_ideal", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Ideal.lean", "def_pos": [32, 13], "def_end_pos": [32, 22]}]], "state_before": "case mp\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\n\u22a2 z \u2208 Ideal.map (algebraMap R S) I \u2192 \u2203 x, z * (algebraMap R S) \u2191x.2 = (algebraMap R S) \u2191x.1", "state_after": "case mp\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\n\u22a2 z \u2208 Ideal.map (algebraMap R S) I \u2192 z \u2208 IsLocalization.map_ideal M S I"}, {"tactic": "refine' fun h => Ideal.mem_sInf.1 h fun z hz => _", "annotated_tactic": ["refine' fun h => <a>Ideal.mem_sInf</a>.1 h fun z hz => _", [{"full_name": "Ideal.mem_sInf", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [428, 9], "def_end_pos": [428, 17]}]], "state_before": "case mp\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\n\u22a2 z \u2208 Ideal.map (algebraMap R S) I \u2192 z \u2208 IsLocalization.map_ideal M S I", "state_after": "case mp\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz\u271d : S\nh : z\u271d \u2208 Ideal.map (algebraMap R S) I\nz : S\nhz : z \u2208 \u21d1(algebraMap R S) '' \u2191I\n\u22a2 z \u2208 \u2191(IsLocalization.map_ideal M S I)"}, {"tactic": "obtain \u27e8y, hy\u27e9 := hz", "annotated_tactic": ["obtain \u27e8y, hy\u27e9 := hz", []], "state_before": "case mp\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz\u271d : S\nh : z\u271d \u2208 Ideal.map (algebraMap R S) I\nz : S\nhz : z \u2208 \u21d1(algebraMap R S) '' \u2191I\n\u22a2 z \u2208 \u2191(IsLocalization.map_ideal M S I)", "state_after": "case mp.intro\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz\u271d : S\nh : z\u271d \u2208 Ideal.map (algebraMap R S) I\nz : S\ny : R\nhy : y \u2208 \u2191I \u2227 (algebraMap R S) y = z\n\u22a2 z \u2208 \u2191(IsLocalization.map_ideal M S I)"}, {"tactic": "let Z : { x // x \u2208 I } := \u27e8y, hy.left\u27e9", "annotated_tactic": ["let Z : { x // x \u2208 I } := \u27e8y, hy.left\u27e9", []], "state_before": "case mp.intro\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz\u271d : S\nh : z\u271d \u2208 Ideal.map (algebraMap R S) I\nz : S\ny : R\nhy : y \u2208 \u2191I \u2227 (algebraMap R S) y = z\n\u22a2 z \u2208 \u2191(IsLocalization.map_ideal M S I)", "state_after": "case mp.intro\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz\u271d : S\nh : z\u271d \u2208 Ideal.map (algebraMap R S) I\nz : S\ny : R\nhy : y \u2208 \u2191I \u2227 (algebraMap R S) y = z\nZ : \u21a5I := { val := y, property := \u22ef }\n\u22a2 z \u2208 \u2191(IsLocalization.map_ideal M S I)"}, {"tactic": "use \u27e8Z, 1\u27e9", "annotated_tactic": ["use \u27e8Z, 1\u27e9", []], "state_before": "case mp.intro\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz\u271d : S\nh : z\u271d \u2208 Ideal.map (algebraMap R S) I\nz : S\ny : R\nhy : y \u2208 \u2191I \u2227 (algebraMap R S) y = z\nZ : \u21a5I := { val := y, property := \u22ef }\n\u22a2 z \u2208 \u2191(IsLocalization.map_ideal M S I)", "state_after": "case h\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz\u271d : S\nh : z\u271d \u2208 Ideal.map (algebraMap R S) I\nz : S\ny : R\nhy : y \u2208 \u2191I \u2227 (algebraMap R S) y = z\nZ : \u21a5I := { val := y, property := \u22ef }\n\u22a2 z * (algebraMap R S) \u2191(Z, 1).2 = (algebraMap R S) \u2191(Z, 1).1"}, {"tactic": "simp [hy.right]", "annotated_tactic": ["simp [hy.right]", []], "state_before": "case h\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz\u271d : S\nh : z\u271d \u2208 Ideal.map (algebraMap R S) I\nz : S\ny : R\nhy : y \u2208 \u2191I \u2227 (algebraMap R S) y = z\nZ : \u21a5I := { val := y, property := \u22ef }\n\u22a2 z * (algebraMap R S) \u2191(Z, 1).2 = (algebraMap R S) \u2191(Z, 1).1", "state_after": "no goals"}, {"tactic": "rintro \u27e8\u27e8a, s\u27e9, h\u27e9", "annotated_tactic": ["rintro \u27e8\u27e8a, s\u27e9, h\u27e9", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\n\u22a2 (\u2203 x, z * (algebraMap R S) \u2191x.2 = (algebraMap R S) \u2191x.1) \u2192 z \u2208 Ideal.map (algebraMap R S) I", "state_after": "case mpr.intro.mk\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\na : \u21a5I\ns : \u21a5M\nh : z * (algebraMap R S) \u2191(a, s).2 = (algebraMap R S) \u2191(a, s).1\n\u22a2 z \u2208 Ideal.map (algebraMap R S) I"}, {"tactic": "rw [\u2190 Ideal.unit_mul_mem_iff_mem _ (map_units S s), mul_comm]", "annotated_tactic": ["rw [\u2190 <a>Ideal.unit_mul_mem_iff_mem</a> _ (<a>map_units</a> S s), <a>mul_comm</a>]", [{"full_name": "Ideal.unit_mul_mem_iff_mem", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [106, 9], "def_end_pos": [106, 29]}, {"full_name": "IsLocalization.map_units", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "case mpr.intro.mk\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\na : \u21a5I\ns : \u21a5M\nh : z * (algebraMap R S) \u2191(a, s).2 = (algebraMap R S) \u2191(a, s).1\n\u22a2 z \u2208 Ideal.map (algebraMap R S) I", "state_after": "case mpr.intro.mk\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\na : \u21a5I\ns : \u21a5M\nh : z * (algebraMap R S) \u2191(a, s).2 = (algebraMap R S) \u2191(a, s).1\n\u22a2 z * (algebraMap R S) \u2191s \u2208 Ideal.map (algebraMap R S) I"}, {"tactic": "exact h.symm \u25b8 Ideal.mem_map_of_mem _ a.2", "annotated_tactic": ["exact h.symm \u25b8 <a>Ideal.mem_map_of_mem</a> _ a.2", [{"full_name": "Ideal.mem_map_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [1426, 9], "def_end_pos": [1426, 23]}]], "state_before": "case mpr.intro.mk\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nI : Ideal R\nz : S\na : \u21a5I\ns : \u21a5M\nh : z * (algebraMap R S) \u2191(a, s).2 = (algebraMap R S) \u2191(a, s).1\n\u22a2 z * (algebraMap R S) \u2191s \u2208 Ideal.map (algebraMap R S) I", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/UniformGroup.lean", "full_name": "uniformGroup_sInf", "start": [212, 1], "end": [217, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.coe_unitOfCoprime", "start": [773, 1], "end": [775, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.coe_nonempty", "start": [471, 1], "end": [472, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.EventuallyEq.comp_tendsto", "start": [3290, 1], "end": [3292, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/ModEq.lean", "full_name": "AddCommGroup.modEq_sub_iff_add_modEq'", "start": [262, 1], "end": [263, 24], "traced_tactics": [{"tactic": "simp [ModEq, sub_sub]", "annotated_tactic": ["simp [<a>ModEq</a>, <a>sub_sub</a>]", [{"full_name": "AddCommGroup.ModEq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/ModEq.lean", "def_pos": [46, 5], "def_end_pos": [46, 10]}, {"full_name": "sub_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [601, 3], "def_end_pos": [601, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\np a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1\nn : \u2115\nz : \u2124\n\u22a2 a \u2261 b - c [PMOD p] \u2194 c + a \u2261 b [PMOD p]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Logic.lean", "full_name": "iff_self_iff", "start": [198, 1], "end": [198, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/IntermediateField.lean", "full_name": "IntermediateField.coe_mul", "start": [249, 11], "end": [250, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "full_name": "hasSum_ite_eq", "start": [128, 1], "end": [131, 26], "traced_tactics": [{"tactic": "convert @hasSum_single _ _ _ _ (fun b' \u21a6 if b' = b then a else 0) b (fun b' hb' \u21a6 if_neg hb')", "annotated_tactic": ["convert @<a>hasSum_single</a> _ _ _ _ (fun b' \u21a6 if b' = b then a else 0) b (fun b' hb' \u21a6 <a>if_neg</a> hb')", [{"full_name": "hasSum_single", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "def_pos": [117, 9], "def_end_pos": [117, 22]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na\u271d b\u271d : \u03b1\ns : Finset \u03b2\nb : \u03b2\ninst\u271d : DecidablePred fun x => x = b\na : \u03b1\n\u22a2 HasSum (fun b' => if b' = b then a else 0) a", "state_after": "case h.e'_6\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na\u271d b\u271d : \u03b1\ns : Finset \u03b2\nb : \u03b2\ninst\u271d : DecidablePred fun x => x = b\na : \u03b1\n\u22a2 a = if b = b then a else 0"}, {"tactic": "exact (if_pos rfl).symm", "annotated_tactic": ["exact (<a>if_pos</a> <a>rfl</a>).<a>symm</a>", [{"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case h.e'_6\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na\u271d b\u271d : \u03b1\ns : Finset \u03b2\nb : \u03b2\ninst\u271d : DecidablePred fun x => x = b\na : \u03b1\n\u22a2 a = if b = b then a else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.inf_comap_le_comap_add", "start": [584, 1], "end": [590, 26], "traced_tactics": [{"tactic": "rw [SetLike.le_def]", "annotated_tactic": ["rw [<a>SetLike.le_def</a>]", [{"full_name": "SetLike.le_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 15]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\nq : Submodule R\u2082 M\u2082\nf\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\n\u22a2 comap f\u2081 q \u2293 comap f\u2082 q \u2264 comap (f\u2081 + f\u2082) q", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\nq : Submodule R\u2082 M\u2082\nf\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\n\u22a2 \u2200 \u2983x : M\u2984, x \u2208 comap f\u2081 q \u2293 comap f\u2082 q \u2192 x \u2208 comap (f\u2081 + f\u2082) q"}, {"tactic": "intro m h", "annotated_tactic": ["intro m h", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\nq : Submodule R\u2082 M\u2082\nf\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\n\u22a2 \u2200 \u2983x : M\u2984, x \u2208 comap f\u2081 q \u2293 comap f\u2082 q \u2192 x \u2208 comap (f\u2081 + f\u2082) q", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\nq : Submodule R\u2082 M\u2082\nf\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nm : M\nh : m \u2208 comap f\u2081 q \u2293 comap f\u2082 q\n\u22a2 m \u2208 comap (f\u2081 + f\u2082) q"}, {"tactic": "change f\u2081 m + f\u2082 m \u2208 q", "annotated_tactic": ["change f\u2081 m + f\u2082 m \u2208 q", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\nq : Submodule R\u2082 M\u2082\nf\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nm : M\nh : m \u2208 comap f\u2081 q \u2293 comap f\u2082 q\n\u22a2 m \u2208 comap (f\u2081 + f\u2082) q", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\nq : Submodule R\u2082 M\u2082\nf\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nm : M\nh : m \u2208 comap f\u2081 q \u2293 comap f\u2082 q\n\u22a2 f\u2081 m + f\u2082 m \u2208 q"}, {"tactic": "change f\u2081 m \u2208 q \u2227 f\u2082 m \u2208 q at h", "annotated_tactic": ["change f\u2081 m \u2208 q \u2227 f\u2082 m \u2208 q at h", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\nq : Submodule R\u2082 M\u2082\nf\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nm : M\nh : m \u2208 comap f\u2081 q \u2293 comap f\u2082 q\n\u22a2 f\u2081 m + f\u2082 m \u2208 q", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\nq : Submodule R\u2082 M\u2082\nf\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nm : M\nh : f\u2081 m \u2208 q \u2227 f\u2082 m \u2208 q\n\u22a2 f\u2081 m + f\u2082 m \u2208 q"}, {"tactic": "apply q.add_mem h.1 h.2", "annotated_tactic": ["apply q.add_mem h.1 h.2", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\nq : Submodule R\u2082 M\u2082\nf\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nm : M\nh : f\u2081 m \u2208 q \u2227 f\u2082 m \u2208 q\n\u22a2 f\u2081 m + f\u2082 m \u2208 q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "antitone_nat_of_succ_le", "start": [1029, 1], "end": [1030, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Pointwise.lean", "full_name": "smul_closedBall'", "start": [104, 1], "end": [106, 92], "traced_tactics": [{"tactic": "simp only [\u2190 ball_union_sphere, Set.smul_set_union, _root_.smul_ball hc, smul_sphere' hc]", "annotated_tactic": ["simp only [\u2190 <a>ball_union_sphere</a>, <a>Set.smul_set_union</a>, <a>_root_.smul_ball</a> hc, <a>smul_sphere'</a> hc]", [{"full_name": "Metric.ball_union_sphere", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [560, 9], "def_end_pos": [560, 26]}, {"full_name": "Set.smul_set_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [363, 9], "def_end_pos": [363, 23]}, {"full_name": "smul_ball", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Pointwise.lean", "def_pos": [84, 9], "def_end_pos": [84, 18]}, {"full_name": "smul_sphere'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Pointwise.lean", "def_pos": [95, 9], "def_end_pos": [95, 21]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nc : \ud835\udd5c\nhc : c \u2260 0\nx : E\nr : \u211d\n\u22a2 c \u2022 closedBall x r = closedBall (c \u2022 x) (\u2016c\u2016 * r)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.mem_sep_iff", "start": [1403, 1], "end": [1404, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "nhds_mul", "start": [1900, 1], "end": [1907, 24], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nx y : G\n\u22a2 \ud835\udcdd (x * y) = map (fun x_1 => x * x_1) (map (fun x => x * y) (\ud835\udcdd 1 * \ud835\udcdd 1))", "state_after": "no goals"}, {"tactic": "rw [\u2190 map\u2082_mul, map_map\u2082, map_map\u2082]", "annotated_tactic": ["rw [\u2190 <a>map\u2082_mul</a>, <a>map_map\u2082</a>, <a>map_map\u2082</a>]", [{"full_name": "Filter.map\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Pointwise.lean", "def_pos": [303, 9], "def_end_pos": [303, 17]}, {"full_name": "Filter.map_map\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/NAry.lean", "def_pos": [167, 9], "def_end_pos": [167, 17]}, {"full_name": "Filter.map_map\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/NAry.lean", "def_pos": [167, 9], "def_end_pos": [167, 17]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nx y : G\n\u22a2 map (fun x_1 => x * x_1) (map (fun x => x * y) (\ud835\udcdd 1 * \ud835\udcdd 1)) = map\u2082 (fun a b => x * (a * b * y)) (\ud835\udcdd 1) (\ud835\udcdd 1)", "state_after": "no goals"}, {"tactic": "simp only [mul_assoc]", "annotated_tactic": ["simp only [<a>mul_assoc</a>]", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nx y : G\n\u22a2 map\u2082 (fun a b => x * (a * b * y)) (\ud835\udcdd 1) (\ud835\udcdd 1) = map\u2082 (fun a b => x * a * (b * y)) (\ud835\udcdd 1) (\ud835\udcdd 1)", "state_after": "no goals"}, {"tactic": "rw [\u2190 map_mul_left_nhds_one x, \u2190 map_mul_right_nhds_one y, \u2190 map\u2082_mul, map\u2082_map_left,\n  map\u2082_map_right]", "annotated_tactic": ["rw [\u2190 <a>map_mul_left_nhds_one</a> x, \u2190 <a>map_mul_right_nhds_one</a> y, \u2190 <a>map\u2082_mul</a>, <a>map\u2082_map_left</a>,\n        <a>map\u2082_map_right</a>]", [{"full_name": "map_mul_left_nhds_one", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [833, 9], "def_end_pos": [833, 30]}, {"full_name": "map_mul_right_nhds_one", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [844, 9], "def_end_pos": [844, 31]}, {"full_name": "Filter.map\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Pointwise.lean", "def_pos": [303, 9], "def_end_pos": [303, 17]}, {"full_name": "Filter.map\u2082_map_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/NAry.lean", "def_pos": [172, 9], "def_end_pos": [172, 22]}, {"full_name": "Filter.map\u2082_map_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/NAry.lean", "def_pos": [177, 9], "def_end_pos": [177, 23]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nx y : G\n\u22a2 map\u2082 (fun a b => x * a * (b * y)) (\ud835\udcdd 1) (\ud835\udcdd 1) = \ud835\udcdd x * \ud835\udcdd y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousOn.lean", "full_name": "ContinuousWithinAt.congr_of_eventuallyEq", "start": [1039, 1], "end": [1042, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "full_name": "fderivWithin_id", "start": [1133, 1], "end": [1135, 18], "traced_tactics": [{"tactic": "rw [DifferentiableAt.fderivWithin differentiableAt_id hxs]", "annotated_tactic": ["rw [<a>DifferentiableAt.fderivWithin</a> <a>differentiableAt_id</a> hxs]", [{"full_name": "DifferentiableAt.fderivWithin", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [655, 19], "def_end_pos": [655, 48]}, {"full_name": "differentiableAt_id", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [1096, 9], "def_end_pos": [1096, 28]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf f\u2080 f\u2081 g : E \u2192 F\nf' f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\n\u22a2 fderivWithin \ud835\udd5c _root_.id s x = ContinuousLinearMap.id \ud835\udd5c E", "state_after": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf f\u2080 f\u2081 g : E \u2192 F\nf' f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\n\u22a2 fderiv \ud835\udd5c _root_.id x = ContinuousLinearMap.id \ud835\udd5c E"}, {"tactic": "exact fderiv_id", "annotated_tactic": ["exact <a>fderiv_id</a>", [{"full_name": "fderiv_id", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [1124, 9], "def_end_pos": [1124, 18]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf f\u2080 f\u2081 g : E \u2192 F\nf' f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\n\u22a2 fderiv \ud835\udd5c _root_.id x = ContinuousLinearMap.id \ud835\udd5c E", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "full_name": "tsum_apply", "start": [200, 1], "end": [202, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Ico_diff_Ioo_self", "start": [607, 1], "end": [607, 90], "traced_tactics": [{"tactic": "simp [\u2190 coe_inj, h]", "annotated_tactic": ["simp [\u2190 <a>coe_inj</a>, h]", [{"full_name": "Finset.coe_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [249, 9], "def_end_pos": [249, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\na b c : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a < b\n\u22a2 Ico a b \\ Ioo a b = {a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeAbelianGroup.lean", "full_name": "FreeAbelianGroup.liftMonoid_coe_addMonoidHom", "start": [532, 1], "end": [533, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeGroup/Basic.lean", "full_name": "FreeGroup.one_bind", "start": [1062, 1], "end": [1063, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/ModEq.lean", "full_name": "AddCommGroup.ModEq.sub_right", "start": [240, 11], "end": [241, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.nthLe_zero", "start": [1282, 1], "end": [1285, 15], "traced_tactics": [{"tactic": "cases L", "annotated_tactic": ["cases L", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : Inhabited \u03b1\nL : List \u03b1\nh : 0 < length L\n\u22a2 nthLe L 0 h = head! L", "state_after": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : Inhabited \u03b1\nh : 0 < length []\n\u22a2 nthLe [] 0 h = head! []\n\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : Inhabited \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : 0 < length (head\u271d :: tail\u271d)\n\u22a2 nthLe (head\u271d :: tail\u271d) 0 h = head! (head\u271d :: tail\u271d)"}, {"tactic": "cases h", "annotated_tactic": ["cases h", []], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : Inhabited \u03b1\nh : 0 < length []\n\u22a2 nthLe [] 0 h = head! []\n\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : Inhabited \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : 0 < length (head\u271d :: tail\u271d)\n\u22a2 nthLe (head\u271d :: tail\u271d) 0 h = head! (head\u271d :: tail\u271d)", "state_after": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : Inhabited \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : 0 < length (head\u271d :: tail\u271d)\n\u22a2 nthLe (head\u271d :: tail\u271d) 0 h = head! (head\u271d :: tail\u271d)"}, {"tactic": "simp [nthLe]", "annotated_tactic": ["simp [<a>nthLe</a>]", [{"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : Inhabited \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : 0 < length (head\u271d :: tail\u271d)\n\u22a2 nthLe (head\u271d :: tail\u271d) 0 h = head! (head\u271d :: tail\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/EssentialImage.lean", "full_name": "CategoryTheory.Functor.essImage.ofIso", "start": [56, 1], "end": [57, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean", "full_name": "SimpleGraph.commonNeighbors_subset_neighborSet_left", "start": [847, 1], "end": [849, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Jensen.lean", "full_name": "StrictConcaveOn.lt_map_sum", "start": [146, 1], "end": [154, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "full_name": "Matrix.inv_eq_right_inv", "start": [516, 1], "end": [517, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Set.Finite.eventuallyEq_iInter", "start": [1818, 1], "end": [1821, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Torsion.lean", "full_name": "AddMonoid.IsTorsion.module_of_finite", "start": [171, 1], "end": [172, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Basic.lean", "full_name": "smul_algebraMap", "start": [403, 1], "end": [405, 63], "traced_tactics": [{"tactic": "rw [algebraMap_eq_smul_one, smul_comm a r (1 : A), smul_one]", "annotated_tactic": ["rw [<a>algebraMap_eq_smul_one</a>, <a>smul_comm</a> a r (1 : A), <a>smul_one</a>]", [{"full_name": "Algebra.algebraMap_eq_smul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [344, 9], "def_end_pos": [344, 31]}, {"full_name": "SMulCommClass.smul_comm", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [187, 3], "def_end_pos": [187, 12]}, {"full_name": "MulDistribMulAction.smul_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [1038, 3], "def_end_pos": [1038, 11]}]], "state_before": "R : Type u\nS : Type v\nA : Type w\nB : Type u_1\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : Algebra R A\ninst\u271d\u2074 : Semiring B\ninst\u271d\u00b3 : Algebra R B\n\u03b1 : Type u_2\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : MulDistribMulAction \u03b1 A\ninst\u271d : SMulCommClass \u03b1 R A\na : \u03b1\nr : R\n\u22a2 a \u2022 (algebraMap R A) r = (algebraMap R A) r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "continuousWithinAt_inv", "start": [206, 1], "end": [207, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Circle.lean", "full_name": "mem_circle_iff_abs", "start": [49, 1], "end": [50, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "full_name": "Polynomial.scaleRoots_eval\u2082_eq_zero", "start": [157, 1], "end": [158, 89], "traced_tactics": [{"tactic": "rw [scaleRoots_eval\u2082_mul, hr, mul_zero]", "annotated_tactic": ["rw [<a>scaleRoots_eval\u2082_mul</a>, hr, <a>mul_zero</a>]", [{"full_name": "Polynomial.scaleRoots_eval\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "def_pos": [152, 9], "def_end_pos": [152, 29]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}]], "state_before": "R : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Field K\np : S[X]\nf : S \u2192+* R\nr : R\ns : S\nhr : eval\u2082 f r p = 0\n\u22a2 eval\u2082 f (f s * r) (scaleRoots p s) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Multiplicity.lean", "full_name": "multiplicity.unique", "start": [130, 1], "end": [135, 40], "traced_tactics": [{"tactic": "have : Finite a b := \u27e8k, hsucc\u27e9", "annotated_tactic": ["have : <a>Finite</a> a b := \u27e8k, hsucc\u27e9", [{"full_name": "multiplicity.Finite", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [50, 5], "def_end_pos": [50, 11]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\nhk : a ^ k \u2223 b\nhsucc : \u00aca ^ (k + 1) \u2223 b\n\u22a2 multiplicity a b \u2264 \u2191k", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\nhk : a ^ k \u2223 b\nhsucc : \u00aca ^ (k + 1) \u2223 b\nthis : Finite a b\n\u22a2 multiplicity a b \u2264 \u2191k"}, {"tactic": "rw [PartENat.le_coe_iff]", "annotated_tactic": ["rw [<a>PartENat.le_coe_iff</a>]", [{"full_name": "PartENat.le_coe_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [324, 9], "def_end_pos": [324, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\nhk : a ^ k \u2223 b\nhsucc : \u00aca ^ (k + 1) \u2223 b\nthis : Finite a b\n\u22a2 multiplicity a b \u2264 \u2191k", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\nhk : a ^ k \u2223 b\nhsucc : \u00aca ^ (k + 1) \u2223 b\nthis : Finite a b\n\u22a2 \u2203 (h : (multiplicity a b).Dom), (multiplicity a b).get h \u2264 k"}, {"tactic": "exact \u27e8this, Nat.find_min' _ hsucc\u27e9", "annotated_tactic": ["exact \u27e8this, <a>Nat.find_min'</a> _ hsucc\u27e9", [{"full_name": "Nat.find_min'", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Lemmas.lean", "def_pos": [726, 19], "def_end_pos": [726, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\nhk : a ^ k \u2223 b\nhsucc : \u00aca ^ (k + 1) \u2223 b\nthis : Finite a b\n\u22a2 \u2203 (h : (multiplicity a b).Dom), (multiplicity a b).get h \u2264 k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Whiskering.lean", "full_name": "CategoryTheory.Functor.pentagon", "start": [283, 1], "end": [286, 82], "traced_tactics": [{"tactic": "aesop_cat", "annotated_tactic": ["aesop_cat", []], "state_before": "A : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} A\nB : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} B\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nE : Type u\u2085\ninst\u271d : Category.{v\u2085, u\u2085} E\nF : A \u2964 B\nG : B \u2964 C\nH : C \u2964 D\nK : D \u2964 E\n\u22a2 whiskerRight (associator F G H).hom K \u226b (associator F (G \u22d9 H) K).hom \u226b whiskerLeft F (associator G H K).hom =\n    (associator (F \u22d9 G) H K).hom \u226b (associator F G (H \u22d9 K)).hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioi_subset_Ioc_union_Ioi", "start": [1315, 1], "end": [1316, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupClosed.lean", "full_name": "isSublattice_preimage_ofDual", "start": [229, 1], "end": [230, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.add_iSup", "start": [600, 1], "end": [601, 43], "traced_tactics": [{"tactic": "rw [add_comm, iSup_add]", "annotated_tactic": ["rw [<a>add_comm</a>, <a>iSup_add</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "ENNReal.iSup_add", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [570, 9], "def_end_pos": [570, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns\u271d : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\ns : \u03b9 \u2192 \u211d\u22650\u221e\ninst\u271d : Nonempty \u03b9\n\u22a2 a + iSup s = \u2a06 b, a + s b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns\u271d : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\ns : \u03b9 \u2192 \u211d\u22650\u221e\ninst\u271d : Nonempty \u03b9\n\u22a2 \u2a06 b, s b + a = \u2a06 b, a + s b"}, {"tactic": "simp [add_comm]", "annotated_tactic": ["simp [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns\u271d : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\ns : \u03b9 \u2192 \u211d\u22650\u221e\ninst\u271d : Nonempty \u03b9\n\u22a2 \u2a06 b, s b + a = \u2a06 b, a + s b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "one_div_one_div", "start": [482, 1], "end": [482, 53], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivisionMonoid \u03b1\na b c d : \u03b1\n\u22a2 1 / (1 / a) = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Lattice.lean", "full_name": "Multiset.inf_union", "start": [168, 1], "end": [169, 58], "traced_tactics": [{"tactic": "rw [\u2190 inf_dedup, dedup_ext.2, inf_dedup, inf_add]", "annotated_tactic": ["rw [\u2190 <a>inf_dedup</a>, <a>dedup_ext</a>.2, <a>inf_dedup</a>, <a>inf_add</a>]", [{"full_name": "Multiset.inf_dedup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Lattice.lean", "def_pos": [158, 9], "def_end_pos": [158, 18]}, {"full_name": "Multiset.dedup_ext", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Dedup.lean", "def_pos": [126, 9], "def_end_pos": [126, 18]}, {"full_name": "Multiset.inf_dedup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Lattice.lean", "def_pos": [158, 9], "def_end_pos": [158, 18]}, {"full_name": "Multiset.inf_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Lattice.lean", "def_pos": [137, 9], "def_end_pos": [137, 16]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 inf (s\u2081 \u222a s\u2082) = inf s\u2081 \u2293 inf s\u2082", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 s\u2081 \u222a s\u2082 \u2194 a \u2208 s\u2081 + s\u2082"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 s\u2081 \u222a s\u2082 \u2194 a \u2208 s\u2081 + s\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "div_le_iff_of_neg'", "start": [752, 1], "end": [753, 38], "traced_tactics": [{"tactic": "rw [mul_comm, div_le_iff_of_neg hc]", "annotated_tactic": ["rw [<a>mul_comm</a>, <a>div_le_iff_of_neg</a> hc]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "div_le_iff_of_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [743, 9], "def_end_pos": [743, 26]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nhc : c < 0\n\u22a2 b / c \u2264 a \u2194 c * a \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "ContinuousLinearMap.iteratedFDerivWithin_comp_right", "start": [414, 1], "end": [420, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pointwise.lean", "full_name": "Filter.vsub.instNeBot", "start": [1157, 1], "end": [1157, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Opposite.lean", "full_name": "AddOpposite.op_pow", "start": [349, 1], "end": [350, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Support.lean", "full_name": "continuous_of_mulTSupport", "start": [131, 1], "end": [134, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearMap.lean", "full_name": "LinearMap.mk\u2082'_apply", "start": [93, 1], "end": [94, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "full_name": "WithSeminorms.topologicalAddGroup", "start": [280, 1], "end": [282, 52], "traced_tactics": [{"tactic": "exact AddGroupFilterBasis.isTopologicalAddGroup _", "annotated_tactic": ["exact <a>AddGroupFilterBasis.isTopologicalAddGroup</a> _", [{"full_name": "AddGroupFilterBasis.isTopologicalAddGroup", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/FilterBasis.lean", "def_pos": [232, 3], "def_end_pos": [232, 14]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : TopologicalSpace E\np : SeminormFamily \ud835\udd5c E \u03b9\nhp : WithSeminorms p\n\u22a2 TopologicalAddGroup E", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/MinMax.lean", "full_name": "le_min_iff", "start": [33, 1], "end": [34, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/IsAlgClosed/Basic.lean", "full_name": "IsAlgClosed.exists_root", "start": [85, 1], "end": [86, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NoncommProd.lean", "full_name": "Finset.noncommProd_cons", "start": [313, 1], "end": [317, 87], "traced_tactics": [{"tactic": "simp_rw [noncommProd, Finset.cons_val, Multiset.map_cons, Multiset.noncommProd_cons]", "annotated_tactic": ["simp_rw [<a>noncommProd</a>, <a>Finset.cons_val</a>, <a>Multiset.map_cons</a>, <a>Multiset.noncommProd_cons</a>]", [{"full_name": "Finset.noncommProd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NoncommProd.lean", "def_pos": [271, 5], "def_end_pos": [271, 16]}, {"full_name": "Finset.cons_val", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [890, 9], "def_end_pos": [890, 17]}, {"full_name": "Multiset.map_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1217, 9], "def_end_pos": [1217, 17]}, {"full_name": "Multiset.noncommProd_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NoncommProd.lean", "def_pos": [142, 9], "def_end_pos": [142, 25]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : Monoid \u03b3\ns : Finset \u03b1\na : \u03b1\nf : \u03b1 \u2192 \u03b2\nha : a \u2209 s\ncomm : Set.Pairwise \u2191(cons a s ha) fun a b => Commute (f a) (f b)\n\u22a2 noncommProd (cons a s ha) f comm = f a * noncommProd s f \u22ef", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "SubMulAction.mem_one'", "start": [64, 1], "end": [65, 55], "traced_tactics": [{"tactic": "rw [algebraMap_eq_smul_one]", "annotated_tactic": ["rw [<a>algebraMap_eq_smul_one</a>]", [{"full_name": "Algebra.algebraMap_eq_smul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [344, 9], "def_end_pos": [344, 31]}]], "state_before": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\nr : R\n\u22a2 (fun r => r \u2022 1) r = x \u2194 (algebraMap R A) r = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Function/Indicator.lean", "full_name": "Set.mulIndicator_rel_mulIndicator", "start": [341, 1], "end": [345, 22], "traced_tactics": [{"tactic": "simp only [mulIndicator]", "annotated_tactic": ["simp only [<a>mulIndicator</a>]", [{"full_name": "Set.mulIndicator", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [46, 19], "def_end_pos": [46, 31]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns t : Set \u03b1\nf g : \u03b1 \u2192 M\na : \u03b1\nr : M \u2192 M \u2192 Prop\nh1 : r 1 1\nha : a \u2208 s \u2192 r (f a) (g a)\n\u22a2 r (mulIndicator s f a) (mulIndicator s g a)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns t : Set \u03b1\nf g : \u03b1 \u2192 M\na : \u03b1\nr : M \u2192 M \u2192 Prop\nh1 : r 1 1\nha : a \u2208 s \u2192 r (f a) (g a)\n\u22a2 r (if a \u2208 s then f a else 1) (if a \u2208 s then g a else 1)"}, {"tactic": "split_ifs with has", "annotated_tactic": ["split_ifs with has", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns t : Set \u03b1\nf g : \u03b1 \u2192 M\na : \u03b1\nr : M \u2192 M \u2192 Prop\nh1 : r 1 1\nha : a \u2208 s \u2192 r (f a) (g a)\n\u22a2 r (if a \u2208 s then f a else 1) (if a \u2208 s then g a else 1)", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns t : Set \u03b1\nf g : \u03b1 \u2192 M\na : \u03b1\nr : M \u2192 M \u2192 Prop\nh1 : r 1 1\nha : a \u2208 s \u2192 r (f a) (g a)\nhas : a \u2208 s\n\u22a2 r (f a) (g a)\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns t : Set \u03b1\nf g : \u03b1 \u2192 M\na : \u03b1\nr : M \u2192 M \u2192 Prop\nh1 : r 1 1\nha : a \u2208 s \u2192 r (f a) (g a)\nhas : a \u2209 s\n\u22a2 r 1 1"}, {"tactic": "exacts [ha has, h1]", "annotated_tactic": ["exacts [ha has, h1]", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns t : Set \u03b1\nf g : \u03b1 \u2192 M\na : \u03b1\nr : M \u2192 M \u2192 Prop\nh1 : r 1 1\nha : a \u2208 s \u2192 r (f a) (g a)\nhas : a \u2208 s\n\u22a2 r (f a) (g a)\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns t : Set \u03b1\nf g : \u03b1 \u2192 M\na : \u03b1\nr : M \u2192 M \u2192 Prop\nh1 : r 1 1\nha : a \u2208 s \u2192 r (f a) (g a)\nhas : a \u2209 s\n\u22a2 r 1 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Inv.lean", "full_name": "deriv_inv'", "start": [94, 1], "end": [95, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean", "full_name": "MeasurableSpace.finite_countablePartition", "start": [198, 1], "end": [200, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "LinearIndependent.comp", "start": [230, 1], "end": [238, 34], "traced_tactics": [{"tactic": "rw [linearIndependent_iff, Finsupp.total_comp]", "annotated_tactic": ["rw [<a>linearIndependent_iff</a>, <a>Finsupp.total_comp</a>]", [{"full_name": "linearIndependent_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [126, 9], "def_end_pos": [126, 30]}, {"full_name": "Finsupp.total_comp", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [863, 9], "def_end_pos": [863, 19]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\n\u22a2 LinearIndependent R (v \u2218 f)", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\n\u22a2 \u2200 (l : \u03b9' \u2192\u2080 R), (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0 \u2192 l = 0"}, {"tactic": "intro l hl", "annotated_tactic": ["intro l hl", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\n\u22a2 \u2200 (l : \u03b9' \u2192\u2080 R), (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0 \u2192 l = 0", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\n\u22a2 l = 0"}, {"tactic": "have h_map_domain : \u2200 x, (Finsupp.mapDomain f l) (f x) = 0 := by\n  rw [linearIndependent_iff.1 h (Finsupp.mapDomain f l) hl]; simp", "annotated_tactic": ["have h_map_domain : \u2200 x, (<a>Finsupp.mapDomain</a> f l) (f x) = 0 := by\n    rw [<a>linearIndependent_iff</a>.1 h (<a>Finsupp.mapDomain</a> f l) hl]; simp", [{"full_name": "Finsupp.mapDomain", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [452, 5], "def_end_pos": [452, 14]}, {"full_name": "linearIndependent_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [126, 9], "def_end_pos": [126, 30]}, {"full_name": "Finsupp.mapDomain", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [452, 5], "def_end_pos": [452, 14]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\n\u22a2 l = 0", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\nh_map_domain : \u2200 (x : \u03b9'), (Finsupp.mapDomain f l) (f x) = 0\n\u22a2 l = 0"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\nh_map_domain : \u2200 (x : \u03b9'), (Finsupp.mapDomain f l) (f x) = 0\n\u22a2 l = 0", "state_after": "case h\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\nh_map_domain : \u2200 (x : \u03b9'), (Finsupp.mapDomain f l) (f x) = 0\nx : \u03b9'\n\u22a2 l x = 0 x"}, {"tactic": "convert h_map_domain x", "annotated_tactic": ["convert h_map_domain x", []], "state_before": "case h\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\nh_map_domain : \u2200 (x : \u03b9'), (Finsupp.mapDomain f l) (f x) = 0\nx : \u03b9'\n\u22a2 l x = 0 x", "state_after": "case h.e'_2\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\nh_map_domain : \u2200 (x : \u03b9'), (Finsupp.mapDomain f l) (f x) = 0\nx : \u03b9'\n\u22a2 l x = (Finsupp.mapDomain f l) (f x)"}, {"tactic": "rw [Finsupp.mapDomain_apply hf]", "annotated_tactic": ["rw [<a>Finsupp.mapDomain_apply</a> hf]", [{"full_name": "Finsupp.mapDomain_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [456, 9], "def_end_pos": [456, 24]}]], "state_before": "case h.e'_2\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\nh_map_domain : \u2200 (x : \u03b9'), (Finsupp.mapDomain f l) (f x) = 0\nx : \u03b9'\n\u22a2 l x = (Finsupp.mapDomain f l) (f x)", "state_after": "no goals"}, {"tactic": "rw [linearIndependent_iff.1 h (Finsupp.mapDomain f l) hl]", "annotated_tactic": ["rw [<a>linearIndependent_iff</a>.1 h (<a>Finsupp.mapDomain</a> f l) hl]", [{"full_name": "linearIndependent_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [126, 9], "def_end_pos": [126, 30]}, {"full_name": "Finsupp.mapDomain", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [452, 5], "def_end_pos": [452, 14]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\n\u22a2 \u2200 (x : \u03b9'), (Finsupp.mapDomain f l) (f x) = 0", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\n\u22a2 \u2200 (x : \u03b9'), 0 (f x) = 0"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nh : LinearIndependent R v\nf : \u03b9' \u2192 \u03b9\nhf : Injective f\nl : \u03b9' \u2192\u2080 R\nhl : (Finsupp.total \u03b9 M R v \u2218\u2097 Finsupp.lmapDomain R R f) l = 0\n\u22a2 \u2200 (x : \u03b9'), 0 (f x) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.zipRight_eq_zipRight'", "start": [4249, 1], "end": [4250, 57], "traced_tactics": [{"tactic": "induction as generalizing bs <;> cases bs <;> simp [*]", "annotated_tactic": ["induction as generalizing bs <;> cases bs <;> simp [*]", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nas : List \u03b1\nb : \u03b2\nbs : List \u03b2\n\u22a2 zipRight as bs = (zipRight' as bs).1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.OuterMeasure.restrict_le_self", "start": [590, 1], "end": [591, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.add_apply", "start": [281, 1], "end": [282, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Set.lean", "full_name": "Equiv.prod_assoc_image", "start": [159, 1], "end": [161, 70], "traced_tactics": [{"tactic": "simpa only [Equiv.image_eq_preimage] using prod_assoc_symm_preimage", "annotated_tactic": ["simpa only [<a>Equiv.image_eq_preimage</a>] using <a>prod_assoc_symm_preimage</a>", [{"full_name": "Equiv.image_eq_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Set.lean", "def_pos": [41, 19], "def_end_pos": [41, 36]}, {"full_name": "Equiv.prod_assoc_symm_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Set.lean", "def_pos": [151, 9], "def_end_pos": [151, 33]}]], "state_before": "\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nu : Set \u03b3\n\u22a2 \u21d1(prodAssoc \u03b1 \u03b2 \u03b3) '' (s \u00d7\u02e2 t) \u00d7\u02e2 u = s \u00d7\u02e2 t \u00d7\u02e2 u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Basic.lean", "full_name": "HahnSeries.embDomain_single", "start": [330, 1], "end": [338, 76], "traced_tactics": [{"tactic": "ext g'", "annotated_tactic": ["ext g'", []], "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\n\u22a2 embDomain f ((single g) r) = (single (f g)) r", "state_after": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\n\u22a2 (embDomain f ((single g) r)).coeff g' = ((single (f g)) r).coeff g'"}, {"tactic": "by_cases h : g' = f g", "annotated_tactic": ["by_cases h : g' = f g", []], "state_before": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\n\u22a2 (embDomain f ((single g) r)).coeff g' = ((single (f g)) r).coeff g'", "state_after": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : g' = f g\n\u22a2 (embDomain f ((single g) r)).coeff g' = ((single (f g)) r).coeff g'\n\ncase neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : \u00acg' = f g\n\u22a2 (embDomain f ((single g) r)).coeff g' = ((single (f g)) r).coeff g'"}, {"tactic": "rw [embDomain_notin_image_support, single_coeff_of_ne h]", "annotated_tactic": ["rw [<a>embDomain_notin_image_support</a>, <a>single_coeff_of_ne</a> h]", [{"full_name": "HahnSeries.embDomain_notin_image_support", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Basic.lean", "def_pos": [306, 9], "def_end_pos": [306, 38]}, {"full_name": "HahnSeries.single_coeff_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Basic.lean", "def_pos": [176, 9], "def_end_pos": [176, 27]}]], "state_before": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : \u00acg' = f g\n\u22a2 (embDomain f ((single g) r)).coeff g' = ((single (f g)) r).coeff g'", "state_after": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : \u00acg' = f g\n\u22a2 g' \u2209 \u21d1f '' support ((single g) r)"}, {"tactic": "by_cases hr : r = 0", "annotated_tactic": ["by_cases hr : r = 0", []], "state_before": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : \u00acg' = f g\n\u22a2 g' \u2209 \u21d1f '' support ((single g) r)", "state_after": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : \u00acg' = f g\nhr : r = 0\n\u22a2 g' \u2209 \u21d1f '' support ((single g) r)\n\ncase neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : \u00acg' = f g\nhr : \u00acr = 0\n\u22a2 g' \u2209 \u21d1f '' support ((single g) r)"}, {"tactic": "rwa [support_single_of_ne hr, Set.image_singleton, Set.mem_singleton_iff]", "annotated_tactic": ["rwa [<a>support_single_of_ne</a> hr, <a>Set.image_singleton</a>, <a>Set.mem_singleton_iff</a>]", [{"full_name": "HahnSeries.support_single_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Basic.lean", "def_pos": [185, 9], "def_end_pos": [185, 29]}, {"full_name": "Set.image_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [335, 9], "def_end_pos": [335, 24]}, {"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}]], "state_before": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : \u00acg' = f g\nhr : \u00acr = 0\n\u22a2 g' \u2209 \u21d1f '' support ((single g) r)", "state_after": "no goals"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : g' = f g\n\u22a2 (embDomain f ((single g) r)).coeff g' = ((single (f g)) r).coeff g'", "state_after": "no goals"}, {"tactic": "simp [hr]", "annotated_tactic": ["simp [hr]", []], "state_before": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : Zero R\na b : \u0393\nr\u271d : R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\ng : \u0393\nr : R\ng' : \u0393'\nh : \u00acg' = f g\nhr : r = 0\n\u22a2 g' \u2209 \u21d1f '' support ((single g) r)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Bitwise.lean", "full_name": "Int.testBit_lor", "start": [340, 1], "end": [341, 37], "traced_tactics": [{"tactic": "rw [\u2190 bitwise_or, testBit_bitwise]", "annotated_tactic": ["rw [\u2190 <a>bitwise_or</a>, <a>testBit_bitwise</a>]", [{"full_name": "Int.bitwise_or", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Bitwise.lean", "def_pos": [220, 9], "def_end_pos": [220, 19]}, {"full_name": "Int.testBit_bitwise", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Bitwise.lean", "def_pos": [330, 9], "def_end_pos": [330, 24]}]], "state_before": "m n : \u2124\nk : \u2115\n\u22a2 testBit (lor m n) k = (testBit m k || testBit n k)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Pointwise.lean", "full_name": "AddSubmonoid.mul_le_mul", "start": [581, 1], "end": [582, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "full_name": "HasSum.nonpos", "start": [129, 1], "end": [130, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_coe_sort", "start": [1054, 1], "end": [1054, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Commutator.lean", "full_name": "Subgroup.commutator_le", "start": [90, 1], "end": [92, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "full_name": "Real.Angle.sin_sub_pi", "start": [390, 1], "end": [391, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.toMeasure_apply\u2080", "start": [688, 1], "end": [695, 26], "traced_tactics": [{"tactic": "refine' le_antisymm _ (le_toMeasure_apply _ _ _)", "annotated_tactic": ["refine' <a>le_antisymm</a> _ (<a>le_toMeasure_apply</a> _ _ _)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "MeasureTheory.le_toMeasure_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "def_pos": [683, 9], "def_end_pos": [683, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nms : MeasurableSpace \u03b1\ns\u271d t : Set \u03b1\nm : OuterMeasure \u03b1\nh : ms \u2264 OuterMeasure.caratheodory m\ns : Set \u03b1\nhs : NullMeasurableSet s (OuterMeasure.toMeasure m h)\n\u22a2 \u2191\u2191(OuterMeasure.toMeasure m h) s = \u2191m s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nms : MeasurableSpace \u03b1\ns\u271d t : Set \u03b1\nm : OuterMeasure \u03b1\nh : ms \u2264 OuterMeasure.caratheodory m\ns : Set \u03b1\nhs : NullMeasurableSet s (OuterMeasure.toMeasure m h)\n\u22a2 \u2191\u2191(OuterMeasure.toMeasure m h) s \u2264 \u2191m s"}, {"tactic": "rcases hs.exists_measurable_subset_ae_eq with \u27e8t, hts, htm, heq\u27e9", "annotated_tactic": ["rcases hs.exists_measurable_subset_ae_eq with \u27e8t, hts, htm, heq\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nms : MeasurableSpace \u03b1\ns\u271d t : Set \u03b1\nm : OuterMeasure \u03b1\nh : ms \u2264 OuterMeasure.caratheodory m\ns : Set \u03b1\nhs : NullMeasurableSet s (OuterMeasure.toMeasure m h)\n\u22a2 \u2191\u2191(OuterMeasure.toMeasure m h) s \u2264 \u2191m s", "state_after": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nms : MeasurableSpace \u03b1\ns\u271d t\u271d : Set \u03b1\nm : OuterMeasure \u03b1\nh : ms \u2264 OuterMeasure.caratheodory m\ns : Set \u03b1\nhs : NullMeasurableSet s (OuterMeasure.toMeasure m h)\nt : Set \u03b1\nhts : t \u2286 s\nhtm : MeasurableSet t\nheq : t =\u1d50[OuterMeasure.toMeasure m h] s\n\u22a2 \u2191\u2191(OuterMeasure.toMeasure m h) s \u2264 \u2191m s"}, {"tactic": "calc\n  m.toMeasure h s = m.toMeasure h t := measure_congr heq.symm\n  _ = m t := (toMeasure_apply m h htm)\n  _ \u2264 m s := m.mono hts", "annotated_tactic": ["calc\n    m.toMeasure h s = m.toMeasure h t := <a>measure_congr</a> heq.symm\n    _ = m t := (<a>toMeasure_apply</a> m h htm)\n    _ \u2264 m s := m.mono hts", [{"full_name": "MeasureTheory.measure_congr", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [606, 9], "def_end_pos": [606, 22]}, {"full_name": "MeasureTheory.toMeasure_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "def_pos": [678, 9], "def_end_pos": [678, 24]}]], "state_before": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nms : MeasurableSpace \u03b1\ns\u271d t\u271d : Set \u03b1\nm : OuterMeasure \u03b1\nh : ms \u2264 OuterMeasure.caratheodory m\ns : Set \u03b1\nhs : NullMeasurableSet s (OuterMeasure.toMeasure m h)\nt : Set \u03b1\nhts : t \u2286 s\nhtm : MeasurableSet t\nheq : t =\u1d50[OuterMeasure.toMeasure m h] s\n\u22a2 \u2191\u2191(OuterMeasure.toMeasure m h) s \u2264 \u2191m s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Multiset.bijective_iff_map_univ_eq_univ", "start": [1259, 1], "end": [1264, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Pi.lean", "full_name": "fderiv_update", "start": [36, 1], "end": [38, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Real.exp_mul", "start": [60, 1], "end": [60, 100], "traced_tactics": [{"tactic": "rw [rpow_def_of_pos (exp_pos _), log_exp]", "annotated_tactic": ["rw [<a>rpow_def_of_pos</a> (<a>exp_pos</a> _), <a>log_exp</a>]", [{"full_name": "Real.rpow_def_of_pos", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [56, 9], "def_end_pos": [56, 24]}, {"full_name": "Real.exp_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [1185, 9], "def_end_pos": [1185, 16]}, {"full_name": "Real.log_exp", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "def_pos": [78, 9], "def_end_pos": [78, 16]}]], "state_before": "x\u271d y\u271d z x y : \u211d\n\u22a2 rexp (x * y) = rexp x ^ y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "mul_self_lt_mul_self", "start": [569, 1], "end": [570, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean", "full_name": "orthonormal_iff_ite", "start": [744, 1], "end": [759, 30], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\n\u22a2 Orthonormal \ud835\udd5c v \u2194 \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0", "state_after": "case mp\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\n\u22a2 Orthonormal \ud835\udd5c v \u2192 \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\n\ncase mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\n\u22a2 (\u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0) \u2192 Orthonormal \ud835\udd5c v"}, {"tactic": "intro hv i j", "annotated_tactic": ["intro hv i j", []], "state_before": "case mp\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\n\u22a2 Orthonormal \ud835\udd5c v \u2192 \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0", "state_after": "case mp\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nhv : Orthonormal \ud835\udd5c v\ni j : \u03b9\n\u22a2 \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0"}, {"tactic": "split_ifs with h", "annotated_tactic": ["split_ifs with h", []], "state_before": "case mp\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nhv : Orthonormal \ud835\udd5c v\ni j : \u03b9\n\u22a2 \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0", "state_after": "case pos\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nhv : Orthonormal \ud835\udd5c v\ni j : \u03b9\nh : i = j\n\u22a2 \u27eav i, v j\u27eb_\ud835\udd5c = 1\n\ncase neg\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nhv : Orthonormal \ud835\udd5c v\ni j : \u03b9\nh : \u00aci = j\n\u22a2 \u27eav i, v j\u27eb_\ud835\udd5c = 0"}, {"tactic": "simp [h, inner_self_eq_norm_sq_to_K, hv.1]", "annotated_tactic": ["simp [h, <a>inner_self_eq_norm_sq_to_K</a>, hv.1]", [{"full_name": "inner_self_eq_norm_sq_to_K", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [578, 9], "def_end_pos": [578, 35]}]], "state_before": "case pos\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nhv : Orthonormal \ud835\udd5c v\ni j : \u03b9\nh : i = j\n\u22a2 \u27eav i, v j\u27eb_\ud835\udd5c = 1", "state_after": "no goals"}, {"tactic": "exact hv.2 h", "annotated_tactic": ["exact hv.2 h", []], "state_before": "case neg\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nhv : Orthonormal \ud835\udd5c v\ni j : \u03b9\nh : \u00aci = j\n\u22a2 \u27eav i, v j\u27eb_\ud835\udd5c = 0", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\n\u22a2 (\u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0) \u2192 Orthonormal \ud835\udd5c v", "state_after": "case mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\n\u22a2 Orthonormal \ud835\udd5c v"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\n\u22a2 Orthonormal \ud835\udd5c v", "state_after": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\n\u22a2 \u2200 (i : \u03b9), \u2016v i\u2016 = 1\n\ncase mpr.right\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\n\u22a2 Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0"}, {"tactic": "intro i", "annotated_tactic": ["intro i", []], "state_before": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\n\u22a2 \u2200 (i : \u03b9), \u2016v i\u2016 = 1", "state_after": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni : \u03b9\n\u22a2 \u2016v i\u2016 = 1"}, {"tactic": "have h' : \u2016v i\u2016 ^ 2 = 1 ^ 2 := by simp [@norm_sq_eq_inner \ud835\udd5c, h i i]", "annotated_tactic": ["have h' : \u2016v i\u2016 ^ 2 = 1 ^ 2 := by simp [@<a>norm_sq_eq_inner</a> \ud835\udd5c, h i i]", [{"full_name": "InnerProductSpace.norm_sq_eq_inner", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [108, 3], "def_end_pos": [108, 19]}]], "state_before": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni : \u03b9\n\u22a2 \u2016v i\u2016 = 1", "state_after": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni : \u03b9\nh' : \u2016v i\u2016 ^ 2 = 1 ^ 2\n\u22a2 \u2016v i\u2016 = 1"}, {"tactic": "have h\u2081 : 0 \u2264 \u2016v i\u2016 := norm_nonneg _", "annotated_tactic": ["have h\u2081 : 0 \u2264 \u2016v i\u2016 := <a>norm_nonneg</a> _", [{"full_name": "norm_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [551, 30], "def_end_pos": [551, 41]}]], "state_before": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni : \u03b9\nh' : \u2016v i\u2016 ^ 2 = 1 ^ 2\n\u22a2 \u2016v i\u2016 = 1", "state_after": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni : \u03b9\nh' : \u2016v i\u2016 ^ 2 = 1 ^ 2\nh\u2081 : 0 \u2264 \u2016v i\u2016\n\u22a2 \u2016v i\u2016 = 1"}, {"tactic": "have h\u2082 : (0 : \u211d) \u2264 1 := zero_le_one", "annotated_tactic": ["have h\u2082 : (0 : \u211d) \u2264 1 := <a>zero_le_one</a>", [{"full_name": "zero_le_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [26, 15], "def_end_pos": [26, 26]}]], "state_before": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni : \u03b9\nh' : \u2016v i\u2016 ^ 2 = 1 ^ 2\nh\u2081 : 0 \u2264 \u2016v i\u2016\n\u22a2 \u2016v i\u2016 = 1", "state_after": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni : \u03b9\nh' : \u2016v i\u2016 ^ 2 = 1 ^ 2\nh\u2081 : 0 \u2264 \u2016v i\u2016\nh\u2082 : 0 \u2264 1\n\u22a2 \u2016v i\u2016 = 1"}, {"tactic": "rwa [sq_eq_sq h\u2081 h\u2082] at h'", "annotated_tactic": ["rwa [<a>sq_eq_sq</a> h\u2081 h\u2082] at h'", [{"full_name": "sq_eq_sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [384, 9], "def_end_pos": [384, 17]}]], "state_before": "case mpr.left\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni : \u03b9\nh' : \u2016v i\u2016 ^ 2 = 1 ^ 2\nh\u2081 : 0 \u2264 \u2016v i\u2016\nh\u2082 : 0 \u2264 1\n\u22a2 \u2016v i\u2016 = 1", "state_after": "no goals"}, {"tactic": "simp [@norm_sq_eq_inner \ud835\udd5c, h i i]", "annotated_tactic": ["simp [@<a>norm_sq_eq_inner</a> \ud835\udd5c, h i i]", [{"full_name": "InnerProductSpace.norm_sq_eq_inner", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [108, 3], "def_end_pos": [108, 19]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni : \u03b9\n\u22a2 \u2016v i\u2016 ^ 2 = 1 ^ 2", "state_after": "no goals"}, {"tactic": "intro i j hij", "annotated_tactic": ["intro i j hij", []], "state_before": "case mpr.right\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\n\u22a2 Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0", "state_after": "case mpr.right\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 \u27eav i, v j\u27eb_\ud835\udd5c = 0"}, {"tactic": "simpa [hij] using h i j", "annotated_tactic": ["simpa [hij] using h i j", []], "state_before": "case mpr.right\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075 : IsROrC \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 E\nh : \u2200 (i j : \u03b9), \u27eav i, v j\u27eb_\ud835\udd5c = if i = j then 1 else 0\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 \u27eav i, v j\u27eb_\ud835\udd5c = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/EMetricSpace/Lipschitz.lean", "full_name": "LocallyLipschitz.id", "start": [357, 1], "end": [358, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Basic.lean", "full_name": "Ne.lt_of_le", "start": [103, 1], "end": [104, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/FinitePresentation.lean", "full_name": "Algebra.FinitePresentation.of_finiteType", "start": [70, 1], "end": [79, 15], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, Algebra.FiniteType.of_finitePresentation\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, <a>Algebra.FiniteType.of_finitePresentation</a>\u27e9", [{"full_name": "Algebra.FiniteType.of_finitePresentation", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/FinitePresentation.lean", "def_pos": [56, 9], "def_end_pos": [56, 30]}]], "state_before": "R : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\n\u22a2 FiniteType R A \u2194 FinitePresentation R A", "state_after": "R : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\n\u22a2 FinitePresentation R A"}, {"tactic": "obtain \u27e8n, f, hf\u27e9 := Algebra.FiniteType.iff_quotient_mvPolynomial''.1 h", "annotated_tactic": ["obtain \u27e8n, f, hf\u27e9 := <a>Algebra.FiniteType.iff_quotient_mvPolynomial''</a>.1 h", [{"full_name": "Algebra.FiniteType.iff_quotient_mvPolynomial''", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/FiniteType.lean", "def_pos": [192, 9], "def_end_pos": [192, 36]}]], "state_before": "R : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\n\u22a2 FinitePresentation R A", "state_after": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\n\u22a2 FinitePresentation R A"}, {"tactic": "refine' \u27e8n, f, hf, _\u27e9", "annotated_tactic": ["refine' \u27e8n, f, hf, _\u27e9", []], "state_before": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\n\u22a2 FinitePresentation R A", "state_after": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)"}, {"tactic": "have hnoet : IsNoetherianRing (MvPolynomial (Fin n) R) := by infer_instance", "annotated_tactic": ["have hnoet : <a>IsNoetherianRing</a> (<a>MvPolynomial</a> (<a>Fin</a> n) R) := by infer_instance", [{"full_name": "IsNoetherianRing", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Noetherian.lean", "def_pos": [503, 5], "def_end_pos": [503, 21]}, {"full_name": "MvPolynomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [86, 5], "def_end_pos": [86, 17]}, {"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}]], "state_before": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)", "state_after": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\nhnoet : IsNoetherianRing (MvPolynomial (Fin n) R)\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)"}, {"tactic": "rw [isNoetherianRing_iff] at hnoet", "annotated_tactic": ["rw [<a>isNoetherianRing_iff</a>] at hnoet", [{"full_name": "isNoetherianRing_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Noetherian.lean", "def_pos": [507, 9], "def_end_pos": [507, 29]}]], "state_before": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\nhnoet : IsNoetherianRing (MvPolynomial (Fin n) R)\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)", "state_after": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\nhnoet : IsNoetherian (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R)\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)"}, {"tactic": "letI : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule", "annotated_tactic": ["letI : <a>Module</a> (<a>MvPolynomial</a> (<a>Fin</a> n) R) (<a>MvPolynomial</a> (<a>Fin</a> n) R) := <a>Semiring.toModule</a>", [{"full_name": "Module", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [56, 7], "def_end_pos": [56, 13]}, {"full_name": "MvPolynomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [86, 5], "def_end_pos": [86, 17]}, {"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}, {"full_name": "MvPolynomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [86, 5], "def_end_pos": [86, 17]}, {"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}, {"full_name": "Semiring.toModule", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [315, 28], "def_end_pos": [315, 45]}]], "state_before": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\nhnoet : IsNoetherian (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R)\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)", "state_after": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\nhnoet : IsNoetherian (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R)\nthis : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)"}, {"tactic": "have := hnoet.noetherian (RingHom.ker f.toRingHom)", "annotated_tactic": ["have := hnoet.noetherian (<a>RingHom.ker</a> f.toRingHom)", [{"full_name": "RingHom.ker", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [2124, 5], "def_end_pos": [2124, 8]}]], "state_before": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\nhnoet : IsNoetherian (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R)\nthis : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)", "state_after": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\nhnoet : IsNoetherian (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R)\nthis\u271d : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule\nthis : Submodule.FG (RingHom.ker f.toRingHom)\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)"}, {"tactic": "convert this", "annotated_tactic": ["convert this", []], "state_before": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\nhnoet : IsNoetherian (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R)\nthis\u271d : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule\nthis : Submodule.FG (RingHom.ker f.toRingHom)\n\u22a2 Ideal.FG (RingHom.ker f.toRingHom)", "state_after": "no goals"}, {"tactic": "infer_instance", "annotated_tactic": ["infer_instance", []], "state_before": "R : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : CommRing B\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsNoetherianRing R\nh : FiniteType R A\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f\n\u22a2 IsNoetherianRing (MvPolynomial (Fin n) R)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Cardinality.lean", "full_name": "Cardinal.not_countable_real", "start": [218, 1], "end": [220, 15], "traced_tactics": [{"tactic": "rw [\u2190 le_aleph0_iff_set_countable, not_le, mk_univ_real]", "annotated_tactic": ["rw [\u2190 <a>le_aleph0_iff_set_countable</a>, <a>not_le</a>, <a>mk_univ_real</a>]", [{"full_name": "Cardinal.le_aleph0_iff_set_countable", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1631, 9], "def_end_pos": [1631, 36]}, {"full_name": "not_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [367, 9], "def_end_pos": [367, 15]}, {"full_name": "Cardinal.mk_univ_real", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Cardinality.lean", "def_pos": [214, 9], "def_end_pos": [214, 21]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\n\u22a2 \u00acSet.Countable Set.univ", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\n\u22a2 \u2135\u2080 < \ud835\udd20"}, {"tactic": "apply cantor", "annotated_tactic": ["apply <a>cantor</a>", [{"full_name": "Cardinal.cantor", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [736, 9], "def_end_pos": [736, 15]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\n\u22a2 \u2135\u2080 < \ud835\udd20", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.iInf_mul_right", "start": [517, 1], "end": [519, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Semicontinuous.lean", "full_name": "lowerSemicontinuousAt_sum", "start": [614, 1], "end": [618, 43], "traced_tactics": [{"tactic": "simp_rw [\u2190 lowerSemicontinuousWithinAt_univ_iff] at *", "annotated_tactic": ["simp_rw [\u2190 <a>lowerSemicontinuousWithinAt_univ_iff</a>] at *", [{"full_name": "lowerSemicontinuousWithinAt_univ_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Semicontinuous.lean", "def_pos": [150, 9], "def_end_pos": [150, 45]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b9 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b3 : LinearOrderedAddCommMonoid \u03b3\ninst\u271d\u00b2 : TopologicalSpace \u03b3\ninst\u271d\u00b9 : OrderTopology \u03b3\ninst\u271d : ContinuousAdd \u03b3\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b3\na : Finset \u03b9\nha : \u2200 i \u2208 a, LowerSemicontinuousAt (f i) x\n\u22a2 LowerSemicontinuousAt (fun z => \u2211 i in a, f i z) x", "state_after": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b9 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b3 : LinearOrderedAddCommMonoid \u03b3\ninst\u271d\u00b2 : TopologicalSpace \u03b3\ninst\u271d\u00b9 : OrderTopology \u03b3\ninst\u271d : ContinuousAdd \u03b3\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b3\na : Finset \u03b9\nha : \u2200 i \u2208 a, LowerSemicontinuousWithinAt (f i) univ x\n\u22a2 LowerSemicontinuousWithinAt (fun z => \u2211 i in a, f i z) univ x"}, {"tactic": "exact lowerSemicontinuousWithinAt_sum ha", "annotated_tactic": ["exact <a>lowerSemicontinuousWithinAt_sum</a> ha", [{"full_name": "lowerSemicontinuousWithinAt_sum", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Semicontinuous.lean", "def_pos": [602, 9], "def_end_pos": [602, 40]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b9 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b3 : LinearOrderedAddCommMonoid \u03b3\ninst\u271d\u00b2 : TopologicalSpace \u03b3\ninst\u271d\u00b9 : OrderTopology \u03b3\ninst\u271d : ContinuousAdd \u03b3\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b3\na : Finset \u03b9\nha : \u2200 i \u2208 a, LowerSemicontinuousWithinAt (f i) univ x\n\u22a2 LowerSemicontinuousWithinAt (fun z => \u2211 i in a, f i z) univ x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.smul_finset_neg", "start": [2330, 1], "end": [2331, 78], "traced_tactics": [{"tactic": "simp only [\u2190 image_smul, \u2190 image_neg, Function.comp, image_image, smul_neg]", "annotated_tactic": ["simp only [\u2190 <a>image_smul</a>, \u2190 <a>image_neg</a>, <a>Function.comp</a>, <a>image_image</a>, <a>smul_neg</a>]", [{"full_name": "Finset.image_smul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Pointwise.lean", "def_pos": [1706, 9], "def_end_pos": [1706, 19]}, {"full_name": "Finset.image_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Pointwise.lean", "def_pos": [226, 3], "def_end_pos": [226, 14]}, {"full_name": "Function.comp", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}, {"full_name": "Finset.image_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [461, 9], "def_end_pos": [461, 20]}, {"full_name": "smul_neg", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [1020, 9], "def_end_pos": [1020, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : AddGroup \u03b2\ninst\u271d\u00b9 : DistribMulAction \u03b1 \u03b2\ninst\u271d : DecidableEq \u03b2\na : \u03b1\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 a \u2022 -t = -(a \u2022 t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.coe_restrictScalars", "start": [1126, 1], "end": [1127, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "continuous_div_right'", "start": [1146, 1], "end": [1147, 96], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean", "full_name": "MeasurableSpace.generateFrom_iUnion_memPartition", "start": [135, 1], "end": [153, 96], "traced_tactics": [{"tactic": "refine le_antisymm (generateFrom_le fun u hu \u21a6 ?_) (generateFrom_le fun u hu \u21a6 ?_)", "annotated_tactic": ["refine <a>le_antisymm</a> (<a>generateFrom_le</a> fun u hu \u21a6 ?_) (<a>generateFrom_le</a> fun u hu \u21a6 ?_)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "MeasurableSpace.generateFrom_le", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [393, 9], "def_end_pos": [393, 24]}, {"full_name": "MeasurableSpace.generateFrom_le", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [393, 9], "def_end_pos": [393, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\n\u22a2 generateFrom (\u22c3 n, memPartition t n) = generateFrom (range t)", "state_after": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhu : u \u2208 \u22c3 n, memPartition t n\n\u22a2 MeasurableSet u\n\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhu : u \u2208 range t\n\u22a2 MeasurableSet u"}, {"tactic": "simp only [mem_iUnion] at hu", "annotated_tactic": ["simp only [<a>mem_iUnion</a>] at hu", [{"full_name": "Set.mem_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [272, 9], "def_end_pos": [272, 19]}]], "state_before": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhu : u \u2208 \u22c3 n, memPartition t n\n\u22a2 MeasurableSet u", "state_after": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhu : \u2203 i, u \u2208 memPartition t i\n\u22a2 MeasurableSet u"}, {"tactic": "obtain \u27e8n, hun\u27e9 := hu", "annotated_tactic": ["obtain \u27e8n, hun\u27e9 := hu", []], "state_before": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhu : \u2203 i, u \u2208 memPartition t i\n\u22a2 MeasurableSet u", "state_after": "case refine_1.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nn : \u2115\nhun : u \u2208 memPartition t n\n\u22a2 MeasurableSet u"}, {"tactic": "simp only [Nat.zero_eq, memPartition_zero, mem_insert_iff, mem_singleton_iff] at hun", "annotated_tactic": ["simp only [<a>Nat.zero_eq</a>, <a>memPartition_zero</a>, <a>mem_insert_iff</a>, <a>mem_singleton_iff</a>] at hun", [{"full_name": "Nat.zero_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [83, 17], "def_end_pos": [83, 24]}, {"full_name": "memPartition_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/MemPartition.lean", "def_pos": [44, 7], "def_end_pos": [44, 24]}, {"full_name": "Set.mem_insert_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1117, 9], "def_end_pos": [1117, 23]}, {"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}]], "state_before": "case refine_1.intro.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhun : u \u2208 memPartition t Nat.zero\n\u22a2 MeasurableSet u", "state_after": "case refine_1.intro.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhun : u = univ\n\u22a2 MeasurableSet u"}, {"tactic": "rw [hun]", "annotated_tactic": ["rw [hun]", []], "state_before": "case refine_1.intro.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhun : u = univ\n\u22a2 MeasurableSet u", "state_after": "case refine_1.intro.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhun : u = univ\n\u22a2 MeasurableSet univ"}, {"tactic": "exact MeasurableSet.univ", "annotated_tactic": ["exact <a>MeasurableSet.univ</a>", [{"full_name": "MeasurableSet.univ", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [102, 19], "def_end_pos": [102, 37]}]], "state_before": "case refine_1.intro.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhun : u = univ\n\u22a2 MeasurableSet univ", "state_after": "no goals"}, {"tactic": "simp only [memPartition_succ, mem_setOf_eq] at hun", "annotated_tactic": ["simp only [<a>memPartition_succ</a>, <a>mem_setOf_eq</a>] at hun", [{"full_name": "memPartition_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/MemPartition.lean", "def_pos": [46, 7], "def_end_pos": [46, 24]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}]], "state_before": "case refine_1.intro.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\nih : \u2200 u \u2208 memPartition t n, MeasurableSet u\nu : Set \u03b1\nhun : u \u2208 memPartition t (Nat.succ n)\n\u22a2 MeasurableSet u", "state_after": "case refine_1.intro.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\nih : \u2200 u \u2208 memPartition t n, MeasurableSet u\nu : Set \u03b1\nhun : \u2203 u_1 \u2208 memPartition t n, u = u_1 \u2229 t n \u2228 u = u_1 \\ t n\n\u22a2 MeasurableSet u"}, {"tactic": "obtain \u27e8v, hv, huv\u27e9 := hun", "annotated_tactic": ["obtain \u27e8v, hv, huv\u27e9 := hun", []], "state_before": "case refine_1.intro.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\nih : \u2200 u \u2208 memPartition t n, MeasurableSet u\nu : Set \u03b1\nhun : \u2203 u_1 \u2208 memPartition t n, u = u_1 \u2229 t n \u2228 u = u_1 \\ t n\n\u22a2 MeasurableSet u", "state_after": "case refine_1.intro.succ.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\nih : \u2200 u \u2208 memPartition t n, MeasurableSet u\nu v : Set \u03b1\nhv : v \u2208 memPartition t n\nhuv : u = v \u2229 t n \u2228 u = v \\ t n\n\u22a2 MeasurableSet u"}, {"tactic": "rcases huv with rfl | rfl", "annotated_tactic": ["rcases huv with rfl | rfl", []], "state_before": "case refine_1.intro.succ.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\nih : \u2200 u \u2208 memPartition t n, MeasurableSet u\nu v : Set \u03b1\nhv : v \u2208 memPartition t n\nhuv : u = v \u2229 t n \u2228 u = v \\ t n\n\u22a2 MeasurableSet u", "state_after": "case refine_1.intro.succ.intro.intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\nih : \u2200 u \u2208 memPartition t n, MeasurableSet u\nv : Set \u03b1\nhv : v \u2208 memPartition t n\n\u22a2 MeasurableSet (v \u2229 t n)\n\ncase refine_1.intro.succ.intro.intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\nih : \u2200 u \u2208 memPartition t n, MeasurableSet u\nv : Set \u03b1\nhv : v \u2208 memPartition t n\n\u22a2 MeasurableSet (v \\ t n)"}, {"tactic": "exact (ih v hv).inter (measurableSet_generateFrom \u27e8n, rfl\u27e9)", "annotated_tactic": ["exact (ih v hv).<a>inter</a> (<a>measurableSet_generateFrom</a> \u27e8n, <a>rfl</a>\u27e9)", [{"full_name": "MeasurableSet.inter", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [199, 19], "def_end_pos": [199, 38]}, {"full_name": "MeasurableSpace.measurableSet_generateFrom", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [379, 9], "def_end_pos": [379, 35]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case refine_1.intro.succ.intro.intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\nih : \u2200 u \u2208 memPartition t n, MeasurableSet u\nv : Set \u03b1\nhv : v \u2208 memPartition t n\n\u22a2 MeasurableSet (v \u2229 t n)", "state_after": "no goals"}, {"tactic": "exact (ih v hv).diff (measurableSet_generateFrom \u27e8n, rfl\u27e9)", "annotated_tactic": ["exact (ih v hv).<a>diff</a> (<a>measurableSet_generateFrom</a> \u27e8n, <a>rfl</a>\u27e9)", [{"full_name": "MeasurableSet.diff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [206, 19], "def_end_pos": [206, 37]}, {"full_name": "MeasurableSpace.measurableSet_generateFrom", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [379, 9], "def_end_pos": [379, 35]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case refine_1.intro.succ.intro.intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\nih : \u2200 u \u2208 memPartition t n, MeasurableSet u\nv : Set \u03b1\nhv : v \u2208 memPartition t n\n\u22a2 MeasurableSet (v \\ t n)", "state_after": "no goals"}, {"tactic": "simp only [iUnion_singleton_eq_range, mem_range] at hu", "annotated_tactic": ["simp only [<a>iUnion_singleton_eq_range</a>, <a>mem_range</a>] at hu", [{"full_name": "Set.iUnion_singleton_eq_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1305, 9], "def_end_pos": [1305, 34]}, {"full_name": "Set.mem_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [160, 17], "def_end_pos": [160, 26]}]], "state_before": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhu : u \u2208 range t\n\u22a2 MeasurableSet u", "state_after": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhu : \u2203 y, t y = u\n\u22a2 MeasurableSet u"}, {"tactic": "obtain \u27e8n, rfl\u27e9 := hu", "annotated_tactic": ["obtain \u27e8n, rfl\u27e9 := hu", []], "state_before": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nu : Set \u03b1\nhu : \u2203 y, t y = u\n\u22a2 MeasurableSet u", "state_after": "case refine_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\n\u22a2 MeasurableSet (t n)"}, {"tactic": "exact generateFrom_mono (subset_iUnion _ _) _ (measurableSet_generateFrom_memPartition t n)", "annotated_tactic": ["exact <a>generateFrom_mono</a> (<a>subset_iUnion</a> _ _) _ (<a>measurableSet_generateFrom_memPartition</a> t n)", [{"full_name": "MeasurableSpace.generateFrom_mono", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [447, 9], "def_end_pos": [447, 26]}, {"full_name": "Set.subset_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [281, 9], "def_end_pos": [281, 22]}, {"full_name": "MeasurableSpace.measurableSet_generateFrom_memPartition", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean", "def_pos": [125, 7], "def_end_pos": [125, 46]}]], "state_before": "case refine_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u2115 \u2192 Set \u03b1\nn : \u2115\n\u22a2 MeasurableSet (t n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.preimage_div_const_uIcc", "start": [788, 1], "end": [790, 80], "traced_tactics": [{"tactic": "simp only [div_eq_mul_inv, preimage_mul_const_uIcc (inv_ne_zero ha), inv_inv]", "annotated_tactic": ["simp only [<a>div_eq_mul_inv</a>, <a>preimage_mul_const_uIcc</a> (<a>inv_ne_zero</a> ha), <a>inv_inv</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "Set.preimage_mul_const_uIcc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Interval.lean", "def_pos": [773, 9], "def_end_pos": [773, 32]}, {"full_name": "inv_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NeZero.lean", "def_pos": [47, 9], "def_end_pos": [47, 20]}, {"full_name": "inv_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 16]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\na : \u03b1\nha : a \u2260 0\nb c : \u03b1\n\u22a2 (fun x => x / a) \u207b\u00b9' [[b, c]] = [[b * a, c * a]]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "full_name": "NonUnitalSubsemiring.toSubsemigroup_mono", "start": [153, 1], "end": [154, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/ConstMulAction.lean", "full_name": "IsOpen.smul", "start": [253, 1], "end": [254, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/IsAlgClosed/Basic.lean", "full_name": "Algebra.IsAlgebraic.range_eval_eq_rootSet_minpoly", "start": [437, 1], "end": [439, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "TopologicalSpace.nhds_mkOfNhds", "start": [123, 1], "end": [126, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "mul_div_mul_comm", "start": [662, 1], "end": [662, 72], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivisionCommMonoid \u03b1\na b c d : \u03b1\n\u22a2 a * b / (c * d) = a / c * (b / d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.eval\u2082_id", "start": [1210, 1], "end": [1211, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/MinMax.lean", "full_name": "min_lt_max", "start": [220, 1], "end": [221, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/Basic.lean", "full_name": "PreconnectedSpace.connectedComponent_eq_univ", "start": [819, 1], "end": [821, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "mul_add_mul_lt_mul_add_mul", "start": [752, 1], "end": [757, 90], "traced_tactics": [{"tactic": "obtain \u27e8b, rfl\u27e9 := exists_add_of_le hab.le", "annotated_tactic": ["obtain \u27e8b, rfl\u27e9 := <a>exists_add_of_le</a> hab.le", [{"full_name": "ExistsAddOfLE.exists_add_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [34, 3], "def_end_pos": [34, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na b c d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nhab : a < b\nhcd : c < d\n\u22a2 a * d + b * c < a * c + b * d", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na c d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nhcd : c < d\nb : \u03b1\nhab : a < a + b\n\u22a2 a * d + (a + b) * c < a * c + (a + b) * d"}, {"tactic": "obtain \u27e8d, rfl\u27e9 := exists_add_of_le hcd.le", "annotated_tactic": ["obtain \u27e8d, rfl\u27e9 := <a>exists_add_of_le</a> hcd.le", [{"full_name": "ExistsAddOfLE.exists_add_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [34, 3], "def_end_pos": [34, 19]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na c d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nhcd : c < d\nb : \u03b1\nhab : a < a + b\n\u22a2 a * d + (a + b) * c < a * c + (a + b) * d", "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na c : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nb : \u03b1\nhab : a < a + b\nd : \u03b1\nhcd : c < c + d\n\u22a2 a * (c + d) + (a + b) * c < a * c + (a + b) * (c + d)"}, {"tactic": "rw [mul_add, add_right_comm, mul_add, \u2190 add_assoc]", "annotated_tactic": ["rw [<a>mul_add</a>, <a>add_right_comm</a>, <a>mul_add</a>, \u2190 <a>add_assoc</a>]", [{"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "add_right_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [161, 3], "def_end_pos": [161, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}]], "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na c : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nb : \u03b1\nhab : a < a + b\nd : \u03b1\nhcd : c < c + d\n\u22a2 a * (c + d) + (a + b) * c < a * c + (a + b) * (c + d)", "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na c : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nb : \u03b1\nhab : a < a + b\nd : \u03b1\nhcd : c < c + d\n\u22a2 a * c + (a + b) * c + a * d < a * c + (a + b) * c + (a + b) * d"}, {"tactic": "exact add_lt_add_left (mul_lt_mul_of_pos_right hab <| (lt_add_iff_pos_right _).1 hcd) _", "annotated_tactic": ["exact <a>add_lt_add_left</a> (<a>mul_lt_mul_of_pos_right</a> hab <| (<a>lt_add_iff_pos_right</a> _).1 hcd) _", [{"full_name": "add_lt_add_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [120, 32], "def_end_pos": [120, 47]}, {"full_name": "mul_lt_mul_of_pos_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [220, 9], "def_end_pos": [220, 32]}, {"full_name": "lt_add_iff_pos_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [563, 30], "def_end_pos": [563, 50]}]], "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na c : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nb : \u03b1\nhab : a < a + b\nd : \u03b1\nhcd : c < c + d\n\u22a2 a * c + (a + b) * c + a * d < a * c + (a + b) * c + (a + b) * d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/NhdsSet.lean", "full_name": "IsOpen.mem_nhdsSet", "start": [90, 1], "end": [91, 57], "traced_tactics": [{"tactic": "rw [\u2190 subset_interior_iff_mem_nhdsSet, hU.interior_eq]", "annotated_tactic": ["rw [\u2190 <a>subset_interior_iff_mem_nhdsSet</a>, hU.interior_eq]", [{"full_name": "subset_interior_iff_mem_nhdsSet", "def_path": ".lake/packages/mathlib/Mathlib/Topology/NhdsSet.lean", "def_pos": [52, 9], "def_end_pos": [52, 40]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : Filter X\ns t s\u2081 s\u2082 t\u2081 t\u2082 : Set X\nx : X\nhU : IsOpen s\n\u22a2 s \u2208 \ud835\udcdd\u02e2 t \u2194 t \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "full_name": "Matrix.mul_nonsing_inv_cancel_left", "start": [285, 1], "end": [286, 49], "traced_tactics": [{"tactic": "simp [\u2190 Matrix.mul_assoc, mul_nonsing_inv A h]", "annotated_tactic": ["simp [\u2190 <a>Matrix.mul_assoc</a>, <a>mul_nonsing_inv</a> A h]", [{"full_name": "Matrix.mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1185, 19], "def_end_pos": [1185, 28]}, {"full_name": "Matrix.mul_nonsing_inv", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "def_pos": [258, 9], "def_end_pos": [258, 24]}]], "state_before": "l : Type u_1\nm : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA B\u271d : Matrix n n \u03b1\nB : Matrix n m \u03b1\nh : IsUnit (det A)\n\u22a2 A * (A\u207b\u00b9 * B) = B", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Basic.lean", "full_name": "LinearMap.map_neg", "start": [607, 11], "end": [608, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "AffineSubspace.not_mem_bot", "start": [835, 1], "end": [836, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Perm.lean", "full_name": "List.Perm.pairwise", "start": [679, 1], "end": [680, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Centralizer.lean", "full_name": "Submonoid.centralizer_le", "start": [80, 1], "end": [81, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "Disjoint.frontier_left", "start": [761, 1], "end": [763, 101], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Units.lean", "full_name": "Units.map_neg_one", "start": [97, 11], "end": [99, 37], "traced_tactics": [{"tactic": "simp only [Units.map_neg, map_one]", "annotated_tactic": ["simp only [<a>Units.map_neg</a>, <a>map_one</a>]", [{"full_name": "Units.map_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Units.lean", "def_pos": [93, 19], "def_end_pos": [93, 26]}, {"full_name": "map_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [203, 9], "def_end_pos": [203, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nR : Type x\ninst\u271d\u00b3 : Ring \u03b1\na b : \u03b1\nF : Type u_1\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : RingHomClass F \u03b1 \u03b2\nf : F\n\u22a2 (map \u2191f) (-1) = -1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Pi.lean", "full_name": "Pi.smul_apply'", "start": [45, 1], "end": [47, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.mem_roots_iff_aeval_eq_zero", "start": [741, 1], "end": [743, 7], "traced_tactics": [{"tactic": "rw [mem_roots w, IsRoot.def, aeval_def, eval\u2082_eq_eval_map]", "annotated_tactic": ["rw [<a>mem_roots</a> w, <a>IsRoot.def</a>, <a>aeval_def</a>, <a>eval\u2082_eq_eval_map</a>]", [{"full_name": "Polynomial.mem_roots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [728, 9], "def_end_pos": [728, 18]}, {"full_name": "Polynomial.IsRoot.def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [502, 9], "def_end_pos": [502, 19]}, {"full_name": "Polynomial.aeval_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/AlgebraMap.lean", "def_pos": [192, 9], "def_end_pos": [192, 18]}, {"full_name": "Polynomial.eval\u2082_eq_eval_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [845, 9], "def_end_pos": [845, 26]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nx : R\nw : p \u2260 0\n\u22a2 x \u2208 roots p \u2194 (aeval x) p = 0", "state_after": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nx : R\nw : p \u2260 0\n\u22a2 eval x p = 0 \u2194 eval x (map (algebraMap R R) p) = 0"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nx : R\nw : p \u2260 0\n\u22a2 eval x p = 0 \u2194 eval x (map (algebraMap R R) p) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Notation.lean", "full_name": "Matrix.natCast_fin_two", "start": [443, 1], "end": [445, 38], "traced_tactics": [{"tactic": "ext i j", "annotated_tactic": ["ext i j", []], "state_before": "\u03b1 : Type u\no n\u271d m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d : AddMonoidWithOne \u03b1\nn : \u2115\n\u22a2 \u2191n = of ![![\u2191n, 0], ![0, \u2191n]]", "state_after": "case a.h\n\u03b1 : Type u\no n\u271d m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d : AddMonoidWithOne \u03b1\nn : \u2115\ni j : Fin 2\n\u22a2 \u2191n i j = of ![![\u2191n, 0], ![0, \u2191n]] i j"}, {"tactic": "fin_cases i <;> fin_cases j <;> rfl", "annotated_tactic": ["fin_cases i <;> fin_cases j <;> rfl", []], "state_before": "case a.h\n\u03b1 : Type u\no n\u271d m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d : AddMonoidWithOne \u03b1\nn : \u2115\ni j : Fin 2\n\u22a2 \u2191n i j = of ![![\u2191n, 0], ![0, \u2191n]] i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "Set.antitone_mem", "start": [322, 1], "end": [323, 14], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Test.lean", "full_name": "amc12a_2020_p9", "start": [883, 1], "end": [886, 25], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "S : Finset \u211d\nh\u2080 : \u2200 (x : \u211d), x \u2208 S \u2194 0 \u2264 x \u2227 x \u2264 2 * \u03c0 \u2227 tan (2 * x) = cos (x / 2)\n\u22a2 S.card = 5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Hom.lean", "full_name": "Algebra.smul_units_def", "start": [579, 1], "end": [580, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "full_name": "CategoryTheory.Limits.IsInitial.hom_ext", "start": [167, 1], "end": [168, 37], "traced_tactics": [{"tactic": "aesop_cat", "annotated_tactic": ["aesop_cat", []], "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y : C\nt : IsInitial X\nf g : X \u27f6 Y\n\u22a2 \u2200 (j : Discrete PEmpty.{1}), (asEmptyCocone X).\u03b9.app j \u226b f = (asEmptyCocone X).\u03b9.app j \u226b g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "top_unique", "start": [129, 1], "end": [130, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "full_name": "Equiv.Perm.mem_list_cycles_iff", "start": [368, 1], "end": [393, 44], "traced_tactics": [{"tactic": "suffices \u03c3.IsCycle \u2192 (\u03c3 \u2208 l \u2194 \u2200 a, \u03c3 a \u2260 a \u2192 \u03c3 a = l.prod a) by\n  exact \u27e8fun h\u03c3 => \u27e8h1 \u03c3 h\u03c3, (this (h1 \u03c3 h\u03c3)).mp h\u03c3\u27e9, fun h\u03c3 => (this h\u03c3.1).mpr h\u03c3.2\u27e9", "annotated_tactic": ["suffices \u03c3.IsCycle \u2192 (\u03c3 \u2208 l \u2194 \u2200 a, \u03c3 a \u2260 a \u2192 \u03c3 a = l.prod a) by\n    exact \u27e8fun h\u03c3 => \u27e8h1 \u03c3 h\u03c3, (this (h1 \u03c3 h\u03c3)).<a>mp</a> h\u03c3\u27e9, fun h\u03c3 => (this h\u03c3.1).<a>mpr</a> h\u03c3.2\u27e9", [{"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}]], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\n\u22a2 \u03c3 \u2208 l \u2194 IsCycle \u03c3 \u2227 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a", "state_after": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\n\u22a2 IsCycle \u03c3 \u2192 (\u03c3 \u2208 l \u2194 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a)"}, {"tactic": "intro h3", "annotated_tactic": ["intro h3", []], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\n\u22a2 IsCycle \u03c3 \u2192 (\u03c3 \u2208 l \u2194 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a)", "state_after": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\n\u22a2 \u03c3 \u2208 l \u2194 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a"}, {"tactic": "exact \u27e8fun h\u03c3 => \u27e8h1 \u03c3 h\u03c3, (this (h1 \u03c3 h\u03c3)).mp h\u03c3\u27e9, fun h\u03c3 => (this h\u03c3.1).mpr h\u03c3.2\u27e9", "annotated_tactic": ["exact \u27e8fun h\u03c3 => \u27e8h1 \u03c3 h\u03c3, (this (h1 \u03c3 h\u03c3)).<a>mp</a> h\u03c3\u27e9, fun h\u03c3 => (this h\u03c3.1).<a>mpr</a> h\u03c3.2\u27e9", [{"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}]], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nthis : IsCycle \u03c3 \u2192 (\u03c3 \u2208 l \u2194 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a)\n\u22a2 \u03c3 \u2208 l \u2194 IsCycle \u03c3 \u2227 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a", "state_after": "no goals"}, {"tactic": "cases nonempty_fintype \u03b1", "annotated_tactic": ["cases <a>nonempty_fintype</a> \u03b1", [{"full_name": "nonempty_fintype", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [442, 9], "def_end_pos": [442, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\n\u22a2 \u03c3 \u2208 l \u2194 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a", "state_after": "case intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\n\u22a2 \u03c3 \u2208 l \u2194 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\n\u22a2 \u03c3 \u2208 l \u2194 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a", "state_after": "case intro.mp\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\n\u22a2 \u03c3 \u2208 l \u2192 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\n\ncase intro.mpr\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\n\u22a2 (\u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a) \u2192 \u03c3 \u2208 l"}, {"tactic": "intro h a ha", "annotated_tactic": ["intro h a ha", []], "state_before": "case intro.mp\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\n\u22a2 \u03c3 \u2208 l \u2192 \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a", "state_after": "case intro.mp\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u03c3 \u2208 l\na : \u03b1\nha : \u03c3 a \u2260 a\n\u22a2 \u03c3 a = (List.prod l) a"}, {"tactic": "exact eq_on_support_mem_disjoint h h2 _ (mem_support.mpr ha)", "annotated_tactic": ["exact <a>eq_on_support_mem_disjoint</a> h h2 _ (mem_support.mpr ha)", [{"full_name": "Equiv.Perm.eq_on_support_mem_disjoint", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [517, 9], "def_end_pos": [517, 35]}]], "state_before": "case intro.mp\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u03c3 \u2208 l\na : \u03b1\nha : \u03c3 a \u2260 a\n\u22a2 \u03c3 a = (List.prod l) a", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case intro.mpr\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\n\u22a2 (\u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a) \u2192 \u03c3 \u2208 l", "state_after": "case intro.mpr\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\n\u22a2 \u03c3 \u2208 l"}, {"tactic": "have h\u03c3l : \u03c3.support \u2286 l.prod.support := by\n  intro x hx\n  rw [mem_support] at hx\n  rwa [mem_support, \u2190 h _ hx]", "annotated_tactic": ["have h\u03c3l : \u03c3.support \u2286 l.prod.support := by\n        intro x hx\n        rw [<a>mem_support</a>] at hx\n        rwa [<a>mem_support</a>, \u2190 h _ hx]", [{"full_name": "Equiv.Perm.mem_support", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [297, 9], "def_end_pos": [297, 20]}, {"full_name": "Equiv.Perm.mem_support", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [297, 9], "def_end_pos": [297, 20]}]], "state_before": "case intro.mpr\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\n\u22a2 \u03c3 \u2208 l", "state_after": "case intro.mpr\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\n\u22a2 \u03c3 \u2208 l"}, {"tactic": "obtain \u27e8a, ha, -\u27e9 := id h3", "annotated_tactic": ["obtain \u27e8a, ha, -\u27e9 := <a>id</a> h3", [{"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "case intro.mpr\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\n\u22a2 \u03c3 \u2208 l", "state_after": "case intro.mpr.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : \u03c3 a \u2260 a\n\u22a2 \u03c3 \u2208 l"}, {"tactic": "rw [\u2190 mem_support] at ha", "annotated_tactic": ["rw [\u2190 <a>mem_support</a>] at ha", [{"full_name": "Equiv.Perm.mem_support", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [297, 9], "def_end_pos": [297, 20]}]], "state_before": "case intro.mpr.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : \u03c3 a \u2260 a\n\u22a2 \u03c3 \u2208 l", "state_after": "case intro.mpr.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u22a2 \u03c3 \u2208 l"}, {"tactic": "obtain \u27e8\u03c4, h\u03c4, h\u03c4a\u27e9 := exists_mem_support_of_mem_support_prod (h\u03c3l ha)", "annotated_tactic": ["obtain \u27e8\u03c4, h\u03c4, h\u03c4a\u27e9 := <a>exists_mem_support_of_mem_support_prod</a> (h\u03c3l ha)", [{"full_name": "Equiv.Perm.exists_mem_support_of_mem_support_prod", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [339, 9], "def_end_pos": [339, 47]}]], "state_before": "case intro.mpr.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u22a2 \u03c3 \u2208 l", "state_after": "case intro.mpr.intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\n\u22a2 \u03c3 \u2208 l"}, {"tactic": "have h\u03c4l : \u2200 x \u2208 \u03c4.support, \u03c4 x = l.prod x := eq_on_support_mem_disjoint h\u03c4 h2", "annotated_tactic": ["have h\u03c4l : \u2200 x \u2208 \u03c4.support, \u03c4 x = l.prod x := <a>eq_on_support_mem_disjoint</a> h\u03c4 h2", [{"full_name": "Equiv.Perm.eq_on_support_mem_disjoint", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [517, 9], "def_end_pos": [517, 35]}]], "state_before": "case intro.mpr.intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\n\u22a2 \u03c3 \u2208 l", "state_after": "case intro.mpr.intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\n\u22a2 \u03c3 \u2208 l"}, {"tactic": "have key : \u2200 x \u2208 \u03c3.support \u2229 \u03c4.support, \u03c3 x = \u03c4 x := by\n  intro x hx\n  rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), h\u03c4l x (mem_of_mem_inter_right hx)]", "annotated_tactic": ["have key : \u2200 x \u2208 \u03c3.support \u2229 \u03c4.support, \u03c3 x = \u03c4 x := by\n        intro x hx\n        rw [h x (mem_support.mp (<a>mem_of_mem_inter_left</a> hx)), h\u03c4l x (<a>mem_of_mem_inter_right</a> hx)]", [{"full_name": "Finset.mem_of_mem_inter_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1642, 9], "def_end_pos": [1642, 30]}, {"full_name": "Finset.mem_of_mem_inter_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1646, 9], "def_end_pos": [1646, 31]}]], "state_before": "case intro.mpr.intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\n\u22a2 \u03c3 \u2208 l", "state_after": "case intro.mpr.intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\nkey : \u2200 x \u2208 support \u03c3 \u2229 support \u03c4, \u03c3 x = \u03c4 x\n\u22a2 \u03c3 \u2208 l"}, {"tactic": "convert h\u03c4", "annotated_tactic": ["convert h\u03c4", []], "state_before": "case intro.mpr.intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\nkey : \u2200 x \u2208 support \u03c3 \u2229 support \u03c4, \u03c3 x = \u03c4 x\n\u22a2 \u03c3 \u2208 l", "state_after": "case h.e'_4\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\nkey : \u2200 x \u2208 support \u03c3 \u2229 support \u03c4, \u03c3 x = \u03c4 x\n\u22a2 \u03c3 = \u03c4"}, {"tactic": "refine' h3.eq_on_support_inter_nonempty_congr (h1 _ h\u03c4) key _ ha", "annotated_tactic": ["refine' h3.eq_on_support_inter_nonempty_congr (h1 _ h\u03c4) key _ ha", []], "state_before": "case h.e'_4\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\nkey : \u2200 x \u2208 support \u03c3 \u2229 support \u03c4, \u03c3 x = \u03c4 x\n\u22a2 \u03c3 = \u03c4", "state_after": "case h.e'_4\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\nkey : \u2200 x \u2208 support \u03c3 \u2229 support \u03c4, \u03c3 x = \u03c4 x\n\u22a2 \u03c3 a = \u03c4 a"}, {"tactic": "exact key a (mem_inter_of_mem ha h\u03c4a)", "annotated_tactic": ["exact key a (<a>mem_inter_of_mem</a> ha h\u03c4a)", [{"full_name": "Finset.mem_inter_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1650, 9], "def_end_pos": [1650, 25]}]], "state_before": "case h.e'_4\n\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\nkey : \u2200 x \u2208 support \u03c3 \u2229 support \u03c4, \u03c3 x = \u03c4 x\n\u22a2 \u03c3 a = \u03c4 a", "state_after": "no goals"}, {"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\n\u22a2 support \u03c3 \u2286 support (List.prod l)", "state_after": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nx : \u03b1\nhx : x \u2208 support \u03c3\n\u22a2 x \u2208 support (List.prod l)"}, {"tactic": "rw [mem_support] at hx", "annotated_tactic": ["rw [<a>mem_support</a>] at hx", [{"full_name": "Equiv.Perm.mem_support", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [297, 9], "def_end_pos": [297, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nx : \u03b1\nhx : x \u2208 support \u03c3\n\u22a2 x \u2208 support (List.prod l)", "state_after": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nx : \u03b1\nhx : \u03c3 x \u2260 x\n\u22a2 x \u2208 support (List.prod l)"}, {"tactic": "rwa [mem_support, \u2190 h _ hx]", "annotated_tactic": ["rwa [<a>mem_support</a>, \u2190 h _ hx]", [{"full_name": "Equiv.Perm.mem_support", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [297, 9], "def_end_pos": [297, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nx : \u03b1\nhx : \u03c3 x \u2260 x\n\u22a2 x \u2208 support (List.prod l)", "state_after": "no goals"}, {"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\n\u22a2 \u2200 x \u2208 support \u03c3 \u2229 support \u03c4, \u03c3 x = \u03c4 x", "state_after": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\nx : \u03b1\nhx : x \u2208 support \u03c3 \u2229 support \u03c4\n\u22a2 \u03c3 x = \u03c4 x"}, {"tactic": "rw [h x (mem_support.mp (mem_of_mem_inter_left hx)), h\u03c4l x (mem_of_mem_inter_right hx)]", "annotated_tactic": ["rw [h x (mem_support.mp (<a>mem_of_mem_inter_left</a> hx)), h\u03c4l x (<a>mem_of_mem_inter_right</a> hx)]", [{"full_name": "Finset.mem_of_mem_inter_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1642, 9], "def_end_pos": [1642, 30]}, {"full_name": "Finset.mem_of_mem_inter_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1646, 9], "def_end_pos": [1646, 31]}]], "state_before": "\u03b9 : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b1 : Type u_4\ninst\u271d : Finite \u03b1\nl : List (Perm \u03b1)\nh1 : \u2200 \u03c3 \u2208 l, IsCycle \u03c3\nh2 : List.Pairwise Disjoint l\n\u03c3 : Perm \u03b1\nh3 : IsCycle \u03c3\nval\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), \u03c3 a \u2260 a \u2192 \u03c3 a = (List.prod l) a\nh\u03c3l : support \u03c3 \u2286 support (List.prod l)\na : \u03b1\nha : a \u2208 support \u03c3\n\u03c4 : Perm \u03b1\nh\u03c4 : \u03c4 \u2208 l\nh\u03c4a : a \u2208 support \u03c4\nh\u03c4l : \u2200 x \u2208 support \u03c4, \u03c4 x = (List.prod l) x\nx : \u03b1\nhx : x \u2208 support \u03c3 \u2229 support \u03c4\n\u22a2 \u03c3 x = \u03c4 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousOn.lean", "full_name": "nhdsWithin_compl_singleton_sup_pure", "start": [300, 1], "end": [301, 85], "traced_tactics": [{"tactic": "rw [\u2190 nhdsWithin_singleton, \u2190 nhdsWithin_union, compl_union_self, nhdsWithin_univ]", "annotated_tactic": ["rw [\u2190 <a>nhdsWithin_singleton</a>, \u2190 <a>nhdsWithin_union</a>, <a>compl_union_self</a>, <a>nhdsWithin_univ</a>]", [{"full_name": "nhdsWithin_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [277, 9], "def_end_pos": [277, 29]}, {"full_name": "nhdsWithin_union", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [236, 9], "def_end_pos": [236, 25]}, {"full_name": "Set.compl_union_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1725, 9], "def_end_pos": [1725, 25]}, {"full_name": "nhdsWithin_univ", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [76, 9], "def_end_pos": [76, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\n\u22a2 \ud835\udcdd[\u2260] a \u2294 pure a = \ud835\udcdd a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.Iio_succ_of_not_isMax", "start": [305, 1], "end": [306, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.seq", "start": [993, 1], "end": [995, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "Submodule.toAffineSubspace_direction", "start": [521, 1], "end": [522, 77], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "k : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\ns : Submodule k V\n\u22a2 AffineSubspace.direction (toAffineSubspace s) = s", "state_after": "case h\nk : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\ns : Submodule k V\nx : V\n\u22a2 x \u2208 AffineSubspace.direction (toAffineSubspace s) \u2194 x \u2208 s"}, {"tactic": "simp [\u2190 s.toAffineSubspace.vadd_mem_iff_mem_direction _ s.zero_mem]", "annotated_tactic": ["simp [\u2190 s.toAffineSubspace.vadd_mem_iff_mem_direction _ s.zero_mem]", []], "state_before": "case h\nk : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\ns : Submodule k V\nx : V\n\u22a2 x \u2208 AffineSubspace.direction (toAffineSubspace s) \u2194 x \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "monotone_or", "start": [513, 1], "end": [515, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Functor.lean", "full_name": "Functor.mapEquiv_apply", "start": [46, 1], "end": [47, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Derivative.lean", "full_name": "Polynomial.eval_multiset_prod_X_sub_C_derivative", "start": [657, 1], "end": [663, 19], "traced_tactics": [{"tactic": "nth_rw 1 [\u2190 Multiset.cons_erase hr]", "annotated_tactic": ["nth_rw 1 [\u2190 <a>Multiset.cons_erase</a> hr]", [{"full_name": "Multiset.cons_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1071, 9], "def_end_pos": [1071, 19]}]], "state_before": "R : Type u\nS\u271d : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : DecidableEq R\nS : Multiset R\nr : R\nhr : r \u2208 S\n\u22a2 eval r (derivative (Multiset.prod (Multiset.map (fun a => X - C a) S))) =\n    Multiset.prod (Multiset.map (fun a => r - a) (Multiset.erase S r))", "state_after": "R : Type u\nS\u271d : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : DecidableEq R\nS : Multiset R\nr : R\nhr : r \u2208 S\n\u22a2 eval r (derivative (Multiset.prod (Multiset.map (fun a => X - C a) (r ::\u2098 Multiset.erase S r)))) =\n    Multiset.prod (Multiset.map (fun a => r - a) (Multiset.erase S r))"}, {"tactic": "have := (evalRingHom r).map_multiset_prod (Multiset.map (fun a => X - C a) (S.erase r))", "annotated_tactic": ["have := (<a>evalRingHom</a> r).<a>map_multiset_prod</a> (<a>Multiset.map</a> (fun a => <a>X</a> - <a>C</a> a) (S.erase r))", [{"full_name": "Polynomial.evalRingHom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [1110, 5], "def_end_pos": [1110, 16]}, {"full_name": "RingHom.map_multiset_prod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [242, 19], "def_end_pos": [242, 44]}, {"full_name": "Multiset.map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1185, 5], "def_end_pos": [1185, 8]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}]], "state_before": "R : Type u\nS\u271d : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : DecidableEq R\nS : Multiset R\nr : R\nhr : r \u2208 S\n\u22a2 eval r (derivative (Multiset.prod (Multiset.map (fun a => X - C a) (r ::\u2098 Multiset.erase S r)))) =\n    Multiset.prod (Multiset.map (fun a => r - a) (Multiset.erase S r))", "state_after": "R : Type u\nS\u271d : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : DecidableEq R\nS : Multiset R\nr : R\nhr : r \u2208 S\nthis :\n  (evalRingHom r) (Multiset.prod (Multiset.map (fun a => X - C a) (Multiset.erase S r))) =\n    Multiset.prod (Multiset.map (\u21d1(evalRingHom r)) (Multiset.map (fun a => X - C a) (Multiset.erase S r)))\n\u22a2 eval r (derivative (Multiset.prod (Multiset.map (fun a => X - C a) (r ::\u2098 Multiset.erase S r)))) =\n    Multiset.prod (Multiset.map (fun a => r - a) (Multiset.erase S r))"}, {"tactic": "simpa using this", "annotated_tactic": ["simpa using this", []], "state_before": "R : Type u\nS\u271d : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : DecidableEq R\nS : Multiset R\nr : R\nhr : r \u2208 S\nthis :\n  (evalRingHom r) (Multiset.prod (Multiset.map (fun a => X - C a) (Multiset.erase S r))) =\n    Multiset.prod (Multiset.map (\u21d1(evalRingHom r)) (Multiset.map (fun a => X - C a) (Multiset.erase S r)))\n\u22a2 eval r (derivative (Multiset.prod (Multiset.map (fun a => X - C a) (r ::\u2098 Multiset.erase S r)))) =\n    Multiset.prod (Multiset.map (fun a => r - a) (Multiset.erase S r))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/SigmaCompact.lean", "full_name": "LocallyFinite.countable_univ", "start": [273, 11], "end": [279, 36], "traced_tactics": [{"tactic": "have := fun n => hf.finite_nonempty_inter_compact (isCompact_compactCovering X n)", "annotated_tactic": ["have := fun n => hf.finite_nonempty_inter_compact (<a>isCompact_compactCovering</a> X n)", [{"full_name": "isCompact_compactCovering", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/SigmaCompact.lean", "def_pos": [201, 9], "def_end_pos": [201, 34]}]], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns t : Set X\ninst\u271d : SigmaCompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), Set.Nonempty (f i)\n\u22a2 Set.Countable univ", "state_after": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns t : Set X\ninst\u271d : SigmaCompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), Set.Nonempty (f i)\nthis : \u2200 (n : \u2115), Set.Finite {i | Set.Nonempty (f i \u2229 compactCovering X n)}\n\u22a2 Set.Countable univ"}, {"tactic": "refine (countable_iUnion fun n => (this n).countable).mono fun i _ => ?_", "annotated_tactic": ["refine (<a>countable_iUnion</a> fun n => (this n).<a>countable</a>).<a>mono</a> fun i _ => ?_", [{"full_name": "Set.countable_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [222, 9], "def_end_pos": [222, 25]}, {"full_name": "Set.Finite.countable", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [272, 9], "def_end_pos": [272, 25]}, {"full_name": "Set.Countable.mono", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [121, 9], "def_end_pos": [121, 23]}]], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns t : Set X\ninst\u271d : SigmaCompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), Set.Nonempty (f i)\nthis : \u2200 (n : \u2115), Set.Finite {i | Set.Nonempty (f i \u2229 compactCovering X n)}\n\u22a2 Set.Countable univ", "state_after": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns t : Set X\ninst\u271d : SigmaCompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), Set.Nonempty (f i)\nthis : \u2200 (n : \u2115), Set.Finite {i | Set.Nonempty (f i \u2229 compactCovering X n)}\ni : \u03b9\nx\u271d : i \u2208 univ\n\u22a2 i \u2208 \u22c3 i, {i_1 | Set.Nonempty (f i_1 \u2229 compactCovering X i)}"}, {"tactic": "rcases hne i with \u27e8x, hx\u27e9", "annotated_tactic": ["rcases hne i with \u27e8x, hx\u27e9", []], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns t : Set X\ninst\u271d : SigmaCompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), Set.Nonempty (f i)\nthis : \u2200 (n : \u2115), Set.Finite {i | Set.Nonempty (f i \u2229 compactCovering X n)}\ni : \u03b9\nx\u271d : i \u2208 univ\n\u22a2 i \u2208 \u22c3 i, {i_1 | Set.Nonempty (f i_1 \u2229 compactCovering X i)}", "state_after": "case intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns t : Set X\ninst\u271d : SigmaCompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), Set.Nonempty (f i)\nthis : \u2200 (n : \u2115), Set.Finite {i | Set.Nonempty (f i \u2229 compactCovering X n)}\ni : \u03b9\nx\u271d : i \u2208 univ\nx : X\nhx : x \u2208 f i\n\u22a2 i \u2208 \u22c3 i, {i_1 | Set.Nonempty (f i_1 \u2229 compactCovering X i)}"}, {"tactic": "rcases iUnion_eq_univ_iff.1 (iUnion_compactCovering X) x with \u27e8n, hn\u27e9", "annotated_tactic": ["rcases <a>iUnion_eq_univ_iff</a>.1 (<a>iUnion_compactCovering</a> X) x with \u27e8n, hn\u27e9", [{"full_name": "Set.iUnion_eq_univ_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1190, 9], "def_end_pos": [1190, 27]}, {"full_name": "iUnion_compactCovering", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/SigmaCompact.lean", "def_pos": [205, 9], "def_end_pos": [205, 31]}]], "state_before": "case intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns t : Set X\ninst\u271d : SigmaCompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), Set.Nonempty (f i)\nthis : \u2200 (n : \u2115), Set.Finite {i | Set.Nonempty (f i \u2229 compactCovering X n)}\ni : \u03b9\nx\u271d : i \u2208 univ\nx : X\nhx : x \u2208 f i\n\u22a2 i \u2208 \u22c3 i, {i_1 | Set.Nonempty (f i_1 \u2229 compactCovering X i)}", "state_after": "case intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns t : Set X\ninst\u271d : SigmaCompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), Set.Nonempty (f i)\nthis : \u2200 (n : \u2115), Set.Finite {i | Set.Nonempty (f i \u2229 compactCovering X n)}\ni : \u03b9\nx\u271d : i \u2208 univ\nx : X\nhx : x \u2208 f i\nn : \u2115\nhn : x \u2208 compactCovering X n\n\u22a2 i \u2208 \u22c3 i, {i_1 | Set.Nonempty (f i_1 \u2229 compactCovering X i)}"}, {"tactic": "exact mem_iUnion.2 \u27e8n, x, hx, hn\u27e9", "annotated_tactic": ["exact <a>mem_iUnion</a>.2 \u27e8n, x, hx, hn\u27e9", [{"full_name": "Set.mem_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [272, 9], "def_end_pos": [272, 19]}]], "state_before": "case intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns t : Set X\ninst\u271d : SigmaCompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), Set.Nonempty (f i)\nthis : \u2200 (n : \u2115), Set.Finite {i | Set.Nonempty (f i \u2229 compactCovering X n)}\ni : \u03b9\nx\u271d : i \u2208 univ\nx : X\nhx : x \u2208 f i\nn : \u2115\nhn : x \u2208 compactCovering X n\n\u22a2 i \u2208 \u22c3 i, {i_1 | Set.Nonempty (f i_1 \u2229 compactCovering X i)}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/EReal.lean", "full_name": "EReal.mul_comm", "start": [222, 11], "end": [225, 38], "traced_tactics": [{"tactic": "induction' x using EReal.rec with x <;> induction' y using EReal.rec with y <;>\n  try { rfl }", "annotated_tactic": ["induction' x using <a>EReal.rec</a> with x <;> induction' y using <a>EReal.rec</a> with y <;>\n    try { rfl }", [{"full_name": "EReal.rec", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/EReal.lean", "def_pos": [147, 15], "def_end_pos": [147, 18]}, {"full_name": "EReal.rec", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/EReal.lean", "def_pos": [147, 15], "def_end_pos": [147, 18]}]], "state_before": "x y : EReal\n\u22a2 x * y = y * x", "state_after": "case h_real.h_real\nx y : \u211d\n\u22a2 \u2191x * \u2191y = \u2191y * \u2191x"}, {"tactic": "rw [\u2190 coe_mul, \u2190 coe_mul, mul_comm]", "annotated_tactic": ["rw [\u2190 <a>coe_mul</a>, \u2190 <a>coe_mul</a>, <a>mul_comm</a>]", [{"full_name": "EReal.coe_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/EReal.lean", "def_pos": [171, 9], "def_end_pos": [171, 16]}, {"full_name": "EReal.coe_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/EReal.lean", "def_pos": [171, 9], "def_end_pos": [171, 16]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "case h_real.h_real\nx y : \u211d\n\u22a2 \u2191x * \u2191y = \u2191y * \u2191x", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h_top.h_top\n\n\u22a2 \u22a4 * \u22a4 = \u22a4 * \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/JacobsonIdeal.lean", "full_name": "Ideal.eq_jacobson_iff_not_mem", "start": [164, 1], "end": [175, 17], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\n\u22a2 jacobson I = I \u2194 \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M", "state_after": "case mp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\n\u22a2 jacobson I = I \u2192 \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M\n\ncase mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\n\u22a2 (\u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M) \u2192 jacobson I = I"}, {"tactic": "intro h x hx", "annotated_tactic": ["intro h x hx", []], "state_before": "case mp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\n\u22a2 jacobson I = I \u2192 \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M", "state_after": "case mp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : jacobson I = I\nx : R\nhx : x \u2209 I\n\u22a2 \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M"}, {"tactic": "erw [\u2190 h, mem_sInf] at hx", "annotated_tactic": ["erw [\u2190 h, <a>mem_sInf</a>] at hx", [{"full_name": "Ideal.mem_sInf", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [428, 9], "def_end_pos": [428, 17]}]], "state_before": "case mp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : jacobson I = I\nx : R\nhx : x \u2209 I\n\u22a2 \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M", "state_after": "case mp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : jacobson I = I\nx : R\nhx : \u00ac\u2200 \u2983I_1 : Ideal R\u2984, I_1 \u2208 {J | I \u2264 J \u2227 IsMaximal J} \u2192 x \u2208 I_1\n\u22a2 \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M"}, {"tactic": "push_neg at hx", "annotated_tactic": ["push_neg at hx", []], "state_before": "case mp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : jacobson I = I\nx : R\nhx : \u00ac\u2200 \u2983I_1 : Ideal R\u2984, I_1 \u2208 {J | I \u2264 J \u2227 IsMaximal J} \u2192 x \u2208 I_1\n\u22a2 \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M", "state_after": "case mp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : jacobson I = I\nx : R\nhx : \u2203 I_1 \u2208 {J | I \u2264 J \u2227 IsMaximal J}, x \u2209 I_1\n\u22a2 \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M"}, {"tactic": "exact hx", "annotated_tactic": ["exact hx", []], "state_before": "case mp\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : jacobson I = I\nx : R\nhx : \u2203 I_1 \u2208 {J | I \u2264 J \u2227 IsMaximal J}, x \u2209 I_1\n\u22a2 \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M", "state_after": "no goals"}, {"tactic": "refine fun h => le_antisymm (fun x hx => ?_) le_jacobson", "annotated_tactic": ["refine fun h => <a>le_antisymm</a> (fun x hx => ?_) <a>le_jacobson</a>", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Ideal.le_jacobson", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/JacobsonIdeal.lean", "def_pos": [64, 9], "def_end_pos": [64, 20]}]], "state_before": "case mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\n\u22a2 (\u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M) \u2192 jacobson I = I", "state_after": "case mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M\nx : R\nhx : x \u2208 jacobson I\n\u22a2 x \u2208 I"}, {"tactic": "contrapose hx", "annotated_tactic": ["contrapose hx", []], "state_before": "case mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M\nx : R\nhx : x \u2208 jacobson I\n\u22a2 x \u2208 I", "state_after": "case mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M\nx : R\nhx : x \u2209 I\n\u22a2 x \u2209 jacobson I"}, {"tactic": "erw [mem_sInf]", "annotated_tactic": ["erw [<a>mem_sInf</a>]", [{"full_name": "Ideal.mem_sInf", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [428, 9], "def_end_pos": [428, 17]}]], "state_before": "case mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M\nx : R\nhx : x \u2209 I\n\u22a2 x \u2209 jacobson I", "state_after": "case mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M\nx : R\nhx : x \u2209 I\n\u22a2 \u00ac\u2200 \u2983I_1 : Ideal R\u2984, I_1 \u2208 {J | I \u2264 J \u2227 IsMaximal J} \u2192 x \u2208 I_1"}, {"tactic": "push_neg", "annotated_tactic": ["push_neg", []], "state_before": "case mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M\nx : R\nhx : x \u2209 I\n\u22a2 \u00ac\u2200 \u2983I_1 : Ideal R\u2984, I_1 \u2208 {J | I \u2264 J \u2227 IsMaximal J} \u2192 x \u2208 I_1", "state_after": "case mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M\nx : R\nhx : x \u2209 I\n\u22a2 \u2203 I_1 \u2208 {J | I \u2264 J \u2227 IsMaximal J}, x \u2209 I_1"}, {"tactic": "exact h x hx", "annotated_tactic": ["exact h x hx", []], "state_before": "case mpr\nR : Type u\nS : Type v\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nI : Ideal R\nh : \u2200 x \u2209 I, \u2203 M, (I \u2264 M \u2227 IsMaximal M) \u2227 x \u2209 M\nx : R\nhx : x \u2209 I\n\u22a2 \u2203 I_1 \u2208 {J | I \u2264 J \u2227 IsMaximal J}, x \u2209 I_1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/WF.lean", "full_name": "Acc.ndrecOn_eq_ndrecOnC", "start": [85, 18], "end": [87, 46], "traced_tactics": [{"tactic": "funext \u03b1 r motive intro a t", "annotated_tactic": ["funext \u03b1 r motive intro a t", []], "state_before": "\u22a2 @ndrecOn = @Acc.ndrecOnC", "state_after": "case h.h.h.h.h.h\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : \u03b1 \u2192 Sort u_2\nintro : \u03b1\na : Acc r intro\nt : (x : \u03b1) \u2192 (\u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 r y x \u2192 motive y) \u2192 motive x\n\u22a2 ndrecOn a t = Acc.ndrecOnC a t"}, {"tactic": "rw [Acc.ndrecOn, rec_eq_recC, Acc.ndrecOnC]", "annotated_tactic": ["rw [<a>Acc.ndrecOn</a>, <a>rec_eq_recC</a>, <a>Acc.ndrecOnC</a>]", [{"full_name": "Acc.ndrecOn", "def_path": ".lake/packages/lean4/src/lean/Init/WF.lean", "def_pos": [20, 22], "def_end_pos": [20, 33]}, {"full_name": "_private.\u00ab.lake\u00bb.packages.std.Std.WF.0.Acc.rec_eq_recC", "def_path": ".lake/packages/std/Std/WF.lean", "def_pos": [63, 26], "def_end_pos": [63, 37]}, {"full_name": "_private.\u00ab.lake\u00bb.packages.std.Std.WF.0.Acc.ndrecOnC", "def_path": ".lake/packages/std/Std/WF.lean", "def_pos": [81, 26], "def_end_pos": [81, 34]}]], "state_before": "case h.h.h.h.h.h\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : \u03b1 \u2192 Sort u_2\nintro : \u03b1\na : Acc r intro\nt : (x : \u03b1) \u2192 (\u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 r y x \u2192 motive y) \u2192 motive x\n\u22a2 ndrecOn a t = Acc.ndrecOnC a t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Opposite.lean", "full_name": "AddOpposite.unop_pow", "start": [354, 1], "end": [355, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.uIcc_toDual", "start": [909, 1], "end": [910, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Interval.lean", "full_name": "Fin.card_fintypeIcc", "start": [131, 1], "end": [132, 41], "traced_tactics": [{"tactic": "rw [\u2190 card_Icc, Fintype.card_ofFinset]", "annotated_tactic": ["rw [\u2190 <a>card_Icc</a>, <a>Fintype.card_ofFinset</a>]", [{"full_name": "Fin.card_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Interval.lean", "def_pos": [105, 9], "def_end_pos": [105, 17]}, {"full_name": "Fintype.card_ofFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [132, 9], "def_end_pos": [132, 22]}]], "state_before": "n : \u2115\na b : Fin n\n\u22a2 Fintype.card \u2191(Set.Icc a b) = \u2191b + 1 - \u2191a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.frequently_sup", "start": [1432, 1], "end": [1434, 60], "traced_tactics": [{"tactic": "simp only [Filter.Frequently, eventually_sup, not_and_or]", "annotated_tactic": ["simp only [<a>Filter.Frequently</a>, <a>eventually_sup</a>, <a>not_and_or</a>]", [{"full_name": "Filter.Frequently", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1278, 15], "def_end_pos": [1278, 25]}, {"full_name": "Filter.eventually_sup", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1238, 9], "def_end_pos": [1238, 23]}, {"full_name": "not_and_or", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [483, 9], "def_end_pos": [483, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\np : \u03b1 \u2192 Prop\nf g : Filter \u03b1\n\u22a2 (\u2203\u1da0 (x : \u03b1) in f \u2294 g, p x) \u2194 (\u2203\u1da0 (x : \u03b1) in f, p x) \u2228 \u2203\u1da0 (x : \u03b1) in g, p x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "exists_lt_of_ciInf_lt", "start": [1022, 1], "end": [1023, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "associated_of_factorization_eq", "start": [2075, 1], "end": [2078, 68], "traced_tactics": [{"tactic": "simp_rw [factorization, AddEquiv.apply_eq_iff_eq] at h", "annotated_tactic": ["simp_rw [<a>factorization</a>, <a>AddEquiv.apply_eq_iff_eq</a>] at h", [{"full_name": "factorization", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [2039, 19], "def_end_pos": [2039, 32]}, {"full_name": "AddEquiv.apply_eq_iff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Equiv/Basic.lean", "def_pos": [424, 3], "def_end_pos": [424, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nha : a \u2260 0\nhb : b \u2260 0\nh : factorization a = factorization b\n\u22a2 a ~\u1d64 b", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nha : a \u2260 0\nhb : b \u2260 0\nh : normalizedFactors a = normalizedFactors b\n\u22a2 a ~\u1d64 b"}, {"tactic": "rwa [associated_iff_normalizedFactors_eq_normalizedFactors ha hb]", "annotated_tactic": ["rwa [<a>associated_iff_normalizedFactors_eq_normalizedFactors</a> ha hb]", [{"full_name": "UniqueFactorizationMonoid.associated_iff_normalizedFactors_eq_normalizedFactors", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [763, 9], "def_end_pos": [763, 62]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : UniqueFactorizationMonoid \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nha : a \u2260 0\nhb : b \u2260 0\nh : normalizedFactors a = normalizedFactors b\n\u22a2 a ~\u1d64 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.frequently_false", "start": [1366, 1], "end": [1366, 71], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : Filter \u03b1\n\u22a2 \u00ac\u2203\u1da0 (x : \u03b1) in f, False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Derivative.lean", "full_name": "Polynomial.coeff_iterate_derivative", "start": [397, 1], "end": [411, 40], "traced_tactics": [{"tactic": "induction k generalizing m with\n| zero => simp\n| succ k ih =>\n    calc\n      (derivative^[k + 1] p).coeff m\n      _ = Nat.descFactorial (Nat.succ (m + k)) k \u2022 p.coeff (m + k.succ) * (m + 1) := by\n        rw [Function.iterate_succ_apply', coeff_derivative, ih m.succ, Nat.succ_add, Nat.add_succ]\n      _ = ((m + 1) * Nat.descFactorial (Nat.succ (m + k)) k) \u2022 p.coeff (m + k.succ) := by\n        rw [\u2190 Nat.cast_add_one, \u2190 nsmul_eq_mul', smul_smul]\n      _ = Nat.descFactorial (m.succ + k) k.succ \u2022 p.coeff (m + k.succ) := by\n        rw [\u2190 Nat.succ_add, Nat.descFactorial_succ, add_tsub_cancel_right]\n      _ = Nat.descFactorial (m + k.succ) k.succ \u2022 p.coeff (m + k.succ) := by\n        rw [Nat.succ_add_eq_add_succ]", "annotated_tactic": ["induction k generalizing m with\n  | <a>zero</a> => simp\n  | <a>succ</a> k ih =>\n      calc\n        (<a>derivative</a>^[k + 1] p).<a>coeff</a> m\n        _ = <a>Nat.descFactorial</a> (<a>Nat.succ</a> (m + k)) k \u2022 p.coeff (m + k.succ) * (m + 1) := by\n          rw [<a>Function.iterate_succ_apply'</a>, <a>coeff_derivative</a>, ih m.succ, <a>Nat.succ_add</a>, <a>Nat.add_succ</a>]\n        _ = ((m + 1) * <a>Nat.descFactorial</a> (<a>Nat.succ</a> (m + k)) k) \u2022 p.coeff (m + k.succ) := by\n          rw [\u2190 <a>Nat.cast_add_one</a>, \u2190 <a>nsmul_eq_mul'</a>, <a>smul_smul</a>]\n        _ = <a>Nat.descFactorial</a> (m.succ + k) k.succ \u2022 p.coeff (m + k.succ) := by\n          rw [\u2190 <a>Nat.succ_add</a>, <a>Nat.descFactorial_succ</a>, <a>add_tsub_cancel_right</a>]\n        _ = <a>Nat.descFactorial</a> (m + k.succ) k.succ \u2022 p.coeff (m + k.succ) := by\n          rw [<a>Nat.succ_add_eq_add_succ</a>]", [{"full_name": "Nat.zero", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1068, 5], "def_end_pos": [1068, 9]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Polynomial.derivative", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [40, 5], "def_end_pos": [40, 15]}, {"full_name": "Polynomial.coeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [666, 5], "def_end_pos": [666, 10]}, {"full_name": "Nat.descFactorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [347, 5], "def_end_pos": [347, 18]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Function.iterate_succ_apply'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [190, 9], "def_end_pos": [190, 28]}, {"full_name": "Polynomial.coeff_derivative", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [57, 9], "def_end_pos": [57, 25]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.add_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 17]}, {"full_name": "Nat.descFactorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [347, 5], "def_end_pos": [347, 18]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Nat.cast_add_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "nsmul_eq_mul'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [65, 7], "def_end_pos": [65, 27]}, {"full_name": "smul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [473, 9], "def_end_pos": [473, 18]}, {"full_name": "Nat.descFactorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [347, 5], "def_end_pos": [347, 18]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.descFactorial_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [358, 9], "def_end_pos": [358, 27]}, {"full_name": "add_tsub_cancel_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [357, 9], "def_end_pos": [357, 30]}, {"full_name": "Nat.descFactorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [347, 5], "def_end_pos": [347, 18]}, {"full_name": "Nat.succ_add_eq_add_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [156, 9], "def_end_pos": [156, 29]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nk : \u2115\np : R[X]\nm : \u2115\n\u22a2 coeff ((\u21d1derivative)^[k] p) m = Nat.descFactorial (m + k) k \u2022 coeff p (m + k)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\nm : \u2115\n\u22a2 coeff ((\u21d1derivative)^[Nat.zero] p) m = Nat.descFactorial (m + Nat.zero) Nat.zero \u2022 coeff p (m + Nat.zero)", "state_after": "no goals"}, {"tactic": "calc\n  (derivative^[k + 1] p).coeff m\n  _ = Nat.descFactorial (Nat.succ (m + k)) k \u2022 p.coeff (m + k.succ) * (m + 1) := by\n    rw [Function.iterate_succ_apply', coeff_derivative, ih m.succ, Nat.succ_add, Nat.add_succ]\n  _ = ((m + 1) * Nat.descFactorial (Nat.succ (m + k)) k) \u2022 p.coeff (m + k.succ) := by\n    rw [\u2190 Nat.cast_add_one, \u2190 nsmul_eq_mul', smul_smul]\n  _ = Nat.descFactorial (m.succ + k) k.succ \u2022 p.coeff (m + k.succ) := by\n    rw [\u2190 Nat.succ_add, Nat.descFactorial_succ, add_tsub_cancel_right]\n  _ = Nat.descFactorial (m + k.succ) k.succ \u2022 p.coeff (m + k.succ) := by\n    rw [Nat.succ_add_eq_add_succ]", "annotated_tactic": ["calc\n        (<a>derivative</a>^[k + 1] p).<a>coeff</a> m\n        _ = <a>Nat.descFactorial</a> (<a>Nat.succ</a> (m + k)) k \u2022 p.coeff (m + k.succ) * (m + 1) := by\n          rw [<a>Function.iterate_succ_apply'</a>, <a>coeff_derivative</a>, ih m.succ, <a>Nat.succ_add</a>, <a>Nat.add_succ</a>]\n        _ = ((m + 1) * <a>Nat.descFactorial</a> (<a>Nat.succ</a> (m + k)) k) \u2022 p.coeff (m + k.succ) := by\n          rw [\u2190 <a>Nat.cast_add_one</a>, \u2190 <a>nsmul_eq_mul'</a>, <a>smul_smul</a>]\n        _ = <a>Nat.descFactorial</a> (m.succ + k) k.succ \u2022 p.coeff (m + k.succ) := by\n          rw [\u2190 <a>Nat.succ_add</a>, <a>Nat.descFactorial_succ</a>, <a>add_tsub_cancel_right</a>]\n        _ = <a>Nat.descFactorial</a> (m + k.succ) k.succ \u2022 p.coeff (m + k.succ) := by\n          rw [<a>Nat.succ_add_eq_add_succ</a>]", [{"full_name": "Polynomial.derivative", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [40, 5], "def_end_pos": [40, 15]}, {"full_name": "Polynomial.coeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [666, 5], "def_end_pos": [666, 10]}, {"full_name": "Nat.descFactorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [347, 5], "def_end_pos": [347, 18]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Function.iterate_succ_apply'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [190, 9], "def_end_pos": [190, 28]}, {"full_name": "Polynomial.coeff_derivative", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [57, 9], "def_end_pos": [57, 25]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.add_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 17]}, {"full_name": "Nat.descFactorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [347, 5], "def_end_pos": [347, 18]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Nat.cast_add_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "nsmul_eq_mul'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [65, 7], "def_end_pos": [65, 27]}, {"full_name": "smul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [473, 9], "def_end_pos": [473, 18]}, {"full_name": "Nat.descFactorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [347, 5], "def_end_pos": [347, 18]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.descFactorial_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [358, 9], "def_end_pos": [358, 27]}, {"full_name": "add_tsub_cancel_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [357, 9], "def_end_pos": [357, 30]}, {"full_name": "Nat.descFactorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [347, 5], "def_end_pos": [347, 18]}, {"full_name": "Nat.succ_add_eq_add_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [156, 9], "def_end_pos": [156, 29]}]], "state_before": "case succ\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\nk : \u2115\nih : \u2200 (m : \u2115), coeff ((\u21d1derivative)^[k] p) m = Nat.descFactorial (m + k) k \u2022 coeff p (m + k)\nm : \u2115\n\u22a2 coeff ((\u21d1derivative)^[Nat.succ k] p) m = Nat.descFactorial (m + Nat.succ k) (Nat.succ k) \u2022 coeff p (m + Nat.succ k)", "state_after": "no goals"}, {"tactic": "rw [Function.iterate_succ_apply', coeff_derivative, ih m.succ, Nat.succ_add, Nat.add_succ]", "annotated_tactic": ["rw [<a>Function.iterate_succ_apply'</a>, <a>coeff_derivative</a>, ih m.succ, <a>Nat.succ_add</a>, <a>Nat.add_succ</a>]", [{"full_name": "Function.iterate_succ_apply'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [190, 9], "def_end_pos": [190, 28]}, {"full_name": "Polynomial.coeff_derivative", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [57, 9], "def_end_pos": [57, 25]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.add_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 17]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\nk : \u2115\nih : \u2200 (m : \u2115), coeff ((\u21d1derivative)^[k] p) m = Nat.descFactorial (m + k) k \u2022 coeff p (m + k)\nm : \u2115\n\u22a2 coeff ((\u21d1derivative)^[k + 1] p) m = Nat.descFactorial (Nat.succ (m + k)) k \u2022 coeff p (m + Nat.succ k) * (\u2191m + 1)", "state_after": "no goals"}, {"tactic": "rw [\u2190 Nat.cast_add_one, \u2190 nsmul_eq_mul', smul_smul]", "annotated_tactic": ["rw [\u2190 <a>Nat.cast_add_one</a>, \u2190 <a>nsmul_eq_mul'</a>, <a>smul_smul</a>]", [{"full_name": "Nat.cast_add_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "nsmul_eq_mul'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [65, 7], "def_end_pos": [65, 27]}, {"full_name": "smul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [473, 9], "def_end_pos": [473, 18]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\nk : \u2115\nih : \u2200 (m : \u2115), coeff ((\u21d1derivative)^[k] p) m = Nat.descFactorial (m + k) k \u2022 coeff p (m + k)\nm : \u2115\n\u22a2 Nat.descFactorial (Nat.succ (m + k)) k \u2022 coeff p (m + Nat.succ k) * (\u2191m + 1) =\n    ((m + 1) * Nat.descFactorial (Nat.succ (m + k)) k) \u2022 coeff p (m + Nat.succ k)", "state_after": "no goals"}, {"tactic": "rw [\u2190 Nat.succ_add, Nat.descFactorial_succ, add_tsub_cancel_right]", "annotated_tactic": ["rw [\u2190 <a>Nat.succ_add</a>, <a>Nat.descFactorial_succ</a>, <a>add_tsub_cancel_right</a>]", [{"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.descFactorial_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [358, 9], "def_end_pos": [358, 27]}, {"full_name": "add_tsub_cancel_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [357, 9], "def_end_pos": [357, 30]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\nk : \u2115\nih : \u2200 (m : \u2115), coeff ((\u21d1derivative)^[k] p) m = Nat.descFactorial (m + k) k \u2022 coeff p (m + k)\nm : \u2115\n\u22a2 ((m + 1) * Nat.descFactorial (Nat.succ (m + k)) k) \u2022 coeff p (m + Nat.succ k) =\n    Nat.descFactorial (Nat.succ m + k) (Nat.succ k) \u2022 coeff p (m + Nat.succ k)", "state_after": "no goals"}, {"tactic": "rw [Nat.succ_add_eq_add_succ]", "annotated_tactic": ["rw [<a>Nat.succ_add_eq_add_succ</a>]", [{"full_name": "Nat.succ_add_eq_add_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [156, 9], "def_end_pos": [156, 29]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\nk : \u2115\nih : \u2200 (m : \u2115), coeff ((\u21d1derivative)^[k] p) m = Nat.descFactorial (m + k) k \u2022 coeff p (m + k)\nm : \u2115\n\u22a2 Nat.descFactorial (Nat.succ m + k) (Nat.succ k) \u2022 coeff p (m + Nat.succ k) =\n    Nat.descFactorial (m + Nat.succ k) (Nat.succ k) \u2022 coeff p (m + Nat.succ k)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Cardinality.lean", "full_name": "Cardinal.mk_Ioo_real", "start": [264, 1], "end": [272, 48], "traced_tactics": [{"tactic": "refine' le_antisymm (mk_real \u25b8 mk_set_le _) _", "annotated_tactic": ["refine' <a>le_antisymm</a> (<a>mk_real</a> \u25b8 <a>mk_set_le</a> _) _", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Cardinal.mk_real", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Cardinality.lean", "def_pos": [200, 9], "def_end_pos": [200, 16]}, {"full_name": "Cardinal.mk_set_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [291, 9], "def_end_pos": [291, 18]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh : a < b\n\u22a2 #\u2191(Ioo a b) = \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh : a < b\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo a b)"}, {"tactic": "have h1 : #((fun x => x - a) '' Ioo a b) \u2264 #(Ioo a b) := mk_image_le", "annotated_tactic": ["have h1 : #((fun x => x - a) '' <a>Ioo</a> a b) \u2264 #(<a>Ioo</a> a b) := <a>mk_image_le</a>", [{"full_name": "Set.Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [44, 5], "def_end_pos": [44, 8]}, {"full_name": "Set.Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [44, 5], "def_end_pos": [44, 8]}, {"full_name": "Cardinal.mk_image_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1933, 9], "def_end_pos": [1933, 20]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh : a < b\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo a b)", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh : a < b\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo a b)"}, {"tactic": "refine' le_trans _ h1", "annotated_tactic": ["refine' <a>le_trans</a> _ h1", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh : a < b\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo a b)", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh : a < b\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\n\u22a2 \ud835\udd20 \u2264 #\u2191((fun x => x - a) '' Ioo a b)"}, {"tactic": "rw [image_sub_const_Ioo, sub_self]", "annotated_tactic": ["rw [<a>image_sub_const_Ioo</a>, <a>sub_self</a>]", [{"full_name": "Set.image_sub_const_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Interval.lean", "def_pos": [489, 9], "def_end_pos": [489, 28]}, {"full_name": "sub_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [813, 30], "def_end_pos": [813, 38]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh : a < b\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\n\u22a2 \ud835\udd20 \u2264 #\u2191((fun x => x - a) '' Ioo a b)", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh : a < b\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo 0 (b - a))"}, {"tactic": "replace h := sub_pos_of_lt h", "annotated_tactic": ["replace h := <a>sub_pos_of_lt</a> h", [{"full_name": "sub_pos_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [892, 23], "def_end_pos": [892, 36]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh : a < b\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo 0 (b - a))", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\nh : 0 < b - a\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo 0 (b - a))"}, {"tactic": "have h2 : #(Inv.inv '' Ioo 0 (b - a)) \u2264 #(Ioo 0 (b - a)) := mk_image_le", "annotated_tactic": ["have h2 : #(<a>Inv.inv</a> '' <a>Ioo</a> 0 (b - a)) \u2264 #(<a>Ioo</a> 0 (b - a)) := <a>mk_image_le</a>", [{"full_name": "Inv.inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [165, 3], "def_end_pos": [165, 6]}, {"full_name": "Set.Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [44, 5], "def_end_pos": [44, 8]}, {"full_name": "Set.Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [44, 5], "def_end_pos": [44, 8]}, {"full_name": "Cardinal.mk_image_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1933, 9], "def_end_pos": [1933, 20]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\nh : 0 < b - a\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo 0 (b - a))", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\nh : 0 < b - a\nh2 : #\u2191(Inv.inv '' Ioo 0 (b - a)) \u2264 #\u2191(Ioo 0 (b - a))\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo 0 (b - a))"}, {"tactic": "refine' le_trans _ h2", "annotated_tactic": ["refine' <a>le_trans</a> _ h2", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\nh : 0 < b - a\nh2 : #\u2191(Inv.inv '' Ioo 0 (b - a)) \u2264 #\u2191(Ioo 0 (b - a))\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioo 0 (b - a))", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\nh : 0 < b - a\nh2 : #\u2191(Inv.inv '' Ioo 0 (b - a)) \u2264 #\u2191(Ioo 0 (b - a))\n\u22a2 \ud835\udd20 \u2264 #\u2191(Inv.inv '' Ioo 0 (b - a))"}, {"tactic": "rw [image_inv, inv_Ioo_0_left h, mk_Ioi_real]", "annotated_tactic": ["rw [<a>image_inv</a>, <a>inv_Ioo_0_left</a> h, <a>mk_Ioi_real</a>]", [{"full_name": "Set.image_inv", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [258, 9], "def_end_pos": [258, 18]}, {"full_name": "Set.inv_Ioo_0_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Interval.lean", "def_pos": [847, 9], "def_end_pos": [847, 23]}, {"full_name": "Cardinal.mk_Ioi_real", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Cardinality.lean", "def_pos": [224, 9], "def_end_pos": [224, 20]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na b : \u211d\nh1 : #\u2191((fun x => x - a) '' Ioo a b) \u2264 #\u2191(Ioo a b)\nh : 0 < b - a\nh2 : #\u2191(Inv.inv '' Ioo 0 (b - a)) \u2264 #\u2191(Ioo 0 (b - a))\n\u22a2 \ud835\udd20 \u2264 #\u2191(Inv.inv '' Ioo 0 (b - a))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/ToNat.lean", "full_name": "Cardinal.toNat_lt_iff_lt_of_lt_aleph0", "start": [85, 1], "end": [87, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Disjoint.lean", "full_name": "Set.iUnion_Ico_right", "start": [115, 1], "end": [116, 70], "traced_tactics": [{"tactic": "simp only [\u2190 Ici_inter_Iio, \u2190 inter_iUnion, iUnion_Iio, inter_univ]", "annotated_tactic": ["simp only [\u2190 <a>Ici_inter_Iio</a>, \u2190 <a>inter_iUnion</a>, <a>iUnion_Iio</a>, <a>inter_univ</a>]", [{"full_name": "Set.Ici_inter_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [622, 9], "def_end_pos": [622, 22]}, {"full_name": "Set.inter_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [485, 9], "def_end_pos": [485, 21]}, {"full_name": "Set.iUnion_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Disjoint.lean", "def_pos": [105, 9], "def_end_pos": [105, 19]}, {"full_name": "Set.inter_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [984, 9], "def_end_pos": [984, 19]}]], "state_before": "\u03b9 : Sort u\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d\u00b9 : Preorder \u03b1\na\u271d b c : \u03b1\ninst\u271d : NoMaxOrder \u03b1\na : \u03b1\n\u22a2 \u22c3 b, Ico a b = Ici a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.range_natCast", "start": [1586, 1], "end": [1587, 69], "traced_tactics": [{"tactic": "simp only [mem_Iio, mem_range, eq_comm, lt_aleph0]", "annotated_tactic": ["simp only [<a>mem_Iio</a>, <a>mem_range</a>, <a>eq_comm</a>, <a>lt_aleph0</a>]", [{"full_name": "Set.mem_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [126, 9], "def_end_pos": [126, 16]}, {"full_name": "Set.mem_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [160, 17], "def_end_pos": [160, 26]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "Cardinal.lt_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1542, 9], "def_end_pos": [1542, 18]}]], "state_before": "\u03b1 \u03b2 : Type u\nx : Cardinal.{u_1}\n\u22a2 x \u2208 range Nat.cast \u2194 x \u2208 Iio \u2135\u2080", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PolynomialAlgebra.lean", "full_name": "matPolyEquiv_symm_X", "start": [231, 9], "end": [236, 30], "traced_tactics": [{"tactic": "suffices (Matrix.map 1 fun x \u21a6 X * algebraMap R R[X] x) = diagonal fun _ : n => (X : R[X]) by\n  simpa [matPolyEquiv]", "annotated_tactic": ["suffices (<a>Matrix.map</a> 1 fun x \u21a6 <a>X</a> * <a>algebraMap</a> R R[X] x) = <a>diagonal</a> fun _ : n => (<a>X</a> : R[X]) by\n    simpa [<a>matPolyEquiv</a>]", [{"full_name": "Matrix.map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [143, 5], "def_end_pos": [143, 8]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "Matrix.diagonal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [403, 5], "def_end_pos": [403, 13]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "matPolyEquiv", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PolynomialAlgebra.lean", "def_pos": [220, 19], "def_end_pos": [220, 31]}]], "state_before": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\n\u22a2 (AlgEquiv.symm matPolyEquiv) X = diagonal fun x => X", "state_after": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\n\u22a2 (Matrix.map 1 fun x => X * (algebraMap R R[X]) x) = diagonal fun x => X"}, {"tactic": "rw [\u2190 Matrix.diagonal_one]", "annotated_tactic": ["rw [\u2190 <a>Matrix.diagonal_one</a>]", [{"full_name": "Matrix.diagonal_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [550, 9], "def_end_pos": [550, 21]}]], "state_before": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\n\u22a2 (Matrix.map 1 fun x => X * (algebraMap R R[X]) x) = diagonal fun x => X", "state_after": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\n\u22a2 (Matrix.map (diagonal fun x => 1) fun x => X * (algebraMap R R[X]) x) = diagonal fun x => X"}, {"tactic": "simp [-Matrix.diagonal_one]", "annotated_tactic": ["simp [-Matrix.diagonal_one]", []], "state_before": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\n\u22a2 (Matrix.map (diagonal fun x => 1) fun x => X * (algebraMap R R[X]) x) = diagonal fun x => X", "state_after": "no goals"}, {"tactic": "simpa [matPolyEquiv]", "annotated_tactic": ["simpa [<a>matPolyEquiv</a>]", [{"full_name": "matPolyEquiv", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PolynomialAlgebra.lean", "def_pos": [220, 19], "def_end_pos": [220, 31]}]], "state_before": "R : Type u_1\nA : Type u_2\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nthis : (Matrix.map 1 fun x => X * (algebraMap R R[X]) x) = diagonal fun x => X\n\u22a2 (AlgEquiv.symm matPolyEquiv) X = diagonal fun x => X", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/OrdConnectedComponent.lean", "full_name": "Set.ordConnectedComponent_univ", "start": [73, 1], "end": [74, 31], "traced_tactics": [{"tactic": "simp [ordConnectedComponent]", "annotated_tactic": ["simp [<a>ordConnectedComponent</a>]", [{"full_name": "Set.ordConnectedComponent", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/OrdConnectedComponent.lean", "def_pos": [29, 5], "def_end_pos": [29, 26]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns t : Set \u03b1\nx y z : \u03b1\n\u22a2 ordConnectedComponent univ x = univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.eq_ofRepr_eq_repr", "start": [331, 1], "end": [332, 36], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : AddCommMonoid M'\ninst\u271d\u2075 : Module R M'\nb b\u2081\u271d : Basis \u03b9 R M\ni : \u03b9\nc : R\nx : M\nR\u2081 : Type u_10\ninst\u271d\u2074 : Semiring R\u2081\n\u03c3 : R \u2192+* R\u2081\n\u03c3' : R\u2081 \u2192+* R\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomInvPair \u03c3' \u03c3\nM\u2081 : Type u_11\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R\u2081 M\u2081\nb\u2081 b\u2082 : Basis \u03b9 R M\nh : \u2200 (x : M) (i : \u03b9), (b\u2081.repr x) i = (b\u2082.repr x) i\n\u22a2 b\u2081.repr = b\u2082.repr", "state_after": "case h.h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : AddCommMonoid M'\ninst\u271d\u2075 : Module R M'\nb b\u2081\u271d : Basis \u03b9 R M\ni : \u03b9\nc : R\nx : M\nR\u2081 : Type u_10\ninst\u271d\u2074 : Semiring R\u2081\n\u03c3 : R \u2192+* R\u2081\n\u03c3' : R\u2081 \u2192+* R\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomInvPair \u03c3' \u03c3\nM\u2081 : Type u_11\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R\u2081 M\u2081\nb\u2081 b\u2082 : Basis \u03b9 R M\nh : \u2200 (x : M) (i : \u03b9), (b\u2081.repr x) i = (b\u2082.repr x) i\nx\u271d : M\na\u271d : \u03b9\n\u22a2 (b\u2081.repr x\u271d) a\u271d = (b\u2082.repr x\u271d) a\u271d"}, {"tactic": "apply h", "annotated_tactic": ["apply h", []], "state_before": "case h.h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : AddCommMonoid M'\ninst\u271d\u2075 : Module R M'\nb b\u2081\u271d : Basis \u03b9 R M\ni : \u03b9\nc : R\nx : M\nR\u2081 : Type u_10\ninst\u271d\u2074 : Semiring R\u2081\n\u03c3 : R \u2192+* R\u2081\n\u03c3' : R\u2081 \u2192+* R\ninst\u271d\u00b3 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u00b2 : RingHomInvPair \u03c3' \u03c3\nM\u2081 : Type u_11\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : Module R\u2081 M\u2081\nb\u2081 b\u2082 : Basis \u03b9 R M\nh : \u2200 (x : M) (i : \u03b9), (b\u2081.repr x) i = (b\u2082.repr x) i\nx\u271d : M\na\u271d : \u03b9\n\u22a2 (b\u2081.repr x\u271d) a\u271d = (b\u2082.repr x\u271d) a\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Semicontinuous.lean", "full_name": "LowerSemicontinuousWithinAt.mono", "start": [145, 1], "end": [147, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "full_name": "Subsemigroup.le_comap_map", "start": [293, 1], "end": [294, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "SubringClass.coe_natCast", "start": [131, 1], "end": [132, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Pointwise.lean", "full_name": "Real.iInf_mul_of_nonneg", "start": [132, 1], "end": [133, 51], "traced_tactics": [{"tactic": "simp only [Real.mul_iInf_of_nonneg ha, mul_comm]", "annotated_tactic": ["simp only [<a>Real.mul_iInf_of_nonneg</a> ha, <a>mul_comm</a>]", [{"full_name": "Real.mul_iInf_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Pointwise.lean", "def_pos": [116, 9], "def_end_pos": [116, 32]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d : LinearOrderedField \u03b1\nr : \u211d\nha : 0 \u2264 r\nf : \u03b9 \u2192 \u211d\n\u22a2 (\u2a05 i, f i) * r = \u2a05 i, f i * r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Determinant.lean", "full_name": "Basis.det_ne_zero", "start": [539, 1], "end": [539, 95], "traced_tactics": [{"tactic": "simpa [h] using e.det_self", "annotated_tactic": ["simpa [h] using e.det_self", []], "state_before": "R : Type u_1\ninst\u271d\u2077 : CommRing R\nM : Type u_2\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\nM' : Type u_3\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ne : Basis \u03b9 R M\ninst\u271d : Nontrivial R\nh : det e = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Vector/Basic.lean", "full_name": "Vector.tail_nil", "start": [188, 1], "end": [189, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Cardinality.lean", "full_name": "Cardinal.cantorFunctionAux_nonneg", "start": [73, 1], "end": [75, 21], "traced_tactics": [{"tactic": "cases h' : f n <;> simp [h']", "annotated_tactic": ["cases h' : f n <;> simp [h']", []], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\nh : 0 \u2264 c\n\u22a2 0 \u2264 cantorFunctionAux c f n", "state_after": "case true\nc : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\nh : 0 \u2264 c\nh' : f n = true\n\u22a2 0 \u2264 c ^ n"}, {"tactic": "apply pow_nonneg h", "annotated_tactic": ["apply <a>pow_nonneg</a> h", [{"full_name": "pow_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [243, 9], "def_end_pos": [243, 19]}]], "state_before": "case true\nc : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\nh : 0 \u2264 c\nh' : f n = true\n\u22a2 0 \u2264 c ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "full_name": "NonUnitalSubring.closure_iUnion", "start": [794, 1], "end": [795, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.ofRealAm_coe", "start": [1109, 1], "end": [1110, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Extr.lean", "full_name": "isMinOn_iff", "start": [130, 1], "end": [131, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "IsTop.atTop_eq", "start": [308, 1], "end": [309, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "AlgHom.rangeRestrict_surjective", "start": [623, 1], "end": [626, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Splits.lean", "full_name": "Polynomial.degree_eq_card_roots'", "start": [219, 1], "end": [221, 72], "traced_tactics": [{"tactic": "simp [degree_eq_natDegree p_ne_zero, natDegree_eq_card_roots' hsplit]", "annotated_tactic": ["simp [<a>degree_eq_natDegree</a> p_ne_zero, <a>natDegree_eq_card_roots'</a> hsplit]", [{"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}, {"full_name": "Polynomial.natDegree_eq_card_roots'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Splits.lean", "def_pos": [201, 9], "def_end_pos": [201, 33]}]], "state_before": "R : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni\u271d : K \u2192+* L\np : K[X]\ni : K \u2192+* L\np_ne_zero : map i p \u2260 0\nhsplit : Splits i p\n\u22a2 degree (map i p) = \u2191(Multiset.card (roots (map i p)))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupIndep.lean", "full_name": "Finset.supIndep_map", "start": [120, 1], "end": [126, 19], "traced_tactics": [{"tactic": "refine' \u27e8fun hs t ht i hi hit => _, fun hs => _\u27e9", "annotated_tactic": ["refine' \u27e8fun hs t ht i hi hit => _, fun hs => _\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\n\u22a2 SupIndep (map g s) f \u2194 SupIndep s (f \u2218 \u21d1g)", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t\u271d : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni\u271d : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep (map g s) f\nt : Finset \u03b9'\nht : t \u2286 s\ni : \u03b9'\nhi : i \u2208 s\nhit : i \u2209 t\n\u22a2 Disjoint ((f \u2218 \u21d1g) i) (sup t (f \u2218 \u21d1g))\n\ncase refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep s (f \u2218 \u21d1g)\n\u22a2 SupIndep (map g s) f"}, {"tactic": "rw [\u2190 sup_map]", "annotated_tactic": ["rw [\u2190 <a>sup_map</a>]", [{"full_name": "Finset.sup_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [67, 9], "def_end_pos": [67, 16]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t\u271d : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni\u271d : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep (map g s) f\nt : Finset \u03b9'\nht : t \u2286 s\ni : \u03b9'\nhi : i \u2208 s\nhit : i \u2209 t\n\u22a2 Disjoint ((f \u2218 \u21d1g) i) (sup t (f \u2218 \u21d1g))", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t\u271d : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni\u271d : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep (map g s) f\nt : Finset \u03b9'\nht : t \u2286 s\ni : \u03b9'\nhi : i \u2208 s\nhit : i \u2209 t\n\u22a2 Disjoint ((f \u2218 \u21d1g) i) (sup (map g t) f)"}, {"tactic": "exact hs (map_subset_map.2 ht) ((mem_map' _).2 hi) (by rwa [mem_map'])", "annotated_tactic": ["exact hs (<a>map_subset_map</a>.2 ht) ((<a>mem_map'</a> _).2 hi) (by rwa [<a>mem_map'</a>])", [{"full_name": "Finset.map_subset_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [160, 9], "def_end_pos": [160, 23]}, {"full_name": "Finset.mem_map'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [86, 9], "def_end_pos": [86, 17]}, {"full_name": "Finset.mem_map'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [86, 9], "def_end_pos": [86, 17]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t\u271d : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni\u271d : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep (map g s) f\nt : Finset \u03b9'\nht : t \u2286 s\ni : \u03b9'\nhi : i \u2208 s\nhit : i \u2209 t\n\u22a2 Disjoint ((f \u2218 \u21d1g) i) (sup (map g t) f)", "state_after": "no goals"}, {"tactic": "rwa [mem_map']", "annotated_tactic": ["rwa [<a>mem_map'</a>]", [{"full_name": "Finset.mem_map'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [86, 9], "def_end_pos": [86, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t\u271d : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni\u271d : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep (map g s) f\nt : Finset \u03b9'\nht : t \u2286 s\ni : \u03b9'\nhi : i \u2208 s\nhit : i \u2209 t\n\u22a2 g i \u2209 map g t", "state_after": "no goals"}, {"tactic": "classical\nrw [map_eq_image]\nexact hs.image", "annotated_tactic": ["classical\n    rw [<a>map_eq_image</a>]\n    exact hs.image", [{"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep s (f \u2218 \u21d1g)\n\u22a2 SupIndep (map g s) f", "state_after": "no goals"}, {"tactic": "rw [map_eq_image]", "annotated_tactic": ["rw [<a>map_eq_image</a>]", [{"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep s (f \u2218 \u21d1g)\n\u22a2 SupIndep (map g s) f", "state_after": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep s (f \u2218 \u21d1g)\n\u22a2 SupIndep (image (\u21d1g) s) f"}, {"tactic": "exact hs.image", "annotated_tactic": ["exact hs.image", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\ns : Finset \u03b9'\ng : \u03b9' \u21aa \u03b9\nhs : SupIndep s (f \u2218 \u21d1g)\n\u22a2 SupIndep (image (\u21d1g) s) f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_range_eq_of_injective", "start": [1960, 1], "end": [1962, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "full_name": "UniformInducing.prod", "start": [115, 1], "end": [118, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SetNotation.lean", "full_name": "Set.sSup_eq_sUnion", "start": [284, 1], "end": [285, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Adjoin/Basic.lean", "full_name": "Algebra.adjoin_attach_biUnion", "start": [76, 1], "end": [77, 91], "traced_tactics": [{"tactic": "simp [adjoin_iUnion]", "annotated_tactic": ["simp [<a>adjoin_iUnion</a>]", [{"full_name": "Algebra.adjoin_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Adjoin/Basic.lean", "def_pos": [71, 9], "def_end_pos": [71, 22]}]], "state_before": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : CommSemiring S\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Semiring B\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Algebra S A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : IsScalarTower R S A\ns\u271d t : Set A\ninst\u271d : DecidableEq A\n\u03b1 : Type u_1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 Finset A\n\u22a2 adjoin R \u2191(Finset.biUnion (Finset.attach s) f) = \u2a06 x, adjoin R \u2191(f x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Count.lean", "full_name": "List.count_erase", "start": [227, 1], "end": [242, 51], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\n\u22a2 count a (List.erase [] b) = count a [] - if a = b then 1 else 0", "state_after": "no goals"}, {"tactic": "rw [erase_cons]", "annotated_tactic": ["rw [<a>erase_cons</a>]", [{"full_name": "List.erase_cons", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1221, 9], "def_end_pos": [1221, 19]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\n\u22a2 count a (List.erase (c :: l) b) = count a (c :: l) - if a = b then 1 else 0", "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\n\u22a2 count a (if (c == b) = true then l else c :: List.erase l b) = count a (c :: l) - if a = b then 1 else 0"}, {"tactic": "if hc : c = b then\n  have hc_beq := (beq_iff_eq _ _).mpr hc\n  rw [if_pos hc_beq, hc, count_cons, Nat.add_sub_cancel]\nelse\n  have hc_beq := beq_false_of_ne hc\n  simp only [hc_beq, if_false, count_cons, count_cons, count_erase a b l]\n  if ha : a = b then\n    rw [\u2190 ha, eq_comm] at hc\n    rw [if_pos ha, if_neg hc, Nat.add_zero, Nat.add_zero]\n  else\n    rw [if_neg ha, Nat.sub_zero, Nat.sub_zero]", "annotated_tactic": ["if hc : c = b then\n      have hc_beq := (<a>beq_iff_eq</a> _ _).<a>mpr</a> hc\n      rw [<a>if_pos</a> hc_beq, hc, <a>count_cons</a>, <a>Nat.add_sub_cancel</a>]\n    else\n      have hc_beq := <a>beq_false_of_ne</a> hc\n      simp only [hc_beq, <a>if_false</a>, <a>count_cons</a>, <a>count_cons</a>, count_erase a b l]\n      if ha : a = b then\n        rw [\u2190 ha, <a>eq_comm</a>] at hc\n        rw [<a>if_pos</a> ha, <a>if_neg</a> hc, <a>Nat.add_zero</a>, <a>Nat.add_zero</a>]\n      else\n        rw [<a>if_neg</a> ha, <a>Nat.sub_zero</a>, <a>Nat.sub_zero</a>]", [{"full_name": "beq_iff_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1314, 17], "def_end_pos": [1314, 27]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "List.count_cons", "def_path": ".lake/packages/std/Std/Data/List/Count.lean", "def_pos": [137, 9], "def_end_pos": [137, 19]}, {"full_name": "Nat.add_sub_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [635, 27], "def_end_pos": [635, 41]}, {"full_name": "beq_false_of_ne", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [732, 9], "def_end_pos": [732, 24]}, {"full_name": "if_false", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [26, 17], "def_end_pos": [26, 25]}, {"full_name": "List.count_cons", "def_path": ".lake/packages/std/Std/Data/List/Count.lean", "def_pos": [137, 9], "def_end_pos": [137, 19]}, {"full_name": "List.count_cons", "def_path": ".lake/packages/std/Std/Data/List/Count.lean", "def_pos": [137, 9], "def_end_pos": [137, 19]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "Nat.sub_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [220, 27], "def_end_pos": [220, 35]}, {"full_name": "Nat.sub_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [220, 27], "def_end_pos": [220, 35]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\n\u22a2 count a (if (c == b) = true then l else c :: List.erase l b) = count a (c :: l) - if a = b then 1 else 0", "state_after": "no goals"}, {"tactic": "have hc_beq := (beq_iff_eq _ _).mpr hc", "annotated_tactic": ["have hc_beq := (<a>beq_iff_eq</a> _ _).<a>mpr</a> hc", [{"full_name": "beq_iff_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1314, 17], "def_end_pos": [1314, 27]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : c = b\n\u22a2 count a (if (c == b) = true then l else c :: List.erase l b) = count a (c :: l) - if a = b then 1 else 0", "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : c = b\nhc_beq : (c == b) = true\n\u22a2 count a (if (c == b) = true then l else c :: List.erase l b) = count a (c :: l) - if a = b then 1 else 0"}, {"tactic": "rw [if_pos hc_beq, hc, count_cons, Nat.add_sub_cancel]", "annotated_tactic": ["rw [<a>if_pos</a> hc_beq, hc, <a>count_cons</a>, <a>Nat.add_sub_cancel</a>]", [{"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "List.count_cons", "def_path": ".lake/packages/std/Std/Data/List/Count.lean", "def_pos": [137, 9], "def_end_pos": [137, 19]}, {"full_name": "Nat.add_sub_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [635, 27], "def_end_pos": [635, 41]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : c = b\nhc_beq : (c == b) = true\n\u22a2 count a (if (c == b) = true then l else c :: List.erase l b) = count a (c :: l) - if a = b then 1 else 0", "state_after": "no goals"}, {"tactic": "have hc_beq := beq_false_of_ne hc", "annotated_tactic": ["have hc_beq := <a>beq_false_of_ne</a> hc", [{"full_name": "beq_false_of_ne", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [732, 9], "def_end_pos": [732, 24]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : \u00acc = b\n\u22a2 count a (if (c == b) = true then l else c :: List.erase l b) = count a (c :: l) - if a = b then 1 else 0", "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : \u00acc = b\nhc_beq : (c == b) = false\n\u22a2 count a (if (c == b) = true then l else c :: List.erase l b) = count a (c :: l) - if a = b then 1 else 0"}, {"tactic": "simp only [hc_beq, if_false, count_cons, count_cons, count_erase a b l]", "annotated_tactic": ["simp only [hc_beq, <a>if_false</a>, <a>count_cons</a>, <a>count_cons</a>, count_erase a b l]", [{"full_name": "if_false", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [26, 17], "def_end_pos": [26, 25]}, {"full_name": "List.count_cons", "def_path": ".lake/packages/std/Std/Data/List/Count.lean", "def_pos": [137, 9], "def_end_pos": [137, 19]}, {"full_name": "List.count_cons", "def_path": ".lake/packages/std/Std/Data/List/Count.lean", "def_pos": [137, 9], "def_end_pos": [137, 19]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : \u00acc = b\nhc_beq : (c == b) = false\n\u22a2 count a (if (c == b) = true then l else c :: List.erase l b) = count a (c :: l) - if a = b then 1 else 0", "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : \u00acc = b\nhc_beq : (c == b) = false\n\u22a2 ((count a l - if a = b then 1 else 0) + if a = c then 1 else 0) =\n    (count a l + if a = c then 1 else 0) - if a = b then 1 else 0"}, {"tactic": "if ha : a = b then\n  rw [\u2190 ha, eq_comm] at hc\n  rw [if_pos ha, if_neg hc, Nat.add_zero, Nat.add_zero]\nelse\n  rw [if_neg ha, Nat.sub_zero, Nat.sub_zero]", "annotated_tactic": ["if ha : a = b then\n        rw [\u2190 ha, <a>eq_comm</a>] at hc\n        rw [<a>if_pos</a> ha, <a>if_neg</a> hc, <a>Nat.add_zero</a>, <a>Nat.add_zero</a>]\n      else\n        rw [<a>if_neg</a> ha, <a>Nat.sub_zero</a>, <a>Nat.sub_zero</a>]", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "Nat.sub_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [220, 27], "def_end_pos": [220, 35]}, {"full_name": "Nat.sub_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [220, 27], "def_end_pos": [220, 35]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : \u00acc = b\nhc_beq : (c == b) = false\n\u22a2 ((count a l - if a = b then 1 else 0) + if a = c then 1 else 0) =\n    (count a l + if a = c then 1 else 0) - if a = b then 1 else 0", "state_after": "no goals"}, {"tactic": "rw [\u2190 ha, eq_comm] at hc", "annotated_tactic": ["rw [\u2190 ha, <a>eq_comm</a>] at hc", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : \u00acc = b\nhc_beq : (c == b) = false\nha : a = b\n\u22a2 ((count a l - if a = b then 1 else 0) + if a = c then 1 else 0) =\n    (count a l + if a = c then 1 else 0) - if a = b then 1 else 0", "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : \u00aca = c\nhc_beq : (c == b) = false\nha : a = b\n\u22a2 ((count a l - if a = b then 1 else 0) + if a = c then 1 else 0) =\n    (count a l + if a = c then 1 else 0) - if a = b then 1 else 0"}, {"tactic": "rw [if_pos ha, if_neg hc, Nat.add_zero, Nat.add_zero]", "annotated_tactic": ["rw [<a>if_pos</a> ha, <a>if_neg</a> hc, <a>Nat.add_zero</a>, <a>Nat.add_zero</a>]", [{"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : \u00aca = c\nhc_beq : (c == b) = false\nha : a = b\n\u22a2 ((count a l - if a = b then 1 else 0) + if a = c then 1 else 0) =\n    (count a l + if a = c then 1 else 0) - if a = b then 1 else 0", "state_after": "no goals"}, {"tactic": "rw [if_neg ha, Nat.sub_zero, Nat.sub_zero]", "annotated_tactic": ["rw [<a>if_neg</a> ha, <a>Nat.sub_zero</a>, <a>Nat.sub_zero</a>]", [{"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "Nat.sub_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [220, 27], "def_end_pos": [220, 35]}, {"full_name": "Nat.sub_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [220, 27], "def_end_pos": [220, 35]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\nl : List \u03b1\nhc : \u00acc = b\nhc_beq : (c == b) = false\nha : \u00aca = b\n\u22a2 ((count a l - if a = b then 1 else 0) + if a = c then 1 else 0) =\n    (count a l + if a = c then 1 else 0) - if a = b then 1 else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/FullSubcategory.lean", "full_name": "CategoryTheory.fullSubcategoryInclusion.obj", "start": [131, 1], "end": [132, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.support_erase", "start": [1254, 1], "end": [1259, 57], "traced_tactics": [{"tactic": "ext j", "annotated_tactic": ["ext j", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 support (erase i f) = Finset.erase (support f) i", "state_after": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\n\u22a2 j \u2208 support (erase i f) \u2194 j \u2208 Finset.erase (support f) i"}, {"tactic": "by_cases h1 : j = i", "annotated_tactic": ["by_cases h1 : j = i", []], "state_before": "case a\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\n\u22a2 j \u2208 support (erase i f) \u2194 j \u2208 Finset.erase (support f) i", "state_after": "case pos\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\nh1 : j = i\n\u22a2 j \u2208 support (erase i f) \u2194 j \u2208 Finset.erase (support f) i\n\ncase neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\nh1 : \u00acj = i\n\u22a2 j \u2208 support (erase i f) \u2194 j \u2208 Finset.erase (support f) i"}, {"tactic": "simp only [h1, mem_support_toFun, erase_apply, ite_true, ne_eq, not_true, not_not,\n  Finset.mem_erase, false_and]", "annotated_tactic": ["simp only [h1, <a>mem_support_toFun</a>, <a>erase_apply</a>, <a>ite_true</a>, <a>ne_eq</a>, <a>not_true</a>, <a>not_not</a>,\n    <a>Finset.mem_erase</a>, <a>false_and</a>]", [{"full_name": "DFinsupp.mem_support_toFun", "def_path": ".lake/packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [1130, 9], "def_end_pos": [1130, 26]}, {"full_name": "DFinsupp.erase_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [766, 9], "def_end_pos": [766, 20]}, {"full_name": "ite_true", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [88, 17], "def_end_pos": [88, 25]}, {"full_name": "ne_eq", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [86, 17], "def_end_pos": [86, 22]}, {"full_name": "not_true", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1357, 9], "def_end_pos": [1357, 17]}, {"full_name": "Classical.not_not", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [128, 24], "def_end_pos": [128, 31]}, {"full_name": "Finset.mem_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1922, 9], "def_end_pos": [1922, 18]}, {"full_name": "false_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [104, 17], "def_end_pos": [104, 26]}]], "state_before": "case pos\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\nh1 : j = i\n\u22a2 j \u2208 support (erase i f) \u2194 j \u2208 Finset.erase (support f) i\n\ncase neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\nh1 : \u00acj = i\n\u22a2 j \u2208 support (erase i f) \u2194 j \u2208 Finset.erase (support f) i", "state_after": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\nh1 : \u00acj = i\n\u22a2 j \u2208 support (erase i f) \u2194 j \u2208 Finset.erase (support f) i"}, {"tactic": "by_cases h2 : f j \u2260 0 <;> simp at h2 <;> simp [h1, h2]", "annotated_tactic": ["by_cases h2 : f j \u2260 0 <;> simp at h2 <;> simp [h1, h2]", []], "state_before": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ni : \u03b9\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nj : \u03b9\nh1 : \u00acj = i\n\u22a2 j \u2208 support (erase i f) \u2194 j \u2208 Finset.erase (support f) i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Pointwise.lean", "full_name": "ball_mul_one", "start": [236, 1], "end": [236, 87], "traced_tactics": [{"tactic": "rw [mul_comm, mul_ball_one]", "annotated_tactic": ["rw [<a>mul_comm</a>, <a>mul_ball_one</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "mul_ball_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Pointwise.lean", "def_pos": [221, 9], "def_end_pos": [221, 21]}]], "state_before": "E : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y : E\n\u22a2 ball 1 \u03b4 * s = thickening \u03b4 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Prime.lean", "full_name": "mem_list_primes_of_dvd_prod", "start": [52, 1], "end": [55, 54], "traced_tactics": [{"tactic": "obtain \u27e8x, hx1, hx2\u27e9 := hp.dvd_prod_iff.mp hpL", "annotated_tactic": ["obtain \u27e8x, hx1, hx2\u27e9 := hp.dvd_prod_iff.mp hpL", []], "state_before": "M : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero M\ninst\u271d : Unique M\u02e3\np : M\nhp : Prime p\nL : List M\nhL : \u2200 q \u2208 L, Prime q\nhpL : p \u2223 prod L\n\u22a2 p \u2208 L", "state_after": "case intro.intro\nM : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero M\ninst\u271d : Unique M\u02e3\np : M\nhp : Prime p\nL : List M\nhL : \u2200 q \u2208 L, Prime q\nhpL : p \u2223 prod L\nx : M\nhx1 : x \u2208 L\nhx2 : p \u2223 x\n\u22a2 p \u2208 L"}, {"tactic": "rwa [(prime_dvd_prime_iff_eq hp (hL x hx1)).mp hx2]", "annotated_tactic": ["rwa [(<a>prime_dvd_prime_iff_eq</a> hp (hL x hx1)).<a>mp</a> hx2]", [{"full_name": "prime_dvd_prime_iff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [761, 9], "def_end_pos": [761, 31]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "case intro.intro\nM : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero M\ninst\u271d : Unique M\u02e3\np : M\nhp : Prime p\nL : List M\nhL : \u2200 q \u2208 L, Prime q\nhpL : p \u2223 prod L\nx : M\nhx1 : x \u2208 L\nhx2 : p \u2223 x\n\u22a2 p \u2208 L", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "contDiffOn_of_subsingleton", "start": [122, 1], "end": [123, 62], "traced_tactics": [{"tactic": "rw [Subsingleton.elim f fun _ => 0]", "annotated_tactic": ["rw [<a>Subsingleton.elim</a> f fun _ => 0]", [{"full_name": "Subsingleton.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1010, 19], "def_end_pos": [1010, 36]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u00b9\u2070 : NormedAddCommGroup D\ninst\u271d\u2079 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u2074 : NormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup X\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\ninst\u271d : Subsingleton F\n\u22a2 ContDiffOn \ud835\udd5c n f s", "state_after": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u00b9\u2070 : NormedAddCommGroup D\ninst\u271d\u2079 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u2074 : NormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup X\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\ninst\u271d : Subsingleton F\n\u22a2 ContDiffOn \ud835\udd5c n (fun x => 0) s"}, {"tactic": "exact contDiffOn_const", "annotated_tactic": ["exact <a>contDiffOn_const</a>", [{"full_name": "contDiffOn_const", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "def_pos": [94, 9], "def_end_pos": [94, 25]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u00b9\u2070 : NormedAddCommGroup D\ninst\u271d\u2079 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u2074 : NormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup X\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\ninst\u271d : Subsingleton F\n\u22a2 ContDiffOn \ud835\udd5c n (fun x => 0) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/TensorProduct/Basic.lean", "full_name": "TensorProduct.map_one", "start": [887, 1], "end": [888, 9], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Monoid.lean", "full_name": "nhds_one_mul_nhds", "start": [149, 1], "end": [152, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Surjective.exists\u2083", "start": [228, 11], "end": [230, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Interval.lean", "full_name": "Nat.card_fintypeIoo", "start": [159, 1], "end": [160, 39], "traced_tactics": [{"tactic": "rw [Fintype.card_ofFinset, card_Ioo]", "annotated_tactic": ["rw [<a>Fintype.card_ofFinset</a>, <a>card_Ioo</a>]", [{"full_name": "Fintype.card_ofFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [132, 9], "def_end_pos": [132, 22]}, {"full_name": "Nat.card_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Interval.lean", "def_pos": [113, 9], "def_end_pos": [113, 17]}]], "state_before": "a b c : \u2115\n\u22a2 Fintype.card \u2191(Set.Ioo a b) = b - a - 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iInf\u2082_le", "start": [750, 1], "end": [751, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LocalizedModule.lean", "full_name": "isLocalizedModule_iff_isLocalization", "start": [600, 1], "end": [611, 91], "traced_tactics": [{"tactic": "rw [isLocalizedModule_iff, isLocalization_iff]", "annotated_tactic": ["rw [<a>isLocalizedModule_iff</a>, <a>isLocalization_iff</a>]", [{"full_name": "isLocalizedModule_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LocalizedModule.lean", "def_pos": [554, 3], "def_end_pos": [554, 9]}, {"full_name": "isLocalization_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [98, 3], "def_end_pos": [98, 9]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\n\u22a2 IsLocalizedModule S (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) \u2194\n    IsLocalization (Algebra.algebraMapSubmonoid A S) A\u209b", "state_after": "R : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\n\u22a2 ((\u2200 (x : \u21a5S), IsUnit ((algebraMap R (Module.End R A\u209b)) \u2191x)) \u2227\n      (\u2200 (y : A\u209b), \u2203 x, x.2 \u2022 y = (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x.1) \u2227\n        \u2200 {x\u2081 x\u2082 : A},\n          (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x\u2081 =\n              (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x\u2082 \u2192\n            \u2203 c, c \u2022 x\u2081 = c \u2022 x\u2082) \u2194\n    (\u2200 (y : \u21a5(Algebra.algebraMapSubmonoid A S)), IsUnit ((algebraMap A A\u209b) \u2191y)) \u2227\n      (\u2200 (z : A\u209b), \u2203 x, z * (algebraMap A A\u209b) \u2191x.2 = (algebraMap A A\u209b) x.1) \u2227\n        \u2200 {x y : A}, (algebraMap A A\u209b) x = (algebraMap A A\u209b) y \u2192 \u2203 c, \u2191c * x = \u2191c * y"}, {"tactic": "refine and_congr ?_ (and_congr (forall_congr' fun _ \u21a6 ?_) (forall\u2082_congr fun _ _ \u21a6 ?_))", "annotated_tactic": ["refine <a>and_congr</a> ?_ (<a>and_congr</a> (<a>forall_congr'</a> fun _ \u21a6 ?_) (<a>forall\u2082_congr</a> fun _ _ \u21a6 ?_))", [{"full_name": "and_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [28, 9], "def_end_pos": [28, 18]}, {"full_name": "and_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [28, 9], "def_end_pos": [28, 18]}, {"full_name": "forall_congr'", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}, {"full_name": "forall\u2082_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [148, 9], "def_end_pos": [148, 22]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\n\u22a2 ((\u2200 (x : \u21a5S), IsUnit ((algebraMap R (Module.End R A\u209b)) \u2191x)) \u2227\n      (\u2200 (y : A\u209b), \u2203 x, x.2 \u2022 y = (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x.1) \u2227\n        \u2200 {x\u2081 x\u2082 : A},\n          (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x\u2081 =\n              (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x\u2082 \u2192\n            \u2203 c, c \u2022 x\u2081 = c \u2022 x\u2082) \u2194\n    (\u2200 (y : \u21a5(Algebra.algebraMapSubmonoid A S)), IsUnit ((algebraMap A A\u209b) \u2191y)) \u2227\n      (\u2200 (z : A\u209b), \u2203 x, z * (algebraMap A A\u209b) \u2191x.2 = (algebraMap A A\u209b) x.1) \u2227\n        \u2200 {x y : A}, (algebraMap A A\u209b) x = (algebraMap A A\u209b) y \u2192 \u2203 c, \u2191c * x = \u2191c * y", "state_after": "case refine_1\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\n\u22a2 (\u2200 (x : \u21a5S), IsUnit ((algebraMap R (Module.End R A\u209b)) \u2191x)) \u2194\n    \u2200 (y : \u21a5(Algebra.algebraMapSubmonoid A S)), IsUnit ((algebraMap A A\u209b) \u2191y)\n\ncase refine_2\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d : A\u209b\n\u22a2 (\u2203 x, x.2 \u2022 x\u271d = (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x.1) \u2194\n    \u2203 x, x\u271d * (algebraMap A A\u209b) \u2191x.2 = (algebraMap A A\u209b) x.1\n\ncase refine_3\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d\u00b9 x\u271d : A\n\u22a2 ((AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x\u271d\u00b9 = (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x\u271d \u2192\n      \u2203 c, c \u2022 x\u271d\u00b9 = c \u2022 x\u271d) \u2194\n    (algebraMap A A\u209b) x\u271d\u00b9 = (algebraMap A A\u209b) x\u271d \u2192 \u2203 c, \u2191c * x\u271d\u00b9 = \u2191c * x\u271d"}, {"tactic": "simp_rw [\u2190 (Algebra.lmul R A\u209b).commutes, Algebra.lmul_isUnit_iff, Subtype.forall,\n  Algebra.algebraMapSubmonoid, \u2190 SetLike.mem_coe, Submonoid.coe_map,\n  Set.forall_mem_image, \u2190 IsScalarTower.algebraMap_apply]", "annotated_tactic": ["simp_rw [\u2190 (<a>Algebra.lmul</a> R A\u209b).<a>commutes</a>, <a>Algebra.lmul_isUnit_iff</a>, <a>Subtype.forall</a>,\n      <a>Algebra.algebraMapSubmonoid</a>, \u2190 <a>SetLike.mem_coe</a>, <a>Submonoid.coe_map</a>,\n      <a>Set.forall_mem_image</a>, \u2190 <a>IsScalarTower.algebraMap_apply</a>]", [{"full_name": "Algebra.lmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Bilinear.lean", "def_pos": [172, 5], "def_end_pos": [172, 24]}, {"full_name": "AlgHom.commutes", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [232, 9], "def_end_pos": [232, 17]}, {"full_name": "Algebra.lmul_isUnit_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Bilinear.lean", "def_pos": [200, 9], "def_end_pos": [200, 39]}, {"full_name": "Subtype.forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [43, 19], "def_end_pos": [43, 27]}, {"full_name": "Algebra.algebraMapSubmonoid", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [557, 5], "def_end_pos": [557, 24]}, {"full_name": "SetLike.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [180, 9], "def_end_pos": [180, 16]}, {"full_name": "Submonoid.coe_map", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [228, 9], "def_end_pos": [228, 16]}, {"full_name": "Set.forall_mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [224, 9], "def_end_pos": [224, 25]}, {"full_name": "IsScalarTower.algebraMap_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Tower.lean", "def_pos": [130, 9], "def_end_pos": [130, 25]}]], "state_before": "case refine_1\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\n\u22a2 (\u2200 (x : \u21a5S), IsUnit ((algebraMap R (Module.End R A\u209b)) \u2191x)) \u2194\n    \u2200 (y : \u21a5(Algebra.algebraMapSubmonoid A S)), IsUnit ((algebraMap A A\u209b) \u2191y)", "state_after": "no goals"}, {"tactic": "simp_rw [Prod.exists, Subtype.exists, Algebra.algebraMapSubmonoid]", "annotated_tactic": ["simp_rw [<a>Prod.exists</a>, <a>Subtype.exists</a>, <a>Algebra.algebraMapSubmonoid</a>]", [{"full_name": "Prod.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [40, 9], "def_end_pos": [40, 17]}, {"full_name": "Subtype.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [54, 19], "def_end_pos": [54, 27]}, {"full_name": "Algebra.algebraMapSubmonoid", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [557, 5], "def_end_pos": [557, 24]}]], "state_before": "case refine_2\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d : A\u209b\n\u22a2 (\u2203 x, x.2 \u2022 x\u271d = (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x.1) \u2194\n    \u2203 x, x\u271d * (algebraMap A A\u209b) \u2191x.2 = (algebraMap A A\u209b) x.1", "state_after": "case refine_2\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d : A\u209b\n\u22a2 (\u2203 a a_1,\n      \u2203 (b : a_1 \u2208 S), { val := a_1, property := b } \u2022 x\u271d = (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) a) \u2194\n    \u2203 a a_1, \u2203 (_ : a_1 \u2208 Submonoid.map (algebraMap R A) S), x\u271d * (algebraMap A A\u209b) a_1 = (algebraMap A A\u209b) a"}, {"tactic": "simp [\u2190 IsScalarTower.algebraMap_apply, Submonoid.mk_smul, Algebra.smul_def, mul_comm]", "annotated_tactic": ["simp [\u2190 <a>IsScalarTower.algebraMap_apply</a>, <a>Submonoid.mk_smul</a>, <a>Algebra.smul_def</a>, <a>mul_comm</a>]", [{"full_name": "IsScalarTower.algebraMap_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Tower.lean", "def_pos": [130, 9], "def_end_pos": [130, 25]}, {"full_name": "Submonoid.mk_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [1457, 7], "def_end_pos": [1457, 14]}, {"full_name": "Algebra.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "case refine_2\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d : A\u209b\n\u22a2 (\u2203 a a_1,\n      \u2203 (b : a_1 \u2208 S), { val := a_1, property := b } \u2022 x\u271d = (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) a) \u2194\n    \u2203 a a_1, \u2203 (_ : a_1 \u2208 Submonoid.map (algebraMap R A) S), x\u271d * (algebraMap A A\u209b) a_1 = (algebraMap A A\u209b) a", "state_after": "no goals"}, {"tactic": "congr!", "annotated_tactic": ["congr!", []], "state_before": "case refine_3\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d\u00b9 x\u271d : A\n\u22a2 ((AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x\u271d\u00b9 = (AlgHom.toLinearMap (IsScalarTower.toAlgHom R A A\u209b)) x\u271d \u2192\n      \u2203 c, c \u2022 x\u271d\u00b9 = c \u2022 x\u271d) \u2194\n    (algebraMap A A\u209b) x\u271d\u00b9 = (algebraMap A A\u209b) x\u271d \u2192 \u2203 c, \u2191c * x\u271d\u00b9 = \u2191c * x\u271d", "state_after": "case refine_3.a.h'.a\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d\u00b9 x\u271d : A\na\u271d : (algebraMap A A\u209b) x\u271d\u00b9 = (algebraMap A A\u209b) x\u271d\n\u22a2 (\u2203 c, c \u2022 x\u271d\u00b9 = c \u2022 x\u271d) \u2194 \u2203 c, \u2191c * x\u271d\u00b9 = \u2191c * x\u271d"}, {"tactic": "simp_rw [Subtype.exists, Algebra.algebraMapSubmonoid]", "annotated_tactic": ["simp_rw [<a>Subtype.exists</a>, <a>Algebra.algebraMapSubmonoid</a>]", [{"full_name": "Subtype.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [54, 19], "def_end_pos": [54, 27]}, {"full_name": "Algebra.algebraMapSubmonoid", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [557, 5], "def_end_pos": [557, 24]}]], "state_before": "case refine_3.a.h'.a\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d\u00b9 x\u271d : A\na\u271d : (algebraMap A A\u209b) x\u271d\u00b9 = (algebraMap A A\u209b) x\u271d\n\u22a2 (\u2203 c, c \u2022 x\u271d\u00b9 = c \u2022 x\u271d) \u2194 \u2203 c, \u2191c * x\u271d\u00b9 = \u2191c * x\u271d", "state_after": "case refine_3.a.h'.a\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d\u00b9 x\u271d : A\na\u271d : (algebraMap A A\u209b) x\u271d\u00b9 = (algebraMap A A\u209b) x\u271d\n\u22a2 (\u2203 a, \u2203 (b : a \u2208 S), { val := a, property := b } \u2022 x\u271d\u00b9 = { val := a, property := b } \u2022 x\u271d) \u2194\n    \u2203 a, \u2203 (_ : a \u2208 Submonoid.map (algebraMap R A) S), a * x\u271d\u00b9 = a * x\u271d"}, {"tactic": "simp [Algebra.smul_def]", "annotated_tactic": ["simp [<a>Algebra.smul_def</a>]", [{"full_name": "Algebra.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}]], "state_before": "case refine_3.a.h'.a\nR : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M'\ninst\u271d\u00b9\u2074 : AddCommMonoid M''\nA\u271d : Type u_5\ninst\u271d\u00b9\u00b3 : CommSemiring A\u271d\ninst\u271d\u00b9\u00b2 : Algebra R A\u271d\ninst\u271d\u00b9\u00b9 : Module A\u271d M'\ninst\u271d\u00b9\u2070 : IsLocalization S A\u271d\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R M'\ninst\u271d\u2077 : Module R M''\ninst\u271d\u2076 : IsScalarTower R A\u271d M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nA : Type u_6\nA\u209b : Type u_7\ninst\u271d\u2075 : CommSemiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : CommSemiring A\u209b\ninst\u271d\u00b2 : Algebra A A\u209b\ninst\u271d\u00b9 : Algebra R A\u209b\ninst\u271d : IsScalarTower R A A\u209b\nx\u271d\u00b9 x\u271d : A\na\u271d : (algebraMap A A\u209b) x\u271d\u00b9 = (algebraMap A A\u209b) x\u271d\n\u22a2 (\u2203 a, \u2203 (b : a \u2208 S), { val := a, property := b } \u2022 x\u271d\u00b9 = { val := a, property := b } \u2022 x\u271d) \u2194\n    \u2203 a, \u2203 (_ : a \u2208 Submonoid.map (algebraMap R A) S), a * x\u271d\u00b9 = a * x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.subtypeEquivRight_apply", "start": [1215, 1], "end": [1216, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pi.lean", "full_name": "Filter.coprod\u1d62_eq_bot_iff'", "start": [243, 1], "end": [245, 33], "traced_tactics": [{"tactic": "simpa only [not_neBot, not_and_or, funext_iff, not_forall, not_exists, not_nonempty_iff]\n  using coprod\u1d62_neBot_iff'.not", "annotated_tactic": ["simpa only [<a>not_neBot</a>, <a>not_and_or</a>, <a>funext_iff</a>, <a>not_forall</a>, <a>not_exists</a>, <a>not_nonempty_iff</a>]\n    using coprod\u1d62_neBot_iff'.not", [{"full_name": "Filter.not_neBot", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [521, 17], "def_end_pos": [521, 26]}, {"full_name": "not_and_or", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [483, 9], "def_end_pos": [483, 19]}, {"full_name": "Function.funext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 19]}, {"full_name": "Classical.not_forall", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [130, 17], "def_end_pos": [130, 27]}, {"full_name": "not_exists", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [187, 17], "def_end_pos": [187, 27]}, {"full_name": "not_nonempty_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [137, 9], "def_end_pos": [137, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\np : (i : \u03b9) \u2192 \u03b1 i \u2192 Prop\n\u22a2 Filter.coprod\u1d62 f = \u22a5 \u2194 (\u2203 i, IsEmpty (\u03b1 i)) \u2228 f = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Comp.lean", "full_name": "HasStrictDerivAt.scomp", "start": [93, 1], "end": [95, 66], "traced_tactics": [{"tactic": "simpa using ((hg.restrictScalars \ud835\udd5c).comp x hh).hasStrictDerivAt", "annotated_tactic": ["simpa using ((hg.restrictScalars \ud835\udd5c).<a>comp</a> x hh).<a>hasStrictDerivAt</a>", [{"full_name": "HasStrictFDerivAt.comp", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Comp.lean", "def_pos": [191, 19], "def_end_pos": [191, 41]}, {"full_name": "HasStrictFDerivAt.hasStrictDerivAt", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "def_pos": [205, 19], "def_end_pos": [205, 53]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u00b2 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c' F\ninst\u271d : IsScalarTower \ud835\udd5c \ud835\udd5c' F\ns' t' : Set \ud835\udd5c'\nh : \ud835\udd5c \u2192 \ud835\udd5c'\nh\u2081 : \ud835\udd5c \u2192 \ud835\udd5c\nh\u2082 : \ud835\udd5c' \u2192 \ud835\udd5c'\nh' h\u2082' : \ud835\udd5c'\nh\u2081' : \ud835\udd5c\ng\u2081 : \ud835\udd5c' \u2192 F\ng\u2081' : F\nL' : Filter \ud835\udd5c'\nhg : HasStrictDerivAt g\u2081 g\u2081' (h x)\nhh : HasStrictDerivAt h h' x\n\u22a2 HasStrictDerivAt (g\u2081 \u2218 h) (h' \u2022 g\u2081') x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "Basis.ext_linearIsometry", "start": [1203, 1], "end": [1205, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Segment.lean", "full_name": "openSegment_subset_iff_segment_subset", "start": [158, 1], "end": [160, 81], "traced_tactics": [{"tactic": "simp only [\u2190 insert_endpoints_openSegment, insert_subset_iff, *, true_and_iff]", "annotated_tactic": ["simp only [\u2190 <a>insert_endpoints_openSegment</a>, <a>insert_subset_iff</a>, *, <a>true_and_iff</a>]", [{"full_name": "insert_endpoints_openSegment", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Convex/Segment.lean", "def_pos": [137, 9], "def_end_pos": [137, 37]}, {"full_name": "Set.insert_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1139, 9], "def_end_pos": [1139, 26]}, {"full_name": "true_and_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [140, 9], "def_end_pos": [140, 21]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d\u00b2 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\nx y z : E\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 openSegment \ud835\udd5c x y \u2286 s \u2194 [x-[\ud835\udd5c]y] \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.mul_iSup", "start": [648, 1], "end": [655, 31], "traced_tactics": [{"tactic": "by_cases hf : \u2200 i, f i = 0", "annotated_tactic": ["by_cases hf : \u2200 i, f i = 0", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\n\u22a2 a * iSup f = \u2a06 i, a * f i", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u2200 (i : \u03b9), f i = 0\n\u22a2 a * iSup f = \u2a06 i, a * f i\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u00ac\u2200 (i : \u03b9), f i = 0\n\u22a2 a * iSup f = \u2a06 i, a * f i"}, {"tactic": "obtain rfl : f = fun _ => 0", "annotated_tactic": ["obtain rfl : f = fun _ => 0", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u2200 (i : \u03b9), f i = 0\n\u22a2 a * iSup f = \u2a06 i, a * f i", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u2200 (i : \u03b9), f i = 0\n\u22a2 f = fun x => 0\n\ncase pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\na : \u211d\u22650\u221e\nhf : \u2200 (i : \u03b9), (fun x => 0) i = 0\n\u22a2 a * \u2a06 x, 0 = \u2a06 i, a * (fun x => 0) i"}, {"tactic": "exact funext hf", "annotated_tactic": ["exact <a>funext</a> hf", [{"full_name": "funext", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1805, 9], "def_end_pos": [1805, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u2200 (i : \u03b9), f i = 0\n\u22a2 f = fun x => 0\n\ncase pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\na : \u211d\u22650\u221e\nhf : \u2200 (i : \u03b9), (fun x => 0) i = 0\n\u22a2 a * \u2a06 x, 0 = \u2a06 i, a * (fun x => 0) i", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\na : \u211d\u22650\u221e\nhf : \u2200 (i : \u03b9), (fun x => 0) i = 0\n\u22a2 a * \u2a06 x, 0 = \u2a06 i, a * (fun x => 0) i"}, {"tactic": "simp only [iSup_zero_eq_zero, mul_zero]", "annotated_tactic": ["simp only [<a>iSup_zero_eq_zero</a>, <a>mul_zero</a>]", [{"full_name": "ENNReal.iSup_zero_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [658, 9], "def_end_pos": [658, 26]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\na : \u211d\u22650\u221e\nhf : \u2200 (i : \u03b9), (fun x => 0) i = 0\n\u22a2 a * \u2a06 x, 0 = \u2a06 i, a * (fun x => 0) i", "state_after": "no goals"}, {"tactic": "refine' (monotone_id.const_mul' _).map_iSup_of_continuousAt _ (mul_zero a)", "annotated_tactic": ["refine' (monotone_id.const_mul' _).<a>map_iSup_of_continuousAt</a> _ (<a>mul_zero</a> a)", [{"full_name": "Monotone.map_iSup_of_continuousAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [1984, 9], "def_end_pos": [1984, 42]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u00ac\u2200 (i : \u03b9), f i = 0\n\u22a2 a * iSup f = \u2a06 i, a * f i", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u00ac\u2200 (i : \u03b9), f i = 0\n\u22a2 ContinuousAt (fun x => a * id x) (\u2a06 i, f i)"}, {"tactic": "refine' ENNReal.Tendsto.const_mul tendsto_id (Or.inl _)", "annotated_tactic": ["refine' <a>ENNReal.Tendsto.const_mul</a> <a>tendsto_id</a> (<a>Or.inl</a> _)", [{"full_name": "ENNReal.Tendsto.const_mul", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [383, 19], "def_end_pos": [383, 36]}, {"full_name": "Filter.tendsto_id", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3065, 9], "def_end_pos": [3065, 19]}, {"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u00ac\u2200 (i : \u03b9), f i = 0\n\u22a2 ContinuousAt (fun x => a * id x) (\u2a06 i, f i)", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u00ac\u2200 (i : \u03b9), f i = 0\n\u22a2 id (\u2a06 i, f i) \u2260 0"}, {"tactic": "exact mt iSup_eq_zero.1 hf", "annotated_tactic": ["exact <a>mt</a> <a>iSup_eq_zero</a>.1 hf", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "ENNReal.iSup_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [653, 9], "def_end_pos": [653, 21]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\n\u03b9 : Sort u_4\nf : \u03b9 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nhf : \u00ac\u2200 (i : \u03b9), f i = 0\n\u22a2 id (\u2a06 i, f i) \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Option/NAry.lean", "full_name": "Option.map\u2082_right_comm", "start": [140, 1], "end": [143, 61], "traced_tactics": [{"tactic": "cases a <;> cases b <;> cases c <;> simp [h_right_comm]", "annotated_tactic": ["cases a <;> cases b <;> cases c <;> simp [h_right_comm]", []], "state_before": "\u03b1 : Type u_5\n\u03b2 : Type u_6\n\u03b3 : Type u_4\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\na : Option \u03b1\nb : Option \u03b2\nc : Option \u03b3\n\u03b4 : Type u_1\n\u03b5 : Type u_2\n\u03b4' : Type u_3\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nf' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\ng' : \u03b4' \u2192 \u03b2 \u2192 \u03b5\nh_right_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), f (g a b) c = g' (f' a c) b\n\u22a2 map\u2082 f (map\u2082 g a b) c = map\u2082 g' (map\u2082 f' a c) b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Inv.lean", "full_name": "ENNReal.lt_inv_iff_lt_inv", "start": [214, 1], "end": [215, 55], "traced_tactics": [{"tactic": "simpa only [inv_inv] using @ENNReal.inv_lt_inv a\u207b\u00b9 b", "annotated_tactic": ["simpa only [<a>inv_inv</a>] using @<a>ENNReal.inv_lt_inv</a> a\u207b\u00b9 b", [{"full_name": "inv_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 16]}, {"full_name": "ENNReal.inv_lt_inv", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Inv.lean", "def_pos": [206, 19], "def_end_pos": [206, 29]}]], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u22a2 a < b\u207b\u00b9 \u2194 b < a\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "PartialHomeomorph.contDiffOn_restrContDiff_source", "start": [1981, 1], "end": [1982, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "bddAbove_Iic", "start": [540, 1], "end": [541, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioc_top", "start": [1020, 1], "end": [1020, 63], "traced_tactics": [{"tactic": "simp [\u2190 Ioi_inter_Iic]", "annotated_tactic": ["simp [\u2190 <a>Ioi_inter_Iic</a>]", [{"full_name": "Set.Ioi_inter_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [626, 9], "def_end_pos": [626, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : OrderTop \u03b1\na : \u03b1\n\u22a2 Ioc a \u22a4 = Ioi a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "mul_le_mul_of_nonpos_right", "start": [360, 1], "end": [366, 71], "traced_tactics": [{"tactic": "obtain \u27e8d, hcd\u27e9 := exists_add_of_le hc", "annotated_tactic": ["obtain \u27e8d, hcd\u27e9 := <a>exists_add_of_le</a> hc", [{"full_name": "ExistsAddOfLE.exists_add_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [34, 3], "def_end_pos": [34, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b2 : OrderedSemiring \u03b1\na b c d : \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (swap fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : b \u2264 a\nhc : c \u2264 0\n\u22a2 a * c \u2264 b * c", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b2 : OrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (swap fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : b \u2264 a\nhc : c \u2264 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c \u2264 b * c"}, {"tactic": "refine le_of_add_le_add_right (a := b * d + a * d) ?_", "annotated_tactic": ["refine <a>le_of_add_le_add_right</a> (a := b * d + a * d) ?_", [{"full_name": "le_of_add_le_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [74, 15], "def_end_pos": [74, 37]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b2 : OrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (swap fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : b \u2264 a\nhc : c \u2264 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c \u2264 b * c", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b2 : OrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (swap fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : b \u2264 a\nhc : c \u2264 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c + (b * d + a * d) \u2264 b * c + (b * d + a * d)"}, {"tactic": "calc\n  _ = b * d := by rw [add_left_comm, \u2190 mul_add, \u2190 hcd, mul_zero, add_zero]\n  _ \u2264 a * d := mul_le_mul_of_nonneg_right h <| hcd.trans_le <| add_le_of_nonpos_left hc\n  _ = _ := by rw [\u2190 add_assoc, \u2190 mul_add, \u2190 hcd, mul_zero, zero_add]", "annotated_tactic": ["calc\n    _ = b * d := by rw [<a>add_left_comm</a>, \u2190 <a>mul_add</a>, \u2190 hcd, <a>mul_zero</a>, <a>add_zero</a>]\n    _ \u2264 a * d := <a>mul_le_mul_of_nonneg_right</a> h <| hcd.trans_le <| <a>add_le_of_nonpos_left</a> hc\n    _ = _ := by rw [\u2190 <a>add_assoc</a>, \u2190 <a>mul_add</a>, \u2190 hcd, <a>mul_zero</a>, <a>zero_add</a>]", [{"full_name": "add_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [155, 3], "def_end_pos": [155, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "mul_le_mul_of_nonneg_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [210, 9], "def_end_pos": [210, 35]}, {"full_name": "add_le_of_nonpos_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [418, 15], "def_end_pos": [418, 36]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b2 : OrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (swap fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : b \u2264 a\nhc : c \u2264 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c + (b * d + a * d) \u2264 b * c + (b * d + a * d)", "state_after": "no goals"}, {"tactic": "rw [add_left_comm, \u2190 mul_add, \u2190 hcd, mul_zero, add_zero]", "annotated_tactic": ["rw [<a>add_left_comm</a>, \u2190 <a>mul_add</a>, \u2190 hcd, <a>mul_zero</a>, <a>add_zero</a>]", [{"full_name": "add_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [155, 3], "def_end_pos": [155, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b2 : OrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (swap fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : b \u2264 a\nhc : c \u2264 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c + (b * d + a * d) = b * d", "state_after": "no goals"}, {"tactic": "rw [\u2190 add_assoc, \u2190 mul_add, \u2190 hcd, mul_zero, zero_add]", "annotated_tactic": ["rw [\u2190 <a>add_assoc</a>, \u2190 <a>mul_add</a>, \u2190 hcd, <a>mul_zero</a>, <a>zero_add</a>]", [{"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b2 : OrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (swap fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : b \u2264 a\nhc : c \u2264 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * d = b * c + (b * d + a * d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "InfHom.ext", "start": [562, 1], "end": [563, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Continuum.lean", "full_name": "Cardinal.continuum_add_aleph0", "start": [128, 1], "end": [129, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.filter_single_neg", "start": [718, 1], "end": [719, 65], "traced_tactics": [{"tactic": "rw [filter_single, if_neg h]", "annotated_tactic": ["rw [<a>filter_single</a>, <a>if_neg</a> h]", [{"full_name": "DFinsupp.filter_single", "def_path": ".lake/packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [701, 9], "def_end_pos": [701, 22]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}]], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\ni : \u03b9\nx : \u03b2 i\nh : \u00acp i\n\u22a2 filter p (single i x) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Associated.comm", "start": [404, 11], "end": [405, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LocallyFinite.lean", "full_name": "Ici_ofDual", "start": [914, 1], "end": [915, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.insert_val'", "start": [1107, 1], "end": [1108, 38], "traced_tactics": [{"tactic": "rw [dedup_cons, dedup_eq_self]", "annotated_tactic": ["rw [<a>dedup_cons</a>, <a>dedup_eq_self</a>]", [{"full_name": "Multiset.dedup_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/FinsetOps.lean", "def_pos": [83, 9], "def_end_pos": [83, 19]}, {"full_name": "Finset.dedup_eq_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [166, 9], "def_end_pos": [166, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t u v : Finset \u03b1\na\u271d b a : \u03b1\ns : Finset \u03b1\n\u22a2 (insert a s).val = dedup (a ::\u2098 s.val)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t u v : Finset \u03b1\na\u271d b a : \u03b1\ns : Finset \u03b1\n\u22a2 (insert a s).val = ndinsert a s.val"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t u v : Finset \u03b1\na\u271d b a : \u03b1\ns : Finset \u03b1\n\u22a2 (insert a s).val = ndinsert a s.val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Separable.lean", "full_name": "Polynomial.Separable.mul", "start": [220, 1], "end": [224, 99], "traced_tactics": [{"tactic": "rw [separable_def, derivative_mul]", "annotated_tactic": ["rw [<a>separable_def</a>, <a>derivative_mul</a>]", [{"full_name": "Polynomial.separable_def", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Separable.lean", "def_pos": [44, 9], "def_end_pos": [44, 22]}, {"full_name": "Polynomial.derivative_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [296, 9], "def_end_pos": [296, 23]}]], "state_before": "R : Type u\ninst\u271d : CommRing R\nf g : R[X]\nhf : Separable f\nhg : Separable g\nh : IsCoprime f g\n\u22a2 Separable (f * g)", "state_after": "R : Type u\ninst\u271d : CommRing R\nf g : R[X]\nhf : Separable f\nhg : Separable g\nh : IsCoprime f g\n\u22a2 IsCoprime (f * g) (derivative f * g + f * derivative g)"}, {"tactic": "exact\n  ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _)", "annotated_tactic": ["exact\n    ((hf.mul_right h).<a>add_mul_left_right</a> _).<a>mul_left</a> ((h.symm.mul_right hg).<a>mul_add_right_right</a> _)", [{"full_name": "IsCoprime.add_mul_left_right", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Coprime/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 27]}, {"full_name": "IsCoprime.mul_left", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Coprime/Basic.lean", "def_pos": [114, 9], "def_end_pos": [114, 27]}, {"full_name": "IsCoprime.mul_add_right_right", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Coprime/Basic.lean", "def_pos": [358, 9], "def_end_pos": [358, 28]}]], "state_before": "R : Type u\ninst\u271d : CommRing R\nf g : R[X]\nhf : Separable f\nhg : Separable g\nh : IsCoprime f g\n\u22a2 IsCoprime (f * g) (derivative f * g + f * derivative g)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/IsEmpty.lean", "full_name": "isEmpty_psum", "start": [195, 1], "end": [196, 56], "traced_tactics": [{"tactic": "simp only [\u2190 not_nonempty_iff, nonempty_psum, not_or]", "annotated_tactic": ["simp only [\u2190 <a>not_nonempty_iff</a>, <a>nonempty_psum</a>, <a>not_or</a>]", [{"full_name": "not_nonempty_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [137, 9], "def_end_pos": [137, 25]}, {"full_name": "nonempty_psum", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nonempty.lean", "def_pos": [99, 9], "def_end_pos": [99, 22]}, {"full_name": "not_or", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [107, 9], "def_end_pos": [107, 15]}]], "state_before": "\u03b1\u271d : Sort u_1\n\u03b2\u271d : Sort u_2\n\u03b3 : Sort u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u22a2 IsEmpty (\u03b1 \u2295' \u03b2) \u2194 IsEmpty \u03b1 \u2227 IsEmpty \u03b2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.mem_of_mem_getLast?", "start": [729, 1], "end": [731, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.rightAssocTensor_map", "start": [841, 1], "end": [842, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Isometry.lean", "full_name": "Isometry.preimage_emetric_closedBall", "start": [139, 1], "end": [142, 20], "traced_tactics": [{"tactic": "ext y", "annotated_tactic": ["ext y", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u2192 \u03b2\nx\u271d y z : \u03b1\ns : Set \u03b1\nh : Isometry f\nx : \u03b1\nr : \u211d\u22650\u221e\n\u22a2 f \u207b\u00b9' EMetric.closedBall (f x) r = EMetric.closedBall x r", "state_after": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u2192 \u03b2\nx\u271d y\u271d z : \u03b1\ns : Set \u03b1\nh : Isometry f\nx : \u03b1\nr : \u211d\u22650\u221e\ny : \u03b1\n\u22a2 y \u2208 f \u207b\u00b9' EMetric.closedBall (f x) r \u2194 y \u2208 EMetric.closedBall x r"}, {"tactic": "simp [h.edist_eq]", "annotated_tactic": ["simp [h.edist_eq]", []], "state_before": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u2192 \u03b2\nx\u271d y\u271d z : \u03b1\ns : Set \u03b1\nh : Isometry f\nx : \u03b1\nr : \u211d\u22650\u221e\ny : \u03b1\n\u22a2 y \u2208 f \u207b\u00b9' EMetric.closedBall (f x) r \u2194 y \u2208 EMetric.closedBall x r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.map_le_iff", "start": [1237, 1], "end": [1241, 18], "traced_tactics": [{"tactic": "erw [\u2190 toDual_le_toDual_iff, toDual_map, toDual_map, WithBot.map_le_iff, toDual_le_toDual_iff]", "annotated_tactic": ["erw [\u2190 <a>toDual_le_toDual_iff</a>, <a>toDual_map</a>, <a>toDual_map</a>, <a>WithBot.map_le_iff</a>, <a>toDual_le_toDual_iff</a>]", [{"full_name": "WithTop.toDual_le_toDual_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [868, 9], "def_end_pos": [868, 29]}, {"full_name": "WithTop.toDual_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [820, 9], "def_end_pos": [820, 19]}, {"full_name": "WithTop.toDual_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [820, 9], "def_end_pos": [820, 19]}, {"full_name": "WithBot.map_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [416, 9], "def_end_pos": [416, 19]}, {"full_name": "WithTop.toDual_le_toDual_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [868, 9], "def_end_pos": [868, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na b : WithTop \u03b1\nmono_iff : \u2200 {a b : \u03b1}, f a \u2264 f b \u2194 a \u2264 b\n\u22a2 map f a \u2264 map f b \u2194 a \u2264 b", "state_after": "case mono_iff\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na b : WithTop \u03b1\nmono_iff : \u2200 {a b : \u03b1}, f a \u2264 f b \u2194 a \u2264 b\n\u22a2 \u2200 {a b : \u03b1\u1d52\u1d48}, (\u21d1OrderDual.toDual \u2218 f \u2218 \u21d1OrderDual.ofDual) a \u2264 (\u21d1OrderDual.toDual \u2218 f \u2218 \u21d1OrderDual.ofDual) b \u2194 a \u2264 b"}, {"tactic": "simp [mono_iff]", "annotated_tactic": ["simp [mono_iff]", []], "state_before": "case mono_iff\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na b : WithTop \u03b1\nmono_iff : \u2200 {a b : \u03b1}, f a \u2264 f b \u2194 a \u2264 b\n\u22a2 \u2200 {a b : \u03b1\u1d52\u1d48}, (\u21d1OrderDual.toDual \u2218 f \u2218 \u21d1OrderDual.ofDual) a \u2264 (\u21d1OrderDual.toDual \u2218 f \u2218 \u21d1OrderDual.ofDual) b \u2194 a \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.diff_inter_self_eq_diff", "start": [2028, 1], "end": [2029, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/GaloisConnection.lean", "full_name": "GaloisConnection.exists_eq_u", "start": [187, 1], "end": [188, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Abel.lean", "full_name": "Mathlib.Tactic.Abel.const_add_termg", "start": [131, 1], "end": [133, 44], "traced_tactics": [{"tactic": "simp [h.symm, termg, add_comm, add_assoc]", "annotated_tactic": ["simp [h.symm, <a>termg</a>, <a>add_comm</a>, <a>add_assoc</a>]", [{"full_name": "Mathlib.Tactic.Abel.termg", "def_path": ".lake/packages/mathlib/Mathlib/Tactic/Abel.lean", "def_pos": [92, 5], "def_end_pos": [92, 10]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\nk : \u03b1\nn : \u2124\nx a a' : \u03b1\nh : k + a = a'\n\u22a2 k + termg n x a = termg n x a'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/LocalExtr/Basic.lean", "full_name": "IsLocalExtr.hasDerivAt_eq_zero", "start": [254, 1], "end": [255, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorization/PrimePow.lean", "full_name": "isPrimePow_iff_card_primeFactors_eq_one", "start": [57, 1], "end": [60, 51], "traced_tactics": [{"tactic": "simp_rw [isPrimePow_iff_factorization_eq_single, \u2190 Nat.support_factorization,\n  Finsupp.card_support_eq_one', pos_iff_ne_zero]", "annotated_tactic": ["simp_rw [<a>isPrimePow_iff_factorization_eq_single</a>, \u2190 <a>Nat.support_factorization</a>,\n    <a>Finsupp.card_support_eq_one'</a>, <a>pos_iff_ne_zero</a>]", [{"full_name": "isPrimePow_iff_factorization_eq_single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/PrimePow.lean", "def_pos": [41, 9], "def_end_pos": [41, 47]}, {"full_name": "Nat.support_factorization", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean", "def_pos": [63, 15], "def_end_pos": [63, 36]}, {"full_name": "Finsupp.card_support_eq_one'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [482, 9], "def_end_pos": [482, 29]}, {"full_name": "pos_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [230, 3], "def_end_pos": [230, 14]}]], "state_before": "R : Type u_1\ninst\u271d : CommMonoidWithZero R\nn\u271d p : R\nk n : \u2115\n\u22a2 IsPrimePow n \u2194 n.primeFactors.card = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Perm.lean", "full_name": "List.subperm_of_subset", "start": [421, 1], "end": [426, 64], "traced_tactics": [{"tactic": "exact \u27e8nil, .nil, nil_sublist _\u27e9", "annotated_tactic": ["exact \u27e8<a>nil</a>, .nil, <a>nil_sublist</a> _\u27e9", [{"full_name": "List.nil", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2268, 5], "def_end_pos": [2268, 8]}, {"full_name": "List.nil_sublist", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [499, 17], "def_end_pos": [499, 28]}]], "state_before": "case nil\n\u03b1\u271d : Type u_1\nl\u2081 l\u2082 : List \u03b1\u271d\nH : [] \u2286 l\u2082\n\u22a2 [] <+~ l\u2082", "state_after": "no goals"}, {"tactic": "have \u27e8H\u2081, H\u2082\u27e9 := forall_mem_cons.1 H", "annotated_tactic": ["have \u27e8H\u2081, H\u2082\u27e9 := <a>forall_mem_cons</a>.1 H", [{"full_name": "List.forall_mem_cons", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [157, 9], "def_end_pos": [157, 24]}]], "state_before": "case cons\n\u03b1\u271d : Type u_1\nl\u2081 l\u2082 : List \u03b1\u271d\na\u271d\u00b9 : \u03b1\u271d\nl\u271d : List \u03b1\u271d\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 l\u271d \u2192 a\u271d\u00b9 \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\u271d\nIH : l\u271d \u2286 l\u2082 \u2192 l\u271d <+~ l\u2082\nH : a\u271d\u00b9 :: l\u271d \u2286 l\u2082\n\u22a2 a\u271d\u00b9 :: l\u271d <+~ l\u2082", "state_after": "case cons\n\u03b1\u271d : Type u_1\nl\u2081 l\u2082 : List \u03b1\u271d\na\u271d\u00b9 : \u03b1\u271d\nl\u271d : List \u03b1\u271d\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 l\u271d \u2192 a\u271d\u00b9 \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\u271d\nIH : l\u271d \u2286 l\u2082 \u2192 l\u271d <+~ l\u2082\nH : a\u271d\u00b9 :: l\u271d \u2286 l\u2082\nH\u2081 : a\u271d\u00b9 \u2208 l\u2082\nH\u2082 : \u2200 (x : \u03b1\u271d), x \u2208 l\u271d \u2192 x \u2208 l\u2082\n\u22a2 a\u271d\u00b9 :: l\u271d <+~ l\u2082"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Preimage.lean", "full_name": "Finset.map_subset_iff_subset_preimage", "start": [94, 1], "end": [96, 64], "traced_tactics": [{"tactic": "classical rw [map_eq_image, image_subset_iff_subset_preimage]", "annotated_tactic": ["classical rw [<a>map_eq_image</a>, <a>image_subset_iff_subset_preimage</a>]", [{"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}, {"full_name": "Finset.image_subset_iff_subset_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [89, 9], "def_end_pos": [89, 41]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\nf : \u03b1 \u21aa \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 map f s \u2286 t \u2194 s \u2286 preimage t \u21d1f \u22ef", "state_after": "no goals"}, {"tactic": "rw [map_eq_image, image_subset_iff_subset_preimage]", "annotated_tactic": ["rw [<a>map_eq_image</a>, <a>image_subset_iff_subset_preimage</a>]", [{"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}, {"full_name": "Finset.image_subset_iff_subset_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [89, 9], "def_end_pos": [89, 41]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\nf : \u03b1 \u21aa \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 map f s \u2286 t \u2194 s \u2286 preimage t \u21d1f \u22ef", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Denumerable.lean", "full_name": "Nat.Subtype.ofNat_surjective", "start": [305, 1], "end": [305, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/Bounded.lean", "full_name": "NormedSpace.isVonNBounded_ball", "start": [365, 1], "end": [367, 70], "traced_tactics": [{"tactic": "rw [Metric.nhds_basis_ball.isVonNBounded_iff, \u2190 ball_normSeminorm \ud835\udd5c E]", "annotated_tactic": ["rw [Metric.nhds_basis_ball.isVonNBounded_iff, \u2190 <a>ball_normSeminorm</a> \ud835\udd5c E]", [{"full_name": "ball_normSeminorm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [1408, 9], "def_end_pos": [1408, 26]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nr : \u211d\n\u22a2 Bornology.IsVonNBounded \ud835\udd5c (Metric.ball 0 r)", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nr : \u211d\n\u22a2 \u2200 (i : \u211d), 0 < i \u2192 Absorbs \ud835\udd5c (Seminorm.ball (normSeminorm \ud835\udd5c E) 0 i) (Seminorm.ball (normSeminorm \ud835\udd5c E) 0 r)"}, {"tactic": "exact fun \u03b5 h\u03b5 => (normSeminorm \ud835\udd5c E).ball_zero_absorbs_ball_zero h\u03b5", "annotated_tactic": ["exact fun \u03b5 h\u03b5 => (<a>normSeminorm</a> \ud835\udd5c E).<a>ball_zero_absorbs_ball_zero</a> h\u03b5", [{"full_name": "normSeminorm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [1398, 5], "def_end_pos": [1398, 17]}, {"full_name": "Seminorm.ball_zero_absorbs_ball_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [1024, 9], "def_end_pos": [1024, 36]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nr : \u211d\n\u22a2 \u2200 (i : \u211d), 0 < i \u2192 Absorbs \ud835\udd5c (Seminorm.ball (normSeminorm \ud835\udd5c E) 0 i) (Seminorm.ball (normSeminorm \ud835\udd5c E) 0 r)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_add_prod_eq", "start": [1981, 1], "end": [1986, 47], "traced_tactics": [{"tactic": "classical\n  simp_rw [prod_eq_mul_prod_diff_singleton hi, \u2190 h1, right_distrib]\n  congr 2 <;> apply prod_congr rfl <;> simpa", "annotated_tactic": ["classical\n    simp_rw [<a>prod_eq_mul_prod_diff_singleton</a> hi, \u2190 h1, <a>right_distrib</a>]\n    congr 2 <;> apply <a>prod_congr</a> <a>rfl</a> <;> simpa", [{"full_name": "Finset.prod_eq_mul_prod_diff_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1786, 9], "def_end_pos": [1786, 40]}, {"full_name": "right_distrib", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [86, 9], "def_end_pos": [86, 22]}, {"full_name": "Finset.prod_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 9], "def_end_pos": [382, 19]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d : CommSemiring \u03b2\ns : Finset \u03b1\ni : \u03b1\nf g h : \u03b1 \u2192 \u03b2\nhi : i \u2208 s\nh1 : g i + h i = f i\nh2 : \u2200 j \u2208 s, j \u2260 i \u2192 g j = f j\nh3 : \u2200 j \u2208 s, j \u2260 i \u2192 h j = f j\n\u22a2 \u220f i in s, g i + \u220f i in s, h i = \u220f i in s, f i", "state_after": "no goals"}, {"tactic": "simp_rw [prod_eq_mul_prod_diff_singleton hi, \u2190 h1, right_distrib]", "annotated_tactic": ["simp_rw [<a>prod_eq_mul_prod_diff_singleton</a> hi, \u2190 h1, <a>right_distrib</a>]", [{"full_name": "Finset.prod_eq_mul_prod_diff_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1786, 9], "def_end_pos": [1786, 40]}, {"full_name": "right_distrib", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [86, 9], "def_end_pos": [86, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d : CommSemiring \u03b2\ns : Finset \u03b1\ni : \u03b1\nf g h : \u03b1 \u2192 \u03b2\nhi : i \u2208 s\nh1 : g i + h i = f i\nh2 : \u2200 j \u2208 s, j \u2260 i \u2192 g j = f j\nh3 : \u2200 j \u2208 s, j \u2260 i \u2192 h j = f j\n\u22a2 \u220f i in s, g i + \u220f i in s, h i = \u220f i in s, f i", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d : CommSemiring \u03b2\ns : Finset \u03b1\ni : \u03b1\nf g h : \u03b1 \u2192 \u03b2\nhi : i \u2208 s\nh1 : g i + h i = f i\nh2 : \u2200 j \u2208 s, j \u2260 i \u2192 g j = f j\nh3 : \u2200 j \u2208 s, j \u2260 i \u2192 h j = f j\n\u22a2 g i * \u220f i in s \\ {i}, g i + h i * \u220f i in s \\ {i}, h i = g i * \u220f i in s \\ {i}, f i + h i * \u220f i in s \\ {i}, f i"}, {"tactic": "congr 2 <;> apply prod_congr rfl <;> simpa", "annotated_tactic": ["congr 2 <;> apply <a>prod_congr</a> <a>rfl</a> <;> simpa", [{"full_name": "Finset.prod_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 9], "def_end_pos": [382, 19]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d : CommSemiring \u03b2\ns : Finset \u03b1\ni : \u03b1\nf g h : \u03b1 \u2192 \u03b2\nhi : i \u2208 s\nh1 : g i + h i = f i\nh2 : \u2200 j \u2208 s, j \u2260 i \u2192 g j = f j\nh3 : \u2200 j \u2208 s, j \u2260 i \u2192 h j = f j\n\u22a2 g i * \u220f i in s \\ {i}, g i + h i * \u220f i in s \\ {i}, h i = g i * \u220f i in s \\ {i}, f i + h i * \u220f i in s \\ {i}, f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Between.lean", "full_name": "not_sbtw_self_left", "start": [312, 1], "end": [313, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Reverse.lean", "full_name": "Polynomial.reflect_C_mul_X_pow", "start": [147, 1], "end": [156, 50], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\n\u22a2 reflect N (C c * X ^ n) = C c * X ^ (revAt N) n", "state_after": "case a\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\n\u22a2 coeff (reflect N (C c * X ^ n)) n\u271d = coeff (C c * X ^ (revAt N) n) n\u271d"}, {"tactic": "rw [reflect_C_mul, coeff_C_mul, coeff_C_mul, coeff_X_pow, coeff_reflect]", "annotated_tactic": ["rw [<a>reflect_C_mul</a>, <a>coeff_C_mul</a>, <a>coeff_C_mul</a>, <a>coeff_X_pow</a>, <a>coeff_reflect</a>]", [{"full_name": "Polynomial.reflect_C_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}, {"full_name": "Polynomial.coeff_C_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [168, 9], "def_end_pos": [168, 20]}, {"full_name": "Polynomial.coeff_C_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [168, 9], "def_end_pos": [168, 20]}, {"full_name": "Polynomial.coeff_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [207, 9], "def_end_pos": [207, 20]}, {"full_name": "Polynomial.coeff_reflect", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [114, 9], "def_end_pos": [114, 22]}]], "state_before": "case a\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\n\u22a2 coeff (reflect N (C c * X ^ n)) n\u271d = coeff (C c * X ^ (revAt N) n) n\u271d", "state_after": "case a\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\n\u22a2 c * coeff (X ^ n) ((revAt N) n\u271d) = c * if n\u271d = (revAt N) n then 1 else 0"}, {"tactic": "split_ifs with h", "annotated_tactic": ["split_ifs with h", []], "state_before": "case a\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\n\u22a2 c * coeff (X ^ n) ((revAt N) n\u271d) = c * if n\u271d = (revAt N) n then 1 else 0", "state_after": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : n\u271d = (revAt N) n\n\u22a2 c * coeff (X ^ n) ((revAt N) n\u271d) = c * 1\n\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\n\u22a2 c * coeff (X ^ n) ((revAt N) n\u271d) = c * 0"}, {"tactic": "rw [h, revAt_invol, coeff_X_pow_self]", "annotated_tactic": ["rw [h, <a>revAt_invol</a>, <a>coeff_X_pow_self</a>]", [{"full_name": "Polynomial.revAt_invol", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [72, 9], "def_end_pos": [72, 20]}, {"full_name": "Polynomial.coeff_X_pow_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [211, 9], "def_end_pos": [211, 25]}]], "state_before": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : n\u271d = (revAt N) n\n\u22a2 c * coeff (X ^ n) ((revAt N) n\u271d) = c * 1", "state_after": "no goals"}, {"tactic": "rw [not_mem_support_iff.mp]", "annotated_tactic": ["rw [not_mem_support_iff.mp]", []], "state_before": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\n\u22a2 c * coeff (X ^ n) ((revAt N) n\u271d) = c * 0", "state_after": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\n\u22a2 (revAt N) n\u271d \u2209 support (X ^ n)"}, {"tactic": "intro a", "annotated_tactic": ["intro a", []], "state_before": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\n\u22a2 (revAt N) n\u271d \u2209 support (X ^ n)", "state_after": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\na : (revAt N) n\u271d \u2208 support (X ^ n)\n\u22a2 False"}, {"tactic": "rw [\u2190 one_mul (X ^ n), \u2190 C_1] at a", "annotated_tactic": ["rw [\u2190 <a>one_mul</a> (<a>X</a> ^ n), \u2190 <a>C_1</a>] at a", [{"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.C_1", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [519, 9], "def_end_pos": [519, 12]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\na : (revAt N) n\u271d \u2208 support (X ^ n)\n\u22a2 False", "state_after": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\na : (revAt N) n\u271d \u2208 support (C 1 * X ^ n)\n\u22a2 False"}, {"tactic": "apply h", "annotated_tactic": ["apply h", []], "state_before": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\na : (revAt N) n\u271d \u2208 support (C 1 * X ^ n)\n\u22a2 False", "state_after": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\na : (revAt N) n\u271d \u2208 support (C 1 * X ^ n)\n\u22a2 n\u271d = (revAt N) n"}, {"tactic": "rw [\u2190 mem_support_C_mul_X_pow a, revAt_invol]", "annotated_tactic": ["rw [\u2190 <a>mem_support_C_mul_X_pow</a> a, <a>revAt_invol</a>]", [{"full_name": "Polynomial.mem_support_C_mul_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [484, 9], "def_end_pos": [484, 32]}, {"full_name": "Polynomial.revAt_invol", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [72, 9], "def_end_pos": [72, 20]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN n : \u2115\nc : R\nn\u271d : \u2115\nh : \u00acn\u271d = (revAt N) n\na : (revAt N) n\u271d \u2208 support (C 1 * X ^ n)\n\u22a2 n\u271d = (revAt N) n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "ContinuousLinearMap.contDiff", "start": [165, 1], "end": [166, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/OrderClosed.lean", "full_name": "nhdsWithin_Icc_eq_nhdsWithin_Ici", "start": [600, 1], "end": [601, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.fract_sub_self", "start": [957, 1], "end": [958, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.isMax_iterate_succ_of_eq_of_lt", "start": [288, 1], "end": [294, 71], "traced_tactics": [{"tactic": "refine' max_of_succ_le (le_trans _ h_eq.symm.le)", "annotated_tactic": ["refine' <a>max_of_succ_le</a> (<a>le_trans</a> _ h_eq.symm.le)", [{"full_name": "Order.max_of_succ_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [217, 9], "def_end_pos": [217, 23]}, {"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\n\u22a2 IsMax (succ^[n] a)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\n\u22a2 succ (succ^[n] a) \u2264 succ^[m] a"}, {"tactic": "have : succ (succ^[n] a) = succ^[n + 1] a := by rw [Function.iterate_succ', comp]", "annotated_tactic": ["have : <a>succ</a> (<a>succ</a>^[n] a) = <a>succ</a>^[n + 1] a := by rw [<a>Function.iterate_succ'</a>, <a>comp</a>]", [{"full_name": "Order.succ", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [209, 5], "def_end_pos": [209, 9]}, {"full_name": "Order.succ", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [209, 5], "def_end_pos": [209, 9]}, {"full_name": "Order.succ", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [209, 5], "def_end_pos": [209, 9]}, {"full_name": "Function.iterate_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [186, 9], "def_end_pos": [186, 22]}, {"full_name": "Function.comp", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\n\u22a2 succ (succ^[n] a) \u2264 succ^[m] a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\nthis : succ (succ^[n] a) = succ^[n + 1] a\n\u22a2 succ (succ^[n] a) \u2264 succ^[m] a"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\nthis : succ (succ^[n] a) = succ^[n + 1] a\n\u22a2 succ (succ^[n] a) \u2264 succ^[m] a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\nthis : succ (succ^[n] a) = succ^[n + 1] a\n\u22a2 succ^[n + 1] a \u2264 succ^[m] a"}, {"tactic": "have h_le : n + 1 \u2264 m := Nat.succ_le_of_lt h_lt", "annotated_tactic": ["have h_le : n + 1 \u2264 m := <a>Nat.succ_le_of_lt</a> h_lt", [{"full_name": "Nat.succ_le_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [292, 9], "def_end_pos": [292, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\nthis : succ (succ^[n] a) = succ^[n + 1] a\n\u22a2 succ^[n + 1] a \u2264 succ^[m] a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\nthis : succ (succ^[n] a) = succ^[n + 1] a\nh_le : n + 1 \u2264 m\n\u22a2 succ^[n + 1] a \u2264 succ^[m] a"}, {"tactic": "exact Monotone.monotone_iterate_of_le_map succ_mono (le_succ a) h_le", "annotated_tactic": ["exact <a>Monotone.monotone_iterate_of_le_map</a> <a>succ_mono</a> (<a>le_succ</a> a) h_le", [{"full_name": "Monotone.monotone_iterate_of_le_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Iterate.lean", "def_pos": [233, 9], "def_end_pos": [233, 35]}, {"full_name": "Order.succ_mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [280, 9], "def_end_pos": [280, 18]}, {"full_name": "Order.le_succ", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\nthis : succ (succ^[n] a) = succ^[n + 1] a\nh_le : n + 1 \u2264 m\n\u22a2 succ^[n + 1] a \u2264 succ^[m] a", "state_after": "no goals"}, {"tactic": "rw [Function.iterate_succ', comp]", "annotated_tactic": ["rw [<a>Function.iterate_succ'</a>, <a>comp</a>]", [{"full_name": "Function.iterate_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [186, 9], "def_end_pos": [186, 22]}, {"full_name": "Function.comp", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nn m : \u2115\nh_eq : succ^[n] a = succ^[m] a\nh_lt : n < m\n\u22a2 succ (succ^[n] a) = succ^[n + 1] a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Congruence.lean", "full_name": "Con.lift_mk'", "start": [914, 1], "end": [915, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.findAux_of_valid", "start": [335, 1], "end": [347, 48], "traced_tactics": [{"tactic": "unfold findAux List.takeWhile", "annotated_tactic": ["unfold <a>findAux</a> <a>List.takeWhile</a>", [{"full_name": "String.findAux", "def_path": ".lake/packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [179, 5], "def_end_pos": [179, 12]}, {"full_name": "List.takeWhile", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [544, 5], "def_end_pos": [544, 14]}]], "state_before": "p : Char \u2192 Bool\nl r : List Char\n\u22a2 findAux { data := l ++ [] ++ r } p { byteIdx := utf8Len l + utf8Len [] } { byteIdx := utf8Len l } =\n    { byteIdx := utf8Len l + utf8Len (List.takeWhile (fun x => !p x) []) }", "state_after": "p : Char \u2192 Bool\nl r : List Char\n\u22a2 (if h : { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len [] } then\n      if p (get { data := l ++ [] ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n      else\n        let_fun this := \u22ef;\n        findAux { data := l ++ [] ++ r } p { byteIdx := utf8Len l + utf8Len [] }\n          (next { data := l ++ [] ++ r } { byteIdx := utf8Len l })\n    else { byteIdx := utf8Len l }) =\n    { byteIdx := utf8Len l + utf8Len [] }"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "p : Char \u2192 Bool\nl r : List Char\n\u22a2 (if h : { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len [] } then\n      if p (get { data := l ++ [] ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n      else\n        let_fun this := \u22ef;\n        findAux { data := l ++ [] ++ r } p { byteIdx := utf8Len l + utf8Len [] }\n          (next { data := l ++ [] ++ r } { byteIdx := utf8Len l })\n    else { byteIdx := utf8Len l }) =\n    { byteIdx := utf8Len l + utf8Len [] }", "state_after": "no goals"}, {"tactic": "unfold findAux List.takeWhile", "annotated_tactic": ["unfold <a>findAux</a> <a>List.takeWhile</a>", [{"full_name": "String.findAux", "def_path": ".lake/packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [179, 5], "def_end_pos": [179, 12]}, {"full_name": "List.takeWhile", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [544, 5], "def_end_pos": [544, 14]}]], "state_before": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\n\u22a2 findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) } { byteIdx := utf8Len l } =\n    { byteIdx := utf8Len l + utf8Len (List.takeWhile (fun x => !p x) (c :: m)) }", "state_after": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\n\u22a2 (if h : { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len (c :: m) } then\n      if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n      else\n        let_fun this := \u22ef;\n        findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n          (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })\n    else { byteIdx := utf8Len l }) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }"}, {"tactic": "rw [dif_pos (by exact Nat.lt_add_of_pos_right add_csize_pos)]", "annotated_tactic": ["rw [<a>dif_pos</a> (by exact <a>Nat.lt_add_of_pos_right</a> <a>add_csize_pos</a>)]", [{"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}, {"full_name": "Nat.lt_add_of_pos_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [200, 19], "def_end_pos": [200, 38]}, {"full_name": "_private.\u00ab.lake\u00bb.packages.std.Std.Data.String.Lemmas.0.String.add_csize_pos", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [44, 17], "def_end_pos": [44, 30]}]], "state_before": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\n\u22a2 (if h : { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len (c :: m) } then\n      if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n      else\n        let_fun this := \u22ef;\n        findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n          (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })\n    else { byteIdx := utf8Len l }) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }", "state_after": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\n\u22a2 (if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n    else\n      let_fun this := \u22ef;\n      findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }"}, {"tactic": "have h1 := get_of_valid l (c::m++r)", "annotated_tactic": ["have h1 := <a>get_of_valid</a> l (c::m++r)", [{"full_name": "String.get_of_valid", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [223, 9], "def_end_pos": [223, 21]}]], "state_before": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\n\u22a2 (if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n    else\n      let_fun this := \u22ef;\n      findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }", "state_after": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ (c :: m ++ r) } { byteIdx := utf8Len l } = List.headD (c :: m ++ r) default\n\u22a2 (if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n    else\n      let_fun this := \u22ef;\n      findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }"}, {"tactic": "have h2 := next_of_valid l c (m++r)", "annotated_tactic": ["have h2 := <a>next_of_valid</a> l c (m++r)", [{"full_name": "String.next_of_valid", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [269, 9], "def_end_pos": [269, 22]}]], "state_before": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ (c :: m ++ r) } { byteIdx := utf8Len l } = List.headD (c :: m ++ r) default\n\u22a2 (if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n    else\n      let_fun this := \u22ef;\n      findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }", "state_after": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ (c :: m ++ r) } { byteIdx := utf8Len l } = List.headD (c :: m ++ r) default\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\n\u22a2 (if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n    else\n      let_fun this := \u22ef;\n      findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }"}, {"tactic": "simp at h1 h2", "annotated_tactic": ["simp at h1 h2", []], "state_before": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ (c :: m ++ r) } { byteIdx := utf8Len l } = List.headD (c :: m ++ r) default\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\n\u22a2 (if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n    else\n      let_fun this := \u22ef;\n      findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }", "state_after": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\n\u22a2 (if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n    else\n      let_fun this := \u22ef;\n      findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }"}, {"tactic": "simp [h1, h2]", "annotated_tactic": ["simp [h1, h2]", []], "state_before": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\n\u22a2 (if p (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }) = true then { byteIdx := utf8Len l }\n    else\n      let_fun this := \u22ef;\n      findAux { data := l ++ c :: m ++ r } p { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }", "state_after": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\n\u22a2 (if p c = true then { byteIdx := utf8Len l }\n    else\n      findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n        { byteIdx := utf8Len l + csize c }) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }"}, {"tactic": "cases p c <;> simp", "annotated_tactic": ["cases p c <;> simp", []], "state_before": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\n\u22a2 (if p c = true then { byteIdx := utf8Len l }\n    else\n      findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n        { byteIdx := utf8Len l + csize c }) =\n    {\n      byteIdx :=\n        utf8Len l +\n          utf8Len\n            (match !p c with\n            | true => c :: List.takeWhile (fun x => !p x) m\n            | false => []) }", "state_after": "case false\np : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\n\u22a2 findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + (utf8Len (List.takeWhile (fun x => !p x) m) + csize c) }"}, {"tactic": "have foo := findAux_of_valid p (l++[c]) m r", "annotated_tactic": ["have foo := findAux_of_valid p (l++[c]) m r", []], "state_before": "case false\np : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\n\u22a2 findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + (utf8Len (List.takeWhile (fun x => !p x) m) + csize c) }", "state_after": "case false\np : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\nfoo :\n  findAux { data := l ++ [c] ++ m ++ r } p { byteIdx := utf8Len (l ++ [c]) + utf8Len m }\n      { byteIdx := utf8Len (l ++ [c]) } =\n    { byteIdx := utf8Len (l ++ [c]) + utf8Len (List.takeWhile (fun x => !p x) m) }\n\u22a2 findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + (utf8Len (List.takeWhile (fun x => !p x) m) + csize c) }"}, {"tactic": "simp at foo", "annotated_tactic": ["simp at foo", []], "state_before": "case false\np : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\nfoo :\n  findAux { data := l ++ [c] ++ m ++ r } p { byteIdx := utf8Len (l ++ [c]) + utf8Len m }\n      { byteIdx := utf8Len (l ++ [c]) } =\n    { byteIdx := utf8Len (l ++ [c]) + utf8Len (List.takeWhile (fun x => !p x) m) }\n\u22a2 findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + (utf8Len (List.takeWhile (fun x => !p x) m) + csize c) }", "state_after": "case false\np : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\nfoo :\n  findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + csize c + utf8Len m }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + csize c + utf8Len (List.takeWhile (fun x => !p x) m) }\n\u22a2 findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + (utf8Len (List.takeWhile (fun x => !p x) m) + csize c) }"}, {"tactic": "rw [Nat.add_right_comm, Nat.add_assoc] at foo", "annotated_tactic": ["rw [<a>Nat.add_right_comm</a>, <a>Nat.add_assoc</a>] at foo", [{"full_name": "Nat.add_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}, {"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "case false\np : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\nfoo :\n  findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + csize c + utf8Len m }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + csize c + utf8Len (List.takeWhile (fun x => !p x) m) }\n\u22a2 findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + (utf8Len (List.takeWhile (fun x => !p x) m) + csize c) }", "state_after": "case false\np : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\nfoo :\n  findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + csize c + utf8Len (List.takeWhile (fun x => !p x) m) }\n\u22a2 findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + (utf8Len (List.takeWhile (fun x => !p x) m) + csize c) }"}, {"tactic": "rw [foo, Nat.add_right_comm, Nat.add_assoc]", "annotated_tactic": ["rw [foo, <a>Nat.add_right_comm</a>, <a>Nat.add_assoc</a>]", [{"full_name": "Nat.add_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}, {"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "case false\np : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\nh1 : get { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = c\nh2 : next { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l } = { byteIdx := utf8Len l + csize c }\nfoo :\n  findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + csize c + utf8Len (List.takeWhile (fun x => !p x) m) }\n\u22a2 findAux { data := l ++ c :: (m ++ r) } p { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } =\n    { byteIdx := utf8Len l + (utf8Len (List.takeWhile (fun x => !p x) m) + csize c) }", "state_after": "no goals"}, {"tactic": "exact Nat.lt_add_of_pos_right add_csize_pos", "annotated_tactic": ["exact <a>Nat.lt_add_of_pos_right</a> <a>add_csize_pos</a>", [{"full_name": "Nat.lt_add_of_pos_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [200, 19], "def_end_pos": [200, 38]}, {"full_name": "_private.\u00ab.lake\u00bb.packages.std.Std.Data.String.Lemmas.0.String.add_csize_pos", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [44, 17], "def_end_pos": [44, 30]}]], "state_before": "p : Char \u2192 Bool\nl : List Char\nc : Char\nm r : List Char\n\u22a2 { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len (c :: m) }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/SelfAdjoint.lean", "full_name": "IsSelfAdjoint.conj_eq", "start": [242, 1], "end": [242, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Pi/Lemmas.lean", "full_name": "Pi.mulSingle_commute", "start": [407, 1], "end": [416, 16], "traced_tactics": [{"tactic": "intro i j hij x y", "annotated_tactic": ["intro i j hij x y", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx y : (i : I) \u2192 f i\ni j : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\n\u22a2 Pairwise fun i j => \u2200 (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y)", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\n\u22a2 Commute (mulSingle i x) (mulSingle j y)"}, {"tactic": "ext k", "annotated_tactic": ["ext k", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\n\u22a2 Commute (mulSingle i x) (mulSingle j y)", "state_after": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k"}, {"tactic": "by_cases h1 : i = k", "annotated_tactic": ["by_cases h1 : i = k", []], "state_before": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k", "state_after": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\nh1 : i = k\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k\n\ncase neg\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\nh1 : \u00aci = k\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k"}, {"tactic": "by_cases h2 : j = k", "annotated_tactic": ["by_cases h2 : j = k", []], "state_before": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\nh1 : \u00aci = k\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k", "state_after": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\nh1 : \u00aci = k\nh2 : j = k\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k\n\ncase neg\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\nh1 : \u00aci = k\nh2 : \u00acj = k\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k"}, {"tactic": "simp [h1, h2]", "annotated_tactic": ["simp [h1, h2]", []], "state_before": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\nh1 : \u00aci = k\nh2 : \u00acj = k\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k", "state_after": "no goals"}, {"tactic": "subst h1", "annotated_tactic": ["subst h1", []], "state_before": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\nh1 : i = k\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k", "state_after": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\n\u22a2 (mulSingle i x * mulSingle j y) i = (mulSingle j y * mulSingle i x) i"}, {"tactic": "simp [hij]", "annotated_tactic": ["simp [hij]", []], "state_before": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\n\u22a2 (mulSingle i x * mulSingle j y) i = (mulSingle j y * mulSingle i x) i", "state_after": "no goals"}, {"tactic": "subst h2", "annotated_tactic": ["subst h2", []], "state_before": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nk : I\nh1 : \u00aci = k\nh2 : j = k\n\u22a2 (mulSingle i x * mulSingle j y) k = (mulSingle j y * mulSingle i x) k", "state_after": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nh1 : \u00aci = j\n\u22a2 (mulSingle i x * mulSingle j y) j = (mulSingle j y * mulSingle i x) j"}, {"tactic": "simp [hij]", "annotated_tactic": ["simp [hij]", []], "state_before": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nI : Type u\nf : I \u2192 Type v\nx\u271d y\u271d : (i : I) \u2192 f i\ni\u271d j\u271d : I\ninst\u271d\u00b9 : DecidableEq I\ninst\u271d : (i : I) \u2192 MulOneClass (f i)\ni j : I\nhij : i \u2260 j\nx : f i\ny : f j\nh1 : \u00aci = j\n\u22a2 (mulSingle i x * mulSingle j y) j = (mulSingle j y * mulSingle i x) j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.zipWith_eq_zipWithTR", "start": [176, 10], "end": [181, 28], "traced_tactics": [{"tactic": "funext \u03b1 \u03b2 \u03b3 f as bs", "annotated_tactic": ["funext \u03b1 \u03b2 \u03b3 f as bs", []], "state_before": "\u22a2 @zipWith = @zipWithTR", "state_after": "case h.h.h.h.h.h\n\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nas : List \u03b1\nbs : List \u03b2\n\u22a2 zipWith f as bs = zipWithTR f as bs"}, {"tactic": "exact (go as bs #[]).symm", "annotated_tactic": ["exact (go as bs #[]).<a>symm</a>", [{"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case h.h.h.h.h.h\n\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nas : List \u03b1\nbs : List \u03b2\n\u22a2 zipWith f as bs = zipWithTR f as bs", "state_after": "no goals"}, {"tactic": "simp [zipWithTR.go, zipWith]", "annotated_tactic": ["simp [<a>zipWithTR.go</a>, <a>zipWith</a>]", [{"full_name": "List.zipWithTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [172, 3], "def_end_pos": [172, 5]}, {"full_name": "List.zipWith", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [594, 19], "def_end_pos": [594, 26]}]], "state_before": "\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nas : List \u03b1\nbs : List \u03b2\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nacc : Array \u03b3\n\u22a2 zipWithTR.go f (head\u271d :: tail\u271d) [] acc = acc.data ++ zipWith f (head\u271d :: tail\u271d) []", "state_after": "no goals"}, {"tactic": "simp [zipWithTR.go, zipWith, go as bs]", "annotated_tactic": ["simp [<a>zipWithTR.go</a>, <a>zipWith</a>, go as bs]", [{"full_name": "List.zipWithTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [172, 3], "def_end_pos": [172, 5]}, {"full_name": "List.zipWith", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [594, 19], "def_end_pos": [594, 26]}]], "state_before": "\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nas\u271d : List \u03b1\nbs\u271d : List \u03b2\na : \u03b1\nas : List \u03b1\nb : \u03b2\nbs : List \u03b2\nacc : Array \u03b3\n\u22a2 zipWithTR.go f (a :: as) (b :: bs) acc = acc.data ++ zipWith f (a :: as) (b :: bs)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Real.lean", "full_name": "ENNReal.toNNReal_strict_mono", "start": [132, 1], "end": [133, 45], "traced_tactics": [{"tactic": "simpa [\u2190 ENNReal.coe_lt_coe, hb, h.ne_top]", "annotated_tactic": ["simpa [\u2190 <a>ENNReal.coe_lt_coe</a>, hb, h.ne_top]", [{"full_name": "ENNReal.coe_lt_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [379, 28], "def_end_pos": [379, 38]}]], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhb : b \u2260 \u22a4\nh : a < b\n\u22a2 a.toNNReal < b.toNNReal", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Ray.lean", "full_name": "SameRay.zero_right", "start": [58, 1], "end": [59, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Congruence.lean", "full_name": "RingCon.coe_sub", "start": [255, 1], "end": [256, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.mk_bit0", "start": [639, 1], "end": [641, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "Decidable.and_forall_ne", "start": [744, 1], "end": [746, 85], "traced_tactics": [{"tactic": "simp only [\u2190 @forall_eq _ p a, \u2190 forall_and, \u2190 or_imp, Decidable.em, forall_const]", "annotated_tactic": ["simp only [\u2190 @<a>forall_eq</a> _ p a, \u2190 <a>forall_and</a>, \u2190 <a>or_imp</a>, <a>Decidable.em</a>, <a>forall_const</a>]", [{"full_name": "forall_eq", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [206, 17], "def_end_pos": [206, 26]}, {"full_name": "forall_and", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [189, 9], "def_end_pos": [189, 19]}, {"full_name": "or_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 15]}, {"full_name": "Decidable.em", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [871, 9], "def_end_pos": [871, 11]}, {"full_name": "forall_const", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [198, 17], "def_end_pos": [198, 29]}]], "state_before": "\u03b9 : Sort ?u.12586\n\u03b1 : Sort u_2\n\u03ba : \u03b9 \u2192 Sort u_1\np\u271d q : \u03b1 \u2192 Prop\ninst\u271d : DecidableEq \u03b1\na : \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (p a \u2227 \u2200 (b : \u03b1), b \u2260 a \u2192 p b) \u2194 \u2200 (b : \u03b1), p b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "measurable_of_measurable_on_compl_finite", "start": [681, 1], "end": [684, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Defs.lean", "full_name": "tsub_eq_of_eq_add", "start": [344, 1], "end": [345, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/Over.lean", "full_name": "CategoryTheory.Under.under_left", "start": [366, 1], "end": [366, 65], "traced_tactics": [{"tactic": "simp only", "annotated_tactic": ["simp only", []], "state_before": "T : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} T\nX : T\nU : Under X\n\u22a2 U.left = { as := PUnit.unit }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Function.invFunOn_mem", "start": [1253, 1], "end": [1254, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.SameCycle.of_zpow", "start": [204, 1], "end": [205, 33], "traced_tactics": [{"tactic": "simp [zpow_mul, h]", "annotated_tactic": ["simp [<a>zpow_mul</a>, h]", [{"full_name": "zpow_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [342, 33], "def_end_pos": [342, 41]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\np : \u03b1 \u2192 Prop\nx y z : \u03b1\nn : \u2124\nx\u271d : SameCycle (f ^ n) x y\nm : \u2124\nh : ((f ^ n) ^ m) x = y\n\u22a2 (f ^ (n * m)) x = y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "Pi.bot_def", "start": [605, 1], "end": [606, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean", "full_name": "Polynomial.cyclotomic_injective", "start": [146, 1], "end": [166, 54], "traced_tactics": [{"tactic": "intro n m hnm", "annotated_tactic": ["intro n m hnm", []], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\n\u22a2 Function.Injective fun n => cyclotomic n R", "state_after": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : (fun n => cyclotomic n R) n = (fun n => cyclotomic n R) m\n\u22a2 n = m"}, {"tactic": "simp only at hnm", "annotated_tactic": ["simp only at hnm", []], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : (fun n => cyclotomic n R) n = (fun n => cyclotomic n R) m\n\u22a2 n = m", "state_after": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : cyclotomic n R = cyclotomic m R\n\u22a2 n = m"}, {"tactic": "rcases eq_or_ne n 0 with (rfl | hzero)", "annotated_tactic": ["rcases <a>eq_or_ne</a> n 0 with (rfl | hzero)", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : cyclotomic n R = cyclotomic m R\n\u22a2 n = m", "state_after": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : cyclotomic 0 R = cyclotomic m R\n\u22a2 0 = m\n\ncase inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : cyclotomic n R = cyclotomic m R\nhzero : n \u2260 0\n\u22a2 n = m"}, {"tactic": "rw [cyclotomic_zero] at hnm", "annotated_tactic": ["rw [<a>cyclotomic_zero</a>] at hnm", [{"full_name": "Polynomial.cyclotomic_zero", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [304, 9], "def_end_pos": [304, 24]}]], "state_before": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : cyclotomic 0 R = cyclotomic m R\n\u22a2 0 = m", "state_after": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : 1 = cyclotomic m R\n\u22a2 0 = m"}, {"tactic": "replace hnm := congr_arg natDegree hnm", "annotated_tactic": ["replace hnm := <a>congr_arg</a> <a>natDegree</a> hnm", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "Polynomial.natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [69, 5], "def_end_pos": [69, 14]}]], "state_before": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : 1 = cyclotomic m R\n\u22a2 0 = m", "state_after": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : natDegree 1 = natDegree (cyclotomic m R)\n\u22a2 0 = m"}, {"tactic": "rw [natDegree_one, natDegree_cyclotomic] at hnm", "annotated_tactic": ["rw [<a>natDegree_one</a>, <a>natDegree_cyclotomic</a>] at hnm", [{"full_name": "Polynomial.natDegree_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [276, 9], "def_end_pos": [276, 22]}, {"full_name": "Polynomial.natDegree_cyclotomic", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [348, 9], "def_end_pos": [348, 29]}]], "state_before": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : natDegree 1 = natDegree (cyclotomic m R)\n\u22a2 0 = m", "state_after": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : 0 = Nat.totient m\n\u22a2 0 = m"}, {"tactic": "by_contra h", "annotated_tactic": ["by_contra h", []], "state_before": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : 0 = Nat.totient m\n\u22a2 0 = m", "state_after": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : 0 = Nat.totient m\nh : \u00ac0 = m\n\u22a2 False"}, {"tactic": "exact (Nat.totient_pos (zero_lt_iff.2 (Ne.symm h))).ne hnm", "annotated_tactic": ["exact (<a>Nat.totient_pos</a> (<a>zero_lt_iff</a>.2 (<a>Ne.symm</a> h))).<a>ne</a> hnm", [{"full_name": "Nat.totient_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Totient.lean", "def_pos": [70, 9], "def_end_pos": [70, 20]}, {"full_name": "zero_lt_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/WithZero.lean", "def_pos": [103, 9], "def_end_pos": [103, 20]}, {"full_name": "Ne.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [702, 9], "def_end_pos": [702, 16]}, {"full_name": "LT.lt.ne", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [149, 7], "def_end_pos": [149, 15]}]], "state_before": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharZero R\nm : \u2115\nhnm : 0 = Nat.totient m\nh : \u00ac0 = m\n\u22a2 False", "state_after": "no goals"}, {"tactic": "haveI := NeZero.mk hzero", "annotated_tactic": ["haveI := <a>NeZero.mk</a> hzero", [{"full_name": "NeZero.mk", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [25, 7], "def_end_pos": [25, 13]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : cyclotomic n R = cyclotomic m R\nhzero : n \u2260 0\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : cyclotomic n R = cyclotomic m R\nhzero : n \u2260 0\nthis : NeZero n\n\u22a2 n = m"}, {"tactic": "rw [\u2190 map_cyclotomic_int _ R, \u2190 map_cyclotomic_int _ R] at hnm", "annotated_tactic": ["rw [\u2190 <a>map_cyclotomic_int</a> _ R, \u2190 <a>map_cyclotomic_int</a> _ R] at hnm", [{"full_name": "Polynomial.map_cyclotomic_int", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [266, 9], "def_end_pos": [266, 27]}, {"full_name": "Polynomial.map_cyclotomic_int", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [266, 9], "def_end_pos": [266, 27]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : cyclotomic n R = cyclotomic m R\nhzero : n \u2260 0\nthis : NeZero n\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : map (Int.castRingHom R) (cyclotomic n \u2124) = map (Int.castRingHom R) (cyclotomic m \u2124)\nhzero : n \u2260 0\nthis : NeZero n\n\u22a2 n = m"}, {"tactic": "replace hnm := map_injective (Int.castRingHom R) Int.cast_injective hnm", "annotated_tactic": ["replace hnm := <a>map_injective</a> (<a>Int.castRingHom</a> R) <a>Int.cast_injective</a> hnm", [{"full_name": "Polynomial.map_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [853, 9], "def_end_pos": [853, 22]}, {"full_name": "Int.castRingHom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [81, 5], "def_end_pos": [81, 16]}, {"full_name": "Int.cast_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/CharZero.lean", "def_pos": [39, 9], "def_end_pos": [39, 23]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhnm : map (Int.castRingHom R) (cyclotomic n \u2124) = map (Int.castRingHom R) (cyclotomic m \u2124)\nhzero : n \u2260 0\nthis : NeZero n\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2124 = cyclotomic m \u2124\n\u22a2 n = m"}, {"tactic": "replace hnm := congr_arg (map (Int.castRingHom \u2102)) hnm", "annotated_tactic": ["replace hnm := <a>congr_arg</a> (<a>map</a> (<a>Int.castRingHom</a> \u2102)) hnm", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "Polynomial.map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [710, 5], "def_end_pos": [710, 8]}, {"full_name": "Int.castRingHom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [81, 5], "def_end_pos": [81, 16]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2124 = cyclotomic m \u2124\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : map (Int.castRingHom \u2102) (cyclotomic n \u2124) = map (Int.castRingHom \u2102) (cyclotomic m \u2124)\n\u22a2 n = m"}, {"tactic": "rw [map_cyclotomic_int, map_cyclotomic_int] at hnm", "annotated_tactic": ["rw [<a>map_cyclotomic_int</a>, <a>map_cyclotomic_int</a>] at hnm", [{"full_name": "Polynomial.map_cyclotomic_int", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [266, 9], "def_end_pos": [266, 27]}, {"full_name": "Polynomial.map_cyclotomic_int", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [266, 9], "def_end_pos": [266, 27]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : map (Int.castRingHom \u2102) (cyclotomic n \u2124) = map (Int.castRingHom \u2102) (cyclotomic m \u2124)\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\n\u22a2 n = m"}, {"tactic": "have hprim := Complex.isPrimitiveRoot_exp _ hzero", "annotated_tactic": ["have hprim := <a>Complex.isPrimitiveRoot_exp</a> _ hzero", [{"full_name": "Complex.isPrimitiveRoot_exp", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/RootsOfUnity/Complex.lean", "def_pos": [52, 9], "def_end_pos": [52, 28]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\n\u22a2 n = m"}, {"tactic": "have hroot := isRoot_cyclotomic_iff (R := \u2102).2 hprim", "annotated_tactic": ["have hroot := <a>isRoot_cyclotomic_iff</a> (R := \u2102).2 hprim", [{"full_name": "Polynomial.isRoot_cyclotomic_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean", "def_pos": [102, 9], "def_end_pos": [102, 30]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\nhroot : IsRoot (cyclotomic n \u2102) (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n))\n\u22a2 n = m"}, {"tactic": "rw [hnm] at hroot", "annotated_tactic": ["rw [hnm] at hroot", []], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\nhroot : IsRoot (cyclotomic n \u2102) (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n))\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\nhroot : IsRoot (cyclotomic m \u2102) (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n))\n\u22a2 n = m"}, {"tactic": "haveI hmzero : NeZero m := \u27e8fun h => by simp [h] at hroot\u27e9", "annotated_tactic": ["haveI hmzero : <a>NeZero</a> m := \u27e8fun h => by simp [h] at hroot\u27e9", [{"full_name": "NeZero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [25, 7], "def_end_pos": [25, 13]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\nhroot : IsRoot (cyclotomic m \u2102) (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n))\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\nhroot : IsRoot (cyclotomic m \u2102) (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n))\nhmzero : NeZero m\n\u22a2 n = m"}, {"tactic": "rw [isRoot_cyclotomic_iff (R := \u2102)] at hroot", "annotated_tactic": ["rw [<a>isRoot_cyclotomic_iff</a> (R := \u2102)] at hroot", [{"full_name": "Polynomial.isRoot_cyclotomic_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean", "def_pos": [102, 9], "def_end_pos": [102, 30]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\nhroot : IsRoot (cyclotomic m \u2102) (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n))\nhmzero : NeZero m\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\nhroot : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) m\nhmzero : NeZero m\n\u22a2 n = m"}, {"tactic": "replace hprim := hprim.eq_orderOf", "annotated_tactic": ["replace hprim := hprim.eq_orderOf", []], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\nhroot : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) m\nhmzero : NeZero m\n\u22a2 n = m", "state_after": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhroot : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) m\nhmzero : NeZero m\nhprim : n = orderOf (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n))\n\u22a2 n = m"}, {"tactic": "rwa [\u2190 IsPrimitiveRoot.eq_orderOf hroot] at hprim", "annotated_tactic": ["rwa [\u2190 <a>IsPrimitiveRoot.eq_orderOf</a> hroot] at hprim", [{"full_name": "IsPrimitiveRoot.eq_orderOf", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/RootsOfUnity/Basic.lean", "def_pos": [463, 9], "def_end_pos": [463, 19]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhroot : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) m\nhmzero : NeZero m\nhprim : n = orderOf (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n))\n\u22a2 n = m", "state_after": "no goals"}, {"tactic": "simp [h] at hroot", "annotated_tactic": ["simp [h] at hroot", []], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn\u271d : \u2115\ninst\u271d : CharZero R\nn m : \u2115\nhzero : n \u2260 0\nthis : NeZero n\nhnm : cyclotomic n \u2102 = cyclotomic m \u2102\nhprim : IsPrimitiveRoot (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n)) n\nhroot : IsRoot (cyclotomic m \u2102) (Complex.exp (2 * \u2191Real.pi * Complex.I / \u2191n))\nh : m = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "mul_pos_iff_of_pos_left", "start": [414, 1], "end": [415, 67], "traced_tactics": [{"tactic": "simpa using mul_lt_mul_left (b := 0) h", "annotated_tactic": ["simpa using <a>mul_lt_mul_left</a> (b := 0) h", [{"full_name": "mul_lt_mul_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [253, 9], "def_end_pos": [253, 24]}]], "state_before": "\u03b1 : Type u_1\na b c d : \u03b1\ninst\u271d\u00b3 : MulZeroClass \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PosMulStrictMono \u03b1\ninst\u271d : PosMulReflectLT \u03b1\nh : 0 < a\n\u22a2 0 < a * b \u2194 0 < b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/GDelta.lean", "full_name": "IsG\u03b4.singleton", "start": [211, 11], "end": [214, 59], "traced_tactics": [{"tactic": "rcases (nhds_basis_opens x).exists_antitone_subbasis with \u27e8U, hU, h_basis\u27e9", "annotated_tactic": ["rcases (<a>nhds_basis_opens</a> x).<a>exists_antitone_subbasis</a> with \u27e8U, hU, h_basis\u27e9", [{"full_name": "nhds_basis_opens", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [791, 9], "def_end_pos": [791, 25]}, {"full_name": "Filter.HasBasis.exists_antitone_subbasis", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [1098, 9], "def_end_pos": [1098, 42]}]], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : FirstCountableTopology X\nx : X\n\u22a2 IsG\u03b4 {x}", "state_after": "case intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : FirstCountableTopology X\nx : X\nU : \u2115 \u2192 Set X\nhU : \u2200 (i : \u2115), x \u2208 U i \u2227 IsOpen (U i)\nh_basis : HasAntitoneBasis (\ud835\udcdd x) fun i => U i\n\u22a2 IsG\u03b4 {x}"}, {"tactic": "rw [\u2190 biInter_basis_nhds h_basis.toHasBasis]", "annotated_tactic": ["rw [\u2190 <a>biInter_basis_nhds</a> h_basis.toHasBasis]", [{"full_name": "biInter_basis_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [696, 9], "def_end_pos": [696, 27]}]], "state_before": "case intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : FirstCountableTopology X\nx : X\nU : \u2115 \u2192 Set X\nhU : \u2200 (i : \u2115), x \u2208 U i \u2227 IsOpen (U i)\nh_basis : HasAntitoneBasis (\ud835\udcdd x) fun i => U i\n\u22a2 IsG\u03b4 {x}", "state_after": "case intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : FirstCountableTopology X\nx : X\nU : \u2115 \u2192 Set X\nhU : \u2200 (i : \u2115), x \u2208 U i \u2227 IsOpen (U i)\nh_basis : HasAntitoneBasis (\ud835\udcdd x) fun i => U i\n\u22a2 IsG\u03b4 (\u22c2 i, \u22c2 (_ : True), U i)"}, {"tactic": "exact .biInter (to_countable _) fun n _ => (hU n).2.isG\u03b4", "annotated_tactic": ["exact .biInter (<a>to_countable</a> _) fun n _ => (hU n).2.<a>isG\u03b4</a>", [{"full_name": "Set.to_countable", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [53, 9], "def_end_pos": [53, 21]}, {"full_name": "IsOpen.isG\u03b4", "def_path": ".lake/packages/mathlib/Mathlib/Topology/GDelta.lean", "def_pos": [64, 9], "def_end_pos": [64, 20]}]], "state_before": "case intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : T1Space X\ninst\u271d : FirstCountableTopology X\nx : X\nU : \u2115 \u2192 Set X\nhU : \u2200 (i : \u2115), x \u2208 U i \u2227 IsOpen (U i)\nh_basis : HasAntitoneBasis (\ud835\udcdd x) fun i => U i\n\u22a2 IsG\u03b4 (\u22c2 i, \u22c2 (_ : True), U i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sym/Sym2.lean", "full_name": "Sym2.exists", "start": [160, 11], "end": [162, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.dedup_eq_self", "start": [166, 1], "end": [167, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.succ_mono", "start": [280, 1], "end": [280, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "full_name": "Cardinal.beth_zero", "start": [418, 1], "end": [419, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Preimage.lean", "full_name": "Finset.prod_preimage_of_bij", "start": [165, 1], "end": [168, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Lemmas.lean", "full_name": "Int.strictMonoOn_natAbs", "start": [100, 1], "end": [101, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Closure.lean", "full_name": "LowerAdjoint.closure_iSup\u2082_closure", "start": [456, 1], "end": [458, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.val_le_iff", "start": [386, 1], "end": [387, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "nhds_false", "start": [895, 1], "end": [896, 74], "traced_tactics": [{"tactic": "simp [@and_comm (_ \u2208 _)]", "annotated_tactic": ["simp [@<a>and_comm</a> (_ \u2208 _)]", [{"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 \u2a05 s \u2208 {s | False \u2208 s \u2227 s \u2208 {{True}}}, \ud835\udcdf s = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "continuousAt_def", "start": [1535, 1], "end": [1536, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/PathConnected.lean", "full_name": "Inseparable.joinedIn", "start": [890, 1], "end": [891, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isBigO_prod_left", "start": [1055, 1], "end": [1056, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Notation.lean", "full_name": "Matrix.cons_val'", "start": [138, 1], "end": [139, 94], "traced_tactics": [{"tactic": "refine' Fin.cases _ _ i <;> simp", "annotated_tactic": ["refine' <a>Fin.cases</a> _ _ i <;> simp", [{"full_name": "Fin.cases", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [636, 21], "def_end_pos": [636, 26]}]], "state_before": "\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\nv : n' \u2192 \u03b1\nB : Fin m \u2192 n' \u2192 \u03b1\ni : Fin (Nat.succ m)\nj : n'\n\u22a2 vecCons v B i j = vecCons (v j) (fun i => B i j) i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.finite_coe_iff", "start": [69, 1], "end": [69, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/IntegrallyClosed.lean", "full_name": "IsIntegrallyClosed.exists_algebraMap_eq_of_pow_mem_subalgebra", "start": [96, 1], "end": [99, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "norm_pow_le_mul_norm", "start": [1681, 1], "end": [1683, 92], "traced_tactics": [{"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na\u271d a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nn : \u2115\na : E\n\u22a2 \u2016a ^ n\u2016 \u2264 \u2191n * \u2016a\u2016", "state_after": "case zero\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na\u271d a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\na : E\n\u22a2 \u2016a ^ Nat.zero\u2016 \u2264 \u2191Nat.zero * \u2016a\u2016\n\ncase succ\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na\u271d a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\na : E\nn : \u2115\nih : \u2016a ^ n\u2016 \u2264 \u2191n * \u2016a\u2016\n\u22a2 \u2016a ^ Nat.succ n\u2016 \u2264 \u2191(Nat.succ n) * \u2016a\u2016"}, {"tactic": "simpa only [pow_succ', Nat.cast_succ, add_mul, one_mul] using norm_mul_le_of_le ih le_rfl", "annotated_tactic": ["simpa only [<a>pow_succ'</a>, <a>Nat.cast_succ</a>, <a>add_mul</a>, <a>one_mul</a>] using <a>norm_mul_le_of_le</a> ih <a>le_rfl</a>", [{"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}, {"full_name": "Nat.cast_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [131, 9], "def_end_pos": [131, 18]}, {"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "norm_mul_le_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [536, 9], "def_end_pos": [536, 26]}, {"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}]], "state_before": "case succ\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na\u271d a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\na : E\nn : \u2115\nih : \u2016a ^ n\u2016 \u2264 \u2191n * \u2016a\u2016\n\u22a2 \u2016a ^ Nat.succ n\u2016 \u2264 \u2191(Nat.succ n) * \u2016a\u2016", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na\u271d a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\na : E\n\u22a2 \u2016a ^ Nat.zero\u2016 \u2264 \u2191Nat.zero * \u2016a\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Periodic.lean", "full_name": "Function.Periodic.int_mul", "start": [234, 11], "end": [235, 44], "traced_tactics": [{"tactic": "simpa only [zsmul_eq_mul] using h.zsmul n", "annotated_tactic": ["simpa only [<a>zsmul_eq_mul</a>] using h.zsmul n", [{"full_name": "zsmul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [110, 15], "def_end_pos": [110, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf g : \u03b1 \u2192 \u03b2\nc c\u2081 c\u2082 x : \u03b1\ninst\u271d : Ring \u03b1\nh : Periodic f c\nn : \u2124\n\u22a2 Periodic f (\u2191n * c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.image\u2082_left_identity", "start": [488, 1], "end": [490, 81], "traced_tactics": [{"tactic": "rw [coe_image\u2082, coe_singleton, Set.image2_left_identity h]", "annotated_tactic": ["rw [<a>coe_image\u2082</a>, <a>coe_singleton</a>, <a>Set.image2_left_identity</a> h]", [{"full_name": "Finset.coe_image\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [49, 9], "def_end_pos": [49, 19]}, {"full_name": "Finset.coe_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [731, 9], "def_end_pos": [731, 22]}, {"full_name": "Set.image2_left_identity", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [362, 7], "def_end_pos": [362, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu u' : Finset \u03b3\na\u271d a' : \u03b1\nb b' : \u03b2\nc : \u03b3\nf : \u03b1 \u2192 \u03b3 \u2192 \u03b3\na : \u03b1\nh : \u2200 (b : \u03b3), f a b = b\nt : Finset \u03b3\n\u22a2 \u2191(image\u2082 f {a} t) = \u2191t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.lift_two_power", "start": [651, 1], "end": [652, 30], "traced_tactics": [{"tactic": "simp [\u2190 one_add_one_eq_two]", "annotated_tactic": ["simp [\u2190 <a>one_add_one_eq_two</a>]", [{"full_name": "one_add_one_eq_two", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [226, 9], "def_end_pos": [226, 27]}]], "state_before": "\u03b1 \u03b2 : Type u\na : Cardinal.{u_1}\n\u22a2 lift.{v, u_1} (2 ^ a) = 2 ^ lift.{v, u_1} a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.zipRight'_nil_left", "start": [4084, 1], "end": [4085, 19], "traced_tactics": [{"tactic": "cases bs <;> rfl", "annotated_tactic": ["cases bs <;> rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nas : List \u03b1\nb : \u03b2\nbs : List \u03b2\n\u22a2 zipRight' [] bs = (map (fun b => (none, b)) bs, [])", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.subset_setOf", "start": [270, 1], "end": [271, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "AffineMap.lineMap_mem", "start": [526, 1], "end": [530, 40], "traced_tactics": [{"tactic": "rw [AffineMap.lineMap_apply]", "annotated_tactic": ["rw [<a>AffineMap.lineMap_apply</a>]", [{"full_name": "AffineMap.lineMap_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "def_pos": [506, 9], "def_end_pos": [506, 22]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\nQ : AffineSubspace k P\np\u2080 p\u2081 : P\nc : k\nh\u2080 : p\u2080 \u2208 Q\nh\u2081 : p\u2081 \u2208 Q\n\u22a2 (lineMap p\u2080 p\u2081) c \u2208 Q", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\nQ : AffineSubspace k P\np\u2080 p\u2081 : P\nc : k\nh\u2080 : p\u2080 \u2208 Q\nh\u2081 : p\u2081 \u2208 Q\n\u22a2 c \u2022 (p\u2081 -\u1d65 p\u2080) +\u1d65 p\u2080 \u2208 Q"}, {"tactic": "exact Q.smul_vsub_vadd_mem c h\u2081 h\u2080 h\u2080", "annotated_tactic": ["exact Q.smul_vsub_vadd_mem c h\u2081 h\u2080 h\u2080", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\nQ : AffineSubspace k P\np\u2080 p\u2081 : P\nc : k\nh\u2080 : p\u2080 \u2208 Q\nh\u2081 : p\u2081 \u2208 Q\n\u22a2 c \u2022 (p\u2081 -\u1d65 p\u2080) +\u1d65 p\u2080 \u2208 Q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "continuous_ofAdd", "start": [104, 1], "end": [104, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Add.lean", "full_name": "HasDerivWithinAt.const_add", "start": [121, 8], "end": [123, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csInf_lt_of_lt", "start": [654, 1], "end": [655, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "full_name": "NonUnitalSubsemiring.toSubsemigroup_strictMono", "start": [148, 1], "end": [149, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/StructuredArrow.lean", "full_name": "CategoryTheory.CostructuredArrow.w", "start": [433, 1], "end": [433, 94], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nT T' T'' : D\nY Y' Y'' : C\nS S' : C \u2964 D\nA B : CostructuredArrow S T\nf : A \u27f6 B\n\u22a2 S.map f.left \u226b B.hom = A.hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.mem_image_elim", "start": [240, 1], "end": [241, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Int/Basic.lean", "full_name": "Int.normalize_of_nonneg", "start": [100, 1], "end": [101, 70], "traced_tactics": [{"tactic": "rw [normalize_apply, normUnit_eq, if_pos h, Units.val_one, mul_one]", "annotated_tactic": ["rw [<a>normalize_apply</a>, <a>normUnit_eq</a>, <a>if_pos</a> h, <a>Units.val_one</a>, <a>mul_one</a>]", [{"full_name": "normalize_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [132, 9], "def_end_pos": [132, 24]}, {"full_name": "Int.normUnit_eq", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Int/Basic.lean", "def_pos": [98, 9], "def_end_pos": [98, 20]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "Units.val_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [222, 9], "def_end_pos": [222, 16]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "z : \u2124\nh : 0 \u2264 z\n\u22a2 normalize z = z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean", "full_name": "Nat.prod_pow_prime_padicValNat", "start": [946, 1], "end": [961, 62], "traced_tactics": [{"tactic": "conv =>\n  rhs\n  rw [\u2190 factorization_prod_pow_eq_self hn]", "annotated_tactic": ["conv =>\n    rhs\n    rw [\u2190 <a>factorization_prod_pow_eq_self</a> hn]", [{"full_name": "Nat.factorization_prod_pow_eq_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean", "def_pos": [99, 9], "def_end_pos": [99, 39]}]], "state_before": "a b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 \u220f p in Finset.filter Prime (Finset.range m), p ^ padicValNat p n = n", "state_after": "a b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 \u220f p in Finset.filter Prime (Finset.range m), p ^ padicValNat p n = Finsupp.prod (factorization n) fun x x_1 => x ^ x_1"}, {"tactic": "rw [eq_comm]", "annotated_tactic": ["rw [<a>eq_comm</a>]", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "a b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 \u220f p in Finset.filter Prime (Finset.range m), p ^ padicValNat p n = Finsupp.prod (factorization n) fun x x_1 => x ^ x_1", "state_after": "a b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 (Finsupp.prod (factorization n) fun x x_1 => x ^ x_1) =\n    \u220f p in Finset.filter Prime (Finset.range m), p ^ padicValNat p n"}, {"tactic": "apply Finset.prod_subset_one_on_sdiff", "annotated_tactic": ["apply <a>Finset.prod_subset_one_on_sdiff</a>", [{"full_name": "Finset.prod_subset_one_on_sdiff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [548, 9], "def_end_pos": [548, 33]}]], "state_before": "a b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 (Finsupp.prod (factorization n) fun x x_1 => x ^ x_1) =\n    \u220f p in Finset.filter Prime (Finset.range m), p ^ padicValNat p n", "state_after": "case h\na b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 (factorization n).support \u2286 Finset.filter Prime (Finset.range m)\n\ncase hg\na b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 \u2200 x \u2208 Finset.filter Prime (Finset.range m) \\ (factorization n).support, x ^ padicValNat x n = 1\n\ncase hfg\na b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 \u2200 x \u2208 (factorization n).support, (fun x x_1 => x ^ x_1) x ((factorization n) x) = x ^ padicValNat x n"}, {"tactic": "exact fun p hp => Finset.mem_filter.mpr \u27e8Finset.mem_range.2 <| pr.trans_le' <|\n  le_of_mem_primeFactors hp, prime_of_mem_primeFactors hp\u27e9", "annotated_tactic": ["exact fun p hp => Finset.mem_filter.mpr \u27e8<a>Finset.mem_range</a>.2 <| pr.trans_le' <|\n      <a>le_of_mem_primeFactors</a> hp, <a>prime_of_mem_primeFactors</a> hp\u27e9", [{"full_name": "Finset.mem_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3127, 9], "def_end_pos": [3127, 18]}, {"full_name": "Nat.le_of_mem_primeFactors", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PrimeFin.lean", "def_pos": [56, 7], "def_end_pos": [56, 29]}, {"full_name": "Nat.prime_of_mem_primeFactors", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PrimeFin.lean", "def_pos": [50, 7], "def_end_pos": [50, 32]}]], "state_before": "case h\na b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 (factorization n).support \u2286 Finset.filter Prime (Finset.range m)", "state_after": "no goals"}, {"tactic": "intro p hp", "annotated_tactic": ["intro p hp", []], "state_before": "case hg\na b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 \u2200 x \u2208 Finset.filter Prime (Finset.range m) \\ (factorization n).support, x ^ padicValNat x n = 1", "state_after": "case hg\na b m\u271d n\u271d p\u271d n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\np : \u2115\nhp : p \u2208 Finset.filter Prime (Finset.range m) \\ (factorization n).support\n\u22a2 p ^ padicValNat p n = 1"}, {"tactic": "cases' Finset.mem_sdiff.mp hp with hp1 hp2", "annotated_tactic": ["cases' Finset.mem_sdiff.mp hp with hp1 hp2", []], "state_before": "case hg\na b m\u271d n\u271d p\u271d n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\np : \u2115\nhp : p \u2208 Finset.filter Prime (Finset.range m) \\ (factorization n).support\n\u22a2 p ^ padicValNat p n = 1", "state_after": "case hg.intro\na b m\u271d n\u271d p\u271d n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\np : \u2115\nhp : p \u2208 Finset.filter Prime (Finset.range m) \\ (factorization n).support\nhp1 : p \u2208 Finset.filter Prime (Finset.range m)\nhp2 : p \u2209 (factorization n).support\n\u22a2 p ^ padicValNat p n = 1"}, {"tactic": "rw [\u2190 factorization_def n (Finset.mem_filter.mp hp1).2]", "annotated_tactic": ["rw [\u2190 <a>factorization_def</a> n (Finset.mem_filter.mp hp1).2]", [{"full_name": "Nat.factorization_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 26]}]], "state_before": "case hg.intro\na b m\u271d n\u271d p\u271d n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\np : \u2115\nhp : p \u2208 Finset.filter Prime (Finset.range m) \\ (factorization n).support\nhp1 : p \u2208 Finset.filter Prime (Finset.range m)\nhp2 : p \u2209 (factorization n).support\n\u22a2 p ^ padicValNat p n = 1", "state_after": "case hg.intro\na b m\u271d n\u271d p\u271d n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\np : \u2115\nhp : p \u2208 Finset.filter Prime (Finset.range m) \\ (factorization n).support\nhp1 : p \u2208 Finset.filter Prime (Finset.range m)\nhp2 : p \u2209 (factorization n).support\n\u22a2 p ^ (factorization n) p = 1"}, {"tactic": "simp [Finsupp.not_mem_support_iff.mp hp2]", "annotated_tactic": ["simp [Finsupp.not_mem_support_iff.mp hp2]", []], "state_before": "case hg.intro\na b m\u271d n\u271d p\u271d n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\np : \u2115\nhp : p \u2208 Finset.filter Prime (Finset.range m) \\ (factorization n).support\nhp1 : p \u2208 Finset.filter Prime (Finset.range m)\nhp2 : p \u2209 (factorization n).support\n\u22a2 p ^ (factorization n) p = 1", "state_after": "no goals"}, {"tactic": "intro p hp", "annotated_tactic": ["intro p hp", []], "state_before": "case hfg\na b m\u271d n\u271d p n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\n\u22a2 \u2200 x \u2208 (factorization n).support, (fun x x_1 => x ^ x_1) x ((factorization n) x) = x ^ padicValNat x n", "state_after": "case hfg\na b m\u271d n\u271d p\u271d n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\np : \u2115\nhp : p \u2208 (factorization n).support\n\u22a2 (fun x x_1 => x ^ x_1) p ((factorization n) p) = p ^ padicValNat p n"}, {"tactic": "simp [factorization_def n (prime_of_mem_primeFactors hp)]", "annotated_tactic": ["simp [<a>factorization_def</a> n (<a>prime_of_mem_primeFactors</a> hp)]", [{"full_name": "Nat.factorization_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 26]}, {"full_name": "Nat.prime_of_mem_primeFactors", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PrimeFin.lean", "def_pos": [50, 7], "def_end_pos": [50, 32]}]], "state_before": "case hfg\na b m\u271d n\u271d p\u271d n : \u2115\nhn : n \u2260 0\nm : \u2115\npr : n < m\np : \u2115\nhp : p \u2208 (factorization n).support\n\u22a2 (fun x x_1 => x ^ x_1) p ((factorization n) p) = p ^ padicValNat p n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/WF.lean", "full_name": "Std.RBNode.Balanced.balLeft", "start": [253, 11], "end": [267, 95], "traced_tactics": [{"tactic": "unfold balLeft", "annotated_tactic": ["unfold <a>balLeft</a>", [{"full_name": "Std.RBNode.balLeft", "def_path": ".lake/packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [327, 5], "def_end_pos": [327, 12]}]], "state_before": "\u03b1\u271d : Type u_1\nl : RBNode \u03b1\u271d\nv : \u03b1\u271d\nr : RBNode \u03b1\u271d\ncr : RBColor\nn : Nat\nhl : RedRed True l n\nhr : Balanced r cr (n + 1)\n\u22a2 RedRed (cr = red) (balLeft l v r) (n + 1)", "state_after": "\u03b1\u271d : Type u_1\nl : RBNode \u03b1\u271d\nv : \u03b1\u271d\nr : RBNode \u03b1\u271d\ncr : RBColor\nn : Nat\nhl : RedRed True l n\nhr : Balanced r cr (n + 1)\n\u22a2 RedRed (cr = red)\n    (match l with\n    | node red a x b => node red (node black a x b) v r\n    | l =>\n      match r with\n      | node black a y b => balance2 l v (node red a y b)\n      | node red (node black a y b) z c => node red (node black l v a) y (balance2 b z (setRed c))\n      | r => node red l v r)\n    (n + 1)"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "\u03b1\u271d : Type u_1\nl : RBNode \u03b1\u271d\nv : \u03b1\u271d\nr : RBNode \u03b1\u271d\ncr : RBColor\nn : Nat\nhl : RedRed True l n\nhr : Balanced r cr (n + 1)\n\u22a2 RedRed (cr = red)\n    (match l with\n    | node red a x b => node red (node black a x b) v r\n    | l =>\n      match r with\n      | node black a y b => balance2 l v (node red a y b)\n      | node red (node black a y b) z c => node red (node black l v a) y (balance2 b z (setRed c))\n      | r => node red l v r)\n    (n + 1)", "state_after": "case h_1\n\u03b1\u271d : Type u_1\nv : \u03b1\u271d\nr : RBNode \u03b1\u271d\ncr : RBColor\nn : Nat\nhr : Balanced r cr (n + 1)\nl\u271d a\u271d : RBNode \u03b1\u271d\nx\u271d : \u03b1\u271d\nb\u271d : RBNode \u03b1\u271d\nhl : RedRed True (node red a\u271d x\u271d b\u271d) n\n\u22a2 RedRed (cr = red) (node red (node black a\u271d x\u271d b\u271d) v r) (n + 1)\n\ncase h_2\n\u03b1\u271d : Type u_1\nl : RBNode \u03b1\u271d\nv : \u03b1\u271d\nr : RBNode \u03b1\u271d\ncr : RBColor\nn : Nat\nhl : RedRed True l n\nhr : Balanced r cr (n + 1)\nl\u271d : RBNode \u03b1\u271d\nx\u271d : \u2200 (a : RBNode \u03b1\u271d) (x : \u03b1\u271d) (b : RBNode \u03b1\u271d), l = node red a x b \u2192 False\n\u22a2 RedRed (cr = red)\n    (match r with\n    | node black a y b => balance2 l v (node red a y b)\n    | node red (node black a y b) z c => node red (node black l v a) y (balance2 b z (setRed c))\n    | r => node red l v r)\n    (n + 1)"}, {"tactic": "next a x b => exact\nlet \u27e8ca, cb, ha, hb\u27e9 := hl.of_red\nmatch cr with\n| red => .redred rfl (.black ha hb) hr\n| black => .balanced (.red (.black ha hb) hr)", "annotated_tactic": ["next a x b => exact\n    let \u27e8ca, cb, ha, hb\u27e9 := hl.of_red\n    match cr with\n    | <a>red</a> => .redred <a>rfl</a> (.black ha hb) hr\n    | <a>black</a> => .balanced (.red (.black ha hb) hr)", [{"full_name": "Std.RBColor.red", "def_path": ".lake/packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [31, 5], "def_end_pos": [31, 8]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Std.RBColor.black", "def_path": ".lake/packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [33, 5], "def_end_pos": [33, 10]}]], "state_before": "case h_1\n\u03b1\u271d : Type u_1\nv : \u03b1\u271d\nr : RBNode \u03b1\u271d\ncr : RBColor\nn : Nat\nhr : Balanced r cr (n + 1)\nl\u271d a\u271d : RBNode \u03b1\u271d\nx\u271d : \u03b1\u271d\nb\u271d : RBNode \u03b1\u271d\nhl : RedRed True (node red a\u271d x\u271d b\u271d) n\n\u22a2 RedRed (cr = red) (node red (node black a\u271d x\u271d b\u271d) v r) (n + 1)", "state_after": "no goals"}, {"tactic": "exact\nlet \u27e8ca, cb, ha, hb\u27e9 := hl.of_red\nmatch cr with\n| red => .redred rfl (.black ha hb) hr\n| black => .balanced (.red (.black ha hb) hr)", "annotated_tactic": ["exact\n    let \u27e8ca, cb, ha, hb\u27e9 := hl.of_red\n    match cr with\n    | <a>red</a> => .redred <a>rfl</a> (.black ha hb) hr\n    | <a>black</a> => .balanced (.red (.black ha hb) hr)", [{"full_name": "Std.RBColor.red", "def_path": ".lake/packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [31, 5], "def_end_pos": [31, 8]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Std.RBColor.black", "def_path": ".lake/packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [33, 5], "def_end_pos": [33, 10]}]], "state_before": "\u03b1\u271d : Type u_1\nv : \u03b1\u271d\nr : RBNode \u03b1\u271d\ncr : RBColor\nn : Nat\nhr : Balanced r cr (n + 1)\nl\u271d a : RBNode \u03b1\u271d\nx : \u03b1\u271d\nb : RBNode \u03b1\u271d\nhl : RedRed True (node red a x b) n\n\u22a2 RedRed (cr = red) (node red (node black a x b) v r) (n + 1)", "state_after": "no goals"}, {"tactic": "next H => exact match hl with\n| .redred .. => nomatch H _ _ _ rfl\n| .balanced hl => match hr with\n  | .black ha hb =>\n    let \u27e8c, h\u27e9 := RedRed.balance2 hl (.redred trivial ha hb); .balanced h\n  | .red (.black ha hb) (.black hc hd) =>\n    let \u27e8c, h\u27e9 := RedRed.balance2 hb (.redred trivial hc hd); .redred rfl (.black hl ha) h", "annotated_tactic": ["next H => exact match hl with\n    | .redred .. => nomatch H _ _ _ <a>rfl</a>\n    | .balanced hl => match hr with\n      | .black ha hb =>\n        let \u27e8c, h\u27e9 := <a>RedRed.balance2</a> hl (.redred <a>trivial</a> ha hb); .balanced h\n      | .red (.black ha hb) (.black hc hd) =>\n        let \u27e8c, h\u27e9 := <a>RedRed.balance2</a> hb (.redred <a>trivial</a> hc hd); .redred <a>rfl</a> (.black hl ha) h", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Std.RBNode.RedRed.balance2", "def_path": ".lake/packages/std/Std/Data/RBMap/WF.lean", "def_pos": [166, 19], "def_end_pos": [166, 34]}, {"full_name": "trivial", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [643, 31], "def_end_pos": [643, 38]}, {"full_name": "Std.RBNode.RedRed.balance2", "def_path": ".lake/packages/std/Std/Data/RBMap/WF.lean", "def_pos": [166, 19], "def_end_pos": [166, 34]}, {"full_name": "trivial", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [643, 31], "def_end_pos": [643, 38]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case h_2\n\u03b1\u271d : Type u_1\nl : RBNode \u03b1\u271d\nv : \u03b1\u271d\nr : RBNode \u03b1\u271d\ncr : RBColor\nn : Nat\nhl : RedRed True l n\nhr : Balanced r cr (n + 1)\nl\u271d : RBNode \u03b1\u271d\nx\u271d : \u2200 (a : RBNode \u03b1\u271d) (x : \u03b1\u271d) (b : RBNode \u03b1\u271d), l = node red a x b \u2192 False\n\u22a2 RedRed (cr = red)\n    (match r with\n    | node black a y b => balance2 l v (node red a y b)\n    | node red (node black a y b) z c => node red (node black l v a) y (balance2 b z (setRed c))\n    | r => node red l v r)\n    (n + 1)", "state_after": "no goals"}, {"tactic": "exact match hl with\n| .redred .. => nomatch H _ _ _ rfl\n| .balanced hl => match hr with\n| .black ha hb =>\nlet \u27e8c, h\u27e9 := RedRed.balance2 hl (.redred trivial ha hb); .balanced h\n| .red (.black ha hb) (.black hc hd) =>\nlet \u27e8c, h\u27e9 := RedRed.balance2 hb (.redred trivial hc hd); .redred rfl (.black hl ha) h", "annotated_tactic": ["exact match hl with\n    | .redred .. => nomatch H _ _ _ <a>rfl</a>\n    | .balanced hl => match hr with\n      | .black ha hb =>\n        let \u27e8c, h\u27e9 := <a>RedRed.balance2</a> hl (.redred <a>trivial</a> ha hb); .balanced h\n      | .red (.black ha hb) (.black hc hd) =>\n        let \u27e8c, h\u27e9 := <a>RedRed.balance2</a> hb (.redred <a>trivial</a> hc hd); .redred <a>rfl</a> (.black hl ha) h", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Std.RBNode.RedRed.balance2", "def_path": ".lake/packages/std/Std/Data/RBMap/WF.lean", "def_pos": [166, 19], "def_end_pos": [166, 34]}, {"full_name": "trivial", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [643, 31], "def_end_pos": [643, 38]}, {"full_name": "Std.RBNode.RedRed.balance2", "def_path": ".lake/packages/std/Std/Data/RBMap/WF.lean", "def_pos": [166, 19], "def_end_pos": [166, 34]}, {"full_name": "trivial", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [643, 31], "def_end_pos": [643, 38]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1\u271d : Type u_1\nl : RBNode \u03b1\u271d\nv : \u03b1\u271d\nr : RBNode \u03b1\u271d\ncr : RBColor\nn : Nat\nhl : RedRed True l n\nhr : Balanced r cr (n + 1)\nl\u271d : RBNode \u03b1\u271d\nH : \u2200 (a : RBNode \u03b1\u271d) (x : \u03b1\u271d) (b : RBNode \u03b1\u271d), l = node red a x b \u2192 False\n\u22a2 RedRed (cr = red)\n    (match r with\n    | node black a y b => balance2 l v (node red a y b)\n    | node red (node black a y b) z c => node red (node black l v a) y (balance2 b z (setRed c))\n    | r => node red l v r)\n    (n + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "isOfFinOrder_ofAdd_iff", "start": [65, 1], "end": [66, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Ordinal.cof_bsup_le_lift", "start": [452, 1], "end": [456, 35], "traced_tactics": [{"tactic": "rw [\u2190 bsup_eq_blsub_iff_lt_bsup.{u, v}] at H", "annotated_tactic": ["rw [\u2190 <a>bsup_eq_blsub_iff_lt_bsup</a>.{u, v}] at H", [{"full_name": "Ordinal.bsup_eq_blsub_iff_lt_bsup", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1863, 9], "def_end_pos": [1863, 34]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\no : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o \u2192 Ordinal.{max u v}\nH : \u2200 (i : Ordinal.{u}) (h : i < o), f i h < bsup o f\n\u22a2 cof (bsup o f) \u2264 Cardinal.lift.{v, u} (card o)", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\no : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o \u2192 Ordinal.{max u v}\nH : (bsup o fun i h => f i h) = blsub o fun i h => f i h\n\u22a2 cof (bsup o f) \u2264 Cardinal.lift.{v, u} (card o)"}, {"tactic": "rw [H]", "annotated_tactic": ["rw [H]", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\no : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o \u2192 Ordinal.{max u v}\nH : (bsup o fun i h => f i h) = blsub o fun i h => f i h\n\u22a2 cof (bsup o f) \u2264 Cardinal.lift.{v, u} (card o)", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\no : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o \u2192 Ordinal.{max u v}\nH : (bsup o fun i h => f i h) = blsub o fun i h => f i h\n\u22a2 cof (blsub o fun i h => f i h) \u2264 Cardinal.lift.{v, u} (card o)"}, {"tactic": "exact cof_blsub_le_lift.{u, v} f", "annotated_tactic": ["exact <a>cof_blsub_le_lift</a>.{u, v} f", [{"full_name": "Ordinal.cof_blsub_le_lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Cofinality.lean", "def_pos": [430, 9], "def_end_pos": [430, 26]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\no : Ordinal.{u}\nf : (a : Ordinal.{u}) \u2192 a < o \u2192 Ordinal.{max u v}\nH : (bsup o fun i h => f i h) = blsub o fun i h => f i h\n\u22a2 cof (blsub o fun i h => f i h) \u2264 Cardinal.lift.{v, u} (card o)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean", "full_name": "DifferentiableWithinAt.log", "start": [150, 1], "end": [152, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Embedding/Basic.lean", "full_name": "Function.Embedding.equiv_toEmbedding_trans_symm_toEmbedding", "start": [162, 1], "end": [165, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\n\u22a2 Embedding.trans (Equiv.toEmbedding e) (Equiv.toEmbedding e.symm) = Embedding.refl \u03b1", "state_after": "case h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\nx\u271d : \u03b1\n\u22a2 (Embedding.trans (Equiv.toEmbedding e) (Equiv.toEmbedding e.symm)) x\u271d = (Embedding.refl \u03b1) x\u271d"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\nx\u271d : \u03b1\n\u22a2 (Embedding.trans (Equiv.toEmbedding e) (Equiv.toEmbedding e.symm)) x\u271d = (Embedding.refl \u03b1) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Alternating/Basic.lean", "full_name": "AlternatingMap.coe_neg", "start": [374, 1], "end": [375, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.OuterMeasure.smul_dirac_apply", "start": [515, 1], "end": [517, 96], "traced_tactics": [{"tactic": "simp only [smul_apply, smul_eq_mul, dirac_apply, \u2190 indicator_mul_right _ fun _ => a, mul_one]", "annotated_tactic": ["simp only [<a>smul_apply</a>, <a>smul_eq_mul</a>, <a>dirac_apply</a>, \u2190 <a>indicator_mul_right</a> _ fun _ => a, <a>mul_one</a>]", [{"full_name": "MeasureTheory.OuterMeasure.smul_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [304, 9], "def_end_pos": [304, 19]}, {"full_name": "smul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}, {"full_name": "MeasureTheory.OuterMeasure.dirac_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [497, 9], "def_end_pos": [497, 20]}, {"full_name": "Set.indicator_mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [567, 9], "def_end_pos": [567, 28]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\nR' : Type u_4\nms : Set (OuterMeasure \u03b1)\nm : OuterMeasure \u03b1\na : \u211d\u22650\u221e\nb : \u03b1\ns : Set \u03b1\n\u22a2 \u2191(a \u2022 dirac b) s = indicator s (fun x => a) b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.image2_iInter_subset_left", "start": [1921, 1], "end": [1924, 55], "traced_tactics": [{"tactic": "simp_rw [image2_subset_iff, mem_iInter]", "annotated_tactic": ["simp_rw [<a>image2_subset_iff</a>, <a>mem_iInter</a>]", [{"full_name": "Set.image2_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [64, 9], "def_end_pos": [64, 26]}, {"full_name": "Set.mem_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [278, 9], "def_end_pos": [278, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 image2 f (\u22c2 i, s i) t \u2286 \u22c2 i, image2 f (s i) t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 \u2200 (x : \u03b1), (\u2200 (i : \u03b9), x \u2208 s i) \u2192 \u2200 y \u2208 t, \u2200 (i : \u03b9), f x y \u2208 image2 f (s i) t"}, {"tactic": "exact fun x hx y hy i => mem_image2_of_mem (hx _) hy", "annotated_tactic": ["exact fun x hx y hy i => <a>mem_image2_of_mem</a> (hx _) hy", [{"full_name": "Set.mem_image2_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [331, 9], "def_end_pos": [331, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 \u2200 (x : \u03b1), (\u2200 (i : \u03b9), x \u2208 s i) \u2192 \u2200 y \u2208 t, \u2200 (i : \u03b9), f x y \u2208 image2 f (s i) t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Intervals.lean", "full_name": "List.Ico.succ_singleton", "start": [119, 1], "end": [121, 38], "traced_tactics": [{"tactic": "dsimp [Ico]", "annotated_tactic": ["dsimp [<a>Ico</a>]", [{"full_name": "List.Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Intervals.lean", "def_pos": [36, 5], "def_end_pos": [36, 8]}]], "state_before": "n : \u2115\n\u22a2 Ico n (n + 1) = [n]", "state_after": "n : \u2115\n\u22a2 range' n (n + 1 - n) = [n]"}, {"tactic": "simp [range', add_tsub_cancel_left]", "annotated_tactic": ["simp [<a>range'</a>, <a>add_tsub_cancel_left</a>]", [{"full_name": "List.range'", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1107, 5], "def_end_pos": [1107, 11]}, {"full_name": "add_tsub_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 29]}]], "state_before": "n : \u2115\n\u22a2 range' n (n + 1 - n) = [n]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Dilation.lean", "full_name": "Dilation.mul_def", "start": [381, 1], "end": [382, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.lintegral_map_le", "start": [1411, 1], "end": [1416, 76], "traced_tactics": [{"tactic": "rw [\u2190 iSup_lintegral_measurable_le_eq_lintegral, \u2190 iSup_lintegral_measurable_le_eq_lintegral]", "annotated_tactic": ["rw [\u2190 <a>iSup_lintegral_measurable_le_eq_lintegral</a>, \u2190 <a>iSup_lintegral_measurable_le_eq_lintegral</a>]", [{"full_name": "MeasureTheory.iSup_lintegral_measurable_le_eq_lintegral", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [114, 9], "def_end_pos": [114, 50]}, {"full_name": "MeasureTheory.iSup_lintegral_measurable_le_eq_lintegral", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [114, 9], "def_end_pos": [114, 50]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b2 \u2192 \u211d\u22650\u221e\ng : \u03b1 \u2192 \u03b2\nhg : Measurable g\n\u22a2 \u222b\u207b (a : \u03b2), f a \u2202Measure.map g \u03bc \u2264 \u222b\u207b (a : \u03b1), f (g a) \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b2 \u2192 \u211d\u22650\u221e\ng : \u03b1 \u2192 \u03b2\nhg : Measurable g\n\u22a2 \u2a06 g_1, \u2a06 (_ : Measurable g_1), \u2a06 (_ : g_1 \u2264 fun a => f a), \u222b\u207b (a : \u03b2), g_1 a \u2202Measure.map g \u03bc \u2264\n    \u2a06 g_1, \u2a06 (_ : Measurable g_1), \u2a06 (_ : g_1 \u2264 fun a => f (g a)), \u222b\u207b (a : \u03b1), g_1 a \u2202\u03bc"}, {"tactic": "refine' iSup\u2082_le fun i hi => iSup_le fun h'i => _", "annotated_tactic": ["refine' <a>iSup\u2082_le</a> fun i hi => <a>iSup_le</a> fun h'i => _", [{"full_name": "iSup\u2082_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [772, 9], "def_end_pos": [772, 17]}, {"full_name": "iSup_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [764, 9], "def_end_pos": [764, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b2 \u2192 \u211d\u22650\u221e\ng : \u03b1 \u2192 \u03b2\nhg : Measurable g\n\u22a2 \u2a06 g_1, \u2a06 (_ : Measurable g_1), \u2a06 (_ : g_1 \u2264 fun a => f a), \u222b\u207b (a : \u03b2), g_1 a \u2202Measure.map g \u03bc \u2264\n    \u2a06 g_1, \u2a06 (_ : Measurable g_1), \u2a06 (_ : g_1 \u2264 fun a => f (g a)), \u222b\u207b (a : \u03b1), g_1 a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b2 \u2192 \u211d\u22650\u221e\ng : \u03b1 \u2192 \u03b2\nhg : Measurable g\ni : \u03b2 \u2192 \u211d\u22650\u221e\nhi : Measurable i\nh'i : i \u2264 fun a => f a\n\u22a2 \u222b\u207b (a : \u03b2), i a \u2202Measure.map g \u03bc \u2264 \u2a06 g_1, \u2a06 (_ : Measurable g_1), \u2a06 (_ : g_1 \u2264 fun a => f (g a)), \u222b\u207b (a : \u03b1), g_1 a \u2202\u03bc"}, {"tactic": "refine' le_iSup\u2082_of_le (i \u2218 g) (hi.comp hg) _", "annotated_tactic": ["refine' <a>le_iSup\u2082_of_le</a> (i \u2218 g) (hi.comp hg) _", [{"full_name": "le_iSup\u2082_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [754, 9], "def_end_pos": [754, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b2 \u2192 \u211d\u22650\u221e\ng : \u03b1 \u2192 \u03b2\nhg : Measurable g\ni : \u03b2 \u2192 \u211d\u22650\u221e\nhi : Measurable i\nh'i : i \u2264 fun a => f a\n\u22a2 \u222b\u207b (a : \u03b2), i a \u2202Measure.map g \u03bc \u2264 \u2a06 g_1, \u2a06 (_ : Measurable g_1), \u2a06 (_ : g_1 \u2264 fun a => f (g a)), \u222b\u207b (a : \u03b1), g_1 a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b2 \u2192 \u211d\u22650\u221e\ng : \u03b1 \u2192 \u03b2\nhg : Measurable g\ni : \u03b2 \u2192 \u211d\u22650\u221e\nhi : Measurable i\nh'i : i \u2264 fun a => f a\n\u22a2 \u222b\u207b (a : \u03b2), i a \u2202Measure.map g \u03bc \u2264 \u2a06 (_ : i \u2218 g \u2264 fun a => f (g a)), \u222b\u207b (a : \u03b1), (i \u2218 g) a \u2202\u03bc"}, {"tactic": "exact le_iSup_of_le (fun x => h'i (g x)) (le_of_eq (lintegral_map hi hg))", "annotated_tactic": ["exact <a>le_iSup_of_le</a> (fun x => h'i (g x)) (<a>le_of_eq</a> (<a>lintegral_map</a> hi hg))", [{"full_name": "le_iSup_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [738, 9], "def_end_pos": [738, 22]}, {"full_name": "le_of_eq", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [66, 9], "def_end_pos": [66, 17]}, {"full_name": "MeasureTheory.lintegral_map", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [1389, 9], "def_end_pos": [1389, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nf : \u03b2 \u2192 \u211d\u22650\u221e\ng : \u03b1 \u2192 \u03b2\nhg : Measurable g\ni : \u03b2 \u2192 \u211d\u22650\u221e\nhi : Measurable i\nh'i : i \u2264 fun a => f a\n\u22a2 \u222b\u207b (a : \u03b2), i a \u2202Measure.map g \u03bc \u2264 \u2a06 (_ : i \u2218 g \u2264 fun a => f (g a)), \u222b\u207b (a : \u03b1), (i \u2218 g) a \u2202\u03bc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Basic.lean", "full_name": "UniformContinuous.continuous", "start": [1341, 1], "end": [1344, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.card_unit", "start": [363, 1], "end": [364, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/GDelta.lean", "full_name": "IsMeagre.mono", "start": [323, 1], "end": [325, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "HasStrictFDerivAt.const_mul", "start": [568, 1], "end": [570, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Operations.lean", "full_name": "Submonoid.map_comap_le", "start": [299, 1], "end": [300, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "Ideal.quotient_map_mk\u2090", "start": [575, 1], "end": [577, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "full_name": "HasFDerivWithinAt.uniqueDiffWithinAt_of_continuousLinearEquiv", "start": [516, 1], "end": [519, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Complex.cos_add_int_mul_two_pi", "start": [1219, 1], "end": [1220, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/Compact.lean", "full_name": "isCompact_of_finite_subcover", "start": [347, 1], "end": [359, 27], "traced_tactics": [{"tactic": "contrapose! h", "annotated_tactic": ["contrapose! h", []], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nh : \u2200 {\u03b9 : Type u} (U : \u03b9 \u2192 Set X), (\u2200 (i : \u03b9), IsOpen (U i)) \u2192 s \u2286 \u22c3 i, U i \u2192 \u2203 t, s \u2286 \u22c3 i \u2208 t, U i\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\n\u22a2 \u2203 x \u2208 s, ClusterPt x f", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nh : \u2200 x \u2208 s, \u00acClusterPt x f\n\u22a2 \u2203 \u03b9 U, (\u2200 (i : \u03b9), IsOpen (U i)) \u2227 s \u2286 \u22c3 i, U i \u2227 \u2200 (t : Finset \u03b9), \u00acs \u2286 \u22c3 i \u2208 t, U i"}, {"tactic": "simp only [ClusterPt, not_neBot, \u2190 disjoint_iff, SetCoe.forall',\n  (nhds_basis_opens _).disjoint_iff_left] at h", "annotated_tactic": ["simp only [<a>ClusterPt</a>, <a>not_neBot</a>, \u2190 <a>disjoint_iff</a>, <a>SetCoe.forall'</a>,\n    (<a>nhds_basis_opens</a> _).<a>disjoint_iff_left</a>] at h", [{"full_name": "ClusterPt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [255, 5], "def_end_pos": [255, 14]}, {"full_name": "Filter.not_neBot", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [521, 17], "def_end_pos": [521, 26]}, {"full_name": "disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "SetCoe.forall'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [181, 9], "def_end_pos": [181, 23]}, {"full_name": "nhds_basis_opens", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [791, 9], "def_end_pos": [791, 25]}, {"full_name": "Filter.HasBasis.disjoint_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [739, 9], "def_end_pos": [739, 35]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nh : \u2200 x \u2208 s, \u00acClusterPt x f\n\u22a2 \u2203 \u03b9 U, (\u2200 (i : \u03b9), IsOpen (U i)) \u2227 s \u2286 \u22c3 i, U i \u2227 \u2200 (t : Finset \u03b9), \u00acs \u2286 \u22c3 i \u2208 t, U i", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nh : \u2200 (x : \u2191s), \u2203 i, (\u2191x \u2208 i \u2227 IsOpen i) \u2227 i\u1d9c \u2208 f\n\u22a2 \u2203 \u03b9 U, (\u2200 (i : \u03b9), IsOpen (U i)) \u2227 s \u2286 \u22c3 i, U i \u2227 \u2200 (t : Finset \u03b9), \u00acs \u2286 \u22c3 i \u2208 t, U i"}, {"tactic": "choose U hU hUf using h", "annotated_tactic": ["choose U hU hUf using h", []], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nh : \u2200 (x : \u2191s), \u2203 i, (\u2191x \u2208 i \u2227 IsOpen i) \u2227 i\u1d9c \u2208 f\n\u22a2 \u2203 \u03b9 U, (\u2200 (i : \u03b9), IsOpen (U i)) \u2227 s \u2286 \u22c3 i, U i \u2227 \u2200 (t : Finset \u03b9), \u00acs \u2286 \u22c3 i \u2208 t, U i", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\n\u22a2 \u2203 \u03b9 U, (\u2200 (i : \u03b9), IsOpen (U i)) \u2227 s \u2286 \u22c3 i, U i \u2227 \u2200 (t : Finset \u03b9), \u00acs \u2286 \u22c3 i \u2208 t, U i"}, {"tactic": "refine \u27e8s, U, fun x => (hU x).2, fun x hx => mem_iUnion.2 \u27e8\u27e8x, hx\u27e9, (hU _).1\u27e9, fun t ht => ?_\u27e9", "annotated_tactic": ["refine \u27e8s, U, fun x => (hU x).2, fun x hx => <a>mem_iUnion</a>.2 \u27e8\u27e8x, hx\u27e9, (hU _).1\u27e9, fun t ht => ?_\u27e9", [{"full_name": "Set.mem_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [272, 9], "def_end_pos": [272, 19]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\n\u22a2 \u2203 \u03b9 U, (\u2200 (i : \u03b9), IsOpen (U i)) \u2227 s \u2286 \u22c3 i, U i \u2227 \u2200 (t : Finset \u03b9), \u00acs \u2286 \u22c3 i \u2208 t, U i", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t\u271d : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\nt : Finset \u2191s\nht : s \u2286 \u22c3 i \u2208 t, U i\n\u22a2 False"}, {"tactic": "refine compl_not_mem (le_principal_iff.1 hfs) ?_", "annotated_tactic": ["refine <a>compl_not_mem</a> (<a>le_principal_iff</a>.1 hfs) ?_", [{"full_name": "Filter.compl_not_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [727, 9], "def_end_pos": [727, 22]}, {"full_name": "Filter.le_principal_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [669, 9], "def_end_pos": [669, 25]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t\u271d : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\nt : Finset \u2191s\nht : s \u2286 \u22c3 i \u2208 t, U i\n\u22a2 False", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t\u271d : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\nt : Finset \u2191s\nht : s \u2286 \u22c3 i \u2208 t, U i\n\u22a2 s\u1d9c \u2208 f"}, {"tactic": "refine mem_of_superset ((biInter_finset_mem t).2 fun x _ => hUf x) ?_", "annotated_tactic": ["refine <a>mem_of_superset</a> ((<a>biInter_finset_mem</a> t).2 fun x _ => hUf x) ?_", [{"full_name": "Filter.mem_of_superset", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [152, 9], "def_end_pos": [152, 24]}, {"full_name": "Filter.biInter_finset_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [204, 9], "def_end_pos": [204, 27]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t\u271d : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\nt : Finset \u2191s\nht : s \u2286 \u22c3 i \u2208 t, U i\n\u22a2 s\u1d9c \u2208 f", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t\u271d : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\nt : Finset \u2191s\nht : s \u2286 \u22c3 i \u2208 t, U i\n\u22a2 \u22c2 i \u2208 t, (U i)\u1d9c \u2286 s\u1d9c"}, {"tactic": "rw [subset_compl_comm, compl_iInter\u2082]", "annotated_tactic": ["rw [<a>subset_compl_comm</a>, <a>compl_iInter\u2082</a>]", [{"full_name": "Set.subset_compl_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1732, 9], "def_end_pos": [1732, 26]}, {"full_name": "Set.compl_iInter\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [471, 9], "def_end_pos": [471, 22]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t\u271d : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\nt : Finset \u2191s\nht : s \u2286 \u22c3 i \u2208 t, U i\n\u22a2 \u22c2 i \u2208 t, (U i)\u1d9c \u2286 s\u1d9c", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t\u271d : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\nt : Finset \u2191s\nht : s \u2286 \u22c3 i \u2208 t, U i\n\u22a2 s \u2286 \u22c3 i \u2208 t, (U i)\u1d9c\u1d9c"}, {"tactic": "simpa only [compl_compl]", "annotated_tactic": ["simpa only [<a>compl_compl</a>]", [{"full_name": "compl_compl", "def_path": ".lake/packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [656, 9], "def_end_pos": [656, 20]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t\u271d : Set X\nf : Filter X\nhf : NeBot f\nhfs : f \u2264 \ud835\udcdf s\nU : \u2191s \u2192 Set X\nhU : \u2200 (x : \u2191s), \u2191x \u2208 U x \u2227 IsOpen (U x)\nhUf : \u2200 (x : \u2191s), (U x)\u1d9c \u2208 f\nt : Finset \u2191s\nht : s \u2286 \u22c3 i \u2208 t, U i\n\u22a2 s \u2286 \u22c3 i \u2208 t, (U i)\u1d9c\u1d9c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Complex.sinh_sub_cosh", "start": [432, 1], "end": [432, 88], "traced_tactics": [{"tactic": "rw [\u2190 neg_sub, cosh_sub_sinh]", "annotated_tactic": ["rw [\u2190 <a>neg_sub</a>, <a>cosh_sub_sinh</a>]", [{"full_name": "neg_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [471, 3], "def_end_pos": [471, 14]}, {"full_name": "Complex.cosh_sub_sinh", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [427, 9], "def_end_pos": [427, 22]}]], "state_before": "x y : \u2102\n\u22a2 sinh x - cosh x = -cexp (-x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_zpow", "start": [2062, 1], "end": [2063, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean", "full_name": "PowerSeries.rescale_X", "start": [659, 1], "end": [662, 32], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\nA : Type u_2\ninst\u271d : CommRing A\na : A\n\u22a2 (rescale a) X = (C A) a * X", "state_after": "case h\nR : Type u_1\nA : Type u_2\ninst\u271d : CommRing A\na : A\nn\u271d : \u2115\n\u22a2 (coeff A n\u271d) ((rescale a) X) = (coeff A n\u271d) ((C A) a * X)"}, {"tactic": "simp only [coeff_rescale, coeff_C_mul, coeff_X]", "annotated_tactic": ["simp only [<a>coeff_rescale</a>, <a>coeff_C_mul</a>, <a>coeff_X</a>]", [{"full_name": "PowerSeries.coeff_rescale", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerSeries/Basic.lean", "def_pos": [591, 9], "def_end_pos": [591, 22]}, {"full_name": "PowerSeries.coeff_C_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerSeries/Basic.lean", "def_pos": [332, 9], "def_end_pos": [332, 20]}, {"full_name": "PowerSeries.coeff_X", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerSeries/Basic.lean", "def_pos": [269, 9], "def_end_pos": [269, 16]}]], "state_before": "case h\nR : Type u_1\nA : Type u_2\ninst\u271d : CommRing A\na : A\nn\u271d : \u2115\n\u22a2 (coeff A n\u271d) ((rescale a) X) = (coeff A n\u271d) ((C A) a * X)", "state_after": "case h\nR : Type u_1\nA : Type u_2\ninst\u271d : CommRing A\na : A\nn\u271d : \u2115\n\u22a2 (a ^ n\u271d * if n\u271d = 1 then 1 else 0) = a * if n\u271d = 1 then 1 else 0"}, {"tactic": "split_ifs with h <;> simp [h]", "annotated_tactic": ["split_ifs with h <;> simp [h]", []], "state_before": "case h\nR : Type u_1\nA : Type u_2\ninst\u271d : CommRing A\na : A\nn\u271d : \u2115\n\u22a2 (a ^ n\u271d * if n\u271d = 1 then 1 else 0) = a * if n\u271d = 1 then 1 else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/Alter.lean", "full_name": "Std.RBNode.Path.Zoomed.toRootOrdered", "start": [252, 1], "end": [256, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Antichain.lean", "full_name": "IsAntichain.image_relEmbedding_iff", "start": [141, 1], "end": [143, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "fderivWithin_mul", "start": [464, 1], "end": [468, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AddTorsor.lean", "full_name": "dist_homothety_center", "start": [59, 1], "end": [60, 95], "traced_tactics": [{"tactic": "rw [dist_comm, dist_center_homothety]", "annotated_tactic": ["rw [<a>dist_comm</a>, <a>dist_center_homothety</a>]", [{"full_name": "dist_comm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [179, 9], "def_end_pos": [179, 18]}, {"full_name": "dist_center_homothety", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/AddTorsor.lean", "def_pos": [45, 9], "def_end_pos": [45, 30]}]], "state_before": "\u03b1 : Type u_1\nV : Type u_2\nP : Type u_3\nW : Type u_4\nQ : Type u_5\ninst\u271d\u2078 : SeminormedAddCommGroup V\ninst\u271d\u2077 : PseudoMetricSpace P\ninst\u271d\u2076 : NormedAddTorsor V P\ninst\u271d\u2075 : NormedAddCommGroup W\ninst\u271d\u2074 : MetricSpace Q\ninst\u271d\u00b3 : NormedAddTorsor W Q\n\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c V\ninst\u271d : NormedSpace \ud835\udd5c W\np\u2081 p\u2082 : P\nc : \ud835\udd5c\n\u22a2 dist ((homothety p\u2081 c) p\u2082) p\u2081 = \u2016c\u2016 * dist p\u2081 p\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Cauchy.lean", "full_name": "cauchySeq_const", "start": [223, 1], "end": [224, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.monotone_castPred_comp", "start": [1299, 1], "end": [1301, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Monotone.isBoundedUnder_ge_comp_iff", "start": [1470, 1], "end": [1473, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.X_dvd_sub_C", "start": [237, 1], "end": [238, 28], "traced_tactics": [{"tactic": "simp [X_dvd_iff, coeff_C]", "annotated_tactic": ["simp [<a>X_dvd_iff</a>, <a>coeff_C</a>]", [{"full_name": "Polynomial.X_dvd_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [38, 9], "def_end_pos": [38, 18]}, {"full_name": "Polynomial.coeff_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [741, 9], "def_end_pos": [741, 16]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\n\u22a2 X \u2223 p - C (coeff p 0)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean", "full_name": "MeasureTheory.measurable_spanningSets", "start": [600, 1], "end": [602, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.IsCycle.pow_eq_one_iff'", "start": [658, 1], "end": [660, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Basic.lean", "full_name": "LinearMap.sub_apply", "start": [959, 1], "end": [960, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "full_name": "AffineMap.coeFn_injective", "start": [150, 1], "end": [151, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Congruence.lean", "full_name": "Con.symm", "start": [147, 11], "end": [147, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "AddCommGroup.modEq_iff_toIcoMod_add_period_eq_toIocMod", "start": [652, 1], "end": [654, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/RatFunc.lean", "full_name": "RatFunc.intDegree_mul", "start": [1598, 1], "end": [1608, 27], "traced_tactics": [{"tactic": "simp only [intDegree, add_sub, sub_add, sub_sub_eq_add_sub, sub_sub, sub_eq_sub_iff_add_eq_add]", "annotated_tactic": ["simp only [<a>intDegree</a>, <a>add_sub</a>, <a>sub_add</a>, <a>sub_sub_eq_add_sub</a>, <a>sub_sub</a>, <a>sub_eq_sub_iff_add_eq_add</a>]", [{"full_name": "RatFunc.intDegree", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1564, 5], "def_end_pos": [1564, 14]}, {"full_name": "add_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [391, 3], "def_end_pos": [391, 14]}, {"full_name": "sub_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [606, 3], "def_end_pos": [606, 14]}, {"full_name": "sub_sub_eq_add_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [523, 3], "def_end_pos": [523, 14]}, {"full_name": "sub_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [601, 3], "def_end_pos": [601, 14]}, {"full_name": "sub_eq_sub_iff_add_eq_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1081, 3], "def_end_pos": [1081, 14]}]], "state_before": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 intDegree (x * y) = intDegree x + intDegree y", "state_after": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 \u2191(natDegree (num (x * y))) + (\u2191(natDegree (denom x)) + \u2191(natDegree (denom y))) =\n    \u2191(natDegree (num x)) + \u2191(natDegree (num y)) + \u2191(natDegree (denom (x * y)))"}, {"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 \u2191(natDegree (num (x * y))) + (\u2191(natDegree (denom x)) + \u2191(natDegree (denom y))) =\n    \u2191(natDegree (num x)) + \u2191(natDegree (num y)) + \u2191(natDegree (denom (x * y)))", "state_after": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 natDegree (num (x * y)) + (natDegree (denom x) + natDegree (denom y)) =\n    natDegree (num x) + natDegree (num y) + natDegree (denom (x * y))"}, {"tactic": "rw [\u2190 Polynomial.natDegree_mul x.denom_ne_zero y.denom_ne_zero, \u2190\n  Polynomial.natDegree_mul (RatFunc.num_ne_zero (mul_ne_zero hx hy))\n    (mul_ne_zero x.denom_ne_zero y.denom_ne_zero),\n  \u2190 Polynomial.natDegree_mul (RatFunc.num_ne_zero hx) (RatFunc.num_ne_zero hy), \u2190\n  Polynomial.natDegree_mul (mul_ne_zero (RatFunc.num_ne_zero hx) (RatFunc.num_ne_zero hy))\n    (x * y).denom_ne_zero,\n  RatFunc.num_denom_mul]", "annotated_tactic": ["rw [\u2190 <a>Polynomial.natDegree_mul</a> x.denom_ne_zero y.denom_ne_zero, \u2190\n    <a>Polynomial.natDegree_mul</a> (<a>RatFunc.num_ne_zero</a> (<a>mul_ne_zero</a> hx hy))\n      (<a>mul_ne_zero</a> x.denom_ne_zero y.denom_ne_zero),\n    \u2190 <a>Polynomial.natDegree_mul</a> (<a>RatFunc.num_ne_zero</a> hx) (<a>RatFunc.num_ne_zero</a> hy), \u2190\n    <a>Polynomial.natDegree_mul</a> (<a>mul_ne_zero</a> (<a>RatFunc.num_ne_zero</a> hx) (<a>RatFunc.num_ne_zero</a> hy))\n      (x * y).<a>denom_ne_zero</a>,\n    <a>RatFunc.num_denom_mul</a>]", [{"full_name": "Polynomial.natDegree_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}, {"full_name": "Polynomial.natDegree_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}, {"full_name": "RatFunc.num_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1253, 9], "def_end_pos": [1253, 20]}, {"full_name": "mul_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [88, 9], "def_end_pos": [88, 20]}, {"full_name": "mul_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [88, 9], "def_end_pos": [88, 20]}, {"full_name": "Polynomial.natDegree_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}, {"full_name": "RatFunc.num_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1253, 9], "def_end_pos": [1253, 20]}, {"full_name": "RatFunc.num_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1253, 9], "def_end_pos": [1253, 20]}, {"full_name": "Polynomial.natDegree_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}, {"full_name": "mul_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [88, 9], "def_end_pos": [88, 20]}, {"full_name": "RatFunc.num_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1253, 9], "def_end_pos": [1253, 20]}, {"full_name": "RatFunc.num_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1253, 9], "def_end_pos": [1253, 20]}, {"full_name": "RatFunc.denom_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1196, 9], "def_end_pos": [1196, 22]}, {"full_name": "RatFunc.num_denom_mul", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1279, 9], "def_end_pos": [1279, 22]}]], "state_before": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 natDegree (num (x * y)) + (natDegree (denom x) + natDegree (denom y)) =\n    natDegree (num x) + natDegree (num y) + natDegree (denom (x * y))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Basic.lean", "full_name": "HahnSeries.support_eq_empty_iff", "start": [120, 1], "end": [121, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Field/Defs.lean", "full_name": "Rat.smul_one_eq_coe", "start": [153, 1], "end": [154, 29], "traced_tactics": [{"tactic": "rw [Rat.smul_def, mul_one]", "annotated_tactic": ["rw [<a>Rat.smul_def</a>, <a>mul_one</a>]", [{"full_name": "Rat.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Field/Defs.lean", "def_pos": [148, 9], "def_end_pos": [148, 17]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nK : Type u_3\ninst\u271d\u00b9 : DivisionRing K\na b : K\nA : Type u_4\ninst\u271d : DivisionRing A\nm : \u211a\n\u22a2 m \u2022 1 = \u2191m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.addOrderOf_one", "start": [109, 1], "end": [110, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/ConstMulAction.lean", "full_name": "continuous_const_smul_iff", "start": [227, 1], "end": [228, 71], "traced_tactics": [{"tactic": "simp only [continuous_iff_continuousAt, continuousAt_const_smul_iff]", "annotated_tactic": ["simp only [<a>continuous_iff_continuousAt</a>, <a>continuousAt_const_smul_iff</a>]", [{"full_name": "continuous_iff_continuousAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1635, 9], "def_end_pos": [1635, 36]}, {"full_name": "continuousAt_const_smul_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/ConstMulAction.lean", "def_pos": [220, 9], "def_end_pos": [220, 36]}]], "state_before": "M : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nG : Type u_4\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : MulAction G \u03b1\ninst\u271d\u00b9 : ContinuousConstSMul G \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\ns : Set \u03b2\nc : G\n\u22a2 (Continuous fun x => c \u2022 f x) \u2194 Continuous f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/Prime.lean", "full_name": "Mathlib.Meta.NormNum.isNat_minFac_3", "start": [103, 1], "end": [107, 61], "traced_tactics": [{"tactic": "rw [eq_comm, \u2190 Nat.dvd_iff_mod_eq_zero] at h2", "annotated_tactic": ["rw [<a>eq_comm</a>, \u2190 <a>Nat.dvd_iff_mod_eq_zero</a>] at h2", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "Nat.dvd_iff_mod_eq_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean", "def_pos": [83, 9], "def_end_pos": [83, 28]}]], "state_before": "n k : \u2115\nh1 : MinFacHelper n k\nh2 : 0 = n % k\n\u22a2 IsNat (minFac n) k", "state_after": "n k : \u2115\nh1 : MinFacHelper n k\nh2 : k \u2223 n\n\u22a2 IsNat (minFac n) k"}, {"tactic": "exact \u27e8le_antisymm (minFac_le_of_dvd h1.1.le h2) h1.2.2\u27e9", "annotated_tactic": ["exact \u27e8<a>le_antisymm</a> (<a>minFac_le_of_dvd</a> h1.1.<a>le</a> h2) h1.2.2\u27e9", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Nat.minFac_le_of_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Prime.lean", "def_pos": [335, 9], "def_end_pos": [335, 25]}, {"full_name": "LT.lt.le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [139, 7], "def_end_pos": [139, 15]}]], "state_before": "n k : \u2115\nh1 : MinFacHelper n k\nh2 : k \u2223 n\n\u22a2 IsNat (minFac n) k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.exists_max_image", "start": [1900, 1], "end": [1904, 72], "traced_tactics": [{"tactic": "cases' max_of_nonempty (h.image f) with y hy", "annotated_tactic": ["cases' <a>max_of_nonempty</a> (h.image f) with y hy", [{"full_name": "Finset.max_of_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1379, 9], "def_end_pos": [1379, 24]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\nh : s.Nonempty\n\u22a2 \u2203 x \u2208 s, \u2200 x' \u2208 s, f x' \u2264 f x", "state_after": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\nh : s.Nonempty\ny : \u03b1\nhy : Finset.max (image f s) = \u2191y\n\u22a2 \u2203 x \u2208 s, \u2200 x' \u2208 s, f x' \u2264 f x"}, {"tactic": "rcases mem_image.mp (mem_of_max hy) with \u27e8x, hx, rfl\u27e9", "annotated_tactic": ["rcases mem_image.mp (<a>mem_of_max</a> hy) with \u27e8x, hx, rfl\u27e9", [{"full_name": "Finset.mem_of_max", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1391, 9], "def_end_pos": [1391, 19]}]], "state_before": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\nh : s.Nonempty\ny : \u03b1\nhy : Finset.max (image f s) = \u2191y\n\u22a2 \u2203 x \u2208 s, \u2200 x' \u2208 s, f x' \u2264 f x", "state_after": "case intro.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\nh : s.Nonempty\nx : \u03b2\nhx : x \u2208 s\nhy : Finset.max (image f s) = \u2191(f x)\n\u22a2 \u2203 x \u2208 s, \u2200 x' \u2208 s, f x' \u2264 f x"}, {"tactic": "exact \u27e8x, hx, fun x' hx' => le_max_of_eq (mem_image_of_mem f hx') hy\u27e9", "annotated_tactic": ["exact \u27e8x, hx, fun x' hx' => <a>le_max_of_eq</a> (<a>mem_image_of_mem</a> f hx') hy\u27e9", [{"full_name": "Finset.le_max_of_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1412, 9], "def_end_pos": [1412, 21]}, {"full_name": "Finset.mem_image_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [365, 9], "def_end_pos": [365, 25]}]], "state_before": "case intro.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\nh : s.Nonempty\nx : \u03b2\nhx : x \u2208 s\nhy : Finset.max (image f s) = \u2191(f x)\n\u22a2 \u2203 x \u2208 s, \u2200 x' \u2208 s, f x' \u2264 f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.preimage_mul_preimage_subset", "start": [1314, 1], "end": [1316, 47], "traced_tactics": [{"tactic": "rintro _ \u27e8_, _, _, _, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8_, _, _, _, rfl\u27e9", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MulHomClass F \u03b1 \u03b2\nm : F\ns\u271d t\u271d : Set \u03b1\ns t : Set \u03b2\n\u22a2 \u21d1m \u207b\u00b9' s * \u21d1m \u207b\u00b9' t \u2286 \u21d1m \u207b\u00b9' (s * t)", "state_after": "case intro.intro.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MulHomClass F \u03b1 \u03b2\nm : F\ns\u271d t\u271d : Set \u03b1\ns t : Set \u03b2\nw\u271d\u00b9 : \u03b1\nleft\u271d\u00b9 : w\u271d\u00b9 \u2208 \u21d1m \u207b\u00b9' s\nw\u271d : \u03b1\nleft\u271d : w\u271d \u2208 \u21d1m \u207b\u00b9' t\n\u22a2 (fun x x_1 => x * x_1) w\u271d\u00b9 w\u271d \u2208 \u21d1m \u207b\u00b9' (s * t)"}, {"tactic": "exact \u27e8_, \u2039_\u203a, _, \u2039_\u203a, (map_mul m _ _).symm\u27e9", "annotated_tactic": ["exact \u27e8_, \u2039_\u203a, _, \u2039_\u203a, (<a>map_mul</a> m _ _).<a>symm</a>\u27e9", [{"full_name": "map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [308, 9], "def_end_pos": [308, 16]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case intro.intro.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MulHomClass F \u03b1 \u03b2\nm : F\ns\u271d t\u271d : Set \u03b1\ns t : Set \u03b2\nw\u271d\u00b9 : \u03b1\nleft\u271d\u00b9 : w\u271d\u00b9 \u2208 \u21d1m \u207b\u00b9' s\nw\u271d : \u03b1\nleft\u271d : w\u271d \u2208 \u21d1m \u207b\u00b9' t\n\u22a2 (fun x x_1 => x * x_1) w\u271d\u00b9 w\u271d \u2208 \u21d1m \u207b\u00b9' (s * t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Abel.lean", "full_name": "Mathlib.Tactic.Abel.subst_into_smulg", "start": [268, 1], "end": [270, 76], "traced_tactics": [{"tactic": "simp [prl, prr, prt]", "annotated_tactic": ["simp [prl, prr, prt]", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\nl : \u2124\nr : \u03b1\ntl : \u2124\ntr t : \u03b1\nprl : l = tl\nprr : r = tr\nprt : smulg tl tr = t\n\u22a2 smulg l r = t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_le_aleph0_iff", "start": [1620, 1], "end": [1621, 78], "traced_tactics": [{"tactic": "rw [countable_iff_nonempty_embedding, aleph0, \u2190 lift_uzero #\u03b1, lift_mk_le']", "annotated_tactic": ["rw [<a>countable_iff_nonempty_embedding</a>, <a>aleph0</a>, \u2190 <a>lift_uzero</a> #\u03b1, <a>lift_mk_le'</a>]", [{"full_name": "countable_iff_nonempty_embedding", "def_path": ".lake/packages/mathlib/Mathlib/Data/Countable/Basic.lean", "def_pos": [34, 9], "def_end_pos": [34, 41]}, {"full_name": "Cardinal.aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1266, 5], "def_end_pos": [1266, 11]}, {"full_name": "Cardinal.lift_uzero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [231, 9], "def_end_pos": [231, 19]}, {"full_name": "Cardinal.lift_mk_le'", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [320, 9], "def_end_pos": [320, 20]}]], "state_before": "\u03b1 \u03b2 : Type u\n\u22a2 #\u03b1 \u2264 \u2135\u2080 \u2194 Countable \u03b1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Digits.lean", "full_name": "Nat.digits_zero_succ'", "start": [107, 1], "end": [109, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.dotProduct_star", "start": [948, 1], "end": [948, 83], "traced_tactics": [{"tactic": "simp [dotProduct]", "annotated_tactic": ["simp [<a>dotProduct</a>]", [{"full_name": "Matrix.dotProduct", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [752, 5], "def_end_pos": [752, 15]}]], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : NonUnitalSemiring \u03b1\ninst\u271d : StarRing \u03b1\nv w : m \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 star w = star (w \u2b1d\u1d65 star v)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Notation.lean", "full_name": "Matrix.cons_vecMul", "start": [293, 1], "end": [296, 16], "traced_tactics": [{"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nB : Fin (Nat.succ n) \u2192 o' \u2192 \u03b1\n\u22a2 vecCons x v \u1d65* of B = x \u2022 vecHead B + v \u1d65* of vecTail B", "state_after": "case h\n\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nB : Fin (Nat.succ n) \u2192 o' \u2192 \u03b1\ni : o'\n\u22a2 (vecCons x v \u1d65* of B) i = (x \u2022 vecHead B + v \u1d65* of vecTail B) i"}, {"tactic": "simp [vecMul]", "annotated_tactic": ["simp [<a>vecMul</a>]", [{"full_name": "Matrix.vecMul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1695, 5], "def_end_pos": [1695, 11]}]], "state_before": "case h\n\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nB : Fin (Nat.succ n) \u2192 o' \u2192 \u03b1\ni : o'\n\u22a2 (vecCons x v \u1d65* of B) i = (x \u2022 vecHead B + v \u1d65* of vecTail B) i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Category/Preorder.lean", "full_name": "Monotone.functor_obj", "start": [142, 1], "end": [143, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "full_name": "AffineEquiv.affineIndependent_set_of_eq_iff", "start": [400, 1], "end": [404, 65], "traced_tactics": [{"tactic": "have : e \u2218 ((\u2191) : s \u2192 P) = ((\u2191) : e '' s \u2192 P\u2082) \u2218 (e : P \u2243 P\u2082).image s := rfl", "annotated_tactic": ["have : e \u2218 ((\u2191) : s \u2192 P) = ((\u2191) : e '' s \u2192 P\u2082) \u2218 (e : P \u2243 P\u2082).<a>image</a> s := <a>rfl</a>", [{"full_name": "Equiv.image", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Set.lean", "def_pos": [190, 5], "def_end_pos": [190, 10]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module k V\ninst\u271d\u00b3 : AffineSpace V P\n\u03b9 : Type u_4\nV\u2082 : Type u_5\nP\u2082 : Type u_6\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AffineSpace V\u2082 P\u2082\ns : Set P\ne : P \u2243\u1d43[k] P\u2082\n\u22a2 AffineIndependent k Subtype.val \u2194 AffineIndependent k Subtype.val", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module k V\ninst\u271d\u00b3 : AffineSpace V P\n\u03b9 : Type u_4\nV\u2082 : Type u_5\nP\u2082 : Type u_6\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AffineSpace V\u2082 P\u2082\ns : Set P\ne : P \u2243\u1d43[k] P\u2082\nthis : \u21d1e \u2218 Subtype.val = Subtype.val \u2218 \u21d1(Equiv.image (\u2191e) s)\n\u22a2 AffineIndependent k Subtype.val \u2194 AffineIndependent k Subtype.val"}, {"tactic": "erw [\u2190 e.affineIndependent_iff, this, affineIndependent_equiv]", "annotated_tactic": ["erw [\u2190 e.affineIndependent_iff, this, <a>affineIndependent_equiv</a>]", [{"full_name": "affineIndependent_equiv", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "def_pos": [326, 9], "def_end_pos": [326, 32]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2076 : Ring k\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module k V\ninst\u271d\u00b3 : AffineSpace V P\n\u03b9 : Type u_4\nV\u2082 : Type u_5\nP\u2082 : Type u_6\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module k V\u2082\ninst\u271d : AffineSpace V\u2082 P\u2082\ns : Set P\ne : P \u2243\u1d43[k] P\u2082\nthis : \u21d1e \u2218 Subtype.val = Subtype.val \u2218 \u21d1(Equiv.image (\u2191e) s)\n\u22a2 AffineIndependent k Subtype.val \u2194 AffineIndependent k Subtype.val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "full_name": "TendstoLocallyUniformlyOn.congr", "start": [789, 1], "end": [794, 64], "traced_tactics": [{"tactic": "rintro u hu x hx", "annotated_tactic": ["rintro u hu x hx", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\n\u22a2 TendstoLocallyUniformlyOn G f p s", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\n\u22a2 \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, G n y) \u2208 u"}, {"tactic": "obtain \u27e8t, ht, h\u27e9 := hf u hu x hx", "annotated_tactic": ["obtain \u27e8t, ht, h\u27e9 := hf u hu x hx", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\n\u22a2 \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, G n y) \u2208 u", "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\nt : Set \u03b1\nht : t \u2208 \ud835\udcdd[s] x\nh : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, G n y) \u2208 u"}, {"tactic": "refine' \u27e8s \u2229 t, inter_mem self_mem_nhdsWithin ht, _\u27e9", "annotated_tactic": ["refine' \u27e8s \u2229 t, <a>inter_mem</a> <a>self_mem_nhdsWithin</a> ht, _\u27e9", [{"full_name": "Filter.inter_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [159, 9], "def_end_pos": [159, 18]}, {"full_name": "self_mem_nhdsWithin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [148, 9], "def_end_pos": [148, 28]}]], "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\nt : Set \u03b1\nht : t \u2208 \ud835\udcdd[s] x\nh : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, G n y) \u2208 u", "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\nt : Set \u03b1\nht : t \u2208 \ud835\udcdd[s] x\nh : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 s \u2229 t, (f y, G n y) \u2208 u"}, {"tactic": "filter_upwards [h] with i hi y hy using hg i hy.1 \u25b8 hi y hy.2", "annotated_tactic": ["filter_upwards [h] with i hi y hy using hg i hy.1 \u25b8 hi y hy.2", []], "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhf : TendstoLocallyUniformlyOn F f p s\nhg : \u2200 (n : \u03b9), EqOn (F n) (G n) s\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\nt : Set \u03b1\nht : t \u2208 \ud835\udcdd[s] x\nh : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u\n\u22a2 \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 s \u2229 t, (f y, G n y) \u2208 u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/FiniteDimensional.lean", "full_name": "FiniteDimensional.of_fintype_basis", "start": [132, 1], "end": [133, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/Composition.lean", "full_name": "List.map_length_splitWrtCompositionAux", "start": [677, 1], "end": [685, 35], "traced_tactics": [{"tactic": "induction' ns with n ns IH <;> intro l h <;> simp at h", "annotated_tactic": ["induction' ns with n ns IH <;> intro l h <;> simp at h", []], "state_before": "n : \u2115\n\u03b1 : Type u_1\nns : List \u2115\n\u22a2 \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns", "state_after": "case nil\nn : \u2115\n\u03b1 : Type u_1\nl : List \u03b1\nh : True\n\u22a2 map length (splitWrtCompositionAux l []) = []\n\ncase cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\n\u22a2 map length (splitWrtCompositionAux l (n :: ns)) = n :: ns"}, {"tactic": "have := le_trans (Nat.le_add_right _ _) h", "annotated_tactic": ["have := <a>le_trans</a> (<a>Nat.le_add_right</a> _ _) h", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}]], "state_before": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\n\u22a2 map length (splitWrtCompositionAux l (n :: ns)) = n :: ns", "state_after": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 map length (splitWrtCompositionAux l (n :: ns)) = n :: ns"}, {"tactic": "simp only [splitWrtCompositionAux_cons, this]", "annotated_tactic": ["simp only [<a>splitWrtCompositionAux_cons</a>, this]", [{"full_name": "List.splitWrtCompositionAux_cons", "def_path": ".lake/packages/mathlib/Mathlib/Combinatorics/Composition.lean", "def_pos": [656, 9], "def_end_pos": [656, 36]}]], "state_before": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 map length (splitWrtCompositionAux l (n :: ns)) = n :: ns", "state_after": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 map length (take n l :: splitWrtCompositionAux (drop n l) ns) = n :: ns"}, {"tactic": "dsimp", "annotated_tactic": ["dsimp", []], "state_before": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 map length (take n l :: splitWrtCompositionAux (drop n l) ns) = n :: ns", "state_after": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 length (take n l) :: map length (splitWrtCompositionAux (drop n l) ns) = n :: ns"}, {"tactic": "rw [length_take, IH] <;> simp [length_drop]", "annotated_tactic": ["rw [<a>length_take</a>, IH] <;> simp [<a>length_drop</a>]", [{"full_name": "List.length_take", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [846, 17], "def_end_pos": [846, 28]}, {"full_name": "List.length_drop", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [277, 17], "def_end_pos": [277, 28]}]], "state_before": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 length (take n l) :: map length (splitWrtCompositionAux (drop n l) ns) = n :: ns", "state_after": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 n \u2264 length l\n\ncase cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 sum ns \u2264 length l - n"}, {"tactic": "simp [splitWrtCompositionAux]", "annotated_tactic": ["simp [<a>splitWrtCompositionAux</a>]", [{"full_name": "List.splitWrtCompositionAux", "def_path": ".lake/packages/mathlib/Mathlib/Combinatorics/Composition.lean", "def_pos": [636, 5], "def_end_pos": [636, 27]}]], "state_before": "case nil\nn : \u2115\n\u03b1 : Type u_1\nl : List \u03b1\nh : True\n\u22a2 map length (splitWrtCompositionAux l []) = []", "state_after": "no goals"}, {"tactic": "assumption", "annotated_tactic": ["assumption", []], "state_before": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 n \u2264 length l", "state_after": "no goals"}, {"tactic": "exact le_tsub_of_add_le_left h", "annotated_tactic": ["exact <a>le_tsub_of_add_le_left</a> h", [{"full_name": "le_tsub_of_add_le_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [235, 9], "def_end_pos": [235, 31]}]], "state_before": "case cons\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nns : List \u2115\nIH : \u2200 {l : List \u03b1}, sum ns \u2264 length l \u2192 map length (splitWrtCompositionAux l ns) = ns\nl : List \u03b1\nh : n + sum ns \u2264 length l\nthis : n \u2264 length l\n\u22a2 sum ns \u2264 length l - n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Star.lean", "full_name": "continuous_selfAdjointPart", "start": [50, 1], "end": [52, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.hasPushout_symmetry", "start": [1581, 1], "end": [1582, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Projection.lean", "full_name": "LinearMap.IsProj.codRestrict_apply", "start": [425, 1], "end": [426, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.mem_range_succ_iff", "start": [3174, 1], "end": [3175, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.mem_cyclicPermutations_iff", "start": [625, 1], "end": [637, 48], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\n\u22a2 l \u2208 cyclicPermutations l' \u2194 l ~r l'", "state_after": "case mp\n\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\n\u22a2 l \u2208 cyclicPermutations l' \u2192 l ~r l'\n\ncase mpr\n\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\n\u22a2 l ~r l' \u2192 l \u2208 cyclicPermutations l'"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mp\n\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\n\u22a2 l \u2208 cyclicPermutations l' \u2192 l ~r l'", "state_after": "case mp\n\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\nh : l \u2208 cyclicPermutations l'\n\u22a2 l ~r l'"}, {"tactic": "obtain \u27e8k, hk, rfl\u27e9 := nthLe_of_mem h", "annotated_tactic": ["obtain \u27e8k, hk, rfl\u27e9 := <a>nthLe_of_mem</a> h", [{"full_name": "List.nthLe_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1196, 9], "def_end_pos": [1196, 21]}]], "state_before": "case mp\n\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\nh : l \u2208 cyclicPermutations l'\n\u22a2 l ~r l'", "state_after": "case mp.intro.intro\n\u03b1 : Type u\nl l'\u271d l' : List \u03b1\nk : \u2115\nhk : k < length (cyclicPermutations l')\nh : nthLe (cyclicPermutations l') k hk \u2208 cyclicPermutations l'\n\u22a2 nthLe (cyclicPermutations l') k hk ~r l'"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case mp.intro.intro\n\u03b1 : Type u\nl l'\u271d l' : List \u03b1\nk : \u2115\nhk : k < length (cyclicPermutations l')\nh : nthLe (cyclicPermutations l') k hk \u2208 cyclicPermutations l'\n\u22a2 nthLe (cyclicPermutations l') k hk ~r l'", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mpr\n\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\n\u22a2 l ~r l' \u2192 l \u2208 cyclicPermutations l'", "state_after": "case mpr\n\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\nh : l ~r l'\n\u22a2 l \u2208 cyclicPermutations l'"}, {"tactic": "obtain \u27e8k, rfl\u27e9 := h.symm", "annotated_tactic": ["obtain \u27e8k, rfl\u27e9 := h.symm", []], "state_before": "case mpr\n\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\nh : l ~r l'\n\u22a2 l \u2208 cyclicPermutations l'", "state_after": "case mpr.intro\n\u03b1 : Type u\nl l'\u271d l' : List \u03b1\nk : \u2115\nh : rotate l' k ~r l'\n\u22a2 rotate l' k \u2208 cyclicPermutations l'"}, {"tactic": "rw [mem_iff_nthLe]", "annotated_tactic": ["rw [<a>mem_iff_nthLe</a>]", [{"full_name": "List.mem_iff_nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1224, 9], "def_end_pos": [1224, 22]}]], "state_before": "case mpr.intro\n\u03b1 : Type u\nl l'\u271d l' : List \u03b1\nk : \u2115\nh : rotate l' k ~r l'\n\u22a2 rotate l' k \u2208 cyclicPermutations l'", "state_after": "case mpr.intro\n\u03b1 : Type u\nl l'\u271d l' : List \u03b1\nk : \u2115\nh : rotate l' k ~r l'\n\u22a2 \u2203 n, \u2203 (h : n < length (cyclicPermutations l')), nthLe (cyclicPermutations l') n h = rotate l' k"}, {"tactic": "simp only [exists_prop, nthLe_cyclicPermutations]", "annotated_tactic": ["simp only [<a>exists_prop</a>, <a>nthLe_cyclicPermutations</a>]", [{"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "List.nthLe_cyclicPermutations", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [598, 9], "def_end_pos": [598, 33]}]], "state_before": "case mpr.intro\n\u03b1 : Type u\nl l'\u271d l' : List \u03b1\nk : \u2115\nh : rotate l' k ~r l'\n\u22a2 \u2203 n, \u2203 (h : n < length (cyclicPermutations l')), nthLe (cyclicPermutations l') n h = rotate l' k", "state_after": "case mpr.intro\n\u03b1 : Type u\nl l'\u271d l' : List \u03b1\nk : \u2115\nh : rotate l' k ~r l'\n\u22a2 \u2203 n < length (cyclicPermutations l'), rotate l' n = rotate l' k"}, {"tactic": "cases' l' with x l", "annotated_tactic": ["cases' l' with x l", []], "state_before": "case mpr.intro\n\u03b1 : Type u\nl l'\u271d l' : List \u03b1\nk : \u2115\nh : rotate l' k ~r l'\n\u22a2 \u2203 n < length (cyclicPermutations l'), rotate l' n = rotate l' k", "state_after": "case mpr.intro.nil\n\u03b1 : Type u\nl l' : List \u03b1\nk : \u2115\nh : rotate [] k ~r []\n\u22a2 \u2203 n < length (cyclicPermutations []), rotate [] n = rotate [] k\n\ncase mpr.intro.cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nk : \u2115\nx : \u03b1\nl : List \u03b1\nh : rotate (x :: l) k ~r (x :: l)\n\u22a2 \u2203 n < length (cyclicPermutations (x :: l)), rotate (x :: l) n = rotate (x :: l) k"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case mpr.intro.nil\n\u03b1 : Type u\nl l' : List \u03b1\nk : \u2115\nh : rotate [] k ~r []\n\u22a2 \u2203 n < length (cyclicPermutations []), rotate [] n = rotate [] k", "state_after": "no goals"}, {"tactic": "refine' \u27e8k % length (x :: l), _, rotate_mod _ _\u27e9", "annotated_tactic": ["refine' \u27e8k % <a>length</a> (x :: l), _, <a>rotate_mod</a> _ _\u27e9", [{"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}, {"full_name": "List.rotate_mod", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [35, 9], "def_end_pos": [35, 19]}]], "state_before": "case mpr.intro.cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nk : \u2115\nx : \u03b1\nl : List \u03b1\nh : rotate (x :: l) k ~r (x :: l)\n\u22a2 \u2203 n < length (cyclicPermutations (x :: l)), rotate (x :: l) n = rotate (x :: l) k", "state_after": "case mpr.intro.cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nk : \u2115\nx : \u03b1\nl : List \u03b1\nh : rotate (x :: l) k ~r (x :: l)\n\u22a2 k % length (x :: l) < length (cyclicPermutations (x :: l))"}, {"tactic": "simpa using Nat.mod_lt _ (zero_lt_succ _)", "annotated_tactic": ["simpa using <a>Nat.mod_lt</a> _ (<a>zero_lt_succ</a> _)", [{"full_name": "Nat.mod_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [123, 9], "def_end_pos": [123, 15]}, {"full_name": "Nat.zero_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1652, 9], "def_end_pos": [1652, 25]}]], "state_before": "case mpr.intro.cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nk : \u2115\nx : \u03b1\nl : List \u03b1\nh : rotate (x :: l) k ~r (x :: l)\n\u22a2 k % length (x :: l) < length (cyclicPermutations (x :: l))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/DirectSum/Basic.lean", "full_name": "DirectSum.induction_on", "start": [162, 11], "end": [167, 16], "traced_tactics": [{"tactic": "apply DFinsupp.induction x H_zero", "annotated_tactic": ["apply <a>DFinsupp.induction</a> x H_zero", [{"full_name": "DFinsupp.induction", "def_path": ".lake/packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [968, 19], "def_end_pos": [968, 28]}]], "state_before": "\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\n\u03b2 : \u03b9 \u2192 Type w\ninst\u271d : (i : \u03b9) \u2192 AddCommMonoid (\u03b2 i)\nC : (\u2a01 (i : \u03b9), \u03b2 i) \u2192 Prop\nx : \u2a01 (i : \u03b9), \u03b2 i\nH_zero : C 0\nH_basic : \u2200 (i : \u03b9) (x : \u03b2 i), C ((of \u03b2 i) x)\nH_plus : \u2200 (x y : \u2a01 (i : \u03b9), \u03b2 i), C x \u2192 C y \u2192 C (x + y)\n\u22a2 C x", "state_after": "\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\n\u03b2 : \u03b9 \u2192 Type w\ninst\u271d : (i : \u03b9) \u2192 AddCommMonoid (\u03b2 i)\nC : (\u2a01 (i : \u03b9), \u03b2 i) \u2192 Prop\nx : \u2a01 (i : \u03b9), \u03b2 i\nH_zero : C 0\nH_basic : \u2200 (i : \u03b9) (x : \u03b2 i), C ((of \u03b2 i) x)\nH_plus : \u2200 (x y : \u2a01 (i : \u03b9), \u03b2 i), C x \u2192 C y \u2192 C (x + y)\n\u22a2 \u2200 (i : \u03b9) (b : (fun i => \u03b2 i) i) (f : \u03a0\u2080 (i : \u03b9), (fun i => \u03b2 i) i),\n    f i = 0 \u2192 b \u2260 0 \u2192 C f \u2192 C (DFinsupp.single i b + f)"}, {"tactic": "intro i b f h1 h2 ih", "annotated_tactic": ["intro i b f h1 h2 ih", []], "state_before": "\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\n\u03b2 : \u03b9 \u2192 Type w\ninst\u271d : (i : \u03b9) \u2192 AddCommMonoid (\u03b2 i)\nC : (\u2a01 (i : \u03b9), \u03b2 i) \u2192 Prop\nx : \u2a01 (i : \u03b9), \u03b2 i\nH_zero : C 0\nH_basic : \u2200 (i : \u03b9) (x : \u03b2 i), C ((of \u03b2 i) x)\nH_plus : \u2200 (x y : \u2a01 (i : \u03b9), \u03b2 i), C x \u2192 C y \u2192 C (x + y)\n\u22a2 \u2200 (i : \u03b9) (b : (fun i => \u03b2 i) i) (f : \u03a0\u2080 (i : \u03b9), (fun i => \u03b2 i) i),\n    f i = 0 \u2192 b \u2260 0 \u2192 C f \u2192 C (DFinsupp.single i b + f)", "state_after": "\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\n\u03b2 : \u03b9 \u2192 Type w\ninst\u271d : (i : \u03b9) \u2192 AddCommMonoid (\u03b2 i)\nC : (\u2a01 (i : \u03b9), \u03b2 i) \u2192 Prop\nx : \u2a01 (i : \u03b9), \u03b2 i\nH_zero : C 0\nH_basic : \u2200 (i : \u03b9) (x : \u03b2 i), C ((of \u03b2 i) x)\nH_plus : \u2200 (x y : \u2a01 (i : \u03b9), \u03b2 i), C x \u2192 C y \u2192 C (x + y)\ni : \u03b9\nb : \u03b2 i\nf : \u03a0\u2080 (i : \u03b9), (fun i => \u03b2 i) i\nh1 : f i = 0\nh2 : b \u2260 0\nih : C f\n\u22a2 C (DFinsupp.single i b + f)"}, {"tactic": "solve_by_elim", "annotated_tactic": ["solve_by_elim", []], "state_before": "\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\n\u03b2 : \u03b9 \u2192 Type w\ninst\u271d : (i : \u03b9) \u2192 AddCommMonoid (\u03b2 i)\nC : (\u2a01 (i : \u03b9), \u03b2 i) \u2192 Prop\nx : \u2a01 (i : \u03b9), \u03b2 i\nH_zero : C 0\nH_basic : \u2200 (i : \u03b9) (x : \u03b2 i), C ((of \u03b2 i) x)\nH_plus : \u2200 (x y : \u2a01 (i : \u03b9), \u03b2 i), C x \u2192 C y \u2192 C (x + y)\ni : \u03b9\nb : \u03b2 i\nf : \u03a0\u2080 (i : \u03b9), (fun i => \u03b2 i) i\nh1 : f i = 0\nh2 : b \u2260 0\nih : C f\n\u22a2 C (DFinsupp.single i b + f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Subfield.lean", "full_name": "Subfield.coe_iSup_of_directed", "start": [780, 1], "end": [782, 53], "traced_tactics": [{"tactic": "simp [mem_iSup_of_directed hS]", "annotated_tactic": ["simp [<a>mem_iSup_of_directed</a> hS]", [{"full_name": "Subfield.mem_iSup_of_directed", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Subfield.lean", "def_pos": [769, 9], "def_end_pos": [769, 29]}]], "state_before": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : DivisionRing L\ninst\u271d : DivisionRing M\n\u03b9 : Sort u_1\nh\u03b9 : Nonempty \u03b9\nS : \u03b9 \u2192 Subfield K\nhS : Directed (fun x x_1 => x \u2264 x_1) S\nx : K\n\u22a2 x \u2208 \u2191(\u2a06 i, S i) \u2194 x \u2208 \u22c3 i, \u2191(S i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/Subalgebra.lean", "full_name": "StarSubalgebra.coe_centralizer", "start": [303, 1], "end": [304, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Comp.lean", "full_name": "deriv.comp", "start": [190, 1], "end": [192, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Periodic.lean", "full_name": "Function.Periodic.sub_antiperiod", "start": [521, 1], "end": [523, 61], "traced_tactics": [{"tactic": "simpa only [sub_eq_add_neg] using h1.add_antiperiod h2.neg", "annotated_tactic": ["simpa only [<a>sub_eq_add_neg</a>] using h1.add_antiperiod h2.neg", [{"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf g : \u03b1 \u2192 \u03b2\nc c\u2081 c\u2082 x : \u03b1\ninst\u271d\u00b9 : AddGroup \u03b1\ninst\u271d : InvolutiveNeg \u03b2\nh1 : Periodic f c\u2081\nh2 : Antiperiodic f c\u2082\n\u22a2 Antiperiodic f (c\u2081 - c\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.Monic.isUnit_leadingCoeff_of_dvd", "start": [1502, 1], "end": [1504, 94], "traced_tactics": [{"tactic": "simpa only [hp.leadingCoeff] using leadingCoeff_dvd_leadingCoeff hap", "annotated_tactic": ["simpa only [hp.leadingCoeff] using <a>leadingCoeff_dvd_leadingCoeff</a> hap", [{"full_name": "Polynomial.leadingCoeff_dvd_leadingCoeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1688, 9], "def_end_pos": [1688, 38]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na\u271d b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q a p : R[X]\nhp : Monic p\nhap : a \u2223 p\n\u22a2 Polynomial.leadingCoeff a \u2223 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/W/Cardinal.lean", "full_name": "WType.cardinal_mk_le_max_aleph0_of_finite'", "start": [58, 1], "end": [84, 96], "traced_tactics": [{"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\n\u22a2 IsEmpty \u03b1 \u2192 #(WType \u03b2) \u2264 max (lift.{v, u} #\u03b1) \u2135\u2080", "state_after": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nh : IsEmpty \u03b1\n\u22a2 #(WType \u03b2) \u2264 max (lift.{v, u} #\u03b1) \u2135\u2080"}, {"tactic": "rw [Cardinal.mk_eq_zero (WType \u03b2)]", "annotated_tactic": ["rw [<a>Cardinal.mk_eq_zero</a> (<a>WType</a> \u03b2)]", [{"full_name": "Cardinal.mk_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [382, 9], "def_end_pos": [382, 19]}, {"full_name": "WType", "def_path": ".lake/packages/mathlib/Mathlib/Data/W/Basic.lean", "def_pos": [37, 11], "def_end_pos": [37, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nh : IsEmpty \u03b1\n\u22a2 #(WType \u03b2) \u2264 max (lift.{v, u} #\u03b1) \u2135\u2080", "state_after": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nh : IsEmpty \u03b1\n\u22a2 0 \u2264 max (lift.{v, u} #\u03b1) \u2135\u2080"}, {"tactic": "exact zero_le _", "annotated_tactic": ["exact <a>zero_le</a> _", [{"full_name": "zero_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [204, 30], "def_end_pos": [204, 37]}]], "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nh : IsEmpty \u03b1\n\u22a2 0 \u2264 max (lift.{v, u} #\u03b1) \u2135\u2080", "state_after": "no goals"}, {"tactic": "rw [succ_zero]", "annotated_tactic": ["rw [<a>succ_zero</a>]", [{"full_name": "Cardinal.succ_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1492, 9], "def_end_pos": [1492, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nhn : Nonempty \u03b1\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\n\u22a2 Order.succ 0 \u2264 \u2a06 a, m ^ lift.{u, v} #(\u03b2 a)", "state_after": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nhn : Nonempty \u03b1\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\n\u22a2 1 \u2264 \u2a06 a, m ^ lift.{u, v} #(\u03b2 a)"}, {"tactic": "obtain \u27e8a\u27e9 : Nonempty \u03b1 := hn", "annotated_tactic": ["obtain \u27e8a\u27e9 : <a>Nonempty</a> \u03b1 := hn", [{"full_name": "Nonempty", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [704, 17], "def_end_pos": [704, 25]}]], "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nhn : Nonempty \u03b1\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\n\u22a2 1 \u2264 \u2a06 a, m ^ lift.{u, v} #(\u03b2 a)", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\na : \u03b1\n\u22a2 1 \u2264 \u2a06 a, m ^ lift.{u, v} #(\u03b2 a)"}, {"tactic": "refine' le_trans _ (le_ciSup (bddAbove_range.{_, v} _) a)", "annotated_tactic": ["refine' <a>le_trans</a> _ (<a>le_ciSup</a> (<a>bddAbove_range</a>.{_, v} _) a)", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "le_ciSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [801, 9], "def_end_pos": [801, 17]}, {"full_name": "Cardinal.bddAbove_range", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [956, 9], "def_end_pos": [956, 23]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\na : \u03b1\n\u22a2 1 \u2264 \u2a06 a, m ^ lift.{u, v} #(\u03b2 a)", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\na : \u03b1\n\u22a2 1 \u2264 m ^ lift.{u, v} #(\u03b2 a)"}, {"tactic": "rw [\u2190 power_zero]", "annotated_tactic": ["rw [\u2190 <a>power_zero</a>]", [{"full_name": "Cardinal.power_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [503, 9], "def_end_pos": [503, 19]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\na : \u03b1\n\u22a2 1 \u2264 m ^ lift.{u, v} #(\u03b2 a)", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\na : \u03b1\n\u22a2 ?m.3765 ^ 0 \u2264 m ^ lift.{u, v} #(\u03b2 a)\n\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\na : \u03b1\n\u22a2 Cardinal.{max u v}"}, {"tactic": "exact\n  power_le_power_left\n    (pos_iff_ne_zero.1 (aleph0_pos.trans_le (le_max_right _ _))) (zero_le _)", "annotated_tactic": ["exact\n                    <a>power_le_power_left</a>\n                      (<a>pos_iff_ne_zero</a>.1 (aleph0_pos.trans_le (<a>le_max_right</a> _ _))) (<a>zero_le</a> _)", [{"full_name": "Cardinal.power_le_power_left", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [722, 9], "def_end_pos": [722, 28]}, {"full_name": "pos_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [230, 3], "def_end_pos": [230, 14]}, {"full_name": "le_max_right", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [61, 9], "def_end_pos": [61, 21]}, {"full_name": "zero_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [204, 30], "def_end_pos": [204, 37]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\na : \u03b1\n\u22a2 ?m.3765 ^ 0 \u2264 m ^ lift.{u, v} #(\u03b2 a)\n\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : \u2200 (a : \u03b1), Finite (\u03b2 a)\nm : Cardinal.{max u v} := max (lift.{v, u} #\u03b1) \u2135\u2080\na : \u03b1\n\u22a2 Cardinal.{max u v}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Defs.lean", "full_name": "smul_add_smul_lt_smul_add_smul", "start": [910, 1], "end": [918, 70], "traced_tactics": [{"tactic": "obtain \u27e8b\u2082, rfl\u27e9 := exists_add_of_le hab.le", "annotated_tactic": ["obtain \u27e8b\u2082, rfl\u27e9 := <a>exists_add_of_le</a> hab.le", [{"full_name": "ExistsAddOfLE.exists_add_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [34, 3], "def_end_pos": [34, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2075 : OrderedRing \u03b1\ninst\u271d\u2074 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b3 : Module \u03b1 \u03b2\ninst\u271d\u00b2 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d\u00b9 : CovariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\ninst\u271d : ContravariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\nb\u2081 b\u2082 : \u03b1\na d : \u03b2\nhab : b\u2081 < b\u2082\nhcd : a < d\n\u22a2 b\u2081 \u2022 d + b\u2082 \u2022 a < b\u2081 \u2022 a + b\u2082 \u2022 d", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2075 : OrderedRing \u03b1\ninst\u271d\u2074 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b3 : Module \u03b1 \u03b2\ninst\u271d\u00b2 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d\u00b9 : CovariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\ninst\u271d : ContravariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\nb\u2081 : \u03b1\na d : \u03b2\nhcd : a < d\nb\u2082 : \u03b1\nhab : b\u2081 < b\u2081 + b\u2082\n\u22a2 b\u2081 \u2022 d + (b\u2081 + b\u2082) \u2022 a < b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 d"}, {"tactic": "obtain \u27e8d, rfl\u27e9 := exists_add_of_le hcd.le", "annotated_tactic": ["obtain \u27e8d, rfl\u27e9 := <a>exists_add_of_le</a> hcd.le", [{"full_name": "ExistsAddOfLE.exists_add_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [34, 3], "def_end_pos": [34, 19]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2075 : OrderedRing \u03b1\ninst\u271d\u2074 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b3 : Module \u03b1 \u03b2\ninst\u271d\u00b2 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d\u00b9 : CovariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\ninst\u271d : ContravariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\nb\u2081 : \u03b1\na d : \u03b2\nhcd : a < d\nb\u2082 : \u03b1\nhab : b\u2081 < b\u2081 + b\u2082\n\u22a2 b\u2081 \u2022 d + (b\u2081 + b\u2082) \u2022 a < b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 d", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2075 : OrderedRing \u03b1\ninst\u271d\u2074 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b3 : Module \u03b1 \u03b2\ninst\u271d\u00b2 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d\u00b9 : CovariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\ninst\u271d : ContravariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\nb\u2081 : \u03b1\na : \u03b2\nb\u2082 : \u03b1\nhab : b\u2081 < b\u2081 + b\u2082\nd : \u03b2\nhcd : a < a + d\n\u22a2 b\u2081 \u2022 (a + d) + (b\u2081 + b\u2082) \u2022 a < b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 (a + d)"}, {"tactic": "rw [smul_add, add_right_comm, smul_add, \u2190 add_assoc, add_smul _ _ d]", "annotated_tactic": ["rw [<a>smul_add</a>, <a>add_right_comm</a>, <a>smul_add</a>, \u2190 <a>add_assoc</a>, <a>add_smul</a> _ _ d]", [{"full_name": "smul_add", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [843, 9], "def_end_pos": [843, 17]}, {"full_name": "add_right_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [161, 3], "def_end_pos": [161, 14]}, {"full_name": "smul_add", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [843, 9], "def_end_pos": [843, 17]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "add_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [92, 9], "def_end_pos": [92, 17]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2075 : OrderedRing \u03b1\ninst\u271d\u2074 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b3 : Module \u03b1 \u03b2\ninst\u271d\u00b2 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d\u00b9 : CovariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\ninst\u271d : ContravariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\nb\u2081 : \u03b1\na : \u03b2\nb\u2082 : \u03b1\nhab : b\u2081 < b\u2081 + b\u2082\nd : \u03b2\nhcd : a < a + d\n\u22a2 b\u2081 \u2022 (a + d) + (b\u2081 + b\u2082) \u2022 a < b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 (a + d)", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2075 : OrderedRing \u03b1\ninst\u271d\u2074 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b3 : Module \u03b1 \u03b2\ninst\u271d\u00b2 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d\u00b9 : CovariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\ninst\u271d : ContravariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\nb\u2081 : \u03b1\na : \u03b2\nb\u2082 : \u03b1\nhab : b\u2081 < b\u2081 + b\u2082\nd : \u03b2\nhcd : a < a + d\n\u22a2 b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 a + b\u2081 \u2022 d < b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 a + (b\u2081 \u2022 d + b\u2082 \u2022 d)"}, {"tactic": "rw [lt_add_iff_pos_right] at hab hcd", "annotated_tactic": ["rw [<a>lt_add_iff_pos_right</a>] at hab hcd", [{"full_name": "lt_add_iff_pos_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [563, 30], "def_end_pos": [563, 50]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2075 : OrderedRing \u03b1\ninst\u271d\u2074 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b3 : Module \u03b1 \u03b2\ninst\u271d\u00b2 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d\u00b9 : CovariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\ninst\u271d : ContravariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\nb\u2081 : \u03b1\na : \u03b2\nb\u2082 : \u03b1\nhab : b\u2081 < b\u2081 + b\u2082\nd : \u03b2\nhcd : a < a + d\n\u22a2 b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 a + b\u2081 \u2022 d < b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 a + (b\u2081 \u2022 d + b\u2082 \u2022 d)", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2075 : OrderedRing \u03b1\ninst\u271d\u2074 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b3 : Module \u03b1 \u03b2\ninst\u271d\u00b2 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d\u00b9 : CovariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\ninst\u271d : ContravariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\nb\u2081 : \u03b1\na : \u03b2\nb\u2082 : \u03b1\nhab : 0 < b\u2082\nd : \u03b2\nhcd : 0 < d\n\u22a2 b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 a + b\u2081 \u2022 d < b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 a + (b\u2081 \u2022 d + b\u2082 \u2022 d)"}, {"tactic": "exact add_lt_add_left (lt_add_of_pos_right _ <| smul_pos hab hcd) _", "annotated_tactic": ["exact <a>add_lt_add_left</a> (<a>lt_add_of_pos_right</a> _ <| <a>smul_pos</a> hab hcd) _", [{"full_name": "add_lt_add_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [120, 32], "def_end_pos": [120, 47]}, {"full_name": "lt_add_of_pos_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [495, 15], "def_end_pos": [495, 34]}, {"full_name": "smul_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Module/Defs.lean", "def_pos": [453, 7], "def_end_pos": [453, 15]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2075 : OrderedRing \u03b1\ninst\u271d\u2074 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b3 : Module \u03b1 \u03b2\ninst\u271d\u00b2 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d\u00b9 : CovariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\ninst\u271d : ContravariantClass \u03b2 \u03b2 (fun x x_1 => x + x_1) fun x x_1 => x < x_1\nb\u2081 : \u03b1\na : \u03b2\nb\u2082 : \u03b1\nhab : 0 < b\u2082\nd : \u03b2\nhcd : 0 < d\n\u22a2 b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 a + b\u2081 \u2022 d < b\u2081 \u2022 a + (b\u2081 + b\u2082) \u2022 a + (b\u2081 \u2022 d + b\u2082 \u2022 d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Group/Lattice.lean", "full_name": "sup_mul", "start": [54, 1], "end": [55, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.erase_inter", "start": [2354, 1], "end": [2355, 52], "traced_tactics": [{"tactic": "simpa only [inter_comm t] using inter_erase a t s", "annotated_tactic": ["simpa only [<a>inter_comm</a> t] using <a>inter_erase</a> a t s", [{"full_name": "Finset.inter_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1679, 9], "def_end_pos": [1679, 19]}, {"full_name": "Finset.inter_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2349, 9], "def_end_pos": [2349, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t\u271d u v : Finset \u03b1\na\u271d b a : \u03b1\ns t : Finset \u03b1\n\u22a2 erase s a \u2229 t = erase (s \u2229 t) a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/PiSystem.lean", "full_name": "mem_generatePiSystem_iUnion_elim'", "start": [318, 1], "end": [348, 16], "traced_tactics": [{"tactic": "have : t \u2208 generatePiSystem (\u22c3 b : Subtype s, (g \u2218 Subtype.val) b) := by\n  suffices h1 : \u22c3 b : Subtype s, (g \u2218 Subtype.val) b = \u22c3 b \u2208 s, g b by rwa [h1]\n  ext x\n  simp only [exists_prop, Set.mem_iUnion, Function.comp_apply, Subtype.exists, Subtype.coe_mk]\n  rfl", "annotated_tactic": ["have : t \u2208 <a>generatePiSystem</a> (\u22c3 b : <a>Subtype</a> s, (g \u2218 <a>Subtype.val</a>) b) := by\n    suffices h1 : \u22c3 b : <a>Subtype</a> s, (g \u2218 <a>Subtype.val</a>) b = \u22c3 b \u2208 s, g b by rwa [h1]\n    ext x\n    simp only [<a>exists_prop</a>, <a>Set.mem_iUnion</a>, <a>Function.comp_apply</a>, <a>Subtype.exists</a>, <a>Subtype.coe_mk</a>]\n    rfl", [{"full_name": "generatePiSystem", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/PiSystem.lean", "def_pos": [228, 11], "def_end_pos": [228, 27]}, {"full_name": "Subtype", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [578, 11], "def_end_pos": [578, 18]}, {"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}, {"full_name": "Subtype", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [578, 11], "def_end_pos": [578, 18]}, {"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "Set.mem_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [272, 9], "def_end_pos": [272, 19]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "Subtype.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [54, 19], "def_end_pos": [54, 27]}, {"full_name": "Subtype.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [99, 9], "def_end_pos": [99, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\n\u22a2 \u2203 T f, \u2191T \u2286 s \u2227 t = \u22c2 b \u2208 T, f b \u2227 \u2200 b \u2208 T, f b \u2208 g b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : t \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\n\u22a2 \u2203 T f, \u2191T \u2286 s \u2227 t = \u22c2 b \u2208 T, f b \u2227 \u2200 b \u2208 T, f b \u2208 g b"}, {"tactic": "rcases @mem_generatePiSystem_iUnion_elim \u03b1 (Subtype s) (g \u2218 Subtype.val)\n    (fun b => h_pi b.val b.property) t this with\n  \u27e8T, \u27e8f, \u27e8rfl, h_t'\u27e9\u27e9\u27e9", "annotated_tactic": ["rcases @<a>mem_generatePiSystem_iUnion_elim</a> \u03b1 (<a>Subtype</a> s) (g \u2218 <a>Subtype.val</a>)\n      (fun b => h_pi b.val b.property) t this with\n    \u27e8T, \u27e8f, \u27e8rfl, h_t'\u27e9\u27e9\u27e9", [{"full_name": "mem_generatePiSystem_iUnion_elim", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/PiSystem.lean", "def_pos": [284, 9], "def_end_pos": [284, 41]}, {"full_name": "Subtype", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [578, 11], "def_end_pos": [578, 18]}, {"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : t \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\n\u22a2 \u2203 T f, \u2191T \u2286 s \u2227 t = \u22c2 b \u2208 T, f b \u2227 \u2200 b \u2208 T, f b \u2208 g b", "state_after": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\n\u22a2 \u2203 T_1 f_1, \u2191T_1 \u2286 s \u2227 \u22c2 b \u2208 T, f b = \u22c2 b \u2208 T_1, f_1 b \u2227 \u2200 b \u2208 T_1, f_1 b \u2208 g b"}, {"tactic": "refine'\n  \u27e8T.image (fun x : s => (x : \u03b2)),\n    Function.extend (fun x : s => (x : \u03b2)) f fun _ : \u03b2 => (\u2205 : Set \u03b1), by simp, _, _\u27e9", "annotated_tactic": ["refine'\n    \u27e8T.image (fun x : s => (x : \u03b2)),\n      <a>Function.extend</a> (fun x : s => (x : \u03b2)) f fun _ : \u03b2 => (\u2205 : <a>Set</a> \u03b1), by simp, _, _\u27e9", [{"full_name": "Function.extend", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [720, 5], "def_end_pos": [720, 11]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}]], "state_before": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\n\u22a2 \u2203 T_1 f_1, \u2191T_1 \u2286 s \u2227 \u22c2 b \u2208 T, f b = \u22c2 b \u2208 T_1, f_1 b \u2227 \u2200 b \u2208 T_1, f_1 b \u2208 g b", "state_after": "case intro.intro.intro.refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\n\u22a2 \u22c2 b \u2208 T, f b = \u22c2 b \u2208 Finset.image (fun x => \u2191x) T, Function.extend (fun x => \u2191x) f (fun x => \u2205) b\n\ncase intro.intro.intro.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\n\u22a2 \u2200 b \u2208 Finset.image (fun x => \u2191x) T, Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b"}, {"tactic": "suffices h1 : \u22c3 b : Subtype s, (g \u2218 Subtype.val) b = \u22c3 b \u2208 s, g b by rwa [h1]", "annotated_tactic": ["suffices h1 : \u22c3 b : <a>Subtype</a> s, (g \u2218 <a>Subtype.val</a>) b = \u22c3 b \u2208 s, g b by rwa [h1]", [{"full_name": "Subtype", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [578, 11], "def_end_pos": [578, 18]}, {"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\n\u22a2 t \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\n\u22a2 \u22c3 b, (g \u2218 Subtype.val) b = \u22c3 b \u2208 s, g b"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\n\u22a2 \u22c3 b, (g \u2218 Subtype.val) b = \u22c3 b \u2208 s, g b", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nx : Set \u03b1\n\u22a2 x \u2208 \u22c3 b, (g \u2218 Subtype.val) b \u2194 x \u2208 \u22c3 b \u2208 s, g b"}, {"tactic": "simp only [exists_prop, Set.mem_iUnion, Function.comp_apply, Subtype.exists, Subtype.coe_mk]", "annotated_tactic": ["simp only [<a>exists_prop</a>, <a>Set.mem_iUnion</a>, <a>Function.comp_apply</a>, <a>Subtype.exists</a>, <a>Subtype.coe_mk</a>]", [{"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "Set.mem_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [272, 9], "def_end_pos": [272, 19]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "Subtype.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [54, 19], "def_end_pos": [54, 27]}, {"full_name": "Subtype.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [99, 9], "def_end_pos": [99, 15]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nx : Set \u03b1\n\u22a2 x \u2208 \u22c3 b, (g \u2218 Subtype.val) b \u2194 x \u2208 \u22c3 b \u2208 s, g b", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nx : Set \u03b1\n\u22a2 (\u2203 a, s a \u2227 x \u2208 g a) \u2194 \u2203 i \u2208 s, x \u2208 g i"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nx : Set \u03b1\n\u22a2 (\u2203 a, s a \u2227 x \u2208 g a) \u2194 \u2203 i \u2208 s, x \u2208 g i", "state_after": "no goals"}, {"tactic": "rwa [h1]", "annotated_tactic": ["rwa [h1]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nt : Set \u03b1\nh_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nh1 : \u22c3 b, (g \u2218 Subtype.val) b = \u22c3 b \u2208 s, g b\n\u22a2 t \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\n\u22a2 \u2191(Finset.image (fun x => \u2191x) T) \u2286 s", "state_after": "no goals"}, {"tactic": "ext a", "annotated_tactic": ["ext a", []], "state_before": "case intro.intro.intro.refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\n\u22a2 \u22c2 b \u2208 T, f b = \u22c2 b \u2208 Finset.image (fun x => \u2191x) T, Function.extend (fun x => \u2191x) f (fun x => \u2205) b", "state_after": "case intro.intro.intro.refine'_1.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\n\u22a2 a \u2208 \u22c2 b \u2208 T, f b \u2194 a \u2208 \u22c2 b \u2208 Finset.image (fun x => \u2191x) T, Function.extend (fun x => \u2191x) f (fun x => \u2205) b"}, {"tactic": "simp (config := { proj := false }) only\n  [Set.mem_iInter, Subtype.forall, Finset.set_biInter_finset_image]", "annotated_tactic": ["simp (config := { proj := <a>false</a> }) only\n          [<a>Set.mem_iInter</a>, <a>Subtype.forall</a>, <a>Finset.set_biInter_finset_image</a>]", [{"full_name": "Bool.false", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [565, 5], "def_end_pos": [565, 10]}, {"full_name": "Set.mem_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [278, 9], "def_end_pos": [278, 19]}, {"full_name": "Subtype.forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [43, 19], "def_end_pos": [43, 27]}, {"full_name": "Finset.set_biInter_finset_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [2250, 9], "def_end_pos": [2250, 33]}]], "state_before": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\n\u22a2 a \u2208 \u22c2 b \u2208 Finset.image (fun x => \u2191x) T, Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2192 a \u2208 \u22c2 b \u2208 T, f b", "state_after": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\n\u22a2 (\u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n      { val := a_1, property := b } \u2208 T \u2192\n        a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }) \u2192\n    \u2200 (a_2 : \u03b2) (b : s a_2), { val := a_2, property := b } \u2208 T \u2192 a \u2208 f { val := a_2, property := b }"}, {"tactic": "intro h1 b h_b h_b_in_T", "annotated_tactic": ["intro h1 b h_b h_b_in_T", []], "state_before": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\n\u22a2 (\u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n      { val := a_1, property := b } \u2208 T \u2192\n        a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }) \u2192\n    \u2200 (a_2 : \u03b2) (b : s a_2), { val := a_2, property := b } \u2208 T \u2192 a \u2208 f { val := a_2, property := b }", "state_after": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\nh1 :\n  \u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n    { val := a_1, property := b } \u2208 T \u2192 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }\nb : \u03b2\nh_b : s b\nh_b_in_T : { val := b, property := h_b } \u2208 T\n\u22a2 a \u2208 f { val := b, property := h_b }"}, {"tactic": "have h2 := h1 b h_b h_b_in_T", "annotated_tactic": ["have h2 := h1 b h_b h_b_in_T", []], "state_before": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\nh1 :\n  \u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n    { val := a_1, property := b } \u2208 T \u2192 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }\nb : \u03b2\nh_b : s b\nh_b_in_T : { val := b, property := h_b } \u2208 T\n\u22a2 a \u2208 f { val := b, property := h_b }", "state_after": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\nh1 :\n  \u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n    { val := a_1, property := b } \u2208 T \u2192 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }\nb : \u03b2\nh_b : s b\nh_b_in_T : { val := b, property := h_b } \u2208 T\nh2 : a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := b, property := h_b }\n\u22a2 a \u2208 f { val := b, property := h_b }"}, {"tactic": "revert h2", "annotated_tactic": ["revert h2", []], "state_before": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\nh1 :\n  \u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n    { val := a_1, property := b } \u2208 T \u2192 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }\nb : \u03b2\nh_b : s b\nh_b_in_T : { val := b, property := h_b } \u2208 T\nh2 : a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := b, property := h_b }\n\u22a2 a \u2208 f { val := b, property := h_b }", "state_after": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\nh1 :\n  \u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n    { val := a_1, property := b } \u2208 T \u2192 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }\nb : \u03b2\nh_b : s b\nh_b_in_T : { val := b, property := h_b } \u2208 T\n\u22a2 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := b, property := h_b } \u2192 a \u2208 f { val := b, property := h_b }"}, {"tactic": "rw [Subtype.val_injective.extend_apply]", "annotated_tactic": ["rw [Subtype.val_injective.extend_apply]", []], "state_before": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\nh1 :\n  \u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n    { val := a_1, property := b } \u2208 T \u2192 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }\nb : \u03b2\nh_b : s b\nh_b_in_T : { val := b, property := h_b } \u2208 T\n\u22a2 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := b, property := h_b } \u2192 a \u2208 f { val := b, property := h_b }", "state_after": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\nh1 :\n  \u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n    { val := a_1, property := b } \u2208 T \u2192 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }\nb : \u03b2\nh_b : s b\nh_b_in_T : { val := b, property := h_b } \u2208 T\n\u22a2 a \u2208 f { val := b, property := h_b } \u2192 a \u2208 f { val := b, property := h_b }"}, {"tactic": "apply id", "annotated_tactic": ["apply <a>id</a>", [{"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "case intro.intro.intro.refine'_1.h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\na : \u03b1\nh1 :\n  \u2200 (a_1 : \u03b2) (b : a_1 \u2208 s),\n    { val := a_1, property := b } \u2208 T \u2192 a \u2208 Function.extend (fun x => \u2191x) f (fun x => \u2205) \u2191{ val := a_1, property := b }\nb : \u03b2\nh_b : s b\nh_b_in_T : { val := b, property := h_b } \u2208 T\n\u22a2 a \u2208 f { val := b, property := h_b } \u2192 a \u2208 f { val := b, property := h_b }", "state_after": "no goals"}, {"tactic": "intros b h_b", "annotated_tactic": ["intros b h_b", []], "state_before": "case intro.intro.intro.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\n\u22a2 \u2200 b \u2208 Finset.image (fun x => \u2191x) T, Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b", "state_after": "case intro.intro.intro.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b : b \u2208 Finset.image (fun x => \u2191x) T\n\u22a2 Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b"}, {"tactic": "simp_rw [Finset.mem_image, Subtype.exists, exists_and_right, exists_eq_right]\n  at h_b", "annotated_tactic": ["simp_rw [<a>Finset.mem_image</a>, <a>Subtype.exists</a>, <a>exists_and_right</a>, <a>exists_eq_right</a>]\n      at h_b", [{"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}, {"full_name": "Subtype.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [54, 19], "def_end_pos": [54, 27]}, {"full_name": "exists_and_right", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [224, 17], "def_end_pos": [224, 33]}, {"full_name": "exists_eq_right", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [218, 17], "def_end_pos": [218, 32]}]], "state_before": "case intro.intro.intro.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b : b \u2208 Finset.image (fun x => \u2191x) T\n\u22a2 Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b", "state_after": "case intro.intro.intro.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b : \u2203 (x : b \u2208 s), { val := b, property := \u22ef } \u2208 T\n\u22a2 Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b"}, {"tactic": "cases' h_b with h_b_w h_b_h", "annotated_tactic": ["cases' h_b with h_b_w h_b_h", []], "state_before": "case intro.intro.intro.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b : \u2203 (x : b \u2208 s), { val := b, property := \u22ef } \u2208 T\n\u22a2 Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b", "state_after": "case intro.intro.intro.refine'_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b_w : b \u2208 s\nh_b_h : { val := b, property := \u22ef } \u2208 T\n\u22a2 Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b"}, {"tactic": "have h_b_alt : b = (Subtype.mk b h_b_w).val := rfl", "annotated_tactic": ["have h_b_alt : b = (<a>Subtype.mk</a> b h_b_w).<a>val</a> := <a>rfl</a>", [{"full_name": "Subtype.mk", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [578, 11], "def_end_pos": [578, 18]}, {"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro.intro.intro.refine'_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b_w : b \u2208 s\nh_b_h : { val := b, property := \u22ef } \u2208 T\n\u22a2 Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b", "state_after": "case intro.intro.intro.refine'_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b_w : b \u2208 s\nh_b_h : { val := b, property := \u22ef } \u2208 T\nh_b_alt : b = \u2191{ val := b, property := h_b_w }\n\u22a2 Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b"}, {"tactic": "rw [h_b_alt, Subtype.val_injective.extend_apply]", "annotated_tactic": ["rw [h_b_alt, Subtype.val_injective.extend_apply]", []], "state_before": "case intro.intro.intro.refine'_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b_w : b \u2208 s\nh_b_h : { val := b, property := \u22ef } \u2208 T\nh_b_alt : b = \u2191{ val := b, property := h_b_w }\n\u22a2 Function.extend (fun x => \u2191x) f (fun x => \u2205) b \u2208 g b", "state_after": "case intro.intro.intro.refine'_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b_w : b \u2208 s\nh_b_h : { val := b, property := \u22ef } \u2208 T\nh_b_alt : b = \u2191{ val := b, property := h_b_w }\n\u22a2 f { val := b, property := h_b_w } \u2208 g \u2191{ val := b, property := h_b_w }"}, {"tactic": "apply h_t'", "annotated_tactic": ["apply h_t'", []], "state_before": "case intro.intro.intro.refine'_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b_w : b \u2208 s\nh_b_h : { val := b, property := \u22ef } \u2208 T\nh_b_alt : b = \u2191{ val := b, property := h_b_w }\n\u22a2 f { val := b, property := h_b_w } \u2208 g \u2191{ val := b, property := h_b_w }", "state_after": "case intro.intro.intro.refine'_2.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b_w : b \u2208 s\nh_b_h : { val := b, property := \u22ef } \u2208 T\nh_b_alt : b = \u2191{ val := b, property := h_b_w }\n\u22a2 { val := b, property := h_b_w } \u2208 T"}, {"tactic": "apply h_b_h", "annotated_tactic": ["apply h_b_h", []], "state_before": "case intro.intro.intro.refine'_2.intro.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ng : \u03b2 \u2192 Set (Set \u03b1)\ns : Set \u03b2\nh_pi : \u2200 b \u2208 s, IsPiSystem (g b)\nT : Finset (Subtype s)\nf : Subtype s \u2192 Set \u03b1\nh_t' : \u2200 b \u2208 T, f b \u2208 (g \u2218 Subtype.val) b\nh_t : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)\nthis : \u22c2 b \u2208 T, f b \u2208 generatePiSystem (\u22c3 b, (g \u2218 Subtype.val) b)\nb : \u03b2\nh_b_w : b \u2208 s\nh_b_h : { val := b, property := \u22ef } \u2208 T\nh_b_alt : b = \u2191{ val := b, property := h_b_w }\n\u22a2 { val := b, property := h_b_w } \u2208 T", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Iio_union_Ici_of_le", "start": [1231, 1], "end": [1232, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "Monotone.map_bddBelow", "start": [1305, 1], "end": [1306, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Clopen.lean", "full_name": "isClopen_univ", "start": [51, 1], "end": [51, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Denumerable.lean", "full_name": "Denumerable.ofNat_of_decode", "start": [60, 1], "end": [61, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Count.lean", "full_name": "Nat.count_lt_count_succ_iff", "start": [102, 1], "end": [103, 44], "traced_tactics": [{"tactic": "by_cases h : p n <;> simp [count_succ, h]", "annotated_tactic": ["by_cases h : p n <;> simp [<a>count_succ</a>, h]", [{"full_name": "Nat.count_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Count.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}]], "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 count p n < count p (n + 1) \u2194 p n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Monotone.codRestrict", "start": [1403, 11], "end": [1405, 4], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant.lean", "full_name": "Matrix.coe_det_isEmpty", "start": [104, 1], "end": [106, 20], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "m : Type u_1\nn : Type u_2\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\nR : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsEmpty n\n\u22a2 det = const (Matrix n n R) 1", "state_after": "case h\nm : Type u_1\nn : Type u_2\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\nR : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsEmpty n\nx\u271d : Matrix n n R\n\u22a2 det x\u271d = const (Matrix n n R) 1 x\u271d"}, {"tactic": "exact det_isEmpty", "annotated_tactic": ["exact <a>det_isEmpty</a>", [{"full_name": "Matrix.det_isEmpty", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [100, 9], "def_end_pos": [100, 20]}]], "state_before": "case h\nm : Type u_1\nn : Type u_2\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\nR : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsEmpty n\nx\u271d : Matrix n n R\n\u22a2 det x\u271d = const (Matrix n n R) 1 x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.mem_map_iff_of_surjective", "start": [1705, 1], "end": [1707, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.coe_subgroupOf", "start": [1625, 1], "end": [1626, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Quotient.lean", "full_name": "Ideal.Quotient.maximal_of_isField", "start": [232, 1], "end": [241, 75], "traced_tactics": [{"tactic": "apply Ideal.isMaximal_iff.2", "annotated_tactic": ["apply <a>Ideal.isMaximal_iff</a>.2", [{"full_name": "Ideal.isMaximal_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [307, 9], "def_end_pos": [307, 22]}]], "state_before": "R : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\n\u22a2 IsMaximal I", "state_after": "R : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\n\u22a2 1 \u2209 I \u2227 \u2200 (J : Ideal R) (x : R), I \u2264 J \u2192 x \u2209 I \u2192 x \u2208 J \u2192 1 \u2208 J"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\n\u22a2 1 \u2209 I \u2227 \u2200 (J : Ideal R) (x : R), I \u2264 J \u2192 x \u2209 I \u2192 x \u2208 J \u2192 1 \u2208 J", "state_after": "case left\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\n\u22a2 1 \u2209 I\n\ncase right\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\n\u22a2 \u2200 (J : Ideal R) (x : R), I \u2264 J \u2192 x \u2209 I \u2192 x \u2208 J \u2192 1 \u2208 J"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case left\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\n\u22a2 1 \u2209 I", "state_after": "case left\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nh : 1 \u2208 I\n\u22a2 False"}, {"tactic": "rcases hqf.exists_pair_ne with \u27e8\u27e8x\u27e9, \u27e8y\u27e9, hxy\u27e9", "annotated_tactic": ["rcases hqf.exists_pair_ne with \u27e8\u27e8x\u27e9, \u27e8y\u27e9, hxy\u27e9", []], "state_before": "case left\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nh : 1 \u2208 I\n\u22a2 False", "state_after": "case left.intro.mk.intro.mk\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx\u271d y\u271d : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nh : 1 \u2208 I\nw\u271d\u00b9 : R \u29f8 I\nx : R\nw\u271d : R \u29f8 I\ny : R\nhxy : Quot.mk Setoid.r x \u2260 Quot.mk Setoid.r y\n\u22a2 False"}, {"tactic": "exact hxy (Ideal.Quotient.eq.2 (mul_one (x - y) \u25b8 I.mul_mem_left _ h))", "annotated_tactic": ["exact hxy (<a>Ideal.Quotient.eq</a>.2 (<a>mul_one</a> (x - y) \u25b8 I.mul_mem_left _ h))", [{"full_name": "Ideal.Quotient.eq", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [119, 19], "def_end_pos": [119, 21]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "case left.intro.mk.intro.mk\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx\u271d y\u271d : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nh : 1 \u2208 I\nw\u271d\u00b9 : R \u29f8 I\nx : R\nw\u271d : R \u29f8 I\ny : R\nhxy : Quot.mk Setoid.r x \u2260 Quot.mk Setoid.r y\n\u22a2 False", "state_after": "no goals"}, {"tactic": "intro J x hIJ hxnI hxJ", "annotated_tactic": ["intro J x hIJ hxnI hxJ", []], "state_before": "case right\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\n\u22a2 \u2200 (J : Ideal R) (x : R), I \u2264 J \u2192 x \u2209 I \u2192 x \u2208 J \u2192 1 \u2208 J", "state_after": "case right\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx\u271d y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nJ : Ideal R\nx : R\nhIJ : I \u2264 J\nhxnI : x \u2209 I\nhxJ : x \u2208 J\n\u22a2 1 \u2208 J"}, {"tactic": "rcases hqf.mul_inv_cancel (mt Ideal.Quotient.eq_zero_iff_mem.1 hxnI) with \u27e8\u27e8y\u27e9, hy\u27e9", "annotated_tactic": ["rcases hqf.mul_inv_cancel (<a>mt</a> <a>Ideal.Quotient.eq_zero_iff_mem</a>.1 hxnI) with \u27e8\u27e8y\u27e9, hy\u27e9", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "Ideal.Quotient.eq_zero_iff_mem", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [127, 9], "def_end_pos": [127, 24]}]], "state_before": "case right\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx\u271d y : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nJ : Ideal R\nx : R\nhIJ : I \u2264 J\nhxnI : x \u2209 I\nhxJ : x \u2208 J\n\u22a2 1 \u2208 J", "state_after": "case right.intro.mk\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx\u271d y\u271d : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nJ : Ideal R\nx : R\nhIJ : I \u2264 J\nhxnI : x \u2209 I\nhxJ : x \u2208 J\nw\u271d : R \u29f8 I\ny : R\nhy : (mk I) x * Quot.mk Setoid.r y = 1\n\u22a2 1 \u2208 J"}, {"tactic": "rw [\u2190 zero_add (1 : R), \u2190 sub_self (x * y), sub_add]", "annotated_tactic": ["rw [\u2190 <a>zero_add</a> (1 : R), \u2190 <a>sub_self</a> (x * y), <a>sub_add</a>]", [{"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}, {"full_name": "sub_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [813, 30], "def_end_pos": [813, 38]}, {"full_name": "sub_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [606, 3], "def_end_pos": [606, 14]}]], "state_before": "case right.intro.mk\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx\u271d y\u271d : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nJ : Ideal R\nx : R\nhIJ : I \u2264 J\nhxnI : x \u2209 I\nhxJ : x \u2208 J\nw\u271d : R \u29f8 I\ny : R\nhy : (mk I) x * Quot.mk Setoid.r y = 1\n\u22a2 1 \u2208 J", "state_after": "case right.intro.mk\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx\u271d y\u271d : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nJ : Ideal R\nx : R\nhIJ : I \u2264 J\nhxnI : x \u2209 I\nhxJ : x \u2208 J\nw\u271d : R \u29f8 I\ny : R\nhy : (mk I) x * Quot.mk Setoid.r y = 1\n\u22a2 x * y - (x * y - 1) \u2208 J"}, {"tactic": "exact J.sub_mem (J.mul_mem_right _ hxJ) (hIJ (Ideal.Quotient.eq.1 hy))", "annotated_tactic": ["exact J.sub_mem (J.mul_mem_right _ hxJ) (hIJ (<a>Ideal.Quotient.eq</a>.1 hy))", [{"full_name": "Ideal.Quotient.eq", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [119, 19], "def_end_pos": [119, 21]}]], "state_before": "case right.intro.mk\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx\u271d y\u271d : R\nI : Ideal R\nhqf : IsField (R \u29f8 I)\nJ : Ideal R\nx : R\nhIJ : I \u2264 J\nhxnI : x \u2209 I\nhxJ : x \u2208 J\nw\u271d : R \u29f8 I\ny : R\nhy : (mk I) x * Quot.mk Setoid.r y = 1\n\u22a2 x * y - (x * y - 1) \u2208 J", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean", "full_name": "IsBoundedLinearMap.isBigO_id", "start": [189, 1], "end": [191, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "full_name": "LinearIsometry.coe_toLinearIsometryEquiv", "start": [75, 1], "end": [77, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.disjoint_comap", "start": [2404, 1], "end": [2405, 61], "traced_tactics": [{"tactic": "simp only [disjoint_iff, \u2190 comap_inf, h.eq_bot, comap_bot]", "annotated_tactic": ["simp only [<a>disjoint_iff</a>, \u2190 <a>comap_inf</a>, h.eq_bot, <a>comap_bot</a>]", [{"full_name": "disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "Filter.comap_inf", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2365, 17], "def_end_pos": [2365, 26]}, {"full_name": "Filter.comap_bot", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2387, 9], "def_end_pos": [2387, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nh : Disjoint g\u2081 g\u2082\n\u22a2 Disjoint (comap m g\u2081) (comap m g\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "BddBelow.inter_of_right", "start": [414, 1], "end": [415, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Perfect.lean", "full_name": "PerfectField.separable_iff_squarefree", "start": [239, 1], "end": [245, 61], "traced_tactics": [{"tactic": "rintro p (h : Irreducible p) \u27e8q, rfl\u27e9 (dvd : p \u2223 derivative (p * q))", "annotated_tactic": ["rintro p (h : <a>Irreducible</a> p) \u27e8q, rfl\u27e9 (dvd : p \u2223 <a>derivative</a> (p * q))", [{"full_name": "Irreducible", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [172, 11], "def_end_pos": [172, 22]}, {"full_name": "Polynomial.derivative", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [40, 5], "def_end_pos": [40, 15]}]], "state_before": "K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : PerfectField K\ng : K[X]\nsqf : Squarefree g\n\u22a2 \u2200 (z : K[X]), Irreducible z \u2192 z \u2223 g \u2192 \u00acz \u2223 derivative g", "state_after": "case intro\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : PerfectField K\np : K[X]\nh : Irreducible p\nq : K[X]\nsqf : Squarefree (p * q)\ndvd : p \u2223 derivative (p * q)\n\u22a2 False"}, {"tactic": "replace dvd : p \u2223 q := by\n  rw [derivative_mul, dvd_add_left (dvd_mul_right p _)] at dvd\n  exact (separable_of_irreducible h).dvd_of_dvd_mul_left dvd", "annotated_tactic": ["replace dvd : p \u2223 q := by\n    rw [<a>derivative_mul</a>, <a>dvd_add_left</a> (<a>dvd_mul_right</a> p _)] at dvd\n    exact (<a>separable_of_irreducible</a> h).<a>dvd_of_dvd_mul_left</a> dvd", [{"full_name": "Polynomial.derivative_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [296, 9], "def_end_pos": [296, 23]}, {"full_name": "dvd_add_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Divisibility/Basic.lean", "def_pos": [116, 9], "def_end_pos": [116, 21]}, {"full_name": "dvd_mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 22]}, {"full_name": "PerfectField.separable_of_irreducible", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Perfect.lean", "def_pos": [184, 3], "def_end_pos": [184, 27]}, {"full_name": "IsCoprime.dvd_of_dvd_mul_left", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Coprime/Basic.lean", "def_pos": [108, 9], "def_end_pos": [108, 38]}]], "state_before": "case intro\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : PerfectField K\np : K[X]\nh : Irreducible p\nq : K[X]\nsqf : Squarefree (p * q)\ndvd : p \u2223 derivative (p * q)\n\u22a2 False", "state_after": "case intro\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : PerfectField K\np : K[X]\nh : Irreducible p\nq : K[X]\nsqf : Squarefree (p * q)\ndvd : p \u2223 q\n\u22a2 False"}, {"tactic": "exact (h.1 : \u00ac IsUnit p) (sqf _ <| mul_dvd_mul_left _ dvd)", "annotated_tactic": ["exact (h.1 : \u00ac <a>IsUnit</a> p) (sqf _ <| <a>mul_dvd_mul_left</a> _ dvd)", [{"full_name": "IsUnit", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [637, 5], "def_end_pos": [637, 11]}, {"full_name": "mul_dvd_mul_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [231, 9], "def_end_pos": [231, 25]}]], "state_before": "case intro\nK : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : PerfectField K\np : K[X]\nh : Irreducible p\nq : K[X]\nsqf : Squarefree (p * q)\ndvd : p \u2223 q\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [derivative_mul, dvd_add_left (dvd_mul_right p _)] at dvd", "annotated_tactic": ["rw [<a>derivative_mul</a>, <a>dvd_add_left</a> (<a>dvd_mul_right</a> p _)] at dvd", [{"full_name": "Polynomial.derivative_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [296, 9], "def_end_pos": [296, 23]}, {"full_name": "dvd_add_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Divisibility/Basic.lean", "def_pos": [116, 9], "def_end_pos": [116, 21]}, {"full_name": "dvd_mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 22]}]], "state_before": "K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : PerfectField K\np : K[X]\nh : Irreducible p\nq : K[X]\nsqf : Squarefree (p * q)\ndvd : p \u2223 derivative (p * q)\n\u22a2 p \u2223 q", "state_after": "K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : PerfectField K\np : K[X]\nh : Irreducible p\nq : K[X]\nsqf : Squarefree (p * q)\ndvd : p \u2223 derivative p * q\n\u22a2 p \u2223 q"}, {"tactic": "exact (separable_of_irreducible h).dvd_of_dvd_mul_left dvd", "annotated_tactic": ["exact (<a>separable_of_irreducible</a> h).<a>dvd_of_dvd_mul_left</a> dvd", [{"full_name": "PerfectField.separable_of_irreducible", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Perfect.lean", "def_pos": [184, 3], "def_end_pos": [184, 27]}, {"full_name": "IsCoprime.dvd_of_dvd_mul_left", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Coprime/Basic.lean", "def_pos": [108, 9], "def_end_pos": [108, 38]}]], "state_before": "K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : PerfectField K\np : K[X]\nh : Irreducible p\nq : K[X]\nsqf : Squarefree (p * q)\ndvd : p \u2223 derivative p * q\n\u22a2 p \u2223 q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.smul_le_smul", "start": [376, 1], "end": [380, 72], "traced_tactics": [{"tactic": "simp_rw [le_def]", "annotated_tactic": ["simp_rw [<a>le_def</a>]", [{"full_name": "Seminorm.le_def", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [267, 9], "def_end_pos": [267, 15]}]], "state_before": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b9\u2078 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u2077 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b9\u2076 : SeminormedRing \ud835\udd5c\u2083\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : RingHomIsometric \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : RingHomIsometric \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u00b3 : RingHomIsometric \u03c3\u2081\u2083\ninst\u271d\u00b9\u00b2 : AddCommGroup E\ninst\u271d\u00b9\u00b9 : AddCommGroup E\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup E\u2083\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : AddCommGroup G\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c\u2082 E\u2082\ninst\u271d\u2075 : Module \ud835\udd5c\u2083 E\u2083\ninst\u271d\u2074 : Module \ud835\udd5c F\ninst\u271d\u00b3 : Module \ud835\udd5c G\ninst\u271d\u00b2 : SMul R \u211d\ninst\u271d\u00b9 : SMul R \u211d\u22650\ninst\u271d : IsScalarTower R \u211d\u22650 \u211d\np q : Seminorm \ud835\udd5c E\na b : \u211d\u22650\nhpq : p \u2264 q\nhab : a \u2264 b\n\u22a2 a \u2022 p \u2264 b \u2022 q", "state_after": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b9\u2078 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u2077 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b9\u2076 : SeminormedRing \ud835\udd5c\u2083\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : RingHomIsometric \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : RingHomIsometric \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u00b3 : RingHomIsometric \u03c3\u2081\u2083\ninst\u271d\u00b9\u00b2 : AddCommGroup E\ninst\u271d\u00b9\u00b9 : AddCommGroup E\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup E\u2083\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : AddCommGroup G\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c\u2082 E\u2082\ninst\u271d\u2075 : Module \ud835\udd5c\u2083 E\u2083\ninst\u271d\u2074 : Module \ud835\udd5c F\ninst\u271d\u00b3 : Module \ud835\udd5c G\ninst\u271d\u00b2 : SMul R \u211d\ninst\u271d\u00b9 : SMul R \u211d\u22650\ninst\u271d : IsScalarTower R \u211d\u22650 \u211d\np q : Seminorm \ud835\udd5c E\na b : \u211d\u22650\nhpq : p \u2264 q\nhab : a \u2264 b\n\u22a2 \u2200 (x : E), (a \u2022 p) x \u2264 (b \u2022 q) x"}, {"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b9\u2078 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u2077 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b9\u2076 : SeminormedRing \ud835\udd5c\u2083\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : RingHomIsometric \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : RingHomIsometric \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u00b3 : RingHomIsometric \u03c3\u2081\u2083\ninst\u271d\u00b9\u00b2 : AddCommGroup E\ninst\u271d\u00b9\u00b9 : AddCommGroup E\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup E\u2083\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : AddCommGroup G\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c\u2082 E\u2082\ninst\u271d\u2075 : Module \ud835\udd5c\u2083 E\u2083\ninst\u271d\u2074 : Module \ud835\udd5c F\ninst\u271d\u00b3 : Module \ud835\udd5c G\ninst\u271d\u00b2 : SMul R \u211d\ninst\u271d\u00b9 : SMul R \u211d\u22650\ninst\u271d : IsScalarTower R \u211d\u22650 \u211d\np q : Seminorm \ud835\udd5c E\na b : \u211d\u22650\nhpq : p \u2264 q\nhab : a \u2264 b\n\u22a2 \u2200 (x : E), (a \u2022 p) x \u2264 (b \u2022 q) x", "state_after": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b9\u2078 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u2077 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b9\u2076 : SeminormedRing \ud835\udd5c\u2083\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : RingHomIsometric \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : RingHomIsometric \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u00b3 : RingHomIsometric \u03c3\u2081\u2083\ninst\u271d\u00b9\u00b2 : AddCommGroup E\ninst\u271d\u00b9\u00b9 : AddCommGroup E\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup E\u2083\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : AddCommGroup G\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c\u2082 E\u2082\ninst\u271d\u2075 : Module \ud835\udd5c\u2083 E\u2083\ninst\u271d\u2074 : Module \ud835\udd5c F\ninst\u271d\u00b3 : Module \ud835\udd5c G\ninst\u271d\u00b2 : SMul R \u211d\ninst\u271d\u00b9 : SMul R \u211d\u22650\ninst\u271d : IsScalarTower R \u211d\u22650 \u211d\np q : Seminorm \ud835\udd5c E\na b : \u211d\u22650\nhpq : p \u2264 q\nhab : a \u2264 b\nx : E\n\u22a2 (a \u2022 p) x \u2264 (b \u2022 q) x"}, {"tactic": "exact mul_le_mul hab (hpq x) (apply_nonneg p x) (NNReal.coe_nonneg b)", "annotated_tactic": ["exact <a>mul_le_mul</a> hab (hpq x) (<a>apply_nonneg</a> p x) (<a>NNReal.coe_nonneg</a> b)", [{"full_name": "mul_le_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [472, 9], "def_end_pos": [472, 19]}, {"full_name": "NonnegHomClass.apply_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Hom/Basic.lean", "def_pos": [80, 3], "def_end_pos": [80, 15]}, {"full_name": "NNReal.coe_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [134, 9], "def_end_pos": [134, 19]}]], "state_before": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b9\u2078 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9\u2077 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b9\u2076 : SeminormedRing \ud835\udd5c\u2083\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : RingHomIsometric \u03c3\u2081\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : RingHomIsometric \u03c3\u2082\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b9\u00b3 : RingHomIsometric \u03c3\u2081\u2083\ninst\u271d\u00b9\u00b2 : AddCommGroup E\ninst\u271d\u00b9\u00b9 : AddCommGroup E\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup E\u2083\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : AddCommGroup G\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c\u2082 E\u2082\ninst\u271d\u2075 : Module \ud835\udd5c\u2083 E\u2083\ninst\u271d\u2074 : Module \ud835\udd5c F\ninst\u271d\u00b3 : Module \ud835\udd5c G\ninst\u271d\u00b2 : SMul R \u211d\ninst\u271d\u00b9 : SMul R \u211d\u22650\ninst\u271d : IsScalarTower R \u211d\u22650 \u211d\np q : Seminorm \ud835\udd5c E\na b : \u211d\u22650\nhpq : p \u2264 q\nhab : a \u2264 b\nx : E\n\u22a2 (a \u2022 p) x \u2264 (b \u2022 q) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.iterate_minimalPeriod", "start": [286, 1], "end": [287, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Support.lean", "full_name": "LocallyFinite.smul_left", "start": [424, 1], "end": [427, 72], "traced_tactics": [{"tactic": "rw [Pi.smul_apply', h, zero_smul]", "annotated_tactic": ["rw [<a>Pi.smul_apply'</a>, h, <a>zero_smul</a>]", [{"full_name": "Pi.smul_apply'", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Pi.lean", "def_pos": [45, 9], "def_end_pos": [45, 20]}, {"full_name": "zero_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}]], "state_before": "X : Type u_1\n\u03b1 : Type u_2\n\u03b1' : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\nM : Type u_7\nE : Type u_8\nR : Type u_9\n\u03b9 : Type u_10\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero R M\ns : \u03b9 \u2192 X \u2192 R\nh\u271d : LocallyFinite fun i => support (s i)\nf : \u03b9 \u2192 X \u2192 M\ni : \u03b9\nx : X\nh : s i x = 0\n\u22a2 (s i \u2022 f i) x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Sqrt.lean", "full_name": "Real.lt_sqrt_of_sq_lt", "start": [449, 1], "end": [450, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Subtype.range_coe", "start": [1369, 1], "end": [1371, 32], "traced_tactics": [{"tactic": "rw [\u2190 image_univ]", "annotated_tactic": ["rw [\u2190 <a>image_univ</a>]", [{"full_name": "Set.image_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [692, 9], "def_end_pos": [692, 19]}]], "state_before": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 range val = s", "state_after": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 val '' univ = s"}, {"tactic": "simp [-image_univ, coe_image]", "annotated_tactic": ["simp [-image_univ, <a>coe_image</a>]", [{"full_name": "Subtype.coe_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1356, 9], "def_end_pos": [1356, 18]}]], "state_before": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 val '' univ = s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "toDual_sdiff", "start": [1119, 1], "end": [1120, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.bliminf_true", "start": [496, 1], "end": [497, 31], "traced_tactics": [{"tactic": "simp [bliminf_eq, liminf_eq]", "annotated_tactic": ["simp [<a>bliminf_eq</a>, <a>liminf_eq</a>]", [{"full_name": "Filter.bliminf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean", "def_pos": [478, 9], "def_end_pos": [478, 19]}, {"full_name": "Filter.liminf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean", "def_pos": [470, 9], "def_end_pos": [470, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 (bliminf u f fun x => True) = liminf u f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Surjective.of_comp_left", "start": [181, 1], "end": [182, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.induction_on", "start": [456, 1], "end": [458, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LocalizedModule.lean", "full_name": "LocalizedModule.mul_smul_aux", "start": [359, 9], "end": [363, 73], "traced_tactics": [{"tactic": "induction' p using LocalizedModule.induction_on with m s", "annotated_tactic": ["induction' p using <a>LocalizedModule.induction_on</a> with m s", [{"full_name": "LocalizedModule.induction_on", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LocalizedModule.lean", "def_pos": [99, 9], "def_end_pos": [99, 21]}]], "state_before": "R : Type u\ninst\u271d\u2075 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nT : Type u_1\ninst\u271d\u00b2 : CommSemiring T\ninst\u271d\u00b9 : Algebra R T\ninst\u271d : IsLocalization S T\nx y : T\np : LocalizedModule S M\n\u22a2 (x * y) \u2022 p = x \u2022 y \u2022 p", "state_after": "case h\nR : Type u\ninst\u271d\u2075 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nT : Type u_1\ninst\u271d\u00b2 : CommSemiring T\ninst\u271d\u00b9 : Algebra R T\ninst\u271d : IsLocalization S T\nx y : T\nm : M\ns : \u21a5S\n\u22a2 (x * y) \u2022 mk m s = x \u2022 y \u2022 mk m s"}, {"tactic": "rw [\u2190 IsLocalization.mk'_sec (M := S) T x, \u2190 IsLocalization.mk'_sec (M := S) T y]", "annotated_tactic": ["rw [\u2190 <a>IsLocalization.mk'_sec</a> (M := S) T x, \u2190 <a>IsLocalization.mk'_sec</a> (M := S) T y]", [{"full_name": "IsLocalization.mk'_sec", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [251, 9], "def_end_pos": [251, 16]}, {"full_name": "IsLocalization.mk'_sec", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [251, 9], "def_end_pos": [251, 16]}]], "state_before": "case h\nR : Type u\ninst\u271d\u2075 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nT : Type u_1\ninst\u271d\u00b2 : CommSemiring T\ninst\u271d\u00b9 : Algebra R T\ninst\u271d : IsLocalization S T\nx y : T\nm : M\ns : \u21a5S\n\u22a2 (x * y) \u2022 mk m s = x \u2022 y \u2022 mk m s", "state_after": "case h\nR : Type u\ninst\u271d\u2075 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nT : Type u_1\ninst\u271d\u00b2 : CommSemiring T\ninst\u271d\u00b9 : Algebra R T\ninst\u271d : IsLocalization S T\nx y : T\nm : M\ns : \u21a5S\n\u22a2 (IsLocalization.mk' T (IsLocalization.sec S x).1 (IsLocalization.sec S x).2 *\n        IsLocalization.mk' T (IsLocalization.sec S y).1 (IsLocalization.sec S y).2) \u2022\n      mk m s =\n    IsLocalization.mk' T (IsLocalization.sec S x).1 (IsLocalization.sec S x).2 \u2022\n      IsLocalization.mk' T (IsLocalization.sec S y).1 (IsLocalization.sec S y).2 \u2022 mk m s"}, {"tactic": "simp_rw [\u2190 IsLocalization.mk'_mul, mk'_smul_mk, \u2190 mul_smul, mul_assoc]", "annotated_tactic": ["simp_rw [\u2190 <a>IsLocalization.mk'_mul</a>, <a>mk'_smul_mk</a>, \u2190 <a>mul_smul</a>, <a>mul_assoc</a>]", [{"full_name": "IsLocalization.mk'_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [255, 9], "def_end_pos": [255, 16]}, {"full_name": "LocalizedModule.mk'_smul_mk", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LocalizedModule.lean", "def_pos": [338, 9], "def_end_pos": [338, 20]}, {"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "case h\nR : Type u\ninst\u271d\u2075 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nT : Type u_1\ninst\u271d\u00b2 : CommSemiring T\ninst\u271d\u00b9 : Algebra R T\ninst\u271d : IsLocalization S T\nx y : T\nm : M\ns : \u21a5S\n\u22a2 (IsLocalization.mk' T (IsLocalization.sec S x).1 (IsLocalization.sec S x).2 *\n        IsLocalization.mk' T (IsLocalization.sec S y).1 (IsLocalization.sec S y).2) \u2022\n      mk m s =\n    IsLocalization.mk' T (IsLocalization.sec S x).1 (IsLocalization.sec S x).2 \u2022\n      IsLocalization.mk' T (IsLocalization.sec S y).1 (IsLocalization.sec S y).2 \u2022 mk m s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "full_name": "mul_div_cancel_left_of_imp", "start": [442, 1], "end": [443, 41], "traced_tactics": [{"tactic": "rw [mul_comm, mul_div_cancel_of_imp h]", "annotated_tactic": ["rw [<a>mul_comm</a>, <a>mul_div_cancel_of_imp</a> h]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "mul_div_cancel_of_imp", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [400, 7], "def_end_pos": [400, 28]}]], "state_before": "\u03b1 : Type u_1\nM\u2080 : Type u_2\nG\u2080 : Type u_3\nM\u2080' : Type u_4\nG\u2080' : Type u_5\nF : Type u_6\nF' : Type u_7\ninst\u271d\u00b9 : MonoidWithZero M\u2080\ninst\u271d : CommGroupWithZero G\u2080\na b c d : G\u2080\nh : a = 0 \u2192 b = 0\n\u22a2 a * b / a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.eventually_forall_ge_atTop", "start": [253, 1], "end": [259, 47], "traced_tactics": [{"tactic": "refine \u27e8fun h \u21a6 h.mono fun x hx \u21a6 hx x le_rfl, fun h \u21a6 ?_\u27e9", "annotated_tactic": ["refine \u27e8fun h \u21a6 h.mono fun x hx \u21a6 hx x <a>le_rfl</a>, fun h \u21a6 ?_\u27e9", [{"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1) in atTop, \u2200 (y : \u03b1), x \u2264 y \u2192 p y) \u2194 \u2200\u1da0 (x : \u03b1) in atTop, p x", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1) in atTop, p x\n\u22a2 \u2200\u1da0 (x : \u03b1) in atTop, \u2200 (y : \u03b1), x \u2264 y \u2192 p y"}, {"tactic": "rcases (hasBasis_iInf_principal_finite _).eventually_iff.1 h with \u27e8S, hSf, hS\u27e9", "annotated_tactic": ["rcases (<a>hasBasis_iInf_principal_finite</a> _).<a>eventually_iff</a>.1 h with \u27e8S, hSf, hS\u27e9", [{"full_name": "Filter.hasBasis_iInf_principal_finite", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [782, 9], "def_end_pos": [782, 39]}, {"full_name": "Filter.HasBasis.eventually_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [371, 9], "def_end_pos": [371, 32]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1) in atTop, p x\n\u22a2 \u2200\u1da0 (x : \u03b1) in atTop, \u2200 (y : \u03b1), x \u2264 y \u2192 p y", "state_after": "case intro.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1) in atTop, p x\nS : Set \u03b1\nhSf : Set.Finite S\nhS : \u2200 \u2983x : \u03b1\u2984, x \u2208 \u22c2 i \u2208 S, Ici i \u2192 p x\n\u22a2 \u2200\u1da0 (x : \u03b1) in atTop, \u2200 (y : \u03b1), x \u2264 y \u2192 p y"}, {"tactic": "refine mem_iInf_of_iInter hSf (V := fun x \u21a6 Ici x.1) (fun _ \u21a6 Subset.rfl) fun x hx y hy \u21a6 ?_", "annotated_tactic": ["refine <a>mem_iInf_of_iInter</a> hSf (V := fun x \u21a6 <a>Ici</a> x.1) (fun _ \u21a6 <a>Subset.rfl</a>) fun x hx y hy \u21a6 ?_", [{"full_name": "Filter.mem_iInf_of_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [613, 9], "def_end_pos": [613, 27]}, {"full_name": "Set.Ici", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [74, 5], "def_end_pos": [74, 8]}, {"full_name": "Set.Subset.rfl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [338, 9], "def_end_pos": [338, 19]}]], "state_before": "case intro.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1) in atTop, p x\nS : Set \u03b1\nhSf : Set.Finite S\nhS : \u2200 \u2983x : \u03b1\u2984, x \u2208 \u22c2 i \u2208 S, Ici i \u2192 p x\n\u22a2 \u2200\u1da0 (x : \u03b1) in atTop, \u2200 (y : \u03b1), x \u2264 y \u2192 p y", "state_after": "case intro.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1) in atTop, p x\nS : Set \u03b1\nhSf : Set.Finite S\nhS : \u2200 \u2983x : \u03b1\u2984, x \u2208 \u22c2 i \u2208 S, Ici i \u2192 p x\nx : \u03b1\nhx : x \u2208 \u22c2 i, (fun x => Ici \u2191x) i\ny : \u03b1\nhy : x \u2264 y\n\u22a2 p y"}, {"tactic": "simp only [mem_iInter] at hS hx", "annotated_tactic": ["simp only [<a>mem_iInter</a>] at hS hx", [{"full_name": "Set.mem_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [278, 9], "def_end_pos": [278, 19]}]], "state_before": "case intro.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1) in atTop, p x\nS : Set \u03b1\nhSf : Set.Finite S\nhS : \u2200 \u2983x : \u03b1\u2984, x \u2208 \u22c2 i \u2208 S, Ici i \u2192 p x\nx : \u03b1\nhx : x \u2208 \u22c2 i, (fun x => Ici \u2191x) i\ny : \u03b1\nhy : x \u2264 y\n\u22a2 p y", "state_after": "case intro.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1) in atTop, p x\nS : Set \u03b1\nhSf : Set.Finite S\nx y : \u03b1\nhy : x \u2264 y\nhS : \u2200 \u2983x : \u03b1\u2984, (\u2200 i \u2208 S, x \u2208 Ici i) \u2192 p x\nhx : \u2200 (i : \u2191S), x \u2208 Ici \u2191i\n\u22a2 p y"}, {"tactic": "exact hS fun z hz \u21a6 le_trans (hx \u27e8z, hz\u27e9) hy", "annotated_tactic": ["exact hS fun z hz \u21a6 <a>le_trans</a> (hx \u27e8z, hz\u27e9) hy", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}]], "state_before": "case intro.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : Preorder \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1) in atTop, p x\nS : Set \u03b1\nhSf : Set.Finite S\nx y : \u03b1\nhy : x \u2264 y\nhS : \u2200 \u2983x : \u03b1\u2984, (\u2200 i \u2208 S, x \u2208 Ici i) \u2192 p x\nhx : \u2200 (i : \u2191S), x \u2208 Ici \u2191i\n\u22a2 p y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Basic.lean", "full_name": "SymmetricRel.eq", "start": [233, 1], "end": [234, 5], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Divisibility/Units.lean", "full_name": "isRelPrime_mul_unit_right_left", "start": [208, 1], "end": [209, 50], "traced_tactics": [{"tactic": "rw [mul_comm, isRelPrime_mul_unit_left_left hu]", "annotated_tactic": ["rw [<a>mul_comm</a>, <a>isRelPrime_mul_unit_left_left</a> hu]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "isRelPrime_mul_unit_left_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Units.lean", "def_pos": [199, 9], "def_end_pos": [199, 38]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nx y z : \u03b1\nhu : IsUnit x\n\u22a2 IsRelPrime (y * x) z \u2194 IsRelPrime y z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Infix.lean", "full_name": "List.infix_rfl", "start": [64, 1], "end": [65, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.trans_apply", "start": [413, 1], "end": [413, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.preimage_Iic", "start": [438, 1], "end": [440, 26], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na : \u03b1\nha : 0 \u2264 a\n\u22a2 Nat.cast \u207b\u00b9' Iic a = Iic \u230aa\u230b\u208a", "state_after": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na : \u03b1\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Iic a \u2194 x\u271d \u2208 Iic \u230aa\u230b\u208a"}, {"tactic": "simp [le_floor_iff, ha]", "annotated_tactic": ["simp [<a>le_floor_iff</a>, ha]", [{"full_name": "Nat.le_floor_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [132, 9], "def_end_pos": [132, 21]}]], "state_before": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na : \u03b1\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Iic a \u2194 x\u271d \u2208 Iic \u230aa\u230b\u208a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Defs.lean", "full_name": "zero_eq_mul", "start": [247, 1], "end": [247, 80], "traced_tactics": [{"tactic": "rw [eq_comm, mul_eq_zero]", "annotated_tactic": ["rw [<a>eq_comm</a>, <a>mul_eq_zero</a>]", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "mul_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [239, 9], "def_end_pos": [239, 20]}]], "state_before": "G\u2080 : Type u\nM\u2080 : Type u_1\nM\u2080' : Type u_2\nG\u2080' : Type u_3\ninst\u271d\u00b9 : MulZeroClass M\u2080\ninst\u271d : NoZeroDivisors M\u2080\na b : M\u2080\n\u22a2 0 = a * b \u2194 a = 0 \u2228 b = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/EReal.lean", "full_name": "EReal.image_coe_Ioi", "start": [488, 1], "end": [492, 6], "traced_tactics": [{"tactic": "refine (image_comp WithBot.some WithTop.some _).trans ?_", "annotated_tactic": ["refine (<a>image_comp</a> <a>WithBot.some</a> <a>WithTop.some</a> _).<a>trans</a> ?_", [{"full_name": "Set.image_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [265, 9], "def_end_pos": [265, 19]}, {"full_name": "WithBot.some", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [44, 27], "def_end_pos": [44, 31]}, {"full_name": "WithTop.some", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [612, 27], "def_end_pos": [612, 31]}, {"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}]], "state_before": "x : \u211d\n\u22a2 Real.toEReal '' Ioi x = Ioo \u2191x \u22a4", "state_after": "x : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Ioi x) = Ioo \u2191x \u22a4"}, {"tactic": "rw [WithTop.image_coe_Ioi, WithBot.image_coe_Ioo]", "annotated_tactic": ["rw [<a>WithTop.image_coe_Ioi</a>, <a>WithBot.image_coe_Ioo</a>]", [{"full_name": "WithTop.image_coe_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/WithBotTop.lean", "def_pos": [89, 9], "def_end_pos": [89, 22]}, {"full_name": "WithBot.image_coe_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/WithBotTop.lean", "def_pos": [232, 9], "def_end_pos": [232, 22]}]], "state_before": "x : \u211d\n\u22a2 WithBot.some '' (WithTop.some '' Ioi x) = Ioo \u2191x \u22a4", "state_after": "x : \u211d\n\u22a2 Ioo \u2191\u2191x \u2191\u22a4 = Ioo \u2191x \u22a4"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "x : \u211d\n\u22a2 Ioo \u2191\u2191x \u2191\u22a4 = Ioo \u2191x \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/PartialHomeomorph.lean", "full_name": "PartialHomeomorph.map_target", "start": [156, 1], "end": [157, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.bot_prod_bot", "start": [1851, 1], "end": [1852, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "full_name": "UniformInducing.basis_uniformity", "start": [76, 1], "end": [79, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.apply_eq_of_mem_graph", "start": [88, 1], "end": [89, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.inv_op_smul_set_distrib\u2080", "start": [1110, 1], "end": [1113, 50], "traced_tactics": [{"tactic": "obtain rfl | ha := eq_or_ne a 0", "annotated_tactic": ["obtain rfl | ha := <a>eq_or_ne</a> a 0", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : GroupWithZero \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t : Set \u03b2\na\u271d a : \u03b1\ns : Set \u03b1\n\u22a2 (op a \u2022 s)\u207b\u00b9 = a\u207b\u00b9 \u2022 s\u207b\u00b9", "state_after": "case inl\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : GroupWithZero \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t : Set \u03b2\na : \u03b1\ns : Set \u03b1\n\u22a2 (op 0 \u2022 s)\u207b\u00b9 = 0\u207b\u00b9 \u2022 s\u207b\u00b9\n\ncase inr\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : GroupWithZero \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t : Set \u03b2\na\u271d a : \u03b1\ns : Set \u03b1\nha : a \u2260 0\n\u22a2 (op a \u2022 s)\u207b\u00b9 = a\u207b\u00b9 \u2022 s\u207b\u00b9"}, {"tactic": "obtain rfl | hs := s.eq_empty_or_nonempty <;> simp [*]", "annotated_tactic": ["obtain rfl | hs := s.eq_empty_or_nonempty <;> simp [*]", []], "state_before": "case inl\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : GroupWithZero \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t : Set \u03b2\na : \u03b1\ns : Set \u03b1\n\u22a2 (op 0 \u2022 s)\u207b\u00b9 = 0\u207b\u00b9 \u2022 s\u207b\u00b9", "state_after": "no goals"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "case inr\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : GroupWithZero \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t : Set \u03b2\na\u271d a : \u03b1\ns : Set \u03b1\nha : a \u2260 0\n\u22a2 (op a \u2022 s)\u207b\u00b9 = a\u207b\u00b9 \u2022 s\u207b\u00b9", "state_after": "case inr.h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : GroupWithZero \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t : Set \u03b2\na\u271d a : \u03b1\ns : Set \u03b1\nha : a \u2260 0\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 (op a \u2022 s)\u207b\u00b9 \u2194 x\u271d \u2208 a\u207b\u00b9 \u2022 s\u207b\u00b9"}, {"tactic": "simp [mem_smul_set_iff_inv_smul_mem\u2080, *]", "annotated_tactic": ["simp [<a>mem_smul_set_iff_inv_smul_mem\u2080</a>, *]", [{"full_name": "Set.mem_smul_set_iff_inv_smul_mem\u2080", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [1048, 9], "def_end_pos": [1048, 39]}]], "state_before": "case inr.h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : GroupWithZero \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t : Set \u03b2\na\u271d a : \u03b1\ns : Set \u03b1\nha : a \u2260 0\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 (op a \u2022 s)\u207b\u00b9 \u2194 x\u271d \u2208 a\u207b\u00b9 \u2022 s\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isBigOWith_const_const", "start": [1275, 1], "end": [1280, 62], "traced_tactics": [{"tactic": "simp only [IsBigOWith_def]", "annotated_tactic": ["simp only [<a>IsBigOWith_def</a>]", [{"full_name": "Asymptotics.IsBigOWith_def", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Asymptotics/Asymptotics.lean", "def_pos": [1, 1], "def_end_pos": [1, 1]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc\u271d c'\u271d c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl\u271d l' : Filter \u03b1\nc : E\nc' : F''\nhc' : c' \u2260 0\nl : Filter \u03b1\n\u22a2 IsBigOWith (\u2016c\u2016 / \u2016c'\u2016) l (fun _x => c) fun _x => c'", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc\u271d c'\u271d c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl\u271d l' : Filter \u03b1\nc : E\nc' : F''\nhc' : c' \u2260 0\nl : Filter \u03b1\n\u22a2 \u2200\u1da0 (x : \u03b1) in l, \u2016c\u2016 \u2264 \u2016c\u2016 / \u2016c'\u2016 * \u2016c'\u2016"}, {"tactic": "apply univ_mem'", "annotated_tactic": ["apply <a>univ_mem'</a>", [{"full_name": "Filter.univ_mem'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [173, 9], "def_end_pos": [173, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc\u271d c'\u271d c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl\u271d l' : Filter \u03b1\nc : E\nc' : F''\nhc' : c' \u2260 0\nl : Filter \u03b1\n\u22a2 \u2200\u1da0 (x : \u03b1) in l, \u2016c\u2016 \u2264 \u2016c\u2016 / \u2016c'\u2016 * \u2016c'\u2016", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc\u271d c'\u271d c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl\u271d l' : Filter \u03b1\nc : E\nc' : F''\nhc' : c' \u2260 0\nl : Filter \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 {x | (fun x => \u2016c\u2016 \u2264 \u2016c\u2016 / \u2016c'\u2016 * \u2016c'\u2016) x}"}, {"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc\u271d c'\u271d c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl\u271d l' : Filter \u03b1\nc : E\nc' : F''\nhc' : c' \u2260 0\nl : Filter \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 {x | (fun x => \u2016c\u2016 \u2264 \u2016c\u2016 / \u2016c'\u2016 * \u2016c'\u2016) x}", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc\u271d c'\u271d c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl\u271d l' : Filter \u03b1\nc : E\nc' : F''\nhc' : c' \u2260 0\nl : Filter \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | (fun x => \u2016c\u2016 \u2264 \u2016c\u2016 / \u2016c'\u2016 * \u2016c'\u2016) x}"}, {"tactic": "rw [mem_setOf, div_mul_cancel _ (norm_ne_zero_iff.mpr hc')]", "annotated_tactic": ["rw [<a>mem_setOf</a>, <a>div_mul_cancel</a> _ (norm_ne_zero_iff.mpr hc')]", [{"full_name": "Set.mem_setOf", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [234, 9], "def_end_pos": [234, 18]}, {"full_name": "div_mul_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [340, 15], "def_end_pos": [340, 29]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc\u271d c'\u271d c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl\u271d l' : Filter \u03b1\nc : E\nc' : F''\nhc' : c' \u2260 0\nl : Filter \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | (fun x => \u2016c\u2016 \u2264 \u2016c\u2016 / \u2016c'\u2016 * \u2016c'\u2016) x}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Equivalence.lean", "full_name": "CategoryTheory.Equivalence.unit_inverse_comp", "start": [180, 1], "end": [201, 51], "traced_tactics": [{"tactic": "rw [\u2190 id_comp (e.inverse.map _), \u2190 map_id e.inverse, \u2190 counitInv_functor_comp, map_comp]", "annotated_tactic": ["rw [\u2190 <a>id_comp</a> (e.inverse.map _), \u2190 <a>map_id</a> e.inverse, \u2190 <a>counitInv_functor_comp</a>, <a>map_comp</a>]", [{"full_name": "CategoryTheory.Category.id_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [164, 3], "def_end_pos": [164, 10]}, {"full_name": "CategoryTheory.Functor.map_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [41, 3], "def_end_pos": [41, 9]}, {"full_name": "CategoryTheory.Equivalence.counitInv_functor_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Equivalence.lean", "def_pos": [157, 9], "def_end_pos": [157, 31]}, {"full_name": "CategoryTheory.Functor.map_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [43, 3], "def_end_pos": [43, 11]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app (e.inverse.obj Y) \u226b e.inverse.map (e.counit.app Y) = \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app (e.inverse.obj Y) \u226b\n      (e.inverse.map (e.counitInv.app (e.functor.obj (e.inverse.obj Y))) \u226b\n          e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n        e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "rw [\u2190 Iso.hom_inv_id_assoc (e.unitIso.app _) (e.inverse.map (e.functor.map _)), app_hom, app_inv]", "annotated_tactic": ["rw [\u2190 <a>Iso.hom_inv_id_assoc</a> (e.unitIso.app _) (e.inverse.map (e.functor.map _)), <a>app_hom</a>, <a>app_inv</a>]", [{"full_name": "CategoryTheory.Iso.hom_inv_id_assoc", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [67, 12], "def_end_pos": [67, 34]}, {"full_name": "CategoryTheory.NatIso.app_hom", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/NatIso.lean", "def_pos": [89, 9], "def_end_pos": [89, 16]}, {"full_name": "CategoryTheory.NatIso.app_inv", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/NatIso.lean", "def_pos": [93, 9], "def_end_pos": [93, 16]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app (e.inverse.obj Y) \u226b\n      (e.inverse.map (e.counitInv.app (e.functor.obj (e.inverse.obj Y))) \u226b\n          e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n        e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app (e.inverse.obj Y) \u226b\n      (e.inverse.map (e.counitInv.app (e.functor.obj (e.inverse.obj Y))) \u226b\n          e.unitIso.hom.app\n              (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y))))) \u226b\n            e.unitIso.inv.app\n                (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y))))) \u226b\n              e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n        e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "slice_lhs 2 3 => erw [e.unit.naturality]", "annotated_tactic": ["slice_lhs 2 3 => erw [e.unit.naturality]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app (e.inverse.obj Y) \u226b\n      (e.inverse.map (e.counitInv.app (e.functor.obj (e.inverse.obj Y))) \u226b\n          e.unitIso.hom.app\n              (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y))))) \u226b\n            e.unitIso.inv.app\n                (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y))))) \u226b\n              e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n        e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app (e.inverse.obj Y) \u226b\n      (((e.unit.app (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj Y))) \u226b\n              (e.functor \u22d9 e.inverse).map\n                (e.inverse.toPrefunctor.2 (e.counitInv.app (e.functor.obj (e.inverse.obj Y))))) \u226b\n            e.unitIso.inv.app\n              (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n          e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n        e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "slice_lhs 1 2 => erw [e.unit.naturality]", "annotated_tactic": ["slice_lhs 1 2 => erw [e.unit.naturality]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app (e.inverse.obj Y) \u226b\n      (((e.unit.app (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj Y))) \u226b\n              (e.functor \u22d9 e.inverse).map\n                (e.inverse.toPrefunctor.2 (e.counitInv.app (e.functor.obj (e.inverse.obj Y))))) \u226b\n            e.unitIso.inv.app\n              (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n          e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n        e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 ((((e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b (e.functor \u22d9 e.inverse).map (e.unit.1 (e.inverse.obj Y))) \u226b\n            (e.functor \u22d9 e.inverse).map\n              (e.inverse.toPrefunctor.2 (e.counitInv.app (e.functor.obj (e.inverse.obj Y))))) \u226b\n          e.unitIso.inv.app\n            (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n        e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n      e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "slice_lhs 4 4 =>\n  rw [\u2190 Iso.hom_inv_id_assoc (e.inverse.mapIso (e.counitIso.app _)) (e.unitInv.app _)]", "annotated_tactic": ["slice_lhs 4 4 =>\n    rw [\u2190 <a>Iso.hom_inv_id_assoc</a> (e.inverse.mapIso (e.counitIso.app _)) (e.unitInv.app _)]", [{"full_name": "CategoryTheory.Iso.hom_inv_id_assoc", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [67, 12], "def_end_pos": [67, 34]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 ((((e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b (e.functor \u22d9 e.inverse).map (e.unit.1 (e.inverse.obj Y))) \u226b\n            (e.functor \u22d9 e.inverse).map\n              (e.inverse.toPrefunctor.2 (e.counitInv.app (e.functor.obj (e.inverse.obj Y))))) \u226b\n          e.unitIso.inv.app\n            (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n        e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n      e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      (e.functor \u22d9 e.inverse).map (e.unit.1 (e.inverse.obj Y)) \u226b\n        (e.functor \u22d9 e.inverse).map (e.inverse.toPrefunctor.2 (e.counitInv.app (e.functor.obj (e.inverse.obj Y)))) \u226b\n          (((e.inverse.mapIso (e.counitIso.app (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))).hom \u226b\n                (e.inverse.mapIso\n                      (e.counitIso.app (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))).inv \u226b\n                  e.unitInv.app (e.inverse.obj (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n              e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n            e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "slice_lhs 3 4 =>\n  erw [\u2190 map_comp e.inverse, e.counit.naturality]\n  erw [(e.counitIso.app _).hom_inv_id, map_id]", "annotated_tactic": ["slice_lhs 3 4 =>\n    erw [\u2190 <a>map_comp</a> e.inverse, e.counit.naturality]\n    erw [(e.counitIso.app _).<a>hom_inv_id</a>, <a>map_id</a>]", [{"full_name": "CategoryTheory.Functor.map_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [43, 3], "def_end_pos": [43, 11]}, {"full_name": "CategoryTheory.Iso.hom_inv_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [57, 3], "def_end_pos": [57, 13]}, {"full_name": "CategoryTheory.Functor.map_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [41, 3], "def_end_pos": [41, 9]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      (e.functor \u22d9 e.inverse).map (e.unit.1 (e.inverse.obj Y)) \u226b\n        (e.functor \u22d9 e.inverse).map (e.inverse.toPrefunctor.2 (e.counitInv.app (e.functor.obj (e.inverse.obj Y)))) \u226b\n          (((e.inverse.mapIso (e.counitIso.app (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))).hom \u226b\n                (e.inverse.mapIso\n                      (e.counitIso.app (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))).inv \u226b\n                  e.unitInv.app (e.inverse.obj (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n              e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n            e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      (e.functor \u22d9 e.inverse).map (e.unit.1 (e.inverse.obj Y)) \u226b\n        (((\ud835\udfd9 (e.inverse.obj (e.functor.obj (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj Y))))) \u226b\n                (e.inverse.mapIso\n                    (e.counitIso.app (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))).inv) \u226b\n              e.unitInv.app (e.inverse.obj (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n            e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n          e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "erw [id_comp]", "annotated_tactic": ["erw [<a>id_comp</a>]", [{"full_name": "CategoryTheory.Category.id_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [164, 3], "def_end_pos": [164, 10]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      (e.functor \u22d9 e.inverse).map (e.unit.1 (e.inverse.obj Y)) \u226b\n        (((\ud835\udfd9 (e.inverse.obj (e.functor.obj (e.inverse.toPrefunctor.1 (e.functor.obj (e.inverse.obj Y))))) \u226b\n                (e.inverse.mapIso\n                    (e.counitIso.app (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))).inv) \u226b\n              e.unitInv.app (e.inverse.obj (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n            e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n          e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      (e.functor \u22d9 e.inverse).map (e.unit.1 (e.inverse.obj Y)) \u226b\n        (((e.inverse.mapIso (e.counitIso.app (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))).inv \u226b\n              e.unitInv.app (e.inverse.obj (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n            e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n          e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "slice_lhs 2 3 => erw [\u2190 map_comp e.inverse, e.counitIso.inv.naturality, map_comp]", "annotated_tactic": ["slice_lhs 2 3 => erw [\u2190 <a>map_comp</a> e.inverse, e.counitIso.inv.naturality, <a>map_comp</a>]", [{"full_name": "CategoryTheory.Functor.map_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [43, 3], "def_end_pos": [43, 11]}, {"full_name": "CategoryTheory.Functor.map_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [43, 3], "def_end_pos": [43, 11]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      (e.functor \u22d9 e.inverse).map (e.unit.1 (e.inverse.obj Y)) \u226b\n        (((e.inverse.mapIso (e.counitIso.app (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))).inv \u226b\n              e.unitInv.app (e.inverse.obj (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n            e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n          e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      (((e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n              e.inverse.map ((e.inverse \u22d9 e.functor).map (e.functor.toPrefunctor.2 (e.unit.1 (e.inverse.obj Y))))) \u226b\n            e.unitInv.app (e.inverse.obj (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n          e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n        e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "slice_lhs 3 4 => erw [e.unitInv.naturality]", "annotated_tactic": ["slice_lhs 3 4 => erw [e.unitInv.naturality]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      (((e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n              e.inverse.map ((e.inverse \u22d9 e.functor).map (e.functor.toPrefunctor.2 (e.unit.1 (e.inverse.obj Y))))) \u226b\n            e.unitInv.app (e.inverse.obj (e.functor.obj (e.inverse.obj (e.functor.obj (e.inverse.obj Y)))))) \u226b\n          e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n        e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n        ((e.unitInv.app (e.inverse.obj (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n              (\ud835\udfed C).map (e.inverse.map (e.functor.toPrefunctor.2 (e.unit.1 (e.inverse.obj Y))))) \u226b\n            e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n          e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "slice_lhs 4 5 => erw [\u2190 map_comp (e.functor \u22d9 e.inverse), (e.unitIso.app _).hom_inv_id, map_id]", "annotated_tactic": ["slice_lhs 4 5 => erw [\u2190 <a>map_comp</a> (e.functor \u22d9 e.inverse), (e.unitIso.app _).<a>hom_inv_id</a>, <a>map_id</a>]", [{"full_name": "CategoryTheory.Functor.map_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [43, 3], "def_end_pos": [43, 11]}, {"full_name": "CategoryTheory.Iso.hom_inv_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [57, 3], "def_end_pos": [57, 13]}, {"full_name": "CategoryTheory.Functor.map_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [41, 3], "def_end_pos": [41, 9]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n        ((e.unitInv.app (e.inverse.obj (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n              (\ud835\udfed C).map (e.inverse.map (e.functor.toPrefunctor.2 (e.unit.1 (e.inverse.obj Y))))) \u226b\n            e.inverse.map (e.functor.map (e.unitInv.app (e.inverse.obj Y)))) \u226b\n          e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n        e.unitInv.app (e.inverse.obj (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n          \ud835\udfd9 ((e.functor \u22d9 e.inverse).obj ((\ud835\udfed C).obj (e.inverse.obj Y))) \u226b e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "erw [id_comp]", "annotated_tactic": ["erw [<a>id_comp</a>]", [{"full_name": "CategoryTheory.Category.id_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [164, 3], "def_end_pos": [164, 10]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n        e.unitInv.app (e.inverse.obj (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n          \ud835\udfd9 ((e.functor \u22d9 e.inverse).obj ((\ud835\udfed C).obj (e.inverse.obj Y))) \u226b e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n        e.unitInv.app (e.inverse.obj (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n          e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "slice_lhs 3 4 => erw [\u2190 e.unitInv.naturality]", "annotated_tactic": ["slice_lhs 3 4 => erw [\u2190 e.unitInv.naturality]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n        e.unitInv.app (e.inverse.obj (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n          e.inverse.map (e.counit.app Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n        (e.functor \u22d9 e.inverse).map (e.inverse.toPrefunctor.2 (e.counit.app Y)) \u226b\n          e.unitInv.app (e.inverse.toPrefunctor.1 Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "slice_lhs 2 3 =>\n  erw [\u2190 map_comp e.inverse, \u2190 e.counitIso.inv.naturality, (e.counitIso.app _).hom_inv_id,\n    map_id]", "annotated_tactic": ["slice_lhs 2 3 =>\n    erw [\u2190 <a>map_comp</a> e.inverse, \u2190 e.counitIso.inv.naturality, (e.counitIso.app _).<a>hom_inv_id</a>,\n      <a>map_id</a>]", [{"full_name": "CategoryTheory.Functor.map_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [43, 3], "def_end_pos": [43, 11]}, {"full_name": "CategoryTheory.Iso.hom_inv_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [57, 3], "def_end_pos": [57, 13]}, {"full_name": "CategoryTheory.Functor.map_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [41, 3], "def_end_pos": [41, 9]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      e.inverse.map (e.counitIso.inv.app (e.functor.toPrefunctor.1 ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b\n        (e.functor \u22d9 e.inverse).map (e.inverse.toPrefunctor.2 (e.counit.app Y)) \u226b\n          e.unitInv.app (e.inverse.toPrefunctor.1 Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      \ud835\udfd9 (e.inverse.obj (e.functor.obj ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b e.unitInv.app (e.inverse.toPrefunctor.1 Y) =\n    \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "erw [id_comp, (e.unitIso.app _).hom_inv_id]", "annotated_tactic": ["erw [<a>id_comp</a>, (e.unitIso.app _).<a>hom_inv_id</a>]", [{"full_name": "CategoryTheory.Category.id_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [164, 3], "def_end_pos": [164, 10]}, {"full_name": "CategoryTheory.Iso.hom_inv_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [57, 3], "def_end_pos": [57, 13]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 e.unit.app ((\ud835\udfed C).obj (e.inverse.obj Y)) \u226b\n      \ud835\udfd9 (e.inverse.obj (e.functor.obj ((\ud835\udfed C).obj (e.inverse.obj Y)))) \u226b e.unitInv.app (e.inverse.toPrefunctor.1 Y) =\n    \ud835\udfd9 (e.inverse.obj Y)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 \ud835\udfd9 ((\ud835\udfed C).obj ((\ud835\udfed C).obj (e.inverse.obj Y))) = \ud835\udfd9 (e.inverse.obj Y)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\ne : C \u224c D\nY : D\n\u22a2 \ud835\udfd9 ((\ud835\udfed C).obj ((\ud835\udfed C).obj (e.inverse.obj Y))) = \ud835\udfd9 (e.inverse.obj Y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Function/Indicator.lean", "full_name": "Set.mulIndicator_eq_self", "start": [95, 1], "end": [96, 95], "traced_tactics": [{"tactic": "simp only [funext_iff, subset_def, mem_mulSupport, mulIndicator_apply_eq_self, not_imp_comm]", "annotated_tactic": ["simp only [<a>funext_iff</a>, <a>subset_def</a>, <a>mem_mulSupport</a>, <a>mulIndicator_apply_eq_self</a>, <a>not_imp_comm</a>]", [{"full_name": "Function.funext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 19]}, {"full_name": "Set.subset_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [326, 9], "def_end_pos": [326, 19]}, {"full_name": "Function.mem_mulSupport", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Support.lean", "def_pos": [59, 9], "def_end_pos": [59, 23]}, {"full_name": "Set.mulIndicator_apply_eq_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [88, 9], "def_end_pos": [88, 35]}, {"full_name": "not_imp_comm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [264, 9], "def_end_pos": [264, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns t : Set \u03b1\nf g : \u03b1 \u2192 M\na : \u03b1\n\u22a2 mulIndicator s f = f \u2194 mulSupport f \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.image_vsub_prod", "start": [611, 1], "end": [612, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.spanExt_hom_app_left", "start": [474, 1], "end": [475, 18], "traced_tactics": [{"tactic": "dsimp [spanExt]", "annotated_tactic": ["dsimp [<a>spanExt</a>]", [{"full_name": "CategoryTheory.Limits.spanExt", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "def_pos": [450, 5], "def_end_pos": [450, 12]}]], "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nX Y Z X' Y' Z' : C\niX : X \u2245 X'\niY : Y \u2245 Y'\niZ : Z \u2245 Z'\nf : X \u27f6 Y\ng : X \u27f6 Z\nf' : X' \u27f6 Y'\ng' : X' \u27f6 Z'\nwf : iX.hom \u226b f' = f \u226b iY.hom\nwg : iX.hom \u226b g' = g \u226b iZ.hom\n\u22a2 (spanExt iX iY iZ wf wg).hom.app WalkingSpan.left = iY.hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.inf_eq_bot_iff", "start": [749, 1], "end": [750, 83], "traced_tactics": [{"tactic": "simp only [\u2190 disjoint_iff, Filter.disjoint_iff, Set.disjoint_iff_inter_eq_empty]", "annotated_tactic": ["simp only [\u2190 <a>disjoint_iff</a>, <a>Filter.disjoint_iff</a>, <a>Set.disjoint_iff_inter_eq_empty</a>]", [{"full_name": "disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "Filter.disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [735, 17], "def_end_pos": [735, 29]}, {"full_name": "Set.disjoint_iff_inter_eq_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1522, 9], "def_end_pos": [1522, 36]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g\u271d : Filter \u03b1\ns t : Set \u03b1\nf g : Filter \u03b1\n\u22a2 f \u2293 g = \u22a5 \u2194 \u2203 U \u2208 f, \u2203 V \u2208 g, U \u2229 V = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Tendsto.const_mul_atTop", "start": [1108, 1], "end": [1110, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean", "full_name": "HahnSeries.of_symm_smul_of_eq_mul", "start": [173, 1], "end": [174, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/QuadraticDiscriminant.lean", "full_name": "discrim_lt_zero", "start": [148, 1], "end": [155, 11], "traced_tactics": [{"tactic": "have : \u2200 x : K, 0 \u2264 a * x * x + b * x + c := fun x => le_of_lt (h x)", "annotated_tactic": ["have : \u2200 x : K, 0 \u2264 a * x * x + b * x + c := fun x => <a>le_of_lt</a> (h x)", [{"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}]], "state_before": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\n\u22a2 discrim a b c < 0", "state_after": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\nthis : \u2200 (x : K), 0 \u2264 a * x * x + b * x + c\n\u22a2 discrim a b c < 0"}, {"tactic": "refine lt_of_le_of_ne (discrim_le_zero this) fun h' \u21a6 ?_", "annotated_tactic": ["refine <a>lt_of_le_of_ne</a> (<a>discrim_le_zero</a> this) fun h' \u21a6 ?_", [{"full_name": "lt_of_le_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [190, 9], "def_end_pos": [190, 23]}, {"full_name": "discrim_le_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/QuadraticDiscriminant.lean", "def_pos": [118, 9], "def_end_pos": [118, 24]}]], "state_before": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\nthis : \u2200 (x : K), 0 \u2264 a * x * x + b * x + c\n\u22a2 discrim a b c < 0", "state_after": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\nthis : \u2200 (x : K), 0 \u2264 a * x * x + b * x + c\nh' : discrim a b c = 0\n\u22a2 False"}, {"tactic": "have := h (-b / (2 * a))", "annotated_tactic": ["have := h (-b / (2 * a))", []], "state_before": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\nthis : \u2200 (x : K), 0 \u2264 a * x * x + b * x + c\nh' : discrim a b c = 0\n\u22a2 False", "state_after": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\nthis\u271d : \u2200 (x : K), 0 \u2264 a * x * x + b * x + c\nh' : discrim a b c = 0\nthis : 0 < a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c\n\u22a2 False"}, {"tactic": "have : a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c = 0 := by\n  rw [quadratic_eq_zero_iff_of_discrim_eq_zero ha h' (-b / (2 * a))]", "annotated_tactic": ["have : a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c = 0 := by\n    rw [<a>quadratic_eq_zero_iff_of_discrim_eq_zero</a> ha h' (-b / (2 * a))]", [{"full_name": "quadratic_eq_zero_iff_of_discrim_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/QuadraticDiscriminant.lean", "def_pos": [105, 9], "def_end_pos": [105, 49]}]], "state_before": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\nthis\u271d : \u2200 (x : K), 0 \u2264 a * x * x + b * x + c\nh' : discrim a b c = 0\nthis : 0 < a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c\n\u22a2 False", "state_after": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\nthis\u271d\u00b9 : \u2200 (x : K), 0 \u2264 a * x * x + b * x + c\nh' : discrim a b c = 0\nthis\u271d : 0 < a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c\nthis : a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c = 0\n\u22a2 False"}, {"tactic": "linarith", "annotated_tactic": ["linarith", []], "state_before": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\nthis\u271d\u00b9 : \u2200 (x : K), 0 \u2264 a * x * x + b * x + c\nh' : discrim a b c = 0\nthis\u271d : 0 < a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c\nthis : a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c = 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [quadratic_eq_zero_iff_of_discrim_eq_zero ha h' (-b / (2 * a))]", "annotated_tactic": ["rw [<a>quadratic_eq_zero_iff_of_discrim_eq_zero</a> ha h' (-b / (2 * a))]", [{"full_name": "quadratic_eq_zero_iff_of_discrim_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/QuadraticDiscriminant.lean", "def_pos": [105, 9], "def_end_pos": [105, 49]}]], "state_before": "K : Type u_1\ninst\u271d : LinearOrderedField K\na b c : K\nha : a \u2260 0\nh : \u2200 (x : K), 0 < a * x * x + b * x + c\nthis\u271d : \u2200 (x : K), 0 \u2264 a * x * x + b * x + c\nh' : discrim a b c = 0\nthis : 0 < a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c\n\u22a2 a * (-b / (2 * a)) * (-b / (2 * a)) + b * (-b / (2 * a)) + c = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousOn.lean", "full_name": "ContinuousWithinAt.continuousAt", "start": [904, 1], "end": [906, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Order/Basic.lean", "full_name": "Nat.cast_natAbs", "start": [64, 1], "end": [65, 36], "traced_tactics": [{"tactic": "rw [\u2190 coe_natAbs, Int.cast_ofNat]", "annotated_tactic": ["rw [\u2190 <a>coe_natAbs</a>, <a>Int.cast_ofNat</a>]", [{"full_name": "Int.coe_natAbs", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Order/Basic.lean", "def_pos": [61, 26], "def_end_pos": [61, 36]}, {"full_name": "Int.cast_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : AddGroupWithOne \u03b1\nn : \u2124\n\u22a2 \u2191(natAbs n) = \u2191|n|", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Add.lean", "full_name": "DifferentiableAt.sum", "start": [382, 1], "end": [384, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Option.lean", "full_name": "Equiv.removeNone_symm", "start": [130, 1], "end": [131, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearEquiv.ofSubmodule'_apply", "start": [744, 1], "end": [746, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Real.lean", "full_name": "ENNReal.ofReal_lt_ofReal_iff", "start": [206, 1], "end": [207, 86], "traced_tactics": [{"tactic": "rw [ENNReal.ofReal, ENNReal.ofReal, coe_lt_coe, Real.toNNReal_lt_toNNReal_iff h]", "annotated_tactic": ["rw [<a>ENNReal.ofReal</a>, <a>ENNReal.ofReal</a>, <a>coe_lt_coe</a>, <a>Real.toNNReal_lt_toNNReal_iff</a> h]", [{"full_name": "ENNReal.ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [198, 29], "def_end_pos": [198, 35]}, {"full_name": "ENNReal.ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [198, 29], "def_end_pos": [198, 35]}, {"full_name": "ENNReal.coe_lt_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [379, 28], "def_end_pos": [379, 38]}, {"full_name": "Real.toNNReal_lt_toNNReal_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [718, 9], "def_end_pos": [718, 33]}]], "state_before": "a b c d : \u211d\u22650\u221e\nr p\u271d q\u271d : \u211d\u22650\np q : \u211d\nh : 0 < q\n\u22a2 ENNReal.ofReal p < ENNReal.ofReal q \u2194 p < q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.card_attach", "start": [1616, 1], "end": [1617, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "full_name": "Complex.range_exp_mul_I", "start": [87, 1], "end": [89, 83], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "a x z : \u2102\n\u22a2 (range fun x => cexp (\u2191x * I)) = sphere 0 1", "state_after": "case h\na x\u271d z x : \u2102\n\u22a2 (x \u2208 range fun x => cexp (\u2191x * I)) \u2194 x \u2208 sphere 0 1"}, {"tactic": "simp only [mem_sphere_zero_iff_norm, norm_eq_abs, abs_eq_one_iff, Set.mem_range]", "annotated_tactic": ["simp only [<a>mem_sphere_zero_iff_norm</a>, <a>norm_eq_abs</a>, <a>abs_eq_one_iff</a>, <a>Set.mem_range</a>]", [{"full_name": "mem_sphere_zero_iff_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [781, 3], "def_end_pos": [781, 14]}, {"full_name": "Complex.norm_eq_abs", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Basic.lean", "def_pos": [52, 9], "def_end_pos": [52, 20]}, {"full_name": "Complex.abs_eq_one_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "def_pos": [76, 9], "def_end_pos": [76, 23]}, {"full_name": "Set.mem_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [160, 17], "def_end_pos": [160, 26]}]], "state_before": "case h\na x\u271d z x : \u2102\n\u22a2 (x \u2208 range fun x => cexp (\u2191x * I)) \u2194 x \u2208 sphere 0 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "full_name": "exists_seq_norm_le_one_le_norm_sub", "start": [452, 1], "end": [457, 45], "traced_tactics": [{"tactic": "obtain \u27e8c, hc\u27e9 : \u2203 c : \ud835\udd5c, 1 < \u2016c\u2016 := NormedField.exists_one_lt_norm \ud835\udd5c", "annotated_tactic": ["obtain \u27e8c, hc\u27e9 : \u2203 c : \ud835\udd5c, 1 < \u2016c\u2016 := <a>NormedField.exists_one_lt_norm</a> \ud835\udd5c", [{"full_name": "NormedField.exists_one_lt_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Field/Basic.lean", "def_pos": [951, 9], "def_end_pos": [951, 27]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\nF : Type w\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\nF' : Type x\ninst\u271d\u2075 : AddCommGroup F'\ninst\u271d\u2074 : Module \ud835\udd5c F'\ninst\u271d\u00b3 : TopologicalSpace F'\ninst\u271d\u00b2 : TopologicalAddGroup F'\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F'\ninst\u271d : CompleteSpace \ud835\udd5c\nh : \u00acFiniteDimensional \ud835\udd5c E\n\u22a2 \u2203 R f, 1 < R \u2227 (\u2200 (n : \u2115), \u2016f n\u2016 \u2264 R) \u2227 Pairwise fun m n => 1 \u2264 \u2016f m - f n\u2016", "state_after": "case intro\n\ud835\udd5c : Type u\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\nF : Type w\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\nF' : Type x\ninst\u271d\u2075 : AddCommGroup F'\ninst\u271d\u2074 : Module \ud835\udd5c F'\ninst\u271d\u00b3 : TopologicalSpace F'\ninst\u271d\u00b2 : TopologicalAddGroup F'\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F'\ninst\u271d : CompleteSpace \ud835\udd5c\nh : \u00acFiniteDimensional \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\n\u22a2 \u2203 R f, 1 < R \u2227 (\u2200 (n : \u2115), \u2016f n\u2016 \u2264 R) \u2227 Pairwise fun m n => 1 \u2264 \u2016f m - f n\u2016"}, {"tactic": "have A : \u2016c\u2016 < \u2016c\u2016 + 1 := by linarith", "annotated_tactic": ["have A : \u2016c\u2016 < \u2016c\u2016 + 1 := by linarith", []], "state_before": "case intro\n\ud835\udd5c : Type u\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\nF : Type w\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\nF' : Type x\ninst\u271d\u2075 : AddCommGroup F'\ninst\u271d\u2074 : Module \ud835\udd5c F'\ninst\u271d\u00b3 : TopologicalSpace F'\ninst\u271d\u00b2 : TopologicalAddGroup F'\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F'\ninst\u271d : CompleteSpace \ud835\udd5c\nh : \u00acFiniteDimensional \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\n\u22a2 \u2203 R f, 1 < R \u2227 (\u2200 (n : \u2115), \u2016f n\u2016 \u2264 R) \u2227 Pairwise fun m n => 1 \u2264 \u2016f m - f n\u2016", "state_after": "case intro\n\ud835\udd5c : Type u\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\nF : Type w\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\nF' : Type x\ninst\u271d\u2075 : AddCommGroup F'\ninst\u271d\u2074 : Module \ud835\udd5c F'\ninst\u271d\u00b3 : TopologicalSpace F'\ninst\u271d\u00b2 : TopologicalAddGroup F'\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F'\ninst\u271d : CompleteSpace \ud835\udd5c\nh : \u00acFiniteDimensional \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nA : \u2016c\u2016 < \u2016c\u2016 + 1\n\u22a2 \u2203 R f, 1 < R \u2227 (\u2200 (n : \u2115), \u2016f n\u2016 \u2264 R) \u2227 Pairwise fun m n => 1 \u2264 \u2016f m - f n\u2016"}, {"tactic": "rcases exists_seq_norm_le_one_le_norm_sub' hc A h with \u27e8f, hf\u27e9", "annotated_tactic": ["rcases <a>exists_seq_norm_le_one_le_norm_sub'</a> hc A h with \u27e8f, hf\u27e9", [{"full_name": "exists_seq_norm_le_one_le_norm_sub'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "def_pos": [438, 9], "def_end_pos": [438, 44]}]], "state_before": "case intro\n\ud835\udd5c : Type u\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\nF : Type w\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\nF' : Type x\ninst\u271d\u2075 : AddCommGroup F'\ninst\u271d\u2074 : Module \ud835\udd5c F'\ninst\u271d\u00b3 : TopologicalSpace F'\ninst\u271d\u00b2 : TopologicalAddGroup F'\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F'\ninst\u271d : CompleteSpace \ud835\udd5c\nh : \u00acFiniteDimensional \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nA : \u2016c\u2016 < \u2016c\u2016 + 1\n\u22a2 \u2203 R f, 1 < R \u2227 (\u2200 (n : \u2115), \u2016f n\u2016 \u2264 R) \u2227 Pairwise fun m n => 1 \u2264 \u2016f m - f n\u2016", "state_after": "case intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\nF : Type w\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\nF' : Type x\ninst\u271d\u2075 : AddCommGroup F'\ninst\u271d\u2074 : Module \ud835\udd5c F'\ninst\u271d\u00b3 : TopologicalSpace F'\ninst\u271d\u00b2 : TopologicalAddGroup F'\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F'\ninst\u271d : CompleteSpace \ud835\udd5c\nh : \u00acFiniteDimensional \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nA : \u2016c\u2016 < \u2016c\u2016 + 1\nf : \u2115 \u2192 E\nhf : (\u2200 (n : \u2115), \u2016f n\u2016 \u2264 \u2016c\u2016 + 1) \u2227 Pairwise fun m n => 1 \u2264 \u2016f m - f n\u2016\n\u22a2 \u2203 R f, 1 < R \u2227 (\u2200 (n : \u2115), \u2016f n\u2016 \u2264 R) \u2227 Pairwise fun m n => 1 \u2264 \u2016f m - f n\u2016"}, {"tactic": "exact \u27e8\u2016c\u2016 + 1, f, hc.trans A, hf.1, hf.2\u27e9", "annotated_tactic": ["exact \u27e8\u2016c\u2016 + 1, f, hc.trans A, hf.1, hf.2\u27e9", []], "state_before": "case intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\nF : Type w\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\nF' : Type x\ninst\u271d\u2075 : AddCommGroup F'\ninst\u271d\u2074 : Module \ud835\udd5c F'\ninst\u271d\u00b3 : TopologicalSpace F'\ninst\u271d\u00b2 : TopologicalAddGroup F'\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F'\ninst\u271d : CompleteSpace \ud835\udd5c\nh : \u00acFiniteDimensional \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nA : \u2016c\u2016 < \u2016c\u2016 + 1\nf : \u2115 \u2192 E\nhf : (\u2200 (n : \u2115), \u2016f n\u2016 \u2264 \u2016c\u2016 + 1) \u2227 Pairwise fun m n => 1 \u2264 \u2016f m - f n\u2016\n\u22a2 \u2203 R f, 1 < R \u2227 (\u2200 (n : \u2115), \u2016f n\u2016 \u2264 R) \u2227 Pairwise fun m n => 1 \u2264 \u2016f m - f n\u2016", "state_after": "no goals"}, {"tactic": "linarith", "annotated_tactic": ["linarith", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u2079 : NormedAddCommGroup E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\nF : Type w\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\nF' : Type x\ninst\u271d\u2075 : AddCommGroup F'\ninst\u271d\u2074 : Module \ud835\udd5c F'\ninst\u271d\u00b3 : TopologicalSpace F'\ninst\u271d\u00b2 : TopologicalAddGroup F'\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F'\ninst\u271d : CompleteSpace \ud835\udd5c\nh : \u00acFiniteDimensional \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\n\u22a2 \u2016c\u2016 < \u2016c\u2016 + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/RowCol.lean", "full_name": "Matrix.row_vecMul", "start": [117, 1], "end": [120, 6], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nM : Matrix m n \u03b1\nv : m \u2192 \u03b1\n\u22a2 row (v \u1d65* M) = row v * M", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nM : Matrix m n \u03b1\nv : m \u2192 \u03b1\ni\u271d : Unit\nx\u271d : n\n\u22a2 row (v \u1d65* M) i\u271d x\u271d = (row v * M) i\u271d x\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d\u00b9 : Fintype m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nM : Matrix m n \u03b1\nv : m \u2192 \u03b1\ni\u271d : Unit\nx\u271d : n\n\u22a2 row (v \u1d65* M) i\u271d x\u271d = (row v * M) i\u271d x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "closure_eq_iff_isClosed", "start": [457, 1], "end": [458, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Limit.lean", "full_name": "Order.not_isSuccLimit", "start": [226, 1], "end": [226, 67], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\na b : \u03b1\nC : \u03b1 \u2192 Sort u_2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b1\ninst\u271d : NoMinOrder \u03b1\n\u22a2 \u00acIsSuccLimit a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Infix.lean", "full_name": "List.tails_append", "start": [383, 1], "end": [387, 44], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 l\u2083 : List \u03b1\na b : \u03b1\nm n : \u2115\n\u22a2 tails ([] ++ []) = map (fun l => l ++ []) (tails []) ++ tail (tails [])", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 l\u2083 : List \u03b1\na\u271d b : \u03b1\nm n : \u2115\na : \u03b1\nt : List \u03b1\n\u22a2 tails ([] ++ a :: t) = map (fun l => l ++ a :: t) (tails []) ++ tail (tails (a :: t))", "state_after": "no goals"}, {"tactic": "simp [tails_append s t]", "annotated_tactic": ["simp [tails_append s t]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 l\u2083 : List \u03b1\na\u271d b : \u03b1\nm n : \u2115\na : \u03b1\ns t : List \u03b1\n\u22a2 tails (a :: s ++ t) = map (fun l => l ++ t) (tails (a :: s)) ++ tail (tails t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "MonoidHom.range_eq_map", "start": [2631, 1], "end": [2631, 85], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : Group G'\ninst\u271d\u00b3 : Group G''\nA : Type u_4\ninst\u271d\u00b2 : AddGroup A\nN : Type u_5\nP : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : Group P\nK : Subgroup G\nf : G \u2192* N\n\u22a2 range f = map f \u22a4", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : Group G'\ninst\u271d\u00b3 : Group G''\nA : Type u_4\ninst\u271d\u00b2 : AddGroup A\nN : Type u_5\nP : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : Group P\nK : Subgroup G\nf : G \u2192* N\nx\u271d : N\n\u22a2 x\u271d \u2208 range f \u2194 x\u271d \u2208 map f \u22a4"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : Group G'\ninst\u271d\u00b3 : Group G''\nA : Type u_4\ninst\u271d\u00b2 : AddGroup A\nN : Type u_5\nP : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : Group P\nK : Subgroup G\nf : G \u2192* N\nx\u271d : N\n\u22a2 x\u271d \u2208 range f \u2194 x\u271d \u2208 map f \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Defs.lean", "full_name": "Nat.le_succ_iff", "start": [84, 1], "end": [88, 8], "traced_tactics": [{"tactic": "refine \u27e8fun hmn \u21a6 (lt_or_eq_of_le hmn).imp_left le_of_lt_succ, ?_\u27e9", "annotated_tactic": ["refine \u27e8fun hmn \u21a6 (<a>lt_or_eq_of_le</a> hmn).<a>imp_left</a> <a>le_of_lt_succ</a>, ?_\u27e9", [{"full_name": "lt_or_eq_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [222, 9], "def_end_pos": [222, 23]}, {"full_name": "Or.imp_left", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [160, 9], "def_end_pos": [160, 20]}, {"full_name": "Nat.le_of_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1697, 9], "def_end_pos": [1697, 26]}]], "state_before": "a b c d m n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 m \u2264 succ n \u2194 m \u2264 n \u2228 m = succ n", "state_after": "a b c d m n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 m \u2264 n \u2228 m = succ n \u2192 m \u2264 succ n"}, {"tactic": "rintro (hmn | rfl)", "annotated_tactic": ["rintro (hmn | rfl)", []], "state_before": "a b c d m n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 m \u2264 n \u2228 m = succ n \u2192 m \u2264 succ n", "state_after": "case inl\na b c d m n k : \u2115\np q : \u2115 \u2192 Prop\nhmn : m \u2264 n\n\u22a2 m \u2264 succ n\n\ncase inr\na b c d n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 succ n \u2264 succ n"}, {"tactic": "exact le_succ_of_le hmn", "annotated_tactic": ["exact <a>le_succ_of_le</a> hmn", [{"full_name": "Nat.le_succ_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1668, 9], "def_end_pos": [1668, 26]}]], "state_before": "case inl\na b c d m n k : \u2115\np q : \u2115 \u2192 Prop\nhmn : m \u2264 n\n\u22a2 m \u2264 succ n", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case inr\na b c d n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 succ n \u2264 succ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/PiSystem.lean", "full_name": "isPiSystem_Ixx", "start": [177, 1], "end": [181, 90], "traced_tactics": [{"tactic": "simpa only [exists_range_iff] using isPiSystem_Ixx_mem (@Hne) (@Hi) (range f) (range g)", "annotated_tactic": ["simpa only [<a>exists_range_iff</a>] using <a>isPiSystem_Ixx_mem</a> (@Hne) (@Hi) (<a>range</a> f) (<a>range</a> g)", [{"full_name": "Set.exists_range_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [665, 9], "def_end_pos": [665, 25]}, {"full_name": "isPiSystem_Ixx_mem", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/PiSystem.lean", "def_pos": [168, 9], "def_end_pos": [168, 27]}, {"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}, {"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\n\u03b9' : Sort u_3\ninst\u271d : LinearOrder \u03b1\nIxx : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1\np : \u03b1 \u2192 \u03b1 \u2192 Prop\nHne : \u2200 {a b : \u03b1}, Set.Nonempty (Ixx a b) \u2192 p a b\nHi : \u2200 {a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1}, Ixx a\u2081 b\u2081 \u2229 Ixx a\u2082 b\u2082 = Ixx (max a\u2081 a\u2082) (min b\u2081 b\u2082)\nf : \u03b9 \u2192 \u03b1\ng : \u03b9' \u2192 \u03b1\n\u22a2 IsPiSystem {S | \u2203 i j, p (f i) (g j) \u2227 Ixx (f i) (g j) = S}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Basic.lean", "full_name": "Complex.continuous_abs", "start": [185, 1], "end": [186, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.eval\u2082_eq'", "start": [968, 1], "end": [971, 6], "traced_tactics": [{"tactic": "simp only [eval\u2082_eq, \u2190 Finsupp.prod_pow]", "annotated_tactic": ["simp only [<a>eval\u2082_eq</a>, \u2190 <a>Finsupp.prod_pow</a>]", [{"full_name": "MvPolynomial.eval\u2082_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [963, 9], "def_end_pos": [963, 17]}, {"full_name": "Finsupp.prod_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [150, 9], "def_end_pos": [150, 17]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d : R \u2192+* S\u2081\ng\u271d : \u03c3 \u2192 S\u2081\ninst\u271d : Fintype \u03c3\ng : R \u2192+* S\u2081\nX : \u03c3 \u2192 S\u2081\nf : MvPolynomial \u03c3 R\n\u22a2 eval\u2082 g X f = \u2211 d in support f, g (coeff d f) * \u220f i : \u03c3, X i ^ d i", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d : R \u2192+* S\u2081\ng\u271d : \u03c3 \u2192 S\u2081\ninst\u271d : Fintype \u03c3\ng : R \u2192+* S\u2081\nX : \u03c3 \u2192 S\u2081\nf : MvPolynomial \u03c3 R\n\u22a2 \u2211 d in support f, g (coeff d f) * \u220f i in d.support, X i ^ d i =\n    \u2211 x in support f, g (coeff x f) * Finsupp.prod x fun a b => X a ^ b"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d : R \u2192+* S\u2081\ng\u271d : \u03c3 \u2192 S\u2081\ninst\u271d : Fintype \u03c3\ng : R \u2192+* S\u2081\nX : \u03c3 \u2192 S\u2081\nf : MvPolynomial \u03c3 R\n\u22a2 \u2211 d in support f, g (coeff d f) * \u220f i in d.support, X i ^ d i =\n    \u2211 x in support f, g (coeff x f) * Finsupp.prod x fun a b => X a ^ b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Hull.lean", "full_name": "convexHull_singleton", "start": [117, 1], "end": [118, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Group/Defs.lean", "full_name": "div_le_iff_le_mul'", "start": [816, 1], "end": [816, 90], "traced_tactics": [{"tactic": "rw [div_le_iff_le_mul, mul_comm]", "annotated_tactic": ["rw [<a>div_le_iff_le_mul</a>, <a>mul_comm</a>]", [{"full_name": "div_le_iff_le_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [751, 9], "def_end_pos": [751, 26]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na b c d : \u03b1\n\u22a2 a / b \u2264 c \u2194 a \u2264 b * c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Sqrt.lean", "full_name": "Real.sqrt_eq_one", "start": [221, 1], "end": [224, 42], "traced_tactics": [{"tactic": "rw [eq_comm, mul_one]", "annotated_tactic": ["rw [<a>eq_comm</a>, <a>mul_one</a>]", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "x y : \u211d\n\u22a2 1 * 1 = x \u2194 x = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.coe_refl", "start": [304, 1], "end": [305, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/NNNorm.lean", "full_name": "ContinuousLinearMap.exists_mul_lt_of_lt_opNorm", "start": [169, 1], "end": [172, 48], "traced_tactics": [{"tactic": "lift r to \u211d\u22650 using hr\u2080", "annotated_tactic": ["lift r to \u211d\u22650 using hr\u2080", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nr : \u211d\nhr\u2080 : 0 \u2264 r\nhr : r < \u2016f\u2016\n\u22a2 \u2203 x, r * \u2016x\u2016 < \u2016f x\u2016", "state_after": "case intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nr : \u211d\u22650\nhr : \u2191r < \u2016f\u2016\n\u22a2 \u2203 x, \u2191r * \u2016x\u2016 < \u2016f x\u2016"}, {"tactic": "exact f.exists_mul_lt_apply_of_lt_opNNNorm hr", "annotated_tactic": ["exact f.exists_mul_lt_apply_of_lt_opNNNorm hr", []], "state_before": "case intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nr : \u211d\u22650\nhr : \u2191r < \u2016f\u2016\n\u22a2 \u2203 x, \u2191r * \u2016x\u2016 < \u2016f x\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_X_pow", "start": [1338, 1], "end": [1339, 61], "traced_tactics": [{"tactic": "rw [X_pow_eq_monomial, degree_monomial _ (one_ne_zero' R)]", "annotated_tactic": ["rw [<a>X_pow_eq_monomial</a>, <a>degree_monomial</a> _ (<a>one_ne_zero'</a> R)]", [{"full_name": "Polynomial.X_pow_eq_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [927, 9], "def_end_pos": [927, 26]}, {"full_name": "Polynomial.degree_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [288, 9], "def_end_pos": [288, 24]}, {"full_name": "one_ne_zero'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [81, 7], "def_end_pos": [81, 19]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np q : R[X]\nn : \u2115\n\u22a2 degree (X ^ n) = \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Squarefree/Basic.lean", "full_name": "squarefree_iff_no_irreducibles", "start": [146, 1], "end": [151, 49], "traced_tactics": [{"tactic": "refine \u27e8fun h p hp hp' \u21a6 hp.not_unit (h p hp'), fun h d hd \u21a6 by_contra fun hdu \u21a6 ?_\u27e9", "annotated_tactic": ["refine \u27e8fun h p hp hp' \u21a6 hp.not_unit (h p hp'), fun h d hd \u21a6 <a>by_contra</a> fun hdu \u21a6 ?_\u27e9", [{"full_name": "by_contra", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [222, 7], "def_end_pos": [222, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommMonoidWithZero R\ninst\u271d : WfDvdMonoid R\nx : R\nhx\u2080 : x \u2260 0\n\u22a2 Squarefree x \u2194 \u2200 (p : R), Irreducible p \u2192 \u00acp * p \u2223 x", "state_after": "R : Type u_1\ninst\u271d\u00b9 : CommMonoidWithZero R\ninst\u271d : WfDvdMonoid R\nx : R\nhx\u2080 : x \u2260 0\nh : \u2200 (p : R), Irreducible p \u2192 \u00acp * p \u2223 x\nd : R\nhd : d * d \u2223 x\nhdu : \u00acIsUnit d\n\u22a2 False"}, {"tactic": "have hd\u2080 : d \u2260 0 := ne_zero_of_dvd_ne_zero (ne_zero_of_dvd_ne_zero hx\u2080 hd) (dvd_mul_left d d)", "annotated_tactic": ["have hd\u2080 : d \u2260 0 := <a>ne_zero_of_dvd_ne_zero</a> (<a>ne_zero_of_dvd_ne_zero</a> hx\u2080 hd) (<a>dvd_mul_left</a> d d)", [{"full_name": "ne_zero_of_dvd_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean", "def_pos": [121, 9], "def_end_pos": [121, 31]}, {"full_name": "ne_zero_of_dvd_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean", "def_pos": [121, 9], "def_end_pos": [121, 31]}, {"full_name": "dvd_mul_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [198, 9], "def_end_pos": [198, 21]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommMonoidWithZero R\ninst\u271d : WfDvdMonoid R\nx : R\nhx\u2080 : x \u2260 0\nh : \u2200 (p : R), Irreducible p \u2192 \u00acp * p \u2223 x\nd : R\nhd : d * d \u2223 x\nhdu : \u00acIsUnit d\n\u22a2 False", "state_after": "R : Type u_1\ninst\u271d\u00b9 : CommMonoidWithZero R\ninst\u271d : WfDvdMonoid R\nx : R\nhx\u2080 : x \u2260 0\nh : \u2200 (p : R), Irreducible p \u2192 \u00acp * p \u2223 x\nd : R\nhd : d * d \u2223 x\nhdu : \u00acIsUnit d\nhd\u2080 : d \u2260 0\n\u22a2 False"}, {"tactic": "obtain \u27e8p, irr, dvd\u27e9 := WfDvdMonoid.exists_irreducible_factor hdu hd\u2080", "annotated_tactic": ["obtain \u27e8p, irr, dvd\u27e9 := <a>WfDvdMonoid.exists_irreducible_factor</a> hdu hd\u2080", [{"full_name": "WfDvdMonoid.exists_irreducible_factor", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [76, 9], "def_end_pos": [76, 34]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommMonoidWithZero R\ninst\u271d : WfDvdMonoid R\nx : R\nhx\u2080 : x \u2260 0\nh : \u2200 (p : R), Irreducible p \u2192 \u00acp * p \u2223 x\nd : R\nhd : d * d \u2223 x\nhdu : \u00acIsUnit d\nhd\u2080 : d \u2260 0\n\u22a2 False", "state_after": "case intro.intro\nR : Type u_1\ninst\u271d\u00b9 : CommMonoidWithZero R\ninst\u271d : WfDvdMonoid R\nx : R\nhx\u2080 : x \u2260 0\nh : \u2200 (p : R), Irreducible p \u2192 \u00acp * p \u2223 x\nd : R\nhd : d * d \u2223 x\nhdu : \u00acIsUnit d\nhd\u2080 : d \u2260 0\np : R\nirr : Irreducible p\ndvd : p \u2223 d\n\u22a2 False"}, {"tactic": "exact h p irr ((mul_dvd_mul dvd dvd).trans hd)", "annotated_tactic": ["exact h p irr ((<a>mul_dvd_mul</a> dvd dvd).<a>trans</a> hd)", [{"full_name": "mul_dvd_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [210, 9], "def_end_pos": [210, 20]}, {"full_name": "Dvd.dvd.trans", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [75, 7], "def_end_pos": [75, 20]}]], "state_before": "case intro.intro\nR : Type u_1\ninst\u271d\u00b9 : CommMonoidWithZero R\ninst\u271d : WfDvdMonoid R\nx : R\nhx\u2080 : x \u2260 0\nh : \u2200 (p : R), Irreducible p \u2192 \u00acp * p \u2223 x\nd : R\nhd : d * d \u2223 x\nhdu : \u00acIsUnit d\nhd\u2080 : d \u2260 0\np : R\nirr : Irreducible p\ndvd : p \u2223 d\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.card_cons", "start": [97, 1], "end": [98, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.mem_setOf", "start": [234, 1], "end": [235, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Hom.lean", "full_name": "NormedAddGroupHom.le_opNorm_of_le", "start": [248, 1], "end": [249, 62], "traced_tactics": [{"tactic": "gcongr", "annotated_tactic": ["gcongr", []], "state_before": "V : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf g : NormedAddGroupHom V\u2081 V\u2082\nc : \u211d\nx : V\u2081\nh : \u2016x\u2016 \u2264 c\n\u22a2 \u2016f\u2016 * \u2016x\u2016 \u2264 \u2016f\u2016 * c", "state_after": "case a0\nV : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf g : NormedAddGroupHom V\u2081 V\u2082\nc : \u211d\nx : V\u2081\nh : \u2016x\u2016 \u2264 c\n\u22a2 0 \u2264 \u2016f\u2016"}, {"tactic": "exact f.opNorm_nonneg", "annotated_tactic": ["exact f.opNorm_nonneg", []], "state_before": "case a0\nV : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf g : NormedAddGroupHom V\u2081 V\u2082\nc : \u211d\nx : V\u2081\nh : \u2016x\u2016 \u2264 c\n\u22a2 0 \u2264 \u2016f\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.sigma_support", "start": [1881, 1], "end": [1885, 8], "traced_tactics": [{"tactic": "simp only [Finset.ext_iff, splitSupport, split, comapDomain, @mem_image _ _ (Classical.decEq _),\n  mem_preimage, Sigma.forall, mem_sigma]", "annotated_tactic": ["simp only [<a>Finset.ext_iff</a>, <a>splitSupport</a>, <a>split</a>, <a>comapDomain</a>, @<a>mem_image</a> _ _ (<a>Classical.decEq</a> _),\n    <a>mem_preimage</a>, <a>Sigma.forall</a>, <a>mem_sigma</a>]", [{"full_name": "Finset.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 16]}, {"full_name": "Finsupp.splitSupport", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [1855, 5], "def_end_pos": [1855, 17]}, {"full_name": "Finsupp.split", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [1843, 5], "def_end_pos": [1843, 10]}, {"full_name": "Finsupp.comapDomain", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [691, 5], "def_end_pos": [691, 16]}, {"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}, {"full_name": "Classical.decEq", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [979, 19], "def_end_pos": [979, 24]}, {"full_name": "Finset.mem_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}, {"full_name": "Sigma.forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sigma/Basic.lean", "def_pos": [95, 9], "def_end_pos": [95, 17]}, {"full_name": "Finset.mem_sigma", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Sigma.lean", "def_pos": [49, 9], "def_end_pos": [49, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\n\u03b1s : \u03b9 \u2192 Type u_13\ninst\u271d : Zero M\nl : (i : \u03b9) \u00d7 \u03b1s i \u2192\u2080 M\n\u22a2 l.support = Finset.sigma (splitSupport l) fun i => (split l i).support", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\n\u03b1s : \u03b9 \u2192 Type u_13\ninst\u271d : Zero M\nl : (i : \u03b9) \u00d7 \u03b1s i \u2192\u2080 M\n\u22a2 \u2200 (a : \u03b9) (b : \u03b1s a),\n    { fst := a, snd := b } \u2208 l.support \u2194 (\u2203 a_1 \u2208 l.support, a_1.fst = a) \u2227 { fst := a, snd := b } \u2208 l.support"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\n\u03b1s : \u03b9 \u2192 Type u_13\ninst\u271d : Zero M\nl : (i : \u03b9) \u00d7 \u03b1s i \u2192\u2080 M\n\u22a2 \u2200 (a : \u03b9) (b : \u03b1s a),\n    { fst := a, snd := b } \u2208 l.support \u2194 (\u2203 a_1 \u2208 l.support, a_1.fst = a) \u2227 { fst := a, snd := b } \u2208 l.support", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Irreducible.dvd_symm", "start": [244, 1], "end": [247, 82], "traced_tactics": [{"tactic": "rintro \u27e8q', rfl\u27e9", "annotated_tactic": ["rintro \u27e8q', rfl\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\np q : \u03b1\nhp : Irreducible p\nhq : Irreducible q\n\u22a2 p \u2223 q \u2192 q \u2223 p", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\np : \u03b1\nhp : Irreducible p\nq' : \u03b1\nhq : Irreducible (p * q')\n\u22a2 p * q' \u2223 p"}, {"tactic": "rw [IsUnit.mul_right_dvd (Or.resolve_left (of_irreducible_mul hq) hp.not_unit)]", "annotated_tactic": ["rw [<a>IsUnit.mul_right_dvd</a> (<a>Or.resolve_left</a> (<a>of_irreducible_mul</a> hq) hp.not_unit)]", [{"full_name": "IsUnit.mul_right_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Units.lean", "def_pos": [94, 9], "def_end_pos": [94, 22]}, {"full_name": "Or.resolve_left", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [551, 9], "def_end_pos": [551, 24]}, {"full_name": "of_irreducible_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [216, 9], "def_end_pos": [216, 27]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\np : \u03b1\nhp : Irreducible p\nq' : \u03b1\nhq : Irreducible (p * q')\n\u22a2 p * q' \u2223 p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "Set.pairwiseDisjoint_nhds", "start": [1236, 11], "end": [1237, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Multilinear/Curry.lean", "full_name": "ContinuousMultilinearMap.apply_zero_curry0", "start": [430, 1], "end": [433, 31], "traced_tactics": [{"tactic": "ext m", "annotated_tactic": ["ext m", []], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2074 : Fintype \u03b9\ninst\u271d\u00b9\u00b3 : Fintype \u03b9'\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedAddCommGroup (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedAddCommGroup (E' i)\ninst\u271d\u2076 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedAddCommGroup (Ei i)\ninst\u271d\u2074 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf : ContinuousMultilinearMap \ud835\udd5c (fun i => G) G'\nx : Fin 0 \u2192 G\n\u22a2 curry0 \ud835\udd5c G (f x) = f", "state_after": "case H\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2074 : Fintype \u03b9\ninst\u271d\u00b9\u00b3 : Fintype \u03b9'\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedAddCommGroup (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedAddCommGroup (E' i)\ninst\u271d\u2076 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedAddCommGroup (Ei i)\ninst\u271d\u2074 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf : ContinuousMultilinearMap \ud835\udd5c (fun i => G) G'\nx m : Fin 0 \u2192 G\n\u22a2 (curry0 \ud835\udd5c G (f x)) m = f m"}, {"tactic": "simp [Subsingleton.elim x m]", "annotated_tactic": ["simp [<a>Subsingleton.elim</a> x m]", [{"full_name": "Subsingleton.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1010, 19], "def_end_pos": [1010, 36]}]], "state_before": "case H\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2074 : Fintype \u03b9\ninst\u271d\u00b9\u00b3 : Fintype \u03b9'\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedAddCommGroup (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedAddCommGroup (E' i)\ninst\u271d\u2076 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedAddCommGroup (Ei i)\ninst\u271d\u2074 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf : ContinuousMultilinearMap \ud835\udd5c (fun i => G) G'\nx m : Fin 0 \u2192 G\n\u22a2 (curry0 \ud835\udd5c G (f x)) m = f m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.nodup_permutations", "start": [893, 1], "end": [929, 30], "traced_tactics": [{"tactic": "rw [(permutations_perm_permutations' s).nodup_iff]", "annotated_tactic": ["rw [(<a>permutations_perm_permutations'</a> s).<a>nodup_iff</a>]", [{"full_name": "List.permutations_perm_permutations'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [758, 9], "def_end_pos": [758, 40]}, {"full_name": "List.Perm.nodup_iff", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [682, 9], "def_end_pos": [682, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nhs : Nodup s\n\u22a2 Nodup (permutations s)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nhs : Nodup s\n\u22a2 Nodup (permutations' s)"}, {"tactic": "induction' hs with x l h h' IH", "annotated_tactic": ["induction' hs with x l h h' IH", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nhs : Nodup s\n\u22a2 Nodup (permutations' s)", "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\n\u22a2 Nodup (permutations' [])\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 Nodup (permutations' (x :: l))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\n\u22a2 Nodup (permutations' [])", "state_after": "no goals"}, {"tactic": "rw [permutations']", "annotated_tactic": ["rw [<a>permutations'</a>]", [{"full_name": "List.permutations'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [274, 5], "def_end_pos": [274, 18]}]], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 Nodup (permutations' (x :: l))", "state_after": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 Nodup (List.bind (permutations' l) (permutations'Aux x))"}, {"tactic": "rw [nodup_bind]", "annotated_tactic": ["rw [<a>nodup_bind</a>]", [{"full_name": "List.nodup_bind", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Nodup.lean", "def_pos": [353, 9], "def_end_pos": [353, 19]}]], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 Nodup (List.bind (permutations' l) (permutations'Aux x))", "state_after": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 (\u2200 x_1 \u2208 permutations' l, Nodup (permutations'Aux x x_1)) \u2227\n    Pairwise (fun a b => Disjoint (permutations'Aux x a) (permutations'Aux x b)) (permutations' l)"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 (\u2200 x_1 \u2208 permutations' l, Nodup (permutations'Aux x x_1)) \u2227\n    Pairwise (fun a b => Disjoint (permutations'Aux x a) (permutations'Aux x b)) (permutations' l)", "state_after": "case cons.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 \u2200 x_1 \u2208 permutations' l, Nodup (permutations'Aux x x_1)\n\ncase cons.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 Pairwise (fun a b => Disjoint (permutations'Aux x a) (permutations'Aux x b)) (permutations' l)"}, {"tactic": "intro ys hy", "annotated_tactic": ["intro ys hy", []], "state_before": "case cons.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 \u2200 x_1 \u2208 permutations' l, Nodup (permutations'Aux x x_1)", "state_after": "case cons.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nys : List \u03b1\nhy : ys \u2208 permutations' l\n\u22a2 Nodup (permutations'Aux x ys)"}, {"tactic": "rw [mem_permutations'] at hy", "annotated_tactic": ["rw [<a>mem_permutations'</a>] at hy", [{"full_name": "List.mem_permutations'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [778, 9], "def_end_pos": [778, 26]}]], "state_before": "case cons.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nys : List \u03b1\nhy : ys \u2208 permutations' l\n\u22a2 Nodup (permutations'Aux x ys)", "state_after": "case cons.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nys : List \u03b1\nhy : ys ~ l\n\u22a2 Nodup (permutations'Aux x ys)"}, {"tactic": "rw [nodup_permutations'Aux_iff, hy.mem_iff]", "annotated_tactic": ["rw [<a>nodup_permutations'Aux_iff</a>, hy.mem_iff]", [{"full_name": "List.nodup_permutations'Aux_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [861, 9], "def_end_pos": [861, 35]}]], "state_before": "case cons.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nys : List \u03b1\nhy : ys ~ l\n\u22a2 Nodup (permutations'Aux x ys)", "state_after": "case cons.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nys : List \u03b1\nhy : ys ~ l\n\u22a2 x \u2209 l"}, {"tactic": "exact fun H => h x H rfl", "annotated_tactic": ["exact fun H => h x H <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case cons.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nys : List \u03b1\nhy : ys ~ l\n\u22a2 x \u2209 l", "state_after": "no goals"}, {"tactic": "refine' IH.pairwise_of_forall_ne fun as ha bs hb H => _", "annotated_tactic": ["refine' IH.pairwise_of_forall_ne fun as ha bs hb H => _", []], "state_before": "case cons.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\n\u22a2 Pairwise (fun a b => Disjoint (permutations'Aux x a) (permutations'Aux x b)) (permutations' l)", "state_after": "case cons.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\n\u22a2 Disjoint (permutations'Aux x as) (permutations'Aux x bs)"}, {"tactic": "rw [disjoint_iff_ne]", "annotated_tactic": ["rw [<a>disjoint_iff_ne</a>]", [{"full_name": "List.disjoint_iff_ne", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1642, 9], "def_end_pos": [1642, 24]}]], "state_before": "case cons.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\n\u22a2 Disjoint (permutations'Aux x as) (permutations'Aux x bs)", "state_after": "case cons.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\n\u22a2 \u2200 a \u2208 permutations'Aux x as, \u2200 b \u2208 permutations'Aux x bs, a \u2260 b"}, {"tactic": "rintro a ha' b hb' rfl", "annotated_tactic": ["rintro a ha' b hb' rfl", []], "state_before": "case cons.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\n\u22a2 \u2200 a \u2208 permutations'Aux x as, \u2200 b \u2208 permutations'Aux x bs, a \u2260 b", "state_after": "case cons.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\n\u22a2 False"}, {"tactic": "obtain \u27e8\u27e8n, hn\u27e9, hn'\u27e9 := get_of_mem ha'", "annotated_tactic": ["obtain \u27e8\u27e8n, hn\u27e9, hn'\u27e9 := <a>get_of_mem</a> ha'", [{"full_name": "List.get_of_mem", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [180, 9], "def_end_pos": [180, 19]}]], "state_before": "case cons.right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\n\u22a2 False", "state_after": "case cons.right.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn } = a\n\u22a2 False"}, {"tactic": "obtain \u27e8\u27e8m, hm\u27e9, hm'\u27e9 := get_of_mem hb'", "annotated_tactic": ["obtain \u27e8\u27e8m, hm\u27e9, hm'\u27e9 := <a>get_of_mem</a> hb'", [{"full_name": "List.get_of_mem", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [180, 9], "def_end_pos": [180, 19]}]], "state_before": "case cons.right.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn } = a\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn } = a\nm : \u2115\nhm : m < length (permutations'Aux x bs)\nhm' : get (permutations'Aux x bs) { val := m, isLt := hm } = a\n\u22a2 False"}, {"tactic": "rw [mem_permutations'] at ha hb", "annotated_tactic": ["rw [<a>mem_permutations'</a>] at ha hb", [{"full_name": "List.mem_permutations'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [778, 9], "def_end_pos": [778, 26]}]], "state_before": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as \u2208 permutations' l\nbs : List \u03b1\nhb : bs \u2208 permutations' l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn } = a\nm : \u2115\nhm : m < length (permutations'Aux x bs)\nhm' : get (permutations'Aux x bs) { val := m, isLt := hm } = a\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn } = a\nm : \u2115\nhm : m < length (permutations'Aux x bs)\nhm' : get (permutations'Aux x bs) { val := m, isLt := hm } = a\n\u22a2 False"}, {"tactic": "have hl : as.length = bs.length := (ha.trans hb.symm).length_eq", "annotated_tactic": ["have hl : as.length = bs.length := (ha.trans hb.symm).<a>length_eq</a>", [{"full_name": "List.Perm.length_eq", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [108, 9], "def_end_pos": [108, 23]}]], "state_before": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn } = a\nm : \u2115\nhm : m < length (permutations'Aux x bs)\nhm' : get (permutations'Aux x bs) { val := m, isLt := hm } = a\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn } = a\nm : \u2115\nhm : m < length (permutations'Aux x bs)\nhm' : get (permutations'Aux x bs) { val := m, isLt := hm } = a\nhl : length as = length bs\n\u22a2 False"}, {"tactic": "simp only [Nat.lt_succ_iff, length_permutations'Aux] at hn hm", "annotated_tactic": ["simp only [<a>Nat.lt_succ_iff</a>, <a>length_permutations'Aux</a>] at hn hm", [{"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}, {"full_name": "List.length_permutations'Aux", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [825, 9], "def_end_pos": [825, 32]}]], "state_before": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn } = a\nm : \u2115\nhm : m < length (permutations'Aux x bs)\nhm' : get (permutations'Aux x bs) { val := m, isLt := hm } = a\nhl : length as = length bs\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn\u271d } = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : get (permutations'Aux x bs) { val := m, isLt := hm\u271d } = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\n\u22a2 False"}, {"tactic": "rw [\u2190 nthLe, nthLe_permutations'Aux] at hn' hm'", "annotated_tactic": ["rw [\u2190 <a>nthLe</a>, <a>nthLe_permutations'Aux</a>] at hn' hm'", [{"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}, {"full_name": "List.nthLe_permutations'Aux", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [800, 9], "def_end_pos": [800, 31]}]], "state_before": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : get (permutations'Aux x as) { val := n, isLt := hn\u271d } = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : get (permutations'Aux x bs) { val := m, isLt := hm\u271d } = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\n\u22a2 False"}, {"tactic": "have hx :\n  nthLe (insertNth n x as) m (by rwa [length_insertNth _ _ hn, Nat.lt_succ_iff, hl]) = x :=\n  by simp [hn', \u2190 hm', hm]", "annotated_tactic": ["have hx :\n        <a>nthLe</a> (<a>insertNth</a> n x as) m (by rwa [<a>length_insertNth</a> _ _ hn, <a>Nat.lt_succ_iff</a>, hl]) = x :=\n        by simp [hn', \u2190 hm', hm]", [{"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}, {"full_name": "List.insertNth", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [543, 5], "def_end_pos": [543, 14]}, {"full_name": "List.length_insertNth", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1568, 9], "def_end_pos": [1568, 25]}, {"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}]], "state_before": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\n\u22a2 False"}, {"tactic": "have hx' :\n  nthLe (insertNth m x bs) n (by rwa [length_insertNth _ _ hm, Nat.lt_succ_iff, \u2190 hl]) =\n    x :=\n  by simp [hm', \u2190 hn', hn]", "annotated_tactic": ["have hx' :\n        <a>nthLe</a> (<a>insertNth</a> m x bs) n (by rwa [<a>length_insertNth</a> _ _ hm, <a>Nat.lt_succ_iff</a>, \u2190 hl]) =\n          x :=\n        by simp [hm', \u2190 hn', hn]", [{"full_name": "List.nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/List/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 10]}, {"full_name": "List.insertNth", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [543, 5], "def_end_pos": [543, 14]}, {"full_name": "List.length_insertNth", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1568, 9], "def_end_pos": [1568, 25]}, {"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}]], "state_before": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\n\u22a2 False"}, {"tactic": "rcases lt_trichotomy n m with (ht | ht | ht)", "annotated_tactic": ["rcases <a>lt_trichotomy</a> n m with (ht | ht | ht)", [{"full_name": "lt_trichotomy", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [305, 9], "def_end_pos": [305, 22]}]], "state_before": "case cons.right.intro.mk.intro.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n < m\n\u22a2 False\n\ncase cons.right.intro.mk.intro.mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n = m\n\u22a2 False\n\ncase cons.right.intro.mk.intro.mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : m < n\n\u22a2 False"}, {"tactic": "rwa [length_insertNth _ _ hn, Nat.lt_succ_iff, hl]", "annotated_tactic": ["rwa [<a>length_insertNth</a> _ _ hn, <a>Nat.lt_succ_iff</a>, hl]", [{"full_name": "List.length_insertNth", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1568, 9], "def_end_pos": [1568, 25]}, {"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\n\u22a2 m < length (insertNth n x as)", "state_after": "no goals"}, {"tactic": "simp [hn', \u2190 hm', hm]", "annotated_tactic": ["simp [hn', \u2190 hm', hm]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\n\u22a2 nthLe (insertNth n x as) m \u22ef = x", "state_after": "no goals"}, {"tactic": "rwa [length_insertNth _ _ hm, Nat.lt_succ_iff, \u2190 hl]", "annotated_tactic": ["rwa [<a>length_insertNth</a> _ _ hm, <a>Nat.lt_succ_iff</a>, \u2190 hl]", [{"full_name": "List.length_insertNth", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1568, 9], "def_end_pos": [1568, 25]}, {"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\n\u22a2 n < length (insertNth m x bs)", "state_after": "no goals"}, {"tactic": "simp [hm', \u2190 hn', hn]", "annotated_tactic": ["simp [hm', \u2190 hn', hn]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\n\u22a2 nthLe (insertNth m x bs) n \u22ef = x", "state_after": "no goals"}, {"tactic": "suffices x \u2208 bs by exact h x (hb.subset this) rfl", "annotated_tactic": ["suffices x \u2208 bs by exact h x (hb.subset this) <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case cons.right.intro.mk.intro.mk.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n < m\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n < m\n\u22a2 x \u2208 bs"}, {"tactic": "rw [\u2190 hx', nthLe_insertNth_of_lt _ _ _ _ ht (ht.trans_le hm)]", "annotated_tactic": ["rw [\u2190 hx', <a>nthLe_insertNth_of_lt</a> _ _ _ _ ht (ht.trans_le hm)]", [{"full_name": "List.nthLe_insertNth_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1667, 9], "def_end_pos": [1667, 30]}]], "state_before": "case cons.right.intro.mk.intro.mk.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n < m\n\u22a2 x \u2208 bs", "state_after": "case cons.right.intro.mk.intro.mk.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n < m\n\u22a2 nthLe bs n \u22ef \u2208 bs"}, {"tactic": "exact nthLe_mem _ _ _", "annotated_tactic": ["exact <a>nthLe_mem</a> _ _ _", [{"full_name": "List.nthLe_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1218, 9], "def_end_pos": [1218, 18]}]], "state_before": "case cons.right.intro.mk.intro.mk.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n < m\n\u22a2 nthLe bs n \u22ef \u2208 bs", "state_after": "no goals"}, {"tactic": "exact h x (hb.subset this) rfl", "annotated_tactic": ["exact h x (hb.subset this) <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n < m\nthis : x \u2208 bs\n\u22a2 False", "state_after": "no goals"}, {"tactic": "simp only [ht] at hm' hn'", "annotated_tactic": ["simp only [ht] at hm' hn'", []], "state_before": "case cons.right.intro.mk.intro.mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n = m\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n = m\nhn' : insertNth m x as = a\n\u22a2 False"}, {"tactic": "rw [\u2190 hm'] at hn'", "annotated_tactic": ["rw [\u2190 hm'] at hn'", []], "state_before": "case cons.right.intro.mk.intro.mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n = m\nhn' : insertNth m x as = a\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n = m\nhn' : insertNth m x as = insertNth m x bs\n\u22a2 False"}, {"tactic": "exact H (insertNth_injective _ _ hn')", "annotated_tactic": ["exact H (<a>insertNth_injective</a> _ _ hn')", [{"full_name": "List.insertNth_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1711, 9], "def_end_pos": [1711, 28]}]], "state_before": "case cons.right.intro.mk.intro.mk.inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : n = m\nhn' : insertNth m x as = insertNth m x bs\n\u22a2 False", "state_after": "no goals"}, {"tactic": "suffices x \u2208 as by exact h x (ha.subset this) rfl", "annotated_tactic": ["suffices x \u2208 as by exact h x (ha.subset this) <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case cons.right.intro.mk.intro.mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : m < n\n\u22a2 False", "state_after": "case cons.right.intro.mk.intro.mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : m < n\n\u22a2 x \u2208 as"}, {"tactic": "rw [\u2190 hx, nthLe_insertNth_of_lt _ _ _ _ ht (ht.trans_le hn)]", "annotated_tactic": ["rw [\u2190 hx, <a>nthLe_insertNth_of_lt</a> _ _ _ _ ht (ht.trans_le hn)]", [{"full_name": "List.nthLe_insertNth_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1667, 9], "def_end_pos": [1667, 30]}]], "state_before": "case cons.right.intro.mk.intro.mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : m < n\n\u22a2 x \u2208 as", "state_after": "case cons.right.intro.mk.intro.mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : m < n\n\u22a2 nthLe as m \u22ef \u2208 as"}, {"tactic": "exact nthLe_mem _ _ _", "annotated_tactic": ["exact <a>nthLe_mem</a> _ _ _", [{"full_name": "List.nthLe_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1218, 9], "def_end_pos": [1218, 18]}]], "state_before": "case cons.right.intro.mk.intro.mk.inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : m < n\n\u22a2 nthLe as m \u22ef \u2208 as", "state_after": "no goals"}, {"tactic": "exact h x (ha.subset this) rfl", "annotated_tactic": ["exact h x (ha.subset this) <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na\u271d : \u03b1\ns : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : \u2200 a' \u2208 l, x \u2260 a'\nh' : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : Nodup (permutations' l)\nas : List \u03b1\nha : as ~ l\nbs : List \u03b1\nhb : bs ~ l\nH : as \u2260 bs\na : List \u03b1\nha' : a \u2208 permutations'Aux x as\nhb' : a \u2208 permutations'Aux x bs\nn : \u2115\nhn\u271d : n < length (permutations'Aux x as)\nhn' : insertNth n x as = a\nm : \u2115\nhm\u271d : m < length (permutations'Aux x bs)\nhm' : insertNth m x bs = a\nhl : length as = length bs\nhn : n \u2264 length as\nhm : m \u2264 length bs\nhx : nthLe (insertNth n x as) m \u22ef = x\nhx' : nthLe (insertNth m x bs) n \u22ef = x\nht : m < n\nthis : x \u2208 as\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "MeasurableEquiv.image_preimage", "start": [1515, 1], "end": [1517, 43], "traced_tactics": [{"tactic": "rw [\u2190 coe_toEquiv, Equiv.image_preimage]", "annotated_tactic": ["rw [\u2190 <a>coe_toEquiv</a>, <a>Equiv.image_preimage</a>]", [{"full_name": "MeasurableEquiv.coe_toEquiv", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [1374, 9], "def_end_pos": [1374, 20]}, {"full_name": "Equiv.image_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Set.lean", "def_pos": [98, 9], "def_end_pos": [98, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\ne : \u03b1 \u2243\u1d50 \u03b2\ns : Set \u03b2\n\u22a2 \u21d1e '' (\u21d1e \u207b\u00b9' s) = s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "isOpen_singleton_of_finite_mem_nhds", "start": [800, 1], "end": [806, 93], "traced_tactics": [{"tactic": "have A : {x} \u2286 s := by simp only [singleton_subset_iff, mem_of_mem_nhds hs]", "annotated_tactic": ["have A : {x} \u2286 s := by simp only [<a>singleton_subset_iff</a>, <a>mem_of_mem_nhds</a> hs]", [{"full_name": "Set.singleton_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1300, 9], "def_end_pos": [1300, 29]}, {"full_name": "mem_of_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [845, 9], "def_end_pos": [845, 24]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\n\u22a2 IsOpen {x}", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\nA : {x} \u2286 s\n\u22a2 IsOpen {x}"}, {"tactic": "have B : IsClosed (s \\ {x}) := (hsf.subset (diff_subset _ _)).isClosed", "annotated_tactic": ["have B : <a>IsClosed</a> (s \\ {x}) := (hsf.subset (<a>diff_subset</a> _ _)).<a>isClosed</a>", [{"full_name": "IsClosed", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [100, 7], "def_end_pos": [100, 15]}, {"full_name": "Set.diff_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1812, 9], "def_end_pos": [1812, 20]}, {"full_name": "Set.Finite.isClosed", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [437, 19], "def_end_pos": [437, 38]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\nA : {x} \u2286 s\n\u22a2 IsOpen {x}", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\nA : {x} \u2286 s\nB : IsClosed (s \\ {x})\n\u22a2 IsOpen {x}"}, {"tactic": "have C : (s \\ {x})\u1d9c \u2208 \ud835\udcdd x := B.isOpen_compl.mem_nhds fun h => h.2 rfl", "annotated_tactic": ["have C : (s \\ {x})\u1d9c \u2208 \ud835\udcdd x := B.isOpen_compl.mem_nhds fun h => h.2 <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\nA : {x} \u2286 s\nB : IsClosed (s \\ {x})\n\u22a2 IsOpen {x}", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\nA : {x} \u2286 s\nB : IsClosed (s \\ {x})\nC : (s \\ {x})\u1d9c \u2208 \ud835\udcdd x\n\u22a2 IsOpen {x}"}, {"tactic": "have D : {x} \u2208 \ud835\udcdd x := by simpa only [\u2190 diff_eq, diff_diff_cancel_left A] using inter_mem hs C", "annotated_tactic": ["have D : {x} \u2208 \ud835\udcdd x := by simpa only [\u2190 <a>diff_eq</a>, <a>diff_diff_cancel_left</a> A] using <a>inter_mem</a> hs C", [{"full_name": "Set.diff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [90, 9], "def_end_pos": [90, 16]}, {"full_name": "Set.diff_diff_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2067, 9], "def_end_pos": [2067, 30]}, {"full_name": "Filter.inter_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [159, 9], "def_end_pos": [159, 18]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\nA : {x} \u2286 s\nB : IsClosed (s \\ {x})\nC : (s \\ {x})\u1d9c \u2208 \ud835\udcdd x\n\u22a2 IsOpen {x}", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\nA : {x} \u2286 s\nB : IsClosed (s \\ {x})\nC : (s \\ {x})\u1d9c \u2208 \ud835\udcdd x\nD : {x} \u2208 \ud835\udcdd x\n\u22a2 IsOpen {x}"}, {"tactic": "rwa [\u2190 mem_interior_iff_mem_nhds, \u2190 singleton_subset_iff, subset_interior_iff_isOpen] at D", "annotated_tactic": ["rwa [\u2190 <a>mem_interior_iff_mem_nhds</a>, \u2190 <a>singleton_subset_iff</a>, <a>subset_interior_iff_isOpen</a>] at D", [{"full_name": "mem_interior_iff_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [836, 9], "def_end_pos": [836, 34]}, {"full_name": "Set.singleton_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1300, 9], "def_end_pos": [1300, 29]}, {"full_name": "subset_interior_iff_isOpen", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [276, 9], "def_end_pos": [276, 35]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\nA : {x} \u2286 s\nB : IsClosed (s \\ {x})\nC : (s \\ {x})\u1d9c \u2208 \ud835\udcdd x\nD : {x} \u2208 \ud835\udcdd x\n\u22a2 IsOpen {x}", "state_after": "no goals"}, {"tactic": "simp only [singleton_subset_iff, mem_of_mem_nhds hs]", "annotated_tactic": ["simp only [<a>singleton_subset_iff</a>, <a>mem_of_mem_nhds</a> hs]", [{"full_name": "Set.singleton_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1300, 9], "def_end_pos": [1300, 29]}, {"full_name": "mem_of_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [845, 9], "def_end_pos": [845, 24]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\n\u22a2 {x} \u2286 s", "state_after": "no goals"}, {"tactic": "simpa only [\u2190 diff_eq, diff_diff_cancel_left A] using inter_mem hs C", "annotated_tactic": ["simpa only [\u2190 <a>diff_eq</a>, <a>diff_diff_cancel_left</a> A] using <a>inter_mem</a> hs C", [{"full_name": "Set.diff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [90, 9], "def_end_pos": [90, 16]}, {"full_name": "Set.diff_diff_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2067, 9], "def_end_pos": [2067, 30]}, {"full_name": "Filter.inter_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [159, 9], "def_end_pos": [159, 18]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\ns : Set X\nhs : s \u2208 \ud835\udcdd x\nhsf : Set.Finite s\nA : {x} \u2286 s\nB : IsClosed (s \\ {x})\nC : (s \\ {x})\u1d9c \u2208 \ud835\udcdd x\n\u22a2 {x} \u2208 \ud835\udcdd x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Norm.lean", "full_name": "Algebra.norm_eq_norm_adjoin", "start": [199, 1], "end": [209, 61], "traced_tactics": [{"tactic": "letI := isSeparable_tower_top_of_isSeparable K K\u27eex\u27ef L", "annotated_tactic": ["letI := <a>isSeparable_tower_top_of_isSeparable</a> K K\u27eex\u27ef L", [{"full_name": "isSeparable_tower_top_of_isSeparable", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Separable.lean", "def_pos": [636, 9], "def_end_pos": [636, 45]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\n\u22a2 (norm K) x = (norm K) (AdjoinSimple.gen K x) ^ finrank (\u21a5K\u27eex\u27ef) L", "state_after": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\n\u22a2 (norm K) x = (norm K) (AdjoinSimple.gen K x) ^ finrank (\u21a5K\u27eex\u27ef) L"}, {"tactic": "let pbL := Field.powerBasisOfFiniteOfSeparable K\u27eex\u27ef L", "annotated_tactic": ["let pbL := <a>Field.powerBasisOfFiniteOfSeparable</a> K\u27eex\u27ef L", [{"full_name": "Field.powerBasisOfFiniteOfSeparable", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/PrimitiveElement.lean", "def_pos": [234, 19], "def_end_pos": [234, 48]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\n\u22a2 (norm K) x = (norm K) (AdjoinSimple.gen K x) ^ finrank (\u21a5K\u27eex\u27ef) L", "state_after": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\n\u22a2 (norm K) x = (norm K) (AdjoinSimple.gen K x) ^ finrank (\u21a5K\u27eex\u27ef) L"}, {"tactic": "let pbx := IntermediateField.adjoin.powerBasis (IsSeparable.isIntegral K x)", "annotated_tactic": ["let pbx := <a>IntermediateField.adjoin.powerBasis</a> (<a>IsSeparable.isIntegral</a> K x)", [{"full_name": "IntermediateField.adjoin.powerBasis", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [1127, 19], "def_end_pos": [1127, 36]}, {"full_name": "IsSeparable.isIntegral", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Separable.lean", "def_pos": [585, 9], "def_end_pos": [585, 31]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\n\u22a2 (norm K) x = (norm K) (AdjoinSimple.gen K x) ^ finrank (\u21a5K\u27eex\u27ef) L", "state_after": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\npbx : PowerBasis K \u21a5K\u27eex\u27ef := adjoin.powerBasis \u22ef\n\u22a2 (norm K) x = (norm K) (AdjoinSimple.gen K x) ^ finrank (\u21a5K\u27eex\u27ef) L"}, {"tactic": "erw [\u2190 AdjoinSimple.algebraMap_gen K x, norm_eq_matrix_det (pbx.basis.smul pbL.basis) _,\n  smul_leftMulMatrix_algebraMap, det_blockDiagonal, norm_eq_matrix_det pbx.basis]", "annotated_tactic": ["erw [\u2190 <a>AdjoinSimple.algebraMap_gen</a> K x, <a>norm_eq_matrix_det</a> (pbx.basis.smul pbL.basis) _,\n    <a>smul_leftMulMatrix_algebraMap</a>, <a>det_blockDiagonal</a>, <a>norm_eq_matrix_det</a> pbx.basis]", [{"full_name": "IntermediateField.AdjoinSimple.algebraMap_gen", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [608, 9], "def_end_pos": [608, 36]}, {"full_name": "Algebra.norm_eq_matrix_det", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Norm.lean", "def_pos": [87, 9], "def_end_pos": [87, 27]}, {"full_name": "Algebra.smul_leftMulMatrix_algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "def_pos": [968, 9], "def_end_pos": [968, 38]}, {"full_name": "Matrix.det_blockDiagonal", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}, {"full_name": "Algebra.norm_eq_matrix_det", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Norm.lean", "def_pos": [87, 9], "def_end_pos": [87, 27]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\npbx : PowerBasis K \u21a5K\u27eex\u27ef := adjoin.powerBasis \u22ef\n\u22a2 (norm K) x = (norm K) (AdjoinSimple.gen K x) ^ finrank (\u21a5K\u27eex\u27ef) L", "state_after": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\npbx : PowerBasis K \u21a5K\u27eex\u27ef := adjoin.powerBasis \u22ef\n\u22a2 \u220f k : Fin pbL.dim, det ((leftMulMatrix pbx.basis) (AdjoinSimple.gen K x)) =\n    det ((leftMulMatrix pbx.basis) (AdjoinSimple.gen K ((algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)))) ^\n      finrank (\u21a5K\u27ee(algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)\u27ef) L"}, {"tactic": "simp only [Finset.card_fin, Finset.prod_const]", "annotated_tactic": ["simp only [<a>Finset.card_fin</a>, <a>Finset.prod_const</a>]", [{"full_name": "Finset.card_fin", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [322, 9], "def_end_pos": [322, 24]}, {"full_name": "Finset.prod_const", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1665, 9], "def_end_pos": [1665, 19]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\npbx : PowerBasis K \u21a5K\u27eex\u27ef := adjoin.powerBasis \u22ef\n\u22a2 \u220f k : Fin pbL.dim, det ((leftMulMatrix pbx.basis) (AdjoinSimple.gen K x)) =\n    det ((leftMulMatrix pbx.basis) (AdjoinSimple.gen K ((algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)))) ^\n      finrank (\u21a5K\u27ee(algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)\u27ef) L", "state_after": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\npbx : PowerBasis K \u21a5K\u27eex\u27ef := adjoin.powerBasis \u22ef\n\u22a2 det ((leftMulMatrix pbx.basis) (AdjoinSimple.gen K x)) ^ pbL.dim =\n    det ((leftMulMatrix pbx.basis) (AdjoinSimple.gen K ((algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)))) ^\n      finrank (\u21a5K\u27ee(algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)\u27ef) L"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\npbx : PowerBasis K \u21a5K\u27eex\u27ef := adjoin.powerBasis \u22ef\n\u22a2 det ((leftMulMatrix pbx.basis) (AdjoinSimple.gen K x)) ^ pbL.dim =\n    det ((leftMulMatrix pbx.basis) (AdjoinSimple.gen K ((algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)))) ^\n      finrank (\u21a5K\u27ee(algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)\u27ef) L", "state_after": "case e_a\nR : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\npbx : PowerBasis K \u21a5K\u27eex\u27ef := adjoin.powerBasis \u22ef\n\u22a2 pbL.dim = finrank (\u21a5K\u27ee(algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)\u27ef) L"}, {"tactic": "rw [\u2190 PowerBasis.finrank, AdjoinSimple.algebraMap_gen K x]", "annotated_tactic": ["rw [\u2190 <a>PowerBasis.finrank</a>, <a>AdjoinSimple.algebraMap_gen</a> K x]", [{"full_name": "PowerBasis.finrank", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerBasis.lean", "def_pos": [83, 9], "def_end_pos": [83, 16]}, {"full_name": "IntermediateField.AdjoinSimple.algebraMap_gen", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [608, 9], "def_end_pos": [608, 36]}]], "state_before": "case e_a\nR : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : Ring S\ninst\u271d\u2077 : Algebra R S\nK : Type u_4\nL : Type u_5\nF : Type u_6\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Field L\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Algebra K L\ninst\u271d\u00b2 : Algebra K F\n\u03b9 : Type w\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : IsSeparable K L\nx : L\nthis : IsSeparable (\u21a5K\u27eex\u27ef) L := isSeparable_tower_top_of_isSeparable K (\u21a5K\u27eex\u27ef) L\npbL : PowerBasis (\u21a5K\u27eex\u27ef) L := Field.powerBasisOfFiniteOfSeparable (\u21a5K\u27eex\u27ef) L\npbx : PowerBasis K \u21a5K\u27eex\u27ef := adjoin.powerBasis \u22ef\n\u22a2 pbL.dim = finrank (\u21a5K\u27ee(algebraMap (\u21a5K\u27eex\u27ef) L) (AdjoinSimple.gen K x)\u27ef) L", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WellFounded.lean", "full_name": "Function.not_lt_argmin", "start": [197, 1], "end": [198, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pointwise.lean", "full_name": "Filter.Tendsto.div_div", "start": [932, 11], "end": [934, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.map\u2082Right'_cons_cons", "start": [4035, 1], "end": [4039, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/Bilinear.lean", "full_name": "ContinuousLinearMap.coe_deriv\u2082", "start": [421, 1], "end": [423, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/OpenPos.lean", "full_name": "Metric.measure_closedBall_pos_iff", "start": [233, 1], "end": [238, 52], "traced_tactics": [{"tactic": "refine' \u27e8fun h \u21a6 _, measure_closedBall_pos \u03bc x\u27e9", "annotated_tactic": ["refine' \u27e8fun h \u21a6 _, <a>measure_closedBall_pos</a> \u03bc x\u27e9", [{"full_name": "Metric.measure_closedBall_pos", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/OpenPos.lean", "def_pos": [229, 9], "def_end_pos": [229, 31]}]], "state_before": "X\u271d : Type u_1\ninst\u271d\u2074 : PseudoMetricSpace X\u271d\nm\u271d : MeasurableSpace X\u271d\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b3 : IsOpenPosMeasure \u03bc\u271d\nX : Type u_2\ninst\u271d\u00b2 : MetricSpace X\nm : MeasurableSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsOpenPosMeasure \u03bc\ninst\u271d : NoAtoms \u03bc\nx : X\nr : \u211d\n\u22a2 0 < \u2191\u2191\u03bc (closedBall x r) \u2194 0 < r", "state_after": "X\u271d : Type u_1\ninst\u271d\u2074 : PseudoMetricSpace X\u271d\nm\u271d : MeasurableSpace X\u271d\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b3 : IsOpenPosMeasure \u03bc\u271d\nX : Type u_2\ninst\u271d\u00b2 : MetricSpace X\nm : MeasurableSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsOpenPosMeasure \u03bc\ninst\u271d : NoAtoms \u03bc\nx : X\nr : \u211d\nh : 0 < \u2191\u2191\u03bc (closedBall x r)\n\u22a2 0 < r"}, {"tactic": "contrapose! h", "annotated_tactic": ["contrapose! h", []], "state_before": "X\u271d : Type u_1\ninst\u271d\u2074 : PseudoMetricSpace X\u271d\nm\u271d : MeasurableSpace X\u271d\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b3 : IsOpenPosMeasure \u03bc\u271d\nX : Type u_2\ninst\u271d\u00b2 : MetricSpace X\nm : MeasurableSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsOpenPosMeasure \u03bc\ninst\u271d : NoAtoms \u03bc\nx : X\nr : \u211d\nh : 0 < \u2191\u2191\u03bc (closedBall x r)\n\u22a2 0 < r", "state_after": "X\u271d : Type u_1\ninst\u271d\u2074 : PseudoMetricSpace X\u271d\nm\u271d : MeasurableSpace X\u271d\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b3 : IsOpenPosMeasure \u03bc\u271d\nX : Type u_2\ninst\u271d\u00b2 : MetricSpace X\nm : MeasurableSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsOpenPosMeasure \u03bc\ninst\u271d : NoAtoms \u03bc\nx : X\nr : \u211d\nh : r \u2264 0\n\u22a2 \u2191\u2191\u03bc (closedBall x r) \u2264 0"}, {"tactic": "rw [(subsingleton_closedBall x h).measure_zero \u03bc]", "annotated_tactic": ["rw [(<a>subsingleton_closedBall</a> x h).<a>measure_zero</a> \u03bc]", [{"full_name": "Metric.subsingleton_closedBall", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Basic.lean", "def_pos": [121, 9], "def_end_pos": [121, 32]}, {"full_name": "Set.Subsingleton.measure_zero", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Typeclasses.lean", "def_pos": [344, 9], "def_end_pos": [344, 45]}]], "state_before": "X\u271d : Type u_1\ninst\u271d\u2074 : PseudoMetricSpace X\u271d\nm\u271d : MeasurableSpace X\u271d\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b3 : IsOpenPosMeasure \u03bc\u271d\nX : Type u_2\ninst\u271d\u00b2 : MetricSpace X\nm : MeasurableSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsOpenPosMeasure \u03bc\ninst\u271d : NoAtoms \u03bc\nx : X\nr : \u211d\nh : r \u2264 0\n\u22a2 \u2191\u2191\u03bc (closedBall x r) \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "Continuous.congr", "start": [1526, 1], "end": [1527, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.IsBoundedUnder.isCoboundedUnder_flip", "start": [237, 1], "end": [239, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Defs.lean", "full_name": "Nat.add_succ_sub_one", "start": [189, 1], "end": [189, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.sup'_one", "start": [181, 1], "end": [182, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.EqOn.congr_antitoneOn", "start": [286, 1], "end": [287, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/NatAntidiagonal.lean", "full_name": "List.Nat.antidiagonal_succ_succ'", "start": [85, 1], "end": [92, 7], "traced_tactics": [{"tactic": "rw [antidiagonal_succ']", "annotated_tactic": ["rw [<a>antidiagonal_succ'</a>]", [{"full_name": "List.Nat.antidiagonal_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/NatAntidiagonal.lean", "def_pos": [76, 9], "def_end_pos": [76, 27]}]], "state_before": "n : \u2115\n\u22a2 antidiagonal (n + 2) = (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]", "state_after": "n : \u2115\n\u22a2 map (Prod.map id succ) (antidiagonal (n + 1)) ++ [(n + 1 + 1, 0)] =\n    (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]"}, {"tactic": "simp only [antidiagonal_succ, map_cons, Prod_map, id_eq, map_map, cons_append, cons.injEq,\n  append_cancel_right_eq, true_and]", "annotated_tactic": ["simp only [<a>antidiagonal_succ</a>, <a>map_cons</a>, <a>Prod_map</a>, <a>id_eq</a>, <a>map_map</a>, <a>cons_append</a>, cons.injEq,\n    <a>append_cancel_right_eq</a>, <a>true_and</a>]", [{"full_name": "List.Nat.antidiagonal_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/NatAntidiagonal.lean", "def_pos": [68, 9], "def_end_pos": [68, 26]}, {"full_name": "List.map_cons", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [118, 17], "def_end_pos": [118, 25]}, {"full_name": "Prod_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [24, 9], "def_end_pos": [24, 17]}, {"full_name": "id_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [297, 17], "def_end_pos": [297, 22]}, {"full_name": "List.map_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [133, 17], "def_end_pos": [133, 24]}, {"full_name": "List.cons_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [139, 17], "def_end_pos": [139, 28]}, {"full_name": "List.append_cancel_right_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/BasicAux.lean", "def_pos": [156, 17], "def_end_pos": [156, 39]}, {"full_name": "true_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [102, 17], "def_end_pos": [102, 25]}]], "state_before": "n : \u2115\n\u22a2 map (Prod.map id succ) (antidiagonal (n + 1)) ++ [(n + 1 + 1, 0)] =\n    (0, n + 2) :: map (Prod.map succ succ) (antidiagonal n) ++ [(n + 2, 0)]", "state_after": "n : \u2115\n\u22a2 map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n) = map (Prod.map succ succ) (antidiagonal n)"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "n : \u2115\n\u22a2 map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n) = map (Prod.map succ succ) (antidiagonal n)", "state_after": "case a.a\nn n\u271d : \u2115\na\u271d : \u2115 \u00d7 \u2115\n\u22a2 a\u271d \u2208 get? (map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n)) n\u271d \u2194\n    a\u271d \u2208 get? (map (Prod.map succ succ) (antidiagonal n)) n\u271d"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a.a\nn n\u271d : \u2115\na\u271d : \u2115 \u00d7 \u2115\n\u22a2 a\u271d \u2208 get? (map (Prod.map id succ \u2218 Prod.map succ id) (antidiagonal n)) n\u271d \u2194\n    a\u271d \u2208 get? (map (Prod.map succ succ) (antidiagonal n)) n\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Icc_eq_empty", "start": [358, 1], "end": [359, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.empty_div", "start": [655, 1], "end": [656, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/AffineMap.lean", "full_name": "AffineMap.hasDerivWithinAt_lineMap", "start": [70, 1], "end": [71, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.toFinsupp_add", "start": [210, 1], "end": [213, 23], "traced_tactics": [{"tactic": "cases a", "annotated_tactic": ["cases a", []], "state_before": "R : Type u\na\u271d b\u271d : R\nm n : \u2115\ninst\u271d : Semiring R\np q a b : R[X]\n\u22a2 (a + b).toFinsupp = a.toFinsupp + b.toFinsupp", "state_after": "case ofFinsupp\nR : Type u\na b\u271d : R\nm n : \u2115\ninst\u271d : Semiring R\np q b : R[X]\ntoFinsupp\u271d : R[\u2115]\n\u22a2 ({ toFinsupp := toFinsupp\u271d } + b).toFinsupp = { toFinsupp := toFinsupp\u271d }.toFinsupp + b.toFinsupp"}, {"tactic": "cases b", "annotated_tactic": ["cases b", []], "state_before": "case ofFinsupp\nR : Type u\na b\u271d : R\nm n : \u2115\ninst\u271d : Semiring R\np q b : R[X]\ntoFinsupp\u271d : R[\u2115]\n\u22a2 ({ toFinsupp := toFinsupp\u271d } + b).toFinsupp = { toFinsupp := toFinsupp\u271d }.toFinsupp + b.toFinsupp", "state_after": "case ofFinsupp.ofFinsupp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\ntoFinsupp\u271d\u00b9 toFinsupp\u271d : R[\u2115]\n\u22a2 ({ toFinsupp := toFinsupp\u271d\u00b9 } + { toFinsupp := toFinsupp\u271d }).toFinsupp =\n    { toFinsupp := toFinsupp\u271d\u00b9 }.toFinsupp + { toFinsupp := toFinsupp\u271d }.toFinsupp"}, {"tactic": "rw [\u2190 ofFinsupp_add]", "annotated_tactic": ["rw [\u2190 <a>ofFinsupp_add</a>]", [{"full_name": "Polynomial.ofFinsupp_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [165, 9], "def_end_pos": [165, 22]}]], "state_before": "case ofFinsupp.ofFinsupp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\ntoFinsupp\u271d\u00b9 toFinsupp\u271d : R[\u2115]\n\u22a2 ({ toFinsupp := toFinsupp\u271d\u00b9 } + { toFinsupp := toFinsupp\u271d }).toFinsupp =\n    { toFinsupp := toFinsupp\u271d\u00b9 }.toFinsupp + { toFinsupp := toFinsupp\u271d }.toFinsupp", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/Bilinear.lean", "full_name": "ContinuousLinearMap.norm_precompR_le", "start": [367, 1], "end": [375, 31], "traced_tactics": [{"tactic": "rw [one_mul]", "annotated_tactic": ["rw [<a>one_mul</a>]", [{"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2079 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2078 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c E\ninst\u271d\u2079 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2077 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u2075 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b3 : FunLike \ud835\udcd5 E F\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2081\u2083\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nL : E \u2192L[\ud835\udd5c] F\u2097 \u2192L[\ud835\udd5c] G\u2097\n\u22a2 1 * \u2016L\u2016 = \u2016L\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "antitoneOn_const", "start": [571, 1], "end": [573, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "tsub_lt_tsub_iff_right", "start": [478, 1], "end": [479, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.op_smul_finset_subset_mul", "start": [1961, 1], "end": [1962, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/Order.lean", "full_name": "Int.eq_nat_or_neg", "start": [481, 1], "end": [481, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Index.lean", "full_name": "Subgroup.index_eq_card", "start": [355, 1], "end": [356, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.preimage_Ico", "start": [394, 1], "end": [396, 26], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na b : \u03b1\n\u22a2 Nat.cast \u207b\u00b9' Ico a b = Ico \u2308a\u2309\u208a \u2308b\u2309\u208a", "state_after": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na b : \u03b1\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ico a b \u2194 x\u271d \u2208 Ico \u2308a\u2309\u208a \u2308b\u2309\u208a"}, {"tactic": "simp [ceil_le, lt_ceil]", "annotated_tactic": ["simp [<a>ceil_le</a>, <a>lt_ceil</a>]", [{"full_name": "Nat.ceil_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [280, 9], "def_end_pos": [280, 16]}, {"full_name": "Nat.lt_ceil", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [284, 9], "def_end_pos": [284, 16]}]], "state_before": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na b : \u03b1\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ico a b \u2194 x\u271d \u2208 Ico \u2308a\u2309\u208a \u2308b\u2309\u208a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean", "full_name": "abs_real_inner_div_norm_mul_norm_eq_one_of_ne_zero_of_ne_zero_mul", "start": [1557, 1], "end": [1559, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "full_name": "Equiv.Perm.card_cycleType_pos", "start": [91, 1], "end": [92, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Basic.lean", "full_name": "Complex.ofReal_injective", "start": [114, 1], "end": [114, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Tendsto.eventually_gt_atTop", "start": [210, 11], "end": [212, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.bot_lt_succ", "start": [554, 1], "end": [555, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.mem_iSup", "start": [770, 1], "end": [773, 40], "traced_tactics": [{"tactic": "rw [\u2190 span_singleton_le_iff_mem, le_iSup_iff]", "annotated_tactic": ["rw [\u2190 <a>span_singleton_le_iff_mem</a>, <a>le_iSup_iff</a>]", [{"full_name": "Submodule.span_singleton_le_iff_mem", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [611, 9], "def_end_pos": [611, 34]}, {"full_name": "le_iSup_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [110, 9], "def_end_pos": [110, 20]}]], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx : M\np\u271d p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\n\u03b9 : Sort u_9\np : \u03b9 \u2192 Submodule R M\nm : M\n\u22a2 m \u2208 \u2a06 i, p i \u2194 \u2200 (N : Submodule R M), (\u2200 (i : \u03b9), p i \u2264 N) \u2192 m \u2208 N", "state_after": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx : M\np\u271d p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\n\u03b9 : Sort u_9\np : \u03b9 \u2192 Submodule R M\nm : M\n\u22a2 (\u2200 (b : Submodule R M), (\u2200 (i : \u03b9), p i \u2264 b) \u2192 span R {m} \u2264 b) \u2194 \u2200 (N : Submodule R M), (\u2200 (i : \u03b9), p i \u2264 N) \u2192 m \u2208 N"}, {"tactic": "simp only [span_singleton_le_iff_mem]", "annotated_tactic": ["simp only [<a>span_singleton_le_iff_mem</a>]", [{"full_name": "Submodule.span_singleton_le_iff_mem", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [611, 9], "def_end_pos": [611, 34]}]], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx : M\np\u271d p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\n\u03b9 : Sort u_9\np : \u03b9 \u2192 Submodule R M\nm : M\n\u22a2 (\u2200 (b : Submodule R M), (\u2200 (i : \u03b9), p i \u2264 b) \u2192 span R {m} \u2264 b) \u2194 \u2200 (N : Submodule R M), (\u2200 (i : \u03b9), p i \u2264 N) \u2192 m \u2208 N", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Isometry.lean", "full_name": "rotation_apply", "start": [50, 1], "end": [51, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/QuadraticReciprocity.lean", "full_name": "ZMod.exists_sq_eq_prime_iff_of_mod_four_eq_three", "start": [183, 1], "end": [186, 59], "traced_tactics": [{"tactic": "rw [\u2190 eq_one_iff' p (prime_ne_zero p q hpq), \u2190 eq_neg_one_iff' q,\n  quadratic_reciprocity_three_mod_four hp3 hq3, neg_inj]", "annotated_tactic": ["rw [\u2190 <a>eq_one_iff'</a> p (<a>prime_ne_zero</a> p q hpq), \u2190 <a>eq_neg_one_iff'</a> q,\n    <a>quadratic_reciprocity_three_mod_four</a> hp3 hq3, <a>neg_inj</a>]", [{"full_name": "legendreSym.eq_one_iff'", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/Basic.lean", "def_pos": [193, 9], "def_end_pos": [193, 20]}, {"full_name": "ZMod.prime_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [1164, 9], "def_end_pos": [1164, 22]}, {"full_name": "legendreSym.eq_neg_one_iff'", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/Basic.lean", "def_pos": [202, 9], "def_end_pos": [202, 24]}, {"full_name": "legendreSym.quadratic_reciprocity_three_mod_four", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticReciprocity.lean", "def_pos": [158, 9], "def_end_pos": [158, 45]}, {"full_name": "neg_inj", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [324, 3], "def_end_pos": [324, 14]}]], "state_before": "p q : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : Fact (Nat.Prime q)\nhp3 : p % 4 = 3\nhq3 : q % 4 = 3\nhpq : p \u2260 q\n\u22a2 IsSquare \u2191q \u2194 \u00acIsSquare \u2191p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Fold.lean", "full_name": "Multiset.max_le_of_forall_le", "start": [127, 1], "end": [130, 45], "traced_tactics": [{"tactic": "induction l using Quotient.inductionOn", "annotated_tactic": ["induction l using <a>Quotient.inductionOn</a>", [{"full_name": "Quotient.inductionOn", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1617, 19], "def_end_pos": [1617, 30]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\ninst\u271d : CanonicallyLinearOrderedAddCommMonoid \u03b1\nl : Multiset \u03b1\nn : \u03b1\nh : \u2200 x \u2208 l, x \u2264 n\n\u22a2 fold max \u22a5 l \u2264 n", "state_after": "case h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\ninst\u271d : CanonicallyLinearOrderedAddCommMonoid \u03b1\nn : \u03b1\na\u271d : List \u03b1\nh : \u2200 x \u2208 \u27e6a\u271d\u27e7, x \u2264 n\n\u22a2 fold max \u22a5 \u27e6a\u271d\u27e7 \u2264 n"}, {"tactic": "simpa using List.max_le_of_forall_le _ _ h", "annotated_tactic": ["simpa using <a>List.max_le_of_forall_le</a> _ _ h", [{"full_name": "List.max_le_of_forall_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/MinMax.lean", "def_pos": [505, 9], "def_end_pos": [505, 28]}]], "state_before": "case h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\ninst\u271d : CanonicallyLinearOrderedAddCommMonoid \u03b1\nn : \u03b1\na\u271d : List \u03b1\nh : \u2200 x \u2208 \u27e6a\u271d\u27e7, x \u2264 n\n\u22a2 fold max \u22a5 \u27e6a\u271d\u27e7 \u2264 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.preimage_Ioo", "start": [386, 1], "end": [389, 31], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na b : \u03b1\nha : 0 \u2264 a\n\u22a2 Nat.cast \u207b\u00b9' Ioo a b = Ioo \u230aa\u230b\u208a \u2308b\u2309\u208a", "state_after": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na b : \u03b1\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ioo a b \u2194 x\u271d \u2208 Ioo \u230aa\u230b\u208a \u2308b\u2309\u208a"}, {"tactic": "simp [floor_lt, lt_ceil, ha]", "annotated_tactic": ["simp [<a>floor_lt</a>, <a>lt_ceil</a>, ha]", [{"full_name": "Nat.floor_lt", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [140, 9], "def_end_pos": [140, 17]}, {"full_name": "Nat.lt_ceil", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [284, 9], "def_end_pos": [284, 16]}]], "state_before": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na b : \u03b1\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ioo a b \u2194 x\u271d \u2208 Ioo \u230aa\u230b\u208a \u2308b\u2309\u208a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.countP_True", "start": [2352, 1], "end": [2353, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.cantor_injective", "start": [291, 1], "end": [293, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "Pi.symmDiff_def", "start": [848, 1], "end": [850, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/SelfAdjoint.lean", "full_name": "skewAdjoint.smul_mem", "start": [546, 1], "end": [548, 66], "traced_tactics": [{"tactic": "rw [mem_iff, star_smul, star_trivial, mem_iff.mp h, smul_neg r]", "annotated_tactic": ["rw [<a>mem_iff</a>, <a>star_smul</a>, <a>star_trivial</a>, mem_iff.mp h, <a>smul_neg</a> r]", [{"full_name": "skewAdjoint.mem_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Star/SelfAdjoint.lean", "def_pos": [497, 9], "def_end_pos": [497, 16]}, {"full_name": "StarModule.star_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Star/Basic.lean", "def_pos": [500, 3], "def_end_pos": [500, 12]}, {"full_name": "TrivialStar.star_trivial", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Star/Basic.lean", "def_pos": [127, 3], "def_end_pos": [127, 15]}, {"full_name": "smul_neg", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [1020, 9], "def_end_pos": [1020, 17]}]], "state_before": "R : Type u_1\nA : Type u_2\ninst\u271d\u2076 : Star R\ninst\u271d\u2075 : TrivialStar R\ninst\u271d\u2074 : AddCommGroup A\ninst\u271d\u00b3 : StarAddMonoid A\ninst\u271d\u00b2 : Monoid R\ninst\u271d\u00b9 : DistribMulAction R A\ninst\u271d : StarModule R A\nr : R\nx : A\nh : x \u2208 skewAdjoint A\n\u22a2 r \u2022 x \u2208 skewAdjoint A", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Lattice.lean", "full_name": "Multiset.sup_ndunion", "start": [79, 1], "end": [80, 58], "traced_tactics": [{"tactic": "rw [\u2190 sup_dedup, dedup_ext.2, sup_dedup, sup_add]", "annotated_tactic": ["rw [\u2190 <a>sup_dedup</a>, <a>dedup_ext</a>.2, <a>sup_dedup</a>, <a>sup_add</a>]", [{"full_name": "Multiset.sup_dedup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Lattice.lean", "def_pos": [74, 9], "def_end_pos": [74, 18]}, {"full_name": "Multiset.dedup_ext", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Dedup.lean", "def_pos": [126, 9], "def_end_pos": [126, 18]}, {"full_name": "Multiset.sup_dedup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Lattice.lean", "def_pos": [74, 9], "def_end_pos": [74, 18]}, {"full_name": "Multiset.sup_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Lattice.lean", "def_pos": [53, 9], "def_end_pos": [53, 16]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 sup (ndunion s\u2081 s\u2082) = sup s\u2081 \u2294 sup s\u2082", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 ndunion s\u2081 s\u2082 \u2194 a \u2208 s\u2081 + s\u2082"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 ndunion s\u2081 s\u2082 \u2194 a \u2208 s\u2081 + s\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.mem_permutations_of_perm_lemma", "start": [685, 1], "end": [687, 78], "traced_tactics": [{"tactic": "simpa [permutations, perm_nil] using H", "annotated_tactic": ["simpa [<a>permutations</a>, <a>perm_nil</a>] using H", [{"full_name": "List.permutations", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [245, 5], "def_end_pos": [245, 17]}, {"full_name": "List.perm_nil", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [119, 17], "def_end_pos": [119, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 : List \u03b1\na : \u03b1\nis l : List \u03b1\nH : l ~ [] ++ is \u2192 (\u2203 ts', \u2203 (_ : ts' ~ []), l = ts' ++ is) \u2228 l \u2208 permutationsAux is []\n\u22a2 l ~ is \u2192 l \u2208 permutations is", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Equiv.lean", "full_name": "UniformEquiv.toEquiv_injective", "start": [51, 1], "end": [52, 63], "traced_tactics": [{"tactic": "simpa only [mk.injEq]", "annotated_tactic": ["simpa only [mk.injEq]", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b3\ninst\u271d : UniformSpace \u03b4\ne : \u03b1 \u2243 \u03b2\nh\u2081 : UniformContinuous e.toFun\nh\u2082 : UniformContinuous e.invFun\ne' : \u03b1 \u2243 \u03b2\nh\u2081' : UniformContinuous e'.toFun\nh\u2082' : UniformContinuous e'.invFun\nh :\n  { toEquiv := e, uniformContinuous_toFun := h\u2081, uniformContinuous_invFun := h\u2082 }.toEquiv =\n    { toEquiv := e', uniformContinuous_toFun := h\u2081', uniformContinuous_invFun := h\u2082' }.toEquiv\n\u22a2 { toEquiv := e, uniformContinuous_toFun := h\u2081, uniformContinuous_invFun := h\u2082 } =\n    { toEquiv := e', uniformContinuous_toFun := h\u2081', uniformContinuous_invFun := h\u2082' }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.liminf_le_liminf_of_le", "start": [645, 1], "end": [650, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Chain.lean", "full_name": "List.chain'_split", "start": [214, 1], "end": [217, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "tendsto_of_tendsto_of_tendsto_of_le_of_le", "start": [163, 1], "end": [167, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "associated_zero_iff_eq_zero", "start": [444, 1], "end": [449, 35], "traced_tactics": [{"tactic": "let \u27e8u, h\u27e9 := h.symm", "annotated_tactic": ["let \u27e8u, h\u27e9 := h.symm", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : MonoidWithZero \u03b1\na : \u03b1\nh : a ~\u1d64 0\n\u22a2 a = 0", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : MonoidWithZero \u03b1\na : \u03b1\nh\u271d : a ~\u1d64 0\nu : \u03b1\u02e3\nh : 0 * \u2191u = a\n\u22a2 a = 0"}, {"tactic": "simpa using h.symm", "annotated_tactic": ["simpa using h.symm", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : MonoidWithZero \u03b1\na : \u03b1\nh\u271d : a ~\u1d64 0\nu : \u03b1\u02e3\nh : 0 * \u2191u = a\n\u22a2 a = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/NNRat/Defs.lean", "full_name": "NNRat.coe_zero", "start": [115, 1], "end": [116, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Nat.bit1_mod_bit0", "start": [278, 1], "end": [284, 43], "traced_tactics": [{"tactic": "have h\u2081 := congr_arg bit1 (Nat.div_add_mod n m)", "annotated_tactic": ["have h\u2081 := <a>congr_arg</a> <a>bit1</a> (<a>Nat.div_add_mod</a> n m)", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "bit1", "def_path": ".lake/packages/mathlib/Mathlib/Init/ZeroOne.lean", "def_pos": [39, 34], "def_end_pos": [39, 38]}, {"full_name": "Nat.div_add_mod", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [167, 9], "def_end_pos": [167, 20]}]], "state_before": "m n : \u2115\n\u22a2 bit1 n % bit0 m = bit1 (n % m)", "state_after": "m n : \u2115\nh\u2081 : bit1 (m * (n / m) + n % m) = bit1 n\n\u22a2 bit1 n % bit0 m = bit1 (n % m)"}, {"tactic": "rw [bit1_add, bit0_eq_two_mul, \u2190 mul_assoc, \u2190 bit0_eq_two_mul] at h\u2081", "annotated_tactic": ["rw [<a>bit1_add</a>, <a>bit0_eq_two_mul</a>, \u2190 <a>mul_assoc</a>, \u2190 <a>bit0_eq_two_mul</a>] at h\u2081", [{"full_name": "bit1_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [196, 9], "def_end_pos": [196, 17]}, {"full_name": "bit0_eq_two_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [185, 9], "def_end_pos": [185, 24]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "bit0_eq_two_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [185, 9], "def_end_pos": [185, 24]}]], "state_before": "m n : \u2115\nh\u2081 : bit1 (m * (n / m) + n % m) = bit1 n\n\u22a2 bit1 n % bit0 m = bit1 (n % m)", "state_after": "m n : \u2115\nh\u2081 : bit0 m * (n / m) + bit1 (n % m) = bit1 n\n\u22a2 bit1 n % bit0 m = bit1 (n % m)"}, {"tactic": "have h\u2082 := Nat.div_add_mod (bit1 n) (bit0 m)", "annotated_tactic": ["have h\u2082 := <a>Nat.div_add_mod</a> (<a>bit1</a> n) (<a>bit0</a> m)", [{"full_name": "Nat.div_add_mod", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [167, 9], "def_end_pos": [167, 20]}, {"full_name": "bit1", "def_path": ".lake/packages/mathlib/Mathlib/Init/ZeroOne.lean", "def_pos": [39, 34], "def_end_pos": [39, 38]}, {"full_name": "bit0", "def_path": ".lake/packages/mathlib/Mathlib/Init/ZeroOne.lean", "def_pos": [36, 34], "def_end_pos": [36, 38]}]], "state_before": "m n : \u2115\nh\u2081 : bit0 m * (n / m) + bit1 (n % m) = bit1 n\n\u22a2 bit1 n % bit0 m = bit1 (n % m)", "state_after": "m n : \u2115\nh\u2081 : bit0 m * (n / m) + bit1 (n % m) = bit1 n\nh\u2082 : bit0 m * (bit1 n / bit0 m) + bit1 n % bit0 m = bit1 n\n\u22a2 bit1 n % bit0 m = bit1 (n % m)"}, {"tactic": "rw [bit1_div_bit0] at h\u2082", "annotated_tactic": ["rw [<a>bit1_div_bit0</a>] at h\u2082", [{"full_name": "Nat.bit1_div_bit0", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Parity.lean", "def_pos": [268, 9], "def_end_pos": [268, 22]}]], "state_before": "m n : \u2115\nh\u2081 : bit0 m * (n / m) + bit1 (n % m) = bit1 n\nh\u2082 : bit0 m * (bit1 n / bit0 m) + bit1 n % bit0 m = bit1 n\n\u22a2 bit1 n % bit0 m = bit1 (n % m)", "state_after": "m n : \u2115\nh\u2081 : bit0 m * (n / m) + bit1 (n % m) = bit1 n\nh\u2082 : bit0 m * (n / m) + bit1 n % bit0 m = bit1 n\n\u22a2 bit1 n % bit0 m = bit1 (n % m)"}, {"tactic": "exact add_left_cancel (h\u2082.trans h\u2081.symm)", "annotated_tactic": ["exact <a>add_left_cancel</a> (h\u2082.trans h\u2081.symm)", [{"full_name": "add_left_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [227, 3], "def_end_pos": [227, 14]}]], "state_before": "m n : \u2115\nh\u2081 : bit0 m * (n / m) + bit1 (n % m) = bit1 n\nh\u2082 : bit0 m * (n / m) + bit1 n % bit0 m = bit1 n\n\u22a2 bit1 n % bit0 m = bit1 (n % m)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/ENat.lean", "full_name": "Cardinal.toENat_nat", "start": [241, 1], "end": [241, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "full_name": "Matrix.cramer_transpose_apply", "start": [102, 1], "end": [103, 59], "traced_tactics": [{"tactic": "rw [cramer_apply, updateColumn_transpose, det_transpose]", "annotated_tactic": ["rw [<a>cramer_apply</a>, <a>updateColumn_transpose</a>, <a>det_transpose</a>]", [{"full_name": "Matrix.cramer_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "def_pos": [98, 9], "def_end_pos": [98, 21]}, {"full_name": "Matrix.updateColumn_transpose", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/RowCol.lean", "def_pos": [248, 9], "def_end_pos": [248, 31]}, {"full_name": "Matrix.det_transpose", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [228, 9], "def_end_pos": [228, 22]}]], "state_before": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni : n\n\u22a2 (cramer A\u1d40) b i = det (updateRow A i b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Option.lean", "full_name": "Equiv.removeNone_optionCongr", "start": [160, 1], "end": [161, 100], "traced_tactics": [{"tactic": "simp [EquivFunctor.map]", "annotated_tactic": ["simp [<a>EquivFunctor.map</a>]", [{"full_name": "EquivFunctor.map", "def_path": ".lake/packages/mathlib/Mathlib/Control/EquivFunctor.lean", "def_pos": [33, 3], "def_end_pos": [33, 6]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne\u271d : Option \u03b1 \u2243 Option \u03b2\ne : \u03b1 \u2243 \u03b2\nx : \u03b1\n\u22a2 (optionCongr e) (some x) = some (e x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finite/Card.lean", "full_name": "Finite.card_eq_zero_of_embedding", "start": [162, 1], "end": [163, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.IsLimit.one_lt", "start": [290, 1], "end": [291, 43], "traced_tactics": [{"tactic": "simpa only [succ_zero] using h.2 _ h.pos", "annotated_tactic": ["simpa only [<a>succ_zero</a>] using h.2 _ h.pos", [{"full_name": "Ordinal.succ_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1052, 9], "def_end_pos": [1052, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\no : Ordinal.{u_4}\nh : IsLimit o\n\u22a2 1 < o", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pointwise.lean", "full_name": "Filter.map_one", "start": [172, 11], "end": [173, 42], "traced_tactics": [{"tactic": "rw [Filter.map_one', map_one, pure_one]", "annotated_tactic": ["rw [<a>Filter.map_one'</a>, <a>map_one</a>, <a>pure_one</a>]", [{"full_name": "Filter.map_one'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Pointwise.lean", "def_pos": [114, 19], "def_end_pos": [114, 27]}, {"full_name": "map_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [203, 9], "def_end_pos": [203, 16]}, {"full_name": "Filter.pure_one", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Pointwise.lean", "def_pos": [94, 9], "def_end_pos": [94, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\n\u03b5 : Type u_6\ninst\u271d\u00b3 : One \u03b1\nf : Filter \u03b1\ns : Set \u03b1\ninst\u271d\u00b2 : One \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : OneHomClass F \u03b1 \u03b2\n\u03c6 : F\n\u22a2 map (\u21d1\u03c6) 1 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "full_name": "PartialEquiv.ofSet_coe", "start": [667, 1], "end": [668, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "full_name": "FreeMonoid.lift_apply", "start": [245, 1], "end": [246, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finite/Card.lean", "full_name": "Finite.card_eq", "start": [72, 1], "end": [75, 56], "traced_tactics": [{"tactic": "haveI := Fintype.ofFinite \u03b1", "annotated_tactic": ["haveI := <a>Fintype.ofFinite</a> \u03b1", [{"full_name": "Fintype.ofFinite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [448, 19], "def_end_pos": [448, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)"}, {"tactic": "haveI := Fintype.ofFinite \u03b2", "annotated_tactic": ["haveI := <a>Fintype.ofFinite</a> \u03b2", [{"full_name": "Fintype.ofFinite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [448, 19], "def_end_pos": [448, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)"}, {"tactic": "simp only [Nat.card_eq_fintype_card, Fintype.card_eq]", "annotated_tactic": ["simp only [<a>Nat.card_eq_fintype_card</a>, <a>Fintype.card_eq</a>]", [{"full_name": "Nat.card_eq_fintype_card", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Finite.lean", "def_pos": [41, 9], "def_end_pos": [41, 29]}, {"full_name": "Fintype.card_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [205, 9], "def_end_pos": [205, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/PartialHomeomorph.lean", "full_name": "PartialHomeomorph.IsImage.of_symm_image_eq", "start": [602, 1], "end": [603, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Functor/EpiMono.lean", "full_name": "CategoryTheory.Functor.preservesEpimorphisms.iso_iff", "start": [142, 1], "end": [144, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/Compact.lean", "full_name": "finite_cover_nhds_interior", "start": [824, 1], "end": [828, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.lintegral_ofReal_le_lintegral_nnnorm", "start": [324, 1], "end": [329, 26], "traced_tactics": [{"tactic": "simp_rw [\u2190 ofReal_norm_eq_coe_nnnorm]", "annotated_tactic": ["simp_rw [\u2190 <a>ofReal_norm_eq_coe_nnnorm</a>]", [{"full_name": "ofReal_norm_eq_coe_nnnorm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [1068, 15], "def_end_pos": [1068, 40]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\n\u22a2 \u222b\u207b (x : \u03b1), ENNReal.ofReal (f x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), \u2191\u2016f x\u2016\u208a \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\n\u22a2 \u222b\u207b (x : \u03b1), ENNReal.ofReal (f x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), ENNReal.ofReal \u2016f x\u2016 \u2202\u03bc"}, {"tactic": "refine' lintegral_mono fun x => ENNReal.ofReal_le_ofReal _", "annotated_tactic": ["refine' <a>lintegral_mono</a> fun x => <a>ENNReal.ofReal_le_ofReal</a> _", [{"full_name": "MeasureTheory.lintegral_mono", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [101, 9], "def_end_pos": [101, 23]}, {"full_name": "ENNReal.ofReal_le_ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [179, 9], "def_end_pos": [179, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\n\u22a2 \u222b\u207b (x : \u03b1), ENNReal.ofReal (f x) \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1), ENNReal.ofReal \u2016f x\u2016 \u2202\u03bc", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx : \u03b1\n\u22a2 f x \u2264 \u2016f x\u2016"}, {"tactic": "rw [Real.norm_eq_abs]", "annotated_tactic": ["rw [<a>Real.norm_eq_abs</a>]", [{"full_name": "Real.norm_eq_abs", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [1837, 9], "def_end_pos": [1837, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx : \u03b1\n\u22a2 f x \u2264 \u2016f x\u2016", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx : \u03b1\n\u22a2 f x \u2264 |f x|"}, {"tactic": "exact le_abs_self (f x)", "annotated_tactic": ["exact <a>le_abs_self</a> (f x)", [{"full_name": "le_abs_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [72, 3], "def_end_pos": [72, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nx : \u03b1\n\u22a2 f x \u2264 |f x|", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/CompactOpen.lean", "full_name": "ContinuousMap.continuous_of_continuous_uncurry", "start": [355, 1], "end": [357, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.trans_toLinearMap", "start": [619, 1], "end": [621, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Hom/Monoid.lean", "full_name": "OrderMonoidWithZeroHom.coe_mk", "start": [563, 1], "end": [564, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Maps.lean", "full_name": "ClosedEmbedding.closure_image_eq", "start": [690, 1], "end": [692, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "Antitone.map_sup_le", "start": [1173, 1], "end": [1175, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/FiniteDimension.lean", "full_name": "LinearMap.continuous_of_isClosed_ker", "start": [131, 1], "end": [172, 35], "traced_tactics": [{"tactic": "by_cases H : finrank \ud835\udd5c (LinearMap.range l) = 0", "annotated_tactic": ["by_cases H : <a>finrank</a> \ud835\udd5c (<a>LinearMap.range</a> l) = 0", [{"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}, {"full_name": "LinearMap.range", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [132, 5], "def_end_pos": [132, 10]}]], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\n\u22a2 Continuous \u21d1l", "state_after": "case pos\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : finrank \ud835\udd5c \u21a5(range l) = 0\n\u22a2 Continuous \u21d1l\n\ncase neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\n\u22a2 Continuous \u21d1l"}, {"tactic": "rw [Submodule.finrank_eq_zero, LinearMap.range_eq_bot] at H", "annotated_tactic": ["rw [<a>Submodule.finrank_eq_zero</a>, <a>LinearMap.range_eq_bot</a>] at H", [{"full_name": "Submodule.finrank_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finite.lean", "def_pos": [433, 9], "def_end_pos": [433, 34]}, {"full_name": "LinearMap.range_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [309, 9], "def_end_pos": [309, 21]}]], "state_before": "case pos\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : finrank \ud835\udd5c \u21a5(range l) = 0\n\u22a2 Continuous \u21d1l", "state_after": "case pos\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : l = 0\n\u22a2 Continuous \u21d1l"}, {"tactic": "rw [H]", "annotated_tactic": ["rw [H]", []], "state_before": "case pos\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : l = 0\n\u22a2 Continuous \u21d1l", "state_after": "case pos\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : l = 0\n\u22a2 Continuous \u21d10"}, {"tactic": "exact continuous_zero", "annotated_tactic": ["exact <a>continuous_zero</a>", [{"full_name": "continuous_zero", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Monoid.lean", "def_pos": [33, 3], "def_end_pos": [33, 14]}]], "state_before": "case pos\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : l = 0\n\u22a2 Continuous \u21d10", "state_after": "no goals"}, {"tactic": "have : finrank \ud835\udd5c (LinearMap.range l) = 1 :=\n  le_antisymm (finrank_self \ud835\udd5c \u25b8 l.range.finrank_le) (zero_lt_iff.mpr H)", "annotated_tactic": ["have : <a>finrank</a> \ud835\udd5c (<a>LinearMap.range</a> l) = 1 :=\n      <a>le_antisymm</a> (<a>finrank_self</a> \ud835\udd5c \u25b8 l.range.finrank_le) (zero_lt_iff.mpr H)", [{"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}, {"full_name": "LinearMap.range", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [132, 5], "def_end_pos": [132, 10]}, {"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "FiniteDimensional.finrank_self", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "def_pos": [449, 9], "def_end_pos": [449, 39]}]], "state_before": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\n\u22a2 Continuous \u21d1l", "state_after": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\n\u22a2 Continuous \u21d1l"}, {"tactic": "have hi : Function.Injective ((LinearMap.ker l).liftQ l (le_refl _)) := by\n  rw [\u2190 LinearMap.ker_eq_bot]\n  exact Submodule.ker_liftQ_eq_bot _ _ _ (le_refl _)", "annotated_tactic": ["have hi : <a>Function.Injective</a> ((<a>LinearMap.ker</a> l).<a>liftQ</a> l (<a>le_refl</a> _)) := by\n      rw [\u2190 <a>LinearMap.ker_eq_bot</a>]\n      exact <a>Submodule.ker_liftQ_eq_bot</a> _ _ _ (<a>le_refl</a> _)", [{"full_name": "Function.Injective", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [116, 5], "def_end_pos": [116, 14]}, {"full_name": "LinearMap.ker", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [60, 5], "def_end_pos": [60, 8]}, {"full_name": "Submodule.liftQ", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [353, 5], "def_end_pos": [353, 10]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}, {"full_name": "LinearMap.ker_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [210, 9], "def_end_pos": [210, 19]}, {"full_name": "Submodule.ker_liftQ_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [484, 9], "def_end_pos": [484, 25]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\n\u22a2 Continuous \u21d1l", "state_after": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u22a2 Continuous \u21d1l"}, {"tactic": "have hs : Function.Surjective ((LinearMap.ker l).liftQ l (le_refl _)) := by\n  rw [\u2190 LinearMap.range_eq_top, Submodule.range_liftQ]\n  exact Submodule.eq_top_of_finrank_eq ((finrank_self \ud835\udd5c).symm \u25b8 this)", "annotated_tactic": ["have hs : <a>Function.Surjective</a> ((<a>LinearMap.ker</a> l).<a>liftQ</a> l (<a>le_refl</a> _)) := by\n      rw [\u2190 <a>LinearMap.range_eq_top</a>, <a>Submodule.range_liftQ</a>]\n      exact <a>Submodule.eq_top_of_finrank_eq</a> ((<a>finrank_self</a> \ud835\udd5c).<a>symm</a> \u25b8 this)", [{"full_name": "Function.Surjective", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [126, 5], "def_end_pos": [126, 15]}, {"full_name": "LinearMap.ker", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [60, 5], "def_end_pos": [60, 8]}, {"full_name": "Submodule.liftQ", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [353, 5], "def_end_pos": [353, 10]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}, {"full_name": "LinearMap.range_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [174, 9], "def_end_pos": [174, 21]}, {"full_name": "Submodule.range_liftQ", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [480, 9], "def_end_pos": [480, 20]}, {"full_name": "Submodule.eq_top_of_finrank_eq", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FiniteDimensional.lean", "def_pos": [225, 9], "def_end_pos": [225, 46]}, {"full_name": "FiniteDimensional.finrank_self", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "def_pos": [449, 9], "def_end_pos": [449, 39]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u22a2 Continuous \u21d1l", "state_after": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u22a2 Continuous \u21d1l"}, {"tactic": "let \u03c6 : (E \u29f8 LinearMap.ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c :=\n  LinearEquiv.ofBijective ((LinearMap.ker l).liftQ l (le_refl _)) \u27e8hi, hs\u27e9", "annotated_tactic": ["let \u03c6 : (E \u29f8 <a>LinearMap.ker</a> l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c :=\n      <a>LinearEquiv.ofBijective</a> ((<a>LinearMap.ker</a> l).<a>liftQ</a> l (<a>le_refl</a> _)) \u27e8hi, hs\u27e9", [{"full_name": "LinearMap.ker", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [60, 5], "def_end_pos": [60, 8]}, {"full_name": "LinearEquiv.ofBijective", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [868, 19], "def_end_pos": [868, 30]}, {"full_name": "LinearMap.ker", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [60, 5], "def_end_pos": [60, 8]}, {"full_name": "Submodule.liftQ", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [353, 5], "def_end_pos": [353, 10]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u22a2 Continuous \u21d1l", "state_after": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\n\u22a2 Continuous \u21d1l"}, {"tactic": "have hl\u03c6 : (l : E \u2192 \ud835\udd5c) = \u03c6 \u2218 (LinearMap.ker l).mkQ := by ext; rfl", "annotated_tactic": ["have hl\u03c6 : (l : E \u2192 \ud835\udd5c) = \u03c6 \u2218 (<a>LinearMap.ker</a> l).<a>mkQ</a> := by ext; rfl", [{"full_name": "LinearMap.ker", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [60, 5], "def_end_pos": [60, 8]}, {"full_name": "Submodule.mkQ", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [323, 5], "def_end_pos": [323, 8]}]], "state_before": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\n\u22a2 Continuous \u21d1l", "state_after": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\n\u22a2 Continuous \u21d1l"}, {"tactic": "suffices Continuous \u03c6.toEquiv by\n  rw [hl\u03c6]\n  exact this.comp continuous_quot_mk", "annotated_tactic": ["suffices <a>Continuous</a> \u03c6.toEquiv by\n      rw [hl\u03c6]\n      exact this.comp <a>continuous_quot_mk</a>", [{"full_name": "Continuous", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [137, 11], "def_end_pos": [137, 21]}, {"full_name": "continuous_quot_mk", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [1232, 9], "def_end_pos": [1232, 27]}]], "state_before": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\n\u22a2 Continuous \u21d1l", "state_after": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\n\u22a2 Continuous \u21d1(LinearEquiv.toEquiv \u03c6)"}, {"tactic": "have : induced \u03c6.toEquiv.symm inferInstance = hnorm.toUniformSpace.toTopologicalSpace := by\n  refine' unique_topology_of_t2 (topologicalAddGroup_induced \u03c6.symm.toLinearMap)\n    (continuousSMul_induced \u03c6.symm.toLinearMap) _\n  refine (@t2Space_iff \ud835\udd5c (induced (\u2191(LinearEquiv.toEquiv \u03c6).symm) inferInstance)).mpr ?_\n  exact fun x y hxy =>\n    @separated_by_continuous _ _ (induced _ _) _ _ _ continuous_induced_dom _ _\n      (\u03c6.toEquiv.symm.injective.ne hxy)", "annotated_tactic": ["have : <a>induced</a> \u03c6.toEquiv.symm <a>inferInstance</a> = hnorm.toUniformSpace.toTopologicalSpace := by\n      refine' <a>unique_topology_of_t2</a> (<a>topologicalAddGroup_induced</a> \u03c6.symm.toLinearMap)\n        (<a>continuousSMul_induced</a> \u03c6.symm.toLinearMap) _\n      -- Porting note: was `rw [t2Space_iff]`\n      refine (@<a>t2Space_iff</a> \ud835\udd5c (<a>induced</a> (\u2191(<a>LinearEquiv.toEquiv</a> \u03c6).<a>symm</a>) <a>inferInstance</a>)).<a>mpr</a> ?_\n      exact fun x y hxy =>\n        @<a>separated_by_continuous</a> _ _ (<a>induced</a> _ _) _ _ _ <a>continuous_induced_dom</a> _ _\n          (\u03c6.toEquiv.symm.injective.ne hxy)", [{"full_name": "TopologicalSpace.induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Induced.lean", "def_pos": [54, 5], "def_end_pos": [54, 12]}, {"full_name": "inferInstance", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [99, 8], "def_end_pos": [99, 21]}, {"full_name": "unique_topology_of_t2", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/FiniteDimension.lean", "def_pos": [76, 9], "def_end_pos": [76, 30]}, {"full_name": "topologicalAddGroup_induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [684, 3], "def_end_pos": [684, 14]}, {"full_name": "continuousSMul_induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [105, 9], "def_end_pos": [105, 31]}, {"full_name": "t2Space_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [1208, 3], "def_end_pos": [1208, 9]}, {"full_name": "TopologicalSpace.induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Induced.lean", "def_pos": [54, 5], "def_end_pos": [54, 12]}, {"full_name": "LinearEquiv.toEquiv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [145, 5], "def_end_pos": [145, 12]}, {"full_name": "Equiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [166, 15], "def_end_pos": [166, 19]}, {"full_name": "inferInstance", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [99, 8], "def_end_pos": [99, 21]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}, {"full_name": "separated_by_continuous", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [1513, 9], "def_end_pos": [1513, 32]}, {"full_name": "TopologicalSpace.induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Induced.lean", "def_pos": [54, 5], "def_end_pos": [54, 12]}, {"full_name": "continuous_induced_dom", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [691, 9], "def_end_pos": [691, 31]}]], "state_before": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\n\u22a2 Continuous \u21d1(LinearEquiv.toEquiv \u03c6)", "state_after": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis\u271d : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\nthis : induced (\u21d1(LinearEquiv.toEquiv \u03c6).symm) inferInstance = UniformSpace.toTopologicalSpace\n\u22a2 Continuous \u21d1(LinearEquiv.toEquiv \u03c6)"}, {"tactic": "exact continuous_coinduced_rng", "annotated_tactic": ["exact <a>continuous_coinduced_rng</a>", [{"full_name": "continuous_coinduced_rng", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [700, 9], "def_end_pos": [700, 33]}]], "state_before": "case neg\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis\u271d : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\nthis : induced (\u21d1(LinearEquiv.toEquiv \u03c6).symm) inferInstance = UniformSpace.toTopologicalSpace\n\u22a2 Continuous \u21d1(LinearEquiv.toEquiv \u03c6)", "state_after": "no goals"}, {"tactic": "rw [\u2190 LinearMap.ker_eq_bot]", "annotated_tactic": ["rw [\u2190 <a>LinearMap.ker_eq_bot</a>]", [{"full_name": "LinearMap.ker_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [210, 9], "def_end_pos": [210, 19]}]], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\n\u22a2 Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)", "state_after": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\n\u22a2 ker (Submodule.liftQ (ker l) l \u22ef) = \u22a5"}, {"tactic": "exact Submodule.ker_liftQ_eq_bot _ _ _ (le_refl _)", "annotated_tactic": ["exact <a>Submodule.ker_liftQ_eq_bot</a> _ _ _ (<a>le_refl</a> _)", [{"full_name": "Submodule.ker_liftQ_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [484, 9], "def_end_pos": [484, 25]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\n\u22a2 ker (Submodule.liftQ (ker l) l \u22ef) = \u22a5", "state_after": "no goals"}, {"tactic": "rw [\u2190 LinearMap.range_eq_top, Submodule.range_liftQ]", "annotated_tactic": ["rw [\u2190 <a>LinearMap.range_eq_top</a>, <a>Submodule.range_liftQ</a>]", [{"full_name": "LinearMap.range_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [174, 9], "def_end_pos": [174, 21]}, {"full_name": "Submodule.range_liftQ", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [480, 9], "def_end_pos": [480, 20]}]], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u22a2 Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)", "state_after": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u22a2 range l = \u22a4"}, {"tactic": "exact Submodule.eq_top_of_finrank_eq ((finrank_self \ud835\udd5c).symm \u25b8 this)", "annotated_tactic": ["exact <a>Submodule.eq_top_of_finrank_eq</a> ((<a>finrank_self</a> \ud835\udd5c).<a>symm</a> \u25b8 this)", [{"full_name": "Submodule.eq_top_of_finrank_eq", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FiniteDimensional.lean", "def_pos": [225, 9], "def_end_pos": [225, 46]}, {"full_name": "FiniteDimensional.finrank_self", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "def_pos": [449, 9], "def_end_pos": [449, 39]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u22a2 range l = \u22a4", "state_after": "no goals"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\n\u22a2 \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))", "state_after": "case h\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nx\u271d : E\n\u22a2 l x\u271d = (\u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))) x\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h\n\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nx\u271d : E\n\u22a2 l x\u271d = (\u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))) x\u271d", "state_after": "no goals"}, {"tactic": "rw [hl\u03c6]", "annotated_tactic": ["rw [hl\u03c6]", []], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis\u271d : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\nthis : Continuous \u21d1(LinearEquiv.toEquiv \u03c6)\n\u22a2 Continuous \u21d1l", "state_after": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis\u271d : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\nthis : Continuous \u21d1(LinearEquiv.toEquiv \u03c6)\n\u22a2 Continuous (\u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l)))"}, {"tactic": "exact this.comp continuous_quot_mk", "annotated_tactic": ["exact this.comp <a>continuous_quot_mk</a>", [{"full_name": "continuous_quot_mk", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [1232, 9], "def_end_pos": [1232, 27]}]], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis\u271d : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\nthis : Continuous \u21d1(LinearEquiv.toEquiv \u03c6)\n\u22a2 Continuous (\u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l)))", "state_after": "no goals"}, {"tactic": "refine' unique_topology_of_t2 (topologicalAddGroup_induced \u03c6.symm.toLinearMap)\n  (continuousSMul_induced \u03c6.symm.toLinearMap) _", "annotated_tactic": ["refine' <a>unique_topology_of_t2</a> (<a>topologicalAddGroup_induced</a> \u03c6.symm.toLinearMap)\n        (<a>continuousSMul_induced</a> \u03c6.symm.toLinearMap) _", [{"full_name": "unique_topology_of_t2", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/FiniteDimension.lean", "def_pos": [76, 9], "def_end_pos": [76, 30]}, {"full_name": "topologicalAddGroup_induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [684, 3], "def_end_pos": [684, 14]}, {"full_name": "continuousSMul_induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [105, 9], "def_end_pos": [105, 31]}]], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\n\u22a2 induced (\u21d1(LinearEquiv.toEquiv \u03c6).symm) inferInstance = UniformSpace.toTopologicalSpace", "state_after": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\n\u22a2 T2Space \ud835\udd5c"}, {"tactic": "refine (@t2Space_iff \ud835\udd5c (induced (\u2191(LinearEquiv.toEquiv \u03c6).symm) inferInstance)).mpr ?_", "annotated_tactic": ["refine (@<a>t2Space_iff</a> \ud835\udd5c (<a>induced</a> (\u2191(<a>LinearEquiv.toEquiv</a> \u03c6).<a>symm</a>) <a>inferInstance</a>)).<a>mpr</a> ?_", [{"full_name": "t2Space_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [1208, 3], "def_end_pos": [1208, 9]}, {"full_name": "TopologicalSpace.induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Induced.lean", "def_pos": [54, 5], "def_end_pos": [54, 12]}, {"full_name": "LinearEquiv.toEquiv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [145, 5], "def_end_pos": [145, 12]}, {"full_name": "Equiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [166, 15], "def_end_pos": [166, 19]}, {"full_name": "inferInstance", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [99, 8], "def_end_pos": [99, 21]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}]], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\n\u22a2 T2Space \ud835\udd5c", "state_after": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\n\u22a2 Pairwise fun x y => \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 Disjoint u v"}, {"tactic": "exact fun x y hxy =>\n  @separated_by_continuous _ _ (induced _ _) _ _ _ continuous_induced_dom _ _\n    (\u03c6.toEquiv.symm.injective.ne hxy)", "annotated_tactic": ["exact fun x y hxy =>\n        @<a>separated_by_continuous</a> _ _ (<a>induced</a> _ _) _ _ _ <a>continuous_induced_dom</a> _ _\n          (\u03c6.toEquiv.symm.injective.ne hxy)", [{"full_name": "separated_by_continuous", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [1513, 9], "def_end_pos": [1513, 32]}, {"full_name": "TopologicalSpace.induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Induced.lean", "def_pos": [54, 5], "def_end_pos": [54, 12]}, {"full_name": "continuous_induced_dom", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [691, 9], "def_end_pos": [691, 31]}]], "state_before": "\ud835\udd5c : Type u\nhnorm : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2074 : AddCommGroup E\ninst\u271d\u00b9\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : TopologicalAddGroup E\ninst\u271d\u00b9\u2070 : ContinuousSMul \ud835\udd5c E\nF : Type w\ninst\u271d\u2079 : AddCommGroup F\ninst\u271d\u2078 : Module \ud835\udd5c F\ninst\u271d\u2077 : TopologicalSpace F\ninst\u271d\u2076 : TopologicalAddGroup F\ninst\u271d\u2075 : ContinuousSMul \ud835\udd5c F\nF' : Type x\ninst\u271d\u2074 : AddCommGroup F'\ninst\u271d\u00b3 : Module \ud835\udd5c F'\ninst\u271d\u00b2 : TopologicalSpace F'\ninst\u271d\u00b9 : TopologicalAddGroup F'\ninst\u271d : ContinuousSMul \ud835\udd5c F'\nl : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c\nhl : IsClosed \u2191(ker l)\nH : \u00acfinrank \ud835\udd5c \u21a5(range l) = 0\nthis : finrank \ud835\udd5c \u21a5(range l) = 1\nhi : Function.Injective \u21d1(Submodule.liftQ (ker l) l \u22ef)\nhs : Function.Surjective \u21d1(Submodule.liftQ (ker l) l \u22ef)\n\u03c6 : (E \u29f8 ker l) \u2243\u2097[\ud835\udd5c] \ud835\udd5c := LinearEquiv.ofBijective (Submodule.liftQ (ker l) l \u22ef) \u22ef\nhl\u03c6 : \u21d1l = \u21d1\u03c6 \u2218 \u21d1(Submodule.mkQ (ker l))\n\u22a2 Pairwise fun x y => \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 Disjoint u v", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Ordinal.lsub_lt_ord_lift", "start": [328, 1], "end": [333, 48], "traced_tactics": [{"tactic": "subst h", "annotated_tactic": ["subst h", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nc : Ordinal.{max u v}\nh\u03b9 : Cardinal.lift.{v, u} #\u03b9 < cof c\nhf : \u2200 (i : \u03b9), f i < c\nh : lsub f = c\n\u22a2 False", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nh\u03b9 : Cardinal.lift.{v, u} #\u03b9 < cof (lsub f)\nhf : \u2200 (i : \u03b9), f i < lsub f\n\u22a2 False"}, {"tactic": "exact (cof_lsub_le_lift.{u, v} f).not_lt h\u03b9", "annotated_tactic": ["exact (<a>cof_lsub_le_lift</a>.{u, v} f).<a>not_lt</a> h\u03b9", [{"full_name": "Ordinal.cof_lsub_le_lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Cofinality.lean", "def_pos": [309, 9], "def_end_pos": [309, 25]}, {"full_name": "LE.le.not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [353, 7], "def_end_pos": [353, 19]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nh\u03b9 : Cardinal.lift.{v, u} #\u03b9 < cof (lsub f)\nhf : \u2200 (i : \u03b9), f i < lsub f\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_union_le_aleph0", "start": [2125, 1], "end": [2128, 23], "traced_tactics": [{"tactic": "simp only [le_aleph0_iff_subtype_countable, mem_union, setOf_mem_eq, Set.union_def,\n  \u2190 countable_union]", "annotated_tactic": ["simp only [<a>le_aleph0_iff_subtype_countable</a>, <a>mem_union</a>, <a>setOf_mem_eq</a>, <a>Set.union_def</a>,\n    \u2190 <a>countable_union</a>]", [{"full_name": "Cardinal.le_aleph0_iff_subtype_countable", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1638, 9], "def_end_pos": [1638, 40]}, {"full_name": "Set.mem_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 18]}, {"full_name": "Set.setOf_mem_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [250, 9], "def_end_pos": [250, 21]}, {"full_name": "Set.union_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [715, 9], "def_end_pos": [715, 18]}, {"full_name": "Set.countable_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [252, 9], "def_end_pos": [252, 24]}]], "state_before": "\u03b1\u271d \u03b2 : Type u\nc : Cardinal.{?u.243040}\n\u03b1 : Type u_1\nP Q : Set \u03b1\n\u22a2 #\u2191(P \u222a Q) \u2264 \u2135\u2080 \u2194 #\u2191P \u2264 \u2135\u2080 \u2227 #\u2191Q \u2264 \u2135\u2080", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Cardinal.le_range_of_union_finset_eq_top", "start": [1035, 1], "end": [1052, 88], "traced_tactics": [{"tactic": "have k : _root_.Infinite (range f) := by\n  rw [infinite_coe_iff]\n  apply mt (union_finset_finite_of_range_finite f)\n  rw [w]\n  exact infinite_univ", "annotated_tactic": ["have k : <a>_root_.Infinite</a> (<a>range</a> f) := by\n    rw [<a>infinite_coe_iff</a>]\n    apply <a>mt</a> (<a>union_finset_finite_of_range_finite</a> f)\n    rw [w]\n    exact <a>infinite_univ</a>", [{"full_name": "Infinite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finite/Defs.lean", "def_pos": [117, 7], "def_end_pos": [117, 15]}, {"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}, {"full_name": "Set.infinite_coe_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1328, 9], "def_end_pos": [1328, 25]}, {"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "Set.union_finset_finite_of_range_finite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1051, 9], "def_end_pos": [1051, 44]}, {"full_name": "Set.infinite_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1324, 9], "def_end_pos": [1324, 22]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\n\u22a2 #\u03b2 \u2264 #\u2191(range f)", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\n\u22a2 #\u03b2 \u2264 #\u2191(range f)"}, {"tactic": "by_contra h", "annotated_tactic": ["by_contra h", []], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\n\u22a2 #\u03b2 \u2264 #\u2191(range f)", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : \u00ac#\u03b2 \u2264 #\u2191(range f)\n\u22a2 False"}, {"tactic": "simp only [not_le] at h", "annotated_tactic": ["simp only [<a>not_le</a>] at h", [{"full_name": "not_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [367, 9], "def_end_pos": [367, 15]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : \u00ac#\u03b2 \u2264 #\u2191(range f)\n\u22a2 False", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\n\u22a2 False"}, {"tactic": "let u : \u2200 b, \u2203 a, b \u2208 f a := fun b => by simpa using (w.ge : _) (Set.mem_univ b)", "annotated_tactic": ["let u : \u2200 b, \u2203 a, b \u2208 f a := fun b => by simpa using (w.ge : _) (<a>Set.mem_univ</a> b)", [{"full_name": "Set.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [82, 29], "def_end_pos": [82, 37]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\n\u22a2 False", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\n\u22a2 False"}, {"tactic": "let u' : \u03b2 \u2192 range f := fun b => \u27e8f (u b).choose, by simp\u27e9", "annotated_tactic": ["let u' : \u03b2 \u2192 <a>range</a> f := fun b => \u27e8f (u b).<a>choose</a>, by simp\u27e9", [{"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}, {"full_name": "Exists.choose", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [154, 32], "def_end_pos": [154, 45]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\n\u22a2 False", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\n\u22a2 False"}, {"tactic": "have v' : \u2200 a, u' \u207b\u00b9' {\u27e8f a, by simp\u27e9} \u2264 f a := by\n  rintro a p m\n  simp? [u']  at m says simp only [mem_preimage, mem_singleton_iff, Subtype.mk.injEq, u'] at m\n  rw [\u2190 m]\n  apply fun b => (u b).choose_spec", "annotated_tactic": ["have v' : \u2200 a, u' \u207b\u00b9' {\u27e8f a, by simp\u27e9} \u2264 f a := by\n    rintro a p m\n    simp? [u']  at m says simp only [<a>mem_preimage</a>, <a>mem_singleton_iff</a>, Subtype.mk.injEq, u'] at m\n    rw [\u2190 m]\n    apply fun b => (u b).<a>choose_spec</a>", [{"full_name": "Set.mem_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 21]}, {"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}, {"full_name": "Exists.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [157, 9], "def_end_pos": [157, 27]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\n\u22a2 False", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\nv' : \u2200 (a : \u03b1), u' \u207b\u00b9' {{ val := f a, property := \u22ef }} \u2264 \u2191(f a)\n\u22a2 False"}, {"tactic": "obtain \u27e8\u27e8-, \u27e8a, rfl\u27e9\u27e9, p\u27e9 := exists_infinite_fiber u' h k", "annotated_tactic": ["obtain \u27e8\u27e8-, \u27e8a, rfl\u27e9\u27e9, p\u27e9 := <a>exists_infinite_fiber</a> u' h k", [{"full_name": "Cardinal.exists_infinite_fiber", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Cofinality.lean", "def_pos": [1024, 9], "def_end_pos": [1024, 30]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\nv' : \u2200 (a : \u03b1), u' \u207b\u00b9' {{ val := f a, property := \u22ef }} \u2264 \u2191(f a)\n\u22a2 False", "state_after": "case intro.mk.intro\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\nv' : \u2200 (a : \u03b1), u' \u207b\u00b9' {{ val := f a, property := \u22ef }} \u2264 \u2191(f a)\na : \u03b1\np : Infinite \u2191(u' \u207b\u00b9' {{ val := f a, property := \u22ef }})\n\u22a2 False"}, {"tactic": "exact (@Infinite.of_injective _ _ p (inclusion (v' a)) (inclusion_injective _)).false", "annotated_tactic": ["exact (@<a>Infinite.of_injective</a> _ _ p (<a>inclusion</a> (v' a)) (<a>inclusion_injective</a> _)).<a>false</a>", [{"full_name": "Infinite.of_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [1046, 9], "def_end_pos": [1046, 21]}, {"full_name": "Set.inclusion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2771, 5], "def_end_pos": [2771, 14]}, {"full_name": "Set.inclusion_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2812, 9], "def_end_pos": [2812, 28]}, {"full_name": "Infinite.false", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finite/Defs.lean", "def_pos": [155, 19], "def_end_pos": [155, 33]}]], "state_before": "case intro.mk.intro\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\nv' : \u2200 (a : \u03b1), u' \u207b\u00b9' {{ val := f a, property := \u22ef }} \u2264 \u2191(f a)\na : \u03b1\np : Infinite \u2191(u' \u207b\u00b9' {{ val := f a, property := \u22ef }})\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [infinite_coe_iff]", "annotated_tactic": ["rw [<a>infinite_coe_iff</a>]", [{"full_name": "Set.infinite_coe_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1328, 9], "def_end_pos": [1328, 25]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\n\u22a2 Infinite \u2191(range f)", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\n\u22a2 Set.Infinite (range f)"}, {"tactic": "apply mt (union_finset_finite_of_range_finite f)", "annotated_tactic": ["apply <a>mt</a> (<a>union_finset_finite_of_range_finite</a> f)", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "Set.union_finset_finite_of_range_finite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1051, 9], "def_end_pos": [1051, 44]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\n\u22a2 Set.Infinite (range f)", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\n\u22a2 \u00acSet.Finite (\u22c3 a, \u2191(f a))"}, {"tactic": "rw [w]", "annotated_tactic": ["rw [w]", []], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\n\u22a2 \u00acSet.Finite (\u22c3 a, \u2191(f a))", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\n\u22a2 \u00acSet.Finite \u22a4"}, {"tactic": "exact infinite_univ", "annotated_tactic": ["exact <a>infinite_univ</a>", [{"full_name": "Set.infinite_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1324, 9], "def_end_pos": [1324, 22]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\n\u22a2 \u00acSet.Finite \u22a4", "state_after": "no goals"}, {"tactic": "simpa using (w.ge : _) (Set.mem_univ b)", "annotated_tactic": ["simpa using (w.ge : _) (<a>Set.mem_univ</a> b)", [{"full_name": "Set.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [82, 29], "def_end_pos": [82, 37]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nb : \u03b2\n\u22a2 \u2203 a, b \u2208 f a", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nb : \u03b2\n\u22a2 f (Exists.choose \u22ef) \u2208 range f", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\na : \u03b1\n\u22a2 f a \u2208 range f", "state_after": "no goals"}, {"tactic": "rintro a p m", "annotated_tactic": ["rintro a p m", []], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\n\u22a2 \u2200 (a : \u03b1), u' \u207b\u00b9' {{ val := f a, property := \u22ef }} \u2264 \u2191(f a)", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\na : \u03b1\np : \u03b2\nm : p \u2208 u' \u207b\u00b9' {{ val := f a, property := \u22ef }}\n\u22a2 p \u2208 \u2191(f a)"}, {"tactic": "simp? [u']  at m says simp only [mem_preimage, mem_singleton_iff, Subtype.mk.injEq, u'] at m", "annotated_tactic": ["simp? [u']  at m says simp only [<a>mem_preimage</a>, <a>mem_singleton_iff</a>, Subtype.mk.injEq, u'] at m", [{"full_name": "Set.mem_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 21]}, {"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\na : \u03b1\np : \u03b2\nm : p \u2208 u' \u207b\u00b9' {{ val := f a, property := \u22ef }}\n\u22a2 p \u2208 \u2191(f a)", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\na : \u03b1\np : \u03b2\nm : f (Exists.choose \u22ef) = f a\n\u22a2 p \u2208 \u2191(f a)"}, {"tactic": "rw [\u2190 m]", "annotated_tactic": ["rw [\u2190 m]", []], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\na : \u03b1\np : \u03b2\nm : f (Exists.choose \u22ef) = f a\n\u22a2 p \u2208 \u2191(f a)", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\na : \u03b1\np : \u03b2\nm : f (Exists.choose \u22ef) = f a\n\u22a2 p \u2208 \u2191(f (Exists.choose \u22ef))"}, {"tactic": "apply fun b => (u b).choose_spec", "annotated_tactic": ["apply fun b => (u b).<a>choose_spec</a>", [{"full_name": "Exists.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [157, 9], "def_end_pos": [157, 27]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\na : \u03b1\np : \u03b2\nm : f (Exists.choose \u22ef) = f a\n\u22a2 p \u2208 \u2191(f (Exists.choose \u22ef))", "state_after": "no goals"}, {"tactic": "simp only [mem_preimage, mem_singleton_iff, Subtype.mk.injEq, u'] at m", "annotated_tactic": ["simp only [<a>mem_preimage</a>, <a>mem_singleton_iff</a>, Subtype.mk.injEq, u'] at m", [{"full_name": "Set.mem_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 21]}, {"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\na : \u03b1\np : \u03b2\nm : p \u2208 u' \u207b\u00b9' {{ val := f a, property := \u22ef }}\n\u22a2 p \u2208 \u2191(f a)", "state_after": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : Infinite \u03b2\nf : \u03b1 \u2192 Finset \u03b2\nw : \u22c3 a, \u2191(f a) = \u22a4\nk : Infinite \u2191(range f)\nh : #\u2191(range f) < #\u03b2\nu : \u2200 (b : \u03b2), \u2203 a, b \u2208 f a :=\n  fun b =>\n    Eq.mp\n      (Mathlib.Order.SetNotation._auxLemma.3.trans\n        (congrArg Exists (funext fun i => Mathlib.Data.Finset.Basic._auxLemma.6)))\n      (Eq.ge w (mem_univ b))\nu' : \u03b2 \u2192 \u2191(range f) := fun b => { val := f (Exists.choose \u22ef), property := \u22ef }\na : \u03b1\np : \u03b2\nm : f (Exists.choose \u22ef) = f a\n\u22a2 p \u2208 \u2191(f a)"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.div_mem_div", "start": [643, 1], "end": [644, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Option.lean", "full_name": "Equiv.optionCongr_eq_equivFunctor_mapEquiv", "start": [63, 1], "end": [65, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/GaussLemma.lean", "full_name": "Polynomial.IsPrimitive.irreducible_iff_irreducible_map_fraction_map", "start": [249, 1], "end": [288, 75], "traced_tactics": [{"tactic": "refine'\n  \u27e8fun hi => \u27e8fun h => hi.not_unit (hp.isUnit_iff_isUnit_map.2 h), fun a b hab => _\u27e9,\n    hp.irreducible_of_irreducible_map_of_injective (IsFractionRing.injective R K)\u27e9", "annotated_tactic": ["refine'\n    \u27e8fun hi => \u27e8fun h => hi.not_unit (hp.isUnit_iff_isUnit_map.2 h), fun a b hab => _\u27e9,\n      hp.irreducible_of_irreducible_map_of_injective (<a>IsFractionRing.injective</a> R K)\u27e9", [{"full_name": "IsFractionRing.injective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/FractionRing.lean", "def_pos": [81, 19], "def_end_pos": [81, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\n\u22a2 Irreducible p \u2194 Irreducible (map (algebraMap R K) p)", "state_after": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "obtain \u27e8\u27e8c, c0\u27e9, hc\u27e9 := integerNormalization_map_to_map R\u2070 a", "annotated_tactic": ["obtain \u27e8\u27e8c, c0\u27e9, hc\u27e9 := <a>integerNormalization_map_to_map</a> R\u2070 a", [{"full_name": "IsLocalization.integerNormalization_map_to_map", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Integral.lean", "def_pos": [94, 9], "def_end_pos": [94, 40]}]], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2208 R\u2070\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = \u2191{ val := c, property := c0 } \u2022 a\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "obtain \u27e8\u27e8d, d0\u27e9, hd\u27e9 := integerNormalization_map_to_map R\u2070 b", "annotated_tactic": ["obtain \u27e8\u27e8d, d0\u27e9, hd\u27e9 := <a>integerNormalization_map_to_map</a> R\u2070 b", [{"full_name": "IsLocalization.integerNormalization_map_to_map", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Integral.lean", "def_pos": [94, 9], "def_end_pos": [94, 40]}]], "state_before": "case intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2208 R\u2070\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = \u2191{ val := c, property := c0 } \u2022 a\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2208 R\u2070\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = \u2191{ val := c, property := c0 } \u2022 a\nd : R\nd0 : d \u2208 R\u2070\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = \u2191{ val := d, property := d0 } \u2022 b\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "rw [Algebra.smul_def, algebraMap_apply, Subtype.coe_mk] at hc hd", "annotated_tactic": ["rw [<a>Algebra.smul_def</a>, <a>algebraMap_apply</a>, <a>Subtype.coe_mk</a>] at hc hd", [{"full_name": "Algebra.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}, {"full_name": "Polynomial.algebraMap_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/AlgebraMap.lean", "def_pos": [53, 9], "def_end_pos": [53, 25]}, {"full_name": "Subtype.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [99, 9], "def_end_pos": [99, 15]}]], "state_before": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2208 R\u2070\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = \u2191{ val := c, property := c0 } \u2022 a\nd : R\nd0 : d \u2208 R\u2070\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = \u2191{ val := d, property := d0 } \u2022 b\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2208 R\u2070\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2208 R\u2070\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "rw [mem_nonZeroDivisors_iff_ne_zero] at c0 d0", "annotated_tactic": ["rw [<a>mem_nonZeroDivisors_iff_ne_zero</a>] at c0 d0", [{"full_name": "mem_nonZeroDivisors_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "def_pos": [202, 9], "def_end_pos": [202, 40]}]], "state_before": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2208 R\u2070\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2208 R\u2070\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "have hcd0 : c * d \u2260 0 := mul_ne_zero c0 d0", "annotated_tactic": ["have hcd0 : c * d \u2260 0 := <a>mul_ne_zero</a> c0 d0", [{"full_name": "mul_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [88, 9], "def_end_pos": [88, 20]}]], "state_before": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : c * d \u2260 0\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "rw [Ne.def, \u2190 C_eq_zero] at hcd0", "annotated_tactic": ["rw [<a>Ne.def</a>, \u2190 <a>C_eq_zero</a>] at hcd0", [{"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Polynomial.C_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [804, 9], "def_end_pos": [804, 18]}]], "state_before": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : c * d \u2260 0\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "have h1 : C c * C d * p = integerNormalization R\u2070 a * integerNormalization R\u2070 b := by\n  apply map_injective (algebraMap R K) (IsFractionRing.injective _ _) _\n  rw [Polynomial.map_mul, Polynomial.map_mul, Polynomial.map_mul, hc, hd, map_C, map_C, hab]\n  ring", "annotated_tactic": ["have h1 : <a>C</a> c * <a>C</a> d * p = <a>integerNormalization</a> R\u2070 a * <a>integerNormalization</a> R\u2070 b := by\n    apply <a>map_injective</a> (<a>algebraMap</a> R K) (<a>IsFractionRing.injective</a> _ _) _\n    rw [<a>Polynomial.map_mul</a>, <a>Polynomial.map_mul</a>, <a>Polynomial.map_mul</a>, hc, hd, <a>map_C</a>, <a>map_C</a>, hab]\n    ring", [{"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}, {"full_name": "IsLocalization.integerNormalization", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Integral.lean", "def_pos": [69, 19], "def_end_pos": [69, 39]}, {"full_name": "IsLocalization.integerNormalization", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Integral.lean", "def_pos": [69, 19], "def_end_pos": [69, 39]}, {"full_name": "Polynomial.map_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [853, 9], "def_end_pos": [853, 22]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "IsFractionRing.injective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/FractionRing.lean", "def_pos": [81, 19], "def_end_pos": [81, 28]}, {"full_name": "Polynomial.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [746, 19], "def_end_pos": [746, 26]}, {"full_name": "Polynomial.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [746, 19], "def_end_pos": [746, 26]}, {"full_name": "Polynomial.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [746, 19], "def_end_pos": [746, 26]}, {"full_name": "Polynomial.map_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [715, 9], "def_end_pos": [715, 14]}, {"full_name": "Polynomial.map_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [715, 9], "def_end_pos": [715, 14]}]], "state_before": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nh1 : C c * C d * p = integerNormalization R\u2070 a * integerNormalization R\u2070 b\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "obtain \u27e8u, hu\u27e9 :\n  Associated (c * d)\n    (content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)) := by\n  rw [\u2190 dvd_dvd_iff_associated, \u2190 normalize_eq_normalize_iff, normalize.map_mul,\n    normalize.map_mul, normalize_content, normalize_content, \u2190\n    mul_one (normalize c * normalize d), \u2190 hp.content_eq_one, \u2190 content_C, \u2190 content_C, \u2190\n    content_mul, \u2190 content_mul, \u2190 content_mul, h1]", "annotated_tactic": ["obtain \u27e8u, hu\u27e9 :\n    <a>Associated</a> (c * d)\n      (<a>content</a> (<a>integerNormalization</a> R\u2070 a) * <a>content</a> (<a>integerNormalization</a> R\u2070 b)) := by\n    rw [\u2190 <a>dvd_dvd_iff_associated</a>, \u2190 <a>normalize_eq_normalize_iff</a>, normalize.map_mul,\n      normalize.map_mul, <a>normalize_content</a>, <a>normalize_content</a>, \u2190\n      <a>mul_one</a> (<a>normalize</a> c * <a>normalize</a> d), \u2190 hp.content_eq_one, \u2190 <a>content_C</a>, \u2190 <a>content_C</a>, \u2190\n      <a>content_mul</a>, \u2190 <a>content_mul</a>, \u2190 <a>content_mul</a>, h1]", [{"full_name": "Associated", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [378, 5], "def_end_pos": [378, 15]}, {"full_name": "Polynomial.content", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [79, 5], "def_end_pos": [79, 12]}, {"full_name": "IsLocalization.integerNormalization", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Integral.lean", "def_pos": [69, 19], "def_end_pos": [69, 39]}, {"full_name": "Polynomial.content", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [79, 5], "def_end_pos": [79, 12]}, {"full_name": "IsLocalization.integerNormalization", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Integral.lean", "def_pos": [69, 19], "def_end_pos": [69, 39]}, {"full_name": "dvd_dvd_iff_associated", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [570, 9], "def_end_pos": [570, 31]}, {"full_name": "normalize_eq_normalize_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [184, 9], "def_end_pos": [184, 35]}, {"full_name": "Polynomial.normalize_content", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [172, 9], "def_end_pos": [172, 26]}, {"full_name": "Polynomial.normalize_content", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [172, 9], "def_end_pos": [172, 26]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "normalize", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [99, 5], "def_end_pos": [99, 14]}, {"full_name": "normalize", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [99, 5], "def_end_pos": [99, 14]}, {"full_name": "Polynomial.content_C", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [92, 9], "def_end_pos": [92, 18]}, {"full_name": "Polynomial.content_C", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [92, 9], "def_end_pos": [92, 18]}, {"full_name": "Polynomial.content_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [357, 9], "def_end_pos": [357, 20]}, {"full_name": "Polynomial.content_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [357, 9], "def_end_pos": [357, 20]}, {"full_name": "Polynomial.content_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [357, 9], "def_end_pos": [357, 20]}]], "state_before": "case intro.mk.intro.mk\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nh1 : C c * C d * p = integerNormalization R\u2070 a * integerNormalization R\u2070 b\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk.intro\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nh1 : C c * C d * p = integerNormalization R\u2070 a * integerNormalization R\u2070 b\nu : R\u02e3\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "rw [\u2190 RingHom.map_mul, eq_comm, (integerNormalization R\u2070 a).eq_C_content_mul_primPart,\n  (integerNormalization R\u2070 b).eq_C_content_mul_primPart, mul_assoc, mul_comm _ (C _ * _), \u2190\n  mul_assoc, \u2190 mul_assoc, \u2190 RingHom.map_mul, \u2190 hu, RingHom.map_mul, mul_assoc, mul_assoc, \u2190\n  mul_assoc (C (u : R))] at h1", "annotated_tactic": ["rw [\u2190 <a>RingHom.map_mul</a>, <a>eq_comm</a>, (<a>integerNormalization</a> R\u2070 a).<a>eq_C_content_mul_primPart</a>,\n    (<a>integerNormalization</a> R\u2070 b).<a>eq_C_content_mul_primPart</a>, <a>mul_assoc</a>, <a>mul_comm</a> _ (<a>C</a> _ * _), \u2190\n    <a>mul_assoc</a>, \u2190 <a>mul_assoc</a>, \u2190 <a>RingHom.map_mul</a>, \u2190 hu, <a>RingHom.map_mul</a>, <a>mul_assoc</a>, <a>mul_assoc</a>, \u2190\n    <a>mul_assoc</a> (<a>C</a> (u : R))] at h1", [{"full_name": "RingHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "IsLocalization.integerNormalization", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Integral.lean", "def_pos": [69, 19], "def_end_pos": [69, 39]}, {"full_name": "Polynomial.eq_C_content_mul_primPart", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [251, 9], "def_end_pos": [251, 34]}, {"full_name": "IsLocalization.integerNormalization", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Integral.lean", "def_pos": [69, 19], "def_end_pos": [69, 39]}, {"full_name": "Polynomial.eq_C_content_mul_primPart", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [251, 9], "def_end_pos": [251, 34]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "RingHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "RingHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}]], "state_before": "case intro.mk.intro.mk.intro\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nh1 : C c * C d * p = integerNormalization R\u2070 a * integerNormalization R\u2070 b\nu : R\u02e3\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk.intro\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "have h0 : a \u2260 0 \u2227 b \u2260 0 := by\n  classical\n  rw [Ne.def, Ne.def, \u2190 not_or, \u2190 mul_eq_zero, \u2190 hab]\n  intro con\n  apply hp.ne_zero (map_injective (algebraMap R K) (IsFractionRing.injective _ _) _)\n  simp [con]", "annotated_tactic": ["have h0 : a \u2260 0 \u2227 b \u2260 0 := by\n    classical\n    rw [<a>Ne.def</a>, <a>Ne.def</a>, \u2190 <a>not_or</a>, \u2190 <a>mul_eq_zero</a>, \u2190 hab]\n    intro con\n    apply hp.ne_zero (<a>map_injective</a> (<a>algebraMap</a> R K) (<a>IsFractionRing.injective</a> _ _) _)\n    simp [con]", [{"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "not_or", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [107, 9], "def_end_pos": [107, 15]}, {"full_name": "mul_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [239, 9], "def_end_pos": [239, 20]}, {"full_name": "Polynomial.map_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [853, 9], "def_end_pos": [853, 22]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "IsFractionRing.injective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/FractionRing.lean", "def_pos": [81, 19], "def_end_pos": [81, 28]}]], "state_before": "case intro.mk.intro.mk.intro\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk.intro\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "rcases hi.isUnit_or_isUnit (mul_left_cancel\u2080 hcd0 h1).symm with (h | h)", "annotated_tactic": ["rcases hi.isUnit_or_isUnit (<a>mul_left_cancel\u2080</a> hcd0 h1).<a>symm</a> with (h | h)", [{"full_name": "mul_left_cancel\u2080", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 25]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case intro.mk.intro.mk.intro\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk.intro.inl\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\nh : IsUnit (C \u2191u * primPart (integerNormalization R\u2070 b))\n\u22a2 IsUnit a \u2228 IsUnit b\n\ncase intro.mk.intro.mk.intro.inr\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\nh : IsUnit (primPart (integerNormalization R\u2070 a))\n\u22a2 IsUnit a \u2228 IsUnit b"}, {"tactic": "apply map_injective (algebraMap R K) (IsFractionRing.injective _ _) _", "annotated_tactic": ["apply <a>map_injective</a> (<a>algebraMap</a> R K) (<a>IsFractionRing.injective</a> _ _) _", [{"full_name": "Polynomial.map_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [853, 9], "def_end_pos": [853, 22]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "IsFractionRing.injective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/FractionRing.lean", "def_pos": [81, 19], "def_end_pos": [81, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\n\u22a2 C c * C d * p = integerNormalization R\u2070 a * integerNormalization R\u2070 b", "state_after": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\n\u22a2 map (algebraMap R K) (C c * C d * p) = map (algebraMap R K) (integerNormalization R\u2070 a * integerNormalization R\u2070 b)"}, {"tactic": "rw [Polynomial.map_mul, Polynomial.map_mul, Polynomial.map_mul, hc, hd, map_C, map_C, hab]", "annotated_tactic": ["rw [<a>Polynomial.map_mul</a>, <a>Polynomial.map_mul</a>, <a>Polynomial.map_mul</a>, hc, hd, <a>map_C</a>, <a>map_C</a>, hab]", [{"full_name": "Polynomial.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [746, 19], "def_end_pos": [746, 26]}, {"full_name": "Polynomial.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [746, 19], "def_end_pos": [746, 26]}, {"full_name": "Polynomial.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [746, 19], "def_end_pos": [746, 26]}, {"full_name": "Polynomial.map_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [715, 9], "def_end_pos": [715, 14]}, {"full_name": "Polynomial.map_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [715, 9], "def_end_pos": [715, 14]}]], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\n\u22a2 map (algebraMap R K) (C c * C d * p) = map (algebraMap R K) (integerNormalization R\u2070 a * integerNormalization R\u2070 b)", "state_after": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\n\u22a2 C ((algebraMap R K) c) * C ((algebraMap R K) d) * (a * b) = C ((algebraMap R K) c) * a * (C ((algebraMap R K) d) * b)"}, {"tactic": "ring", "annotated_tactic": ["ring", []], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\n\u22a2 C ((algebraMap R K) c) * C ((algebraMap R K) d) * (a * b) = C ((algebraMap R K) c) * a * (C ((algebraMap R K) d) * b)", "state_after": "no goals"}, {"tactic": "rw [\u2190 dvd_dvd_iff_associated, \u2190 normalize_eq_normalize_iff, normalize.map_mul,\n  normalize.map_mul, normalize_content, normalize_content, \u2190\n  mul_one (normalize c * normalize d), \u2190 hp.content_eq_one, \u2190 content_C, \u2190 content_C, \u2190\n  content_mul, \u2190 content_mul, \u2190 content_mul, h1]", "annotated_tactic": ["rw [\u2190 <a>dvd_dvd_iff_associated</a>, \u2190 <a>normalize_eq_normalize_iff</a>, normalize.map_mul,\n      normalize.map_mul, <a>normalize_content</a>, <a>normalize_content</a>, \u2190\n      <a>mul_one</a> (<a>normalize</a> c * <a>normalize</a> d), \u2190 hp.content_eq_one, \u2190 <a>content_C</a>, \u2190 <a>content_C</a>, \u2190\n      <a>content_mul</a>, \u2190 <a>content_mul</a>, \u2190 <a>content_mul</a>, h1]", [{"full_name": "dvd_dvd_iff_associated", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [570, 9], "def_end_pos": [570, 31]}, {"full_name": "normalize_eq_normalize_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [184, 9], "def_end_pos": [184, 35]}, {"full_name": "Polynomial.normalize_content", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [172, 9], "def_end_pos": [172, 26]}, {"full_name": "Polynomial.normalize_content", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [172, 9], "def_end_pos": [172, 26]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "normalize", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [99, 5], "def_end_pos": [99, 14]}, {"full_name": "normalize", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [99, 5], "def_end_pos": [99, 14]}, {"full_name": "Polynomial.content_C", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [92, 9], "def_end_pos": [92, 18]}, {"full_name": "Polynomial.content_C", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [92, 9], "def_end_pos": [92, 18]}, {"full_name": "Polynomial.content_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [357, 9], "def_end_pos": [357, 20]}, {"full_name": "Polynomial.content_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [357, 9], "def_end_pos": [357, 20]}, {"full_name": "Polynomial.content_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [357, 9], "def_end_pos": [357, 20]}]], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nh1 : C c * C d * p = integerNormalization R\u2070 a * integerNormalization R\u2070 b\n\u22a2 Associated (c * d) (content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b))", "state_after": "no goals"}, {"tactic": "classical\nrw [Ne.def, Ne.def, \u2190 not_or, \u2190 mul_eq_zero, \u2190 hab]\nintro con\napply hp.ne_zero (map_injective (algebraMap R K) (IsFractionRing.injective _ _) _)\nsimp [con]", "annotated_tactic": ["classical\n    rw [<a>Ne.def</a>, <a>Ne.def</a>, \u2190 <a>not_or</a>, \u2190 <a>mul_eq_zero</a>, \u2190 hab]\n    intro con\n    apply hp.ne_zero (<a>map_injective</a> (<a>algebraMap</a> R K) (<a>IsFractionRing.injective</a> _ _) _)\n    simp [con]", [{"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "not_or", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [107, 9], "def_end_pos": [107, 15]}, {"full_name": "mul_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [239, 9], "def_end_pos": [239, 20]}, {"full_name": "Polynomial.map_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [853, 9], "def_end_pos": [853, 22]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "IsFractionRing.injective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/FractionRing.lean", "def_pos": [81, 19], "def_end_pos": [81, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\n\u22a2 a \u2260 0 \u2227 b \u2260 0", "state_after": "no goals"}, {"tactic": "rw [Ne.def, Ne.def, \u2190 not_or, \u2190 mul_eq_zero, \u2190 hab]", "annotated_tactic": ["rw [<a>Ne.def</a>, <a>Ne.def</a>, \u2190 <a>not_or</a>, \u2190 <a>mul_eq_zero</a>, \u2190 hab]", [{"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "not_or", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [107, 9], "def_end_pos": [107, 15]}, {"full_name": "mul_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [239, 9], "def_end_pos": [239, 20]}]], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\n\u22a2 a \u2260 0 \u2227 b \u2260 0", "state_after": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\n\u22a2 \u00acmap (algebraMap R K) p = 0"}, {"tactic": "intro con", "annotated_tactic": ["intro con", []], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\n\u22a2 \u00acmap (algebraMap R K) p = 0", "state_after": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\ncon : map (algebraMap R K) p = 0\n\u22a2 False"}, {"tactic": "apply hp.ne_zero (map_injective (algebraMap R K) (IsFractionRing.injective _ _) _)", "annotated_tactic": ["apply hp.ne_zero (<a>map_injective</a> (<a>algebraMap</a> R K) (<a>IsFractionRing.injective</a> _ _) _)", [{"full_name": "Polynomial.map_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [853, 9], "def_end_pos": [853, 22]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "IsFractionRing.injective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/FractionRing.lean", "def_pos": [81, 19], "def_end_pos": [81, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\ncon : map (algebraMap R K) p = 0\n\u22a2 False", "state_after": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\ncon : map (algebraMap R K) p = 0\n\u22a2 map (algebraMap R K) p = map (algebraMap R K) 0"}, {"tactic": "simp [con]", "annotated_tactic": ["simp [con]", []], "state_before": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\ncon : map (algebraMap R K) p = 0\n\u22a2 map (algebraMap R K) p = map (algebraMap R K) 0", "state_after": "no goals"}, {"tactic": "right", "annotated_tactic": ["right", []], "state_before": "case intro.mk.intro.mk.intro.inl\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\nh : IsUnit (C \u2191u * primPart (integerNormalization R\u2070 b))\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk.intro.inl.h\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\nh : IsUnit (C \u2191u * primPart (integerNormalization R\u2070 b))\n\u22a2 IsUnit b"}, {"tactic": "apply\n  isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart h0.2\n    (isUnit_of_mul_isUnit_right h)", "annotated_tactic": ["apply\n      <a>isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart</a> h0.2\n        (<a>isUnit_of_mul_isUnit_right</a> h)", [{"full_name": "Polynomial.isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/GaussLemma.lean", "def_pos": [229, 9], "def_end_pos": [229, 66]}, {"full_name": "isUnit_of_mul_isUnit_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [778, 9], "def_end_pos": [778, 35]}]], "state_before": "case intro.mk.intro.mk.intro.inl.h\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\nh : IsUnit (C \u2191u * primPart (integerNormalization R\u2070 b))\n\u22a2 IsUnit b", "state_after": "no goals"}, {"tactic": "left", "annotated_tactic": ["left", []], "state_before": "case intro.mk.intro.mk.intro.inr\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\nh : IsUnit (primPart (integerNormalization R\u2070 a))\n\u22a2 IsUnit a \u2228 IsUnit b", "state_after": "case intro.mk.intro.mk.intro.inr.h\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\nh : IsUnit (primPart (integerNormalization R\u2070 a))\n\u22a2 IsUnit a"}, {"tactic": "apply isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart h0.1 h", "annotated_tactic": ["apply <a>isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart</a> h0.1 h", [{"full_name": "Polynomial.isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/GaussLemma.lean", "def_pos": [229, 9], "def_end_pos": [229, 66]}]], "state_before": "case intro.mk.intro.mk.intro.inr.h\nR : Type u_1\ninst\u271d\u2075 : CommRing R\nK : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra R K\ninst\u271d\u00b2 : IsFractionRing R K\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nhi : Irreducible p\na b : K[X]\nhab : map (algebraMap R K) p = a * b\nc : R\nc0 : c \u2260 0\nhc : map (algebraMap R K) (integerNormalization R\u2070 a) = C ((algebraMap R K) c) * a\nd : R\nd0 : d \u2260 0\nhd : map (algebraMap R K) (integerNormalization R\u2070 b) = C ((algebraMap R K) d) * b\nhcd0 : \u00acC (c * d) = 0\nu : R\u02e3\nh1 : C (c * d) * (C \u2191u * primPart (integerNormalization R\u2070 b) * primPart (integerNormalization R\u2070 a)) = C (c * d) * p\nhu : c * d * \u2191u = content (integerNormalization R\u2070 a) * content (integerNormalization R\u2070 b)\nh0 : a \u2260 0 \u2227 b \u2260 0\nh : IsUnit (primPart (integerNormalization R\u2070 a))\n\u22a2 IsUnit a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.measure_diff_null'", "start": [229, 1], "end": [230, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_const_mul_atTop_iff_pos", "start": [1085, 1], "end": [1089, 58], "traced_tactics": [{"tactic": "refine' \u27e8fun hrf => not_le.mp fun hr => _, fun hr => (tendsto_const_mul_atTop_of_pos hr).mpr h\u27e9", "annotated_tactic": ["refine' \u27e8fun hrf => not_le.mp fun hr => _, fun hr => (<a>tendsto_const_mul_atTop_of_pos</a> hr).<a>mpr</a> h\u27e9", [{"full_name": "Filter.tendsto_const_mul_atTop_of_pos", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [1064, 9], "def_end_pos": [1064, 39]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u00b9 : LinearOrderedSemifield \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\nr c : \u03b1\nn : \u2115\ninst\u271d : NeBot l\nh : Tendsto f l atTop\n\u22a2 Tendsto (fun x => r * f x) l atTop \u2194 0 < r", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u00b9 : LinearOrderedSemifield \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\nr c : \u03b1\nn : \u2115\ninst\u271d : NeBot l\nh : Tendsto f l atTop\nhrf : Tendsto (fun x => r * f x) l atTop\nhr : r \u2264 0\n\u22a2 False"}, {"tactic": "rcases ((h.eventually_ge_atTop 0).and (hrf.eventually_gt_atTop 0)).exists with \u27e8x, hx, hrx\u27e9", "annotated_tactic": ["rcases ((h.eventually_ge_atTop 0).<a>and</a> (hrf.eventually_gt_atTop 0)).<a>exists</a> with \u27e8x, hx, hrx\u27e9", [{"full_name": "Filter.Eventually.and", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1120, 19], "def_end_pos": [1120, 33]}, {"full_name": "Filter.Eventually.exists", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1327, 9], "def_end_pos": [1327, 26]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u00b9 : LinearOrderedSemifield \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\nr c : \u03b1\nn : \u2115\ninst\u271d : NeBot l\nh : Tendsto f l atTop\nhrf : Tendsto (fun x => r * f x) l atTop\nhr : r \u2264 0\n\u22a2 False", "state_after": "case intro.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u00b9 : LinearOrderedSemifield \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\nr c : \u03b1\nn : \u2115\ninst\u271d : NeBot l\nh : Tendsto f l atTop\nhrf : Tendsto (fun x => r * f x) l atTop\nhr : r \u2264 0\nx : \u03b2\nhx : 0 \u2264 f x\nhrx : 0 < r * f x\n\u22a2 False"}, {"tactic": "exact (mul_nonpos_of_nonpos_of_nonneg hr hx).not_lt hrx", "annotated_tactic": ["exact (<a>mul_nonpos_of_nonpos_of_nonneg</a> hr hx).<a>not_lt</a> hrx", [{"full_name": "mul_nonpos_of_nonpos_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [449, 9], "def_end_pos": [449, 39]}, {"full_name": "LE.le.not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [353, 7], "def_end_pos": [353, 19]}]], "state_before": "case intro.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u00b9 : LinearOrderedSemifield \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\nr c : \u03b1\nn : \u2115\ninst\u271d : NeBot l\nh : Tendsto f l atTop\nhrf : Tendsto (fun x => r * f x) l atTop\nhr : r \u2264 0\nx : \u03b2\nhx : 0 \u2264 f x\nhrx : 0 < r * f x\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "full_name": "tsum_dite_left", "start": [476, 1], "end": [478, 32], "traced_tactics": [{"tactic": "by_cases hP : P <;> simp [hP]", "annotated_tactic": ["by_cases hP : P <;> simp [hP]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na a\u2081 a\u2082 : \u03b1\nP : Prop\ninst\u271d : Decidable P\nx : \u03b2 \u2192 P \u2192 \u03b1\n\u22a2 (\u2211' (b : \u03b2), if h : P then x b h else 0) = if h : P then \u2211' (b : \u03b2), x b h else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Nat.ne_of_odd_add", "start": [199, 1], "end": [199, 83], "traced_tactics": [{"tactic": "simp [hnot] at h", "annotated_tactic": ["simp [hnot] at h", []], "state_before": "m n : \u2115\nh : Odd (m + n)\nhnot : m = n\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.ringEquivCongr_refl", "start": [459, 1], "end": [460, 18], "traced_tactics": [{"tactic": "cases a <;> rfl", "annotated_tactic": ["cases a <;> rfl", []], "state_before": "n : \u2115\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : CharP R n\na : \u2115\n\u22a2 ringEquivCongr \u22ef = RingEquiv.refl (ZMod a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "Real.borel_eq_generateFrom_Iic_rat", "start": [1933, 1], "end": [1939, 76], "traced_tactics": [{"tactic": "rw [borel_eq_generateFrom_Ioi_rat, iUnion_singleton_eq_range, iUnion_singleton_eq_range]", "annotated_tactic": ["rw [<a>borel_eq_generateFrom_Ioi_rat</a>, <a>iUnion_singleton_eq_range</a>, <a>iUnion_singleton_eq_range</a>]", [{"full_name": "Real.borel_eq_generateFrom_Ioi_rat", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "def_pos": [1921, 9], "def_end_pos": [1921, 38]}, {"full_name": "Set.iUnion_singleton_eq_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1305, 9], "def_end_pos": [1305, 34]}, {"full_name": "Set.iUnion_singleton_eq_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1305, 9], "def_end_pos": [1305, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\n\u22a2 borel \u211d = MeasurableSpace.generateFrom (\u22c3 a, {Iic \u2191a})", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\n\u22a2 MeasurableSpace.generateFrom (range fun a => Ioi \u2191a) = MeasurableSpace.generateFrom (range fun a => Iic \u2191a)"}, {"tactic": "refine le_antisymm (generateFrom_le ?_) (generateFrom_le ?_) <;>\nrintro _ \u27e8q, rfl\u27e9 <;>\ndsimp only <;>\n[rw [\u2190 compl_Iic]; rw [\u2190 compl_Ioi]] <;>\nexact MeasurableSet.compl (GenerateMeasurable.basic _ (mem_range_self q))", "annotated_tactic": ["refine <a>le_antisymm</a> (<a>generateFrom_le</a> ?_) (<a>generateFrom_le</a> ?_) <;>\n  rintro _ \u27e8q, rfl\u27e9 <;>\n  dsimp only <;>\n  [rw [\u2190 <a>compl_Iic</a>]; rw [\u2190 <a>compl_Ioi</a>]] <;>\n  exact <a>MeasurableSet.compl</a> (<a>GenerateMeasurable.basic</a> _ (<a>mem_range_self</a> q))", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "MeasurableSpace.generateFrom_le", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [393, 9], "def_end_pos": [393, 24]}, {"full_name": "MeasurableSpace.generateFrom_le", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [393, 9], "def_end_pos": [393, 24]}, {"full_name": "Set.compl_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1078, 9], "def_end_pos": [1078, 18]}, {"full_name": "Set.compl_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1093, 9], "def_end_pos": [1093, 18]}, {"full_name": "MeasurableSet.compl", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [88, 19], "def_end_pos": [88, 38]}, {"full_name": "MeasurableSpace.GenerateMeasurable.basic", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [364, 15], "def_end_pos": [364, 20]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\n\u22a2 MeasurableSpace.generateFrom (range fun a => Ioi \u2191a) = MeasurableSpace.generateFrom (range fun a => Iic \u2191a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/EMetricSpace/Basic.lean", "full_name": "EMetric.mem_nhdsWithin_iff", "start": [660, 1], "end": [661, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean", "full_name": "IsBoundedLinearMap.lim_zero_bounded_linear_map", "start": [181, 1], "end": [182, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/PartialHomeomorph.lean", "full_name": "PartialHomeomorph.symm_symm", "start": [364, 21], "end": [364, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Basic.lean", "full_name": "Complex.eq_coe_norm_of_nonneg", "start": [501, 1], "end": [503, 71], "traced_tactics": [{"tactic": "lift z to \u211d using hz.2.symm", "annotated_tactic": ["lift z to \u211d using hz.2.<a>symm</a>", [{"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "z\u271d : \u2102\nE : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nz : \u2102\nhz : 0 \u2264 z\n\u22a2 z = \u2191\u2016z\u2016", "state_after": "case intro\nz\u271d : \u2102\nE : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nz : \u211d\nhz : 0 \u2264 \u2191z\n\u22a2 \u2191z = \u2191\u2016\u2191z\u2016"}, {"tactic": "rw [norm_eq_abs, abs_ofReal, _root_.abs_of_nonneg (id hz.1 : 0 \u2264 z)]", "annotated_tactic": ["rw [<a>norm_eq_abs</a>, <a>abs_ofReal</a>, <a>_root_.abs_of_nonneg</a> (<a>id</a> hz.1 : 0 \u2264 z)]", [{"full_name": "Complex.norm_eq_abs", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Basic.lean", "def_pos": [52, 9], "def_end_pos": [52, 20]}, {"full_name": "Complex.abs_ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Abs.lean", "def_pos": [75, 9], "def_end_pos": [75, 19]}, {"full_name": "abs_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [94, 3], "def_end_pos": [94, 14]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "case intro\nz\u271d : \u2102\nE : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nz : \u211d\nhz : 0 \u2264 \u2191z\n\u22a2 \u2191z = \u2191\u2016\u2191z\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bornology/Hom.lean", "full_name": "LocallyBoundedMap.copy_eq", "start": [110, 1], "end": [111, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Prod.lean", "full_name": "AlgHom.prod_fst_snd", "start": [94, 1], "end": [95, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Addition.lean", "full_name": "HahnSeries.embDomain_add", "start": [112, 1], "end": [118, 36], "traced_tactics": [{"tactic": "ext g", "annotated_tactic": ["ext g", []], "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddMonoid R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\nx y : HahnSeries \u0393 R\n\u22a2 embDomain f (x + y) = embDomain f x + embDomain f y", "state_after": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddMonoid R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\nx y : HahnSeries \u0393 R\ng : \u0393'\n\u22a2 (embDomain f (x + y)).coeff g = (embDomain f x + embDomain f y).coeff g"}, {"tactic": "by_cases hg : g \u2208 Set.range f", "annotated_tactic": ["by_cases hg : g \u2208 <a>Set.range</a> f", [{"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}]], "state_before": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddMonoid R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\nx y : HahnSeries \u0393 R\ng : \u0393'\n\u22a2 (embDomain f (x + y)).coeff g = (embDomain f x + embDomain f y).coeff g", "state_after": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddMonoid R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\nx y : HahnSeries \u0393 R\ng : \u0393'\nhg : g \u2208 Set.range \u21d1f\n\u22a2 (embDomain f (x + y)).coeff g = (embDomain f x + embDomain f y).coeff g\n\ncase neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddMonoid R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\nx y : HahnSeries \u0393 R\ng : \u0393'\nhg : g \u2209 Set.range \u21d1f\n\u22a2 (embDomain f (x + y)).coeff g = (embDomain f x + embDomain f y).coeff g"}, {"tactic": "obtain \u27e8a, rfl\u27e9 := hg", "annotated_tactic": ["obtain \u27e8a, rfl\u27e9 := hg", []], "state_before": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddMonoid R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\nx y : HahnSeries \u0393 R\ng : \u0393'\nhg : g \u2208 Set.range \u21d1f\n\u22a2 (embDomain f (x + y)).coeff g = (embDomain f x + embDomain f y).coeff g", "state_after": "case pos.intro\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddMonoid R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\nx y : HahnSeries \u0393 R\na : \u0393\n\u22a2 (embDomain f (x + y)).coeff (f a) = (embDomain f x + embDomain f y).coeff (f a)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case pos.intro\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddMonoid R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\nx y : HahnSeries \u0393 R\na : \u0393\n\u22a2 (embDomain f (x + y)).coeff (f a) = (embDomain f x + embDomain f y).coeff (f a)", "state_after": "no goals"}, {"tactic": "simp [embDomain_notin_range hg]", "annotated_tactic": ["simp [<a>embDomain_notin_range</a> hg]", [{"full_name": "HahnSeries.embDomain_notin_range", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Basic.lean", "def_pos": [318, 9], "def_end_pos": [318, 30]}]], "state_before": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddMonoid R\n\u0393' : Type u_3\ninst\u271d : PartialOrder \u0393'\nf : \u0393 \u21aao \u0393'\nx y : HahnSeries \u0393 R\ng : \u0393'\nhg : g \u2209 Set.range \u21d1f\n\u22a2 (embDomain f (x + y)).coeff g = (embDomain f x + embDomain f y).coeff g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Cast/Order.lean", "full_name": "Nat.not_ofNat_le_one", "start": [203, 1], "end": [204, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometry.id_apply", "start": [383, 1], "end": [384, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bases.lean", "full_name": "TopologicalSpace.IsTopologicalBasis.open_eq_sUnion'", "start": [182, 1], "end": [188, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Finset.map_erase", "start": [667, 1], "end": [670, 28], "traced_tactics": [{"tactic": "simp_rw [map_eq_image]", "annotated_tactic": ["simp_rw [<a>map_eq_image</a>]", [{"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\ns\u271d : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb c : \u03b2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u21aa \u03b2\ns : Finset \u03b1\na : \u03b1\n\u22a2 map f (erase s a) = erase (map f s) (f a)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\ns\u271d : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb c : \u03b2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u21aa \u03b2\ns : Finset \u03b1\na : \u03b1\n\u22a2 image (\u21d1f) (erase s a) = erase (image (\u21d1f) s) (f a)"}, {"tactic": "exact s.image_erase f.2 a", "annotated_tactic": ["exact s.image_erase f.2 a", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\ns\u271d : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb c : \u03b2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u21aa \u03b2\ns : Finset \u03b1\na : \u03b1\n\u22a2 image (\u21d1f) (erase s a) = erase (image (\u21d1f) s) (f a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Pi/Basic.lean", "full_name": "Subsingleton.pi_mulSingle_eq", "start": [574, 1], "end": [576, 70], "traced_tactics": [{"tactic": "rw [Subsingleton.elim j i, Pi.mulSingle_eq_same]", "annotated_tactic": ["rw [<a>Subsingleton.elim</a> j i, <a>Pi.mulSingle_eq_same</a>]", [{"full_name": "Subsingleton.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1010, 19], "def_end_pos": [1010, 36]}, {"full_name": "Pi.mulSingle_eq_same", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [364, 9], "def_end_pos": [364, 26]}]], "state_before": "I : Type u\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx\u271d y : (i : I) \u2192 f i\ni\u271d : I\n\u03b1 : Type u_4\ninst\u271d\u00b2 : DecidableEq I\ninst\u271d\u00b9 : Subsingleton I\ninst\u271d : One \u03b1\ni : I\nx : \u03b1\nj : I\n\u22a2 Pi.mulSingle i x j = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Monic.lean", "full_name": "Polynomial.Monic.mul_left_ne_zero", "start": [449, 1], "end": [456, 7], "traced_tactics": [{"tactic": "by_cases h : p = 1", "annotated_tactic": ["by_cases h : p = 1", []], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\n\u22a2 q * p \u2260 0", "state_after": "case pos\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : p = 1\n\u22a2 q * p \u2260 0\n\ncase neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : \u00acp = 1\n\u22a2 q * p \u2260 0"}, {"tactic": "rw [Ne.def, \u2190 degree_eq_bot, hp.degree_mul, WithBot.add_eq_bot, not_or, degree_eq_bot]", "annotated_tactic": ["rw [<a>Ne.def</a>, \u2190 <a>degree_eq_bot</a>, hp.degree_mul, <a>WithBot.add_eq_bot</a>, <a>not_or</a>, <a>degree_eq_bot</a>]", [{"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Polynomial.degree_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [120, 9], "def_end_pos": [120, 22]}, {"full_name": "WithBot.add_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/WithTop.lean", "def_pos": [625, 9], "def_end_pos": [625, 19]}, {"full_name": "not_or", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [107, 9], "def_end_pos": [107, 15]}, {"full_name": "Polynomial.degree_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [120, 9], "def_end_pos": [120, 22]}]], "state_before": "case neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : \u00acp = 1\n\u22a2 q * p \u2260 0", "state_after": "case neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : \u00acp = 1\n\u22a2 \u00acq = 0 \u2227 \u00acdegree p = \u22a5"}, {"tactic": "refine' \u27e8hq, _\u27e9", "annotated_tactic": ["refine' \u27e8hq, _\u27e9", []], "state_before": "case neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : \u00acp = 1\n\u22a2 \u00acq = 0 \u2227 \u00acdegree p = \u22a5", "state_after": "case neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : \u00acp = 1\n\u22a2 \u00acdegree p = \u22a5"}, {"tactic": "rw [\u2190 hp.degree_le_zero_iff_eq_one, not_le] at h", "annotated_tactic": ["rw [\u2190 hp.degree_le_zero_iff_eq_one, <a>not_le</a>] at h", [{"full_name": "not_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [367, 9], "def_end_pos": [367, 15]}]], "state_before": "case neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : \u00acp = 1\n\u22a2 \u00acdegree p = \u22a5", "state_after": "case neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : 0 < degree p\n\u22a2 \u00acdegree p = \u22a5"}, {"tactic": "refine' (lt_trans _ h).ne'", "annotated_tactic": ["refine' (<a>lt_trans</a> _ h).<a>ne'</a>", [{"full_name": "lt_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [84, 9], "def_end_pos": [84, 17]}, {"full_name": "LT.lt.ne'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 12]}]], "state_before": "case neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : 0 < degree p\n\u22a2 \u00acdegree p = \u22a5", "state_after": "case neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : 0 < degree p\n\u22a2 \u22a5 < 0"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case neg\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : 0 < degree p\n\u22a2 \u22a5 < 0", "state_after": "no goals"}, {"tactic": "simpa [h]", "annotated_tactic": ["simpa [h]", []], "state_before": "case pos\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np : R[X]\nhp : Monic p\nq : R[X]\nhq : q \u2260 0\nh : p = 1\n\u22a2 q * p \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.exp_sub", "start": [854, 1], "end": [855, 58], "traced_tactics": [{"tactic": "simp [sub_eq_add_neg, exp_add, exp_neg, div_eq_mul_inv]", "annotated_tactic": ["simp [<a>sub_eq_add_neg</a>, <a>exp_add</a>, <a>exp_neg</a>, <a>div_eq_mul_inv</a>]", [{"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}, {"full_name": "Real.exp_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [816, 16], "def_end_pos": [816, 23]}, {"full_name": "Real.exp_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [850, 16], "def_end_pos": [850, 23]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}]], "state_before": "x y : \u211d\n\u22a2 rexp (x - y) = rexp x / rexp y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.eq_prime_pow_of_dvd_least_prime_pow", "start": [703, 1], "end": [707, 97], "traced_tactics": [{"tactic": "obtain \u27e8l, \u27e8h, rfl\u27e9\u27e9 := (dvd_prime_pow pp).1 h\u2082", "annotated_tactic": ["obtain \u27e8l, \u27e8h, rfl\u27e9\u27e9 := (<a>dvd_prime_pow</a> pp).1 h\u2082", [{"full_name": "Nat.dvd_prime_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Prime.lean", "def_pos": [690, 9], "def_end_pos": [690, 22]}]], "state_before": "n a p k : \u2115\npp : Prime p\nh\u2081 : \u00aca \u2223 p ^ k\nh\u2082 : a \u2223 p ^ (k + 1)\n\u22a2 a = p ^ (k + 1)", "state_after": "case intro.intro\nn p k : \u2115\npp : Prime p\nl : \u2115\nh : l \u2264 k + 1\nh\u2081 : \u00acp ^ l \u2223 p ^ k\nh\u2082 : p ^ l \u2223 p ^ (k + 1)\n\u22a2 p ^ l = p ^ (k + 1)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case intro.intro\nn p k : \u2115\npp : Prime p\nl : \u2115\nh : l \u2264 k + 1\nh\u2081 : \u00acp ^ l \u2223 p ^ k\nh\u2082 : p ^ l \u2223 p ^ (k + 1)\n\u22a2 p ^ l = p ^ (k + 1)", "state_after": "case intro.intro.e_a\nn p k : \u2115\npp : Prime p\nl : \u2115\nh : l \u2264 k + 1\nh\u2081 : \u00acp ^ l \u2223 p ^ k\nh\u2082 : p ^ l \u2223 p ^ (k + 1)\n\u22a2 l = k + 1"}, {"tactic": "exact le_antisymm h (not_le.1 ((not_congr (pow_dvd_pow_iff_le_right (Prime.one_lt pp))).1 h\u2081))", "annotated_tactic": ["exact <a>le_antisymm</a> h (<a>not_le</a>.1 ((<a>not_congr</a> (<a>pow_dvd_pow_iff_le_right</a> (<a>Prime.one_lt</a> pp))).1 h\u2081))", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "not_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [367, 9], "def_end_pos": [367, 15]}, {"full_name": "not_congr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1337, 9], "def_end_pos": [1337, 18]}, {"full_name": "Nat.pow_dvd_pow_iff_le_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [934, 9], "def_end_pos": [934, 33]}, {"full_name": "Nat.Prime.one_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Prime.lean", "def_pos": [77, 9], "def_end_pos": [77, 21]}]], "state_before": "case intro.intro.e_a\nn p k : \u2115\npp : Prime p\nl : \u2115\nh : l \u2264 k + 1\nh\u2081 : \u00acp ^ l \u2223 p ^ k\nh\u2082 : p ^ l \u2223 p ^ (k + 1)\n\u22a2 l = k + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "Disjoint.eq_bot_of_le", "start": [97, 1], "end": [98, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/EpiMono.lean", "full_name": "CategoryTheory.IsIso.of_epi_section", "start": [200, 1], "end": [202, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.roots_prod", "start": [855, 1], "end": [858, 91], "traced_tactics": [{"tactic": "rcases s with \u27e8m, hm\u27e9", "annotated_tactic": ["rcases s with \u27e8m, hm\u27e9", []], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\n\u03b9 : Type u_1\nf : \u03b9 \u2192 R[X]\ns : Finset \u03b9\n\u22a2 Finset.prod s f \u2260 0 \u2192 roots (Finset.prod s f) = Multiset.bind s.val fun i => roots (f i)", "state_after": "case mk\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\n\u03b9 : Type u_1\nf : \u03b9 \u2192 R[X]\nm : Multiset \u03b9\nhm : Nodup m\n\u22a2 Finset.prod { val := m, nodup := hm } f \u2260 0 \u2192\n    roots (Finset.prod { val := m, nodup := hm } f) = Multiset.bind { val := m, nodup := hm }.val fun i => roots (f i)"}, {"tactic": "simpa [Multiset.prod_eq_zero_iff, Multiset.bind_map] using roots_multiset_prod (m.map f)", "annotated_tactic": ["simpa [<a>Multiset.prod_eq_zero_iff</a>, <a>Multiset.bind_map</a>] using <a>roots_multiset_prod</a> (m.map f)", [{"full_name": "Multiset.prod_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [291, 9], "def_end_pos": [291, 25]}, {"full_name": "Multiset.bind_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Bind.lean", "def_pos": [166, 9], "def_end_pos": [166, 17]}, {"full_name": "Polynomial.roots_multiset_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [850, 9], "def_end_pos": [850, 28]}]], "state_before": "case mk\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\n\u03b9 : Type u_1\nf : \u03b9 \u2192 R[X]\nm : Multiset \u03b9\nhm : Nodup m\n\u22a2 Finset.prod { val := m, nodup := hm } f \u2260 0 \u2192\n    roots (Finset.prod { val := m, nodup := hm } f) = Multiset.bind { val := m, nodup := hm }.val fun i => roots (f i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Basic.lean", "full_name": "Pi.compl_apply", "start": [879, 1], "end": [881, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/Basic.lean", "full_name": "Mathlib.Meta.NormNum.ble_eq_false", "start": [472, 1], "end": [473, 52], "traced_tactics": [{"tactic": "rw [\u2190 Nat.not_le, \u2190 Bool.not_eq_true, Nat.ble_eq]", "annotated_tactic": ["rw [\u2190 <a>Nat.not_le</a>, \u2190 <a>Bool.not_eq_true</a>, <a>Nat.ble_eq</a>]", [{"full_name": "Nat.not_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [376, 27], "def_end_pos": [376, 33]}, {"full_name": "Bool.not_eq_true", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [212, 17], "def_end_pos": [212, 33]}, {"full_name": "Nat.ble_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [97, 17], "def_end_pos": [97, 23]}]], "state_before": "x y : \u2115\n\u22a2 Nat.ble x y = false \u2194 y < x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "sdiff_le_sdiff", "start": [622, 1], "end": [623, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "RingHom.mapMatrix_id", "start": [1545, 1], "end": [1546, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Pairwise.lean", "full_name": "List.pairwise_replicate", "start": [249, 1], "end": [252, 66], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx : \u03b1\nhx : r x x\n\u22a2 Pairwise r (replicate 0 x)", "state_after": "no goals"}, {"tactic": "simp [mem_replicate, hx, pairwise_replicate hx n]", "annotated_tactic": ["simp [<a>mem_replicate</a>, hx, pairwise_replicate hx n]", [{"full_name": "List.mem_replicate", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [459, 9], "def_end_pos": [459, 22]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx : \u03b1\nhx : r x x\nn : Nat\n\u22a2 Pairwise r (replicate (n + 1) x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/Over.lean", "full_name": "CategoryTheory.Over.map_obj_left", "start": [172, 1], "end": [173, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.tail_add", "start": [498, 1], "end": [499, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Basic.lean", "full_name": "Complex.nnnorm_nat", "start": [200, 1], "end": [201, 25], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "z : \u2102\nE : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nn : \u2115\n\u22a2 \u2191\u2016\u2191n\u2016\u208a = \u2191\u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "vectorSpan_singleton", "start": [86, 1], "end": [86, 98], "traced_tactics": [{"tactic": "simp [vectorSpan_def]", "annotated_tactic": ["simp [<a>vectorSpan_def</a>]", [{"full_name": "vectorSpan_def", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [65, 9], "def_end_pos": [65, 23]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\np : P\n\u22a2 vectorSpan k {p} = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.take_left", "start": [1935, 1], "end": [1937, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Complex.cos_add_nat_mul_two_pi", "start": [1215, 1], "end": [1216, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.lt_ceil", "start": [1199, 1], "end": [1200, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Algebra/Classes.lean", "full_name": "trichotomous_of", "start": [364, 1], "end": [365, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/EraseLead.lean", "full_name": "Polynomial.mono_map_natDegree_eq", "start": [323, 1], "end": [341, 43], "traced_tactics": [{"tactic": "refine' induction_with_natDegree_le (fun p => (\u03c6 p).natDegree = fu p.natDegree)\n  p.natDegree (by simp [fu0]) _ _ _ rfl.le", "annotated_tactic": ["refine' <a>induction_with_natDegree_le</a> (fun p => (\u03c6 p).<a>natDegree</a> = fu p.natDegree)\n    p.natDegree (by simp [fu0]) _ _ _ rfl.le", [{"full_name": "Polynomial.induction_with_natDegree_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/EraseLead.lean", "def_pos": [286, 9], "def_end_pos": [286, 36]}, {"full_name": "Polynomial.natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [69, 5], "def_end_pos": [69, 14]}]], "state_before": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\nf : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\n\u22a2 natDegree (\u03c6 p) = fu (natDegree p)", "state_after": "case refine'_1\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\n\u22a2 \u2200 (n : \u2115) (r : R), r \u2260 0 \u2192 n \u2264 natDegree p \u2192 (fun p => natDegree (\u03c6 p) = fu (natDegree p)) (C r * X ^ n)\n\ncase refine'_2\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\n\u22a2 \u2200 (f g : R[X]),\n    natDegree f < natDegree g \u2192\n      natDegree g \u2264 natDegree p \u2192\n        (fun p => natDegree (\u03c6 p) = fu (natDegree p)) f \u2192\n          (fun p => natDegree (\u03c6 p) = fu (natDegree p)) g \u2192 (fun p => natDegree (\u03c6 p) = fu (natDegree p)) (f + g)"}, {"tactic": "simp [fu0]", "annotated_tactic": ["simp [fu0]", []], "state_before": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\nf : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\n\u22a2 (fun p => natDegree (\u03c6 p) = fu (natDegree p)) 0", "state_after": "no goals"}, {"tactic": "intro n r r0 _", "annotated_tactic": ["intro n r r0 _", []], "state_before": "case refine'_1\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\n\u22a2 \u2200 (n : \u2115) (r : R), r \u2260 0 \u2192 n \u2264 natDegree p \u2192 (fun p => natDegree (\u03c6 p) = fu (natDegree p)) (C r * X ^ n)", "state_after": "case refine'_1\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nn : \u2115\nr : R\nr0 : r \u2260 0\na\u271d : n \u2264 natDegree p\n\u22a2 natDegree (\u03c6 (C r * X ^ n)) = fu (natDegree (C r * X ^ n))"}, {"tactic": "rw [natDegree_C_mul_X_pow _ _ r0, C_mul_X_pow_eq_monomial, \u03c6_mon_nat _ _ r0]", "annotated_tactic": ["rw [<a>natDegree_C_mul_X_pow</a> _ _ r0, <a>C_mul_X_pow_eq_monomial</a>, \u03c6_mon_nat _ _ r0]", [{"full_name": "Polynomial.natDegree_C_mul_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [317, 9], "def_end_pos": [317, 30]}, {"full_name": "Polynomial.C_mul_X_pow_eq_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [774, 9], "def_end_pos": [774, 32]}]], "state_before": "case refine'_1\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nn : \u2115\nr : R\nr0 : r \u2260 0\na\u271d : n \u2264 natDegree p\n\u22a2 natDegree (\u03c6 (C r * X ^ n)) = fu (natDegree (C r * X ^ n))", "state_after": "no goals"}, {"tactic": "intro f g fg _ fk gk", "annotated_tactic": ["intro f g fg _ fk gk", []], "state_before": "case refine'_2\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\n\u22a2 \u2200 (f g : R[X]),\n    natDegree f < natDegree g \u2192\n      natDegree g \u2264 natDegree p \u2192\n        (fun p => natDegree (\u03c6 p) = fu (natDegree p)) f \u2192\n          (fun p => natDegree (\u03c6 p) = fu (natDegree p)) g \u2192 (fun p => natDegree (\u03c6 p) = fu (natDegree p)) (f + g)", "state_after": "case refine'_2\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\n\u22a2 natDegree (\u03c6 (f + g)) = fu (natDegree (f + g))"}, {"tactic": "rw [natDegree_add_eq_right_of_natDegree_lt fg, _root_.map_add]", "annotated_tactic": ["rw [<a>natDegree_add_eq_right_of_natDegree_lt</a> fg, <a>_root_.map_add</a>]", [{"full_name": "Polynomial.natDegree_add_eq_right_of_natDegree_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [730, 9], "def_end_pos": [730, 47]}, {"full_name": "map_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [307, 3], "def_end_pos": [307, 14]}]], "state_before": "case refine'_2\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\n\u22a2 natDegree (\u03c6 (f + g)) = fu (natDegree (f + g))", "state_after": "case refine'_2\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)"}, {"tactic": "by_cases FG : k \u2264 f.natDegree", "annotated_tactic": ["by_cases FG : k \u2264 f.natDegree", []], "state_before": "case refine'_2\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)", "state_after": "case pos\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nFG : k \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)\n\ncase neg\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nFG : \u00ack \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)"}, {"tactic": "rw [natDegree_add_eq_right_of_natDegree_lt, gk]", "annotated_tactic": ["rw [<a>natDegree_add_eq_right_of_natDegree_lt</a>, gk]", [{"full_name": "Polynomial.natDegree_add_eq_right_of_natDegree_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [730, 9], "def_end_pos": [730, 47]}]], "state_before": "case pos\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nFG : k \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)", "state_after": "case pos\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nFG : k \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f) < natDegree (\u03c6 g)"}, {"tactic": "rw [fk, gk]", "annotated_tactic": ["rw [fk, gk]", []], "state_before": "case pos\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nFG : k \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f) < natDegree (\u03c6 g)", "state_after": "case pos\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nFG : k \u2264 natDegree f\n\u22a2 fu (natDegree f) < fu (natDegree g)"}, {"tactic": "exact fc FG fg", "annotated_tactic": ["exact fc FG fg", []], "state_before": "case pos\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nFG : k \u2264 natDegree f\n\u22a2 fu (natDegree f) < fu (natDegree g)", "state_after": "no goals"}, {"tactic": "cases k", "annotated_tactic": ["cases k", []], "state_before": "case neg\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nk : \u2115\nfu : \u2115 \u2192 \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 k \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, k \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < k \u2192 \u03c6 f = 0\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nFG : \u00ack \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)", "state_after": "case neg.zero\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nfu : \u2115 \u2192 \u2115\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nfu0 : \u2200 {n : \u2115}, n \u2264 Nat.zero \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, Nat.zero \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < Nat.zero \u2192 \u03c6 f = 0\nFG : \u00acNat.zero \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)\n\ncase neg.succ\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nfu : \u2115 \u2192 \u2115\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nn\u271d : \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 Nat.succ n\u271d \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, Nat.succ n\u271d \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < Nat.succ n\u271d \u2192 \u03c6 f = 0\nFG : \u00acNat.succ n\u271d \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)"}, {"tactic": "exact (FG (Nat.zero_le _)).elim", "annotated_tactic": ["exact (FG (<a>Nat.zero_le</a> _)).<a>elim</a>", [{"full_name": "Nat.zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1644, 9], "def_end_pos": [1644, 20]}, {"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}]], "state_before": "case neg.zero\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nfu : \u2115 \u2192 \u2115\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nfu0 : \u2200 {n : \u2115}, n \u2264 Nat.zero \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, Nat.zero \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < Nat.zero \u2192 \u03c6 f = 0\nFG : \u00acNat.zero \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)", "state_after": "no goals"}, {"tactic": "rwa [\u03c6_k (not_le.mp FG), zero_add]", "annotated_tactic": ["rwa [\u03c6_k (not_le.mp FG), <a>zero_add</a>]", [{"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "case neg.succ\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\nf\u271d : R[X]\nS : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R[X] S[X]\ninst\u271d : AddMonoidHomClass F R[X] S[X]\n\u03c6 : F\np : R[X]\nfu : \u2115 \u2192 \u2115\n\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 natDegree (\u03c6 ((monomial n) c)) = fu n\nf g : R[X]\nfg : natDegree f < natDegree g\na\u271d : natDegree g \u2264 natDegree p\nfk : natDegree (\u03c6 f) = fu (natDegree f)\ngk : natDegree (\u03c6 g) = fu (natDegree g)\nn\u271d : \u2115\nfu0 : \u2200 {n : \u2115}, n \u2264 Nat.succ n\u271d \u2192 fu n = 0\nfc : \u2200 {n m : \u2115}, Nat.succ n\u271d \u2264 n \u2192 n < m \u2192 fu n < fu m\n\u03c6_k : \u2200 {f : R[X]}, natDegree f < Nat.succ n\u271d \u2192 \u03c6 f = 0\nFG : \u00acNat.succ n\u271d \u2264 natDegree f\n\u22a2 natDegree (\u03c6 f + \u03c6 g) = fu (natDegree g)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.pair_mem_product", "start": [1738, 1], "end": [1741, 47], "traced_tactics": [{"tactic": "simp only [product, and_imp, exists_prop, mem_map, Prod.mk.injEq,\n  exists_eq_right_right, mem_bind, iff_self]", "annotated_tactic": ["simp only [<a>product</a>, <a>and_imp</a>, <a>exists_prop</a>, <a>mem_map</a>, Prod.mk.injEq,\n    <a>exists_eq_right_right</a>, <a>mem_bind</a>, <a>iff_self</a>]", [{"full_name": "List.product", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [941, 5], "def_end_pos": [941, 12]}, {"full_name": "and_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [108, 17], "def_end_pos": [108, 24]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "List.mem_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [127, 17], "def_end_pos": [127, 24]}, {"full_name": "exists_eq_right_right", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [234, 17], "def_end_pos": [234, 38]}, {"full_name": "List.mem_bind", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [370, 9], "def_end_pos": [370, 17]}, {"full_name": "iff_self", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [115, 17], "def_end_pos": [115, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nxs : List \u03b1\nys : List \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 product xs ys \u2194 x \u2208 xs \u2227 y \u2208 ys", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "ContDiffOn.continuousOn_fderivWithin", "start": [1210, 1], "end": [1212, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Minimal.lean", "full_name": "RelEmbedding.image_minimals_eq", "start": [332, 1], "end": [334, 59], "traced_tactics": [{"tactic": "rw [image_minimals_of_rel_iff_rel]", "annotated_tactic": ["rw [<a>image_minimals_of_rel_iff_rel</a>]", [{"full_name": "image_minimals_of_rel_iff_rel", "def_path": ".lake/packages/mathlib/Mathlib/Order/Minimal.lean", "def_pos": [322, 9], "def_end_pos": [322, 38]}]], "state_before": "\u03b2 : Type u_2\n\u03b1 : Type u_1\nr\u271d r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d t : Set \u03b1\na b : \u03b1\ninst\u271d : PartialOrder \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : r \u21aar s\nx : Set \u03b1\n\u22a2 \u21d1f '' minimals r x = minimals s (\u21d1f '' x)", "state_after": "\u03b2 : Type u_2\n\u03b1 : Type u_1\nr\u271d r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d t : Set \u03b1\na b : \u03b1\ninst\u271d : PartialOrder \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : r \u21aar s\nx : Set \u03b1\n\u22a2 \u2200 \u2983a a' : \u03b1\u2984, a \u2208 x \u2192 a' \u2208 x \u2192 (r a a' \u2194 s (f a) (f a'))"}, {"tactic": "simp [f.map_rel_iff]", "annotated_tactic": ["simp [f.map_rel_iff]", []], "state_before": "\u03b2 : Type u_2\n\u03b1 : Type u_1\nr\u271d r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d t : Set \u03b1\na b : \u03b1\ninst\u271d : PartialOrder \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : r \u21aar s\nx : Set \u03b1\n\u22a2 \u2200 \u2983a a' : \u03b1\u2984, a \u2208 x \u2192 a' \u2208 x \u2192 (r a a' \u2194 s (f a) (f a'))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Cast/Basic.lean", "full_name": "Nat.cast_pow", "start": [82, 1], "end": [85, 80], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Semiring \u03b1\nm\u271d n m : \u2115\n\u22a2 \u2191(m ^ 0) = \u2191m ^ 0", "state_after": "no goals"}, {"tactic": "rw [_root_.pow_succ', _root_.pow_succ', cast_mul, cast_pow m n]", "annotated_tactic": ["rw [<a>_root_.pow_succ'</a>, <a>_root_.pow_succ'</a>, <a>cast_mul</a>, cast_pow m n]", [{"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}, {"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}, {"full_name": "Nat.cast_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [52, 26], "def_end_pos": [52, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Semiring \u03b1\nm\u271d n\u271d m n : \u2115\n\u22a2 \u2191(m ^ (n + 1)) = \u2191m ^ (n + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/List.lean", "full_name": "List.formPerm_rotate", "start": [279, 1], "end": [285, 31], "traced_tactics": [{"tactic": "induction' n with n hn", "annotated_tactic": ["induction' n with n hn", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nn : \u2115\n\u22a2 formPerm (rotate l n) = formPerm l", "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\n\u22a2 formPerm (rotate l Nat.zero) = formPerm l\n\ncase succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nn : \u2115\nhn : formPerm (rotate l n) = formPerm l\n\u22a2 formPerm (rotate l (Nat.succ n)) = formPerm l"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\n\u22a2 formPerm (rotate l Nat.zero) = formPerm l", "state_after": "no goals"}, {"tactic": "rw [Nat.succ_eq_add_one, \u2190 rotate_rotate, formPerm_rotate_one, hn]", "annotated_tactic": ["rw [<a>Nat.succ_eq_add_one</a>, \u2190 <a>rotate_rotate</a>, <a>formPerm_rotate_one</a>, hn]", [{"full_name": "Nat.succ_eq_add_one", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 24]}, {"full_name": "List.rotate_rotate", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [159, 9], "def_end_pos": [159, 22]}, {"full_name": "List.formPerm_rotate_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/List.lean", "def_pos": [268, 9], "def_end_pos": [268, 28]}]], "state_before": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nn : \u2115\nhn : formPerm (rotate l n) = formPerm l\n\u22a2 formPerm (rotate l (Nat.succ n)) = formPerm l", "state_after": "case succ.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nn : \u2115\nhn : formPerm (rotate l n) = formPerm l\n\u22a2 Nodup (rotate l n)"}, {"tactic": "rwa [IsRotated.nodup_iff]", "annotated_tactic": ["rwa [<a>IsRotated.nodup_iff</a>]", [{"full_name": "List.IsRotated.nodup_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [479, 9], "def_end_pos": [479, 28]}]], "state_before": "case succ.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nn : \u2115\nhn : formPerm (rotate l n) = formPerm l\n\u22a2 Nodup (rotate l n)", "state_after": "case succ.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nn : \u2115\nhn : formPerm (rotate l n) = formPerm l\n\u22a2 rotate l n ~r l"}, {"tactic": "exact IsRotated.forall l n", "annotated_tactic": ["exact <a>IsRotated.forall</a> l n", [{"full_name": "List.IsRotated.forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [456, 19], "def_end_pos": [456, 35]}]], "state_before": "case succ.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nn : \u2115\nhn : formPerm (rotate l n) = formPerm l\n\u22a2 rotate l n ~r l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Subsemiring.list_sum_mem", "start": [297, 11], "end": [298, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/StructuredArrow.lean", "full_name": "CategoryTheory.CostructuredArrow.IsUniversal.existsUnique", "start": [707, 1], "end": [709, 58], "traced_tactics": [{"tactic": "simp [w]", "annotated_tactic": ["simp [w]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nT T' T'' : D\nY Y' Y'' : C\nS S' : C \u2964 D\nA : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} A\nB : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} B\nf\u271d g\u271d : CostructuredArrow S T\nh : IsUniversal f\u271d\ng : CostructuredArrow S T\nf : g.left \u27f6 f\u271d.left\nw : (fun \u03b7 => S.map \u03b7 \u226b f\u271d.hom = g.hom) f\n\u22a2 S.map f \u226b f\u271d.hom = S.map (lift h g) \u226b f\u271d.hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Ray.lean", "full_name": "sameRay_neg_smul_right_iff_of_ne", "start": [561, 1], "end": [563, 73], "traced_tactics": [{"tactic": "simp only [sameRay_neg_smul_right_iff, hv, or_false_iff, hr.le_iff_lt]", "annotated_tactic": ["simp only [<a>sameRay_neg_smul_right_iff</a>, hv, <a>or_false_iff</a>, hr.le_iff_lt]", [{"full_name": "sameRay_neg_smul_right_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Ray.lean", "def_pos": [557, 9], "def_end_pos": [557, 35]}, {"full_name": "or_false_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [180, 9], "def_end_pos": [180, 21]}]], "state_before": "R : Type u_1\ninst\u271d\u00b3 : LinearOrderedCommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nv : M\nr : R\nhv : v \u2260 0\nhr : r \u2260 0\n\u22a2 SameRay R (-v) (r \u2022 v) \u2194 r < 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "le_of_mul_le_of_one_le", "start": [1043, 1], "end": [1044, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Lift.lean", "full_name": "Filter.map_lift_eq2", "start": [131, 1], "end": [133, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.IsRotated.mem_iff", "start": [483, 1], "end": [484, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/WithBotTop.lean", "full_name": "WithBot.preimage_coe_Ioi_bot", "start": [183, 1], "end": [184, 35], "traced_tactics": [{"tactic": "rw [\u2190 range_coe, preimage_range]", "annotated_tactic": ["rw [\u2190 <a>range_coe</a>, <a>preimage_range</a>]", [{"full_name": "WithBot.range_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/WithBotTop.lean", "def_pos": [142, 9], "def_end_pos": [142, 18]}, {"full_name": "Set.preimage_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1092, 9], "def_end_pos": [1092, 23]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' Ioi \u22a5 = univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Pow.lean", "full_name": "hasDerivAt_pow", "start": [54, 1], "end": [56, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.pi_subset_pi_iff", "start": [928, 1], "end": [934, 45], "traced_tactics": [{"tactic": "refine'\n  \u27e8fun h => or_iff_not_imp_right.2 _, fun h => h.elim pi_mono fun h' => h'.symm \u25b8 empty_subset _\u27e9", "annotated_tactic": ["refine'\n    \u27e8fun h => <a>or_iff_not_imp_right</a>.2 _, fun h => h.elim <a>pi_mono</a> fun h' => h'.symm \u25b8 <a>empty_subset</a> _\u27e9", [{"full_name": "Classical.or_iff_not_imp_right", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [142, 9], "def_end_pos": [142, 29]}, {"full_name": "Set.pi_mono", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [727, 9], "def_end_pos": [727, 16]}, {"full_name": "Set.empty_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [548, 9], "def_end_pos": [548, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\n\u22a2 pi s t\u2081 \u2286 pi s t\u2082 \u2194 (\u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i) \u2228 pi s t\u2081 = \u2205", "state_after": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\n\u22a2 \u00acpi s t\u2081 = \u2205 \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i"}, {"tactic": "rw [\u2190 Ne.def, \u2190 nonempty_iff_ne_empty]", "annotated_tactic": ["rw [\u2190 <a>Ne.def</a>, \u2190 <a>nonempty_iff_ne_empty</a>]", [{"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Set.nonempty_iff_ne_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [584, 9], "def_end_pos": [584, 30]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\n\u22a2 \u00acpi s t\u2081 = \u2205 \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i", "state_after": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\n\u22a2 Set.Nonempty (pi s t\u2081) \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i"}, {"tactic": "intro hne i hi", "annotated_tactic": ["intro hne i hi", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\n\u22a2 Set.Nonempty (pi s t\u2081) \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i", "state_after": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni\u271d : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\nhne : Set.Nonempty (pi s t\u2081)\ni : \u03b9\nhi : i \u2208 s\n\u22a2 t\u2081 i \u2286 t\u2082 i"}, {"tactic": "simpa only [eval_image_pi hi hne, eval_image_pi hi (hne.mono h)] using\n  image_subset (fun f : \u2200 i, \u03b1 i => f i) h", "annotated_tactic": ["simpa only [<a>eval_image_pi</a> hi hne, <a>eval_image_pi</a> hi (hne.mono h)] using\n    <a>image_subset</a> (fun f : \u2200 i, \u03b1 i => f i) h", [{"full_name": "Set.eval_image_pi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [918, 9], "def_end_pos": [918, 22]}, {"full_name": "Set.eval_image_pi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [918, 9], "def_end_pos": [918, 22]}, {"full_name": "Set.image_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [293, 9], "def_end_pos": [293, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni\u271d : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\nhne : Set.Nonempty (pi s t\u2081)\ni : \u03b9\nhi : i \u2208 s\n\u22a2 t\u2081 i \u2286 t\u2082 i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "full_name": "Equiv.Perm.mem_cycleType_iff", "start": [290, 1], "end": [302, 38], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\n\u03c3 : Perm \u03b1\n\u22a2 n \u2208 cycleType \u03c3 \u2194 \u2203 c \u03c4, \u03c3 = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\n\u03c3 : Perm \u03b1\n\u22a2 n \u2208 cycleType \u03c3 \u2192 \u2203 c \u03c4, \u03c3 = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n\n\ncase mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\n\u03c3 : Perm \u03b1\n\u22a2 (\u2203 c \u03c4, \u03c3 = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n) \u2192 n \u2208 cycleType \u03c3"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\n\u03c3 : Perm \u03b1\n\u22a2 n \u2208 cycleType \u03c3 \u2192 \u2203 c \u03c4, \u03c3 = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\n\u03c3 : Perm \u03b1\nh : n \u2208 cycleType \u03c3\n\u22a2 \u2203 c \u03c4, \u03c3 = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n"}, {"tactic": "obtain \u27e8l, rfl, hlc, hld\u27e9 := truncCycleFactors \u03c3", "annotated_tactic": ["obtain \u27e8l, rfl, hlc, hld\u27e9 := <a>truncCycleFactors</a> \u03c3", [{"full_name": "Equiv.Perm.truncCycleFactors", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "def_pos": [420, 5], "def_end_pos": [420, 22]}]], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\n\u03c3 : Perm \u03b1\nh : n \u2208 cycleType \u03c3\n\u22a2 \u2203 c \u03c4, \u03c3 = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n", "state_after": "case mp.mk.mk.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\nl : List (Perm \u03b1)\nh : n \u2208 cycleType (List.prod l)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nhld : List.Pairwise Disjoint l\n\u22a2 \u2203 c \u03c4, List.prod l = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n"}, {"tactic": "rw [cycleType_eq _ rfl hlc hld, Multiset.mem_coe, List.mem_map] at h", "annotated_tactic": ["rw [<a>cycleType_eq</a> _ <a>rfl</a> hlc hld, <a>Multiset.mem_coe</a>, <a>List.mem_map</a>] at h", [{"full_name": "Equiv.Perm.cycleType_eq", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Type.lean", "def_pos": [67, 9], "def_end_pos": [67, 21]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Multiset.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [232, 9], "def_end_pos": [232, 16]}, {"full_name": "List.mem_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [127, 17], "def_end_pos": [127, 24]}]], "state_before": "case mp.mk.mk.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\nl : List (Perm \u03b1)\nh : n \u2208 cycleType (List.prod l)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nhld : List.Pairwise Disjoint l\n\u22a2 \u2203 c \u03c4, List.prod l = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n", "state_after": "case mp.mk.mk.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\nl : List (Perm \u03b1)\nh : \u2203 a \u2208 l, (Finset.card \u2218 support) a = n\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nhld : List.Pairwise Disjoint l\n\u22a2 \u2203 c \u03c4, List.prod l = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n"}, {"tactic": "obtain \u27e8c, cl, rfl\u27e9 := h", "annotated_tactic": ["obtain \u27e8c, cl, rfl\u27e9 := h", []], "state_before": "case mp.mk.mk.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\nl : List (Perm \u03b1)\nh : \u2203 a \u2208 l, (Finset.card \u2218 support) a = n\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nhld : List.Pairwise Disjoint l\n\u22a2 \u2203 c \u03c4, List.prod l = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n", "state_after": "case mp.mk.mk.intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List (Perm \u03b1)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nhld : List.Pairwise Disjoint l\nc : Perm \u03b1\ncl : c \u2208 l\n\u22a2 \u2203 c_1 \u03c4, List.prod l = c_1 * \u03c4 \u2227 Disjoint c_1 \u03c4 \u2227 IsCycle c_1 \u2227 (support c_1).card = (Finset.card \u2218 support) c"}, {"tactic": "rw [(List.perm_cons_erase cl).pairwise_iff @(Disjoint.symmetric)] at hld", "annotated_tactic": ["rw [(<a>List.perm_cons_erase</a> cl).<a>pairwise_iff</a> @(<a>Disjoint.symmetric</a>)] at hld", [{"full_name": "List.perm_cons_erase", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [150, 9], "def_end_pos": [150, 24]}, {"full_name": "List.Perm.pairwise_iff", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [662, 9], "def_end_pos": [662, 26]}, {"full_name": "Equiv.Perm.Disjoint.symmetric", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [53, 9], "def_end_pos": [53, 27]}]], "state_before": "case mp.mk.mk.intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List (Perm \u03b1)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nhld : List.Pairwise Disjoint l\nc : Perm \u03b1\ncl : c \u2208 l\n\u22a2 \u2203 c_1 \u03c4, List.prod l = c_1 * \u03c4 \u2227 Disjoint c_1 \u03c4 \u2227 IsCycle c_1 \u2227 (support c_1).card = (Finset.card \u2218 support) c", "state_after": "case mp.mk.mk.intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List (Perm \u03b1)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nc : Perm \u03b1\nhld : List.Pairwise (fun x y => Disjoint x y) (c :: List.erase l c)\ncl : c \u2208 l\n\u22a2 \u2203 c_1 \u03c4, List.prod l = c_1 * \u03c4 \u2227 Disjoint c_1 \u03c4 \u2227 IsCycle c_1 \u2227 (support c_1).card = (Finset.card \u2218 support) c"}, {"tactic": "refine' \u27e8c, (l.erase c).prod, _, _, hlc _ cl, rfl\u27e9", "annotated_tactic": ["refine' \u27e8c, (l.erase c).<a>prod</a>, _, _, hlc _ cl, <a>rfl</a>\u27e9", [{"full_name": "List.prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Defs.lean", "def_pos": [21, 5], "def_end_pos": [21, 9]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case mp.mk.mk.intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List (Perm \u03b1)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nc : Perm \u03b1\nhld : List.Pairwise (fun x y => Disjoint x y) (c :: List.erase l c)\ncl : c \u2208 l\n\u22a2 \u2203 c_1 \u03c4, List.prod l = c_1 * \u03c4 \u2227 Disjoint c_1 \u03c4 \u2227 IsCycle c_1 \u2227 (support c_1).card = (Finset.card \u2218 support) c", "state_after": "case mp.mk.mk.intro.intro.intro.intro.refine'_1\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List (Perm \u03b1)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nc : Perm \u03b1\nhld : List.Pairwise (fun x y => Disjoint x y) (c :: List.erase l c)\ncl : c \u2208 l\n\u22a2 List.prod l = c * List.prod (List.erase l c)\n\ncase mp.mk.mk.intro.intro.intro.intro.refine'_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List (Perm \u03b1)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nc : Perm \u03b1\nhld : List.Pairwise (fun x y => Disjoint x y) (c :: List.erase l c)\ncl : c \u2208 l\n\u22a2 Disjoint c (List.prod (List.erase l c))"}, {"tactic": "rw [\u2190 List.prod_cons, (List.perm_cons_erase cl).symm.prod_eq' (hld.imp Disjoint.commute)]", "annotated_tactic": ["rw [\u2190 <a>List.prod_cons</a>, (<a>List.perm_cons_erase</a> cl).symm.prod_eq' (hld.imp <a>Disjoint.commute</a>)]", [{"full_name": "List.prod_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [43, 9], "def_end_pos": [43, 18]}, {"full_name": "List.perm_cons_erase", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [150, 9], "def_end_pos": [150, 24]}, {"full_name": "Equiv.Perm.Disjoint.commute", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [63, 9], "def_end_pos": [63, 25]}]], "state_before": "case mp.mk.mk.intro.intro.intro.intro.refine'_1\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List (Perm \u03b1)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nc : Perm \u03b1\nhld : List.Pairwise (fun x y => Disjoint x y) (c :: List.erase l c)\ncl : c \u2208 l\n\u22a2 List.prod l = c * List.prod (List.erase l c)", "state_after": "no goals"}, {"tactic": "exact disjoint_prod_right _ fun g => List.rel_of_pairwise_cons hld", "annotated_tactic": ["exact <a>disjoint_prod_right</a> _ fun g => <a>List.rel_of_pairwise_cons</a> hld", [{"full_name": "Equiv.Perm.disjoint_prod_right", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [130, 9], "def_end_pos": [130, 28]}, {"full_name": "List.rel_of_pairwise_cons", "def_path": ".lake/packages/std/Std/Data/List/Pairwise.lean", "def_pos": [33, 9], "def_end_pos": [33, 29]}]], "state_before": "case mp.mk.mk.intro.intro.intro.intro.refine'_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List (Perm \u03b1)\nx\u271d : Trunc { l_1 // List.prod l_1 = List.prod l \u2227 (\u2200 g \u2208 l_1, IsCycle g) \u2227 List.Pairwise Disjoint l_1 }\nhlc : \u2200 g \u2208 l, IsCycle g\nc : Perm \u03b1\nhld : List.Pairwise (fun x y => Disjoint x y) (c :: List.erase l c)\ncl : c \u2208 l\n\u22a2 Disjoint c (List.prod (List.erase l c))", "state_after": "no goals"}, {"tactic": "rintro \u27e8c, t, rfl, hd, hc, rfl\u27e9", "annotated_tactic": ["rintro \u27e8c, t, rfl, hd, hc, rfl\u27e9", []], "state_before": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nn : \u2115\n\u03c3 : Perm \u03b1\n\u22a2 (\u2203 c \u03c4, \u03c3 = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 (support c).card = n) \u2192 n \u2208 cycleType \u03c3", "state_after": "case mpr.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nc t : Perm \u03b1\nhd : Disjoint c t\nhc : IsCycle c\n\u22a2 (support c).card \u2208 cycleType (c * t)"}, {"tactic": "simp [hd.cycleType, hc.cycleType]", "annotated_tactic": ["simp [hd.cycleType, hc.cycleType]", []], "state_before": "case mpr.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nc t : Perm \u03b1\nhd : Disjoint c t\nhc : IsCycle c\n\u22a2 (support c).card \u2208 cycleType (c * t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Defs.lean", "full_name": "Finsupp.mapRange_sub", "start": [1327, 1], "end": [1330, 61], "traced_tactics": [{"tactic": "simp only [hf', sub_apply, mapRange_apply]", "annotated_tactic": ["simp only [hf', <a>sub_apply</a>, <a>mapRange_apply</a>]", [{"full_name": "Finsupp.sub_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [1323, 9], "def_end_pos": [1323, 18]}, {"full_name": "Finsupp.mapRange_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b9 : SubNegZeroMonoid G\ninst\u271d : SubNegZeroMonoid H\nf : G \u2192 H\nhf : f 0 = 0\nhf' : \u2200 (x y : G), f (x - y) = f x - f y\nv\u2081 v\u2082 : \u03b1 \u2192\u2080 G\nx\u271d : \u03b1\n\u22a2 (mapRange f hf (v\u2081 - v\u2082)) x\u271d = (mapRange f hf v\u2081 - mapRange f hf v\u2082) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Nodup.lean", "full_name": "Multiset.not_nodup_pair", "start": [68, 1], "end": [69, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Periodic.lean", "full_name": "Function.Periodic.int_mul_eq", "start": [275, 1], "end": [276, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Denumerable.lean", "full_name": "Nat.Subtype.lt_succ_iff_le", "start": [268, 1], "end": [270, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/MonoidAlgebra/Degree.lean", "full_name": "AddMonoidAlgebra.le_infDegree_add", "start": [338, 1], "end": [340, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/CountableSeparatingOn.lean", "full_name": "exists_nonempty_countable_separating", "start": [95, 1], "end": [101, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "BotHom.comp_apply", "start": [470, 1], "end": [471, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "wellFoundedGT_dual_iff", "start": [370, 1], "end": [371, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Equiv.lean", "full_name": "RingEquiv.congr_fun", "start": [199, 11], "end": [200, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "le_hnot_inf_hnot", "start": [1073, 1], "end": [1074, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "full_name": "ConjAct.toConjAct_one", "start": [120, 1], "end": [121, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean", "full_name": "HasFDerivWithinAt.log", "start": [135, 1], "end": [137, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "MulEquiv.map_finprod_mem", "start": [739, 1], "end": [741, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Prod.lean", "full_name": "Finset.product_image_fst", "start": [75, 1], "end": [77, 27], "traced_tactics": [{"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns s' : Finset \u03b1\nt t' : Finset \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d : DecidableEq \u03b1\nht : t.Nonempty\n\u22a2 image Prod.fst (s \u00d7\u02e2 t) = s", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns s' : Finset \u03b1\nt t' : Finset \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d : DecidableEq \u03b1\nht : t.Nonempty\ni : \u03b1\n\u22a2 i \u2208 image Prod.fst (s \u00d7\u02e2 t) \u2194 i \u2208 s"}, {"tactic": "simp [mem_image, ht.bex]", "annotated_tactic": ["simp [<a>mem_image</a>, ht.bex]", [{"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}]], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns s' : Finset \u03b1\nt t' : Finset \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d : DecidableEq \u03b1\nht : t.Nonempty\ni : \u03b1\n\u22a2 i \u2208 image Prod.fst (s \u00d7\u02e2 t) \u2194 i \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "Measurable.subtype_map", "start": [638, 1], "end": [640, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "continuous_prod_mk", "start": [323, 9], "end": [327, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.succ_castPred_eq_castPred_succ", "start": [1345, 1], "end": [1347, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csInf_Ioi", "start": [754, 1], "end": [756, 34], "traced_tactics": [{"tactic": "simpa using exists_between hw", "annotated_tactic": ["simpa using <a>exists_between</a> hw", [{"full_name": "exists_between", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [1355, 9], "def_end_pos": [1355, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ns t : Set \u03b1\na b : \u03b1\ninst\u271d\u00b9 : NoMaxOrder \u03b1\ninst\u271d : DenselyOrdered \u03b1\nw : \u03b1\nhw : a < w\n\u22a2 \u2203 a_1 \u2208 Ioi a, a_1 < w", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.valid_next", "start": [277, 1], "end": [282, 45], "traced_tactics": [{"tactic": "match s, p, h with\n| \u27e8_\u27e9, \u27e8_\u27e9, \u27e8cs, [], rfl, rfl\u27e9 => simp at h\u2082\n| \u27e8_\u27e9, \u27e8_\u27e9, \u27e8cs, c::cs', rfl, rfl\u27e9 =>\n  rw [utf8ByteSize.go_eq, next_of_valid]\n  simpa using Pos.Valid.mk (cs ++ [c]) cs'", "annotated_tactic": ["match s, p, h with\n  | \u27e8_\u27e9, \u27e8_\u27e9, \u27e8cs, [], <a>rfl</a>, <a>rfl</a>\u27e9 => simp at h\u2082\n  | \u27e8_\u27e9, \u27e8_\u27e9, \u27e8cs, c::cs', <a>rfl</a>, <a>rfl</a>\u27e9 =>\n    rw [<a>utf8ByteSize.go_eq</a>, <a>next_of_valid</a>]\n    simpa using <a>Pos.Valid.mk</a> (cs ++ [c]) cs'", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Nat", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1065, 11], "def_end_pos": [1065, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Nat", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1065, 11], "def_end_pos": [1065, 14]}, {"full_name": "String.utf8ByteSize.go_eq", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [56, 17], "def_end_pos": [56, 35]}, {"full_name": "String.next_of_valid", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [269, 9], "def_end_pos": [269, 22]}, {"full_name": "String.Pos.Valid.mk", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [168, 9], "def_end_pos": [168, 17]}]], "state_before": "s : String\np : Pos\nh : Pos.Valid s p\nh\u2082 : p < endPos s\n\u22a2 Pos.Valid s (next s p)", "state_after": "no goals"}, {"tactic": "simp at h\u2082", "annotated_tactic": ["simp at h\u2082", []], "state_before": "s : String\np : Pos\nh : Pos.Valid s p\ncs : List Char\nh\u2082 : { byteIdx := utf8ByteSize.go cs } < endPos { data := cs ++ [] }\n\u22a2 Pos.Valid { data := cs ++ [] } (next { data := cs ++ [] } { byteIdx := utf8ByteSize.go cs })", "state_after": "no goals"}, {"tactic": "rw [utf8ByteSize.go_eq, next_of_valid]", "annotated_tactic": ["rw [<a>utf8ByteSize.go_eq</a>, <a>next_of_valid</a>]", [{"full_name": "String.utf8ByteSize.go_eq", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [56, 17], "def_end_pos": [56, 35]}, {"full_name": "String.next_of_valid", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [269, 9], "def_end_pos": [269, 22]}]], "state_before": "s : String\np : Pos\nh : Pos.Valid s p\ncs : List Char\nc : Char\ncs' : List Char\nh\u2082 : { byteIdx := utf8ByteSize.go cs } < endPos { data := cs ++ c :: cs' }\n\u22a2 Pos.Valid { data := cs ++ c :: cs' } (next { data := cs ++ c :: cs' } { byteIdx := utf8ByteSize.go cs })", "state_after": "s : String\np : Pos\nh : Pos.Valid s p\ncs : List Char\nc : Char\ncs' : List Char\nh\u2082 : { byteIdx := utf8ByteSize.go cs } < endPos { data := cs ++ c :: cs' }\n\u22a2 Pos.Valid { data := cs ++ c :: cs' } { byteIdx := utf8Len cs + csize c }"}, {"tactic": "simpa using Pos.Valid.mk (cs ++ [c]) cs'", "annotated_tactic": ["simpa using <a>Pos.Valid.mk</a> (cs ++ [c]) cs'", [{"full_name": "String.Pos.Valid.mk", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [168, 9], "def_end_pos": [168, 17]}]], "state_before": "s : String\np : Pos\nh : Pos.Valid s p\ncs : List Char\nc : Char\ncs' : List Char\nh\u2082 : { byteIdx := utf8ByteSize.go cs } < endPos { data := cs ++ c :: cs' }\n\u22a2 Pos.Valid { data := cs ++ c :: cs' } { byteIdx := utf8Len cs + csize c }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.Prime.dvd_of_dvd_pow", "start": [592, 1], "end": [593, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Finite/Basic.lean", "full_name": "FiniteField.card_image_polynomial_eval", "start": [66, 1], "end": [73, 37], "traced_tactics": [{"tactic": "simp [Finset.ext_iff, \u2190 mem_roots_sub_C hp]", "annotated_tactic": ["simp [<a>Finset.ext_iff</a>, \u2190 <a>mem_roots_sub_C</a> hp]", [{"full_name": "Finset.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 16]}, {"full_name": "Polynomial.mem_roots_sub_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [791, 9], "def_end_pos": [791, 24]}]], "state_before": "K : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : DecidableEq R\ninst\u271d : Fintype R\np : R[X]\nhp : 0 < degree p\na : R\nx\u271d : a \u2208 image (fun x => eval x p) univ\n\u22a2 filter (fun x => eval x p = a) univ = Multiset.toFinset (roots (p - C a))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dual.lean", "full_name": "Subspace.dualRestrict_comp_dualLift", "start": [1123, 1], "end": [1125, 7], "traced_tactics": [{"tactic": "ext \u03c6 x", "annotated_tactic": ["ext \u03c6 x", []], "state_before": "K : Type u\nV : Type v\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nW\u271d W : Subspace K V\n\u22a2 dualRestrict W \u2218\u2097 dualLift W = 1", "state_after": "case h.h\nK : Type u\nV : Type v\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nW\u271d W : Subspace K V\n\u03c6 : Module.Dual K \u21a5W\nx : \u21a5W\n\u22a2 ((dualRestrict W \u2218\u2097 dualLift W) \u03c6) x = (1 \u03c6) x"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.h\nK : Type u\nV : Type v\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nW\u271d W : Subspace K V\n\u03c6 : Module.Dual K \u21a5W\nx : \u21a5W\n\u22a2 ((dualRestrict W \u2218\u2097 dualLift W) \u03c6) x = (1 \u03c6) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Relation.lean", "full_name": "reflTransGen_of_pred", "start": [132, 1], "end": [135, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean", "full_name": "pairwise_disjoint_mono", "start": [60, 1], "end": [62, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Rat/Lemmas.lean", "full_name": "Rat.divInt_neg'", "start": [150, 1], "end": [150, 99], "traced_tactics": [{"tactic": "rw [\u2190 neg_divInt_neg, Int.neg_neg]", "annotated_tactic": ["rw [\u2190 <a>neg_divInt_neg</a>, <a>Int.neg_neg</a>]", [{"full_name": "Rat.neg_divInt_neg", "def_path": ".lake/packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [144, 9], "def_end_pos": [144, 23]}, {"full_name": "Int.neg_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [75, 27], "def_end_pos": [75, 34]}]], "state_before": "num den : Int\n\u22a2 num /. -den = -num /. den", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "full_name": "HasFDerivAtFilter.congr_of_eventuallyEq", "start": [929, 1], "end": [931, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Bounded.lean", "full_name": "Bornology.IsBounded.subset_closedBall_lt", "start": [93, 1], "end": [96, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "compl_inf_eq_bot", "start": [838, 1], "end": [839, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/NonUnitalHom.lean", "full_name": "NonUnitalAlgHom.one_apply", "start": [288, 1], "end": [289, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pointwise.lean", "full_name": "Filter.inv_pure", "start": [210, 1], "end": [211, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Pointwise.lean", "full_name": "preimage_smul_set\u209b\u2097", "start": [32, 1], "end": [38, 79], "traced_tactics": [{"tactic": "lift c to R\u02e3 using hc", "annotated_tactic": ["lift c to R\u02e3 using hc", []], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\nM\u2081 : Type u_4\nM\u2082 : Type u_5\nN : Type u_6\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Semiring S\n\u03c3 : R \u2192+* S\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2081\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module S N\nF : Type u_7\nh : F\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : SemilinearMapClass F \u03c3 M N\nc : R\nhc : IsUnit c\ns : Set N\n\u22a2 \u21d1h \u207b\u00b9' (\u03c3 c \u2022 s) = c \u2022 \u21d1h \u207b\u00b9' s", "state_after": "case intro\nR : Type u_1\nS : Type u_2\nM : Type u_3\nM\u2081 : Type u_4\nM\u2082 : Type u_5\nN : Type u_6\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Semiring S\n\u03c3 : R \u2192+* S\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2081\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module S N\nF : Type u_7\nh : F\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : SemilinearMapClass F \u03c3 M N\ns : Set N\nc : R\u02e3\n\u22a2 \u21d1h \u207b\u00b9' (\u03c3 \u2191c \u2022 s) = \u2191c \u2022 \u21d1h \u207b\u00b9' s"}, {"tactic": "rw [\u2190 preimage_smul_inv]", "annotated_tactic": ["rw [\u2190 <a>preimage_smul_inv</a>]", [{"full_name": "Set.preimage_smul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [917, 9], "def_end_pos": [917, 26]}]], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\nM\u2081 : Type u_4\nM\u2082 : Type u_5\nN : Type u_6\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Semiring S\n\u03c3 : R \u2192+* S\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2081\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module S N\nF : Type u_7\nh : F\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : SemilinearMapClass F \u03c3 M N\ns : Set N\nc : R\u02e3\n\u22a2 \u21d1h \u207b\u00b9' ((Units.map \u2191\u03c3) c \u2022 s) = (fun x => \u03c3 \u2191c\u207b\u00b9 \u2022 h x) \u207b\u00b9' s", "state_after": "R : Type u_1\nS : Type u_2\nM : Type u_3\nM\u2081 : Type u_4\nM\u2082 : Type u_5\nN : Type u_6\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Semiring S\n\u03c3 : R \u2192+* S\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2081\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module S N\nF : Type u_7\nh : F\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : SemilinearMapClass F \u03c3 M N\ns : Set N\nc : R\u02e3\n\u22a2 \u21d1h \u207b\u00b9' ((fun x => ((Units.map \u2191\u03c3) c)\u207b\u00b9 \u2022 x) \u207b\u00b9' s) = (fun x => \u03c3 \u2191c\u207b\u00b9 \u2022 h x) \u207b\u00b9' s"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\nM\u2081 : Type u_4\nM\u2082 : Type u_5\nN : Type u_6\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Semiring S\n\u03c3 : R \u2192+* S\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2081\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module S N\nF : Type u_7\nh : F\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : SemilinearMapClass F \u03c3 M N\ns : Set N\nc : R\u02e3\n\u22a2 \u21d1h \u207b\u00b9' ((fun x => ((Units.map \u2191\u03c3) c)\u207b\u00b9 \u2022 x) \u207b\u00b9' s) = (fun x => \u03c3 \u2191c\u207b\u00b9 \u2022 h x) \u207b\u00b9' s", "state_after": "no goals"}, {"tactic": "simp only [\u2190 map_smul\u209b\u2097 h, \u2190 preimage_smul_inv]", "annotated_tactic": ["simp only [\u2190 <a>map_smul\u209b\u2097</a> h, \u2190 <a>preimage_smul_inv</a>]", [{"full_name": "SemilinearMapClass.map_smul\u209b\u2097", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [122, 3], "def_end_pos": [122, 13]}, {"full_name": "Set.preimage_smul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [917, 9], "def_end_pos": [917, 26]}]], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\nM\u2081 : Type u_4\nM\u2082 : Type u_5\nN : Type u_6\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Semiring S\n\u03c3 : R \u2192+* S\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2081\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module S N\nF : Type u_7\nh : F\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : SemilinearMapClass F \u03c3 M N\ns : Set N\nc : R\u02e3\n\u22a2 (fun x => \u03c3 \u2191c\u207b\u00b9 \u2022 h x) \u207b\u00b9' s = c \u2022 \u21d1h \u207b\u00b9' s", "state_after": "R : Type u_1\nS : Type u_2\nM : Type u_3\nM\u2081 : Type u_4\nM\u2082 : Type u_5\nN : Type u_6\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Semiring S\n\u03c3 : R \u2192+* S\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2081\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module S N\nF : Type u_7\nh : F\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : SemilinearMapClass F \u03c3 M N\ns : Set N\nc : R\u02e3\n\u22a2 (fun x => h (\u2191c\u207b\u00b9 \u2022 x)) \u207b\u00b9' s = (fun x => c\u207b\u00b9 \u2022 x) \u207b\u00b9' (\u21d1h \u207b\u00b9' s)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\nM\u2081 : Type u_4\nM\u2082 : Type u_5\nN : Type u_6\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Semiring S\n\u03c3 : R \u2192+* S\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2081\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M\u2081\ninst\u271d\u00b3 : Module R M\u2082\ninst\u271d\u00b2 : Module S N\nF : Type u_7\nh : F\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : SemilinearMapClass F \u03c3 M N\ns : Set N\nc : R\u02e3\n\u22a2 (fun x => h (\u2191c\u207b\u00b9 \u2022 x)) \u207b\u00b9' s = (fun x => c\u207b\u00b9 \u2022 x) \u207b\u00b9' (\u21d1h \u207b\u00b9' s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/EraseLead.lean", "full_name": "Polynomial.eraseLead_coeff_natDegree", "start": [51, 1], "end": [51, 99], "traced_tactics": [{"tactic": "simp [eraseLead_coeff]", "annotated_tactic": ["simp [<a>eraseLead_coeff</a>]", [{"full_name": "Polynomial.eraseLead_coeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/EraseLead.lean", "def_pos": [46, 9], "def_end_pos": [46, 24]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\n\u22a2 coeff (eraseLead f) (natDegree f) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/CharZero/Defs.lean", "full_name": "Nat.cast_ne_zero", "start": [83, 1], "end": [84, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean", "full_name": "SimpleGraph.deleteEdges_deleteEdges", "start": [950, 1], "end": [953, 27], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v w : V\ne : Sym2 V\ns s' : Set (Sym2 V)\n\u22a2 deleteEdges (deleteEdges G s) s' = deleteEdges G (s \u222a s')", "state_after": "case Adj.h.h.a\n\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v w : V\ne : Sym2 V\ns s' : Set (Sym2 V)\nx\u271d\u00b9 x\u271d : V\n\u22a2 (deleteEdges (deleteEdges G s) s').Adj x\u271d\u00b9 x\u271d \u2194 (deleteEdges G (s \u222a s')).Adj x\u271d\u00b9 x\u271d"}, {"tactic": "simp [and_assoc, not_or]", "annotated_tactic": ["simp [<a>and_assoc</a>, <a>not_or</a>]", [{"full_name": "and_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [136, 9], "def_end_pos": [136, 18]}, {"full_name": "not_or", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [107, 9], "def_end_pos": [107, 15]}]], "state_before": "case Adj.h.h.a\n\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v w : V\ne : Sym2 V\ns s' : Set (Sym2 V)\nx\u271d\u00b9 x\u271d : V\n\u22a2 (deleteEdges (deleteEdges G s) s').Adj x\u271d\u00b9 x\u271d \u2194 (deleteEdges G (s \u222a s')).Adj x\u271d\u00b9 x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Completion.lean", "full_name": "UniformSpace.Completion.denseInducing_coe", "start": [420, 1], "end": [421, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "full_name": "continuousAt_of_locally_uniform_approx_of_continuousAt", "start": [836, 1], "end": [841, 77], "traced_tactics": [{"tactic": "rw [\u2190 continuousWithinAt_univ]", "annotated_tactic": ["rw [\u2190 <a>continuousWithinAt_univ</a>]", [{"full_name": "continuousWithinAt_univ", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [535, 9], "def_end_pos": [535, 32]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nL : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u\n\u22a2 ContinuousAt f x", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nL : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u\n\u22a2 ContinuousWithinAt f univ x"}, {"tactic": "apply continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt (mem_univ _) _", "annotated_tactic": ["apply <a>continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt</a> (<a>mem_univ</a> _) _", [{"full_name": "continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "def_pos": [817, 9], "def_end_pos": [817, 75]}, {"full_name": "Set.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [82, 29], "def_end_pos": [82, 37]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nL : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u\n\u22a2 ContinuousWithinAt f univ x", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nL : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u\n\u22a2 \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd[univ] x, \u2203 F, ContinuousWithinAt F univ x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u"}, {"tactic": "simpa only [exists_prop, nhdsWithin_univ, continuousWithinAt_univ] using L", "annotated_tactic": ["simpa only [<a>exists_prop</a>, <a>nhdsWithin_univ</a>, <a>continuousWithinAt_univ</a>] using L", [{"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "nhdsWithin_univ", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [76, 9], "def_end_pos": [76, 24]}, {"full_name": "continuousWithinAt_univ", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [535, 9], "def_end_pos": [535, 32]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b9 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np : Filter \u03b9\np' : Filter \u03b1\ng : \u03b9 \u2192 \u03b1\ninst\u271d : TopologicalSpace \u03b1\nL : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u\n\u22a2 \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd[univ] x, \u2203 F, ContinuousWithinAt F univ x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Log.lean", "full_name": "Nat.pow_log_le_self", "start": [119, 1], "end": [120, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.lift_pred", "start": [230, 1], "end": [232, 86], "traced_tactics": [{"tactic": "cases' h with a e", "annotated_tactic": ["cases' h with a e", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\no : Ordinal.{v}\nh : \u2203 a, o = succ a\n\u22a2 lift.{u, v} (pred o) = pred (lift.{u, v} o)", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\no a : Ordinal.{v}\ne : o = succ a\n\u22a2 lift.{u, v} (pred o) = pred (lift.{u, v} o)"}, {"tactic": "simp only [e, pred_succ, lift_succ]", "annotated_tactic": ["simp only [e, <a>pred_succ</a>, <a>lift_succ</a>]", [{"full_name": "Ordinal.pred_succ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [172, 9], "def_end_pos": [172, 18]}, {"full_name": "Ordinal.lift_succ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [79, 9], "def_end_pos": [79, 18]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\no a : Ordinal.{v}\ne : o = succ a\n\u22a2 lift.{u, v} (pred o) = pred (lift.{u, v} o)", "state_after": "no goals"}, {"tactic": "rw [pred_eq_iff_not_succ.2 h, pred_eq_iff_not_succ.2 (mt lift_is_succ.1 h)]", "annotated_tactic": ["rw [<a>pred_eq_iff_not_succ</a>.2 h, <a>pred_eq_iff_not_succ</a>.2 (<a>mt</a> <a>lift_is_succ</a>.1 h)]", [{"full_name": "Ordinal.pred_eq_iff_not_succ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [184, 9], "def_end_pos": [184, 29]}, {"full_name": "Ordinal.pred_eq_iff_not_succ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [184, 9], "def_end_pos": [184, 29]}, {"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "Ordinal.lift_is_succ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [222, 9], "def_end_pos": [222, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\no : Ordinal.{v}\nh : \u00ac\u2203 a, o = succ a\n\u22a2 lift.{u, v} (pred o) = pred (lift.{u, v} o)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_mem_union", "start": [829, 1], "end": [831, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "iteratedFDerivWithin_sum_apply", "start": [1450, 1], "end": [1459, 80], "traced_tactics": [{"tactic": "induction u using Finset.cons_induction with\n| empty => ext; simp [hs, hx]\n| @cons a u ha IH =>\n  simp only [Finset.mem_cons, forall_eq_or_imp] at h\n  simp only [Finset.sum_cons]\n  rw [iteratedFDerivWithin_add_apply' h.1 (ContDiffOn.sum h.2) hs hx, IH h.2]", "annotated_tactic": ["induction u using <a>Finset.cons_induction</a> with\n  | <a>empty</a> => ext; simp [hs, hx]\n  | @<a>cons</a> a u ha IH =>\n    simp only [<a>Finset.mem_cons</a>, <a>forall_eq_or_imp</a>] at h\n    simp only [<a>Finset.sum_cons</a>]\n    rw [<a>iteratedFDerivWithin_add_apply'</a> h.1 (<a>ContDiffOn.sum</a> h.2) hs hx, IH h.2]", [{"full_name": "Finset.cons_induction", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1253, 9], "def_end_pos": [1253, 23]}, {"full_name": "Finset.empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [537, 15], "def_end_pos": [537, 20]}, {"full_name": "Finset.cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [872, 5], "def_end_pos": [872, 9]}, {"full_name": "Finset.mem_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 17]}, {"full_name": "forall_eq_or_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [228, 17], "def_end_pos": [228, 33]}, {"full_name": "Finset.sum_cons", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [305, 3], "def_end_pos": [305, 14]}, {"full_name": "iteratedFDerivWithin_add_apply'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "def_pos": [1315, 9], "def_end_pos": [1315, 40]}, {"full_name": "ContDiffOn.sum", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "def_pos": [1439, 9], "def_end_pos": [1439, 23]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf\u271d f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u03b9 : Type u_3\nf : \u03b9 \u2192 E \u2192 F\nu : Finset \u03b9\ni : \u2115\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nh : \u2200 j \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f j) s\n\u22a2 iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in u, f j x) s x = \u2211 j in u, iteratedFDerivWithin \ud835\udd5c i (f j) s x", "state_after": "no goals"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "case empty\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf\u271d f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u03b9 : Type u_3\nf : \u03b9 \u2192 E \u2192 F\ni : \u2115\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nh : \u2200 j \u2208 \u2205, ContDiffOn \ud835\udd5c (\u2191i) (f j) s\n\u22a2 iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in \u2205, f j x) s x = \u2211 j in \u2205, iteratedFDerivWithin \ud835\udd5c i (f j) s x", "state_after": "case empty.H\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf\u271d f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d\u00b9 x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u03b9 : Type u_3\nf : \u03b9 \u2192 E \u2192 F\ni : \u2115\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nh : \u2200 j \u2208 \u2205, ContDiffOn \ud835\udd5c (\u2191i) (f j) s\nx\u271d : Fin i \u2192 E\n\u22a2 (iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in \u2205, f j x) s x) x\u271d = (\u2211 j in \u2205, iteratedFDerivWithin \ud835\udd5c i (f j) s x) x\u271d"}, {"tactic": "simp [hs, hx]", "annotated_tactic": ["simp [hs, hx]", []], "state_before": "case empty.H\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf\u271d f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d\u00b9 x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u03b9 : Type u_3\nf : \u03b9 \u2192 E \u2192 F\ni : \u2115\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nh : \u2200 j \u2208 \u2205, ContDiffOn \ud835\udd5c (\u2191i) (f j) s\nx\u271d : Fin i \u2192 E\n\u22a2 (iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in \u2205, f j x) s x) x\u271d = (\u2211 j in \u2205, iteratedFDerivWithin \ud835\udd5c i (f j) s x) x\u271d", "state_after": "no goals"}, {"tactic": "simp only [Finset.mem_cons, forall_eq_or_imp] at h", "annotated_tactic": ["simp only [<a>Finset.mem_cons</a>, <a>forall_eq_or_imp</a>] at h", [{"full_name": "Finset.mem_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 17]}, {"full_name": "forall_eq_or_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [228, 17], "def_end_pos": [228, 33]}]], "state_before": "case cons\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf\u271d f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u03b9 : Type u_3\nf : \u03b9 \u2192 E \u2192 F\ni : \u2115\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\na : \u03b9\nu : Finset \u03b9\nha : a \u2209 u\nIH :\n  (\u2200 j \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f j) s) \u2192\n    iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in u, f j x) s x = \u2211 j in u, iteratedFDerivWithin \ud835\udd5c i (f j) s x\nh : \u2200 j \u2208 Finset.cons a u ha, ContDiffOn \ud835\udd5c (\u2191i) (f j) s\n\u22a2 iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in Finset.cons a u ha, f j x) s x =\n    \u2211 j in Finset.cons a u ha, iteratedFDerivWithin \ud835\udd5c i (f j) s x", "state_after": "case cons\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf\u271d f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u03b9 : Type u_3\nf : \u03b9 \u2192 E \u2192 F\ni : \u2115\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\na : \u03b9\nu : Finset \u03b9\nha : a \u2209 u\nIH :\n  (\u2200 j \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f j) s) \u2192\n    iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in u, f j x) s x = \u2211 j in u, iteratedFDerivWithin \ud835\udd5c i (f j) s x\nh : ContDiffOn \ud835\udd5c (\u2191i) (f a) s \u2227 \u2200 a \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f a) s\n\u22a2 iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in Finset.cons a u ha, f j x) s x =\n    \u2211 j in Finset.cons a u ha, iteratedFDerivWithin \ud835\udd5c i (f j) s x"}, {"tactic": "simp only [Finset.sum_cons]", "annotated_tactic": ["simp only [<a>Finset.sum_cons</a>]", [{"full_name": "Finset.sum_cons", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [305, 3], "def_end_pos": [305, 14]}]], "state_before": "case cons\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf\u271d f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u03b9 : Type u_3\nf : \u03b9 \u2192 E \u2192 F\ni : \u2115\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\na : \u03b9\nu : Finset \u03b9\nha : a \u2209 u\nIH :\n  (\u2200 j \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f j) s) \u2192\n    iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in u, f j x) s x = \u2211 j in u, iteratedFDerivWithin \ud835\udd5c i (f j) s x\nh : ContDiffOn \ud835\udd5c (\u2191i) (f a) s \u2227 \u2200 a \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f a) s\n\u22a2 iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in Finset.cons a u ha, f j x) s x =\n    \u2211 j in Finset.cons a u ha, iteratedFDerivWithin \ud835\udd5c i (f j) s x", "state_after": "case cons\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf\u271d f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u03b9 : Type u_3\nf : \u03b9 \u2192 E \u2192 F\ni : \u2115\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\na : \u03b9\nu : Finset \u03b9\nha : a \u2209 u\nIH :\n  (\u2200 j \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f j) s) \u2192\n    iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in u, f j x) s x = \u2211 j in u, iteratedFDerivWithin \ud835\udd5c i (f j) s x\nh : ContDiffOn \ud835\udd5c (\u2191i) (f a) s \u2227 \u2200 a \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f a) s\n\u22a2 iteratedFDerivWithin \ud835\udd5c i (fun x => f a x + \u2211 j in u, f j x) s x =\n    iteratedFDerivWithin \ud835\udd5c i (f a) s x + \u2211 j in u, iteratedFDerivWithin \ud835\udd5c i (f j) s x"}, {"tactic": "rw [iteratedFDerivWithin_add_apply' h.1 (ContDiffOn.sum h.2) hs hx, IH h.2]", "annotated_tactic": ["rw [<a>iteratedFDerivWithin_add_apply'</a> h.1 (<a>ContDiffOn.sum</a> h.2) hs hx, IH h.2]", [{"full_name": "iteratedFDerivWithin_add_apply'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "def_pos": [1315, 9], "def_end_pos": [1315, 40]}, {"full_name": "ContDiffOn.sum", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "def_pos": [1439, 9], "def_end_pos": [1439, 23]}]], "state_before": "case cons\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf\u271d f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u03b9 : Type u_3\nf : \u03b9 \u2192 E \u2192 F\ni : \u2115\nx : E\nhs : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\na : \u03b9\nu : Finset \u03b9\nha : a \u2209 u\nIH :\n  (\u2200 j \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f j) s) \u2192\n    iteratedFDerivWithin \ud835\udd5c i (fun x => \u2211 j in u, f j x) s x = \u2211 j in u, iteratedFDerivWithin \ud835\udd5c i (f j) s x\nh : ContDiffOn \ud835\udd5c (\u2191i) (f a) s \u2227 \u2200 a \u2208 u, ContDiffOn \ud835\udd5c (\u2191i) (f a) s\n\u22a2 iteratedFDerivWithin \ud835\udd5c i (fun x => f a x + \u2211 j in u, f j x) s x =\n    iteratedFDerivWithin \ud835\udd5c i (f a) s x + \u2211 j in u, iteratedFDerivWithin \ud835\udd5c i (f j) s x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/IterateHom.lean", "full_name": "smul_iterate", "start": [170, 1], "end": [173, 74], "traced_tactics": [{"tactic": "rw [iterate_zero, id.def, pow_zero, one_smul]", "annotated_tactic": ["rw [<a>iterate_zero</a>, <a>id.def</a>, <a>pow_zero</a>, <a>one_smul</a>]", [{"full_name": "Function.iterate_zero", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [53, 9], "def_end_pos": [53, 21]}, {"full_name": "id.def", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [22, 9], "def_end_pos": [22, 15]}, {"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}, {"full_name": "one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [481, 9], "def_end_pos": [481, 17]}]], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\ninst\u271d\u00b9 : Monoid G\na : G\nn : \u2115\ninst\u271d : MulAction G H\nb : H\n\u22a2 (fun x => a \u2022 x)^[Nat.zero] b = a ^ Nat.zero \u2022 b", "state_after": "no goals"}, {"tactic": "rw [iterate_succ', comp_apply, ih, pow_succ, mul_smul]", "annotated_tactic": ["rw [<a>iterate_succ'</a>, <a>comp_apply</a>, ih, <a>pow_succ</a>, <a>mul_smul</a>]", [{"full_name": "Function.iterate_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [186, 9], "def_end_pos": [186, 22]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}, {"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}]], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nH : Type u_4\ninst\u271d\u00b9 : Monoid G\na : G\nn\u271d : \u2115\ninst\u271d : MulAction G H\nb : H\nn : \u2115\nih : (fun x => a \u2022 x)^[n] b = a ^ n \u2022 b\n\u22a2 (fun x => a \u2022 x)^[Nat.succ n] b = a ^ Nat.succ n \u2022 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.diff_mem_inf_principal_compl", "start": [1049, 1], "end": [1051, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.erase_same", "start": [1101, 1], "end": [1101, 89], "traced_tactics": [{"tactic": "simp [coeff_erase]", "annotated_tactic": ["simp [<a>coeff_erase</a>]", [{"full_name": "Polynomial.coeff_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1082, 9], "def_end_pos": [1082, 20]}]], "state_before": "R : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np\u271d q p : R[X]\nn : \u2115\n\u22a2 coeff (erase n p) n = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/PairingHeap.lean", "full_name": "Std.PairingHeapImp.Heap.size_deleteMin_lt", "start": [154, 1], "end": [156, 70], "traced_tactics": [{"tactic": "cases s with cases eq | node a c => simp_arith [size_combine, size]", "annotated_tactic": ["cases s with cases eq | <a>node</a> a c => simp_arith [<a>size_combine</a>, <a>size</a>]", [{"full_name": "Std.PairingHeapImp.Heap.node", "def_path": ".lake/packages/std/Std/Data/PairingHeap.lean", "def_pos": [25, 5], "def_end_pos": [25, 9]}, {"full_name": "Std.PairingHeapImp.Heap.size_combine", "def_path": ".lake/packages/std/Std/Data/PairingHeap.lean", "def_pos": [129, 9], "def_end_pos": [129, 26]}, {"full_name": "Std.PairingHeapImp.Heap.size", "def_path": ".lake/packages/std/Std/Data/PairingHeap.lean", "def_pos": [29, 5], "def_end_pos": [29, 14]}]], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\na : \u03b1\ns' s : Heap \u03b1\neq : deleteMin le s = some (a, s')\n\u22a2 size s' < size s", "state_after": "no goals"}, {"tactic": "simp_arith [size_combine, size]", "annotated_tactic": ["simp_arith [<a>size_combine</a>, <a>size</a>]", [{"full_name": "Std.PairingHeapImp.Heap.size_combine", "def_path": ".lake/packages/std/Std/Data/PairingHeap.lean", "def_pos": [129, 9], "def_end_pos": [129, 26]}, {"full_name": "Std.PairingHeapImp.Heap.size", "def_path": ".lake/packages/std/Std/Data/PairingHeap.lean", "def_pos": [29, 5], "def_end_pos": [29, 14]}]], "state_before": "case node.refl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\na : \u03b1\nc sibling\u271d : Heap \u03b1\n\u22a2 size (combine le c) < size (node a c sibling\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "IsUnit.div_eq_one_iff_eq", "start": [1074, 1], "end": [1076, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupClosed.lean", "full_name": "infClosed_pi", "start": [144, 1], "end": [146, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/IsROrC.lean", "full_name": "HasFTaylorSeriesUpToOn.exists_lipschitzOnWith", "start": [106, 1], "end": [111, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Count.lean", "full_name": "List.countP_cons_of_neg", "start": [41, 9], "end": [42, 31], "traced_tactics": [{"tactic": "simp [countP, countP.go, pa]", "annotated_tactic": ["simp [<a>countP</a>, <a>countP.go</a>, pa]", [{"full_name": "List.countP", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [699, 15], "def_end_pos": [699, 21]}, {"full_name": "List.countP.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [701, 17], "def_end_pos": [701, 19]}]], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\na : \u03b1\nl : List \u03b1\npa : \u00acp a = true\n\u22a2 countP p (a :: l) = countP p l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.support_congr", "start": [324, 1], "end": [329, 28], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : support f \u2286 support g\nh' : \u2200 x \u2208 support g, f x = g x\n\u22a2 f = g", "state_after": "case H\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : support f \u2286 support g\nh' : \u2200 x \u2208 support g, f x = g x\nx : \u03b1\n\u22a2 f x = g x"}, {"tactic": "by_cases hx : x \u2208 g.support", "annotated_tactic": ["by_cases hx : x \u2208 g.support", []], "state_before": "case H\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : support f \u2286 support g\nh' : \u2200 x \u2208 support g, f x = g x\nx : \u03b1\n\u22a2 f x = g x", "state_after": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : support f \u2286 support g\nh' : \u2200 x \u2208 support g, f x = g x\nx : \u03b1\nhx : x \u2208 support g\n\u22a2 f x = g x\n\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : support f \u2286 support g\nh' : \u2200 x \u2208 support g, f x = g x\nx : \u03b1\nhx : x \u2209 support g\n\u22a2 f x = g x"}, {"tactic": "exact h' x hx", "annotated_tactic": ["exact h' x hx", []], "state_before": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : support f \u2286 support g\nh' : \u2200 x \u2208 support g, f x = g x\nx : \u03b1\nhx : x \u2208 support g\n\u22a2 f x = g x", "state_after": "no goals"}, {"tactic": "rw [not_mem_support.mp hx, \u2190 not_mem_support]", "annotated_tactic": ["rw [not_mem_support.mp hx, \u2190 <a>not_mem_support</a>]", [{"full_name": "Equiv.Perm.not_mem_support", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [301, 9], "def_end_pos": [301, 24]}]], "state_before": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : support f \u2286 support g\nh' : \u2200 x \u2208 support g, f x = g x\nx : \u03b1\nhx : x \u2209 support g\n\u22a2 f x = g x", "state_after": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : support f \u2286 support g\nh' : \u2200 x \u2208 support g, f x = g x\nx : \u03b1\nhx : x \u2209 support g\n\u22a2 x \u2209 support f"}, {"tactic": "exact fun H => hx (h H)", "annotated_tactic": ["exact fun H => hx (h H)", []], "state_before": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : support f \u2286 support g\nh' : \u2200 x \u2208 support g, f x = g x\nx : \u03b1\nhx : x \u2209 support g\n\u22a2 x \u2209 support f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Matrix.lean", "full_name": "HasSum.matrix_diag", "start": [366, 1], "end": [368, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "Substring.Valid.front", "start": [1032, 1], "end": [1033, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.exists_mem_eq_sup'", "start": [1310, 1], "end": [1317, 67], "traced_tactics": [{"tactic": "refine' H.cons_induction (fun c => _) fun c s hc hs ih => _", "annotated_tactic": ["refine' H.cons_induction (fun c => _) fun c s hc hs ih => _", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b9\nH : s.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u2203 i \u2208 s, sup' s H f = f i", "state_after": "case refine'_1\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b9\nH : s.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\n\u22a2 \u2203 i \u2208 {c}, sup' {c} \u22ef f = f i\n\ncase refine'_2\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b9\nH : s\u271d.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\ns : Finset \u03b9\nhc : c \u2209 s\nhs : s.Nonempty\nih : \u2203 i \u2208 s, sup' s hs f = f i\n\u22a2 \u2203 i \u2208 cons c s hc, sup' (cons c s hc) \u22ef f = f i"}, {"tactic": "exact \u27e8c, mem_singleton_self c, rfl\u27e9", "annotated_tactic": ["exact \u27e8c, <a>mem_singleton_self</a> c, <a>rfl</a>\u27e9", [{"full_name": "Finset.mem_singleton_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [696, 9], "def_end_pos": [696, 27]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case refine'_1\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b9\nH : s.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\n\u22a2 \u2203 i \u2208 {c}, sup' {c} \u22ef f = f i", "state_after": "no goals"}, {"tactic": "rcases ih with \u27e8b, hb, h'\u27e9", "annotated_tactic": ["rcases ih with \u27e8b, hb, h'\u27e9", []], "state_before": "case refine'_2\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b9\nH : s\u271d.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\ns : Finset \u03b9\nhc : c \u2209 s\nhs : s.Nonempty\nih : \u2203 i \u2208 s, sup' s hs f = f i\n\u22a2 \u2203 i \u2208 cons c s hc, sup' (cons c s hc) \u22ef f = f i", "state_after": "case refine'_2.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b9\nH : s\u271d.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\ns : Finset \u03b9\nhc : c \u2209 s\nhs : s.Nonempty\nb : \u03b9\nhb : b \u2208 s\nh' : sup' s hs f = f b\n\u22a2 \u2203 i \u2208 cons c s hc, sup' (cons c s hc) \u22ef f = f i"}, {"tactic": "rw [sup'_cons hs, h']", "annotated_tactic": ["rw [<a>sup'_cons</a> hs, h']", [{"full_name": "Finset.sup'_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [800, 9], "def_end_pos": [800, 18]}]], "state_before": "case refine'_2.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b9\nH : s\u271d.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\ns : Finset \u03b9\nhc : c \u2209 s\nhs : s.Nonempty\nb : \u03b9\nhb : b \u2208 s\nh' : sup' s hs f = f b\n\u22a2 \u2203 i \u2208 cons c s hc, sup' (cons c s hc) \u22ef f = f i", "state_after": "case refine'_2.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b9\nH : s\u271d.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\ns : Finset \u03b9\nhc : c \u2209 s\nhs : s.Nonempty\nb : \u03b9\nhb : b \u2208 s\nh' : sup' s hs f = f b\n\u22a2 \u2203 i \u2208 cons c s hc, f c \u2294 f b = f i"}, {"tactic": "cases le_total (f b) (f c) with\n| inl h => exact \u27e8c, mem_cons.2 (Or.inl rfl), sup_eq_left.2 h\u27e9\n| inr h => exact \u27e8b, mem_cons.2 (Or.inr hb), sup_eq_right.2 h\u27e9", "annotated_tactic": ["cases <a>le_total</a> (f b) (f c) with\n    | <a>inl</a> h => exact \u27e8c, <a>mem_cons</a>.2 (<a>Or.inl</a> <a>rfl</a>), <a>sup_eq_left</a>.2 h\u27e9\n    | <a>inr</a> h => exact \u27e8b, <a>mem_cons</a>.2 (<a>Or.inr</a> hb), <a>sup_eq_right</a>.2 h\u27e9", [{"full_name": "le_total", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [289, 9], "def_end_pos": [289, 17]}, {"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "Finset.mem_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 17]}, {"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "sup_eq_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [156, 9], "def_end_pos": [156, 20]}, {"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "Finset.mem_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 17]}, {"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "sup_eq_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [161, 9], "def_end_pos": [161, 21]}]], "state_before": "case refine'_2.intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b9\nH : s\u271d.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\ns : Finset \u03b9\nhc : c \u2209 s\nhs : s.Nonempty\nb : \u03b9\nhb : b \u2208 s\nh' : sup' s hs f = f b\n\u22a2 \u2203 i \u2208 cons c s hc, f c \u2294 f b = f i", "state_after": "no goals"}, {"tactic": "exact \u27e8c, mem_cons.2 (Or.inl rfl), sup_eq_left.2 h\u27e9", "annotated_tactic": ["exact \u27e8c, <a>mem_cons</a>.2 (<a>Or.inl</a> <a>rfl</a>), <a>sup_eq_left</a>.2 h\u27e9", [{"full_name": "Finset.mem_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 17]}, {"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "sup_eq_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [156, 9], "def_end_pos": [156, 20]}]], "state_before": "case refine'_2.intro.intro.inl\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b9\nH : s\u271d.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\ns : Finset \u03b9\nhc : c \u2209 s\nhs : s.Nonempty\nb : \u03b9\nhb : b \u2208 s\nh' : sup' s hs f = f b\nh : f b \u2264 f c\n\u22a2 \u2203 i \u2208 cons c s hc, f c \u2294 f b = f i", "state_after": "no goals"}, {"tactic": "exact \u27e8b, mem_cons.2 (Or.inr hb), sup_eq_right.2 h\u27e9", "annotated_tactic": ["exact \u27e8b, <a>mem_cons</a>.2 (<a>Or.inr</a> hb), <a>sup_eq_right</a>.2 h\u27e9", [{"full_name": "Finset.mem_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 17]}, {"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "sup_eq_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [161, 9], "def_end_pos": [161, 21]}]], "state_before": "case refine'_2.intro.intro.inr\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b9\nH : s\u271d.Nonempty\nf\u271d : \u03b9 \u2192 \u03b1\na : \u03b1\nf : \u03b9 \u2192 \u03b1\nc : \u03b9\ns : Finset \u03b9\nhc : c \u2209 s\nhs : s.Nonempty\nb : \u03b9\nhb : b \u2208 s\nh' : sup' s hs f = f b\nh : f c \u2264 f b\n\u22a2 \u2203 i \u2208 cons c s hc, f c \u2294 f b = f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "full_name": "AffineMap.coe_mk", "start": [114, 1], "end": [115, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "IsLowerSet.erase", "start": [227, 1], "end": [228, 33], "traced_tactics": [{"tactic": "simpa using has", "annotated_tactic": ["simpa using has", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LE \u03b2\ns t : Set \u03b1\na : \u03b1\nhs : IsLowerSet s\nhas : \u2200 b \u2208 s, a \u2264 b \u2192 b = a\n\u22a2 \u2200 b \u2208 s, \u2200 c \u2208 {a}, c \u2264 b \u2192 b \u2208 {a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupIndep.lean", "full_name": "CompleteLattice.independent_ne_bot_iff_independent", "start": [412, 1], "end": [424, 12], "traced_tactics": [{"tactic": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.comp Subtype.val_injective\u27e9", "annotated_tactic": ["refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.comp <a>Subtype.val_injective</a>\u27e9", [{"full_name": "Subtype.val_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [122, 9], "def_end_pos": [122, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\n\u22a2 (Independent fun i => t \u2191i) \u2194 Independent t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : Independent fun i => t \u2191i\n\u22a2 Independent t"}, {"tactic": "simp only [independent_def] at h \u22a2", "annotated_tactic": ["simp only [<a>independent_def</a>] at h \u22a2", [{"full_name": "CompleteLattice.independent_def", "def_path": ".lake/packages/mathlib/Mathlib/Order/SupIndep.lean", "def_pos": [354, 9], "def_end_pos": [354, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : Independent fun i => t \u2191i\n\u22a2 Independent t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\n\u22a2 \u2200 (i : \u03b9), Disjoint (t i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t j)"}, {"tactic": "intro i", "annotated_tactic": ["intro i", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\n\u22a2 \u2200 (i : \u03b9), Disjoint (t i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t j)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\n\u22a2 Disjoint (t i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t j)"}, {"tactic": "cases eq_or_ne (t i) \u22a5 with\n| inl hi => simp [hi]\n| inr hi => ?_", "annotated_tactic": ["cases <a>eq_or_ne</a> (t i) \u22a5 with\n  | <a>inl</a> hi => simp [hi]\n  | <a>inr</a> hi => ?_", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}, {"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\n\u22a2 Disjoint (t i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t j)", "state_after": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i \u2260 \u22a5\n\u22a2 Disjoint (t i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t j)"}, {"tactic": "convert h \u27e8i, hi\u27e9", "annotated_tactic": ["convert h \u27e8i, hi\u27e9", []], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i \u2260 \u22a5\n\u22a2 Disjoint (t i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t j)", "state_after": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i \u2260 \u22a5\n\u22a2 \u2a06 j, \u2a06 (_ : j \u2260 i), t j = \u2a06 j, \u2a06 (_ : j \u2260 { val := i, property := hi }), t \u2191j"}, {"tactic": "have : \u2200 j, \u2a06 (_ : t j = \u22a5), t j = \u22a5 := fun j \u21a6 by simp only [iSup_eq_bot, imp_self]", "annotated_tactic": ["have : \u2200 j, \u2a06 (_ : t j = \u22a5), t j = \u22a5 := fun j \u21a6 by simp only [<a>iSup_eq_bot</a>, <a>imp_self</a>]", [{"full_name": "iSup_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1012, 9], "def_end_pos": [1012, 20]}, {"full_name": "imp_self", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1406, 17], "def_end_pos": [1406, 25]}]], "state_before": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i \u2260 \u22a5\n\u22a2 \u2a06 j, \u2a06 (_ : j \u2260 i), t j = \u2a06 j, \u2a06 (_ : j \u2260 { val := i, property := hi }), t \u2191j", "state_after": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i \u2260 \u22a5\nthis : \u2200 (j : \u03b9), \u2a06 (_ : t j = \u22a5), t j = \u22a5\n\u22a2 \u2a06 j, \u2a06 (_ : j \u2260 i), t j = \u2a06 j, \u2a06 (_ : j \u2260 { val := i, property := hi }), t \u2191j"}, {"tactic": "rw [iSup_split _ (fun j \u21a6 t j = \u22a5), iSup_subtype]", "annotated_tactic": ["rw [<a>iSup_split</a> _ (fun j \u21a6 t j = \u22a5), <a>iSup_subtype</a>]", [{"full_name": "iSup_split", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1393, 9], "def_end_pos": [1393, 19]}, {"full_name": "iSup_subtype", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1144, 9], "def_end_pos": [1144, 21]}]], "state_before": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i \u2260 \u22a5\nthis : \u2200 (j : \u03b9), \u2a06 (_ : t j = \u22a5), t j = \u22a5\n\u22a2 \u2a06 j, \u2a06 (_ : j \u2260 i), t j = \u2a06 j, \u2a06 (_ : j \u2260 { val := i, property := hi }), t \u2191j", "state_after": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i \u2260 \u22a5\nthis : \u2200 (j : \u03b9), \u2a06 (_ : t j = \u22a5), t j = \u22a5\n\u22a2 (\u2a06 i_1, \u2a06 (_ : t i_1 = \u22a5), \u2a06 (_ : i_1 \u2260 i), t i_1) \u2294 \u2a06 i_1, \u2a06 (_ : \u00act i_1 = \u22a5), \u2a06 (_ : i_1 \u2260 i), t i_1 =\n    \u2a06 i_1,\n      \u2a06 (h : t i_1 \u2260 \u22a5),\n        \u2a06 (_ : { val := i_1, property := h } \u2260 { val := i, property := hi }), t \u2191{ val := i_1, property := h }"}, {"tactic": "simp only [iSup_comm (\u03b9' := _ \u2260 i), this, ne_eq, sup_of_le_right, Subtype.mk.injEq, iSup_bot,\n  bot_le]", "annotated_tactic": ["simp only [<a>iSup_comm</a> (\u03b9' := _ \u2260 i), this, <a>ne_eq</a>, <a>sup_of_le_right</a>, Subtype.mk.injEq, <a>iSup_bot</a>,\n    <a>bot_le</a>]", [{"full_name": "iSup_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1085, 9], "def_end_pos": [1085, 18]}, {"full_name": "ne_eq", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [86, 17], "def_end_pos": [86, 22]}, {"full_name": "sup_of_le_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [178, 22], "def_end_pos": [178, 37]}, {"full_name": "iSup_bot", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1002, 9], "def_end_pos": [1002, 17]}, {"full_name": "bot_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [224, 9], "def_end_pos": [224, 15]}]], "state_before": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i \u2260 \u22a5\nthis : \u2200 (j : \u03b9), \u2a06 (_ : t j = \u22a5), t j = \u22a5\n\u22a2 (\u2a06 i_1, \u2a06 (_ : t i_1 = \u22a5), \u2a06 (_ : i_1 \u2260 i), t i_1) \u2294 \u2a06 i_1, \u2a06 (_ : \u00act i_1 = \u22a5), \u2a06 (_ : i_1 \u2260 i), t i_1 =\n    \u2a06 i_1,\n      \u2a06 (h : t i_1 \u2260 \u22a5),\n        \u2a06 (_ : { val := i_1, property := h } \u2260 { val := i, property := hi }), t \u2191{ val := i_1, property := h }", "state_after": "no goals"}, {"tactic": "simp [hi]", "annotated_tactic": ["simp [hi]", []], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i = \u22a5\n\u22a2 Disjoint (t i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t j)", "state_after": "no goals"}, {"tactic": "simp only [iSup_eq_bot, imp_self]", "annotated_tactic": ["simp only [<a>iSup_eq_bot</a>, <a>imp_self</a>]", [{"full_name": "iSup_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1012, 9], "def_end_pos": [1012, 20]}, {"full_name": "imp_self", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1406, 17], "def_end_pos": [1406, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht : Independent t\nh : \u2200 (i : { i // t i \u2260 \u22a5 }), Disjoint (t \u2191i) (\u2a06 j, \u2a06 (_ : j \u2260 i), t \u2191j)\ni : \u03b9\nhi : t i \u2260 \u22a5\nj : \u03b9\n\u22a2 \u2a06 (_ : t j = \u22a5), t j = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Arg.lean", "full_name": "Complex.abs_sub_eq", "start": [65, 1], "end": [66, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Hom.lean", "full_name": "NormedAddGroupHom.uniformContinuous", "start": [263, 11], "end": [264, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Squarefree.lean", "full_name": "Nat.prod_primeFactors_sdiff_of_squarefree", "start": [427, 1], "end": [432, 64], "traced_tactics": [{"tactic": "refine symm <| Nat.div_eq_of_eq_mul_left (Finset.prod_pos\n  fun p hp => (prime_of_mem_factors (List.mem_toFinset.mp (ht hp))).pos) ?_", "annotated_tactic": ["refine <a>symm</a> <| <a>Nat.div_eq_of_eq_mul_left</a> (<a>Finset.prod_pos</a>\n    fun p hp => (<a>prime_of_mem_factors</a> (List.mem_toFinset.mp (ht hp))).<a>pos</a>) ?_", [{"full_name": "symm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [303, 9], "def_end_pos": [303, 13]}, {"full_name": "Nat.div_eq_of_eq_mul_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [650, 19], "def_end_pos": [650, 40]}, {"full_name": "Finset.prod_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Order.lean", "def_pos": [648, 9], "def_end_pos": [648, 17]}, {"full_name": "Nat.prime_of_mem_factors", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factors.lean", "def_pos": [51, 9], "def_end_pos": [51, 29]}, {"full_name": "Nat.Prime.pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Prime.lean", "def_pos": [67, 9], "def_end_pos": [67, 18]}]], "state_before": "s : Finset \u2115\nm n\u271d p n : \u2115\nhn : Squarefree n\nt : Finset \u2115\nht : t \u2286 n.primeFactors\n\u22a2 \u220f a in n.primeFactors \\ t, a = n / \u220f a in t, a", "state_after": "s : Finset \u2115\nm n\u271d p n : \u2115\nhn : Squarefree n\nt : Finset \u2115\nht : t \u2286 n.primeFactors\n\u22a2 n = (\u220f a in n.primeFactors \\ t, a) * \u220f a in t, a"}, {"tactic": "rw [Finset.prod_sdiff ht, prod_primeFactors_of_squarefree hn]", "annotated_tactic": ["rw [<a>Finset.prod_sdiff</a> ht, <a>prod_primeFactors_of_squarefree</a> hn]", [{"full_name": "Finset.prod_sdiff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [541, 9], "def_end_pos": [541, 19]}, {"full_name": "Nat.prod_primeFactors_of_squarefree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Squarefree.lean", "def_pos": [397, 7], "def_end_pos": [397, 38]}]], "state_before": "s : Finset \u2115\nm n\u271d p n : \u2115\nhn : Squarefree n\nt : Finset \u2115\nht : t \u2286 n.primeFactors\n\u22a2 n = (\u220f a in n.primeFactors \\ t, a) * \u220f a in t, a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Ring.lean", "full_name": "zpow_bit0_neg", "start": [160, 1], "end": [161, 43], "traced_tactics": [{"tactic": "rw [zpow_bit0', zpow_bit0', neg_mul_neg]", "annotated_tactic": ["rw [<a>zpow_bit0'</a>, <a>zpow_bit0'</a>, <a>neg_mul_neg</a>]", [{"full_name": "zpow_bit0'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [373, 9], "def_end_pos": [373, 19]}, {"full_name": "zpow_bit0'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [373, 9], "def_end_pos": [373, 19]}, {"full_name": "neg_mul_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [315, 9], "def_end_pos": [315, 20]}]], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : DivisionMonoid R\ninst\u271d : HasDistribNeg R\na : R\nn : \u2124\n\u22a2 (-a) ^ bit0 n = a ^ bit0 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Perm.lean", "full_name": "List.Perm.rfl", "start": [33, 11], "end": [33, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "mem_affineSpan", "start": [572, 1], "end": [573, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.isLeast_min'", "start": [1532, 1], "end": [1533, 28], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "mathd_numbertheory_961", "start": [1009, 1], "end": [1011, 16], "traced_tactics": [{"tactic": "apply Eq.refl", "annotated_tactic": ["apply <a>Eq.refl</a>", [{"full_name": "Eq.refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [279, 5], "def_end_pos": [279, 9]}]], "state_before": "\u22a2 2003 % 11 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_apply_ite", "start": [1122, 1], "end": [1126, 96], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean", "full_name": "ContDiff.cexp", "start": [159, 1], "end": [160, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.coe_smul", "start": [372, 1], "end": [373, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Defs.lean", "full_name": "Int.nat_succ_eq_int_succ", "start": [88, 1], "end": [88, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Group/Arithmetic.lean", "full_name": "measurable_div_const'", "start": [188, 1], "end": [189, 93], "traced_tactics": [{"tactic": "simp_rw [div_eq_mul_inv, measurable_mul_const]", "annotated_tactic": ["simp_rw [<a>div_eq_mul_inv</a>, <a>measurable_mul_const</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "MeasurableMul.measurable_mul_const", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Group/Arithmetic.lean", "def_pos": [82, 3], "def_end_pos": [82, 23]}]], "state_before": "\u03b1 : Type u_1\nG : Type u_2\ninst\u271d\u00b2 : DivInvMonoid G\ninst\u271d\u00b9 : MeasurableSpace G\ninst\u271d : MeasurableMul G\ng : G\n\u22a2 Measurable fun h => h / g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "compl_top", "start": [843, 1], "end": [844, 93], "traced_tactics": [{"tactic": "rw [le_compl_iff_disjoint_right, disjoint_top, le_bot_iff]", "annotated_tactic": ["rw [<a>le_compl_iff_disjoint_right</a>, <a>disjoint_top</a>, <a>le_bot_iff</a>]", [{"full_name": "le_compl_iff_disjoint_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [772, 9], "def_end_pos": [772, 36]}, {"full_name": "disjoint_top", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [116, 9], "def_end_pos": [116, 21]}, {"full_name": "le_bot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [323, 9], "def_end_pos": [323, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : HeytingAlgebra \u03b1\na\u271d b c a : \u03b1\n\u22a2 a \u2264 \u22a4\u1d9c \u2194 a \u2264 \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounded.lean", "full_name": "Set.bounded_le_of_bounded_lt", "start": [94, 1], "end": [95, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.range_quotient_lift", "start": [966, 1], "end": [968, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearMap.coe_add'", "start": [731, 1], "end": [732, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.getOrElse_of_not_dom", "start": [274, 1], "end": [276, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.add_mul_ediv_left", "start": [114, 1], "end": [116, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Group/Arithmetic.lean", "full_name": "AEMeasurable.inv", "start": [472, 1], "end": [473, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Ray.lean", "full_name": "SameRay.trans", "start": [104, 1], "end": [113, 47], "traced_tactics": [{"tactic": "rcases eq_or_ne x 0 with (rfl | hx)", "annotated_tactic": ["rcases <a>eq_or_ne</a> x 0 with (rfl | hx)", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "R : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy : y = 0 \u2192 x = 0 \u2228 z = 0\n\u22a2 SameRay R x z", "state_after": "case inl\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\ny z : M\nhyz : SameRay R y z\nhxy : SameRay R 0 y\nhy : y = 0 \u2192 0 = 0 \u2228 z = 0\n\u22a2 SameRay R 0 z\n\ncase inr\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\n\u22a2 SameRay R x z"}, {"tactic": "rcases eq_or_ne z 0 with (rfl | hz)", "annotated_tactic": ["rcases <a>eq_or_ne</a> z 0 with (rfl | hz)", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "case inr\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\n\u22a2 SameRay R x z", "state_after": "case inr.inl\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y : M\nhxy : SameRay R x y\nhx : x \u2260 0\nhyz : SameRay R y 0\nhy : y = 0 \u2192 x = 0 \u2228 0 = 0\n\u22a2 SameRay R x 0\n\ncase inr.inr\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\n\u22a2 SameRay R x z"}, {"tactic": "rcases eq_or_ne y 0 with (rfl | hy)", "annotated_tactic": ["rcases <a>eq_or_ne</a> y 0 with (rfl | hy)", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "case inr.inr\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\n\u22a2 SameRay R x z", "state_after": "case inr.inr.inl\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx z : M\nhx : x \u2260 0\nhz : z \u2260 0\nhxy : SameRay R x 0\nhyz : SameRay R 0 z\nhy : 0 = 0 \u2192 x = 0 \u2228 z = 0\n\u22a2 SameRay R x z\n\ncase inr.inr.inr\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy\u271d : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\nhy : y \u2260 0\n\u22a2 SameRay R x z"}, {"tactic": "rcases hxy.exists_pos hx hy with \u27e8r\u2081, r\u2082, hr\u2081, hr\u2082, h\u2081\u27e9", "annotated_tactic": ["rcases hxy.exists_pos hx hy with \u27e8r\u2081, r\u2082, hr\u2081, hr\u2082, h\u2081\u27e9", []], "state_before": "case inr.inr.inr\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy\u271d : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\nhy : y \u2260 0\n\u22a2 SameRay R x z", "state_after": "case inr.inr.inr.intro.intro.intro.intro\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy\u271d : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\nhy : y \u2260 0\nr\u2081 r\u2082 : R\nhr\u2081 : 0 < r\u2081\nhr\u2082 : 0 < r\u2082\nh\u2081 : r\u2081 \u2022 x = r\u2082 \u2022 y\n\u22a2 SameRay R x z"}, {"tactic": "rcases hyz.exists_pos hy hz with \u27e8r\u2083, r\u2084, hr\u2083, hr\u2084, h\u2082\u27e9", "annotated_tactic": ["rcases hyz.exists_pos hy hz with \u27e8r\u2083, r\u2084, hr\u2083, hr\u2084, h\u2082\u27e9", []], "state_before": "case inr.inr.inr.intro.intro.intro.intro\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy\u271d : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\nhy : y \u2260 0\nr\u2081 r\u2082 : R\nhr\u2081 : 0 < r\u2081\nhr\u2082 : 0 < r\u2082\nh\u2081 : r\u2081 \u2022 x = r\u2082 \u2022 y\n\u22a2 SameRay R x z", "state_after": "case inr.inr.inr.intro.intro.intro.intro.intro.intro.intro.intro\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy\u271d : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\nhy : y \u2260 0\nr\u2081 r\u2082 : R\nhr\u2081 : 0 < r\u2081\nhr\u2082 : 0 < r\u2082\nh\u2081 : r\u2081 \u2022 x = r\u2082 \u2022 y\nr\u2083 r\u2084 : R\nhr\u2083 : 0 < r\u2083\nhr\u2084 : 0 < r\u2084\nh\u2082 : r\u2083 \u2022 y = r\u2084 \u2022 z\n\u22a2 SameRay R x z"}, {"tactic": "refine' Or.inr (Or.inr <| \u27e8r\u2083 * r\u2081, r\u2082 * r\u2084, mul_pos hr\u2083 hr\u2081, mul_pos hr\u2082 hr\u2084, _\u27e9)", "annotated_tactic": ["refine' <a>Or.inr</a> (<a>Or.inr</a> <| \u27e8r\u2083 * r\u2081, r\u2082 * r\u2084, <a>mul_pos</a> hr\u2083 hr\u2081, <a>mul_pos</a> hr\u2082 hr\u2084, _\u27e9)", [{"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "mul_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [406, 7], "def_end_pos": [406, 14]}, {"full_name": "mul_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [406, 7], "def_end_pos": [406, 14]}]], "state_before": "case inr.inr.inr.intro.intro.intro.intro.intro.intro.intro.intro\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy\u271d : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\nhy : y \u2260 0\nr\u2081 r\u2082 : R\nhr\u2081 : 0 < r\u2081\nhr\u2082 : 0 < r\u2082\nh\u2081 : r\u2081 \u2022 x = r\u2082 \u2022 y\nr\u2083 r\u2084 : R\nhr\u2083 : 0 < r\u2083\nhr\u2084 : 0 < r\u2084\nh\u2082 : r\u2083 \u2022 y = r\u2084 \u2022 z\n\u22a2 SameRay R x z", "state_after": "case inr.inr.inr.intro.intro.intro.intro.intro.intro.intro.intro\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy\u271d : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\nhy : y \u2260 0\nr\u2081 r\u2082 : R\nhr\u2081 : 0 < r\u2081\nhr\u2082 : 0 < r\u2082\nh\u2081 : r\u2081 \u2022 x = r\u2082 \u2022 y\nr\u2083 r\u2084 : R\nhr\u2083 : 0 < r\u2083\nhr\u2084 : 0 < r\u2084\nh\u2082 : r\u2083 \u2022 y = r\u2084 \u2022 z\n\u22a2 (r\u2083 * r\u2081) \u2022 x = (r\u2082 * r\u2084) \u2022 z"}, {"tactic": "rw [mul_smul, mul_smul, h\u2081, \u2190 h\u2082, smul_comm]", "annotated_tactic": ["rw [<a>mul_smul</a>, <a>mul_smul</a>, h\u2081, \u2190 h\u2082, <a>smul_comm</a>]", [{"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}, {"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}, {"full_name": "SMulCommClass.smul_comm", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [187, 3], "def_end_pos": [187, 12]}]], "state_before": "case inr.inr.inr.intro.intro.intro.intro.intro.intro.intro.intro\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y z : M\nhxy : SameRay R x y\nhyz : SameRay R y z\nhy\u271d : y = 0 \u2192 x = 0 \u2228 z = 0\nhx : x \u2260 0\nhz : z \u2260 0\nhy : y \u2260 0\nr\u2081 r\u2082 : R\nhr\u2081 : 0 < r\u2081\nhr\u2082 : 0 < r\u2082\nh\u2081 : r\u2081 \u2022 x = r\u2082 \u2022 y\nr\u2083 r\u2084 : R\nhr\u2083 : 0 < r\u2083\nhr\u2084 : 0 < r\u2084\nh\u2082 : r\u2083 \u2022 y = r\u2084 \u2022 z\n\u22a2 (r\u2083 * r\u2081) \u2022 x = (r\u2082 * r\u2084) \u2022 z", "state_after": "no goals"}, {"tactic": "exact zero_left z", "annotated_tactic": ["exact <a>zero_left</a> z", [{"full_name": "SameRay.zero_left", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Ray.lean", "def_pos": [53, 9], "def_end_pos": [53, 18]}]], "state_before": "case inl\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\ny z : M\nhyz : SameRay R y z\nhxy : SameRay R 0 y\nhy : y = 0 \u2192 0 = 0 \u2228 z = 0\n\u22a2 SameRay R 0 z", "state_after": "no goals"}, {"tactic": "exact zero_right x", "annotated_tactic": ["exact <a>zero_right</a> x", [{"full_name": "SameRay.zero_right", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Ray.lean", "def_pos": [58, 9], "def_end_pos": [58, 19]}]], "state_before": "case inr.inl\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx y : M\nhxy : SameRay R x y\nhx : x \u2260 0\nhyz : SameRay R y 0\nhy : y = 0 \u2192 x = 0 \u2228 0 = 0\n\u22a2 SameRay R x 0", "state_after": "no goals"}, {"tactic": "exact (hy rfl).elim (fun h => (hx h).elim) fun h => (hz h).elim", "annotated_tactic": ["exact (hy <a>rfl</a>).<a>elim</a> (fun h => (hx h).<a>elim</a>) fun h => (hz h).<a>elim</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Or.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [546, 9], "def_end_pos": [546, 16]}, {"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}, {"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}]], "state_before": "case inr.inr.inl\nR : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx z : M\nhx : x \u2260 0\nhz : z \u2260 0\nhxy : SameRay R x 0\nhyz : SameRay R 0 z\nhy : 0 = 0 \u2192 x = 0 \u2228 z = 0\n\u22a2 SameRay R x z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Quotient.lean", "full_name": "Ideal.Quotient.nontrivial", "start": [146, 11], "end": [147, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.support_prod_subset", "start": [2166, 1], "end": [2168, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Cardinal.IsRegular.pos", "start": [956, 1], "end": [957, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Discrete.lean", "full_name": "discreteTopology_iff_orderTopology_of_pred_succ'", "start": [66, 1], "end": [72, 70], "traced_tactics": [{"tactic": "refine' \u27e8fun h => \u27e8_\u27e9, fun h => \u27e8_\u27e9\u27e9", "annotated_tactic": ["refine' \u27e8fun h => \u27e8_\u27e9, fun h => \u27e8_\u27e9\u27e9", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u22a2 DiscreteTopology \u03b1 \u2194 OrderTopology \u03b1", "state_after": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : DiscreteTopology \u03b1\n\u22a2 inst\u271d\u2075 = generateFrom {s | \u2203 a, s = Ioi a \u2228 s = Iio a}\n\ncase refine'_2\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : OrderTopology \u03b1\n\u22a2 inst\u271d\u2075 = \u22a5"}, {"tactic": "rw [h.eq_bot]", "annotated_tactic": ["rw [h.eq_bot]", []], "state_before": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : DiscreteTopology \u03b1\n\u22a2 inst\u271d\u2075 = generateFrom {s | \u2203 a, s = Ioi a \u2228 s = Iio a}", "state_after": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : DiscreteTopology \u03b1\n\u22a2 \u22a5 = generateFrom {s | \u2203 a, s = Ioi a \u2228 s = Iio a}"}, {"tactic": "exact bot_topologicalSpace_eq_generateFrom_of_pred_succOrder", "annotated_tactic": ["exact <a>bot_topologicalSpace_eq_generateFrom_of_pred_succOrder</a>", [{"full_name": "bot_topologicalSpace_eq_generateFrom_of_pred_succOrder", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/Discrete.lean", "def_pos": [51, 9], "def_end_pos": [51, 63]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : DiscreteTopology \u03b1\n\u22a2 \u22a5 = generateFrom {s | \u2203 a, s = Ioi a \u2228 s = Iio a}", "state_after": "no goals"}, {"tactic": "rw [h.topology_eq_generate_intervals]", "annotated_tactic": ["rw [h.topology_eq_generate_intervals]", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : OrderTopology \u03b1\n\u22a2 inst\u271d\u2075 = \u22a5", "state_after": "case refine'_2\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : OrderTopology \u03b1\n\u22a2 generateFrom {s | \u2203 a, s = Ioi a \u2228 s = Iio a} = \u22a5"}, {"tactic": "exact bot_topologicalSpace_eq_generateFrom_of_pred_succOrder.symm", "annotated_tactic": ["exact bot_topologicalSpace_eq_generateFrom_of_pred_succOrder.symm", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PredOrder \u03b1\ninst\u271d\u00b2 : SuccOrder \u03b1\ninst\u271d\u00b9 : NoMinOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\nh : OrderTopology \u03b1\n\u22a2 generateFrom {s | \u2203 a, s = Ioi a \u2228 s = Iio a} = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Sum/Lemmas.lean", "full_name": "Sum.Lex.mono_left", "start": [208, 1], "end": [209, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/TensorProduct/Basic.lean", "full_name": "Algebra.TensorProduct.congr_apply", "start": [926, 1], "end": [928, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.map_prod", "start": [822, 8], "end": [824, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.inter_val_nd", "start": [1628, 1], "end": [1629, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.lift_umax'", "start": [210, 1], "end": [211, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "dite_eq_or_eq", "start": [1205, 1], "end": [1206, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.erase_cons_head", "start": [1050, 1], "end": [1051, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "IsClosed.frontier_eq", "start": [726, 1], "end": [727, 31], "traced_tactics": [{"tactic": "rw [frontier, hs.closure_eq]", "annotated_tactic": ["rw [<a>frontier</a>, hs.closure_eq]", [{"full_name": "frontier", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [121, 5], "def_end_pos": [121, 13]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Sort w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : X\ns s\u2081 s\u2082 t : Set X\np p\u2081 p\u2082 : X \u2192 Prop\ninst\u271d : TopologicalSpace X\nhs : IsClosed s\n\u22a2 frontier s = s \\ interior s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Finite.lean", "full_name": "Set.Finite.inv", "start": [37, 1], "end": [38, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.coe_replicate", "start": [925, 1], "end": [925, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/CountableInter.lean", "full_name": "eventually_countable_forall", "start": [61, 1], "end": [64, 59], "traced_tactics": [{"tactic": "simpa only [Filter.Eventually, setOf_forall] using\n  @countable_iInter_mem _ _ l _ _ fun i => { x | p x i }", "annotated_tactic": ["simpa only [<a>Filter.Eventually</a>, <a>setOf_forall</a>] using\n    @<a>countable_iInter_mem</a> _ _ l _ _ fun i => { x | p x i }", [{"full_name": "Filter.Eventually", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1089, 15], "def_end_pos": [1089, 25]}, {"full_name": "Set.setOf_forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [236, 9], "def_end_pos": [236, 21]}, {"full_name": "countable_iInter_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/CountableInter.lean", "def_pos": [50, 9], "def_end_pos": [50, 29]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\ninst\u271d\u00b9 : CountableInterFilter l\ninst\u271d : Countable \u03b9\np : \u03b1 \u2192 \u03b9 \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : \u03b1) in l, \u2200 (i : \u03b9), p x i) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (x : \u03b1) in l, p x i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.mem_map_of_mem", "start": [1426, 1], "end": [1427, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.IsBoundedUnder.comp", "start": [123, 1], "end": [125, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "one_le_bit1", "start": [968, 1], "end": [969, 98], "traced_tactics": [{"tactic": "rw [bit1, le_add_iff_nonneg_left, bit0, \u2190 two_mul, mul_nonneg_iff_of_pos_left (zero_lt_two' \u03b1)]", "annotated_tactic": ["rw [<a>bit1</a>, <a>le_add_iff_nonneg_left</a>, <a>bit0</a>, \u2190 <a>two_mul</a>, <a>mul_nonneg_iff_of_pos_left</a> (<a>zero_lt_two'</a> \u03b1)]", [{"full_name": "bit1", "def_path": ".lake/packages/mathlib/Mathlib/Init/ZeroOne.lean", "def_pos": [39, 34], "def_end_pos": [39, 38]}, {"full_name": "le_add_iff_nonneg_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [465, 30], "def_end_pos": [465, 52]}, {"full_name": "bit0", "def_path": ".lake/packages/mathlib/Mathlib/Init/ZeroOne.lean", "def_pos": [36, 34], "def_end_pos": [36, 38]}, {"full_name": "two_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [179, 9], "def_end_pos": [179, 16]}, {"full_name": "mul_nonneg_iff_of_pos_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [899, 9], "def_end_pos": [899, 35]}, {"full_name": "zero_lt_two'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [89, 7], "def_end_pos": [89, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : LinearOrderedSemiring \u03b1\na b c d : \u03b1\n\u22a2 1 \u2264 bit1 a \u2194 0 \u2264 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.star_apply", "start": [2423, 1], "end": [2424, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Block.lean", "full_name": "Matrix.blockDiag'_smul", "start": [926, 1], "end": [928, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean", "full_name": "Ideal.polynomial_not_isField", "start": [716, 1], "end": [723, 17], "traced_tactics": [{"tactic": "nontriviality R", "annotated_tactic": ["nontriviality R", []], "state_before": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u22a2 \u00acIsField R[X]", "state_after": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\n\u22a2 \u00acIsField R[X]"}, {"tactic": "intro hR", "annotated_tactic": ["intro hR", []], "state_before": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\n\u22a2 \u00acIsField R[X]", "state_after": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\n\u22a2 False"}, {"tactic": "obtain \u27e8p, hp\u27e9 := hR.mul_inv_cancel X_ne_zero", "annotated_tactic": ["obtain \u27e8p, hp\u27e9 := hR.mul_inv_cancel <a>X_ne_zero</a>", [{"full_name": "Polynomial.X_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1259, 9], "def_end_pos": [1259, 18]}]], "state_before": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\n\u22a2 False"}, {"tactic": "have hp0 : p \u2260 0 := right_ne_zero_of_mul_eq_one hp", "annotated_tactic": ["have hp0 : p \u2260 0 := <a>right_ne_zero_of_mul_eq_one</a> hp", [{"full_name": "right_ne_zero_of_mul_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [150, 9], "def_end_pos": [150, 36]}]], "state_before": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\n\u22a2 False"}, {"tactic": "have := degree_lt_degree_mul_X hp0", "annotated_tactic": ["have := <a>degree_lt_degree_mul_X</a> hp0", [{"full_name": "Polynomial.degree_lt_degree_mul_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1179, 9], "def_end_pos": [1179, 31]}]], "state_before": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : degree p < degree (p * X)\n\u22a2 False"}, {"tactic": "rw [\u2190 X_mul, congr_arg degree hp, degree_one, Nat.WithBot.lt_zero_iff, degree_eq_bot] at this", "annotated_tactic": ["rw [\u2190 <a>X_mul</a>, <a>congr_arg</a> <a>degree</a> hp, <a>degree_one</a>, <a>Nat.WithBot.lt_zero_iff</a>, <a>degree_eq_bot</a>] at this", [{"full_name": "Polynomial.X_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [587, 9], "def_end_pos": [587, 14]}, {"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "Polynomial.degree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [54, 5], "def_end_pos": [54, 11]}, {"full_name": "Polynomial.degree_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [513, 9], "def_end_pos": [513, 19]}, {"full_name": "Nat.WithBot.lt_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/WithBot.lean", "def_pos": [67, 9], "def_end_pos": [67, 20]}, {"full_name": "Polynomial.degree_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [120, 9], "def_end_pos": [120, 22]}]], "state_before": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : degree p < degree (p * X)\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p = 0\n\u22a2 False"}, {"tactic": "exact hp0 this", "annotated_tactic": ["exact hp0 this", []], "state_before": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\na\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Cover.lean", "full_name": "CovBy.unique_right", "start": [460, 1], "end": [461, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "inv_lt_inv_of_lt", "start": [287, 1], "end": [288, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Sum/Lemmas.lean", "full_name": "Sum.getRight?_eq_some_iff", "start": [67, 9], "end": [68, 66], "traced_tactics": [{"tactic": "cases x <;> simp only [getRight?, Option.some.injEq, inr.injEq]", "annotated_tactic": ["cases x <;> simp only [<a>getRight?</a>, Option.some.injEq, inr.injEq]", [{"full_name": "Sum.getRight?", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Sum.lean", "def_pos": [20, 5], "def_end_pos": [20, 14]}]], "state_before": "\u03b2\u271d : Type u_1\nb : \u03b2\u271d\n\u03b1\u271d : Type u_2\nx : \u03b1\u271d \u2295 \u03b2\u271d\n\u22a2 getRight? x = some b \u2194 x = inr b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.cons_swap", "start": [171, 1], "end": [172, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/LaurentSeries.lean", "full_name": "LaurentSeries.ofPowerSeries_powerSeriesPart", "start": [111, 1], "end": [114, 88], "traced_tactics": [{"tactic": "refine' Eq.trans _ (congr rfl x.single_order_mul_powerSeriesPart)", "annotated_tactic": ["refine' <a>Eq.trans</a> _ (<a>congr</a> <a>rfl</a> x.single_order_mul_powerSeriesPart)", [{"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}, {"full_name": "congr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [372, 9], "def_end_pos": [372, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nx : LaurentSeries R\n\u22a2 (ofPowerSeries \u2124 R) (powerSeriesPart x) = (single (-order x)) 1 * x", "state_after": "R : Type u_1\ninst\u271d : Semiring R\nx : LaurentSeries R\n\u22a2 (ofPowerSeries \u2124 R) (powerSeriesPart x) =\n    (single (-order x)) 1 * ((single (order x)) 1 * (ofPowerSeries \u2124 R) (powerSeriesPart x))"}, {"tactic": "rw [\u2190 mul_assoc, single_mul_single, neg_add_self, mul_one, \u2190 C_apply, C_one, one_mul]", "annotated_tactic": ["rw [\u2190 <a>mul_assoc</a>, <a>single_mul_single</a>, <a>neg_add_self</a>, <a>mul_one</a>, \u2190 <a>C_apply</a>, <a>C_one</a>, <a>one_mul</a>]", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "HahnSeries.single_mul_single", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "def_pos": [431, 9], "def_end_pos": [431, 26]}, {"full_name": "neg_add_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1144, 3], "def_end_pos": [1144, 14]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "HahnSeries.C_apply", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "def_pos": [451, 3], "def_end_pos": [451, 8]}, {"full_name": "HahnSeries.C_one", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "def_pos": [468, 9], "def_end_pos": [468, 14]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nx : LaurentSeries R\n\u22a2 (ofPowerSeries \u2124 R) (powerSeriesPart x) =\n    (single (-order x)) 1 * ((single (order x)) 1 * (ofPowerSeries \u2124 R) (powerSeriesPart x))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sum/Order.lean", "full_name": "Sum.Lex.inl_le_inl_iff", "start": [344, 1], "end": [345, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean", "full_name": "Submonoid.LocalizationMap.map_mul_right", "start": [1224, 1], "end": [1225, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "full_name": "HasFDerivAt.le_of_lip'", "start": [336, 1], "end": [346, 46], "traced_tactics": [{"tactic": "refine' le_of_forall_pos_le_add fun \u03b5 \u03b50 => opNorm_le_of_nhds_zero _ _", "annotated_tactic": ["refine' <a>le_of_forall_pos_le_add</a> fun \u03b5 \u03b50 => <a>opNorm_le_of_nhds_zero</a> _ _", [{"full_name": "le_of_forall_pos_le_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [69, 3], "def_end_pos": [69, 14]}, {"full_name": "ContinuousLinearMap.opNorm_le_of_nhds_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean", "def_pos": [320, 9], "def_end_pos": [320, 31]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u22a2 \u2016f'\u2016 \u2264 C", "state_after": "case refine'_1\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\n\u22a2 0 \u2264 C + \u03b5\n\ncase refine'_2\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\n\u22a2 \u2200\u1da0 (x : E) in \ud835\udcdd 0, \u2016f' x\u2016 \u2264 (C + \u03b5) * \u2016x\u2016"}, {"tactic": "exact add_nonneg hC\u2080 \u03b50.le", "annotated_tactic": ["exact <a>add_nonneg</a> hC\u2080 \u03b50.le", [{"full_name": "add_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [1092, 24], "def_end_pos": [1092, 34]}]], "state_before": "case refine'_1\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\n\u22a2 0 \u2264 C + \u03b5\n\ncase refine'_2\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\n\u22a2 \u2200\u1da0 (x : E) in \ud835\udcdd 0, \u2016f' x\u2016 \u2264 (C + \u03b5) * \u2016x\u2016", "state_after": "case refine'_2\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\n\u22a2 \u2200\u1da0 (x : E) in \ud835\udcdd 0, \u2016f' x\u2016 \u2264 (C + \u03b5) * \u2016x\u2016"}, {"tactic": "rw [\u2190 map_add_left_nhds_zero x\u2080, eventually_map] at hlip", "annotated_tactic": ["rw [\u2190 <a>map_add_left_nhds_zero</a> x\u2080, <a>eventually_map</a>] at hlip", [{"full_name": "map_add_left_nhds_zero", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [832, 3], "def_end_pos": [832, 14]}, {"full_name": "Filter.eventually_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1936, 9], "def_end_pos": [1936, 23]}]], "state_before": "case refine'_2\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : E) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\n\u22a2 \u2200\u1da0 (x : E) in \ud835\udcdd 0, \u2016f' x\u2016 \u2264 (C + \u03b5) * \u2016x\u2016", "state_after": "case refine'_2\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (a : E) in \ud835\udcdd 0, \u2016f (x\u2080 + a) - f x\u2080\u2016 \u2264 C * \u2016x\u2080 + a - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\n\u22a2 \u2200\u1da0 (x : E) in \ud835\udcdd 0, \u2016f' x\u2016 \u2264 (C + \u03b5) * \u2016x\u2016"}, {"tactic": "filter_upwards [isLittleO_iff.1 (hasFDerivAt_iff_isLittleO_nhds_zero.1 hf) \u03b50, hlip] with y hy hyC", "annotated_tactic": ["filter_upwards [<a>isLittleO_iff</a>.1 (<a>hasFDerivAt_iff_isLittleO_nhds_zero</a>.1 hf) \u03b50, hlip] with y hy hyC", [{"full_name": "Asymptotics.isLittleO_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Asymptotics/Asymptotics.lean", "def_pos": [186, 9], "def_end_pos": [186, 22]}, {"full_name": "hasFDerivAt_iff_isLittleO_nhds_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [327, 9], "def_end_pos": [327, 44]}]], "state_before": "case refine'_2\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (a : E) in \ud835\udcdd 0, \u2016f (x\u2080 + a) - f x\u2080\u2016 \u2264 C * \u2016x\u2080 + a - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\n\u22a2 \u2200\u1da0 (x : E) in \ud835\udcdd 0, \u2016f' x\u2016 \u2264 (C + \u03b5) * \u2016x\u2016", "state_after": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (a : E) in \ud835\udcdd 0, \u2016f (x\u2080 + a) - f x\u2080\u2016 \u2264 C * \u2016x\u2080 + a - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\ny : E\nhy : \u2016f (x\u2080 + y) - f x\u2080 - f' y\u2016 \u2264 \u03b5 * \u2016y\u2016\nhyC : \u2016f (x\u2080 + y) - f x\u2080\u2016 \u2264 C * \u2016x\u2080 + y - x\u2080\u2016\n\u22a2 \u2016f' y\u2016 \u2264 (C + \u03b5) * \u2016y\u2016"}, {"tactic": "rw [add_sub_cancel'] at hyC", "annotated_tactic": ["rw [<a>add_sub_cancel'</a>] at hyC", [{"full_name": "add_sub_cancel'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1026, 30], "def_end_pos": [1026, 45]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (a : E) in \ud835\udcdd 0, \u2016f (x\u2080 + a) - f x\u2080\u2016 \u2264 C * \u2016x\u2080 + a - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\ny : E\nhy : \u2016f (x\u2080 + y) - f x\u2080 - f' y\u2016 \u2264 \u03b5 * \u2016y\u2016\nhyC : \u2016f (x\u2080 + y) - f x\u2080\u2016 \u2264 C * \u2016x\u2080 + y - x\u2080\u2016\n\u22a2 \u2016f' y\u2016 \u2264 (C + \u03b5) * \u2016y\u2016", "state_after": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (a : E) in \ud835\udcdd 0, \u2016f (x\u2080 + a) - f x\u2080\u2016 \u2264 C * \u2016x\u2080 + a - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\ny : E\nhy : \u2016f (x\u2080 + y) - f x\u2080 - f' y\u2016 \u2264 \u03b5 * \u2016y\u2016\nhyC : \u2016f (x\u2080 + y) - f x\u2080\u2016 \u2264 C * \u2016y\u2016\n\u22a2 \u2016f' y\u2016 \u2264 (C + \u03b5) * \u2016y\u2016"}, {"tactic": "calc\n  \u2016f' y\u2016 \u2264 \u2016f (x\u2080 + y) - f x\u2080\u2016 + \u2016f (x\u2080 + y) - f x\u2080 - f' y\u2016 := norm_le_insert _ _\n  _ \u2264 C * \u2016y\u2016 + \u03b5 * \u2016y\u2016 := (add_le_add hyC hy)\n  _ = (C + \u03b5) * \u2016y\u2016 := (add_mul _ _ _).symm", "annotated_tactic": ["calc\n    \u2016f' y\u2016 \u2264 \u2016f (x\u2080 + y) - f x\u2080\u2016 + \u2016f (x\u2080 + y) - f x\u2080 - f' y\u2016 := <a>norm_le_insert</a> _ _\n    _ \u2264 C * \u2016y\u2016 + \u03b5 * \u2016y\u2016 := (<a>add_le_add</a> hyC hy)\n    _ = (C + \u03b5) * \u2016y\u2016 := (<a>add_mul</a> _ _ _).<a>symm</a>", [{"full_name": "norm_le_insert", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [669, 7], "def_end_pos": [669, 21]}, {"full_name": "add_le_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [205, 32], "def_end_pos": [205, 42]}, {"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf\u271d f\u2080 f\u2081 g : E \u2192 F\nf'\u271d f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx\u2080 : E\nhf : HasFDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (a : E) in \ud835\udcdd 0, \u2016f (x\u2080 + a) - f x\u2080\u2016 \u2264 C * \u2016x\u2080 + a - x\u2080\u2016\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\ny : E\nhy : \u2016f (x\u2080 + y) - f x\u2080 - f' y\u2016 \u2264 \u03b5 * \u2016y\u2016\nhyC : \u2016f (x\u2080 + y) - f x\u2080\u2016 \u2264 C * \u2016y\u2016\n\u22a2 \u2016f' y\u2016 \u2264 (C + \u03b5) * \u2016y\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sum/Basic.lean", "full_name": "Sum.eq_left_iff_getLeft_eq", "start": [54, 1], "end": [55, 19], "traced_tactics": [{"tactic": "cases x <;> simp", "annotated_tactic": ["cases x <;> simp", []], "state_before": "\u03b1 : Type u\n\u03b1' : Type w\n\u03b2 : Type v\n\u03b2' : Type x\n\u03b3 : Type u_1\n\u03b4 : Type u_2\nx y : \u03b1 \u2295 \u03b2\na : \u03b1\n\u22a2 x = inl a \u2194 \u2203 h, getLeft x h = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.eq_mul_of_ediv_eq_left", "start": [524, 11], "end": [526, 55], "traced_tactics": [{"tactic": "rw [Int.mul_comm, Int.eq_mul_of_ediv_eq_right H1 H2]", "annotated_tactic": ["rw [<a>Int.mul_comm</a>, <a>Int.eq_mul_of_ediv_eq_right</a> H1 H2]", [{"full_name": "Int.mul_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [353, 19], "def_end_pos": [353, 27]}, {"full_name": "Int.eq_mul_of_ediv_eq_right", "def_path": ".lake/packages/std/Std/Data/Int/DivMod.lean", "def_pos": [487, 19], "def_end_pos": [487, 42]}]], "state_before": "a b c : Int\nH1 : b \u2223 a\nH2 : a / b = c\n\u22a2 a = c * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "Odd.neg_pow", "start": [433, 1], "end": [435, 55], "traced_tactics": [{"tactic": "rintro \u27e8c, rfl\u27e9 a", "annotated_tactic": ["rintro \u27e8c, rfl\u27e9 a", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : HasDistribNeg \u03b1\na : \u03b1\nn : \u2115\n\u22a2 Odd n \u2192 \u2200 (a : \u03b1), (-a) ^ n = -a ^ n", "state_after": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : HasDistribNeg \u03b1\na\u271d : \u03b1\nc : \u2115\na : \u03b1\n\u22a2 (-a) ^ (2 * c + 1) = -a ^ (2 * c + 1)"}, {"tactic": "simp_rw [pow_add, pow_mul, neg_sq, pow_one, mul_neg]", "annotated_tactic": ["simp_rw [<a>pow_add</a>, <a>pow_mul</a>, <a>neg_sq</a>, <a>pow_one</a>, <a>mul_neg</a>]", [{"full_name": "pow_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [103, 9], "def_end_pos": [103, 16]}, {"full_name": "pow_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [110, 9], "def_end_pos": [110, 16]}, {"full_name": "neg_sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [141, 9], "def_end_pos": [141, 15]}, {"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}, {"full_name": "mul_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [311, 9], "def_end_pos": [311, 16]}]], "state_before": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : HasDistribNeg \u03b1\na\u271d : \u03b1\nc : \u2115\na : \u03b1\n\u22a2 (-a) ^ (2 * c + 1) = -a ^ (2 * c + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Lemmas.lean", "full_name": "IsRelPrime.pow_right", "start": [304, 1], "end": [306, 42], "traced_tactics": [{"tactic": "rw [\u2190 Finset.card_range n, \u2190 Finset.prod_const]", "annotated_tactic": ["rw [\u2190 <a>Finset.card_range</a> n, \u2190 <a>Finset.prod_const</a>]", [{"full_name": "Finset.card_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [199, 9], "def_end_pos": [199, 19]}, {"full_name": "Finset.prod_const", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1665, 9], "def_end_pos": [1665, 19]}]], "state_before": "\u03b1 : Type u_1\nI : Type ?u.45900\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nx y z : \u03b1\ns : I \u2192 \u03b1\nt : Finset I\nm n : \u2115\nH : IsRelPrime x y\n\u22a2 IsRelPrime x (y ^ n)", "state_after": "\u03b1 : Type u_1\nI : Type ?u.45900\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nx y z : \u03b1\ns : I \u2192 \u03b1\nt : Finset I\nm n : \u2115\nH : IsRelPrime x y\n\u22a2 IsRelPrime x (\u220f _x in Finset.range n, y)"}, {"tactic": "exact IsRelPrime.prod_right fun _ _ \u21a6 H", "annotated_tactic": ["exact <a>IsRelPrime.prod_right</a> fun _ _ \u21a6 H", [{"full_name": "IsRelPrime.prod_right", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Coprime/Lemmas.lean", "def_pos": [247, 9], "def_end_pos": [247, 30]}]], "state_before": "\u03b1 : Type u_1\nI : Type ?u.45900\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nx y z : \u03b1\ns : I \u2192 \u03b1\nt : Finset I\nm n : \u2115\nH : IsRelPrime x y\n\u22a2 IsRelPrime x (\u220f _x in Finset.range n, y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "sup_top_eq", "start": [411, 1], "end": [412, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.monomial_sum_index", "start": [380, 1], "end": [382, 81], "traced_tactics": [{"tactic": "rw [\u2190 monomial_sum_one, C_mul', \u2190 (monomial _).map_smul, smul_eq_mul, mul_one]", "annotated_tactic": ["rw [\u2190 <a>monomial_sum_one</a>, <a>C_mul'</a>, \u2190 (<a>monomial</a> _).<a>map_smul</a>, <a>smul_eq_mul</a>, <a>mul_one</a>]", [{"full_name": "MvPolynomial.monomial_sum_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [375, 9], "def_end_pos": [375, 25]}, {"full_name": "MvPolynomial.C_mul'", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [277, 9], "def_end_pos": [277, 15]}, {"full_name": "MvPolynomial.monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [164, 5], "def_end_pos": [164, 13]}, {"full_name": "LinearMap.map_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [355, 19], "def_end_pos": [355, 27]}, {"full_name": "smul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\n\u03b1 : Type u_2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03c3 \u2192\u2080 \u2115\na : R\n\u22a2 (monomial (\u2211 i in s, f i)) a = C a * \u220f i in s, (monomial (f i)) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Sum.lean", "full_name": "Finset.disjSum_eq_empty", "start": [83, 1], "end": [83, 80], "traced_tactics": [{"tactic": "simp [ext_iff]", "annotated_tactic": ["simp [<a>ext_iff</a>]", [{"full_name": "Finset.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\nt : Finset \u03b2\ns\u2081 s\u2082 : Finset \u03b1\nt\u2081 t\u2082 : Finset \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1 \u2295 \u03b2\n\u22a2 disjSum s t = \u2205 \u2194 s = \u2205 \u2227 t = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/ByteArray.lean", "full_name": "ByteArray.size_empty", "start": [29, 9], "end": [29, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Basic.lean", "full_name": "Metric.uniformEmbedding_iff'", "start": [140, 1], "end": [144, 88], "traced_tactics": [{"tactic": "rw [uniformEmbedding_iff_uniformInducing, uniformInducing_iff, uniformContinuous_iff]", "annotated_tactic": ["rw [<a>uniformEmbedding_iff_uniformInducing</a>, <a>uniformInducing_iff</a>, <a>uniformContinuous_iff</a>]", [{"full_name": "uniformEmbedding_iff_uniformInducing", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "def_pos": [209, 9], "def_end_pos": [209, 45]}, {"full_name": "Metric.uniformInducing_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [842, 16], "def_end_pos": [842, 35]}, {"full_name": "Metric.uniformContinuous_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [825, 9], "def_end_pos": [825, 30]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\n\u03b3 : Type w\ninst\u271d\u00b9 : MetricSpace \u03b3\nx : \u03b3\ns : Set \u03b3\ninst\u271d : MetricSpace \u03b2\nf : \u03b3 \u2192 \u03b2\n\u22a2 UniformEmbedding f \u2194\n    (\u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {a b : \u03b3}, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5) \u2227\n      \u2200 \u03b4 > 0, \u2203 \u03b5 > 0, \u2200 {a b : \u03b3}, dist (f a) (f b) < \u03b5 \u2192 dist a b < \u03b4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Parity.lean", "full_name": "Int.add_one_ediv_two_mul_two_of_odd", "start": [280, 1], "end": [284, 22], "traced_tactics": [{"tactic": "rintro \u27e8c, rfl\u27e9", "annotated_tactic": ["rintro \u27e8c, rfl\u27e9", []], "state_before": "m n : \u2124\n\u22a2 Odd n \u2192 1 + n / 2 * 2 = n", "state_after": "case intro\nm c : \u2124\n\u22a2 1 + (2 * c + 1) / 2 * 2 = 2 * c + 1"}, {"tactic": "rw [add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "case intro\nm c : \u2124\n\u22a2 1 + (2 * c + 1) / 2 * 2 = 2 * c + 1", "state_after": "case intro\nm c : \u2124\n\u22a2 (2 * c + 1) / 2 * 2 + 1 = 2 * c + 1"}, {"tactic": "convert Int.ediv_add_emod' (2 * c + 1) 2", "annotated_tactic": ["convert <a>Int.ediv_add_emod'</a> (2 * c + 1) 2", [{"full_name": "Int.ediv_add_emod'", "def_path": ".lake/packages/std/Std/Data/Int/DivMod.lean", "def_pos": [286, 9], "def_end_pos": [286, 23]}]], "state_before": "case intro\nm c : \u2124\n\u22a2 (2 * c + 1) / 2 * 2 + 1 = 2 * c + 1", "state_after": "case h.e'_2.h.e'_6\nm c : \u2124\n\u22a2 1 = (2 * c + 1) % 2"}, {"tactic": "simp [Int.add_emod]", "annotated_tactic": ["simp [<a>Int.add_emod</a>]", [{"full_name": "Int.add_emod", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean", "def_pos": [181, 9], "def_end_pos": [181, 17]}]], "state_before": "case h.e'_2.h.e'_6\nm c : \u2124\n\u22a2 1 = (2 * c + 1) % 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "nhdsWithin_Ici_basis_Icc", "start": [1020, 1], "end": [1024, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WellFoundedSet.lean", "full_name": "Set.Subsingleton.isPWO", "start": [485, 11], "end": [485, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/RootsOfUnity/Basic.lean", "full_name": "rootsOfUnity.coe_injective", "start": [100, 1], "end": [102, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints", "start": [136, 1], "end": [143, 40], "traced_tactics": [{"tactic": "rcases hp1 with \u27e8p1a, \u27e8hp1a, \u27e8v1, \u27e8hv1, hv1p\u27e9\u27e9\u27e9\u27e9", "annotated_tactic": ["rcases hp1 with \u27e8p1a, \u27e8hp1a, \u27e8v1, \u27e8hv1, hv1p\u27e9\u27e9\u27e9\u27e9", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 : P\nhp1 : p1 \u2208 spanPoints k s\nhp2 : p2 \u2208 spanPoints k s\n\u22a2 p1 -\u1d65 p2 \u2208 vectorSpan k s", "state_after": "case intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 : P\nhp2 : p2 \u2208 spanPoints k s\np1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\n\u22a2 p1 -\u1d65 p2 \u2208 vectorSpan k s"}, {"tactic": "rcases hp2 with \u27e8p2a, \u27e8hp2a, \u27e8v2, \u27e8hv2, hv2p\u27e9\u27e9\u27e9\u27e9", "annotated_tactic": ["rcases hp2 with \u27e8p2a, \u27e8hp2a, \u27e8v2, \u27e8hv2, hv2p\u27e9\u27e9\u27e9\u27e9", []], "state_before": "case intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 : P\nhp2 : p2 \u2208 spanPoints k s\np1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\n\u22a2 p1 -\u1d65 p2 \u2208 vectorSpan k s", "state_after": "case intro.intro.intro.intro.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 p1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\np2a : P\nhp2a : p2a \u2208 s\nv2 : V\nhv2 : v2 \u2208 vectorSpan k s\nhv2p : p2 = v2 +\u1d65 p2a\n\u22a2 p1 -\u1d65 p2 \u2208 vectorSpan k s"}, {"tactic": "rw [hv1p, hv2p, vsub_vadd_eq_vsub_sub (v1 +\u1d65 p1a), vadd_vsub_assoc, add_comm, add_sub_assoc]", "annotated_tactic": ["rw [hv1p, hv2p, <a>vsub_vadd_eq_vsub_sub</a> (v1 +\u1d65 p1a), <a>vadd_vsub_assoc</a>, <a>add_comm</a>, <a>add_sub_assoc</a>]", [{"full_name": "vsub_vadd_eq_vsub_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [164, 9], "def_end_pos": [164, 30]}, {"full_name": "vadd_vsub_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [116, 9], "def_end_pos": [116, 24]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "add_sub_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [373, 3], "def_end_pos": [373, 14]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 p1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\np2a : P\nhp2a : p2a \u2208 s\nv2 : V\nhv2 : v2 \u2208 vectorSpan k s\nhv2p : p2 = v2 +\u1d65 p2a\n\u22a2 p1 -\u1d65 p2 \u2208 vectorSpan k s", "state_after": "case intro.intro.intro.intro.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 p1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\np2a : P\nhp2a : p2a \u2208 s\nv2 : V\nhv2 : v2 \u2208 vectorSpan k s\nhv2p : p2 = v2 +\u1d65 p2a\n\u22a2 p1a -\u1d65 p2a + (v1 - v2) \u2208 vectorSpan k s"}, {"tactic": "have hv1v2 : v1 - v2 \u2208 vectorSpan k s := (vectorSpan k s).sub_mem hv1 hv2", "annotated_tactic": ["have hv1v2 : v1 - v2 \u2208 <a>vectorSpan</a> k s := (<a>vectorSpan</a> k s).<a>sub_mem</a> hv1 hv2", [{"full_name": "vectorSpan", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [60, 5], "def_end_pos": [60, 15]}, {"full_name": "vectorSpan", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [60, 5], "def_end_pos": [60, 15]}, {"full_name": "Submodule.sub_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [436, 19], "def_end_pos": [436, 26]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 p1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\np2a : P\nhp2a : p2a \u2208 s\nv2 : V\nhv2 : v2 \u2208 vectorSpan k s\nhv2p : p2 = v2 +\u1d65 p2a\n\u22a2 p1a -\u1d65 p2a + (v1 - v2) \u2208 vectorSpan k s", "state_after": "case intro.intro.intro.intro.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 p1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\np2a : P\nhp2a : p2a \u2208 s\nv2 : V\nhv2 : v2 \u2208 vectorSpan k s\nhv2p : p2 = v2 +\u1d65 p2a\nhv1v2 : v1 - v2 \u2208 vectorSpan k s\n\u22a2 p1a -\u1d65 p2a + (v1 - v2) \u2208 vectorSpan k s"}, {"tactic": "refine' (vectorSpan k s).add_mem _ hv1v2", "annotated_tactic": ["refine' (<a>vectorSpan</a> k s).<a>add_mem</a> _ hv1v2", [{"full_name": "vectorSpan", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [60, 5], "def_end_pos": [60, 15]}, {"full_name": "Submodule.add_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [222, 19], "def_end_pos": [222, 26]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 p1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\np2a : P\nhp2a : p2a \u2208 s\nv2 : V\nhv2 : v2 \u2208 vectorSpan k s\nhv2p : p2 = v2 +\u1d65 p2a\nhv1v2 : v1 - v2 \u2208 vectorSpan k s\n\u22a2 p1a -\u1d65 p2a + (v1 - v2) \u2208 vectorSpan k s", "state_after": "case intro.intro.intro.intro.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 p1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\np2a : P\nhp2a : p2a \u2208 s\nv2 : V\nhv2 : v2 \u2208 vectorSpan k s\nhv2p : p2 = v2 +\u1d65 p2a\nhv1v2 : v1 - v2 \u2208 vectorSpan k s\n\u22a2 p1a -\u1d65 p2a \u2208 vectorSpan k s"}, {"tactic": "exact vsub_mem_vectorSpan k hp1a hp2a", "annotated_tactic": ["exact <a>vsub_mem_vectorSpan</a> k hp1a hp2a", [{"full_name": "vsub_mem_vectorSpan", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [95, 9], "def_end_pos": [95, 28]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro.intro\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\np1 p2 p1a : P\nhp1a : p1a \u2208 s\nv1 : V\nhv1 : v1 \u2208 vectorSpan k s\nhv1p : p1 = v1 +\u1d65 p1a\np2a : P\nhp2a : p2a \u2208 s\nv2 : V\nhv2 : v2 \u2208 vectorSpan k s\nhv2p : p2 = v2 +\u1d65 p2a\nhv1v2 : v1 - v2 \u2208 vectorSpan k s\n\u22a2 p1a -\u1d65 p2a \u2208 vectorSpan k s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UnitInterval.lean", "full_name": "unitInterval.two_mul_sub_one_mem_iff", "start": [205, 1], "end": [206, 63], "traced_tactics": [{"tactic": "constructor <;> rintro \u27e8h\u2081, h\u2082\u27e9 <;> constructor <;> linarith", "annotated_tactic": ["constructor <;> rintro \u27e8h\u2081, h\u2082\u27e9 <;> constructor <;> linarith", []], "state_before": "t : \u211d\n\u22a2 2 * t - 1 \u2208 I \u2194 t \u2208 Icc (1 / 2) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Monotone.iUnion_nat_add", "start": [2209, 1], "end": [2211, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "sSup_iUnion_Iic", "start": [1080, 1], "end": [1085, 52], "traced_tactics": [{"tactic": "apply csSup_eq_csSup_of_forall_exists_le", "annotated_tactic": ["apply <a>csSup_eq_csSup_of_forall_exists_le</a>", [{"full_name": "csSup_eq_csSup_of_forall_exists_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [1042, 9], "def_end_pos": [1042, 43]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns t : Set \u03b1\na b : \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 sSup (\u22c3 i, Iic (f i)) = \u2a06 i, f i", "state_after": "case hs\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns t : Set \u03b1\na b : \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u2200 x \u2208 \u22c3 i, Iic (f i), \u2203 y \u2208 range fun i => f i, x \u2264 y\n\ncase ht\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns t : Set \u03b1\na b : \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u2200 y \u2208 range fun i => f i, \u2203 x \u2208 \u22c3 i, Iic (f i), y \u2264 x"}, {"tactic": "rintro x \u27e8-, \u27e8i, rfl\u27e9, hi\u27e9", "annotated_tactic": ["rintro x \u27e8-, \u27e8i, rfl\u27e9, hi\u27e9", []], "state_before": "case hs\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns t : Set \u03b1\na b : \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u2200 x \u2208 \u22c3 i, Iic (f i), \u2203 y \u2208 range fun i => f i, x \u2264 y", "state_after": "case hs.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns t : Set \u03b1\na b : \u03b1\nf : \u03b9 \u2192 \u03b1\nx : \u03b1\ni : \u03b9\nhi : x \u2208 (fun i => Iic (f i)) i\n\u22a2 \u2203 y \u2208 range fun i => f i, x \u2264 y"}, {"tactic": "exact \u27e8f i, mem_range_self _, hi\u27e9", "annotated_tactic": ["exact \u27e8f i, <a>mem_range_self</a> _, hi\u27e9", [{"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "case hs.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns t : Set \u03b1\na b : \u03b1\nf : \u03b9 \u2192 \u03b1\nx : \u03b1\ni : \u03b9\nhi : x \u2208 (fun i => Iic (f i)) i\n\u22a2 \u2203 y \u2208 range fun i => f i, x \u2264 y", "state_after": "no goals"}, {"tactic": "rintro x \u27e8i, rfl\u27e9", "annotated_tactic": ["rintro x \u27e8i, rfl\u27e9", []], "state_before": "case ht\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns t : Set \u03b1\na b : \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u2200 y \u2208 range fun i => f i, \u2203 x \u2208 \u22c3 i, Iic (f i), y \u2264 x", "state_after": "case ht.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns t : Set \u03b1\na b : \u03b1\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\n\u22a2 \u2203 x \u2208 \u22c3 i, Iic (f i), (fun i => f i) i \u2264 x"}, {"tactic": "exact \u27e8f i, mem_iUnion_of_mem i le_rfl, le_rfl\u27e9", "annotated_tactic": ["exact \u27e8f i, <a>mem_iUnion_of_mem</a> i <a>le_rfl</a>, <a>le_rfl</a>\u27e9", [{"full_name": "Set.mem_iUnion_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [79, 9], "def_end_pos": [79, 26]}, {"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}, {"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}]], "state_before": "case ht.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns t : Set \u03b1\na b : \u03b1\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\n\u22a2 \u2203 x \u2208 \u22c3 i, Iic (f i), (fun i => f i) i \u2264 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "Subtype.mk_bot", "start": [734, 1], "end": [735, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "ofNat_mem", "start": [45, 1], "end": [48, 50], "traced_tactics": [{"tactic": "rw [\u2190 Nat.cast_eq_ofNat]", "annotated_tactic": ["rw [\u2190 <a>Nat.cast_eq_ofNat</a>]", [{"full_name": "Nat.cast_eq_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [78, 9], "def_end_pos": [78, 26]}]], "state_before": "S : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : AddMonoidWithOne R\ninst\u271d\u00b2 : SetLike S R\ns\u271d : S\ninst\u271d\u00b9 : AddSubmonoidWithOneClass S R\ns : S\nn : \u2115\ninst\u271d : Nat.AtLeastTwo n\n\u22a2 OfNat.ofNat n \u2208 s", "state_after": "S : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : AddMonoidWithOne R\ninst\u271d\u00b2 : SetLike S R\ns\u271d : S\ninst\u271d\u00b9 : AddSubmonoidWithOneClass S R\ns : S\nn : \u2115\ninst\u271d : Nat.AtLeastTwo n\n\u22a2 \u2191n \u2208 s"}, {"tactic": "exact natCast_mem s n", "annotated_tactic": ["exact <a>natCast_mem</a> s n", [{"full_name": "natCast_mem", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Subsemiring/Basic.lean", "def_pos": [41, 9], "def_end_pos": [41, 20]}]], "state_before": "S : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : AddMonoidWithOne R\ninst\u271d\u00b2 : SetLike S R\ns\u271d : S\ninst\u271d\u00b9 : AddSubmonoidWithOneClass S R\ns : S\nn : \u2115\ninst\u271d : Nat.AtLeastTwo n\n\u22a2 \u2191n \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "Contravariant.MulLECancellable", "start": [1602, 1], "end": [1605, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.succ_strictMono", "start": [360, 1], "end": [360, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.self_sub_floor", "start": [866, 1], "end": [867, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.mem_join", "start": [518, 1], "end": [525, 40], "traced_tactics": [{"tactic": "simp only [mem_def, join_data, List.mem_join, List.mem_map]", "annotated_tactic": ["simp only [<a>mem_def</a>, <a>join_data</a>, <a>List.mem_join</a>, <a>List.mem_map</a>]", [{"full_name": "Array.mem_def", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [186, 9], "def_end_pos": [186, 16]}, {"full_name": "Array.join_data", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [508, 17], "def_end_pos": [508, 26]}, {"full_name": "List.mem_join", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [360, 9], "def_end_pos": [360, 17]}, {"full_name": "List.mem_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [127, 17], "def_end_pos": [127, 24]}]], "state_before": "\u03b1 : Type u_1\na : \u03b1\n\u22a2 \u2200 {L : Array (Array \u03b1)}, a \u2208 join L \u2194 \u2203 l, l \u2208 L \u2227 a \u2208 l", "state_after": "\u03b1 : Type u_1\na : \u03b1\n\u22a2 \u2200 {L : Array (Array \u03b1)}, (\u2203 l, (\u2203 a, a \u2208 L.data \u2227 a.data = l) \u2227 a \u2208 l) \u2194 \u2203 l, l \u2208 L.data \u2227 a \u2208 l.data"}, {"tactic": "intro l", "annotated_tactic": ["intro l", []], "state_before": "\u03b1 : Type u_1\na : \u03b1\n\u22a2 \u2200 {L : Array (Array \u03b1)}, (\u2203 l, (\u2203 a, a \u2208 L.data \u2227 a.data = l) \u2227 a \u2208 l) \u2194 \u2203 l, l \u2208 L.data \u2227 a \u2208 l.data", "state_after": "\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\n\u22a2 (\u2203 l_1, (\u2203 a, a \u2208 l.data \u2227 a.data = l_1) \u2227 a \u2208 l_1) \u2194 \u2203 l_1, l_1 \u2208 l.data \u2227 a \u2208 l_1.data"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\n\u22a2 (\u2203 l_1, (\u2203 a, a \u2208 l.data \u2227 a.data = l_1) \u2227 a \u2208 l_1) \u2194 \u2203 l_1, l_1 \u2208 l.data \u2227 a \u2208 l_1.data", "state_after": "case mp\n\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\n\u22a2 (\u2203 l_1, (\u2203 a, a \u2208 l.data \u2227 a.data = l_1) \u2227 a \u2208 l_1) \u2192 \u2203 l_1, l_1 \u2208 l.data \u2227 a \u2208 l_1.data\n\ncase mpr\n\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\n\u22a2 (\u2203 l_1, l_1 \u2208 l.data \u2227 a \u2208 l_1.data) \u2192 \u2203 l_1, (\u2203 a, a \u2208 l.data \u2227 a.data = l_1) \u2227 a \u2208 l_1"}, {"tactic": "rintro \u27e8_, \u27e8s, m, rfl\u27e9, h\u27e9", "annotated_tactic": ["rintro \u27e8_, \u27e8s, m, rfl\u27e9, h\u27e9", []], "state_before": "case mp\n\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\n\u22a2 (\u2203 l_1, (\u2203 a, a \u2208 l.data \u2227 a.data = l_1) \u2227 a \u2208 l_1) \u2192 \u2203 l_1, l_1 \u2208 l.data \u2227 a \u2208 l_1.data", "state_after": "case mp.intro.intro.intro.intro\n\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\ns : Array \u03b1\nm : s \u2208 l.data\nh : a \u2208 s.data\n\u22a2 \u2203 l_1, l_1 \u2208 l.data \u2227 a \u2208 l_1.data"}, {"tactic": "exact \u27e8s, m, h\u27e9", "annotated_tactic": ["exact \u27e8s, m, h\u27e9", []], "state_before": "case mp.intro.intro.intro.intro\n\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\ns : Array \u03b1\nm : s \u2208 l.data\nh : a \u2208 s.data\n\u22a2 \u2203 l_1, l_1 \u2208 l.data \u2227 a \u2208 l_1.data", "state_after": "no goals"}, {"tactic": "rintro \u27e8s, h\u2081, h\u2082\u27e9", "annotated_tactic": ["rintro \u27e8s, h\u2081, h\u2082\u27e9", []], "state_before": "case mpr\n\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\n\u22a2 (\u2203 l_1, l_1 \u2208 l.data \u2227 a \u2208 l_1.data) \u2192 \u2203 l_1, (\u2203 a, a \u2208 l.data \u2227 a.data = l_1) \u2227 a \u2208 l_1", "state_after": "case mpr.intro.intro\n\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\ns : Array \u03b1\nh\u2081 : s \u2208 l.data\nh\u2082 : a \u2208 s.data\n\u22a2 \u2203 l_1, (\u2203 a, a \u2208 l.data \u2227 a.data = l_1) \u2227 a \u2208 l_1"}, {"tactic": "refine \u27e8s.data, \u27e8\u27e8s, h\u2081, rfl\u27e9, h\u2082\u27e9\u27e9", "annotated_tactic": ["refine \u27e8s.data, \u27e8\u27e8s, h\u2081, <a>rfl</a>\u27e9, h\u2082\u27e9\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case mpr.intro.intro\n\u03b1 : Type u_1\na : \u03b1\nl : Array (Array \u03b1)\ns : Array \u03b1\nh\u2081 : s \u2208 l.data\nh\u2082 : a \u2208 s.data\n\u22a2 \u2203 l_1, (\u2203 a, a \u2208 l.data \u2227 a.data = l_1) \u2227 a \u2208 l_1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "full_name": "Real.strictAntiOn_logb_of_base_lt_one", "start": [359, 1], "end": [360, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Trace.lean", "full_name": "LinearMap.trace_conj", "start": [117, 1], "end": [120, 7], "traced_tactics": [{"tactic": "rw [trace_mul_comm]", "annotated_tactic": ["rw [<a>trace_mul_comm</a>]", [{"full_name": "LinearMap.trace_mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Trace.lean", "def_pos": [99, 9], "def_end_pos": [99, 23]}]], "state_before": "R : Type u\ninst\u271d\u2076 : CommSemiring R\nM : Type v\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\n\u03b9 : Type w\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : Fintype \u03b9\n\u03ba : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03ba\ninst\u271d : Fintype \u03ba\nb : Basis \u03b9 R M\nc : Basis \u03ba R M\ng : M \u2192\u2097[R] M\nf : (M \u2192\u2097[R] M)\u02e3\n\u22a2 (trace R M) (\u2191f * g * \u2191f\u207b\u00b9) = (trace R M) g", "state_after": "R : Type u\ninst\u271d\u2076 : CommSemiring R\nM : Type v\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\n\u03b9 : Type w\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : Fintype \u03b9\n\u03ba : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03ba\ninst\u271d : Fintype \u03ba\nb : Basis \u03b9 R M\nc : Basis \u03ba R M\ng : M \u2192\u2097[R] M\nf : (M \u2192\u2097[R] M)\u02e3\n\u22a2 (trace R M) (\u2191f\u207b\u00b9 * (\u2191f * g)) = (trace R M) g"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\ninst\u271d\u2076 : CommSemiring R\nM : Type v\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\n\u03b9 : Type w\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : Fintype \u03b9\n\u03ba : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03ba\ninst\u271d : Fintype \u03ba\nb : Basis \u03b9 R M\nc : Basis \u03ba R M\ng : M \u2192\u2097[R] M\nf : (M \u2192\u2097[R] M)\u02e3\n\u22a2 (trace R M) (\u2191f\u207b\u00b9 * (\u2191f * g)) = (trace R M) g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Odd.ne_two_of_dvd_nat", "start": [410, 1], "end": [412, 46], "traced_tactics": [{"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "m n : \u2115\nhn : Odd n\nhm : m \u2223 n\n\u22a2 m \u2260 2", "state_after": "n : \u2115\nhn : Odd n\nhm : 2 \u2223 n\n\u22a2 False"}, {"tactic": "exact absurd (hn.of_dvd_nat hm) (by decide)", "annotated_tactic": ["exact <a>absurd</a> (hn.of_dvd_nat hm) (by decide)", [{"full_name": "absurd", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [246, 21], "def_end_pos": [246, 27]}]], "state_before": "n : \u2115\nhn : Odd n\nhm : 2 \u2223 n\n\u22a2 False", "state_after": "no goals"}, {"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "n : \u2115\nhn : Odd n\nhm : 2 \u2223 n\n\u22a2 \u00acOdd 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "HasStrictFDerivAt.mul'", "start": [368, 1], "end": [372, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "sdiff_sup_self", "start": [508, 1], "end": [508, 99], "traced_tactics": [{"tactic": "rw [sup_comm, sup_sdiff_self, sup_comm]", "annotated_tactic": ["rw [<a>sup_comm</a>, <a>sup_sdiff_self</a>, <a>sup_comm</a>]", [{"full_name": "sup_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}, {"full_name": "sup_sdiff_self", "def_path": ".lake/packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [503, 9], "def_end_pos": [503, 23]}, {"full_name": "sup_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na\u271d b\u271d c d a b : \u03b1\n\u22a2 b \\ a \u2294 a = b \u2294 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Basic.lean", "full_name": "ENNReal.coe_finset_sup", "start": [612, 1], "end": [613, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Prod.lean", "full_name": "Filter.prod_bot", "start": [426, 9], "end": [426, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/HasLimits.lean", "full_name": "CategoryTheory.Limits.HasColimit.isoOfNatIso_inv_desc", "start": [953, 1], "end": [957, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Atoms.lean", "full_name": "GaloisInsertion.isAtom_iff'", "start": [833, 1], "end": [835, 78], "traced_tactics": [{"tactic": "rw [\u2190 gi.isAtom_iff hbot h_atom, gi.l_u_eq]", "annotated_tactic": ["rw [\u2190 gi.isAtom_iff hbot h_atom, gi.l_u_eq]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b2\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : IsAtomic \u03b1\ninst\u271d : OrderBot \u03b2\nl : \u03b1 \u2192 \u03b2\nu : \u03b2 \u2192 \u03b1\ngi : GaloisInsertion l u\nhbot : u \u22a5 = \u22a5\nh_atom : \u2200 (a : \u03b1), IsAtom a \u2192 u (l a) = a\nb : \u03b2\n\u22a2 IsAtom (u b) \u2194 IsAtom b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.Perm.dropSlice_inter", "start": [634, 1], "end": [641, 37], "traced_tactics": [{"tactic": "simp only [dropSlice_eq]", "annotated_tactic": ["simp only [<a>dropSlice_eq</a>]", [{"full_name": "List.dropSlice_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [4347, 9], "def_end_pos": [4347, 21]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\n\u22a2 dropSlice n m xs ~ ys \u2229 dropSlice n m xs", "state_after": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\n\u22a2 take n xs ++ drop (n + m) xs ~ ys \u2229 (take n xs ++ drop (n + m) xs)"}, {"tactic": "have : n \u2264 n + m := Nat.le_add_right _ _", "annotated_tactic": ["have : n \u2264 n + m := <a>Nat.le_add_right</a> _ _", [{"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\n\u22a2 take n xs ++ drop (n + m) xs ~ ys \u2229 (take n xs ++ drop (n + m) xs)", "state_after": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\nthis : n \u2264 n + m\n\u22a2 take n xs ++ drop (n + m) xs ~ ys \u2229 (take n xs ++ drop (n + m) xs)"}, {"tactic": "have h\u2082 := h.nodup_iff.2 h'", "annotated_tactic": ["have h\u2082 := h.nodup_iff.2 h'", []], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\nthis : n \u2264 n + m\n\u22a2 take n xs ++ drop (n + m) xs ~ ys \u2229 (take n xs ++ drop (n + m) xs)", "state_after": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\nthis : n \u2264 n + m\nh\u2082 : Nodup xs\n\u22a2 take n xs ++ drop (n + m) xs ~ ys \u2229 (take n xs ++ drop (n + m) xs)"}, {"tactic": "apply Perm.trans _ (Perm.inter_append _).symm", "annotated_tactic": ["apply <a>Perm.trans</a> _ (<a>Perm.inter_append</a> _).<a>symm</a>", [{"full_name": "List.Perm.trans", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1566, 5], "def_end_pos": [1566, 10]}, {"full_name": "List.Perm.inter_append", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [504, 9], "def_end_pos": [504, 26]}, {"full_name": "List.Perm.symm", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [37, 19], "def_end_pos": [37, 28]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\nthis : n \u2264 n + m\nh\u2082 : Nodup xs\n\u22a2 take n xs ++ drop (n + m) xs ~ ys \u2229 (take n xs ++ drop (n + m) xs)", "state_after": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\nthis : n \u2264 n + m\nh\u2082 : Nodup xs\n\u22a2 take n xs ++ drop (n + m) xs ~ ys \u2229 take n xs ++ ys \u2229 drop (n + m) xs\n\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\nthis : n \u2264 n + m\nh\u2082 : Nodup xs\n\u22a2 Disjoint (take n xs) (drop (n + m) xs)"}, {"tactic": "exact Perm.append (Perm.take_inter _ h h') (Perm.drop_inter _ h h')", "annotated_tactic": ["exact <a>Perm.append</a> (<a>Perm.take_inter</a> _ h h') (<a>Perm.drop_inter</a> _ h h')", [{"full_name": "List.Perm.append", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [89, 9], "def_end_pos": [89, 20]}, {"full_name": "List.Perm.take_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [605, 9], "def_end_pos": [605, 24]}, {"full_name": "List.Perm.drop_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [613, 9], "def_end_pos": [613, 24]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\nthis : n \u2264 n + m\nh\u2082 : Nodup xs\n\u22a2 take n xs ++ drop (n + m) xs ~ ys \u2229 take n xs ++ ys \u2229 drop (n + m) xs", "state_after": "no goals"}, {"tactic": "exact disjoint_take_drop h\u2082 this", "annotated_tactic": ["exact <a>disjoint_take_drop</a> h\u2082 this", [{"full_name": "List.disjoint_take_drop", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2046, 9], "def_end_pos": [2046, 27]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn m : \u2115\nh : xs ~ ys\nh' : Nodup ys\nthis : n \u2264 n + m\nh\u2082 : Nodup xs\n\u22a2 Disjoint (take n xs) (drop (n + m) xs)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Between.lean", "full_name": "Sbtw.not_swap_right", "start": [407, 1], "end": [408, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Basic.lean", "full_name": "FixedPoints.mem_subgroup", "start": [247, 1], "end": [249, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Ring.lean", "full_name": "sub_sq'", "start": [224, 1], "end": [225, 66], "traced_tactics": [{"tactic": "rw [sub_eq_add_neg, add_sq', neg_sq, mul_neg, \u2190 sub_eq_add_neg]", "annotated_tactic": ["rw [<a>sub_eq_add_neg</a>, <a>add_sq'</a>, <a>neg_sq</a>, <a>mul_neg</a>, \u2190 <a>sub_eq_add_neg</a>]", [{"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}, {"full_name": "add_sq'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [97, 9], "def_end_pos": [97, 16]}, {"full_name": "neg_sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [141, 9], "def_end_pos": [141, 15]}, {"full_name": "mul_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [311, 9], "def_end_pos": [311, 16]}, {"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}]], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d : CommRing R\na b : R\n\u22a2 (a - b) ^ 2 = a ^ 2 + b ^ 2 - 2 * a * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Module.lean", "full_name": "Complex.liftAux_apply", "start": [361, 1], "end": [362, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Group/Defs.lean", "full_name": "lt_mul_inv_iff_mul_lt", "start": [311, 1], "end": [312, 70], "traced_tactics": [{"tactic": "rw [inv_mul_cancel_right]", "annotated_tactic": ["rw [<a>inv_mul_cancel_right</a>]", [{"full_name": "inv_mul_cancel_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1185, 9], "def_end_pos": [1185, 29]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (swap fun x x_1 => x * x_1) fun x x_1 => x < x_1\na b c : \u03b1\n\u22a2 c * b < a * b\u207b\u00b9 * b \u2194 c * b < a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.Pos.zero_addChar_eq", "start": [125, 1], "end": [125, 97], "traced_tactics": [{"tactic": "rw [\u2190 zero_addChar_byteIdx]", "annotated_tactic": ["rw [\u2190 <a>zero_addChar_byteIdx</a>]", [{"full_name": "String.Pos.zero_addChar_byteIdx", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [122, 9], "def_end_pos": [122, 29]}]], "state_before": "c : Char\n\u22a2 0 + c = { byteIdx := csize c }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Notation.lean", "full_name": "Matrix.cons_vecMul_cons", "start": [307, 1], "end": [308, 67], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nw : o' \u2192 \u03b1\nB : Fin n \u2192 o' \u2192 \u03b1\n\u22a2 vecCons x v \u1d65* of (vecCons w B) = x \u2022 w + v \u1d65* of B", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.sup_mul", "start": [250, 1], "end": [251, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "Submodule.fst_map_fst", "start": [628, 1], "end": [632, 44], "traced_tactics": [{"tactic": "rw [eq_top_iff]", "annotated_tactic": ["rw [<a>eq_top_iff</a>]", [{"full_name": "eq_top_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [133, 9], "def_end_pos": [133, 19]}]], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 map (LinearMap.fst R M M\u2082) (fst R M M\u2082) = \u22a4", "state_after": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 \u22a4 \u2264 map (LinearMap.fst R M M\u2082) (fst R M M\u2082)"}, {"tactic": "rintro x -", "annotated_tactic": ["rintro x -", []], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 \u22a4 \u2264 map (LinearMap.fst R M M\u2082) (fst R M M\u2082)", "state_after": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\n\u22a2 x \u2208 map (LinearMap.fst R M M\u2082) (fst R M M\u2082)"}, {"tactic": "simp only [fst, comap_bot, mem_map, mem_ker, snd_apply, fst_apply,\n  Prod.exists, exists_eq_left, exists_eq]", "annotated_tactic": ["simp only [<a>fst</a>, <a>comap_bot</a>, <a>mem_map</a>, <a>mem_ker</a>, <a>snd_apply</a>, <a>fst_apply</a>,\n    <a>Prod.exists</a>, <a>exists_eq_left</a>, <a>exists_eq</a>]", [{"full_name": "Submodule.fst", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [607, 5], "def_end_pos": [607, 8]}, {"full_name": "Submodule.comap_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [265, 9], "def_end_pos": [265, 18]}, {"full_name": "Submodule.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [89, 9], "def_end_pos": [89, 16]}, {"full_name": "LinearMap.mem_ker", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [65, 9], "def_end_pos": [65, 16]}, {"full_name": "LinearMap.snd_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [81, 9], "def_end_pos": [81, 18]}, {"full_name": "LinearMap.fst_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [76, 9], "def_end_pos": [76, 18]}, {"full_name": "Prod.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [40, 9], "def_end_pos": [40, 17]}, {"full_name": "exists_eq_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [215, 17], "def_end_pos": [215, 31]}, {"full_name": "exists_eq", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [211, 17], "def_end_pos": [211, 26]}]], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\n\u22a2 x \u2208 map (LinearMap.fst R M M\u2082) (fst R M M\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/BigOperators/Basic.lean", "full_name": "Commute.list_prod_left", "start": [269, 1], "end": [271, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "full_name": "Complex.arg_cos_add_sin_mul_I_coe_angle", "start": [534, 1], "end": [536, 88], "traced_tactics": [{"tactic": "rw [\u2190 one_mul (_ + _), \u2190 ofReal_one, arg_mul_cos_add_sin_mul_I_coe_angle zero_lt_one]", "annotated_tactic": ["rw [\u2190 <a>one_mul</a> (_ + _), \u2190 <a>ofReal_one</a>, <a>arg_mul_cos_add_sin_mul_I_coe_angle</a> <a>zero_lt_one</a>]", [{"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "Complex.ofReal_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [178, 9], "def_end_pos": [178, 19]}, {"full_name": "Complex.arg_mul_cos_add_sin_mul_I_coe_angle", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "def_pos": [525, 9], "def_end_pos": [525, 44]}, {"full_name": "zero_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}]], "state_before": "a x z : \u2102\n\u03b8 : Real.Angle\n\u22a2 \u2191(arg (\u2191(Real.Angle.cos \u03b8) + \u2191(Real.Angle.sin \u03b8) * I)) = \u03b8", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.C_1", "start": [519, 1], "end": [520, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.exp_zero", "start": [813, 1], "end": [813, 51], "traced_tactics": [{"tactic": "simp [Real.exp]", "annotated_tactic": ["simp [<a>Real.exp</a>]", [{"full_name": "Real.exp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [109, 12], "def_end_pos": [109, 15]}]], "state_before": "x y : \u211d\n\u22a2 rexp 0 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Prod.lean", "full_name": "RingHom.coe_fst", "start": [211, 1], "end": [212, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "full_name": "Summable.tendsto_atTop_of_pos", "start": [282, 1], "end": [286, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.mem_principal_self", "start": [311, 1], "end": [311, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Ordinal.infinite_pigeonhole_card", "start": [819, 1], "end": [824, 59], "traced_tactics": [{"tactic": "rcases le_mk_iff_exists_set.1 h\u03b8 with \u27e8s, rfl\u27e9", "annotated_tactic": ["rcases <a>le_mk_iff_exists_set</a>.1 h\u03b8 with \u27e8s, rfl\u27e9", [{"full_name": "Cardinal.le_mk_iff_exists_set", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [282, 9], "def_end_pos": [282, 29]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2 \u03b1 : Type u\nf : \u03b2 \u2192 \u03b1\n\u03b8 : Cardinal.{u}\nh\u03b8 : \u03b8 \u2264 #\u03b2\nh\u2081 : \u2135\u2080 \u2264 \u03b8\nh\u2082 : #\u03b1 < cof (ord \u03b8)\n\u22a2 \u2203 a, \u03b8 \u2264 #\u2191(f \u207b\u00b9' {a})", "state_after": "case intro\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2 \u03b1 : Type u\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nh\u03b8 : #\u2191s \u2264 #\u03b2\nh\u2081 : \u2135\u2080 \u2264 #\u2191s\nh\u2082 : #\u03b1 < cof (ord #\u2191s)\n\u22a2 \u2203 a, #\u2191s \u2264 #\u2191(f \u207b\u00b9' {a})"}, {"tactic": "cases' infinite_pigeonhole (f \u2218 Subtype.val : s \u2192 \u03b1) h\u2081 h\u2082 with a ha", "annotated_tactic": ["cases' <a>infinite_pigeonhole</a> (f \u2218 <a>Subtype.val</a> : s \u2192 \u03b1) h\u2081 h\u2082 with a ha", [{"full_name": "Ordinal.infinite_pigeonhole", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Cofinality.lean", "def_pos": [803, 9], "def_end_pos": [803, 28]}, {"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}]], "state_before": "case intro\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2 \u03b1 : Type u\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nh\u03b8 : #\u2191s \u2264 #\u03b2\nh\u2081 : \u2135\u2080 \u2264 #\u2191s\nh\u2082 : #\u03b1 < cof (ord #\u2191s)\n\u22a2 \u2203 a, #\u2191s \u2264 #\u2191(f \u207b\u00b9' {a})", "state_after": "case intro.intro\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2 \u03b1 : Type u\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nh\u03b8 : #\u2191s \u2264 #\u03b2\nh\u2081 : \u2135\u2080 \u2264 #\u2191s\nh\u2082 : #\u03b1 < cof (ord #\u2191s)\na : \u03b1\nha : #\u2191(f \u2218 Subtype.val \u207b\u00b9' {a}) = #\u2191s\n\u22a2 \u2203 a, #\u2191s \u2264 #\u2191(f \u207b\u00b9' {a})"}, {"tactic": "use a", "annotated_tactic": ["use a", []], "state_before": "case intro.intro\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2 \u03b1 : Type u\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nh\u03b8 : #\u2191s \u2264 #\u03b2\nh\u2081 : \u2135\u2080 \u2264 #\u2191s\nh\u2082 : #\u03b1 < cof (ord #\u2191s)\na : \u03b1\nha : #\u2191(f \u2218 Subtype.val \u207b\u00b9' {a}) = #\u2191s\n\u22a2 \u2203 a, #\u2191s \u2264 #\u2191(f \u207b\u00b9' {a})", "state_after": "case h\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2 \u03b1 : Type u\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nh\u03b8 : #\u2191s \u2264 #\u03b2\nh\u2081 : \u2135\u2080 \u2264 #\u2191s\nh\u2082 : #\u03b1 < cof (ord #\u2191s)\na : \u03b1\nha : #\u2191(f \u2218 Subtype.val \u207b\u00b9' {a}) = #\u2191s\n\u22a2 #\u2191s \u2264 #\u2191(f \u207b\u00b9' {a})"}, {"tactic": "rw [\u2190 ha, @preimage_comp _ _ _ Subtype.val f]", "annotated_tactic": ["rw [\u2190 ha, @<a>preimage_comp</a> _ _ _ <a>Subtype.val</a> f]", [{"full_name": "Set.preimage_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [151, 9], "def_end_pos": [151, 22]}, {"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}]], "state_before": "case h\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2 \u03b1 : Type u\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nh\u03b8 : #\u2191s \u2264 #\u03b2\nh\u2081 : \u2135\u2080 \u2264 #\u2191s\nh\u2082 : #\u03b1 < cof (ord #\u2191s)\na : \u03b1\nha : #\u2191(f \u2218 Subtype.val \u207b\u00b9' {a}) = #\u2191s\n\u22a2 #\u2191s \u2264 #\u2191(f \u207b\u00b9' {a})", "state_after": "case h\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2 \u03b1 : Type u\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nh\u03b8 : #\u2191s \u2264 #\u03b2\nh\u2081 : \u2135\u2080 \u2264 #\u2191s\nh\u2082 : #\u03b1 < cof (ord #\u2191s)\na : \u03b1\nha : #\u2191(f \u2218 Subtype.val \u207b\u00b9' {a}) = #\u2191s\n\u22a2 #\u2191(Subtype.val \u207b\u00b9' (f \u207b\u00b9' {a})) \u2264 #\u2191(f \u207b\u00b9' {a})"}, {"tactic": "exact mk_preimage_of_injective _ _ Subtype.val_injective", "annotated_tactic": ["exact <a>mk_preimage_of_injective</a> _ _ <a>Subtype.val_injective</a>", [{"full_name": "Cardinal.mk_preimage_of_injective", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2172, 9], "def_end_pos": [2172, 33]}, {"full_name": "Subtype.val_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [122, 9], "def_end_pos": [122, 22]}]], "state_before": "case h\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2 \u03b1 : Type u\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nh\u03b8 : #\u2191s \u2264 #\u03b2\nh\u2081 : \u2135\u2080 \u2264 #\u2191s\nh\u2082 : #\u03b1 < cof (ord #\u2191s)\na : \u03b1\nha : #\u2191(f \u2218 Subtype.val \u207b\u00b9' {a}) = #\u2191s\n\u22a2 #\u2191(Subtype.val \u207b\u00b9' (f \u207b\u00b9' {a})) \u2264 #\u2191(f \u207b\u00b9' {a})", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "full_name": "MeasureTheory.SimpleFunc.piecewise_compl", "start": [240, 1], "end": [244, 49], "traced_tactics": [{"tactic": "set_option tactic.skipAssignedInstances false in\nsimp [hs]; convert Set.piecewise_compl s f g", "annotated_tactic": ["set_option tactic.skipAssignedInstances false in\n    simp [hs]; convert <a>Set.piecewise_compl</a> s f g", [{"full_name": "Set.piecewise_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [1505, 9], "def_end_pos": [1505, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\u1d9c\nf g : \u03b1 \u2192\u209b \u03b2\n\u22a2 \u2191(piecewise s\u1d9c hs f g) = \u2191(piecewise s \u22ef g f)", "state_after": "no goals"}, {"tactic": "simp [hs]", "annotated_tactic": ["simp [hs]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\u1d9c\nf g : \u03b1 \u2192\u209b \u03b2\n\u22a2 \u2191(piecewise s\u1d9c hs f g) = \u2191(piecewise s \u22ef g f)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\u1d9c\nf g : \u03b1 \u2192\u209b \u03b2\n\u22a2 Set.piecewise s\u1d9c \u2191f \u2191g = Set.piecewise s \u2191g \u2191f"}, {"tactic": "convert Set.piecewise_compl s f g", "annotated_tactic": ["convert <a>Set.piecewise_compl</a> s f g", [{"full_name": "Set.piecewise_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [1505, 9], "def_end_pos": [1505, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\u1d9c\nf g : \u03b1 \u2192\u209b \u03b2\n\u22a2 Set.piecewise s\u1d9c \u2191f \u2191g = Set.piecewise s \u2191g \u2191f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.monic_of_degree_le_of_coeff_eq_one", "start": [918, 1], "end": [920, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Monic.lean", "full_name": "Polynomial.monic_X_add_C", "start": [112, 1], "end": [113, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "full_name": "Subsemigroup.map_le_map_iff_of_injective", "start": [429, 1], "end": [430, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "IsClosed.smul_left_of_isCompact", "start": [1285, 1], "end": [1302, 52], "traced_tactics": [{"tactic": "have : \u2200 x \u2208 s \u2022 t, \u2203 g \u2208 s, g\u207b\u00b9 \u2022 x \u2208 t := by\n  rintro x \u27e8g, hgs, y, hyt, rfl\u27e9\n  refine \u27e8g, hgs, ?_\u27e9\n  rwa [inv_smul_smul]", "annotated_tactic": ["have : \u2200 x \u2208 s \u2022 t, \u2203 g \u2208 s, g\u207b\u00b9 \u2022 x \u2208 t := by\n    rintro x \u27e8g, hgs, y, hyt, rfl\u27e9\n    refine \u27e8g, hgs, ?_\u27e9\n    rwa [<a>inv_smul_smul</a>]", [{"full_name": "inv_smul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [37, 9], "def_end_pos": [37, 22]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\n\u22a2 IsClosed (s \u2022 t)", "state_after": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nthis : \u2200 x \u2208 s \u2022 t, \u2203 g \u2208 s, g\u207b\u00b9 \u2022 x \u2208 t\n\u22a2 IsClosed (s \u2022 t)"}, {"tactic": "choose! f hf using this", "annotated_tactic": ["choose! f hf using this", []], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nthis : \u2200 x \u2208 s \u2022 t, \u2203 g \u2208 s, g\u207b\u00b9 \u2022 x \u2208 t\n\u22a2 IsClosed (s \u2022 t)", "state_after": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\n\u22a2 IsClosed (s \u2022 t)"}, {"tactic": "refine isClosed_of_closure_subset (fun x hx \u21a6 ?_)", "annotated_tactic": ["refine <a>isClosed_of_closure_subset</a> (fun x hx \u21a6 ?_)", [{"full_name": "isClosed_of_closure_subset", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [453, 9], "def_end_pos": [453, 35]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\n\u22a2 IsClosed (s \u2022 t)", "state_after": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\n\u22a2 x \u2208 s \u2022 t"}, {"tactic": "rcases mem_closure_iff_ultrafilter.mp hx with \u27e8u, hust, hux\u27e9", "annotated_tactic": ["rcases mem_closure_iff_ultrafilter.mp hx with \u27e8u, hust, hux\u27e9", []], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\n\u22a2 x \u2208 s \u2022 t", "state_after": "case intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\nu : Ultrafilter \u03b2\nhust : s \u2022 t \u2208 u\nhux : \u2191u \u2264 \ud835\udcdd x\n\u22a2 x \u2208 s \u2022 t"}, {"tactic": "have : Ultrafilter.map f u \u2264 \ud835\udcdf s :=\n  calc Ultrafilter.map f u \u2264 map f (\ud835\udcdf (s \u2022 t)) := map_mono (le_principal_iff.mpr hust)\n    _ = \ud835\udcdf (f '' (s \u2022 t)) := map_principal\n    _ \u2264 \ud835\udcdf s := principal_mono.mpr (image_subset_iff.mpr (fun x hx \u21a6 (hf x hx).1))", "annotated_tactic": ["have : <a>Ultrafilter.map</a> f u \u2264 \ud835\udcdf s :=\n    calc <a>Ultrafilter.map</a> f u \u2264 <a>map</a> f (\ud835\udcdf (s \u2022 t)) := <a>map_mono</a> (le_principal_iff.mpr hust)\n      _ = \ud835\udcdf (f '' (s \u2022 t)) := <a>map_principal</a>\n      _ \u2264 \ud835\udcdf s := principal_mono.mpr (image_subset_iff.mpr (fun x hx \u21a6 (hf x hx).1))", [{"full_name": "Ultrafilter.map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Ultrafilter.lean", "def_pos": [211, 12], "def_end_pos": [211, 15]}, {"full_name": "Ultrafilter.map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Ultrafilter.lean", "def_pos": [211, 12], "def_end_pos": [211, 15]}, {"full_name": "Filter.map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1921, 5], "def_end_pos": [1921, 8]}, {"full_name": "Filter.map_mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2331, 9], "def_end_pos": [2331, 17]}, {"full_name": "Filter.map_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1929, 9], "def_end_pos": [1929, 22]}]], "state_before": "case intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\nu : Ultrafilter \u03b2\nhust : s \u2022 t \u2208 u\nhux : \u2191u \u2264 \ud835\udcdd x\n\u22a2 x \u2208 s \u2022 t", "state_after": "case intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\nu : Ultrafilter \u03b2\nhust : s \u2022 t \u2208 u\nhux : \u2191u \u2264 \ud835\udcdd x\nthis : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdf s\n\u22a2 x \u2208 s \u2022 t"}, {"tactic": "rcases hs.ultrafilter_le_nhds (Ultrafilter.map f u) this with \u27e8g, hg, hug\u27e9", "annotated_tactic": ["rcases hs.ultrafilter_le_nhds (<a>Ultrafilter.map</a> f u) this with \u27e8g, hg, hug\u27e9", [{"full_name": "Ultrafilter.map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Ultrafilter.lean", "def_pos": [211, 12], "def_end_pos": [211, 15]}]], "state_before": "case intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\nu : Ultrafilter \u03b2\nhust : s \u2022 t \u2208 u\nhux : \u2191u \u2264 \ud835\udcdd x\nthis : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdf s\n\u22a2 x \u2208 s \u2022 t", "state_after": "case intro.intro.intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\nu : Ultrafilter \u03b2\nhust : s \u2022 t \u2208 u\nhux : \u2191u \u2264 \ud835\udcdd x\nthis : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdf s\ng : \u03b1\nhg : g \u2208 s\nhug : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdd g\n\u22a2 x \u2208 s \u2022 t"}, {"tactic": "suffices g\u207b\u00b9 \u2022 x \u2208 t from\n  \u27e8g, hg, g\u207b\u00b9 \u2022 x, this, smul_inv_smul _ _\u27e9", "annotated_tactic": ["suffices g\u207b\u00b9 \u2022 x \u2208 t from\n    \u27e8g, hg, g\u207b\u00b9 \u2022 x, this, <a>smul_inv_smul</a> _ _\u27e9", [{"full_name": "smul_inv_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [42, 9], "def_end_pos": [42, 22]}]], "state_before": "case intro.intro.intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\nu : Ultrafilter \u03b2\nhust : s \u2022 t \u2208 u\nhux : \u2191u \u2264 \ud835\udcdd x\nthis : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdf s\ng : \u03b1\nhg : g \u2208 s\nhug : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdd g\n\u22a2 x \u2208 s \u2022 t", "state_after": "case intro.intro.intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\nu : Ultrafilter \u03b2\nhust : s \u2022 t \u2208 u\nhux : \u2191u \u2264 \ud835\udcdd x\nthis : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdf s\ng : \u03b1\nhg : g \u2208 s\nhug : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdd g\n\u22a2 g\u207b\u00b9 \u2022 x \u2208 t"}, {"tactic": "exact ht.mem_of_tendsto ((Tendsto.inv hug).smul hux)\n  (Eventually.mono hust (fun y hy \u21a6 (hf y hy).2))", "annotated_tactic": ["exact ht.mem_of_tendsto ((<a>Tendsto.inv</a> hug).<a>smul</a> hux)\n    (<a>Eventually.mono</a> hust (fun y hy \u21a6 (hf y hy).2))", [{"full_name": "Filter.Tendsto.inv", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [229, 9], "def_end_pos": [229, 27]}, {"full_name": "Filter.Tendsto.smul", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/MulAction.lean", "def_pos": [83, 9], "def_end_pos": [83, 28]}, {"full_name": "Filter.Eventually.mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1157, 9], "def_end_pos": [1157, 24]}]], "state_before": "case intro.intro.intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2208 s \u2022 t, f x \u2208 s \u2227 (f x)\u207b\u00b9 \u2022 x \u2208 t\nx : \u03b2\nhx : x \u2208 closure (s \u2022 t)\nu : Ultrafilter \u03b2\nhust : s \u2022 t \u2208 u\nhux : \u2191u \u2264 \ud835\udcdd x\nthis : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdf s\ng : \u03b1\nhg : g \u2208 s\nhug : \u2191(Ultrafilter.map f u) \u2264 \ud835\udcdd g\n\u22a2 g\u207b\u00b9 \u2022 x \u2208 t", "state_after": "no goals"}, {"tactic": "rintro x \u27e8g, hgs, y, hyt, rfl\u27e9", "annotated_tactic": ["rintro x \u27e8g, hgs, y, hyt, rfl\u27e9", []], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\n\u22a2 \u2200 x \u2208 s \u2022 t, \u2203 g \u2208 s, g\u207b\u00b9 \u2022 x \u2208 t", "state_after": "case intro.intro.intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\ng : \u03b1\nhgs : g \u2208 s\ny : \u03b2\nhyt : y \u2208 t\n\u22a2 \u2203 g_1 \u2208 s, g_1\u207b\u00b9 \u2022 (fun x x_1 => x \u2022 x_1) g y \u2208 t"}, {"tactic": "refine \u27e8g, hgs, ?_\u27e9", "annotated_tactic": ["refine \u27e8g, hgs, ?_\u27e9", []], "state_before": "case intro.intro.intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\ng : \u03b1\nhgs : g \u2208 s\ny : \u03b2\nhyt : y \u2208 t\n\u22a2 \u2203 g_1 \u2208 s, g_1\u207b\u00b9 \u2022 (fun x x_1 => x \u2022 x_1) g y \u2208 t", "state_after": "case intro.intro.intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\ng : \u03b1\nhgs : g \u2208 s\ny : \u03b2\nhyt : y \u2208 t\n\u22a2 g\u207b\u00b9 \u2022 (fun x x_1 => x \u2022 x_1) g y \u2208 t"}, {"tactic": "rwa [inv_smul_smul]", "annotated_tactic": ["rwa [<a>inv_smul_smul</a>]", [{"full_name": "inv_smul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [37, 9], "def_end_pos": [37, 22]}]], "state_before": "case intro.intro.intro.intro\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : ContinuousSMul \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nht : IsClosed t\nhs : IsCompact s\ng : \u03b1\nhgs : g \u2208 s\ny : \u03b2\nhyt : y \u2208 t\n\u22a2 g\u207b\u00b9 \u2022 (fun x x_1 => x \u2022 x_1) g y \u2208 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Multiset.toFinset_eq_singleton_iff", "start": [3325, 1], "end": [3338, 87], "traced_tactics": [{"tactic": "refine \u27e8fun H \u21a6 \u27e8fun h \u21a6 ?_, ext' fun x \u21a6 ?_\u27e9, fun H \u21a6 ?_\u27e9", "annotated_tactic": ["refine \u27e8fun H \u21a6 \u27e8fun h \u21a6 ?_, <a>ext'</a> fun x \u21a6 ?_\u27e9, fun H \u21a6 ?_\u27e9", [{"full_name": "Multiset.ext'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2607, 9], "def_end_pos": [2607, 13]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\n\u22a2 toFinset s = {a} \u2194 card s \u2260 0 \u2227 s = card s \u2022 {a}", "state_after": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nh : card s = 0\n\u22a2 False\n\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\n\u22a2 count x s = count x (card s \u2022 {a})\n\ncase refine_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : card s \u2260 0 \u2227 s = card s \u2022 {a}\n\u22a2 toFinset s = {a}"}, {"tactic": "simpa only [toFinset_nsmul _ _ H.1, toFinset_singleton] using congr($(H.2).toFinset)", "annotated_tactic": ["simpa only [<a>toFinset_nsmul</a> _ _ H.1, <a>toFinset_singleton</a>] using congr($(H.2).<a>toFinset</a>)", [{"full_name": "Multiset.toFinset_nsmul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3317, 9], "def_end_pos": [3317, 23]}, {"full_name": "Multiset.toFinset_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3307, 9], "def_end_pos": [3307, 27]}, {"full_name": "Multiset.toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3273, 5], "def_end_pos": [3273, 13]}]], "state_before": "case refine_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : card s \u2260 0 \u2227 s = card s \u2022 {a}\n\u22a2 toFinset s = {a}", "state_after": "no goals"}, {"tactic": "rw [card_eq_zero.1 h, toFinset_zero] at H", "annotated_tactic": ["rw [<a>card_eq_zero</a>.1 h, <a>toFinset_zero</a>] at H", [{"full_name": "Multiset.card_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [823, 9], "def_end_pos": [823, 21]}, {"full_name": "Multiset.toFinset_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3297, 9], "def_end_pos": [3297, 22]}]], "state_before": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nh : card s = 0\n\u22a2 False", "state_after": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : \u2205 = {a}\nh : card s = 0\n\u22a2 False"}, {"tactic": "exact Finset.singleton_ne_empty _ H.symm", "annotated_tactic": ["exact <a>Finset.singleton_ne_empty</a> _ H.symm", [{"full_name": "Finset.singleton_ne_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [722, 9], "def_end_pos": [722, 27]}]], "state_before": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : \u2205 = {a}\nh : card s = 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [count_nsmul, count_singleton]", "annotated_tactic": ["rw [<a>count_nsmul</a>, <a>count_singleton</a>]", [{"full_name": "Multiset.count_nsmul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2493, 9], "def_end_pos": [2493, 20]}, {"full_name": "Multiset.count_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2473, 9], "def_end_pos": [2473, 24]}]], "state_before": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\n\u22a2 count x s = count x (card s \u2022 {a})", "state_after": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\n\u22a2 count x s = card s * if x = a then 1 else 0"}, {"tactic": "by_cases hx : x = a", "annotated_tactic": ["by_cases hx : x = a", []], "state_before": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\n\u22a2 count x s = card s * if x = a then 1 else 0", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : x = a\n\u22a2 count x s = card s * if x = a then 1 else 0\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : \u00acx = a\n\u22a2 count x s = card s * if x = a then 1 else 0"}, {"tactic": "have hx' : x \u2209 s := fun h' \u21a6 hx <| by rwa [\u2190 mem_toFinset, H, Finset.mem_singleton] at h'", "annotated_tactic": ["have hx' : x \u2209 s := fun h' \u21a6 hx <| by rwa [\u2190 <a>mem_toFinset</a>, H, <a>Finset.mem_singleton</a>] at h'", [{"full_name": "Multiset.mem_toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3292, 9], "def_end_pos": [3292, 21]}, {"full_name": "Finset.mem_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [684, 9], "def_end_pos": [684, 22]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : \u00acx = a\n\u22a2 count x s = card s * if x = a then 1 else 0", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : \u00acx = a\nhx' : x \u2209 s\n\u22a2 count x s = card s * if x = a then 1 else 0"}, {"tactic": "simp_rw [count_eq_zero_of_not_mem hx', hx, ite_false, mul_zero]", "annotated_tactic": ["simp_rw [<a>count_eq_zero_of_not_mem</a> hx', hx, <a>ite_false</a>, <a>mul_zero</a>]", [{"full_name": "Multiset.count_eq_zero_of_not_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2510, 9], "def_end_pos": [2510, 33]}, {"full_name": "ite_false", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [89, 17], "def_end_pos": [89, 26]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : \u00acx = a\nhx' : x \u2209 s\n\u22a2 count x s = card s * if x = a then 1 else 0", "state_after": "no goals"}, {"tactic": "simp_rw [hx, ite_true, mul_one, count_eq_card]", "annotated_tactic": ["simp_rw [hx, <a>ite_true</a>, <a>mul_one</a>, <a>count_eq_card</a>]", [{"full_name": "ite_true", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [88, 17], "def_end_pos": [88, 25]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "Multiset.count_eq_card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2523, 9], "def_end_pos": [2523, 22]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : x = a\n\u22a2 count x s = card s * if x = a then 1 else 0", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : x = a\n\u22a2 \u2200 x \u2208 s, a = x"}, {"tactic": "intro y hy", "annotated_tactic": ["intro y hy", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : x = a\n\u22a2 \u2200 x \u2208 s, a = x", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : x = a\ny : \u03b1\nhy : y \u2208 s\n\u22a2 a = y"}, {"tactic": "rw [\u2190 mem_toFinset, H, Finset.mem_singleton] at hy", "annotated_tactic": ["rw [\u2190 <a>mem_toFinset</a>, H, <a>Finset.mem_singleton</a>] at hy", [{"full_name": "Multiset.mem_toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3292, 9], "def_end_pos": [3292, 21]}, {"full_name": "Finset.mem_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [684, 9], "def_end_pos": [684, 22]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : x = a\ny : \u03b1\nhy : y \u2208 s\n\u22a2 a = y", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : x = a\ny : \u03b1\nhy : y = a\n\u22a2 a = y"}, {"tactic": "exact hy.symm", "annotated_tactic": ["exact hy.symm", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : x = a\ny : \u03b1\nhy : y = a\n\u22a2 a = y", "state_after": "no goals"}, {"tactic": "rwa [\u2190 mem_toFinset, H, Finset.mem_singleton] at h'", "annotated_tactic": ["rwa [\u2190 <a>mem_toFinset</a>, H, <a>Finset.mem_singleton</a>] at h'", [{"full_name": "Multiset.mem_toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3292, 9], "def_end_pos": [3292, 21]}, {"full_name": "Finset.mem_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [684, 9], "def_end_pos": [684, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t s : Multiset \u03b1\na : \u03b1\nH : toFinset s = {a}\nx : \u03b1\nhx : \u00acx = a\nh' : x \u2208 s\n\u22a2 x = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/Composition.lean", "full_name": "Composition.sizeUpTo_strict_mono", "start": [236, 1], "end": [238, 7], "traced_tactics": [{"tactic": "rw [c.sizeUpTo_succ h]", "annotated_tactic": ["rw [c.sizeUpTo_succ h]", []], "state_before": "n : \u2115\nc : Composition n\ni : \u2115\nh : i < length c\n\u22a2 sizeUpTo c i < sizeUpTo c (i + 1)", "state_after": "n : \u2115\nc : Composition n\ni : \u2115\nh : i < length c\n\u22a2 sizeUpTo c i < sizeUpTo c i + List.get c.blocks { val := i, isLt := h }"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n : \u2115\nc : Composition n\ni : \u2115\nh : i < length c\n\u22a2 sizeUpTo c i < sizeUpTo c i + List.get c.blocks { val := i, isLt := h }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.map_op_smul'", "start": [356, 1], "end": [359, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Pi.lean", "full_name": "LinearMap.vecCons_apply", "start": [584, 1], "end": [586, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Strict.lean", "full_name": "strictConvex_Iio", "start": [179, 1], "end": [180, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Conformal.lean", "full_name": "isConformalMap_iff_is_complex_or_conj_linear", "start": [105, 1], "end": [123, 53], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "f : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\n\u22a2 IsConformalMap g \u2194 ((\u2203 map, restrictScalars \u211d map = g) \u2228 \u2203 map, restrictScalars \u211d map = comp g \u2191conjCLE) \u2227 g \u2260 0", "state_after": "case mp\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\n\u22a2 IsConformalMap g \u2192 ((\u2203 map, restrictScalars \u211d map = g) \u2228 \u2203 map, restrictScalars \u211d map = comp g \u2191conjCLE) \u2227 g \u2260 0\n\ncase mpr\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\n\u22a2 ((\u2203 map, restrictScalars \u211d map = g) \u2228 \u2203 map, restrictScalars \u211d map = comp g \u2191conjCLE) \u2227 g \u2260 0 \u2192 IsConformalMap g"}, {"tactic": "exact fun h => \u27e8h.is_complex_or_conj_linear, h.ne_zero\u27e9", "annotated_tactic": ["exact fun h => \u27e8h.is_complex_or_conj_linear, h.ne_zero\u27e9", []], "state_before": "case mp\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\n\u22a2 IsConformalMap g \u2192 ((\u2203 map, restrictScalars \u211d map = g) \u2228 \u2203 map, restrictScalars \u211d map = comp g \u2191conjCLE) \u2227 g \u2260 0", "state_after": "no goals"}, {"tactic": "rintro \u27e8\u27e8map, rfl\u27e9 | \u27e8map, hmap\u27e9, h\u2082\u27e9", "annotated_tactic": ["rintro \u27e8\u27e8map, rfl\u27e9 | \u27e8map, hmap\u27e9, h\u2082\u27e9", []], "state_before": "case mpr\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\n\u22a2 ((\u2203 map, restrictScalars \u211d map = g) \u2228 \u2203 map, restrictScalars \u211d map = comp g \u2191conjCLE) \u2227 g \u2260 0 \u2192 IsConformalMap g", "state_after": "case mpr.intro.inl.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nh\u2082 : restrictScalars \u211d map \u2260 0\n\u22a2 IsConformalMap (restrictScalars \u211d map)\n\ncase mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nh\u2082 : g \u2260 0\nmap : \u2102 \u2192L[\u2102] \u2102\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\n\u22a2 IsConformalMap g"}, {"tactic": "refine' isConformalMap_complex_linear _", "annotated_tactic": ["refine' <a>isConformalMap_complex_linear</a> _", [{"full_name": "isConformalMap_complex_linear", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Conformal.lean", "def_pos": [49, 9], "def_end_pos": [49, 38]}]], "state_before": "case mpr.intro.inl.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nh\u2082 : restrictScalars \u211d map \u2260 0\n\u22a2 IsConformalMap (restrictScalars \u211d map)", "state_after": "case mpr.intro.inl.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nh\u2082 : restrictScalars \u211d map \u2260 0\n\u22a2 map \u2260 0"}, {"tactic": "contrapose! h\u2082 with w", "annotated_tactic": ["contrapose! h\u2082 with w", []], "state_before": "case mpr.intro.inl.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nh\u2082 : restrictScalars \u211d map \u2260 0\n\u22a2 map \u2260 0", "state_after": "case mpr.intro.inl.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nw : map = 0\n\u22a2 restrictScalars \u211d map = 0"}, {"tactic": "simp only [w, restrictScalars_zero]", "annotated_tactic": ["simp only [w, <a>restrictScalars_zero</a>]", [{"full_name": "ContinuousLinearMap.restrictScalars_zero", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [1787, 9], "def_end_pos": [1787, 29]}]], "state_before": "case mpr.intro.inl.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nw : map = 0\n\u22a2 restrictScalars \u211d map = 0", "state_after": "no goals"}, {"tactic": "have minor\u2081 : g = map.restrictScalars \u211d \u2218L \u2191conjCLE := by\n  ext1\n  simp only [hmap, coe_comp', ContinuousLinearEquiv.coe_coe, Function.comp_apply,\n    conjCLE_apply, starRingEnd_self_apply]", "annotated_tactic": ["have minor\u2081 : g = map.restrictScalars \u211d \u2218L \u2191<a>conjCLE</a> := by\n        ext1\n        simp only [hmap, <a>coe_comp'</a>, <a>ContinuousLinearEquiv.coe_coe</a>, <a>Function.comp_apply</a>,\n          <a>conjCLE_apply</a>, <a>starRingEnd_self_apply</a>]", [{"full_name": "Complex.conjCLE", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Basic.lean", "def_pos": [377, 5], "def_end_pos": [377, 12]}, {"full_name": "ContinuousLinearMap.coe_comp'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [799, 9], "def_end_pos": [799, 18]}, {"full_name": "ContinuousLinearEquiv.coe_coe", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [1904, 9], "def_end_pos": [1904, 16]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "Complex.conjCLE_apply", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Basic.lean", "def_pos": [387, 9], "def_end_pos": [387, 22]}, {"full_name": "starRingEnd_self_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Star/Basic.lean", "def_pos": [401, 9], "def_end_pos": [401, 31]}]], "state_before": "case mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nh\u2082 : g \u2260 0\nmap : \u2102 \u2192L[\u2102] \u2102\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\n\u22a2 IsConformalMap g", "state_after": "case mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nh\u2082 : g \u2260 0\nmap : \u2102 \u2192L[\u2102] \u2102\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nminor\u2081 : g = comp (restrictScalars \u211d map) \u2191conjCLE\n\u22a2 IsConformalMap g"}, {"tactic": "rw [minor\u2081] at h\u2082 \u22a2", "annotated_tactic": ["rw [minor\u2081] at h\u2082 \u22a2", []], "state_before": "case mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nh\u2082 : g \u2260 0\nmap : \u2102 \u2192L[\u2102] \u2102\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nminor\u2081 : g = comp (restrictScalars \u211d map) \u2191conjCLE\n\u22a2 IsConformalMap g", "state_after": "case mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nh\u2082 : comp (restrictScalars \u211d map) \u2191conjCLE \u2260 0\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nminor\u2081 : g = comp (restrictScalars \u211d map) \u2191conjCLE\n\u22a2 IsConformalMap (comp (restrictScalars \u211d map) \u2191conjCLE)"}, {"tactic": "refine' isConformalMap_complex_linear_conj _", "annotated_tactic": ["refine' <a>isConformalMap_complex_linear_conj</a> _", [{"full_name": "isConformalMap_complex_linear_conj", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Conformal.lean", "def_pos": [67, 9], "def_end_pos": [67, 43]}]], "state_before": "case mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nh\u2082 : comp (restrictScalars \u211d map) \u2191conjCLE \u2260 0\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nminor\u2081 : g = comp (restrictScalars \u211d map) \u2191conjCLE\n\u22a2 IsConformalMap (comp (restrictScalars \u211d map) \u2191conjCLE)", "state_after": "case mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nh\u2082 : comp (restrictScalars \u211d map) \u2191conjCLE \u2260 0\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nminor\u2081 : g = comp (restrictScalars \u211d map) \u2191conjCLE\n\u22a2 map \u2260 0"}, {"tactic": "contrapose! h\u2082 with w", "annotated_tactic": ["contrapose! h\u2082 with w", []], "state_before": "case mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nh\u2082 : comp (restrictScalars \u211d map) \u2191conjCLE \u2260 0\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nminor\u2081 : g = comp (restrictScalars \u211d map) \u2191conjCLE\n\u22a2 map \u2260 0", "state_after": "case mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nminor\u2081 : g = comp (restrictScalars \u211d map) \u2191conjCLE\nw : map = 0\n\u22a2 comp (restrictScalars \u211d map) \u2191conjCLE = 0"}, {"tactic": "simp only [w, restrictScalars_zero, zero_comp]", "annotated_tactic": ["simp only [w, <a>restrictScalars_zero</a>, <a>zero_comp</a>]", [{"full_name": "ContinuousLinearMap.restrictScalars_zero", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [1787, 9], "def_end_pos": [1787, 29]}, {"full_name": "ContinuousLinearMap.zero_comp", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [824, 9], "def_end_pos": [824, 18]}]], "state_before": "case mpr.intro.inr.intro\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nmap : \u2102 \u2192L[\u2102] \u2102\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nminor\u2081 : g = comp (restrictScalars \u211d map) \u2191conjCLE\nw : map = 0\n\u22a2 comp (restrictScalars \u211d map) \u2191conjCLE = 0", "state_after": "no goals"}, {"tactic": "ext1", "annotated_tactic": ["ext1", []], "state_before": "f : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nh\u2082 : g \u2260 0\nmap : \u2102 \u2192L[\u2102] \u2102\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\n\u22a2 g = comp (restrictScalars \u211d map) \u2191conjCLE", "state_after": "case h\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nh\u2082 : g \u2260 0\nmap : \u2102 \u2192L[\u2102] \u2102\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nx\u271d : \u2102\n\u22a2 g x\u271d = (comp (restrictScalars \u211d map) \u2191conjCLE) x\u271d"}, {"tactic": "simp only [hmap, coe_comp', ContinuousLinearEquiv.coe_coe, Function.comp_apply,\n  conjCLE_apply, starRingEnd_self_apply]", "annotated_tactic": ["simp only [hmap, <a>coe_comp'</a>, <a>ContinuousLinearEquiv.coe_coe</a>, <a>Function.comp_apply</a>,\n          <a>conjCLE_apply</a>, <a>starRingEnd_self_apply</a>]", [{"full_name": "ContinuousLinearMap.coe_comp'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [799, 9], "def_end_pos": [799, 18]}, {"full_name": "ContinuousLinearEquiv.coe_coe", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [1904, 9], "def_end_pos": [1904, 16]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "Complex.conjCLE_apply", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Basic.lean", "def_pos": [387, 9], "def_end_pos": [387, 22]}, {"full_name": "starRingEnd_self_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Star/Basic.lean", "def_pos": [401, 9], "def_end_pos": [401, 31]}]], "state_before": "case h\nf : \u2102 \u2192 \u2102\nz : \u2102\ng : \u2102 \u2192L[\u211d] \u2102\nh\u2082 : g \u2260 0\nmap : \u2102 \u2192L[\u2102] \u2102\nhmap : restrictScalars \u211d map = comp g \u2191conjCLE\nx\u271d : \u2102\n\u22a2 g x\u271d = (comp (restrictScalars \u211d map) \u2191conjCLE) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.hasPullbacks_of_hasLimit_cospan", "start": [2686, 1], "end": [2688, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "not_summable_iff_tendsto_nat_atTop_of_nonneg", "start": [1355, 1], "end": [1358, 59], "traced_tactics": [{"tactic": "lift f to \u2115 \u2192 \u211d\u22650 using hf", "annotated_tactic": ["lift f to \u2115 \u2192 \u211d\u22650 using hf", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), 0 \u2264 f n\n\u22a2 \u00acSummable f \u2194 Tendsto (fun n => \u2211 i in Finset.range n, f i) atTop atTop", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u2115 \u2192 \u211d\u22650\n\u22a2 (\u00acSummable fun i => \u2191(f i)) \u2194 Tendsto (fun n => \u2211 i in Finset.range n, (fun i => \u2191(f i)) i) atTop atTop"}, {"tactic": "exact mod_cast NNReal.not_summable_iff_tendsto_nat_atTop", "annotated_tactic": ["exact mod_cast <a>NNReal.not_summable_iff_tendsto_nat_atTop</a>", [{"full_name": "NNReal.not_summable_iff_tendsto_nat_atTop", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [1159, 9], "def_end_pos": [1159, 43]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u2115 \u2192 \u211d\u22650\n\u22a2 (\u00acSummable fun i => \u2191(f i)) \u2194 Tendsto (fun n => \u2211 i in Finset.range n, (fun i => \u2191(f i)) i) atTop atTop", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.range_sigma_eq_iUnion_range", "start": [1267, 1], "end": [1269, 21], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\n\u03b3 : \u03b1 \u2192 Type u_11\nf : Sigma \u03b3 \u2192 \u03b2\n\u22a2 \u2200 (x : \u03b2), x \u2208 range f \u2194 x \u2208 \u22c3 a, range fun b => f { fst := a, snd := b }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Real.lean", "full_name": "ENNReal.ofReal_le_ofNat", "start": [265, 1], "end": [268, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "nhdsWithin_Ici_basis_Ico", "start": [1014, 1], "end": [1016, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.pullbackSymmetry_hom_of_mono_eq", "start": [1964, 1], "end": [1965, 66], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nW X Y Z : C\nf : X \u27f6 Y\ninst\u271d : Mono f\n\u22a2 (pullbackSymmetry f f).hom = \ud835\udfd9 (pullback f f)", "state_after": "case h\u2080\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nW X Y Z : C\nf : X \u27f6 Y\ninst\u271d : Mono f\n\u22a2 (pullbackSymmetry f f).hom \u226b pullback.fst = \ud835\udfd9 (pullback f f) \u226b pullback.fst\n\ncase h\u2081\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nW X Y Z : C\nf : X \u27f6 Y\ninst\u271d : Mono f\n\u22a2 (pullbackSymmetry f f).hom \u226b pullback.snd = \ud835\udfd9 (pullback f f) \u226b pullback.snd"}, {"tactic": "simp [fst_eq_snd_of_mono_eq]", "annotated_tactic": ["simp [<a>fst_eq_snd_of_mono_eq</a>]", [{"full_name": "CategoryTheory.Limits.fst_eq_snd_of_mono_eq", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "def_pos": [1958, 9], "def_end_pos": [1958, 30]}]], "state_before": "case h\u2080\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nW X Y Z : C\nf : X \u27f6 Y\ninst\u271d : Mono f\n\u22a2 (pullbackSymmetry f f).hom \u226b pullback.fst = \ud835\udfd9 (pullback f f) \u226b pullback.fst\n\ncase h\u2081\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nW X Y Z : C\nf : X \u27f6 Y\ninst\u271d : Mono f\n\u22a2 (pullbackSymmetry f f).hom \u226b pullback.snd = \ud835\udfd9 (pullback f f) \u226b pullback.snd", "state_after": "case h\u2081\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nW X Y Z : C\nf : X \u27f6 Y\ninst\u271d : Mono f\n\u22a2 (pullbackSymmetry f f).hom \u226b pullback.snd = \ud835\udfd9 (pullback f f) \u226b pullback.snd"}, {"tactic": "simp [fst_eq_snd_of_mono_eq]", "annotated_tactic": ["simp [<a>fst_eq_snd_of_mono_eq</a>]", [{"full_name": "CategoryTheory.Limits.fst_eq_snd_of_mono_eq", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "def_pos": [1958, 9], "def_end_pos": [1958, 30]}]], "state_before": "case h\u2081\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nW X Y Z : C\nf : X \u27f6 Y\ninst\u271d : Mono f\n\u22a2 (pullbackSymmetry f f).hom \u226b pullback.snd = \ud835\udfd9 (pullback f f) \u226b pullback.snd", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/FreeRing.lean", "full_name": "FreeRing.map_of", "start": [108, 1], "end": [109, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "mul_mem_ball_iff_norm", "start": [1645, 1], "end": [1646, 46], "traced_tactics": [{"tactic": "rw [mem_ball_iff_norm'', mul_div_cancel''']", "annotated_tactic": ["rw [<a>mem_ball_iff_norm''</a>, <a>mul_div_cancel'''</a>]", [{"full_name": "mem_ball_iff_norm''", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [693, 9], "def_end_pos": [693, 28]}, {"full_name": "mul_div_cancel'''", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1027, 9], "def_end_pos": [1027, 26]}]], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\n\u22a2 a * b \u2208 ball a r \u2194 \u2016b\u2016 < r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/RatFunc.lean", "full_name": "RatFunc.intDegree_C", "start": [1579, 1], "end": [1580, 71], "traced_tactics": [{"tactic": "rw [intDegree, num_C, natDegree_C, denom_C, natDegree_one, sub_self]", "annotated_tactic": ["rw [<a>intDegree</a>, <a>num_C</a>, <a>natDegree_C</a>, <a>denom_C</a>, <a>natDegree_one</a>, <a>sub_self</a>]", [{"full_name": "RatFunc.intDegree", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1564, 5], "def_end_pos": [1564, 14]}, {"full_name": "RatFunc.num_C", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1433, 9], "def_end_pos": [1433, 14]}, {"full_name": "Polynomial.natDegree_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [268, 9], "def_end_pos": [268, 20]}, {"full_name": "RatFunc.denom_C", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1439, 9], "def_end_pos": [1439, 16]}, {"full_name": "Polynomial.natDegree_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [276, 9], "def_end_pos": [276, 22]}, {"full_name": "sub_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [813, 30], "def_end_pos": [813, 38]}]], "state_before": "K : Type u\ninst\u271d : Field K\nk : K\n\u22a2 intDegree (C k) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Fin.lean", "full_name": "finSuccEquiv'_at", "start": [137, 1], "end": [138, 23], "traced_tactics": [{"tactic": "simp [finSuccEquiv']", "annotated_tactic": ["simp [<a>finSuccEquiv'</a>]", [{"full_name": "finSuccEquiv'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Fin.lean", "def_pos": [128, 5], "def_end_pos": [128, 18]}]], "state_before": "m n : \u2115\ni : Fin (n + 1)\n\u22a2 (finSuccEquiv' i) i = none", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/GroupCompletion.lean", "full_name": "UniformSpace.Completion.continuous_toCompl", "start": [186, 1], "end": [187, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.OuterMeasure.map_top_of_surjective", "start": [635, 1], "end": [636, 43], "traced_tactics": [{"tactic": "rw [map_top, hf.range_eq, restrict_univ]", "annotated_tactic": ["rw [<a>map_top</a>, hf.range_eq, <a>restrict_univ</a>]", [{"full_name": "MeasureTheory.OuterMeasure.map_top", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [628, 9], "def_end_pos": [628, 16]}, {"full_name": "MeasureTheory.OuterMeasure.restrict_univ", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [568, 9], "def_end_pos": [568, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\nR' : Type u_4\nms : Set (OuterMeasure \u03b1)\nm : OuterMeasure \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\n\u22a2 (map f) \u22a4 = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Finite/Basic.lean", "full_name": "FiniteField.pow_card_pow", "start": [235, 1], "end": [238, 43], "traced_tactics": [{"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "K : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\nn : \u2115\na : K\n\u22a2 a ^ q ^ n = a", "state_after": "case zero\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\n\u22a2 a ^ q ^ Nat.zero = a\n\ncase succ\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\nn : \u2115\nih : a ^ q ^ n = a\n\u22a2 a ^ q ^ Nat.succ n = a"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\n\u22a2 a ^ q ^ Nat.zero = a", "state_after": "no goals"}, {"tactic": "simp [pow_succ, pow_mul, ih, pow_card]", "annotated_tactic": ["simp [<a>pow_succ</a>, <a>pow_mul</a>, ih, <a>pow_card</a>]", [{"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}, {"full_name": "pow_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [110, 9], "def_end_pos": [110, 16]}, {"full_name": "FiniteField.pow_card", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finite/Basic.lean", "def_pos": [229, 9], "def_end_pos": [229, 17]}]], "state_before": "case succ\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\nn : \u2115\nih : a ^ q ^ n = a\n\u22a2 a ^ q ^ Nat.succ n = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/FiniteDimensional.lean", "full_name": "Module.finrank_le_one_iff_top_isPrincipal", "start": [1079, 1], "end": [1082, 18], "traced_tactics": [{"tactic": "rw [\u2190 Module.rank_le_one_iff_top_isPrincipal, \u2190 finrank_eq_rank, \u2190 Cardinal.natCast_le,\n  Nat.cast_one]", "annotated_tactic": ["rw [\u2190 <a>Module.rank_le_one_iff_top_isPrincipal</a>, \u2190 <a>finrank_eq_rank</a>, \u2190 <a>Cardinal.natCast_le</a>,\n    <a>Nat.cast_one</a>]", [{"full_name": "Module.rank_le_one_iff_top_isPrincipal", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/DivisionRing.lean", "def_pos": [303, 9], "def_end_pos": [303, 47]}, {"full_name": "finrank_eq_rank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "def_pos": [477, 9], "def_end_pos": [477, 24]}, {"full_name": "Cardinal.natCast_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1459, 9], "def_end_pos": [1459, 19]}, {"full_name": "Nat.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [150, 9], "def_end_pos": [150, 17]}]], "state_before": "K : Type u\nV : Type v\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : FiniteDimensional K V\n\u22a2 finrank K V \u2264 1 \u2194 IsPrincipal \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.exists_mem_eq_inf", "start": [1329, 1], "end": [1331, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "full_name": "Equiv.Perm.cycleOf_zpow_apply_self", "start": [76, 1], "end": [81, 95], "traced_tactics": [{"tactic": "intro z", "annotated_tactic": ["intro z", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g : Perm \u03b1\nx\u271d y : \u03b1\nf : Perm \u03b1\nx : \u03b1\n\u22a2 \u2200 (n : \u2124), (cycleOf f x ^ n) x = (f ^ n) x", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g : Perm \u03b1\nx\u271d y : \u03b1\nf : Perm \u03b1\nx : \u03b1\nz : \u2124\n\u22a2 (cycleOf f x ^ z) x = (f ^ z) x"}, {"tactic": "induction' z with z hz", "annotated_tactic": ["induction' z with z hz", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g : Perm \u03b1\nx\u271d y : \u03b1\nf : Perm \u03b1\nx : \u03b1\nz : \u2124\n\u22a2 (cycleOf f x ^ z) x = (f ^ z) x", "state_after": "case ofNat\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g : Perm \u03b1\nx\u271d y : \u03b1\nf : Perm \u03b1\nx : \u03b1\nz : \u2115\n\u22a2 (cycleOf f x ^ Int.ofNat z) x = (f ^ Int.ofNat z) x\n\ncase negSucc\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g : Perm \u03b1\nx\u271d y : \u03b1\nf : Perm \u03b1\nx : \u03b1\nhz : \u2115\n\u22a2 (cycleOf f x ^ Int.negSucc hz) x = (f ^ Int.negSucc hz) x"}, {"tactic": "exact cycleOf_pow_apply_self f x z", "annotated_tactic": ["exact <a>cycleOf_pow_apply_self</a> f x z", [{"full_name": "Equiv.Perm.cycleOf_pow_apply_self", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "def_pos": [67, 9], "def_end_pos": [67, 31]}]], "state_before": "case ofNat\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g : Perm \u03b1\nx\u271d y : \u03b1\nf : Perm \u03b1\nx : \u03b1\nz : \u2115\n\u22a2 (cycleOf f x ^ Int.ofNat z) x = (f ^ Int.ofNat z) x", "state_after": "no goals"}, {"tactic": "rw [zpow_negSucc, \u2190 inv_pow, cycleOf_inv, zpow_negSucc, \u2190 inv_pow, cycleOf_pow_apply_self]", "annotated_tactic": ["rw [<a>zpow_negSucc</a>, \u2190 <a>inv_pow</a>, <a>cycleOf_inv</a>, <a>zpow_negSucc</a>, \u2190 <a>inv_pow</a>, <a>cycleOf_pow_apply_self</a>]", [{"full_name": "zpow_negSucc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [978, 9], "def_end_pos": [978, 21]}, {"full_name": "inv_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [278, 9], "def_end_pos": [278, 16]}, {"full_name": "Equiv.Perm.cycleOf_inv", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "def_pos": [60, 9], "def_end_pos": [60, 20]}, {"full_name": "zpow_negSucc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [978, 9], "def_end_pos": [978, 21]}, {"full_name": "inv_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [278, 9], "def_end_pos": [278, 16]}, {"full_name": "Equiv.Perm.cycleOf_pow_apply_self", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "def_pos": [67, 9], "def_end_pos": [67, 31]}]], "state_before": "case negSucc\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g : Perm \u03b1\nx\u271d y : \u03b1\nf : Perm \u03b1\nx : \u03b1\nhz : \u2115\n\u22a2 (cycleOf f x ^ Int.negSucc hz) x = (f ^ Int.negSucc hz) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "full_name": "aemeasurable_union_iff", "start": [153, 1], "end": [156, 92], "traced_tactics": [{"tactic": "simp only [union_eq_iUnion, aemeasurable_iUnion_iff, Bool.forall_bool, cond, and_comm]", "annotated_tactic": ["simp only [<a>union_eq_iUnion</a>, <a>aemeasurable_iUnion_iff</a>, <a>Bool.forall_bool</a>, <a>cond</a>, <a>and_comm</a>]", [{"full_name": "Set.union_eq_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1342, 9], "def_end_pos": [1342, 24]}, {"full_name": "aemeasurable_iUnion_iff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "def_pos": [147, 9], "def_end_pos": [147, 39]}, {"full_name": "Bool.forall_bool", "def_path": ".lake/packages/mathlib/Mathlib/Data/Bool/Basic.lean", "def_pos": [101, 9], "def_end_pos": [101, 20]}, {"full_name": "cond", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [998, 21], "def_end_pos": [998, 25]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nR : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\nf g : \u03b1 \u2192 \u03b2\n\u03bc \u03bd : Measure \u03b1\ns t : Set \u03b1\n\u22a2 AEMeasurable f (Measure.restrict \u03bc (s \u222a t)) \u2194\n    AEMeasurable f (Measure.restrict \u03bc s) \u2227 AEMeasurable f (Measure.restrict \u03bc t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Alternating/Basic.lean", "full_name": "AlternatingMap.domDomCongr_eq_iff", "start": [807, 1], "end": [809, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "full_name": "FiniteDimensional.proper", "start": [627, 1], "end": [630, 77], "traced_tactics": [{"tactic": "have : ProperSpace \ud835\udd5c := .of_locallyCompactSpace \ud835\udd5c", "annotated_tactic": ["have : <a>ProperSpace</a> \ud835\udd5c := .of_locallyCompactSpace \ud835\udd5c", [{"full_name": "ProperSpace", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/ProperSpace.lean", "def_pos": [32, 7], "def_end_pos": [32, 18]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : LocallyCompactSpace \ud835\udd5c\ninst\u271d : FiniteDimensional \ud835\udd5c E\n\u22a2 ProperSpace E", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : LocallyCompactSpace \ud835\udd5c\ninst\u271d : FiniteDimensional \ud835\udd5c E\nthis : ProperSpace \ud835\udd5c\n\u22a2 ProperSpace E"}, {"tactic": "set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun \ud835\udd5c _ _ (finrank \ud835\udd5c E)).symm", "annotated_tactic": ["set e := <a>ContinuousLinearEquiv.ofFinrankEq</a> (@<a>finrank_fin_fun</a> \ud835\udd5c _ _ (<a>finrank</a> \ud835\udd5c E)).<a>symm</a>", [{"full_name": "ContinuousLinearEquiv.ofFinrankEq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/FiniteDimension.lean", "def_pos": [425, 5], "def_end_pos": [425, 38]}, {"full_name": "FiniteDimensional.finrank_fin_fun", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "def_pos": [318, 9], "def_end_pos": [318, 42]}, {"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : LocallyCompactSpace \ud835\udd5c\ninst\u271d : FiniteDimensional \ud835\udd5c E\nthis : ProperSpace \ud835\udd5c\n\u22a2 ProperSpace E", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : LocallyCompactSpace \ud835\udd5c\ninst\u271d : FiniteDimensional \ud835\udd5c E\nthis : ProperSpace \ud835\udd5c\ne : E \u2243L[\ud835\udd5c] Fin (finrank \ud835\udd5c E) \u2192 \ud835\udd5c := ContinuousLinearEquiv.ofFinrankEq \u22ef\n\u22a2 ProperSpace E"}, {"tactic": "exact e.symm.antilipschitz.properSpace e.symm.continuous e.symm.surjective", "annotated_tactic": ["exact e.symm.antilipschitz.properSpace e.symm.continuous e.symm.surjective", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : LocallyCompactSpace \ud835\udd5c\ninst\u271d : FiniteDimensional \ud835\udd5c E\nthis : ProperSpace \ud835\udd5c\ne : E \u2243L[\ud835\udd5c] Fin (finrank \ud835\udd5c E) \u2192 \ud835\udd5c := ContinuousLinearEquiv.ofFinrankEq \u22ef\n\u22a2 ProperSpace E", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/SigmaCompact.lean", "full_name": "isSigmaCompact_iUnion_of_isCompact", "start": [36, 1], "end": [43, 77], "traced_tactics": [{"tactic": "rcases isEmpty_or_nonempty \u03b9", "annotated_tactic": ["rcases <a>isEmpty_or_nonempty</a> \u03b9", [{"full_name": "isEmpty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [215, 9], "def_end_pos": [215, 28]}]], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns\u271d t : Set X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\n\u22a2 IsSigmaCompact (\u22c3 i, s i)", "state_after": "case inl\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns\u271d t : Set X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\nh\u271d : IsEmpty \u03b9\n\u22a2 IsSigmaCompact (\u22c3 i, s i)\n\ncase inr\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns\u271d t : Set X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\nh\u271d : Nonempty \u03b9\n\u22a2 IsSigmaCompact (\u22c3 i, s i)"}, {"tactic": "simp only [iUnion_of_empty, isSigmaCompact_empty]", "annotated_tactic": ["simp only [<a>iUnion_of_empty</a>, <a>isSigmaCompact_empty</a>]", [{"full_name": "Set.iUnion_of_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1333, 9], "def_end_pos": [1333, 24]}, {"full_name": "isSigmaCompact_empty", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/SigmaCompact.lean", "def_pos": [33, 7], "def_end_pos": [33, 27]}]], "state_before": "case inl\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns\u271d t : Set X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\nh\u271d : IsEmpty \u03b9\n\u22a2 IsSigmaCompact (\u22c3 i, s i)", "state_after": "no goals"}, {"tactic": "obtain \u27e8f, hf\u27e9 := countable_iff_exists_surjective.mp h\u03b9", "annotated_tactic": ["obtain \u27e8f, hf\u27e9 := countable_iff_exists_surjective.mp h\u03b9", []], "state_before": "case inr\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns\u271d t : Set X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\nh\u271d : Nonempty \u03b9\n\u22a2 IsSigmaCompact (\u22c3 i, s i)", "state_after": "case inr.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns\u271d t : Set X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\nh\u271d : Nonempty \u03b9\nf : \u2115 \u2192 \u03b9\nhf : Function.Surjective f\n\u22a2 IsSigmaCompact (\u22c3 i, s i)"}, {"tactic": "exact \u27e8s \u2218 f, fun n \u21a6 hcomp (f n), Function.Surjective.iUnion_comp hf _\u27e9", "annotated_tactic": ["exact \u27e8s \u2218 f, fun n \u21a6 hcomp (f n), <a>Function.Surjective.iUnion_comp</a> hf _\u27e9", [{"full_name": "Function.Surjective.iUnion_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [2044, 9], "def_end_pos": [2044, 20]}]], "state_before": "case inr.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns\u271d t : Set X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\nh\u271d : Nonempty \u03b9\nf : \u2115 \u2192 \u03b9\nhf : Function.Surjective f\n\u22a2 IsSigmaCompact (\u22c3 i, s i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "LatticeHom.cancel_left", "start": [1158, 1], "end": [1161, 17], "traced_tactics": [{"tactic": "rw [\u2190 LatticeHom.comp_apply, h, LatticeHom.comp_apply]", "annotated_tactic": ["rw [\u2190 <a>LatticeHom.comp_apply</a>, h, <a>LatticeHom.comp_apply</a>]", [{"full_name": "LatticeHom.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Order/Hom/Lattice.lean", "def_pos": [1109, 9], "def_end_pos": [1109, 19]}, {"full_name": "LatticeHom.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Order/Hom/Lattice.lean", "def_pos": [1109, 9], "def_end_pos": [1109, 19]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Lattice \u03b1\ninst\u271d\u00b2 : Lattice \u03b2\ninst\u271d\u00b9 : Lattice \u03b3\ninst\u271d : Lattice \u03b4\ng : LatticeHom \u03b2 \u03b3\nf\u2081 f\u2082 : LatticeHom \u03b1 \u03b2\nhg : Injective \u21d1g\nh : comp g f\u2081 = comp g f\u2082\na : \u03b1\n\u22a2 g (f\u2081 a) = g (f\u2082 a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.aleph0_le_mul_iff'", "start": [1708, 1], "end": [1711, 32], "traced_tactics": [{"tactic": "have : \u2200 {a : Cardinal.{u}}, \u2135\u2080 \u2264 a \u2192 a \u2260 0 := fun a => ne_bot_of_le_ne_bot aleph0_ne_zero a", "annotated_tactic": ["have : \u2200 {a : <a>Cardinal</a>.{u}}, \u2135\u2080 \u2264 a \u2192 a \u2260 0 := fun a => <a>ne_bot_of_le_ne_bot</a> <a>aleph0_ne_zero</a> a", [{"full_name": "Cardinal", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [108, 5], "def_end_pos": [108, 13]}, {"full_name": "ne_bot_of_le_ne_bot", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [364, 9], "def_end_pos": [364, 28]}, {"full_name": "Cardinal.aleph0_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1278, 9], "def_end_pos": [1278, 23]}]], "state_before": "\u03b1 \u03b2 : Type u\na b : Cardinal.{u}\n\u22a2 \u2135\u2080 \u2264 a * b \u2194 a \u2260 0 \u2227 \u2135\u2080 \u2264 b \u2228 \u2135\u2080 \u2264 a \u2227 b \u2260 0", "state_after": "\u03b1 \u03b2 : Type u\na b : Cardinal.{u}\nthis : \u2200 {a : Cardinal.{u}}, \u2135\u2080 \u2264 a \u2192 a \u2260 0\n\u22a2 \u2135\u2080 \u2264 a * b \u2194 a \u2260 0 \u2227 \u2135\u2080 \u2264 b \u2228 \u2135\u2080 \u2264 a \u2227 b \u2260 0"}, {"tactic": "simp only [aleph0_le_mul_iff, and_or_left, and_iff_right_of_imp this, @and_left_comm (a \u2260 0)]", "annotated_tactic": ["simp only [<a>aleph0_le_mul_iff</a>, <a>and_or_left</a>, <a>and_iff_right_of_imp</a> this, @<a>and_left_comm</a> (a \u2260 0)]", [{"full_name": "Cardinal.aleph0_le_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1702, 9], "def_end_pos": [1702, 26]}, {"full_name": "and_or_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [90, 9], "def_end_pos": [90, 20]}, {"full_name": "and_iff_right_of_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [149, 9], "def_end_pos": [149, 29]}, {"full_name": "and_left_comm", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [41, 9], "def_end_pos": [41, 22]}]], "state_before": "\u03b1 \u03b2 : Type u\na b : Cardinal.{u}\nthis : \u2200 {a : Cardinal.{u}}, \u2135\u2080 \u2264 a \u2192 a \u2260 0\n\u22a2 \u2135\u2080 \u2264 a * b \u2194 a \u2260 0 \u2227 \u2135\u2080 \u2264 b \u2228 \u2135\u2080 \u2264 a \u2227 b \u2260 0", "state_after": "\u03b1 \u03b2 : Type u\na b : Cardinal.{u}\nthis : \u2200 {a : Cardinal.{u}}, \u2135\u2080 \u2264 a \u2192 a \u2260 0\n\u22a2 b \u2260 0 \u2227 \u2135\u2080 \u2264 a \u2228 a \u2260 0 \u2227 \u2135\u2080 \u2264 b \u2194 a \u2260 0 \u2227 \u2135\u2080 \u2264 b \u2228 \u2135\u2080 \u2264 a \u2227 b \u2260 0"}, {"tactic": "simp only [and_comm, or_comm]", "annotated_tactic": ["simp only [<a>and_comm</a>, <a>or_comm</a>]", [{"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}, {"full_name": "or_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [818, 9], "def_end_pos": [818, 16]}]], "state_before": "\u03b1 \u03b2 : Type u\na b : Cardinal.{u}\nthis : \u2200 {a : Cardinal.{u}}, \u2135\u2080 \u2264 a \u2192 a \u2260 0\n\u22a2 b \u2260 0 \u2227 \u2135\u2080 \u2264 a \u2228 a \u2260 0 \u2227 \u2135\u2080 \u2264 b \u2194 a \u2260 0 \u2227 \u2135\u2080 \u2264 b \u2228 \u2135\u2080 \u2264 a \u2227 b \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "inv_mem_connectedComponent_one", "start": [774, 1], "end": [780, 46], "traced_tactics": [{"tactic": "rw [\u2190 inv_one]", "annotated_tactic": ["rw [\u2190 <a>inv_one</a>]", [{"full_name": "inv_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1035, 9], "def_end_pos": [1035, 16]}]], "state_before": "G\u271d : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2076 : TopologicalSpace G\u271d\ninst\u271d\u2075 : Group G\u271d\ninst\u271d\u2074 : TopologicalGroup G\u271d\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nf : \u03b1 \u2192 G\u271d\ns : Set \u03b1\nx : \u03b1\nG : Type u_1\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\ng : G\nhg : g \u2208 connectedComponent 1\n\u22a2 g\u207b\u00b9 \u2208 connectedComponent 1", "state_after": "G\u271d : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2076 : TopologicalSpace G\u271d\ninst\u271d\u2075 : Group G\u271d\ninst\u271d\u2074 : TopologicalGroup G\u271d\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nf : \u03b1 \u2192 G\u271d\ns : Set \u03b1\nx : \u03b1\nG : Type u_1\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\ng : G\nhg : g \u2208 connectedComponent 1\n\u22a2 g\u207b\u00b9 \u2208 connectedComponent 1\u207b\u00b9"}, {"tactic": "exact\n  Continuous.image_connectedComponent_subset continuous_inv _\n    ((Set.mem_image _ _ _).mp \u27e8g, hg, rfl\u27e9)", "annotated_tactic": ["exact\n    <a>Continuous.image_connectedComponent_subset</a> <a>continuous_inv</a> _\n      ((<a>Set.mem_image</a> _ _ _).<a>mp</a> \u27e8g, hg, <a>rfl</a>\u27e9)", [{"full_name": "Continuous.image_connectedComponent_subset", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/Basic.lean", "def_pos": [704, 9], "def_end_pos": [704, 51]}, {"full_name": "ContinuousInv.continuous_inv", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [185, 3], "def_end_pos": [185, 17]}, {"full_name": "Set.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [127, 9], "def_end_pos": [127, 18]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "G\u271d : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2076 : TopologicalSpace G\u271d\ninst\u271d\u2075 : Group G\u271d\ninst\u271d\u2074 : TopologicalGroup G\u271d\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nf : \u03b1 \u2192 G\u271d\ns : Set \u03b1\nx : \u03b1\nG : Type u_1\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\ng : G\nhg : g \u2208 connectedComponent 1\n\u22a2 g\u207b\u00b9 \u2208 connectedComponent 1\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/CharP/Two.lean", "full_name": "CharTwo.bit0_apply_eq_zero", "start": [43, 1], "end": [43, 65], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : CharP R 2\nx : R\n\u22a2 bit0 x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "exists_max_ideal_of_mem_nonunits", "start": [895, 1], "end": [905, 28], "traced_tactics": [{"tactic": "have : Ideal.span ({a} : Set \u03b1) \u2260 \u22a4 := by\n  intro H\n  rw [Ideal.span_singleton_eq_top] at H\n  contradiction", "annotated_tactic": ["have : <a>Ideal.span</a> ({a} : <a>Set</a> \u03b1) \u2260 \u22a4 := by\n    intro H\n    rw [<a>Ideal.span_singleton_eq_top</a>] at H\n    contradiction", [{"full_name": "Ideal.span", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [114, 5], "def_end_pos": [114, 9]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "Ideal.span_singleton_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [526, 9], "def_end_pos": [526, 30]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\n\u22a2 \u2203 I, Ideal.IsMaximal I \u2227 a \u2208 I", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\n\u22a2 \u2203 I, Ideal.IsMaximal I \u2227 a \u2208 I"}, {"tactic": "rcases Ideal.exists_le_maximal _ this with \u27e8I, Imax, H\u27e9", "annotated_tactic": ["rcases <a>Ideal.exists_le_maximal</a> _ this with \u27e8I, Imax, H\u27e9", [{"full_name": "Ideal.exists_le_maximal", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [337, 9], "def_end_pos": [337, 26]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\n\u22a2 \u2203 I, Ideal.IsMaximal I \u2227 a \u2208 I", "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\nI : Ideal \u03b1\nImax : Ideal.IsMaximal I\nH : Ideal.span {a} \u2264 I\n\u22a2 \u2203 I, Ideal.IsMaximal I \u2227 a \u2208 I"}, {"tactic": "use I, Imax", "annotated_tactic": ["use I, Imax", []], "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\nI : Ideal \u03b1\nImax : Ideal.IsMaximal I\nH : Ideal.span {a} \u2264 I\n\u22a2 \u2203 I, Ideal.IsMaximal I \u2227 a \u2208 I", "state_after": "case right\n\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\nI : Ideal \u03b1\nImax : Ideal.IsMaximal I\nH : Ideal.span {a} \u2264 I\n\u22a2 a \u2208 I"}, {"tactic": "apply H", "annotated_tactic": ["apply H", []], "state_before": "case right\n\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\nI : Ideal \u03b1\nImax : Ideal.IsMaximal I\nH : Ideal.span {a} \u2264 I\n\u22a2 a \u2208 I", "state_after": "case right.a\n\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\nI : Ideal \u03b1\nImax : Ideal.IsMaximal I\nH : Ideal.span {a} \u2264 I\n\u22a2 a \u2208 Ideal.span {a}"}, {"tactic": "apply Ideal.subset_span", "annotated_tactic": ["apply <a>Ideal.subset_span</a>", [{"full_name": "Ideal.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [145, 9], "def_end_pos": [145, 20]}]], "state_before": "case right.a\n\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\nI : Ideal \u03b1\nImax : Ideal.IsMaximal I\nH : Ideal.span {a} \u2264 I\n\u22a2 a \u2208 Ideal.span {a}", "state_after": "case right.a.a\n\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\nI : Ideal \u03b1\nImax : Ideal.IsMaximal I\nH : Ideal.span {a} \u2264 I\n\u22a2 a \u2208 {a}"}, {"tactic": "exact Set.mem_singleton a", "annotated_tactic": ["exact <a>Set.mem_singleton</a> a", [{"full_name": "Set.mem_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1259, 9], "def_end_pos": [1259, 22]}]], "state_before": "case right.a.a\n\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nthis : Ideal.span {a} \u2260 \u22a4\nI : Ideal \u03b1\nImax : Ideal.IsMaximal I\nH : Ideal.span {a} \u2264 I\n\u22a2 a \u2208 {a}", "state_after": "no goals"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\n\u22a2 Ideal.span {a} \u2260 \u22a4", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nH : Ideal.span {a} = \u22a4\n\u22a2 False"}, {"tactic": "rw [Ideal.span_singleton_eq_top] at H", "annotated_tactic": ["rw [<a>Ideal.span_singleton_eq_top</a>] at H", [{"full_name": "Ideal.span_singleton_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [526, 9], "def_end_pos": [526, 30]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nH : Ideal.span {a} = \u22a4\n\u22a2 False", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nH : IsUnit a\n\u22a2 False"}, {"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nh : a \u2208 nonunits \u03b1\nH : IsUnit a\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Basic.lean", "full_name": "Complex.restrictScalars_one_smulRight'", "start": [309, 1], "end": [313, 52], "traced_tactics": [{"tactic": "ext \u27e8a, b\u27e9", "annotated_tactic": ["ext \u27e8a, b\u27e9", []], "state_before": "z : \u2102\nE : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nx : E\n\u22a2 restrictScalars \u211d (smulRight 1 x) = smulRight reCLM x + I \u2022 smulRight imCLM x", "state_after": "case h.mk\nz : \u2102\nE : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nx : E\na b : \u211d\n\u22a2 (restrictScalars \u211d (smulRight 1 x)) { re := a, im := b } =\n    (smulRight reCLM x + I \u2022 smulRight imCLM x) { re := a, im := b }"}, {"tactic": "simp [mk_eq_add_mul_I, mul_smul, smul_comm I b x]", "annotated_tactic": ["simp [<a>mk_eq_add_mul_I</a>, <a>mul_smul</a>, <a>smul_comm</a> <a>I</a> b x]", [{"full_name": "Complex.mk_eq_add_mul_I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [331, 9], "def_end_pos": [331, 24]}, {"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}, {"full_name": "SMulCommClass.smul_comm", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [187, 3], "def_end_pos": [187, 12]}, {"full_name": "Complex.I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [299, 5], "def_end_pos": [299, 6]}]], "state_before": "case h.mk\nz : \u2102\nE : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nx : E\na b : \u211d\n\u22a2 (restrictScalars \u211d (smulRight 1 x)) { re := a, im := b } =\n    (smulRight reCLM x + I \u2022 smulRight imCLM x) { re := a, im := b }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.mem_domain_iff_of_eq_graph", "start": [918, 1], "end": [919, 66], "traced_tactics": [{"tactic": "simp_rw [mem_domain_iff, h]", "annotated_tactic": ["simp_rw [<a>mem_domain_iff</a>, h]", [{"full_name": "LinearPMap.mem_domain_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearPMap.lean", "def_pos": [873, 9], "def_end_pos": [873, 23]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny : M\nf g : E \u2192\u2097.[R] F\nh : graph f = graph g\nx : E\n\u22a2 x \u2208 f.domain \u2194 x \u2208 g.domain", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/IsometricSMul.lean", "full_name": "Metric.preimage_mul_left_ball", "start": [478, 1], "end": [480, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Basic.lean", "full_name": "Convex.smul", "start": [459, 1], "end": [460, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "DoubleQuot.liftSupQuotQuotMk\u2090_toRingHom", "start": [876, 1], "end": [878, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/GetD.lean", "full_name": "List.getD_eq_getD_get?", "start": [113, 1], "end": [116, 78], "traced_tactics": [{"tactic": "cases lt_or_le n l.length with\n| inl h => rw [getD_eq_get _ _ h, get?_eq_get h, Option.getD_some]\n| inr h => rw [getD_eq_default _ _ h, get?_eq_none.mpr h, Option.getD_none]", "annotated_tactic": ["cases <a>lt_or_le</a> n l.length with\n  | <a>inl</a> h => rw [<a>getD_eq_get</a> _ _ h, <a>get?_eq_get</a> h, <a>Option.getD_some</a>]\n  | <a>inr</a> h => rw [<a>getD_eq_default</a> _ _ h, get?_eq_none.mpr h, <a>Option.getD_none</a>]", [{"full_name": "lt_or_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [330, 9], "def_end_pos": [330, 17]}, {"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "List.getD_eq_get", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/GetD.lean", "def_pos": [45, 9], "def_end_pos": [45, 20]}, {"full_name": "List.get?_eq_get", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [195, 9], "def_end_pos": [195, 20]}, {"full_name": "Option.getD_some", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [88, 17], "def_end_pos": [88, 26]}, {"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "List.getD_eq_default", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/GetD.lean", "def_pos": [68, 9], "def_end_pos": [68, 24]}, {"full_name": "Option.getD_none", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [87, 17], "def_end_pos": [87, 26]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd : \u03b1\nn : \u2115\n\u22a2 getD l n d = Option.getD (get? l n) d", "state_after": "no goals"}, {"tactic": "rw [getD_eq_get _ _ h, get?_eq_get h, Option.getD_some]", "annotated_tactic": ["rw [<a>getD_eq_get</a> _ _ h, <a>get?_eq_get</a> h, <a>Option.getD_some</a>]", [{"full_name": "List.getD_eq_get", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/GetD.lean", "def_pos": [45, 9], "def_end_pos": [45, 20]}, {"full_name": "List.get?_eq_get", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [195, 9], "def_end_pos": [195, 20]}, {"full_name": "Option.getD_some", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [88, 17], "def_end_pos": [88, 26]}]], "state_before": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd : \u03b1\nn : \u2115\nh : n < length l\n\u22a2 getD l n d = Option.getD (get? l n) d", "state_after": "no goals"}, {"tactic": "rw [getD_eq_default _ _ h, get?_eq_none.mpr h, Option.getD_none]", "annotated_tactic": ["rw [<a>getD_eq_default</a> _ _ h, get?_eq_none.mpr h, <a>Option.getD_none</a>]", [{"full_name": "List.getD_eq_default", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/GetD.lean", "def_pos": [68, 9], "def_end_pos": [68, 24]}, {"full_name": "Option.getD_none", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [87, 17], "def_end_pos": [87, 26]}]], "state_before": "case inr\n\u03b1 : Type u\n\u03b2 : Type v\nl : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\n\u22a2 getD l n d = Option.getD (get? l n) d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.prod_eq_of_fintype", "start": [1116, 1], "end": [1129, 24], "traced_tactics": [{"tactic": "revert f", "annotated_tactic": ["revert f", []], "state_before": "\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\nf : \u03b1 \u2192 Cardinal.{v}\n\u22a2 prod f = lift.{u, v} (\u220f i : \u03b1, f i)", "state_after": "\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\n\u22a2 \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)"}, {"tactic": "refine' Fintype.induction_empty_option _ _ _ \u03b1 (h_fintype := h)", "annotated_tactic": ["refine' <a>Fintype.induction_empty_option</a> _ _ _ \u03b1 (h_fintype := h)", [{"full_name": "Fintype.induction_empty_option", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Option.lean", "def_pos": [92, 9], "def_end_pos": [92, 31]}]], "state_before": "\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\n\u22a2 \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)", "state_after": "case refine'_1\n\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\n\u22a2 \u2200 (\u03b1 \u03b2 : Type u) [inst : Fintype \u03b2] (e : \u03b1 \u2243 \u03b2),\n    (\u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)) \u2192\n      \u2200 (f : \u03b2 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b2, f i)\n\ncase refine'_2\n\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\n\u22a2 \u2200 (f : PEmpty.{u + 1} \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : PEmpty.{u + 1}, f i)\n\ncase refine'_3\n\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\n\u22a2 \u2200 (\u03b1 : Type u) [inst : Fintype \u03b1],\n    (\u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)) \u2192\n      \u2200 (f : Option \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : Option \u03b1, f i)"}, {"tactic": "intro \u03b1 \u03b2 h\u03b2 e h f", "annotated_tactic": ["intro \u03b1 \u03b2 h\u03b2 e h f", []], "state_before": "case refine'_1\n\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\n\u22a2 \u2200 (\u03b1 \u03b2 : Type u) [inst : Fintype \u03b2] (e : \u03b1 \u2243 \u03b2),\n    (\u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)) \u2192\n      \u2200 (f : \u03b2 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b2, f i)", "state_after": "case refine'_1\n\u03b1\u271d\u00b9 \u03b2\u271d \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 \u03b2 : Type u\nh\u03b2 : Fintype \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : \u03b2 \u2192 Cardinal.{v}\n\u22a2 prod f = lift.{u, v} (\u220f i : \u03b2, f i)"}, {"tactic": "letI := Fintype.ofEquiv \u03b2 e.symm", "annotated_tactic": ["letI := <a>Fintype.ofEquiv</a> \u03b2 e.symm", [{"full_name": "Fintype.ofEquiv", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [607, 5], "def_end_pos": [607, 12]}]], "state_before": "case refine'_1\n\u03b1\u271d\u00b9 \u03b2\u271d \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 \u03b2 : Type u\nh\u03b2 : Fintype \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : \u03b2 \u2192 Cardinal.{v}\n\u22a2 prod f = lift.{u, v} (\u220f i : \u03b2, f i)", "state_after": "case refine'_1\n\u03b1\u271d\u00b9 \u03b2\u271d \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 \u03b2 : Type u\nh\u03b2 : Fintype \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : \u03b2 \u2192 Cardinal.{v}\nthis : Fintype \u03b1 := Fintype.ofEquiv \u03b2 e.symm\n\u22a2 prod f = lift.{u, v} (\u220f i : \u03b2, f i)"}, {"tactic": "rw [\u2190 e.prod_comp f, \u2190 h]", "annotated_tactic": ["rw [\u2190 e.prod_comp f, \u2190 h]", []], "state_before": "case refine'_1\n\u03b1\u271d\u00b9 \u03b2\u271d \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 \u03b2 : Type u\nh\u03b2 : Fintype \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : \u03b2 \u2192 Cardinal.{v}\nthis : Fintype \u03b1 := Fintype.ofEquiv \u03b2 e.symm\n\u22a2 prod f = lift.{u, v} (\u220f i : \u03b2, f i)", "state_after": "case refine'_1\n\u03b1\u271d\u00b9 \u03b2\u271d \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 \u03b2 : Type u\nh\u03b2 : Fintype \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : \u03b2 \u2192 Cardinal.{v}\nthis : Fintype \u03b1 := Fintype.ofEquiv \u03b2 e.symm\n\u22a2 prod f = prod fun i => f (e i)"}, {"tactic": "exact mk_congr (e.piCongrLeft _).symm", "annotated_tactic": ["exact <a>mk_congr</a> (e.piCongrLeft _).<a>symm</a>", [{"full_name": "Cardinal.mk_congr", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}, {"full_name": "Equiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [166, 15], "def_end_pos": [166, 19]}]], "state_before": "case refine'_1\n\u03b1\u271d\u00b9 \u03b2\u271d \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 \u03b2 : Type u\nh\u03b2 : Fintype \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : \u03b2 \u2192 Cardinal.{v}\nthis : Fintype \u03b1 := Fintype.ofEquiv \u03b2 e.symm\n\u22a2 prod f = prod fun i => f (e i)", "state_after": "no goals"}, {"tactic": "intro f", "annotated_tactic": ["intro f", []], "state_before": "case refine'_2\n\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\n\u22a2 \u2200 (f : PEmpty.{u + 1} \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : PEmpty.{u + 1}, f i)", "state_after": "case refine'_2\n\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\nf : PEmpty.{u + 1} \u2192 Cardinal.{v}\n\u22a2 prod f = lift.{u, v} (\u220f i : PEmpty.{u + 1}, f i)"}, {"tactic": "rw [Fintype.univ_pempty, Finset.prod_empty, lift_one, Cardinal.prod, mk_eq_one]", "annotated_tactic": ["rw [<a>Fintype.univ_pempty</a>, <a>Finset.prod_empty</a>, <a>lift_one</a>, <a>Cardinal.prod</a>, <a>mk_eq_one</a>]", [{"full_name": "Fintype.univ_pempty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [920, 9], "def_end_pos": [920, 28]}, {"full_name": "Finset.prod_empty", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [294, 9], "def_end_pos": [294, 19]}, {"full_name": "Cardinal.lift_one", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [603, 9], "def_end_pos": [603, 17]}, {"full_name": "Cardinal.prod", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1074, 5], "def_end_pos": [1074, 9]}, {"full_name": "Cardinal.mk_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [418, 9], "def_end_pos": [418, 18]}]], "state_before": "case refine'_2\n\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\nf : PEmpty.{u + 1} \u2192 Cardinal.{v}\n\u22a2 prod f = lift.{u, v} (\u220f i : PEmpty.{u + 1}, f i)", "state_after": "no goals"}, {"tactic": "intro \u03b1 h\u03b1 h f", "annotated_tactic": ["intro \u03b1 h\u03b1 h f", []], "state_before": "case refine'_3\n\u03b1\u271d \u03b2 \u03b1 : Type u\nh : Fintype \u03b1\n\u22a2 \u2200 (\u03b1 : Type u) [inst : Fintype \u03b1],\n    (\u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)) \u2192\n      \u2200 (f : Option \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : Option \u03b1, f i)", "state_after": "case refine'_3\n\u03b1\u271d\u00b9 \u03b2 \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 : Type u\nh\u03b1 : Fintype \u03b1\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : Option \u03b1 \u2192 Cardinal.{v}\n\u22a2 prod f = lift.{u, v} (\u220f i : Option \u03b1, f i)"}, {"tactic": "rw [Cardinal.prod, mk_congr Equiv.piOptionEquivProd, mk_prod, lift_umax'.{v, u}, mk_out, \u2190\n    Cardinal.prod, lift_prod, Fintype.prod_option, lift_mul, \u2190 h fun a => f (some a)]", "annotated_tactic": ["rw [<a>Cardinal.prod</a>, <a>mk_congr</a> <a>Equiv.piOptionEquivProd</a>, <a>mk_prod</a>, <a>lift_umax'</a>.{v, u}, <a>mk_out</a>, \u2190\n        <a>Cardinal.prod</a>, <a>lift_prod</a>, <a>Fintype.prod_option</a>, <a>lift_mul</a>, \u2190 h fun a => f (<a>some</a> a)]", [{"full_name": "Cardinal.prod", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1074, 5], "def_end_pos": [1074, 9]}, {"full_name": "Cardinal.mk_congr", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}, {"full_name": "Equiv.piOptionEquivProd", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [518, 5], "def_end_pos": [518, 22]}, {"full_name": "Cardinal.mk_prod", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [477, 9], "def_end_pos": [477, 16]}, {"full_name": "Cardinal.lift_umax'", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [210, 9], "def_end_pos": [210, 19]}, {"full_name": "Cardinal.mk_out", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [153, 9], "def_end_pos": [153, 15]}, {"full_name": "Cardinal.prod", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1074, 5], "def_end_pos": [1074, 9]}, {"full_name": "Cardinal.lift_prod", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1109, 9], "def_end_pos": [1109, 18]}, {"full_name": "Fintype.prod_option", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/BigOperators.lean", "def_pos": [112, 9], "def_end_pos": [112, 28]}, {"full_name": "Cardinal.lift_mul", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [617, 9], "def_end_pos": [617, 17]}, {"full_name": "Option.some", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2226, 5], "def_end_pos": [2226, 9]}]], "state_before": "case refine'_3\n\u03b1\u271d\u00b9 \u03b2 \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 : Type u\nh\u03b1 : Fintype \u03b1\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : Option \u03b1 \u2192 Cardinal.{v}\n\u22a2 prod f = lift.{u, v} (\u220f i : Option \u03b1, f i)", "state_after": "case refine'_3\n\u03b1\u271d\u00b9 \u03b2 \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 : Type u\nh\u03b1 : Fintype \u03b1\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : Option \u03b1 \u2192 Cardinal.{v}\n\u22a2 (lift.{u, v} (f none) * prod fun i => lift.{v, v} (f (some i))) = lift.{u, v} (f none) * prod fun a => f (some a)"}, {"tactic": "simp only [lift_id]", "annotated_tactic": ["simp only [<a>lift_id</a>]", [{"full_name": "Cardinal.lift_id", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [224, 9], "def_end_pos": [224, 16]}]], "state_before": "case refine'_3\n\u03b1\u271d\u00b9 \u03b2 \u03b1\u271d : Type u\nh\u271d : Fintype \u03b1\u271d\n\u03b1 : Type u\nh\u03b1 : Fintype \u03b1\nh : \u2200 (f : \u03b1 \u2192 Cardinal.{v}), prod f = lift.{u, v} (\u220f i : \u03b1, f i)\nf : Option \u03b1 \u2192 Cardinal.{v}\n\u22a2 (lift.{u, v} (f none) * prod fun i => lift.{v, v} (f (some i))) = lift.{u, v} (f none) * prod fun a => f (some a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Icc_diff_Ioc_same", "start": [837, 1], "end": [838, 91], "traced_tactics": [{"tactic": "rw [\u2190 Icc_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 <| left_mem_Icc.2 h)]", "annotated_tactic": ["rw [\u2190 <a>Icc_diff_left</a>, <a>diff_diff_cancel_left</a> (<a>singleton_subset_iff</a>.2 <| <a>left_mem_Icc</a>.2 h)]", [{"full_name": "Set.Icc_diff_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [787, 9], "def_end_pos": [787, 22]}, {"full_name": "Set.diff_diff_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2067, 9], "def_end_pos": [2067, 30]}, {"full_name": "Set.singleton_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1300, 9], "def_end_pos": [1300, 29]}, {"full_name": "Set.left_mem_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [191, 9], "def_end_pos": [191, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na b c : \u03b1\nh : a \u2264 b\n\u22a2 Icc a b \\ Ioc a b = {a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Operations.lean", "full_name": "ENNReal.add_lt_top", "start": [190, 9], "end": [190, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.countable_biInf_eq_iInf_seq", "start": [1056, 1], "end": [1059, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.eval_one", "start": [396, 1], "end": [397, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Field/Basic.lean", "full_name": "neg_div", "start": [113, 1], "end": [114, 63], "traced_tactics": [{"tactic": "rw [neg_eq_neg_one_mul, mul_div_assoc, \u2190 neg_eq_neg_one_mul]", "annotated_tactic": ["rw [<a>neg_eq_neg_one_mul</a>, <a>mul_div_assoc</a>, \u2190 <a>neg_eq_neg_one_mul</a>]", [{"full_name": "neg_eq_neg_one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [335, 9], "def_end_pos": [335, 27]}, {"full_name": "mul_div_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [374, 9], "def_end_pos": [374, 22]}, {"full_name": "neg_eq_neg_one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [335, 9], "def_end_pos": [335, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nK : Type u_3\ninst\u271d\u00b9 : DivisionMonoid K\ninst\u271d : HasDistribNeg K\na\u271d b\u271d a b : K\n\u22a2 -b / a = -(b / a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.natDegree_monomial_eq", "start": [341, 1], "end": [343, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Subsingleton.lean", "full_name": "Filter.Subsingleton.of_subsingleton", "start": [32, 1], "end": [33, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Basic.lean", "full_name": "Equiv.mulRight_one", "start": [646, 1], "end": [647, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.comapDomain_apply", "start": [702, 1], "end": [704, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Defs.lean", "full_name": "Nat.sub_one_add_self", "start": [204, 1], "end": [204, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Pi/Basic.lean", "full_name": "Pi.pow_apply", "start": [123, 1], "end": [124, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean", "full_name": "natDegree_minpolyDiv_lt", "start": [105, 1], "end": [108, 27], "traced_tactics": [{"tactic": "rw [\u2190 natDegree_minpolyDiv_succ hx]", "annotated_tactic": ["rw [\u2190 <a>natDegree_minpolyDiv_succ</a> hx]", [{"full_name": "natDegree_minpolyDiv_succ", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean", "def_pos": [92, 7], "def_end_pos": [92, 32]}]], "state_before": "R : Type u_2\nK : Type ?u.71131\nL : Type ?u.71134\nS : Type u_1\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : Algebra K L\nx : S\nhx : IsIntegral R x\ninst\u271d : Nontrivial S\n\u22a2 natDegree (minpolyDiv R x) < natDegree (minpoly R x)", "state_after": "R : Type u_2\nK : Type ?u.71131\nL : Type ?u.71134\nS : Type u_1\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : Algebra K L\nx : S\nhx : IsIntegral R x\ninst\u271d : Nontrivial S\n\u22a2 natDegree (minpolyDiv R x) < natDegree (minpolyDiv R x) + 1"}, {"tactic": "exact Nat.lt_succ_self _", "annotated_tactic": ["exact <a>Nat.lt_succ_self</a> _", [{"full_name": "Nat.lt_succ_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 21]}]], "state_before": "R : Type u_2\nK : Type ?u.71131\nL : Type ?u.71134\nS : Type u_1\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : Algebra K L\nx : S\nhx : IsIntegral R x\ninst\u271d : Nontrivial S\n\u22a2 natDegree (minpolyDiv R x) < natDegree (minpolyDiv R x) + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Pointwise.lean", "full_name": "Real.mul_iSup_of_nonpos", "start": [128, 1], "end": [129, 32], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Test.lean", "full_name": "amc12a_2013_p4", "start": [487, 1], "end": [488, 64], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "\u22a2 (2 ^ 2014 + 2 ^ 2012) / (2 ^ 2014 - 2 ^ 2012) = 5 / 3", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Power.lean", "full_name": "zpow_neg_two_nonneg", "start": [141, 1], "end": [142, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteBooleanAlgebra.lean", "full_name": "sSup_disjoint_iff", "start": [259, 1], "end": [260, 53], "traced_tactics": [{"tactic": "simp only [disjoint_iff, sSup_inf_eq, iSup_eq_bot]", "annotated_tactic": ["simp only [<a>disjoint_iff</a>, <a>sSup_inf_eq</a>, <a>iSup_eq_bot</a>]", [{"full_name": "disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "sSup_inf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteBooleanAlgebra.lean", "def_pos": [199, 9], "def_end_pos": [199, 20]}, {"full_name": "iSup_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1012, 9], "def_end_pos": [1012, 20]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03ba : \u03b9 \u2192 Sort w'\ninst\u271d : Frame \u03b1\ns\u271d t : Set \u03b1\na b : \u03b1\ns : Set \u03b1\n\u22a2 Disjoint (sSup s) a \u2194 \u2200 b \u2208 s, Disjoint b a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finsupp.lean", "full_name": "Finsupp.prod_fintype", "start": [64, 1], "end": [66, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "full_name": "NonUnitalRingHom.coe_srangeRestrict", "start": [907, 1], "end": [908, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "Exists.fst", "start": [862, 1], "end": [863, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.inter_union_diff", "start": [1856, 1], "end": [1857, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean", "full_name": "MeasureTheory.Measure.restrict_iUnion_ae", "start": [529, 1], "end": [531, 83], "traced_tactics": [{"tactic": "simp only [sum_apply _ ht, restrict_iUnion_apply_ae hd hm ht]", "annotated_tactic": ["simp only [<a>sum_apply</a> _ ht, <a>restrict_iUnion_apply_ae</a> hd hm ht]", [{"full_name": "MeasureTheory.Measure.sum_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "def_pos": [1432, 9], "def_end_pos": [1432, 18]}, {"full_name": "MeasureTheory.Measure.restrict_iUnion_apply_ae", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [305, 9], "def_end_pos": [305, 33]}]], "state_before": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t\u271d : Set \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\nhd : Pairwise (AEDisjoint \u03bc on s)\nhm : \u2200 (i : \u03b9), NullMeasurableSet (s i) \u03bc\nt : Set \u03b1\nht : MeasurableSet t\n\u22a2 \u2191\u2191(restrict \u03bc (\u22c3 i, s i)) t = \u2191\u2191(sum fun i => restrict \u03bc (s i)) t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.card_of_finset'", "start": [137, 1], "end": [138, 91], "traced_tactics": [{"tactic": "rw [\u2190 card_ofFinset s H]", "annotated_tactic": ["rw [\u2190 <a>card_ofFinset</a> s H]", [{"full_name": "Fintype.card_ofFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [132, 9], "def_end_pos": [132, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 card \u2191p = s.card", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 card \u2191p = card \u2191p"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 card \u2191p = card \u2191p", "state_after": "case h.e_2.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 inst\u271d = ofFinset s H"}, {"tactic": "apply Subsingleton.elim", "annotated_tactic": ["apply <a>Subsingleton.elim</a>", [{"full_name": "Subsingleton.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1010, 19], "def_end_pos": [1010, 36]}]], "state_before": "case h.e_2.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 inst\u271d = ofFinset s H", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Thickening.lean", "full_name": "Metric.diam_thickening_le", "start": [393, 1], "end": [401, 15], "traced_tactics": [{"tactic": "by_cases hs : IsBounded s", "annotated_tactic": ["by_cases hs : <a>IsBounded</a> s", [{"full_name": "Bornology.IsBounded", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bornology/Basic.lean", "def_pos": [128, 5], "def_end_pos": [128, 14]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4 \u03b5 : \u211d\ns\u271d t : Set \u03b1\u271d\nx : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nh\u03b5 : 0 \u2264 \u03b5\n\u22a2 diam (thickening \u03b5 s) \u2264 diam s + 2 * \u03b5", "state_after": "case pos\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4 \u03b5 : \u211d\ns\u271d t : Set \u03b1\u271d\nx : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nh\u03b5 : 0 \u2264 \u03b5\nhs : Bornology.IsBounded s\n\u22a2 diam (thickening \u03b5 s) \u2264 diam s + 2 * \u03b5\n\ncase neg\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4 \u03b5 : \u211d\ns\u271d t : Set \u03b1\u271d\nx : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nh\u03b5 : 0 \u2264 \u03b5\nhs : \u00acBornology.IsBounded s\n\u22a2 diam (thickening \u03b5 s) \u2264 diam s + 2 * \u03b5"}, {"tactic": "obtain rfl | h\u03b5 := h\u03b5.eq_or_lt", "annotated_tactic": ["obtain rfl | h\u03b5 := h\u03b5.eq_or_lt", []], "state_before": "case neg\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4 \u03b5 : \u211d\ns\u271d t : Set \u03b1\u271d\nx : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nh\u03b5 : 0 \u2264 \u03b5\nhs : \u00acBornology.IsBounded s\n\u22a2 diam (thickening \u03b5 s) \u2264 diam s + 2 * \u03b5", "state_after": "case neg.inl\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4 : \u211d\ns\u271d t : Set \u03b1\u271d\nx : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nhs : \u00acBornology.IsBounded s\nh\u03b5 : 0 \u2264 0\n\u22a2 diam (thickening 0 s) \u2264 diam s + 2 * 0\n\ncase neg.inr\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4 \u03b5 : \u211d\ns\u271d t : Set \u03b1\u271d\nx : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nh\u03b5\u271d : 0 \u2264 \u03b5\nhs : \u00acBornology.IsBounded s\nh\u03b5 : 0 < \u03b5\n\u22a2 diam (thickening \u03b5 s) \u2264 diam s + 2 * \u03b5"}, {"tactic": "exact (diam_mono (thickening_subset_cthickening _ _) hs.cthickening).trans\n  (diam_cthickening_le _ h\u03b5)", "annotated_tactic": ["exact (<a>diam_mono</a> (<a>thickening_subset_cthickening</a> _ _) hs.cthickening).<a>trans</a>\n      (<a>diam_cthickening_le</a> _ h\u03b5)", [{"full_name": "Metric.diam_mono", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Bounded.lean", "def_pos": [492, 9], "def_end_pos": [492, 18]}, {"full_name": "Metric.thickening_subset_cthickening", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [281, 9], "def_end_pos": [281, 38]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "Metric.diam_cthickening_le", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [384, 9], "def_end_pos": [384, 28]}]], "state_before": "case pos\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4 \u03b5 : \u211d\ns\u271d t : Set \u03b1\u271d\nx : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nh\u03b5 : 0 \u2264 \u03b5\nhs : Bornology.IsBounded s\n\u22a2 diam (thickening \u03b5 s) \u2264 diam s + 2 * \u03b5", "state_after": "no goals"}, {"tactic": "simp [thickening_of_nonpos, diam_nonneg]", "annotated_tactic": ["simp [<a>thickening_of_nonpos</a>, <a>diam_nonneg</a>]", [{"full_name": "Metric.thickening_of_nonpos", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [85, 9], "def_end_pos": [85, 29]}, {"full_name": "Metric.diam_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Bounded.lean", "def_pos": [377, 9], "def_end_pos": [377, 20]}]], "state_before": "case neg.inl\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4 : \u211d\ns\u271d t : Set \u03b1\u271d\nx : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nhs : \u00acBornology.IsBounded s\nh\u03b5 : 0 \u2264 0\n\u22a2 diam (thickening 0 s) \u2264 diam s + 2 * 0", "state_after": "no goals"}, {"tactic": "positivity", "annotated_tactic": ["positivity", []], "state_before": "case neg.inr\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4 \u03b5 : \u211d\ns\u271d t : Set \u03b1\u271d\nx : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nh\u03b5\u271d : 0 \u2264 \u03b5\nhs : \u00acBornology.IsBounded s\nh\u03b5 : 0 < \u03b5\n\u22a2 0 \u2264 diam s + 2 * \u03b5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.not_le", "start": [349, 11], "end": [349, 99], "traced_tactics": [{"tactic": "simp_rw [le_def, not_forall, exists_prop]", "annotated_tactic": ["simp_rw [<a>le_def</a>, <a>not_forall</a>, <a>exists_prop</a>]", [{"full_name": "Filter.le_def", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [345, 9], "def_end_pos": [345, 15]}, {"full_name": "Classical.not_forall", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [130, 17], "def_end_pos": [130, 27]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf g : Filter \u03b1\ns t : Set \u03b1\n\u22a2 \u00acf \u2264 g \u2194 \u2203 s \u2208 g, s \u2209 f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "full_name": "Submodule.toNonUnitalSubalgebra_toSubmodule", "start": [410, 1], "end": [412, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "full_name": "AEMeasurable.mono_ac", "start": [56, 1], "end": [57, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Sets/Opens.lean", "full_name": "TopologicalSpace.Opens.coe_top", "start": [195, 1], "end": [196, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "full_name": "Equiv.Perm.sum_cycleType", "start": [147, 1], "end": [151, 97], "traced_tactics": [{"tactic": "induction \u03c3 using cycle_induction_on with\n| base_one => simp\n| base_cycles \u03c3 h\u03c3 => rw [h\u03c3.cycleType, sum_coe, List.sum_singleton]\n| induction_disjoint \u03c3 \u03c4 hd _ h\u03c3 h\u03c4 => rw [hd.cycleType, sum_add, h\u03c3, h\u03c4, hd.card_support_mul]", "annotated_tactic": ["induction \u03c3 using <a>cycle_induction_on</a> with\n  | base_one => simp\n  | base_cycles \u03c3 h\u03c3 => rw [h\u03c3.cycleType, <a>sum_coe</a>, <a>List.sum_singleton</a>]\n  | induction_disjoint \u03c3 \u03c4 hd _ h\u03c3 h\u03c4 => rw [hd.cycleType, <a>sum_add</a>, h\u03c3, h\u03c4, hd.card_support_mul]", [{"full_name": "Equiv.Perm.cycle_induction_on", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "def_pos": [621, 9], "def_end_pos": [621, 27]}, {"full_name": "Multiset.sum_coe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [63, 3], "def_end_pos": [63, 14]}, {"full_name": "List.sum_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [36, 3], "def_end_pos": [36, 14]}, {"full_name": "Multiset.sum_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [114, 3], "def_end_pos": [114, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Perm \u03b1\n\u22a2 Multiset.sum (cycleType \u03c3) = (support \u03c3).card", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case base_one\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 Multiset.sum (cycleType 1) = (support 1).card", "state_after": "no goals"}, {"tactic": "rw [h\u03c3.cycleType, sum_coe, List.sum_singleton]", "annotated_tactic": ["rw [h\u03c3.cycleType, <a>sum_coe</a>, <a>List.sum_singleton</a>]", [{"full_name": "Multiset.sum_coe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [63, 3], "def_end_pos": [63, 14]}, {"full_name": "List.sum_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [36, 3], "def_end_pos": [36, 14]}]], "state_before": "case base_cycles\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Perm \u03b1\nh\u03c3 : IsCycle \u03c3\n\u22a2 Multiset.sum (cycleType \u03c3) = (support \u03c3).card", "state_after": "no goals"}, {"tactic": "rw [hd.cycleType, sum_add, h\u03c3, h\u03c4, hd.card_support_mul]", "annotated_tactic": ["rw [hd.cycleType, <a>sum_add</a>, h\u03c3, h\u03c4, hd.card_support_mul]", [{"full_name": "Multiset.sum_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [114, 3], "def_end_pos": [114, 14]}]], "state_before": "case induction_disjoint\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 \u03c4 : Perm \u03b1\nhd : Disjoint \u03c3 \u03c4\na\u271d : IsCycle \u03c3\nh\u03c3 : Multiset.sum (cycleType \u03c3) = (support \u03c3).card\nh\u03c4 : Multiset.sum (cycleType \u03c4) = (support \u03c4).card\n\u22a2 Multiset.sum (cycleType (\u03c3 * \u03c4)) = (support (\u03c3 * \u03c4)).card", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Pointwise.lean", "full_name": "SubMulAction.coe_one", "start": [36, 1], "end": [37, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.eq_zero_of_subset_zero", "start": [437, 1], "end": [438, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Support.lean", "full_name": "exists_compact_iff_hasCompactMulSupport", "start": [164, 1], "end": [167, 61], "traced_tactics": [{"tactic": "simp_rw [\u2190 nmem_mulSupport, \u2190 mem_compl_iff, \u2190 subset_def, compl_subset_compl,\n  hasCompactMulSupport_def, exists_isCompact_superset_iff]", "annotated_tactic": ["simp_rw [\u2190 <a>nmem_mulSupport</a>, \u2190 <a>mem_compl_iff</a>, \u2190 <a>subset_def</a>, <a>compl_subset_compl</a>,\n    <a>hasCompactMulSupport_def</a>, <a>exists_isCompact_superset_iff</a>]", [{"full_name": "Function.nmem_mulSupport", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Support.lean", "def_pos": [47, 9], "def_end_pos": [47, 24]}, {"full_name": "Set.mem_compl_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [87, 17], "def_end_pos": [87, 30]}, {"full_name": "Set.subset_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [326, 9], "def_end_pos": [326, 19]}, {"full_name": "Set.compl_subset_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1737, 9], "def_end_pos": [1737, 27]}, {"full_name": "hasCompactMulSupport_def", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Support.lean", "def_pos": [158, 9], "def_end_pos": [158, 33]}, {"full_name": "exists_isCompact_superset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [1020, 9], "def_end_pos": [1020, 38]}]], "state_before": "X : Type u_1\n\u03b1 : Type u_2\n\u03b1' : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\nM : Type u_7\nE : Type u_8\nR : Type u_9\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1'\ninst\u271d\u00b3 : One \u03b2\ninst\u271d\u00b2 : One \u03b3\ninst\u271d\u00b9 : One \u03b4\ng : \u03b2 \u2192 \u03b3\nf : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nm : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nx : \u03b1\ninst\u271d : R1Space \u03b1\n\u22a2 (\u2203 K, IsCompact K \u2227 \u2200 x \u2209 K, f x = 1) \u2194 HasCompactMulSupport f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "div_mul_eq_div_div_swap", "start": [534, 1], "end": [535, 56], "traced_tactics": [{"tactic": "simp only [mul_assoc, mul_inv_rev, div_eq_mul_inv]", "annotated_tactic": ["simp only [<a>mul_assoc</a>, <a>mul_inv_rev</a>, <a>div_eq_mul_inv</a>]", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_inv_rev", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1070, 9], "def_end_pos": [1070, 20]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivisionMonoid \u03b1\na b c d : \u03b1\n\u22a2 a / (b * c) = a / c / b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Basic.lean", "full_name": "Equiv.pow_addLeft", "start": [619, 1], "end": [620, 27], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : AddGroup \u03b1\na b : \u03b1\nn : \u2115\n\u22a2 Equiv.addLeft a ^ n = Equiv.addLeft (n \u2022 a)", "state_after": "case H\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : AddGroup \u03b1\na b : \u03b1\nn : \u2115\nx\u271d : \u03b1\n\u22a2 (Equiv.addLeft a ^ n) x\u271d = (Equiv.addLeft (n \u2022 a)) x\u271d"}, {"tactic": "simp [Perm.coe_pow]", "annotated_tactic": ["simp [<a>Perm.coe_pow</a>]", [{"full_name": "Equiv.Perm.coe_pow", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [103, 20], "def_end_pos": [103, 27]}]], "state_before": "case H\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : AddGroup \u03b1\na b : \u03b1\nn : \u2115\nx\u271d : \u03b1\n\u22a2 (Equiv.addLeft a ^ n) x\u271d = (Equiv.addLeft (n \u2022 a)) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Congruence.lean", "full_name": "RingCon.sup_def", "start": [551, 1], "end": [552, 30], "traced_tactics": [{"tactic": "rw [sup_eq_ringConGen]", "annotated_tactic": ["rw [<a>sup_eq_ringConGen</a>]", [{"full_name": "RingCon.sup_eq_ringConGen", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Congruence.lean", "def_pos": [544, 9], "def_end_pos": [544, 26]}]], "state_before": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\nc d : RingCon R\n\u22a2 c \u2294 d = ringConGen (\u21d1c \u2294 \u21d1d)", "state_after": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\nc d : RingCon R\n\u22a2 (ringConGen fun x y => c x y \u2228 d x y) = ringConGen (\u21d1c \u2294 \u21d1d)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\nc d : RingCon R\n\u22a2 (ringConGen fun x y => c x y \u2228 d x y) = ringConGen (\u21d1c \u2294 \u21d1d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "left_mem_affineSpan_pair", "start": [1315, 1], "end": [1316, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "full_name": "Real.Angle.two_zsmul_eq_pi_iff", "start": [236, 1], "end": [237, 51], "traced_tactics": [{"tactic": "rw [two_zsmul, \u2190 two_nsmul, two_nsmul_eq_pi_iff]", "annotated_tactic": ["rw [<a>two_zsmul</a>, \u2190 <a>two_nsmul</a>, <a>two_nsmul_eq_pi_iff</a>]", [{"full_name": "two_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [252, 15], "def_end_pos": [252, 24]}, {"full_name": "two_nsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [86, 15], "def_end_pos": [86, 24]}, {"full_name": "Real.Angle.two_nsmul_eq_pi_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "def_pos": [226, 9], "def_end_pos": [226, 28]}]], "state_before": "\u03b8 : Angle\n\u22a2 2 \u2022 \u03b8 = \u2191\u03c0 \u2194 \u03b8 = \u2191(\u03c0 / 2) \u2228 \u03b8 = \u2191(-\u03c0 / 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Relator.lean", "full_name": "Relator.RightTotal.refl", "start": [161, 1], "end": [163, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/CovariantClass.lean", "full_name": "Right.pow_lt_one_of_lt", "start": [208, 1], "end": [214, 29], "traced_tactics": [{"tactic": "rw [pow_succ]", "annotated_tactic": ["rw [<a>pow_succ</a>]", [{"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}]], "state_before": "\u03b2 : Type u_1\nG : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (swap fun x x_1 => x * x_1) fun x x_1 => x < x_1\nn\u271d : \u2115\nx : M\nhn : 0 < n\u271d\nh : x < 1\nn : \u2115\nx\u271d : Nat.succ 0 \u2264 n\nih : x ^ n < 1\n\u22a2 x ^ (n + 1) < 1", "state_after": "\u03b2 : Type u_1\nG : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (swap fun x x_1 => x * x_1) fun x x_1 => x < x_1\nn\u271d : \u2115\nx : M\nhn : 0 < n\u271d\nh : x < 1\nn : \u2115\nx\u271d : Nat.succ 0 \u2264 n\nih : x ^ n < 1\n\u22a2 x * x ^ n < 1"}, {"tactic": "exact Right.mul_lt_one h ih", "annotated_tactic": ["exact <a>Right.mul_lt_one</a> h ih", [{"full_name": "Right.mul_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [914, 9], "def_end_pos": [914, 25]}]], "state_before": "\u03b2 : Type u_1\nG : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (swap fun x x_1 => x * x_1) fun x x_1 => x < x_1\nn\u271d : \u2115\nx : M\nhn : 0 < n\u271d\nh : x < 1\nn : \u2115\nx\u271d : Nat.succ 0 \u2264 n\nih : x ^ n < 1\n\u22a2 x * x ^ n < 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.coe_sSup", "start": [613, 1], "end": [614, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "eq_mul_of_inv_mul_eq", "start": [715, 1], "end": [715, 100], "traced_tactics": [{"tactic": "simp [h.symm, mul_inv_cancel_left]", "annotated_tactic": ["simp [h.symm, <a>mul_inv_cancel_left</a>]", [{"full_name": "mul_inv_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1173, 9], "def_end_pos": [1173, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : Group G\na b c d : G\nn : \u2124\nh : b\u207b\u00b9 * a = c\n\u22a2 a = b * c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "full_name": "Seminorm.isBounded_sup", "start": [241, 1], "end": [256, 38], "traced_tactics": [{"tactic": "obtain rfl | _ := s'.eq_empty_or_nonempty", "annotated_tactic": ["obtain rfl | _ := s'.eq_empty_or_nonempty", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\nhf : IsBounded p q f\ns' : Finset \u03b9'\n\u22a2 \u2203 C s, comp (Finset.sup s' q) f \u2264 C \u2022 Finset.sup s p", "state_after": "case inl\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\nhf : IsBounded p q f\n\u22a2 \u2203 C s, comp (Finset.sup \u2205 q) f \u2264 C \u2022 Finset.sup s p\n\ncase inr\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\nhf : IsBounded p q f\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\n\u22a2 \u2203 C s, comp (Finset.sup s' q) f \u2264 C \u2022 Finset.sup s p"}, {"tactic": "choose f\u209b fC hf using hf", "annotated_tactic": ["choose f\u209b fC hf using hf", []], "state_before": "case inr\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\nhf : IsBounded p q f\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\n\u22a2 \u2203 C s, comp (Finset.sup s' q) f \u2264 C \u2022 Finset.sup s p", "state_after": "case inr\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\n\u22a2 \u2203 C s, comp (Finset.sup s' q) f \u2264 C \u2022 Finset.sup s p"}, {"tactic": "use s'.card \u2022 s'.sup fC, Finset.biUnion s' f\u209b", "annotated_tactic": ["use s'.card \u2022 s'.sup fC, <a>Finset.biUnion</a> s' f\u209b", [{"full_name": "Finset.biUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3725, 15], "def_end_pos": [3725, 22]}]], "state_before": "case inr\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\n\u22a2 \u2203 C s, comp (Finset.sup s' q) f \u2264 C \u2022 Finset.sup s p", "state_after": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\n\u22a2 comp (Finset.sup s' q) f \u2264 (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p"}, {"tactic": "have hs : \u2200 i : \u03b9', i \u2208 s' \u2192 (q i).comp f \u2264 s'.sup fC \u2022 (Finset.biUnion s' f\u209b).sup p := by\n  intro i hi\n  refine' (hf i).trans (smul_le_smul _ (Finset.le_sup hi))\n  exact Finset.sup_mono (Finset.subset_biUnion_of_mem f\u209b hi)", "annotated_tactic": ["have hs : \u2200 i : \u03b9', i \u2208 s' \u2192 (q i).<a>comp</a> f \u2264 s'.sup fC \u2022 (<a>Finset.biUnion</a> s' f\u209b).<a>sup</a> p := by\n      intro i hi\n      refine' (hf i).<a>trans</a> (<a>smul_le_smul</a> _ (<a>Finset.le_sup</a> hi))\n      exact <a>Finset.sup_mono</a> (<a>Finset.subset_biUnion_of_mem</a> f\u209b hi)", [{"full_name": "Seminorm.comp", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [299, 5], "def_end_pos": [299, 9]}, {"full_name": "Finset.biUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3725, 15], "def_end_pos": [3725, 22]}, {"full_name": "Finset.sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [35, 5], "def_end_pos": [35, 8]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "Seminorm.smul_le_smul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [376, 9], "def_end_pos": [376, 21]}, {"full_name": "Finset.le_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [111, 9], "def_end_pos": [111, 15]}, {"full_name": "Finset.sup_mono", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [149, 9], "def_end_pos": [149, 17]}, {"full_name": "Finset.subset_biUnion_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3820, 9], "def_end_pos": [3820, 30]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\n\u22a2 comp (Finset.sup s' q) f \u2264 (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p", "state_after": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\nhs : \u2200 i \u2208 s', comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p\n\u22a2 comp (Finset.sup s' q) f \u2264 (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p"}, {"tactic": "refine' (comp_mono f (finset_sup_le_sum q s')).trans _", "annotated_tactic": ["refine' (<a>comp_mono</a> f (<a>finset_sup_le_sum</a> q s')).<a>trans</a> _", [{"full_name": "Seminorm.comp_mono", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [351, 9], "def_end_pos": [351, 18]}, {"full_name": "Seminorm.finset_sup_le_sum", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [411, 9], "def_end_pos": [411, 26]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\nhs : \u2200 i \u2208 s', comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p\n\u22a2 comp (Finset.sup s' q) f \u2264 (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p", "state_after": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\nhs : \u2200 i \u2208 s', comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p\n\u22a2 comp (\u2211 i in s', q i) f \u2264 (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p"}, {"tactic": "simp_rw [\u2190 pullback_apply, map_sum, pullback_apply]", "annotated_tactic": ["simp_rw [\u2190 <a>pullback_apply</a>, <a>map_sum</a>, <a>pullback_apply</a>]", [{"full_name": "Seminorm.pullback_apply", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [356, 3], "def_end_pos": [356, 8]}, {"full_name": "map_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [208, 3], "def_end_pos": [208, 14]}, {"full_name": "Seminorm.pullback_apply", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [356, 3], "def_end_pos": [356, 8]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\nhs : \u2200 i \u2208 s', comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p\n\u22a2 comp (\u2211 i in s', q i) f \u2264 (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p", "state_after": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\nhs : \u2200 i \u2208 s', comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p\n\u22a2 \u2211 x in s', comp (q x) f \u2264 (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p"}, {"tactic": "refine' (Finset.sum_le_sum hs).trans _", "annotated_tactic": ["refine' (<a>Finset.sum_le_sum</a> hs).<a>trans</a> _", [{"full_name": "Finset.sum_le_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Order.lean", "def_pos": [110, 15], "def_end_pos": [110, 25]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\nhs : \u2200 i \u2208 s', comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p\n\u22a2 \u2211 x in s', comp (q x) f \u2264 (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p", "state_after": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\nhs : \u2200 i \u2208 s', comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p\n\u22a2 \u2211 i in s', Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p \u2264\n    (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p"}, {"tactic": "rw [Finset.sum_const, smul_assoc]", "annotated_tactic": ["rw [<a>Finset.sum_const</a>, <a>smul_assoc</a>]", [{"full_name": "Finset.sum_const", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1664, 3], "def_end_pos": [1664, 14]}, {"full_name": "smul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 19]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\nhs : \u2200 i \u2208 s', comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p\n\u22a2 \u2211 i in s', Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p \u2264\n    (s'.card \u2022 Finset.sup s' fC) \u2022 Finset.sup (Finset.biUnion s' f\u209b) p", "state_after": "no goals"}, {"tactic": "exact \u27e81, \u2205, by simp [Seminorm.bot_eq_zero]\u27e9", "annotated_tactic": ["exact \u27e81, \u2205, by simp [<a>Seminorm.bot_eq_zero</a>]\u27e9", [{"full_name": "Seminorm.bot_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [372, 9], "def_end_pos": [372, 20]}]], "state_before": "case inl\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\nhf : IsBounded p q f\n\u22a2 \u2203 C s, comp (Finset.sup \u2205 q) f \u2264 C \u2022 Finset.sup s p", "state_after": "no goals"}, {"tactic": "simp [Seminorm.bot_eq_zero]", "annotated_tactic": ["simp [<a>Seminorm.bot_eq_zero</a>]", [{"full_name": "Seminorm.bot_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [372, 9], "def_end_pos": [372, 20]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\nhf : IsBounded p q f\n\u22a2 comp (Finset.sup \u2205 q) f \u2264 1 \u2022 Finset.sup \u2205 p", "state_after": "no goals"}, {"tactic": "intro i hi", "annotated_tactic": ["intro i hi", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\n\u22a2 \u2200 i \u2208 s', comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\ni : \u03b9'\nhi : i \u2208 s'\n\u22a2 comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p"}, {"tactic": "refine' (hf i).trans (smul_le_smul _ (Finset.le_sup hi))", "annotated_tactic": ["refine' (hf i).<a>trans</a> (<a>smul_le_smul</a> _ (<a>Finset.le_sup</a> hi))", [{"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "Seminorm.smul_le_smul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [376, 9], "def_end_pos": [376, 21]}, {"full_name": "Finset.le_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [111, 9], "def_end_pos": [111, 15]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\ni : \u03b9'\nhi : i \u2208 s'\n\u22a2 comp (q i) f \u2264 Finset.sup s' fC \u2022 Finset.sup (Finset.biUnion s' f\u209b) p", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\ni : \u03b9'\nhi : i \u2208 s'\n\u22a2 Finset.sup (f\u209b i) p \u2264 Finset.sup (Finset.biUnion s' f\u209b) p"}, {"tactic": "exact Finset.sup_mono (Finset.subset_biUnion_of_mem f\u209b hi)", "annotated_tactic": ["exact <a>Finset.sup_mono</a> (<a>Finset.subset_biUnion_of_mem</a> f\u209b hi)", [{"full_name": "Finset.sup_mono", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [149, 9], "def_end_pos": [149, 17]}, {"full_name": "Finset.subset_biUnion_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3820, 9], "def_end_pos": [3820, 30]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2076 : NormedField \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : NormedField \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup F\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 F\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np : \u03b9 \u2192 Seminorm \ud835\udd5c E\nq : \u03b9' \u2192 Seminorm \ud835\udd5c\u2082 F\nf : E \u2192\u209b\u2097[\u03c3\u2081\u2082] F\ns' : Finset \u03b9'\nh\u271d : s'.Nonempty\nf\u209b : \u03b9' \u2192 Finset \u03b9\nfC : \u03b9' \u2192 \u211d\u22650\nhf : \u2200 (i : \u03b9'), comp (q i) f \u2264 fC i \u2022 Finset.sup (f\u209b i) p\ni : \u03b9'\nhi : i \u2208 s'\n\u22a2 Finset.sup (f\u209b i) p \u2264 Finset.sup (Finset.biUnion s' f\u209b) p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Category/Basic.lean", "full_name": "CategoryTheory.eq_of_comp_left_eq'", "start": [233, 1], "end": [235, 72], "traced_tactics": [{"tactic": "convert congr_fun (congr_fun w Z) h", "annotated_tactic": ["convert <a>congr_fun</a> (<a>congr_fun</a> w Z) h", [{"full_name": "congr_fun", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [74, 7], "def_end_pos": [74, 16]}, {"full_name": "congr_fun", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [74, 7], "def_end_pos": [74, 16]}]], "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z\u271d : C\nf g : X \u27f6 Y\nw : (fun {Z} h => f \u226b h) = fun {Z} h => g \u226b h\nZ : C\nh : Y \u27f6 Z\n\u22a2 f \u226b h = g \u226b h", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Int/Basic.lean", "full_name": "Int.gcd_eq_one_of_gcd_mul_right_eq_one_left", "start": [213, 1], "end": [215, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/WF.lean", "full_name": "Std.RBNode.cmpLT.trans", "start": [30, 1], "end": [31, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "exists_Icc_mem_subset_of_mem_nhdsWithin_Ici", "start": [424, 1], "end": [434, 49], "traced_tactics": [{"tactic": "rcases (em (IsMax a)).imp_right not_isMax_iff.mp with (ha | ha)", "annotated_tactic": ["rcases (<a>em</a> (<a>IsMax</a> a)).<a>imp_right</a> not_isMax_iff.mp with (ha | ha)", [{"full_name": "em", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [193, 7], "def_end_pos": [193, 9]}, {"full_name": "IsMax", "def_path": ".lake/packages/mathlib/Mathlib/Order/Max.lean", "def_pos": [209, 5], "def_end_pos": [209, 10]}, {"full_name": "Or.imp_right", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [161, 9], "def_end_pos": [161, 21]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s", "state_after": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : IsMax a\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s\n\ncase inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s"}, {"tactic": "use a", "annotated_tactic": ["use a", []], "state_before": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : IsMax a\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : IsMax a\n\u22a2 a \u2264 a \u2227 Icc a a \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a a \u2286 s"}, {"tactic": "simpa [ha.Ici_eq] using hs", "annotated_tactic": ["simpa [ha.Ici_eq] using hs", []], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : IsMax a\n\u22a2 a \u2264 a \u2227 Icc a a \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a a \u2286 s", "state_after": "no goals"}, {"tactic": "rcases (nhdsWithin_Ici_basis' ha).mem_iff.mp hs with \u27e8b, hab, hbs\u27e9", "annotated_tactic": ["rcases (<a>nhdsWithin_Ici_basis'</a> ha).mem_iff.mp hs with \u27e8b, hab, hbs\u27e9", [{"full_name": "nhdsWithin_Ici_basis'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [299, 9], "def_end_pos": [299, 30]}]], "state_before": "case inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s", "state_after": "case inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s"}, {"tactic": "rcases eq_empty_or_nonempty (Ioo a b) with (H | \u27e8c, hac, hcb\u27e9)", "annotated_tactic": ["rcases <a>eq_empty_or_nonempty</a> (<a>Ioo</a> a b) with (H | \u27e8c, hac, hcb\u27e9)", [{"full_name": "Set.eq_empty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [609, 9], "def_end_pos": [609, 29]}, {"full_name": "Set.Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [44, 5], "def_end_pos": [44, 8]}]], "state_before": "case inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s", "state_after": "case inr.intro.intro.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\nH : Ioo a b = \u2205\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s\n\ncase inr.intro.intro.inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\nc : \u03b1\nhac : a < c\nhcb : c < b\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s"}, {"tactic": "have : Ico a b = Icc a a := by rw [\u2190 Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]", "annotated_tactic": ["have : <a>Ico</a> a b = <a>Icc</a> a a := by rw [\u2190 <a>Icc_union_Ioo_eq_Ico</a> <a>le_rfl</a> hab, H, <a>union_empty</a>]", [{"full_name": "Set.Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [49, 5], "def_end_pos": [49, 8]}, {"full_name": "Set.Icc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [59, 5], "def_end_pos": [59, 8]}, {"full_name": "Set.Icc_union_Ioo_eq_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1598, 9], "def_end_pos": [1598, 29]}, {"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}, {"full_name": "Set.union_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [747, 9], "def_end_pos": [747, 20]}]], "state_before": "case inr.intro.intro.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\nH : Ioo a b = \u2205\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s", "state_after": "case inr.intro.intro.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\nH : Ioo a b = \u2205\nthis : Ico a b = Icc a a\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s"}, {"tactic": "exact \u27e8a, le_rfl, this \u25b8 \u27e8Ico_mem_nhdsWithin_Ici' hab, hbs\u27e9\u27e9", "annotated_tactic": ["exact \u27e8a, <a>le_rfl</a>, this \u25b8 \u27e8<a>Ico_mem_nhdsWithin_Ici'</a> hab, hbs\u27e9\u27e9", [{"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}, {"full_name": "Ico_mem_nhdsWithin_Ici'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/OrderClosed.lean", "def_pos": [577, 9], "def_end_pos": [577, 32]}]], "state_before": "case inr.intro.intro.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\nH : Ioo a b = \u2205\nthis : Ico a b = Icc a a\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s", "state_after": "no goals"}, {"tactic": "rw [\u2190 Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty]", "annotated_tactic": ["rw [\u2190 <a>Icc_union_Ioo_eq_Ico</a> <a>le_rfl</a> hab, H, <a>union_empty</a>]", [{"full_name": "Set.Icc_union_Ioo_eq_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1598, 9], "def_end_pos": [1598, 29]}, {"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}, {"full_name": "Set.union_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [747, 9], "def_end_pos": [747, 20]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\nH : Ioo a b = \u2205\n\u22a2 Ico a b = Icc a a", "state_after": "no goals"}, {"tactic": "refine' \u27e8c, hac.le, Icc_mem_nhdsWithin_Ici' hac, _\u27e9", "annotated_tactic": ["refine' \u27e8c, hac.le, <a>Icc_mem_nhdsWithin_Ici'</a> hac, _\u27e9", [{"full_name": "Icc_mem_nhdsWithin_Ici'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/OrderClosed.lean", "def_pos": [596, 9], "def_end_pos": [596, 32]}]], "state_before": "case inr.intro.intro.inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\nc : \u03b1\nhac : a < c\nhcb : c < b\n\u22a2 \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s", "state_after": "case inr.intro.intro.inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\nc : \u03b1\nhac : a < c\nhcb : c < b\n\u22a2 Icc a c \u2286 s"}, {"tactic": "exact (Icc_subset_Ico_right hcb).trans hbs", "annotated_tactic": ["exact (<a>Icc_subset_Ico_right</a> hcb).<a>trans</a> hbs", [{"full_name": "Set.Icc_subset_Ico_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [500, 9], "def_end_pos": [500, 29]}, {"full_name": "HasSubset.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [667, 7], "def_end_pos": [667, 29]}]], "state_before": "case inr.intro.intro.inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 \ud835\udcdd[\u2265] a\nha : \u2203 b, a < b\nb : \u03b1\nhab : a < b\nhbs : Ico a b \u2286 s\nc : \u03b1\nhac : a < c\nhcb : c < b\n\u22a2 Icc a c \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Lattice.lean", "full_name": "ContinuousAt.finset_sup", "start": [302, 1], "end": [304, 60], "traced_tactics": [{"tactic": "simpa only [\u2190 Finset.sup_apply] using finset_sup_apply hs", "annotated_tactic": ["simpa only [\u2190 <a>Finset.sup_apply</a>] using <a>finset_sup_apply</a> hs", [{"full_name": "Finset.sup_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1186, 19], "def_end_pos": [1186, 28]}, {"full_name": "ContinuousAt.finset_sup_apply", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Lattice.lean", "def_pos": [298, 7], "def_end_pos": [298, 36]}]], "state_before": "L : Type u_1\nX : Type u_2\ninst\u271d\u2074 : TopologicalSpace L\ninst\u271d\u00b3 : TopologicalSpace X\n\u03b9 : Type u_3\ninst\u271d\u00b2 : SemilatticeSup L\ninst\u271d\u00b9 : OrderBot L\ninst\u271d : ContinuousSup L\ns : Finset \u03b9\nf : \u03b9 \u2192 X \u2192 L\nt : Set X\nx : X\nhs : \u2200 i \u2208 s, ContinuousAt (f i) x\n\u22a2 ContinuousAt (Finset.sup s f) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/Order.lean", "full_name": "Int.le_neg_of_le_neg", "start": [115, 11], "end": [117, 25], "traced_tactics": [{"tactic": "have h := Int.neg_le_neg h", "annotated_tactic": ["have h := <a>Int.neg_le_neg</a> h", [{"full_name": "Int.neg_le_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [277, 19], "def_end_pos": [277, 29]}]], "state_before": "a b : Int\nh : a \u2264 -b\n\u22a2 b \u2264 -a", "state_after": "a b : Int\nh\u271d : a \u2264 -b\nh : - -b \u2264 -a\n\u22a2 b \u2264 -a"}, {"tactic": "rwa [Int.neg_neg] at h", "annotated_tactic": ["rwa [<a>Int.neg_neg</a>] at h", [{"full_name": "Int.neg_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [75, 27], "def_end_pos": [75, 34]}]], "state_before": "a b : Int\nh\u271d : a \u2264 -b\nh : - -b \u2264 -a\n\u22a2 b \u2264 -a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Separation.lean", "full_name": "eq_of_uniformity", "start": [166, 1], "end": [168, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.IsPrincipal.principal", "start": [62, 1], "end": [64, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Ring.lean", "full_name": "Finset.prod_add", "start": [129, 1], "end": [150, 17], "traced_tactics": [{"tactic": "classical\ncalc\n  \u220f i in s, (f i + g i) =\n      \u220f i in s, \u2211 p in ({True, False} : Finset Prop), if p then f i else g i := by simp\n  _ = \u2211 p in (s.pi fun _ => {True, False} : Finset (\u2200 a \u2208 s, Prop)),\n        \u220f a in s.attach, if p a.1 a.2 then f a.1 else g a.1 := prod_sum _ _ _\n  _ = \u2211 t in s.powerset, (\u220f a in t, f a) * \u220f a in s \\ t, g a :=\n    sum_bij'\n      (fun f _ \u21a6 s.filter fun a \u21a6 \u2203 h : a \u2208 s, f a h)\n      (fun t _ a _ => a \u2208 t)\n      (by simp)\n      (by simp [Classical.em])\n      (by simp_rw [mem_filter, Function.funext_iff, eq_iff_iff, mem_pi, mem_insert]; tauto)\n      (by simp_rw [ext_iff, @mem_filter _ _ (id _), mem_powerset]; tauto)\n      (fun a _ \u21a6 by\n        simp only [prod_ite, filter_attach', prod_map, Function.Embedding.coeFn_mk,\n          Subtype.map_coe, id_eq, prod_attach, filter_congr_decidable]\n        congr 2 with x\n        simp only [mem_filter, mem_sdiff, not_and, not_exists, and_congr_right_iff]\n        tauto)", "annotated_tactic": ["classical\n  calc\n    \u220f i in s, (f i + g i) =\n        \u220f i in s, \u2211 p in ({<a>True</a>, <a>False</a>} : <a>Finset</a> Prop), if p then f i else g i := by simp\n    _ = \u2211 p in (s.pi fun _ => {<a>True</a>, <a>False</a>} : <a>Finset</a> (\u2200 a \u2208 s, Prop)),\n          \u220f a in s.attach, if p a.1 a.2 then f a.1 else g a.1 := <a>prod_sum</a> _ _ _\n    _ = \u2211 t in s.powerset, (\u220f a in t, f a) * \u220f a in s \\ t, g a :=\n      <a>sum_bij'</a>\n        (fun f _ \u21a6 s.filter fun a \u21a6 \u2203 h : a \u2208 s, f a h)\n        (fun t _ a _ => a \u2208 t)\n        (by simp)\n        (by simp [<a>Classical.em</a>])\n        (by simp_rw [<a>mem_filter</a>, <a>Function.funext_iff</a>, <a>eq_iff_iff</a>, <a>mem_pi</a>, <a>mem_insert</a>]; tauto)\n        (by simp_rw [<a>ext_iff</a>, @<a>mem_filter</a> _ _ (<a>id</a> _), <a>mem_powerset</a>]; tauto)\n        (fun a _ \u21a6 by\n          simp only [<a>prod_ite</a>, <a>filter_attach'</a>, <a>prod_map</a>, <a>Function.Embedding.coeFn_mk</a>,\n            <a>Subtype.map_coe</a>, <a>id_eq</a>, <a>prod_attach</a>, <a>filter_congr_decidable</a>]\n          congr 2 with x\n          simp only [<a>mem_filter</a>, <a>mem_sdiff</a>, <a>not_and</a>, <a>not_exists</a>, <a>and_congr_right_iff</a>]\n          tauto)", [{"full_name": "True", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [189, 11], "def_end_pos": [189, 15]}, {"full_name": "False", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [202, 11], "def_end_pos": [202, 16]}, {"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}, {"full_name": "True", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [189, 11], "def_end_pos": [189, 15]}, {"full_name": "False", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [202, 11], "def_end_pos": [202, 16]}, {"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}, {"full_name": "Finset.prod_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean", "def_pos": [80, 7], "def_end_pos": [80, 15]}, {"full_name": "Finset.sum_bij'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [633, 3], "def_end_pos": [633, 14]}, {"full_name": "Classical.em", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [25, 9], "def_end_pos": [25, 11]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "Function.funext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 19]}, {"full_name": "eq_iff_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1366, 17], "def_end_pos": [1366, 27]}, {"full_name": "Finset.mem_pi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Pi.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Finset.mem_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1116, 9], "def_end_pos": [1116, 19]}, {"full_name": "Finset.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 16]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "Finset.mem_powerset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Powerset.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}, {"full_name": "Finset.prod_ite", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1141, 9], "def_end_pos": [1141, 17]}, {"full_name": "Finset.filter_attach'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [208, 7], "def_end_pos": [208, 21]}, {"full_name": "Finset.prod_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [369, 9], "def_end_pos": [369, 17]}, {"full_name": "Function.Embedding.coeFn_mk", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 17]}, {"full_name": "Subtype.map_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [199, 3], "def_end_pos": [199, 8]}, {"full_name": "id_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [297, 17], "def_end_pos": [297, 22]}, {"full_name": "Finset.prod_attach", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [376, 7], "def_end_pos": [376, 18]}, {"full_name": "Finset.filter_congr_decidable", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2817, 9], "def_end_pos": [2817, 31]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "Finset.mem_sdiff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2129, 9], "def_end_pos": [2129, 18]}, {"full_name": "not_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [109, 17], "def_end_pos": [109, 24]}, {"full_name": "not_exists", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [187, 17], "def_end_pos": [187, 27]}, {"full_name": "and_congr_right_iff", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [143, 17], "def_end_pos": [143, 36]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u220f i in s, (f i + g i) = \u2211 t in powerset s, (\u220f i in t, f i) * \u220f i in s \\ t, g i", "state_after": "no goals"}, {"tactic": "calc\n  \u220f i in s, (f i + g i) =\n      \u220f i in s, \u2211 p in ({True, False} : Finset Prop), if p then f i else g i := by simp\n  _ = \u2211 p in (s.pi fun _ => {True, False} : Finset (\u2200 a \u2208 s, Prop)),\n        \u220f a in s.attach, if p a.1 a.2 then f a.1 else g a.1 := prod_sum _ _ _\n  _ = \u2211 t in s.powerset, (\u220f a in t, f a) * \u220f a in s \\ t, g a :=\n    sum_bij'\n      (fun f _ \u21a6 s.filter fun a \u21a6 \u2203 h : a \u2208 s, f a h)\n      (fun t _ a _ => a \u2208 t)\n      (by simp)\n      (by simp [Classical.em])\n      (by simp_rw [mem_filter, Function.funext_iff, eq_iff_iff, mem_pi, mem_insert]; tauto)\n      (by simp_rw [ext_iff, @mem_filter _ _ (id _), mem_powerset]; tauto)\n      (fun a _ \u21a6 by\n        simp only [prod_ite, filter_attach', prod_map, Function.Embedding.coeFn_mk,\n          Subtype.map_coe, id_eq, prod_attach, filter_congr_decidable]\n        congr 2 with x\n        simp only [mem_filter, mem_sdiff, not_and, not_exists, and_congr_right_iff]\n        tauto)", "annotated_tactic": ["calc\n    \u220f i in s, (f i + g i) =\n        \u220f i in s, \u2211 p in ({<a>True</a>, <a>False</a>} : <a>Finset</a> Prop), if p then f i else g i := by simp\n    _ = \u2211 p in (s.pi fun _ => {<a>True</a>, <a>False</a>} : <a>Finset</a> (\u2200 a \u2208 s, Prop)),\n          \u220f a in s.attach, if p a.1 a.2 then f a.1 else g a.1 := <a>prod_sum</a> _ _ _\n    _ = \u2211 t in s.powerset, (\u220f a in t, f a) * \u220f a in s \\ t, g a :=\n      <a>sum_bij'</a>\n        (fun f _ \u21a6 s.filter fun a \u21a6 \u2203 h : a \u2208 s, f a h)\n        (fun t _ a _ => a \u2208 t)\n        (by simp)\n        (by simp [<a>Classical.em</a>])\n        (by simp_rw [<a>mem_filter</a>, <a>Function.funext_iff</a>, <a>eq_iff_iff</a>, <a>mem_pi</a>, <a>mem_insert</a>]; tauto)\n        (by simp_rw [<a>ext_iff</a>, @<a>mem_filter</a> _ _ (<a>id</a> _), <a>mem_powerset</a>]; tauto)\n        (fun a _ \u21a6 by\n          simp only [<a>prod_ite</a>, <a>filter_attach'</a>, <a>prod_map</a>, <a>Function.Embedding.coeFn_mk</a>,\n            <a>Subtype.map_coe</a>, <a>id_eq</a>, <a>prod_attach</a>, <a>filter_congr_decidable</a>]\n          congr 2 with x\n          simp only [<a>mem_filter</a>, <a>mem_sdiff</a>, <a>not_and</a>, <a>not_exists</a>, <a>and_congr_right_iff</a>]\n          tauto)", [{"full_name": "True", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [189, 11], "def_end_pos": [189, 15]}, {"full_name": "False", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [202, 11], "def_end_pos": [202, 16]}, {"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}, {"full_name": "True", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [189, 11], "def_end_pos": [189, 15]}, {"full_name": "False", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [202, 11], "def_end_pos": [202, 16]}, {"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}, {"full_name": "Finset.prod_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean", "def_pos": [80, 7], "def_end_pos": [80, 15]}, {"full_name": "Finset.sum_bij'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [633, 3], "def_end_pos": [633, 14]}, {"full_name": "Classical.em", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [25, 9], "def_end_pos": [25, 11]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "Function.funext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 19]}, {"full_name": "eq_iff_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1366, 17], "def_end_pos": [1366, 27]}, {"full_name": "Finset.mem_pi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Pi.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Finset.mem_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1116, 9], "def_end_pos": [1116, 19]}, {"full_name": "Finset.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 16]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "Finset.mem_powerset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Powerset.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}, {"full_name": "Finset.prod_ite", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1141, 9], "def_end_pos": [1141, 17]}, {"full_name": "Finset.filter_attach'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [208, 7], "def_end_pos": [208, 21]}, {"full_name": "Finset.prod_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [369, 9], "def_end_pos": [369, 17]}, {"full_name": "Function.Embedding.coeFn_mk", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 17]}, {"full_name": "Subtype.map_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [199, 3], "def_end_pos": [199, 8]}, {"full_name": "id_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [297, 17], "def_end_pos": [297, 22]}, {"full_name": "Finset.prod_attach", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [376, 7], "def_end_pos": [376, 18]}, {"full_name": "Finset.filter_congr_decidable", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2817, 9], "def_end_pos": [2817, 31]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "Finset.mem_sdiff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2129, 9], "def_end_pos": [2129, 18]}, {"full_name": "not_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [109, 17], "def_end_pos": [109, 24]}, {"full_name": "not_exists", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [187, 17], "def_end_pos": [187, 27]}, {"full_name": "and_congr_right_iff", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [143, 17], "def_end_pos": [143, 36]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u220f i in s, (f i + g i) = \u2211 t in powerset s, (\u220f i in t, f i) * \u220f i in s \\ t, g i", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u220f i in s, (f i + g i) = \u220f i in s, \u2211 p in {True, False}, if p then f i else g i", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 (a : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop) (ha : a \u2208 pi s fun x => {True, False}),\n    (fun f x => filter (fun a => \u2203 (h : a \u2208 s), f a h) s) a ha \u2208 powerset s", "state_after": "no goals"}, {"tactic": "simp [Classical.em]", "annotated_tactic": ["simp [<a>Classical.em</a>]", [{"full_name": "Classical.em", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [25, 9], "def_end_pos": [25, 11]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 (a : Finset \u03b9) (ha : a \u2208 powerset s), (fun t x a x => a \u2208 t) a ha \u2208 pi s fun x => {True, False}", "state_after": "no goals"}, {"tactic": "simp_rw [mem_filter, Function.funext_iff, eq_iff_iff, mem_pi, mem_insert]", "annotated_tactic": ["simp_rw [<a>mem_filter</a>, <a>Function.funext_iff</a>, <a>eq_iff_iff</a>, <a>mem_pi</a>, <a>mem_insert</a>]", [{"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "Function.funext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 19]}, {"full_name": "eq_iff_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1366, 17], "def_end_pos": [1366, 27]}, {"full_name": "Finset.mem_pi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Pi.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Finset.mem_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1116, 9], "def_end_pos": [1116, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 (a : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop) (ha : a \u2208 pi s fun x => {True, False}),\n    (fun t x a x => a \u2208 t) ((fun f x => filter (fun a => \u2203 (h : a \u2208 s), f a h) s) a ha) \u22ef = a", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 (a : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop),\n    (\u2200 (a_1 : \u03b9) (h : a_1 \u2208 s), a a_1 h = True \u2228 a a_1 h \u2208 {False}) \u2192\n      \u2200 (a_1 : \u03b9) (a_2 : a_1 \u2208 s), (a_1 \u2208 s \u2227 \u2203 (h : a_1 \u2208 s), a a_1 h) \u2194 a a_1 a_2"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 (a : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop),\n    (\u2200 (a_1 : \u03b9) (h : a_1 \u2208 s), a a_1 h = True \u2228 a a_1 h \u2208 {False}) \u2192\n      \u2200 (a_1 : \u03b9) (a_2 : a_1 \u2208 s), (a_1 \u2208 s \u2227 \u2203 (h : a_1 \u2208 s), a a_1 h) \u2194 a a_1 a_2", "state_after": "no goals"}, {"tactic": "simp_rw [ext_iff, @mem_filter _ _ (id _), mem_powerset]", "annotated_tactic": ["simp_rw [<a>ext_iff</a>, @<a>mem_filter</a> _ _ (<a>id</a> _), <a>mem_powerset</a>]", [{"full_name": "Finset.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 16]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "Finset.mem_powerset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Powerset.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 (a : Finset \u03b9) (ha : a \u2208 powerset s),\n    (fun f x => filter (fun a => \u2203 (h : a \u2208 s), f a h) s) ((fun t x a x => a \u2208 t) a ha) \u22ef = a", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 a \u2286 s, \u2200 (a_1 : \u03b9), (a_1 \u2208 s \u2227 \u2203 (_ : a_1 \u2208 s), a_1 \u2208 a) \u2194 a_1 \u2208 a"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\n\u22a2 \u2200 a \u2286 s, \u2200 (a_1 : \u03b9), (a_1 \u2208 s \u2227 \u2203 (_ : a_1 \u2208 s), a_1 \u2208 a) \u2194 a_1 \u2208 a", "state_after": "no goals"}, {"tactic": "simp only [prod_ite, filter_attach', prod_map, Function.Embedding.coeFn_mk,\n  Subtype.map_coe, id_eq, prod_attach, filter_congr_decidable]", "annotated_tactic": ["simp only [<a>prod_ite</a>, <a>filter_attach'</a>, <a>prod_map</a>, <a>Function.Embedding.coeFn_mk</a>,\n            <a>Subtype.map_coe</a>, <a>id_eq</a>, <a>prod_attach</a>, <a>filter_congr_decidable</a>]", [{"full_name": "Finset.prod_ite", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1141, 9], "def_end_pos": [1141, 17]}, {"full_name": "Finset.filter_attach'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [208, 7], "def_end_pos": [208, 21]}, {"full_name": "Finset.prod_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [369, 9], "def_end_pos": [369, 17]}, {"full_name": "Function.Embedding.coeFn_mk", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 17]}, {"full_name": "Subtype.map_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [199, 3], "def_end_pos": [199, 8]}, {"full_name": "id_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [297, 17], "def_end_pos": [297, 22]}, {"full_name": "Finset.prod_attach", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [376, 7], "def_end_pos": [376, 18]}, {"full_name": "Finset.filter_congr_decidable", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2817, 9], "def_end_pos": [2817, 31]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na\u271d : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\na : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 (\u220f a_1 in attach s, if a \u2191a_1 \u22ef then f \u2191a_1 else g \u2191a_1) =\n    (\u220f a in (fun f x => filter (fun a => \u2203 (h : a \u2208 s), f a h) s) a x\u271d, f a) *\n      \u220f a in s \\ (fun f x => filter (fun a => \u2203 (h : a \u2208 s), f a h) s) a x\u271d, g a", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na\u271d : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\na : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 (\u220f x in filter (fun x => \u2203 (h : x \u2208 s), a x h) s, f x) * \u220f x in filter (fun x => \u2203 (h : x \u2208 s), \u00aca x h) s, g x =\n    (\u220f x in filter (fun a_1 => \u2203 (h : a_1 \u2208 s), a a_1 h) s, f x) *\n      \u220f x in s \\ filter (fun a_1 => \u2203 (h : a_1 \u2208 s), a a_1 h) s, g x"}, {"tactic": "congr 2 with x", "annotated_tactic": ["congr 2 with x", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na\u271d : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\na : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 (\u220f x in filter (fun x => \u2203 (h : x \u2208 s), a x h) s, f x) * \u220f x in filter (fun x => \u2203 (h : x \u2208 s), \u00aca x h) s, g x =\n    (\u220f x in filter (fun a_1 => \u2203 (h : a_1 \u2208 s), a a_1 h) s, f x) *\n      \u220f x in s \\ filter (fun a_1 => \u2203 (h : a_1 \u2208 s), a a_1 h) s, g x", "state_after": "case e_a.e_s.a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na\u271d : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\na : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\nx : \u03b9\n\u22a2 x \u2208 filter (fun x => \u2203 (h : x \u2208 s), \u00aca x h) s \u2194 x \u2208 s \\ filter (fun a_1 => \u2203 (h : a_1 \u2208 s), a a_1 h) s"}, {"tactic": "simp only [mem_filter, mem_sdiff, not_and, not_exists, and_congr_right_iff]", "annotated_tactic": ["simp only [<a>mem_filter</a>, <a>mem_sdiff</a>, <a>not_and</a>, <a>not_exists</a>, <a>and_congr_right_iff</a>]", [{"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "Finset.mem_sdiff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2129, 9], "def_end_pos": [2129, 18]}, {"full_name": "not_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [109, 17], "def_end_pos": [109, 24]}, {"full_name": "not_exists", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [187, 17], "def_end_pos": [187, 27]}, {"full_name": "and_congr_right_iff", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [143, 17], "def_end_pos": [143, 36]}]], "state_before": "case e_a.e_s.a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na\u271d : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\na : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\nx : \u03b9\n\u22a2 x \u2208 filter (fun x => \u2203 (h : x \u2208 s), \u00aca x h) s \u2194 x \u2208 s \\ filter (fun a_1 => \u2203 (h : a_1 \u2208 s), a a_1 h) s", "state_after": "case e_a.e_s.a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na\u271d : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\na : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\nx : \u03b9\n\u22a2 x \u2208 s \u2192 ((\u2203 (h : x \u2208 s), \u00aca x h) \u2194 x \u2208 s \u2192 \u2200 (x_1 : x \u2208 s), \u00aca x x_1)"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "case e_a.e_s.a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03ba : \u03b9 \u2192 Type u_3\ns\u271d s\u2081 s\u2082 : Finset \u03b9\ni : \u03b9\na\u271d : \u03b1\nf\u271d g\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\na : (a : \u03b9) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\nx : \u03b9\n\u22a2 x \u2208 s \u2192 ((\u2203 (h : x \u2208 s), \u00aca x h) \u2194 x \u2208 s \u2192 \u2200 (x_1 : x \u2208 s), \u00aca x x_1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Integral.lean", "full_name": "isAlgebraic_of_isLocalization", "start": [457, 1], "end": [471, 86], "traced_tactics": [{"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "R\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\n\u22a2 Algebra.IsAlgebraic R S", "state_after": "R\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : S\n\u22a2 IsAlgebraic R x"}, {"tactic": "obtain \u27e8x, s, rfl\u27e9 := IsLocalization.mk'_surjective M x", "annotated_tactic": ["obtain \u27e8x, s, rfl\u27e9 := <a>IsLocalization.mk'_surjective</a> M x", [{"full_name": "IsLocalization.mk'_surjective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [304, 9], "def_end_pos": [304, 23]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : S\n\u22a2 IsAlgebraic R x", "state_after": "case intro.intro\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\n\u22a2 IsAlgebraic R (mk' S x s)"}, {"tactic": "by_cases hs : (s : R) = 0", "annotated_tactic": ["by_cases hs : (s : R) = 0", []], "state_before": "case intro.intro\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\n\u22a2 IsAlgebraic R (mk' S x s)", "state_after": "case pos\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u2191s = 0\n\u22a2 IsAlgebraic R (mk' S x s)\n\ncase neg\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u00ac\u2191s = 0\n\u22a2 IsAlgebraic R (mk' S x s)"}, {"tactic": "refine \u27e8s \u2022 X - C x, ?_, ?_\u27e9", "annotated_tactic": ["refine \u27e8s \u2022 <a>X</a> - <a>C</a> x, ?_, ?_\u27e9", [{"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}]], "state_before": "case neg\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u00ac\u2191s = 0\n\u22a2 IsAlgebraic R (mk' S x s)", "state_after": "case neg.refine_1\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u00ac\u2191s = 0\n\u22a2 s \u2022 X - C x \u2260 0\n\ncase neg.refine_2\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u00ac\u2191s = 0\n\u22a2 (aeval (mk' S x s)) (s \u2022 X - C x) = 0"}, {"tactic": "have := IsLocalization.mk'_spec S x s", "annotated_tactic": ["have := <a>IsLocalization.mk'_spec</a> S x s", [{"full_name": "IsLocalization.mk'_spec", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [264, 9], "def_end_pos": [264, 17]}]], "state_before": "case pos\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u2191s = 0\n\u22a2 IsAlgebraic R (mk' S x s)", "state_after": "case pos\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u2191s = 0\nthis : mk' S x s * (algebraMap R S) \u2191s = (algebraMap R S) x\n\u22a2 IsAlgebraic R (mk' S x s)"}, {"tactic": "rw [hs, map_zero, mul_zero] at this", "annotated_tactic": ["rw [hs, <a>map_zero</a>, <a>mul_zero</a>] at this", [{"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}]], "state_before": "case pos\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u2191s = 0\nthis : mk' S x s * (algebraMap R S) \u2191s = (algebraMap R S) x\n\u22a2 IsAlgebraic R (mk' S x s)", "state_after": "case pos\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u2191s = 0\nthis : 0 = (algebraMap R S) x\n\u22a2 IsAlgebraic R (mk' S x s)"}, {"tactic": "exact \u27e8X, X_ne_zero, by simp [IsLocalization.mk'_eq_mul_mk'_one x, \u2190 this]\u27e9", "annotated_tactic": ["exact \u27e8<a>X</a>, <a>X_ne_zero</a>, by simp [<a>IsLocalization.mk'_eq_mul_mk'_one</a> x, \u2190 this]\u27e9", [{"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.X_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1259, 9], "def_end_pos": [1259, 18]}, {"full_name": "IsLocalization.mk'_eq_mul_mk'_one", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [414, 9], "def_end_pos": [414, 27]}]], "state_before": "case pos\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u2191s = 0\nthis : 0 = (algebraMap R S) x\n\u22a2 IsAlgebraic R (mk' S x s)", "state_after": "no goals"}, {"tactic": "simp [IsLocalization.mk'_eq_mul_mk'_one x, \u2190 this]", "annotated_tactic": ["simp [<a>IsLocalization.mk'_eq_mul_mk'_one</a> x, \u2190 this]", [{"full_name": "IsLocalization.mk'_eq_mul_mk'_one", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [414, 9], "def_end_pos": [414, 27]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u2191s = 0\nthis : 0 = (algebraMap R S) x\n\u22a2 (aeval (mk' S x s)) X = 0", "state_after": "no goals"}, {"tactic": "intro e", "annotated_tactic": ["intro e", []], "state_before": "case neg.refine_1\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u00ac\u2191s = 0\n\u22a2 s \u2022 X - C x \u2260 0", "state_after": "case neg.refine_1\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u00ac\u2191s = 0\ne : s \u2022 X - C x = 0\n\u22a2 False"}, {"tactic": "apply hs", "annotated_tactic": ["apply hs", []], "state_before": "case neg.refine_1\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u00ac\u2191s = 0\ne : s \u2022 X - C x = 0\n\u22a2 False", "state_after": "case neg.refine_1\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u00ac\u2191s = 0\ne : s \u2022 X - C x = 0\n\u22a2 \u2191s = 0"}, {"tactic": "simp only [map_sub, Algebra.smul_def, Submonoid.smul_def,\n  map_mul, AlgHom.commutes, aeval_X, IsLocalization.mk'_spec', aeval_C, sub_self]", "annotated_tactic": ["simp only [<a>map_sub</a>, <a>Algebra.smul_def</a>, <a>Submonoid.smul_def</a>,\n      <a>map_mul</a>, <a>AlgHom.commutes</a>, <a>aeval_X</a>, <a>IsLocalization.mk'_spec'</a>, <a>aeval_C</a>, <a>sub_self</a>]", [{"full_name": "map_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [458, 3], "def_end_pos": [458, 14]}, {"full_name": "Algebra.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}, {"full_name": "Submonoid.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [1452, 22], "def_end_pos": [1452, 30]}, {"full_name": "map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [308, 9], "def_end_pos": [308, 16]}, {"full_name": "AlgHom.commutes", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [232, 9], "def_end_pos": [232, 17]}, {"full_name": "Polynomial.aeval_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/AlgebraMap.lean", "def_pos": [202, 9], "def_end_pos": [202, 16]}, {"full_name": "IsLocalization.mk'_spec'", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [269, 9], "def_end_pos": [269, 18]}, {"full_name": "Polynomial.aeval_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/AlgebraMap.lean", "def_pos": [208, 9], "def_end_pos": [208, 16]}, {"full_name": "sub_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [813, 30], "def_end_pos": [813, 38]}]], "state_before": "case neg.refine_2\nR\u271d : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS\u271d : Type u_2\ninst\u271d\u2079 : CommRing S\u271d\ninst\u271d\u2078 : Algebra R\u271d S\u271d\nP : Type u_3\ninst\u271d\u2077 : CommRing P\nA : Type u_4\nK : Type u_5\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : IsDomain A\nR : Type u_6\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_7\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Algebra R S\ninst\u271d : IsLocalization M S\nx : R\ns : \u21a5M\nhs : \u00ac\u2191s = 0\n\u22a2 (aeval (mk' S x s)) (s \u2022 X - C x) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Finset.Nonempty.image_iff", "start": [439, 1], "end": [440, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/OrderClosed.lean", "full_name": "Dense.exists_ge", "start": [231, 11], "end": [233, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/WithBotTop.lean", "full_name": "WithBot.preimage_coe_Ioc", "start": [175, 1], "end": [175, 101], "traced_tactics": [{"tactic": "simp [\u2190 Ioi_inter_Iic]", "annotated_tactic": ["simp [\u2190 <a>Ioi_inter_Iic</a>]", [{"full_name": "Set.Ioi_inter_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [626, 9], "def_end_pos": [626, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\na b : \u03b1\n\u22a2 some \u207b\u00b9' Ioc \u2191a \u2191b = Ioc a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Lipschitz.lean", "full_name": "LipschitzWith.comap_cobounded_le", "start": [144, 1], "end": [146, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Torsion.lean", "full_name": "Module.isTorsionBySet_iff_is_torsion_by_span", "start": [343, 1], "end": [346, 39], "traced_tactics": [{"tactic": "rw [isTorsionBySet_iff_torsionBySet_eq_top, isTorsionBySet_iff_torsionBySet_eq_top,\n  torsionBySet_eq_torsionBySet_span]", "annotated_tactic": ["rw [<a>isTorsionBySet_iff_torsionBySet_eq_top</a>, <a>isTorsionBySet_iff_torsionBySet_eq_top</a>,\n    <a>torsionBySet_eq_torsionBySet_span</a>]", [{"full_name": "Module.isTorsionBySet_iff_torsionBySet_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean", "def_pos": [330, 9], "def_end_pos": [330, 47]}, {"full_name": "Module.isTorsionBySet_iff_torsionBySet_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean", "def_pos": [330, 9], "def_end_pos": [330, 47]}, {"full_name": "Submodule.torsionBySet_eq_torsionBySet_span", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean", "def_pos": [283, 9], "def_end_pos": [283, 42]}]], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set R\na : R\n\u22a2 IsTorsionBySet R M s \u2194 IsTorsionBySet R M \u2191(Ideal.span s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.comapDomain'_apply", "start": [1397, 1], "end": [1399, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "Prop.forall_iff", "start": [874, 1], "end": [875, 78], "traced_tactics": [{"tactic": "by_cases H : h <;> simpa only [H]", "annotated_tactic": ["by_cases H : h <;> simpa only [H]", []], "state_before": "\u03b9 : Sort ?u.20844\n\u03b1 : Sort ?u.20849\n\u03ba : \u03b9 \u2192 Sort u_1\np\u271d q : \u03b1 \u2192 Prop\np : Prop \u2192 Prop\nx\u271d : p False \u2227 p True\nh : Prop\nh\u2081 : p False\nh\u2082 : p True\n\u22a2 p h", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "clusterPt_iff_lift'_closure'", "start": [1321, 1], "end": [1323, 96], "traced_tactics": [{"tactic": "rw [clusterPt_iff_lift'_closure, \u2190 Ultrafilter.coe_pure, inf_comm, Ultrafilter.inf_neBot_iff]", "annotated_tactic": ["rw [<a>clusterPt_iff_lift'_closure</a>, \u2190 <a>Ultrafilter.coe_pure</a>, <a>inf_comm</a>, <a>Ultrafilter.inf_neBot_iff</a>]", [{"full_name": "clusterPt_iff_lift'_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1315, 9], "def_end_pos": [1315, 36]}, {"full_name": "Ultrafilter.coe_pure", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Ultrafilter.lean", "def_pos": [290, 9], "def_end_pos": [290, 17]}, {"full_name": "inf_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [465, 9], "def_end_pos": [465, 17]}, {"full_name": "Ultrafilter.inf_neBot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Ultrafilter.lean", "def_pos": [111, 9], "def_end_pos": [111, 22]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Sort w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : X\ns s\u2081 s\u2082 t : Set X\np p\u2081 p\u2082 : X \u2192 Prop\ninst\u271d : TopologicalSpace X\nF : Filter X\n\u22a2 ClusterPt x F \u2194 NeBot (Filter.lift' F closure \u2293 pure x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Fin.image_succAbove_univ", "start": [857, 1], "end": [859, 7], "traced_tactics": [{"tactic": "ext m", "annotated_tactic": ["ext m", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\ni : Fin (n + 1)\n\u22a2 image (succAbove i) univ = {i}\u1d9c", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\ni m : Fin (n + 1)\n\u22a2 m \u2208 image (succAbove i) univ \u2194 m \u2208 {i}\u1d9c"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\ni m : Fin (n + 1)\n\u22a2 m \u2208 image (succAbove i) univ \u2194 m \u2208 {i}\u1d9c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Complex.tan_pi_sub", "start": [1286, 1], "end": [1287, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.ringHom_rightInverse", "start": [1294, 1], "end": [1296, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Congruence.lean", "full_name": "RingCon.coe_iInf", "start": [465, 1], "end": [466, 67], "traced_tactics": [{"tactic": "rw [iInf, coe_sInf, \u2190 Set.range_comp, sInf_range, Function.comp]", "annotated_tactic": ["rw [<a>iInf</a>, <a>coe_sInf</a>, \u2190 <a>Set.range_comp</a>, <a>sInf_range</a>, <a>Function.comp</a>]", [{"full_name": "iInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [69, 5], "def_end_pos": [69, 9]}, {"full_name": "RingCon.coe_sInf", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Congruence.lean", "def_pos": [461, 9], "def_end_pos": [461, 17]}, {"full_name": "Set.range_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [722, 9], "def_end_pos": [722, 19]}, {"full_name": "sInf_range", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [638, 9], "def_end_pos": [638, 19]}, {"full_name": "Function.comp", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}]], "state_before": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : Add R\ninst\u271d : Mul R\n\u03b9 : Sort u_3\nf : \u03b9 \u2192 RingCon R\n\u22a2 \u21d1(iInf f) = \u2a05 i, \u21d1(f i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "nhds_top_basis_Ici", "start": [343, 1], "end": [347, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Subsemiring.coe_one", "start": [335, 1], "end": [336, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.mul_X_comp", "start": [602, 1], "end": [607, 68], "traced_tactics": [{"tactic": "induction p using Polynomial.induction_on' with\n| h_add p q hp hq =>\n  simp only [hp, hq, add_mul, add_comp]\n| h_monomial n b =>\n  simp only [pow_succ', mul_assoc, monomial_mul_X, monomial_comp]", "annotated_tactic": ["induction p using <a>Polynomial.induction_on'</a> with\n  | h_add p q hp hq =>\n    simp only [hp, hq, <a>add_mul</a>, <a>add_comp</a>]\n  | h_monomial n b =>\n    simp only [<a>pow_succ'</a>, <a>mul_assoc</a>, <a>monomial_mul_X</a>, <a>monomial_comp</a>]", [{"full_name": "Polynomial.induction_on'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Induction.lean", "def_pos": [63, 19], "def_end_pos": [63, 32]}, {"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "Polynomial.add_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [592, 9], "def_end_pos": [592, 17]}, {"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "Polynomial.monomial_mul_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [640, 9], "def_end_pos": [640, 23]}, {"full_name": "Polynomial.monomial_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [597, 9], "def_end_pos": [597, 22]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\n\u22a2 comp (p * X) r = comp p r * r", "state_after": "no goals"}, {"tactic": "simp only [hp, hq, add_mul, add_comp]", "annotated_tactic": ["simp only [hp, hq, <a>add_mul</a>, <a>add_comp</a>]", [{"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "Polynomial.add_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [592, 9], "def_end_pos": [592, 17]}]], "state_before": "case h_add\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np\u271d q\u271d r p q : R[X]\nhp : comp (p * X) r = comp p r * r\nhq : comp (q * X) r = comp q r * r\n\u22a2 comp ((p + q) * X) r = comp (p + q) r * r", "state_after": "no goals"}, {"tactic": "simp only [pow_succ', mul_assoc, monomial_mul_X, monomial_comp]", "annotated_tactic": ["simp only [<a>pow_succ'</a>, <a>mul_assoc</a>, <a>monomial_mul_X</a>, <a>monomial_comp</a>]", [{"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "Polynomial.monomial_mul_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [640, 9], "def_end_pos": [640, 23]}, {"full_name": "Polynomial.monomial_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [597, 9], "def_end_pos": [597, 22]}]], "state_before": "case h_monomial\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b\u271d : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nb : R\n\u22a2 comp ((monomial n) b * X) r = comp ((monomial n) b) r * r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NoncommProd.lean", "full_name": "Finset.noncommProd_mul_distrib_aux", "start": [427, 1], "end": [437, 32], "traced_tactics": [{"tactic": "intro x hx y hy h", "annotated_tactic": ["intro x hx y hy h", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\n\u22a2 Set.Pairwise \u2191s fun x y => Commute ((f * g) x) ((f * g) y)", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute ((f * g) x) ((f * g) y)"}, {"tactic": "apply Commute.mul_left <;> apply Commute.mul_right", "annotated_tactic": ["apply <a>Commute.mul_left</a> <;> apply <a>Commute.mul_right</a>", [{"full_name": "Commute.mul_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [115, 9], "def_end_pos": [115, 17]}, {"full_name": "Commute.mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [106, 9], "def_end_pos": [106, 18]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute ((f * g) x) ((f * g) y)", "state_after": "case hac.hab\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute (f x) (f y)\n\ncase hac.hac\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute (f x) (g y)\n\ncase hbc.hab\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute (g x) (f y)\n\ncase hbc.hac\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute (g x) (g y)"}, {"tactic": "exact comm_ff.of_refl hx hy", "annotated_tactic": ["exact comm_ff.of_refl hx hy", []], "state_before": "case hac.hab\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute (f x) (f y)", "state_after": "no goals"}, {"tactic": "exact (comm_gf hy hx h.symm).symm", "annotated_tactic": ["exact (comm_gf hy hx h.symm).<a>symm</a>", [{"full_name": "Commute.symm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [69, 19], "def_end_pos": [69, 23]}]], "state_before": "case hac.hac\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute (f x) (g y)", "state_after": "no goals"}, {"tactic": "exact comm_gf hx hy h", "annotated_tactic": ["exact comm_gf hx hy h", []], "state_before": "case hbc.hab\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute (g x) (f y)", "state_after": "no goals"}, {"tactic": "exact comm_gg.of_refl hx hy", "annotated_tactic": ["exact comm_gg.of_refl hx hy", []], "state_before": "case hbc.hac\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : Monoid \u03b3\ninst\u271d : FunLike F \u03b2 \u03b3\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\ncomm_ff : Set.Pairwise \u2191s fun x y => Commute (f x) (f y)\ncomm_gg : Set.Pairwise \u2191s fun x y => Commute (g x) (g y)\ncomm_gf : Set.Pairwise \u2191s fun x y => Commute (g x) (f y)\nx : \u03b1\nhx : x \u2208 \u2191s\ny : \u03b1\nhy : y \u2208 \u2191s\nh : x \u2260 y\n\u22a2 Commute (g x) (g y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LocallyFinite.lean", "full_name": "Set.toFinset_Ioi", "start": [1528, 1], "end": [1529, 95], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Preorder \u03b1\u271d\np : \u03b1\u271d \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\n\u03b1 : Type u_3\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191(Ioi a)\n\u22a2 toFinset (Ioi a) = Finset.Ioi a", "state_after": "case a\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Preorder \u03b1\u271d\np : \u03b1\u271d \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\n\u03b1 : Type u_3\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191(Ioi a)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 toFinset (Ioi a) \u2194 a\u271d \u2208 Finset.Ioi a"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : Preorder \u03b1\u271d\np : \u03b1\u271d \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\n\u03b1 : Type u_3\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderTop \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191(Ioi a)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 toFinset (Ioi a) \u2194 a\u271d \u2208 Finset.Ioi a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsCoprime.neg_left_iff", "start": [401, 1], "end": [402, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "discreteTopology_iff_singleton_mem_nhds", "start": [347, 1], "end": [349, 96], "traced_tactics": [{"tactic": "simp only [\u2190 singletons_open_iff_discrete, isOpen_iff_mem_nhds, mem_singleton_iff, forall_eq]", "annotated_tactic": ["simp only [\u2190 <a>singletons_open_iff_discrete</a>, <a>isOpen_iff_mem_nhds</a>, <a>mem_singleton_iff</a>, <a>forall_eq</a>]", [{"full_name": "singletons_open_iff_discrete", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [342, 9], "def_end_pos": [342, 37]}, {"full_name": "isOpen_iff_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1183, 9], "def_end_pos": [1183, 28]}, {"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}, {"full_name": "forall_eq", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [206, 17], "def_end_pos": [206, 26]}]], "state_before": "\u03b1 : Type u_1\nt t\u2081 t\u2082 : TopologicalSpace \u03b1\ns : Set \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 DiscreteTopology \u03b1 \u2194 \u2200 (x : \u03b1), {x} \u2208 \ud835\udcdd x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/NoncommPiCoprod.lean", "full_name": "MonoidHom.noncommPiCoprod_mulSingle", "start": [128, 1], "end": [140, 14], "traced_tactics": [{"tactic": "change Finset.univ.noncommProd (fun j => \u03d5 j (Pi.mulSingle i y j)) (fun _ _ _ _ h => hcomm h _ _)\n  = \u03d5 i y", "annotated_tactic": ["change Finset.univ.noncommProd (fun j => \u03d5 j (<a>Pi.mulSingle</a> i y j)) (fun _ _ _ _ h => hcomm h _ _)\n    = \u03d5 i y", [{"full_name": "Pi.mulSingle", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [358, 5], "def_end_pos": [358, 14]}]], "state_before": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 (noncommPiCoprod \u03d5 hcomm) (Pi.mulSingle i y) = (\u03d5 i) y", "state_after": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 Finset.noncommProd Finset.univ (fun j => (\u03d5 j) (Pi.mulSingle i y j)) \u22ef = (\u03d5 i) y"}, {"tactic": "rw [\u2190 Finset.insert_erase (Finset.mem_univ i)]", "annotated_tactic": ["rw [\u2190 <a>Finset.insert_erase</a> (<a>Finset.mem_univ</a> i)]", [{"full_name": "Finset.insert_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2001, 17], "def_end_pos": [2001, 29]}, {"full_name": "Finset.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [73, 9], "def_end_pos": [73, 17]}]], "state_before": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 Finset.noncommProd Finset.univ (fun j => (\u03d5 j) (Pi.mulSingle i y j)) \u22ef = (\u03d5 i) y", "state_after": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 Finset.noncommProd (insert i (Finset.erase Finset.univ i)) (fun j => (\u03d5 j) (Pi.mulSingle i y j)) \u22ef = (\u03d5 i) y"}, {"tactic": "rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ (Finset.not_mem_erase i _)]", "annotated_tactic": ["rw [<a>Finset.noncommProd_insert_of_not_mem</a> _ _ _ _ (<a>Finset.not_mem_erase</a> i _)]", [{"full_name": "Finset.noncommProd_insert_of_not_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NoncommProd.lean", "def_pos": [327, 9], "def_end_pos": [327, 38]}, {"full_name": "Finset.not_mem_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1926, 9], "def_end_pos": [1926, 22]}]], "state_before": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 Finset.noncommProd (insert i (Finset.erase Finset.univ i)) (fun j => (\u03d5 j) (Pi.mulSingle i y j)) \u22ef = (\u03d5 i) y", "state_after": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 (\u03d5 i) (Pi.mulSingle i y i) * Finset.noncommProd (Finset.erase Finset.univ i) (fun j => (\u03d5 j) (Pi.mulSingle i y j)) \u22ef =\n    (\u03d5 i) y"}, {"tactic": "rw [Pi.mulSingle_eq_same]", "annotated_tactic": ["rw [<a>Pi.mulSingle_eq_same</a>]", [{"full_name": "Pi.mulSingle_eq_same", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [364, 9], "def_end_pos": [364, 26]}]], "state_before": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 (\u03d5 i) (Pi.mulSingle i y i) * Finset.noncommProd (Finset.erase Finset.univ i) (fun j => (\u03d5 j) (Pi.mulSingle i y j)) \u22ef =\n    (\u03d5 i) y", "state_after": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 (\u03d5 i) y * Finset.noncommProd (Finset.erase Finset.univ i) (fun j => (\u03d5 j) (Pi.mulSingle i y j)) \u22ef = (\u03d5 i) y"}, {"tactic": "rw [Finset.noncommProd_eq_pow_card]", "annotated_tactic": ["rw [<a>Finset.noncommProd_eq_pow_card</a>]", [{"full_name": "Finset.noncommProd_eq_pow_card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NoncommProd.lean", "def_pos": [365, 9], "def_end_pos": [365, 32]}]], "state_before": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 (\u03d5 i) y * Finset.noncommProd (Finset.erase Finset.univ i) (fun j => (\u03d5 j) (Pi.mulSingle i y j)) \u22ef = (\u03d5 i) y", "state_after": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 (\u03d5 i) y * ?m ^ (Finset.erase Finset.univ i).card = (\u03d5 i) y\n\ncase m\nM : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 M\n\ncase h\nM : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 \u2200 x \u2208 Finset.erase Finset.univ i, (\u03d5 x) (Pi.mulSingle i y x) = ?m"}, {"tactic": "rw [one_pow]", "annotated_tactic": ["rw [<a>one_pow</a>]", [{"full_name": "one_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [75, 9], "def_end_pos": [75, 16]}]], "state_before": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 (\u03d5 i) y * ?m ^ (Finset.erase Finset.univ i).card = (\u03d5 i) y", "state_after": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 (\u03d5 i) y * 1 = (\u03d5 i) y"}, {"tactic": "exact mul_one _", "annotated_tactic": ["exact <a>mul_one</a> _", [{"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "M : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 (\u03d5 i) y * 1 = (\u03d5 i) y", "state_after": "no goals"}, {"tactic": "intro j hj", "annotated_tactic": ["intro j hj", []], "state_before": "case h\nM : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\n\u22a2 \u2200 x \u2208 Finset.erase Finset.univ i, (\u03d5 x) (Pi.mulSingle i y x) = 1", "state_after": "case h\nM : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\nj : \u03b9\nhj : j \u2208 Finset.erase Finset.univ i\n\u22a2 (\u03d5 j) (Pi.mulSingle i y j) = 1"}, {"tactic": "simp only [Finset.mem_erase] at hj", "annotated_tactic": ["simp only [<a>Finset.mem_erase</a>] at hj", [{"full_name": "Finset.mem_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1922, 9], "def_end_pos": [1922, 18]}]], "state_before": "case h\nM : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\nj : \u03b9\nhj : j \u2208 Finset.erase Finset.univ i\n\u22a2 (\u03d5 j) (Pi.mulSingle i y j) = 1", "state_after": "case h\nM : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\nj : \u03b9\nhj : j \u2260 i \u2227 j \u2208 Finset.univ\n\u22a2 (\u03d5 j) (Pi.mulSingle i y j) = 1"}, {"tactic": "simp [hj]", "annotated_tactic": ["simp [hj]", []], "state_before": "case h\nM : Type u_1\ninst\u271d\u00b3 : Monoid M\n\u03b9 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nf g : (i : \u03b9) \u2192 N i\ni : \u03b9\ny : N i\nj : \u03b9\nhj : j \u2260 i \u2227 j \u2208 Finset.univ\n\u22a2 (\u03d5 j) (Pi.mulSingle i y j) = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "full_name": "Set.nonempty_uIcc", "start": [91, 1], "end": [91, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/GetD.lean", "full_name": "List.getD_append_right", "start": [100, 1], "end": [110, 46], "traced_tactics": [{"tactic": "rw [getD_eq_get (l ++ l') d h', get_append_right, getD_eq_get]", "annotated_tactic": ["rw [<a>getD_eq_get</a> (l ++ l') d h', <a>get_append_right</a>, <a>getD_eq_get</a>]", [{"full_name": "List.getD_eq_get", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/GetD.lean", "def_pos": [45, 9], "def_end_pos": [45, 20]}, {"full_name": "List.get_append_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/BasicAux.lean", "def_pos": [103, 9], "def_end_pos": [103, 25]}, {"full_name": "List.getD_eq_get", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/GetD.lean", "def_pos": [45, 9], "def_end_pos": [45, 20]}]], "state_before": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : n < length (l ++ l')\n\u22a2 getD (l ++ l') n d = getD l' (n - length l) d", "state_after": "case inl.hn\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : n < length (l ++ l')\n\u22a2 n - length l < length l'\n\ncase inl.h\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : n < length (l ++ l')\n\u22a2 \u00acn < length l"}, {"tactic": "rw [length_append] at h'", "annotated_tactic": ["rw [<a>length_append</a>] at h'", [{"full_name": "List.length_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [857, 17], "def_end_pos": [857, 30]}]], "state_before": "case inl.hn\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : n < length (l ++ l')\n\u22a2 n - length l < length l'", "state_after": "case inl.hn\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : n < length l + length l'\n\u22a2 n - length l < length l'"}, {"tactic": "exact Nat.sub_lt_left_of_lt_add h h'", "annotated_tactic": ["exact <a>Nat.sub_lt_left_of_lt_add</a> h h'", [{"full_name": "Nat.sub_lt_left_of_lt_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [765, 19], "def_end_pos": [765, 40]}]], "state_before": "case inl.hn\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : n < length l + length l'\n\u22a2 n - length l < length l'", "state_after": "no goals"}, {"tactic": "exact not_lt_of_le h", "annotated_tactic": ["exact <a>not_lt_of_le</a> h", [{"full_name": "not_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [350, 9], "def_end_pos": [350, 21]}]], "state_before": "case inl.h\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : n < length (l ++ l')\n\u22a2 \u00acn < length l", "state_after": "no goals"}, {"tactic": "rw [getD_eq_default _ _ h', getD_eq_default]", "annotated_tactic": ["rw [<a>getD_eq_default</a> _ _ h', <a>getD_eq_default</a>]", [{"full_name": "List.getD_eq_default", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/GetD.lean", "def_pos": [68, 9], "def_end_pos": [68, 24]}, {"full_name": "List.getD_eq_default", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/GetD.lean", "def_pos": [68, 9], "def_end_pos": [68, 24]}]], "state_before": "case inr\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : length (l ++ l') \u2264 n\n\u22a2 getD (l ++ l') n d = getD l' (n - length l) d", "state_after": "case inr.hn\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : length (l ++ l') \u2264 n\n\u22a2 length l' \u2264 n - length l"}, {"tactic": "rwa [le_tsub_iff_left h, \u2190 length_append]", "annotated_tactic": ["rwa [<a>le_tsub_iff_left</a> h, \u2190 <a>length_append</a>]", [{"full_name": "le_tsub_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [230, 9], "def_end_pos": [230, 25]}, {"full_name": "List.length_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [857, 17], "def_end_pos": [857, 30]}]], "state_before": "case inr.hn\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d : List \u03b1\nx : \u03b1\nxs : List \u03b1\nn\u271d : \u2115\nd\u271d : \u03b1\nl l' : List \u03b1\nd : \u03b1\nn : \u2115\nh : length l \u2264 n\nh' : length (l ++ l') \u2264 n\n\u22a2 length l' \u2264 n - length l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Types.lean", "full_name": "CategoryTheory.isIso_iff_bijective", "start": [391, 1], "end": [393, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "full_name": "MultilinearMap.zero_apply", "start": [204, 1], "end": [205, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/LocallyFinite.lean", "full_name": "LocallyFinite.point_finite", "start": [37, 1], "end": [39, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Equiv.lean", "full_name": "LinearEquiv.restrictScalars_injective", "start": [612, 1], "end": [614, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Basic.lean", "full_name": "Metric.closedEmbedding_of_pairwise_le_dist", "start": [166, 1], "end": [169, 78], "traced_tactics": [{"tactic": "simpa using hf", "annotated_tactic": ["simpa using hf", []], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\u271d\n\u03b3 : Type w\ninst\u271d\u00b2 : MetricSpace \u03b3\nx : \u03b3\ns : Set \u03b3\n\u03b1 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DiscreteTopology \u03b1\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nf : \u03b1 \u2192 \u03b3\nhf : Pairwise fun x y => \u03b5 \u2264 dist (f x) (f y)\n\u22a2 Pairwise fun x y => (f x, f y) \u2209 {p | dist p.1 p.2 < \u03b5}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "inf_compl_eq_bot'", "start": [577, 1], "end": [578, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "full_name": "Subsemigroup.map_inf_comap_of_surjective", "start": [474, 1], "end": [476, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Finset.sum_mul_sum_eq_sum_perm", "start": [1109, 1], "end": [1111, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Subsingleton.lean", "full_name": "Filter.subsingleton_iff_bot_or_pure", "start": [58, 1], "end": [61, 37], "traced_tactics": [{"tactic": "refine \u27e8fun hl \u21a6 ?_, ?_\u27e9", "annotated_tactic": ["refine \u27e8fun hl \u21a6 ?_, ?_\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\n\u22a2 Filter.Subsingleton l \u2194 l = \u22a5 \u2228 \u2203 a, l = pure a", "state_after": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\nhl : Filter.Subsingleton l\n\u22a2 l = \u22a5 \u2228 \u2203 a, l = pure a\n\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\n\u22a2 (l = \u22a5 \u2228 \u2203 a, l = pure a) \u2192 Filter.Subsingleton l"}, {"tactic": "rintro (rfl | \u27e8a, rfl\u27e9) <;> simp", "annotated_tactic": ["rintro (rfl | \u27e8a, rfl\u27e9) <;> simp", []], "state_before": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\n\u22a2 (l = \u22a5 \u2228 \u2203 a, l = pure a) \u2192 Filter.Subsingleton l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/StructuredArrow.lean", "full_name": "CategoryTheory.StructuredArrow.comp_right", "start": [94, 1], "end": [95, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "full_name": "Metric.disjoint_closedBall_of_lt_infDist", "start": [565, 1], "end": [567, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "lipschitzWith_one_nnnorm'", "start": [1239, 1], "end": [1240, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.diagonal_mul", "start": [1053, 1], "end": [1055, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.IsCycleOn.extendDomain", "start": [960, 1], "end": [964, 36], "traced_tactics": [{"tactic": "rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf\u271d g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1 \u2243 Subtype p\nh : IsCycleOn g s\n\u22a2 \u2200 \u2983x : \u03b2\u2984, x \u2208 Subtype.val \u2218 \u21d1f '' s \u2192 \u2200 \u2983y : \u03b2\u2984, y \u2208 Subtype.val \u2218 \u21d1f '' s \u2192 SameCycle (Perm.extendDomain g f) x y", "state_after": "case intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf\u271d g : Perm \u03b1\ns t : Set \u03b1\na\u271d b\u271d x y : \u03b1\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1 \u2243 Subtype p\nh : IsCycleOn g s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\n\u22a2 SameCycle (Perm.extendDomain g f) ((Subtype.val \u2218 \u21d1f) a) ((Subtype.val \u2218 \u21d1f) b)"}, {"tactic": "exact (h.2 ha hb).extendDomain", "annotated_tactic": ["exact (h.2 ha hb).<a>extendDomain</a>", [{"full_name": "Equiv.Perm.SameCycle.extendDomain", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "def_pos": [224, 11], "def_end_pos": [224, 33]}]], "state_before": "case intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf\u271d g : Perm \u03b1\ns t : Set \u03b1\na\u271d b\u271d x y : \u03b1\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1 \u2243 Subtype p\nh : IsCycleOn g s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\n\u22a2 SameCycle (Perm.extendDomain g f) ((Subtype.val \u2218 \u21d1f) a) ((Subtype.val \u2218 \u21d1f) b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "IsGLB.union", "start": [458, 1], "end": [460, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Injective.of_comp_iff'", "start": [142, 1], "end": [144, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Ring.lean", "full_name": "HasSum.mul_eq", "start": [155, 1], "end": [160, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Basic.lean", "full_name": "MulAction.smul_orbit", "start": [314, 1], "end": [318, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "AddEquiv.mapMatrix_refl", "start": [1451, 1], "end": [1452, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.refl_trans", "start": [917, 1], "end": [919, 6], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : LE \u03b2\ninst\u271d : LE \u03b3\ne : \u03b1 \u2243o \u03b2\n\u22a2 trans (refl \u03b1) e = e", "state_after": "case h.h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : LE \u03b2\ninst\u271d : LE \u03b3\ne : \u03b1 \u2243o \u03b2\nx : \u03b1\n\u22a2 (trans (refl \u03b1) e) x = e x"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : LE \u03b2\ninst\u271d : LE \u03b3\ne : \u03b1 \u2243o \u03b2\nx : \u03b1\n\u22a2 (trans (refl \u03b1) e) x = e x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Nilpotent.lean", "full_name": "Polynomial.isNilpotent_mul_X_iff", "start": [59, 1], "end": [62, 30], "traced_tactics": [{"tactic": "rw [\u2190 commute_X P]", "annotated_tactic": ["rw [\u2190 <a>commute_X</a> P]", [{"full_name": "Polynomial.commute_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [631, 9], "def_end_pos": [631, 18]}]], "state_before": "R : Type u_1\nr : R\ninst\u271d : Semiring R\nP : R[X]\n\u22a2 IsNilpotent (P * X) \u2194 IsNilpotent P", "state_after": "R : Type u_1\nr : R\ninst\u271d : Semiring R\nP : R[X]\n\u22a2 IsNilpotent (X * P) \u2194 IsNilpotent P"}, {"tactic": "exact isNilpotent_X_mul_iff", "annotated_tactic": ["exact <a>isNilpotent_X_mul_iff</a>", [{"full_name": "Polynomial.isNilpotent_X_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Nilpotent.lean", "def_pos": [52, 15], "def_end_pos": [52, 36]}]], "state_before": "R : Type u_1\nr : R\ninst\u271d : Semiring R\nP : R[X]\n\u22a2 IsNilpotent (X * P) \u2194 IsNilpotent P", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Associates.one_eq_mk_one", "start": [839, 1], "end": [840, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Segment.lean", "full_name": "openSegment_subset_segment", "start": [88, 1], "end": [89, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AddTorsor.lean", "full_name": "nndist_homothety_center", "start": [64, 1], "end": [66, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "eq_bot_of_isCompl_top", "start": [655, 1], "end": [656, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "full_name": "AffineBasis.surjective_coord", "start": [255, 1], "end": [264, 53], "traced_tactics": [{"tactic": "classical\n  intro x\n  obtain \u27e8j, hij\u27e9 := exists_ne i\n  let s : Finset \u03b9 := {i, j}\n  have hi : i \u2208 s := by simp [s]\n  let w : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x\n  have hw : s.sum w = 1 := by simp [s, w, Finset.sum_ite, Finset.filter_insert, hij]\n  use s.affineCombination k b w\n  simp [w, b.coord_apply_combination_of_mem hi hw]", "annotated_tactic": ["classical\n    intro x\n    obtain \u27e8j, hij\u27e9 := <a>exists_ne</a> i\n    let s : <a>Finset</a> \u03b9 := {i, j}\n    have hi : i \u2208 s := by simp [s]\n    let w : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x\n    have hw : s.sum w = 1 := by simp [s, w, <a>Finset.sum_ite</a>, <a>Finset.filter_insert</a>, hij]\n    use s.affineCombination k b w\n    simp [w, b.coord_apply_combination_of_mem hi hw]", [{"full_name": "exists_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [53, 9], "def_end_pos": [53, 18]}, {"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}, {"full_name": "Finset.sum_ite", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1140, 3], "def_end_pos": [1140, 14]}, {"full_name": "Finset.filter_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2985, 9], "def_end_pos": [2985, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns : Finset \u03b9\ni\u271d j : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\n\u22a2 Function.Surjective \u21d1(coord b i)", "state_after": "no goals"}, {"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns : Finset \u03b9\ni\u271d j : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\n\u22a2 Function.Surjective \u21d1(coord b i)", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns : Finset \u03b9\ni\u271d j : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\n\u22a2 \u2203 a, (coord b i) a = x"}, {"tactic": "obtain \u27e8j, hij\u27e9 := exists_ne i", "annotated_tactic": ["obtain \u27e8j, hij\u27e9 := <a>exists_ne</a> i", [{"full_name": "exists_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [53, 9], "def_end_pos": [53, 18]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns : Finset \u03b9\ni\u271d j : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\n\u22a2 \u2203 a, (coord b i) a = x", "state_after": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\n\u22a2 \u2203 a, (coord b i) a = x"}, {"tactic": "let s : Finset \u03b9 := {i, j}", "annotated_tactic": ["let s : <a>Finset</a> \u03b9 := {i, j}", [{"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}]], "state_before": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\n\u22a2 \u2203 a, (coord b i) a = x", "state_after": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\n\u22a2 \u2203 a, (coord b i) a = x"}, {"tactic": "have hi : i \u2208 s := by simp [s]", "annotated_tactic": ["have hi : i \u2208 s := by simp [s]", []], "state_before": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\n\u22a2 \u2203 a, (coord b i) a = x", "state_after": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\nhi : i \u2208 s\n\u22a2 \u2203 a, (coord b i) a = x"}, {"tactic": "let w : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x", "annotated_tactic": ["let w : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x", []], "state_before": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\nhi : i \u2208 s\n\u22a2 \u2203 a, (coord b i) a = x", "state_after": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\nhi : i \u2208 s\nw : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x\n\u22a2 \u2203 a, (coord b i) a = x"}, {"tactic": "have hw : s.sum w = 1 := by simp [s, w, Finset.sum_ite, Finset.filter_insert, hij]", "annotated_tactic": ["have hw : s.sum w = 1 := by simp [s, w, <a>Finset.sum_ite</a>, <a>Finset.filter_insert</a>, hij]", [{"full_name": "Finset.sum_ite", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1140, 3], "def_end_pos": [1140, 14]}, {"full_name": "Finset.filter_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2985, 9], "def_end_pos": [2985, 22]}]], "state_before": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\nhi : i \u2208 s\nw : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x\n\u22a2 \u2203 a, (coord b i) a = x", "state_after": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\nhi : i \u2208 s\nw : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x\nhw : Finset.sum s w = 1\n\u22a2 \u2203 a, (coord b i) a = x"}, {"tactic": "use s.affineCombination k b w", "annotated_tactic": ["use s.affineCombination k b w", []], "state_before": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\nhi : i \u2208 s\nw : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x\nhw : Finset.sum s w = 1\n\u22a2 \u2203 a, (coord b i) a = x", "state_after": "case h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\nhi : i \u2208 s\nw : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x\nhw : Finset.sum s w = 1\n\u22a2 (coord b i) ((Finset.affineCombination k s \u21d1b) w) = x"}, {"tactic": "simp [w, b.coord_apply_combination_of_mem hi hw]", "annotated_tactic": ["simp [w, b.coord_apply_combination_of_mem hi hw]", []], "state_before": "case h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\nhi : i \u2208 s\nw : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x\nhw : Finset.sum s w = 1\n\u22a2 (coord b i) ((Finset.affineCombination k s \u21d1b) w) = x", "state_after": "no goals"}, {"tactic": "simp [s]", "annotated_tactic": ["simp [s]", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\n\u22a2 i \u2208 s", "state_after": "no goals"}, {"tactic": "simp [s, w, Finset.sum_ite, Finset.filter_insert, hij]", "annotated_tactic": ["simp [s, w, <a>Finset.sum_ite</a>, <a>Finset.filter_insert</a>, hij]", [{"full_name": "Finset.sum_ite", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1140, 3], "def_end_pos": [1140, 14]}, {"full_name": "Finset.filter_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2985, 9], "def_end_pos": [2985, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : AffineSpace V P\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : Module k V\nb : AffineBasis \u03b9 k P\ns\u271d : Finset \u03b9\ni\u271d j\u271d : \u03b9\ne : \u03b9 \u2243 \u03b9'\ninst\u271d : Nontrivial \u03b9\ni : \u03b9\nx : k\nj : \u03b9\nhij : j \u2260 i\ns : Finset \u03b9 := {i, j}\nhi : i \u2208 s\nw : \u03b9 \u2192 k := fun j' => if j' = i then x else 1 - x\n\u22a2 Finset.sum s w = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsCoprime.of_add_mul_left_right", "start": [209, 1], "end": [211, 31], "traced_tactics": [{"tactic": "rw [isCoprime_comm] at h \u22a2", "annotated_tactic": ["rw [<a>isCoprime_comm</a>] at h \u22a2", [{"full_name": "isCoprime_comm", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Coprime/Basic.lean", "def_pos": [52, 9], "def_end_pos": [52, 23]}]], "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (y + x * z)\n\u22a2 IsCoprime x y", "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime (y + x * z) x\n\u22a2 IsCoprime y x"}, {"tactic": "exact h.of_add_mul_left_left", "annotated_tactic": ["exact h.of_add_mul_left_left", []], "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime (y + x * z) x\n\u22a2 IsCoprime y x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Image.lean", "full_name": "Set.image_subtype_val_Ico_subset", "start": [263, 1], "end": [265, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Finset.range_add", "start": [630, 1], "end": [632, 40], "traced_tactics": [{"tactic": "rw [\u2190 val_inj, union_val]", "annotated_tactic": ["rw [\u2190 <a>val_inj</a>, <a>union_val</a>]", [{"full_name": "Finset.val_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [161, 9], "def_end_pos": [161, 16]}, {"full_name": "Finset.union_val", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1403, 9], "def_end_pos": [1403, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb\u271d c : \u03b2\na b : \u2115\n\u22a2 range (a + b) = range a \u222a map (addLeftEmbedding a) (range b)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb\u271d c : \u03b2\na b : \u2115\n\u22a2 (range (a + b)).val = (range a).val \u222a (map (addLeftEmbedding a) (range b)).val"}, {"tactic": "exact Multiset.range_add_eq_union a b", "annotated_tactic": ["exact <a>Multiset.range_add_eq_union</a> a b", [{"full_name": "Multiset.range_add_eq_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Range.lean", "def_pos": [73, 9], "def_end_pos": [73, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb\u271d c : \u03b2\na b : \u2115\n\u22a2 (range (a + b)).val = (range a).val \u222a (map (addLeftEmbedding a) (range b)).val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/PartialSups.lean", "full_name": "iSup_le_iSup_of_partialSups_le_partialSups", "start": [188, 1], "end": [191, 20], "traced_tactics": [{"tactic": "rw [\u2190 iSup_partialSups_eq f, \u2190 iSup_partialSups_eq g]", "annotated_tactic": ["rw [\u2190 <a>iSup_partialSups_eq</a> f, \u2190 <a>iSup_partialSups_eq</a> g]", [{"full_name": "iSup_partialSups_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/PartialSups.lean", "def_pos": [184, 9], "def_end_pos": [184, 28]}, {"full_name": "iSup_partialSups_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/PartialSups.lean", "def_pos": [184, 9], "def_end_pos": [184, 28]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf g : \u2115 \u2192 \u03b1\nh : partialSups f \u2264 partialSups g\n\u22a2 \u2a06 n, f n \u2264 \u2a06 n, g n", "state_after": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf g : \u2115 \u2192 \u03b1\nh : partialSups f \u2264 partialSups g\n\u22a2 \u2a06 n, (partialSups f) n \u2264 \u2a06 n, (partialSups g) n"}, {"tactic": "exact iSup_mono h", "annotated_tactic": ["exact <a>iSup_mono</a> h", [{"full_name": "iSup_mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [789, 9], "def_end_pos": [789, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf g : \u2115 \u2192 \u03b1\nh : partialSups f \u2264 partialSups g\n\u22a2 \u2a06 n, (partialSups f) n \u2264 \u2a06 n, (partialSups g) n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pointwise.lean", "full_name": "Filter.top_pow", "start": [739, 1], "end": [742, 76], "traced_tactics": [{"tactic": "rw [pow_succ, top_pow n.succ_ne_zero, top_mul_top]", "annotated_tactic": ["rw [<a>pow_succ</a>, top_pow n.succ_ne_zero, <a>top_mul_top</a>]", [{"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}, {"full_name": "Filter.top_mul_top", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Pointwise.lean", "def_pos": [733, 9], "def_end_pos": [733, 20]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\n\u03b5 : Type u_6\ninst\u271d : Monoid \u03b1\nf g : Filter \u03b1\ns : Set \u03b1\na : \u03b1\nm n\u271d n : \u2115\nx\u271d : n + 2 \u2260 0\n\u22a2 \u22a4 ^ (n + 2) = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "full_name": "Real.rpow_logb_of_neg", "start": [146, 1], "end": [148, 22], "traced_tactics": [{"tactic": "rw [rpow_logb_eq_abs b_pos b_ne_one (ne_of_lt hx)]", "annotated_tactic": ["rw [<a>rpow_logb_eq_abs</a> b_pos b_ne_one (<a>ne_of_lt</a> hx)]", [{"full_name": "Real.rpow_logb_eq_abs", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "def_pos": [131, 9], "def_end_pos": [131, 25]}, {"full_name": "ne_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [95, 9], "def_end_pos": [95, 17]}]], "state_before": "b x y : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhx : x < 0\n\u22a2 b ^ logb b x = -x", "state_after": "b x y : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhx : x < 0\n\u22a2 |x| = -x"}, {"tactic": "exact abs_of_neg hx", "annotated_tactic": ["exact <a>abs_of_neg</a> hx", [{"full_name": "abs_of_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [107, 3], "def_end_pos": [107, 14]}]], "state_before": "b x y : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhx : x < 0\n\u22a2 |x| = -x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "full_name": "tsum_eq_sum'", "start": [317, 1], "end": [319, 87], "traced_tactics": [{"tactic": "rw [tsum_eq_finsum (s.finite_toSet.subset hf), finsum_eq_sum_of_support_subset _ hf]", "annotated_tactic": ["rw [<a>tsum_eq_finsum</a> (s.finite_toSet.subset hf), <a>finsum_eq_sum_of_support_subset</a> _ hf]", [{"full_name": "tsum_eq_finsum", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "def_pos": [314, 9], "def_end_pos": [314, 23]}, {"full_name": "finsum_eq_sum_of_support_subset", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na a\u2081 a\u2082 : \u03b1\ns : Finset \u03b2\nhf : support f \u2286 \u2191s\n\u22a2 \u2211' (b : \u03b2), f b = \u2211 b in s, f b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "full_name": "CategoryTheory.Limits.coprod.map_codiag", "start": [954, 1], "end": [955, 56], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nf : X \u27f6 Y\ninst\u271d\u00b9 : HasBinaryCoproduct X X\ninst\u271d : HasBinaryCoproduct Y Y\n\u22a2 map f f \u226b codiag Y = codiag X \u226b f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "IsGLB.mem_of_isClosed", "start": [1344, 1], "end": [1346, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Quot.lean", "full_name": "Quotient.forall", "start": [307, 1], "end": [309, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.size_modifyM", "start": [293, 1], "end": [297, 20], "traced_tactics": [{"tactic": "unfold modifyM", "annotated_tactic": ["unfold <a>modifyM</a>", [{"full_name": "Array.modifyM", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [154, 5], "def_end_pos": [154, 12]}]], "state_before": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\na : Array \u03b1\ni : Nat\nf : \u03b1 \u2192 m \u03b1\n\u22a2 SatisfiesM (fun x => size x = size a) (modifyM a i f)", "state_after": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\na : Array \u03b1\ni : Nat\nf : \u03b1 \u2192 m \u03b1\n\u22a2 SatisfiesM (fun x => size x = size a)\n    (if h : i < size a then\n      let idx := { val := i, isLt := h };\n      let v := get a idx;\n      do\n      let v \u2190 f v\n      pure (set a idx v)\n    else pure a)"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\na : Array \u03b1\ni : Nat\nf : \u03b1 \u2192 m \u03b1\n\u22a2 SatisfiesM (fun x => size x = size a)\n    (if h : i < size a then\n      let idx := { val := i, isLt := h };\n      let v := get a idx;\n      do\n      let v \u2190 f v\n      pure (set a idx v)\n    else pure a)", "state_after": "case inl\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\na : Array \u03b1\ni : Nat\nf : \u03b1 \u2192 m \u03b1\nh\u271d : i < size a\n\u22a2 SatisfiesM (fun x => size x = size a)\n    (let idx := { val := i, isLt := h\u271d };\n    let v := get a idx;\n    do\n    let v \u2190 f v\n    pure (set a idx v))\n\ncase inr\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\na : Array \u03b1\ni : Nat\nf : \u03b1 \u2192 m \u03b1\nh\u271d : \u00aci < size a\n\u22a2 SatisfiesM (fun x => size x = size a) (pure a)"}, {"tactic": "exact .bind_pre <| .of_true fun _ => .pure <| by simp only [size_set]", "annotated_tactic": ["exact .bind_pre <| .of_true fun _ => .pure <| by simp only [<a>size_set</a>]", [{"full_name": "Array.size_set", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [76, 17], "def_end_pos": [76, 25]}]], "state_before": "case inl\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\na : Array \u03b1\ni : Nat\nf : \u03b1 \u2192 m \u03b1\nh\u271d : i < size a\n\u22a2 SatisfiesM (fun x => size x = size a)\n    (let idx := { val := i, isLt := h\u271d };\n    let v := get a idx;\n    do\n    let v \u2190 f v\n    pure (set a idx v))", "state_after": "no goals"}, {"tactic": "simp only [size_set]", "annotated_tactic": ["simp only [<a>size_set</a>]", [{"full_name": "Array.size_set", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [76, 17], "def_end_pos": [76, 25]}]], "state_before": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\na : Array \u03b1\ni : Nat\nf : \u03b1 \u2192 m \u03b1\nh\u271d : i < size a\nx\u271d : \u03b1\n\u22a2 size (set a { val := i, isLt := h\u271d } x\u271d) = size a", "state_after": "no goals"}, {"tactic": "exact .pure rfl", "annotated_tactic": ["exact .pure <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case inr\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\na : Array \u03b1\ni : Nat\nf : \u03b1 \u2192 m \u03b1\nh\u271d : \u00aci < size a\n\u22a2 SatisfiesM (fun x => size x = size a) (pure a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Pi/Basic.lean", "full_name": "Sum.elim_mulSingle_one", "start": [591, 1], "end": [593, 63], "traced_tactics": [{"tactic": "simp only [Pi.mulSingle, Sum.elim_update_left, elim_one_one]", "annotated_tactic": ["simp only [<a>Pi.mulSingle</a>, <a>Sum.elim_update_left</a>, <a>elim_one_one</a>]", [{"full_name": "Pi.mulSingle", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [358, 5], "def_end_pos": [358, 14]}, {"full_name": "Sum.elim_update_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sum/Basic.lean", "def_pos": [332, 9], "def_end_pos": [332, 25]}, {"full_name": "Sum.elim_one_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [585, 9], "def_end_pos": [585, 21]}]], "state_before": "I : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx y : (i : I) \u2192 f i\ni\u271d : I\na a' : \u03b1 \u2192 \u03b3\nb b' : \u03b2 \u2192 \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : One \u03b3\ni : \u03b1\nc : \u03b3\n\u22a2 Sum.elim (Pi.mulSingle i c) 1 = Pi.mulSingle (inl i) c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/DirectSum/Basic.lean", "full_name": "DirectSum.support_of_subset", "start": [141, 1], "end": [143, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "norm_iteratedFDeriv_zero", "start": [1542, 1], "end": [1544, 77], "traced_tactics": [{"tactic": "rw [iteratedFDeriv_zero_eq_comp, comp_apply, LinearIsometryEquiv.norm_map]", "annotated_tactic": ["rw [<a>iteratedFDeriv_zero_eq_comp</a>, <a>comp_apply</a>, <a>LinearIsometryEquiv.norm_map</a>]", [{"full_name": "iteratedFDeriv_zero_eq_comp", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [1536, 9], "def_end_pos": [1536, 36]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "LinearIsometryEquiv.norm_map", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "def_pos": [614, 9], "def_end_pos": [614, 17]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\n\u22a2 \u2016iteratedFDeriv \ud835\udd5c 0 f x\u2016 = \u2016f x\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_finset_product_right'", "start": [804, 1], "end": [807, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/NNReal.lean", "full_name": "Real.toNNReal_eq_ofNat", "start": [672, 1], "end": [675, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "full_name": "Matrix.charpoly_natDegree_eq_dim", "start": [122, 9], "end": [124, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Group.lean", "full_name": "Set.pairwise_disjoint_Ioo_zpow", "start": [223, 1], "end": [225, 64], "traced_tactics": [{"tactic": "simpa only [one_mul] using pairwise_disjoint_Ioo_mul_zpow 1 b", "annotated_tactic": ["simpa only [<a>one_mul</a>] using <a>pairwise_disjoint_Ioo_mul_zpow</a> 1 b", [{"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "Set.pairwise_disjoint_Ioo_mul_zpow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Group.lean", "def_pos": [202, 9], "def_end_pos": [202, 39]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\n\u22a2 Pairwise (Disjoint on fun n => Ioo (b ^ n) (b ^ (n + 1)))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "map_one", "start": [203, 1], "end": [204, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.sup_sets_eq", "start": [546, 1], "end": [547, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Bool/Set.lean", "full_name": "Bool.compl_singleton", "start": [32, 9], "end": [33, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Size.lean", "full_name": "Nat.shiftLeft_eq_mul_pow", "start": [20, 1], "end": [20, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bases.lean", "full_name": "TopologicalSpace.IsTopologicalBasis.isOpen_iff", "start": [156, 1], "end": [157, 97], "traced_tactics": [{"tactic": "simp [isOpen_iff_mem_nhds, hb.mem_nhds_iff]", "annotated_tactic": ["simp [<a>isOpen_iff_mem_nhds</a>, hb.mem_nhds_iff]", [{"full_name": "isOpen_iff_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1183, 9], "def_end_pos": [1183, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\nt : TopologicalSpace \u03b1\nB : Set (Set \u03b1)\ns\u271d s : Set \u03b1\nb : Set (Set \u03b1)\nhb : IsTopologicalBasis b\n\u22a2 IsOpen s \u2194 \u2200 a \u2208 s, \u2203 t \u2208 b, a \u2208 t \u2227 t \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "IsGreatest.isLeast_image2_of_isLeast", "start": [1560, 1], "end": [1563, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "full_name": "Matrix.nonsing_inv_apply", "start": [219, 1], "end": [220, 61], "traced_tactics": [{"tactic": "rw [inv_def, \u2190 Ring.inverse_unit h.unit, IsUnit.unit_spec]", "annotated_tactic": ["rw [<a>inv_def</a>, \u2190 <a>Ring.inverse_unit</a> h.unit, <a>IsUnit.unit_spec</a>]", [{"full_name": "Matrix.inv_def", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "def_pos": [211, 9], "def_end_pos": [211, 16]}, {"full_name": "Ring.inverse_unit", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [93, 9], "def_end_pos": [93, 21]}, {"full_name": "IsUnit.unit_spec", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [819, 9], "def_end_pos": [819, 18]}]], "state_before": "l : Type u_1\nm : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : CommRing \u03b1\nA B : Matrix n n \u03b1\nh : IsUnit (det A)\n\u22a2 A\u207b\u00b9 = \u2191(IsUnit.unit h)\u207b\u00b9 \u2022 adjugate A", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Cauchy.lean", "full_name": "completeSpace_of_isComplete_univ", "start": [457, 1], "end": [458, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bases.lean", "full_name": "TopologicalSpace.isSeparable_univ_iff", "start": [546, 1], "end": [547, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.Iio_succ_eq_insert_of_not_isMax", "start": [462, 1], "end": [463, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.ofBijective_apply", "start": [555, 1], "end": [557, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Function.lean", "full_name": "ConcaveOn.right_le_of_le_left'", "start": [734, 1], "end": [737, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/PiSystem.lean", "full_name": "subset_piiUnionInter", "start": [484, 1], "end": [492, 30], "traced_tactics": [{"tactic": "have h_ss : {i} \u2286 S := by\n  intro j hj\n  rw [mem_singleton_iff] at hj\n  rwa [hj]", "annotated_tactic": ["have h_ss : {i} \u2286 S := by\n    intro j hj\n    rw [<a>mem_singleton_iff</a>] at hj\n    rwa [hj]", [{"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\n\u22a2 \u03c0 i \u2286 piiUnionInter \u03c0 S", "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nh_ss : {i} \u2286 S\n\u22a2 \u03c0 i \u2286 piiUnionInter \u03c0 S"}, {"tactic": "refine' Subset.trans _ (piiUnionInter_mono_right h_ss)", "annotated_tactic": ["refine' <a>Subset.trans</a> _ (<a>piiUnionInter_mono_right</a> h_ss)", [{"full_name": "Set.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [343, 9], "def_end_pos": [343, 21]}, {"full_name": "piiUnionInter_mono_right", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/PiSystem.lean", "def_pos": [471, 9], "def_end_pos": [471, 33]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nh_ss : {i} \u2286 S\n\u22a2 \u03c0 i \u2286 piiUnionInter \u03c0 S", "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nh_ss : {i} \u2286 S\n\u22a2 \u03c0 i \u2286 piiUnionInter \u03c0 {i}"}, {"tactic": "rw [piiUnionInter_singleton]", "annotated_tactic": ["rw [<a>piiUnionInter_singleton</a>]", [{"full_name": "piiUnionInter_singleton", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/PiSystem.lean", "def_pos": [366, 9], "def_end_pos": [366, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nh_ss : {i} \u2286 S\n\u22a2 \u03c0 i \u2286 piiUnionInter \u03c0 {i}", "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nh_ss : {i} \u2286 S\n\u22a2 \u03c0 i \u2286 \u03c0 i \u222a {univ}"}, {"tactic": "exact subset_union_left _ _", "annotated_tactic": ["exact <a>subset_union_left</a> _ _", [{"full_name": "Set.subset_union_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [799, 9], "def_end_pos": [799, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nh_ss : {i} \u2286 S\n\u22a2 \u03c0 i \u2286 \u03c0 i \u222a {univ}", "state_after": "no goals"}, {"tactic": "intro j hj", "annotated_tactic": ["intro j hj", []], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\n\u22a2 {i} \u2286 S", "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nj : \u03b9\nhj : j \u2208 {i}\n\u22a2 j \u2208 S"}, {"tactic": "rw [mem_singleton_iff] at hj", "annotated_tactic": ["rw [<a>mem_singleton_iff</a>] at hj", [{"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nj : \u03b9\nhj : j \u2208 {i}\n\u22a2 j \u2208 S", "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nj : \u03b9\nhj : j = i\n\u22a2 j \u2208 S"}, {"tactic": "rwa [hj]", "annotated_tactic": ["rwa [hj]", []], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nj : \u03b9\nhj : j = i\n\u22a2 j \u2208 S", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Defs.lean", "full_name": "smul_le_smul_of_nonneg_left", "start": [260, 1], "end": [261, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "Disjoint.le_sdiff_of_le_left", "start": [659, 1], "end": [660, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.map_concat", "start": [1742, 1], "end": [1744, 87], "traced_tactics": [{"tactic": "induction l <;> [rfl; simp only [*, concat_eq_append, cons_append, map, map_append]]", "annotated_tactic": ["induction l <;> [rfl; simp only [*, <a>concat_eq_append</a>, <a>cons_append</a>, <a>map</a>, <a>map_append</a>]]", [{"full_name": "List.concat_eq_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [944, 9], "def_end_pos": [944, 25]}, {"full_name": "List.cons_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [139, 17], "def_end_pos": [139, 28]}, {"full_name": "List.map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [191, 19], "def_end_pos": [191, 22]}, {"full_name": "List.map_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [120, 17], "def_end_pos": [120, 27]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nl : List \u03b1\n\u22a2 map f (concat l a) = concat (map f l) (f a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_finset_product", "start": [778, 1], "end": [782, 64], "traced_tactics": [{"tactic": "refine' Eq.trans _ (prod_sigma s t fun p => f (p.1, p.2))", "annotated_tactic": ["refine' <a>Eq.trans</a> _ (<a>prod_sigma</a> s t fun p => f (p.1, p.2))", [{"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}, {"full_name": "Finset.prod_sigma", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [588, 9], "def_end_pos": [588, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\nr : Finset (\u03b3 \u00d7 \u03b1)\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nh : \u2200 (p : \u03b3 \u00d7 \u03b1), p \u2208 r \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t p.1\nf : \u03b3 \u00d7 \u03b1 \u2192 \u03b2\n\u22a2 \u220f p in r, f p = \u220f c in s, \u220f a in t c, f (c, a)", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\nr : Finset (\u03b3 \u00d7 \u03b1)\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nh : \u2200 (p : \u03b3 \u00d7 \u03b1), p \u2208 r \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t p.1\nf : \u03b3 \u00d7 \u03b1 \u2192 \u03b2\n\u22a2 \u220f p in r, f p = \u220f x in Finset.sigma s t, f (x.fst, x.snd)"}, {"tactic": "apply prod_equiv (Equiv.sigmaEquivProd _ _).symm <;> simp [h]", "annotated_tactic": ["apply <a>prod_equiv</a> (<a>Equiv.sigmaEquivProd</a> _ _).<a>symm</a> <;> simp [h]", [{"full_name": "Finset.prod_equiv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [701, 7], "def_end_pos": [701, 17]}, {"full_name": "Equiv.sigmaEquivProd", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [846, 5], "def_end_pos": [846, 19]}, {"full_name": "Equiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [166, 15], "def_end_pos": [166, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\nr : Finset (\u03b3 \u00d7 \u03b1)\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nh : \u2200 (p : \u03b3 \u00d7 \u03b1), p \u2208 r \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t p.1\nf : \u03b3 \u00d7 \u03b1 \u2192 \u03b2\n\u22a2 \u220f p in r, f p = \u220f x in Finset.sigma s t, f (x.fst, x.snd)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Hom.lean", "full_name": "NormedAddGroupHom.toFun_eq_coe", "start": [123, 1], "end": [124, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.div_eq_empty", "start": [637, 1], "end": [638, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "MeasurableEquiv.ofInvolutive_apply", "start": [1819, 9], "end": [1820, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ico_union_Ico_eq_Ico", "start": [1532, 1], "end": [1535, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Operations.lean", "full_name": "Submonoid.comap_map_eq_of_injective", "start": [383, 1], "end": [384, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "biInf_congr", "start": [650, 1], "end": [652, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Semicontinuous.lean", "full_name": "Continuous.comp_lowerSemicontinuous", "start": [412, 1], "end": [414, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "full_name": "summable_norm_iff", "start": [690, 1], "end": [708, 53], "traced_tactics": [{"tactic": "refine \u27e8Summable.of_norm, fun hf \u21a6 ?_\u27e9", "annotated_tactic": ["refine \u27e8<a>Summable.of_norm</a>, fun hf \u21a6 ?_\u27e9", [{"full_name": "Summable.of_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/InfiniteSum.lean", "def_pos": [179, 9], "def_end_pos": [179, 25]}]], "state_before": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\n\u22a2 (Summable fun x => \u2016f x\u2016) \u2194 Summable f", "state_after": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\n\u22a2 Summable fun x => \u2016f x\u2016"}, {"tactic": "suffices \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016 by\n  obtain v := finBasis \u211d E\n  set e := v.equivFunL\n  have H : Summable fun x => \u2016e (f x)\u2016 := this (e.summable.2 hf)\n  refine .of_norm_bounded _ (H.mul_left \u2191\u2016(e.symm : (Fin (finrank \u211d E) \u2192 \u211d) \u2192L[\u211d] E)\u2016\u208a) fun i \u21a6 ?_\n  simpa using (e.symm : (Fin (finrank \u211d E) \u2192 \u211d) \u2192L[\u211d] E).le_opNorm (e <| f i)", "annotated_tactic": ["suffices \u2200 {N : \u2115} {g : \u03b1 \u2192 <a>Fin</a> N \u2192 \u211d}, <a>Summable</a> g \u2192 <a>Summable</a> fun x => \u2016g x\u2016 by\n    obtain v := <a>finBasis</a> \u211d E\n    set e := v.equivFunL\n    have H : <a>Summable</a> fun x => \u2016e (f x)\u2016 := this (e.summable.2 hf)\n    refine .of_norm_bounded _ (H.mul_left \u2191\u2016(e.symm : (<a>Fin</a> (<a>finrank</a> \u211d E) \u2192 \u211d) \u2192L[\u211d] E)\u2016\u208a) fun i \u21a6 ?_\n    simpa using (e.symm : (<a>Fin</a> (<a>finrank</a> \u211d E) \u2192 \u211d) \u2192L[\u211d] E).<a>le_opNorm</a> (e <| f i)", [{"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}, {"full_name": "Summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [64, 5], "def_end_pos": [64, 13]}, {"full_name": "Summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [64, 5], "def_end_pos": [64, 13]}, {"full_name": "FiniteDimensional.finBasis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Free.lean", "def_pos": [212, 19], "def_end_pos": [212, 27]}, {"full_name": "Summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [64, 5], "def_end_pos": [64, 13]}, {"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}, {"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}, {"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}, {"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}, {"full_name": "ContinuousLinearMap.le_opNorm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean", "def_pos": [236, 9], "def_end_pos": [236, 18]}]], "state_before": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\n\u22a2 Summable fun x => \u2016f x\u2016", "state_after": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\n\u22a2 \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016"}, {"tactic": "clear! E", "annotated_tactic": ["clear! E", []], "state_before": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\n\u22a2 \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016", "state_after": "\u03b1 : Type u_1\n\u22a2 \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016"}, {"tactic": "intro N g hg", "annotated_tactic": ["intro N g hg", []], "state_before": "\u03b1 : Type u_1\n\u22a2 \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016", "state_after": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\n\u22a2 Summable fun x => \u2016g x\u2016"}, {"tactic": "have : \u2200 i, Summable fun x => \u2016g x i\u2016 := fun i => (Pi.summable.1 hg i).abs", "annotated_tactic": ["have : \u2200 i, <a>Summable</a> fun x => \u2016g x i\u2016 := fun i => (<a>Pi.summable</a>.1 hg i).<a>abs</a>", [{"full_name": "Summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [64, 5], "def_end_pos": [64, 13]}, {"full_name": "Pi.summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "def_pos": [196, 9], "def_end_pos": [196, 20]}, {"full_name": "Summable.abs", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "def_pos": [259, 25], "def_end_pos": [259, 37]}]], "state_before": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\n\u22a2 Summable fun x => \u2016g x\u2016", "state_after": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\n\u22a2 Summable fun x => \u2016g x\u2016"}, {"tactic": "refine' .of_norm_bounded _ (summable_sum fun i (_ : i \u2208 Finset.univ) => this i) fun x => _", "annotated_tactic": ["refine' .of_norm_bounded _ (<a>summable_sum</a> fun i (_ : i \u2208 <a>Finset.univ</a>) => this i) fun x => _", [{"full_name": "summable_sum", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "def_pos": [227, 9], "def_end_pos": [227, 21]}, {"full_name": "Finset.univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [68, 5], "def_end_pos": [68, 9]}]], "state_before": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\n\u22a2 Summable fun x => \u2016g x\u2016", "state_after": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\nx : \u03b1\n\u22a2 \u2016\u2016g x\u2016\u2016 \u2264 \u2211 i : Fin N, \u2016g x i\u2016"}, {"tactic": "rw [norm_norm, pi_norm_le_iff_of_nonneg]", "annotated_tactic": ["rw [<a>norm_norm</a>, <a>pi_norm_le_iff_of_nonneg</a>]", [{"full_name": "norm_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Field/Basic.lean", "def_pos": [1079, 9], "def_end_pos": [1079, 18]}, {"full_name": "pi_norm_le_iff_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2605, 15], "def_end_pos": [2605, 39]}]], "state_before": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\nx : \u03b1\n\u22a2 \u2016\u2016g x\u2016\u2016 \u2264 \u2211 i : Fin N, \u2016g x i\u2016", "state_after": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\nx : \u03b1\n\u22a2 \u2200 (i : Fin N), \u2016g x i\u2016 \u2264 \u2211 i : Fin N, \u2016g x i\u2016\n\n\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\nx : \u03b1\n\u22a2 0 \u2264 \u2211 i : Fin N, \u2016g x i\u2016"}, {"tactic": "obtain v := finBasis \u211d E", "annotated_tactic": ["obtain v := <a>finBasis</a> \u211d E", [{"full_name": "FiniteDimensional.finBasis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Free.lean", "def_pos": [212, 19], "def_end_pos": [212, 27]}]], "state_before": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\nthis : \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016\n\u22a2 Summable fun x => \u2016f x\u2016", "state_after": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\nthis : \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016\nv : Basis (Fin (finrank \u211d E)) \u211d E\n\u22a2 Summable fun x => \u2016f x\u2016"}, {"tactic": "set e := v.equivFunL", "annotated_tactic": ["set e := v.equivFunL", []], "state_before": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\nthis : \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016\nv : Basis (Fin (finrank \u211d E)) \u211d E\n\u22a2 Summable fun x => \u2016f x\u2016", "state_after": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\nthis : \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016\nv : Basis (Fin (finrank \u211d E)) \u211d E\ne : E \u2243L[\u211d] Fin (finrank \u211d E) \u2192 \u211d := Basis.equivFunL v\n\u22a2 Summable fun x => \u2016f x\u2016"}, {"tactic": "have H : Summable fun x => \u2016e (f x)\u2016 := this (e.summable.2 hf)", "annotated_tactic": ["have H : <a>Summable</a> fun x => \u2016e (f x)\u2016 := this (e.summable.2 hf)", [{"full_name": "Summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [64, 5], "def_end_pos": [64, 13]}]], "state_before": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\nthis : \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016\nv : Basis (Fin (finrank \u211d E)) \u211d E\ne : E \u2243L[\u211d] Fin (finrank \u211d E) \u2192 \u211d := Basis.equivFunL v\n\u22a2 Summable fun x => \u2016f x\u2016", "state_after": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\nthis : \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016\nv : Basis (Fin (finrank \u211d E)) \u211d E\ne : E \u2243L[\u211d] Fin (finrank \u211d E) \u2192 \u211d := Basis.equivFunL v\nH : Summable fun x => \u2016e (f x)\u2016\n\u22a2 Summable fun x => \u2016f x\u2016"}, {"tactic": "refine .of_norm_bounded _ (H.mul_left \u2191\u2016(e.symm : (Fin (finrank \u211d E) \u2192 \u211d) \u2192L[\u211d] E)\u2016\u208a) fun i \u21a6 ?_", "annotated_tactic": ["refine .of_norm_bounded _ (H.mul_left \u2191\u2016(e.symm : (<a>Fin</a> (<a>finrank</a> \u211d E) \u2192 \u211d) \u2192L[\u211d] E)\u2016\u208a) fun i \u21a6 ?_", [{"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}, {"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}]], "state_before": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\nthis : \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016\nv : Basis (Fin (finrank \u211d E)) \u211d E\ne : E \u2243L[\u211d] Fin (finrank \u211d E) \u2192 \u211d := Basis.equivFunL v\nH : Summable fun x => \u2016e (f x)\u2016\n\u22a2 Summable fun x => \u2016f x\u2016", "state_after": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\nthis : \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016\nv : Basis (Fin (finrank \u211d E)) \u211d E\ne : E \u2243L[\u211d] Fin (finrank \u211d E) \u2192 \u211d := Basis.equivFunL v\nH : Summable fun x => \u2016e (f x)\u2016\ni : \u03b1\n\u22a2 \u2016\u2016f i\u2016\u2016 \u2264 \u2191\u2016\u2191(ContinuousLinearEquiv.symm e)\u2016\u208a * \u2016e (f i)\u2016"}, {"tactic": "simpa using (e.symm : (Fin (finrank \u211d E) \u2192 \u211d) \u2192L[\u211d] E).le_opNorm (e <| f i)", "annotated_tactic": ["simpa using (e.symm : (<a>Fin</a> (<a>finrank</a> \u211d E) \u2192 \u211d) \u2192L[\u211d] E).<a>le_opNorm</a> (e <| f i)", [{"full_name": "Fin", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1811, 11], "def_end_pos": [1811, 14]}, {"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}, {"full_name": "ContinuousLinearMap.le_opNorm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean", "def_pos": [236, 9], "def_end_pos": [236, 18]}]], "state_before": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nf : \u03b1 \u2192 E\nhf : Summable f\nthis : \u2200 {N : \u2115} {g : \u03b1 \u2192 Fin N \u2192 \u211d}, Summable g \u2192 Summable fun x => \u2016g x\u2016\nv : Basis (Fin (finrank \u211d E)) \u211d E\ne : E \u2243L[\u211d] Fin (finrank \u211d E) \u2192 \u211d := Basis.equivFunL v\nH : Summable fun x => \u2016e (f x)\u2016\ni : \u03b1\n\u22a2 \u2016\u2016f i\u2016\u2016 \u2264 \u2191\u2016\u2191(ContinuousLinearEquiv.symm e)\u2016\u208a * \u2016e (f i)\u2016", "state_after": "no goals"}, {"tactic": "refine' fun i => Finset.single_le_sum (f := fun i => \u2016g x i\u2016) (fun i _ => _) (Finset.mem_univ i)", "annotated_tactic": ["refine' fun i => <a>Finset.single_le_sum</a> (f := fun i => \u2016g x i\u2016) (fun i _ => _) (<a>Finset.mem_univ</a> i)", [{"full_name": "Finset.single_le_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Order.lean", "def_pos": [199, 15], "def_end_pos": [199, 28]}, {"full_name": "Finset.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [73, 9], "def_end_pos": [73, 17]}]], "state_before": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\nx : \u03b1\n\u22a2 \u2200 (i : Fin N), \u2016g x i\u2016 \u2264 \u2211 i : Fin N, \u2016g x i\u2016", "state_after": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\nx : \u03b1\ni\u271d i : Fin N\nx\u271d : i \u2208 Finset.univ\n\u22a2 0 \u2264 (fun i => \u2016g x i\u2016) i"}, {"tactic": "exact norm_nonneg (g x i)", "annotated_tactic": ["exact <a>norm_nonneg</a> (g x i)", [{"full_name": "norm_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [551, 30], "def_end_pos": [551, 41]}]], "state_before": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\nx : \u03b1\ni\u271d i : Fin N\nx\u271d : i \u2208 Finset.univ\n\u22a2 0 \u2264 (fun i => \u2016g x i\u2016) i", "state_after": "no goals"}, {"tactic": "exact Finset.sum_nonneg fun _ _ => norm_nonneg _", "annotated_tactic": ["exact <a>Finset.sum_nonneg</a> fun _ _ => <a>norm_nonneg</a> _", [{"full_name": "Finset.sum_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Order.lean", "def_pos": [137, 15], "def_end_pos": [137, 25]}, {"full_name": "norm_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [551, 30], "def_end_pos": [551, 41]}]], "state_before": "\u03b1 : Type u_1\nN : \u2115\ng : \u03b1 \u2192 Fin N \u2192 \u211d\nhg : Summable g\nthis : \u2200 (i : Fin N), Summable fun x => \u2016g x i\u2016\nx : \u03b1\n\u22a2 0 \u2264 \u2211 i : Fin N, \u2016g x i\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.normSq_to_real", "start": [980, 1], "end": [980, 77], "traced_tactics": [{"tactic": "simp [IsROrC.normSq]", "annotated_tactic": ["simp [<a>IsROrC.normSq</a>]", [{"full_name": "IsROrC.normSq", "def_path": ".lake/packages/mathlib/Mathlib/Data/IsROrC/Basic.lean", "def_pos": [463, 5], "def_end_pos": [463, 11]}]], "state_before": "K : Type u_1\nE : Type u_2\ninst\u271d : IsROrC K\nx : \u211d\n\u22a2 normSq x = x * x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "full_name": "card_pow_eq_one_eq_orderOf_aux", "start": [383, 9], "end": [402, 8], "traced_tactics": [{"tactic": "let \u27e8i, hi\u27e9 := b.2", "annotated_tactic": ["let \u27e8i, hi\u27e9 := b.2", []], "state_before": "\u03b1 : Type u\na\u271d : \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nhn : \u2200 (n : \u2115), 0 < n \u2192 (filter (fun a => a ^ n = 1) univ).card \u2264 n\na : \u03b1\nb : \u21a5(zpowers a)\n\u22a2 \u2191b ^ orderOf a = 1", "state_after": "\u03b1 : Type u\na\u271d : \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nhn : \u2200 (n : \u2115), 0 < n \u2192 (filter (fun a => a ^ n = 1) univ).card \u2264 n\na : \u03b1\nb : \u21a5(zpowers a)\ni : \u2124\nhi : (fun x => a ^ x) i = \u2191b\n\u22a2 \u2191b ^ orderOf a = 1"}, {"tactic": "rw [\u2190 hi, \u2190 zpow_coe_nat, \u2190 zpow_mul, mul_comm, zpow_mul, zpow_coe_nat,\n  pow_orderOf_eq_one, one_zpow]", "annotated_tactic": ["rw [\u2190 hi, \u2190 <a>zpow_coe_nat</a>, \u2190 <a>zpow_mul</a>, <a>mul_comm</a>, <a>zpow_mul</a>, <a>zpow_coe_nat</a>,\n                    <a>pow_orderOf_eq_one</a>, <a>one_zpow</a>]", [{"full_name": "zpow_coe_nat", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [962, 9], "def_end_pos": [962, 21]}, {"full_name": "zpow_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [342, 33], "def_end_pos": [342, 41]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "zpow_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [342, 33], "def_end_pos": [342, 41]}, {"full_name": "zpow_coe_nat", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [962, 9], "def_end_pos": [962, 21]}, {"full_name": "pow_orderOf_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [176, 9], "def_end_pos": [176, 27]}, {"full_name": "one_zpow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [286, 9], "def_end_pos": [286, 17]}]], "state_before": "\u03b1 : Type u\na\u271d : \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nhn : \u2200 (n : \u2115), 0 < n \u2192 (filter (fun a => a ^ n = 1) univ).card \u2264 n\na : \u03b1\nb : \u21a5(zpowers a)\ni : \u2124\nhi : (fun x => a ^ x) i = \u2191b\n\u22a2 \u2191b ^ orderOf a = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.bot_eq_empty", "start": [100, 1], "end": [101, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Commute.lean", "full_name": "Commute.neg_left_iff", "start": [106, 1], "end": [107, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Defs.lean", "full_name": "SMulPosMono.toSMulPosStrictMono", "start": [720, 1], "end": [722, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "le_div_iff'", "start": [142, 1], "end": [142, 92], "traced_tactics": [{"tactic": "rw [mul_comm, le_div_iff hc]", "annotated_tactic": ["rw [<a>mul_comm</a>, <a>le_div_iff</a> hc]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "le_div_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [133, 9], "def_end_pos": [133, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nhc : 0 < c\n\u22a2 a \u2264 b / c \u2194 c * a \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Group.lean", "full_name": "Set.pairwise_disjoint_Ico_mul_zpow", "start": [185, 1], "end": [197, 26], "traced_tactics": [{"tactic": "simp (config := { unfoldPartialApp := true }) only [Function.onFun]", "annotated_tactic": ["simp (config := { unfoldPartialApp := <a>true</a> }) only [<a>Function.onFun</a>]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}, {"full_name": "Function.onFun", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [54, 5], "def_end_pos": [54, 10]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\n\u22a2 Pairwise (Disjoint on fun n => Ico (a * b ^ n) (a * b ^ (n + 1)))", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\n\u22a2 Pairwise fun x y => Disjoint (Ico (a * b ^ x) (a * b ^ (x + 1))) (Ico (a * b ^ y) (a * b ^ (y + 1)))"}, {"tactic": "simp_rw [Set.disjoint_iff]", "annotated_tactic": ["simp_rw [<a>Set.disjoint_iff</a>]", [{"full_name": "Set.disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1518, 19], "def_end_pos": [1518, 31]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\n\u22a2 Pairwise fun x y => Disjoint (Ico (a * b ^ x) (a * b ^ (x + 1))) (Ico (a * b ^ y) (a * b ^ (y + 1)))", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\n\u22a2 Pairwise fun x y => Ico (a * b ^ x) (a * b ^ (x + 1)) \u2229 Ico (a * b ^ y) (a * b ^ (y + 1)) \u2286 \u2205"}, {"tactic": "intro m n hmn x hx", "annotated_tactic": ["intro m n hmn x hx", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\n\u22a2 Pairwise fun x y => Ico (a * b ^ x) (a * b ^ (x + 1)) \u2229 Ico (a * b ^ y) (a * b ^ (y + 1)) \u2286 \u2205", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\n\u22a2 x \u2208 \u2205"}, {"tactic": "apply hmn", "annotated_tactic": ["apply hmn", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\n\u22a2 x \u2208 \u2205", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\n\u22a2 m = n"}, {"tactic": "have hb : 1 < b := by\n  have : a * b ^ m < a * b ^ (m + 1) := hx.1.1.trans_lt hx.1.2\n  rwa [mul_lt_mul_iff_left, \u2190 mul_one (b ^ m), zpow_add_one, mul_lt_mul_iff_left] at this", "annotated_tactic": ["have hb : 1 < b := by\n    have : a * b ^ m < a * b ^ (m + 1) := hx.1.1.<a>trans_lt</a> hx.1.2\n    rwa [<a>mul_lt_mul_iff_left</a>, \u2190 <a>mul_one</a> (b ^ m), <a>zpow_add_one</a>, <a>mul_lt_mul_iff_left</a>] at this", [{"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}, {"full_name": "mul_lt_mul_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 28]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "zpow_add_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [427, 7], "def_end_pos": [427, 19]}, {"full_name": "mul_lt_mul_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 28]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\n\u22a2 m = n", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nhb : 1 < b\n\u22a2 m = n"}, {"tactic": "have i1 := hx.1.1.trans_lt hx.2.2", "annotated_tactic": ["have i1 := hx.1.1.<a>trans_lt</a> hx.2.2", [{"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nhb : 1 < b\n\u22a2 m = n", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nhb : 1 < b\ni1 : a * b ^ m < a * b ^ (n + 1)\n\u22a2 m = n"}, {"tactic": "have i2 := hx.2.1.trans_lt hx.1.2", "annotated_tactic": ["have i2 := hx.2.1.<a>trans_lt</a> hx.1.2", [{"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nhb : 1 < b\ni1 : a * b ^ m < a * b ^ (n + 1)\n\u22a2 m = n", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nhb : 1 < b\ni1 : a * b ^ m < a * b ^ (n + 1)\ni2 : a * b ^ n < a * b ^ (m + 1)\n\u22a2 m = n"}, {"tactic": "rw [mul_lt_mul_iff_left, zpow_lt_zpow_iff hb, Int.lt_add_one_iff] at i1 i2", "annotated_tactic": ["rw [<a>mul_lt_mul_iff_left</a>, <a>zpow_lt_zpow_iff</a> hb, <a>Int.lt_add_one_iff</a>] at i1 i2", [{"full_name": "mul_lt_mul_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 28]}, {"full_name": "zpow_lt_zpow_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [68, 7], "def_end_pos": [68, 23]}, {"full_name": "Int.lt_add_one_iff", "def_path": ".lake/packages/std/Std/Data/Int/Order.lean", "def_pos": [91, 9], "def_end_pos": [91, 23]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nhb : 1 < b\ni1 : a * b ^ m < a * b ^ (n + 1)\ni2 : a * b ^ n < a * b ^ (m + 1)\n\u22a2 m = n", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nhb : 1 < b\ni1 : m \u2264 n\ni2 : n \u2264 m\n\u22a2 m = n"}, {"tactic": "exact le_antisymm i1 i2", "annotated_tactic": ["exact <a>le_antisymm</a> i1 i2", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nhb : 1 < b\ni1 : m \u2264 n\ni2 : n \u2264 m\n\u22a2 m = n", "state_after": "no goals"}, {"tactic": "have : a * b ^ m < a * b ^ (m + 1) := hx.1.1.trans_lt hx.1.2", "annotated_tactic": ["have : a * b ^ m < a * b ^ (m + 1) := hx.1.1.<a>trans_lt</a> hx.1.2", [{"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\n\u22a2 1 < b", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nthis : a * b ^ m < a * b ^ (m + 1)\n\u22a2 1 < b"}, {"tactic": "rwa [mul_lt_mul_iff_left, \u2190 mul_one (b ^ m), zpow_add_one, mul_lt_mul_iff_left] at this", "annotated_tactic": ["rwa [<a>mul_lt_mul_iff_left</a>, \u2190 <a>mul_one</a> (b ^ m), <a>zpow_add_one</a>, <a>mul_lt_mul_iff_left</a>] at this", [{"full_name": "mul_lt_mul_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 28]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "zpow_add_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [427, 7], "def_end_pos": [427, 19]}, {"full_name": "mul_lt_mul_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 28]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\na b : \u03b1\nm n : \u2124\nhmn : m \u2260 n\nx : \u03b1\nhx : x \u2208 Ico (a * b ^ m) (a * b ^ (m + 1)) \u2229 Ico (a * b ^ n) (a * b ^ (n + 1))\nthis : a * b ^ m < a * b ^ (m + 1)\n\u22a2 1 < b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.le_natDegree_of_ne_zero", "start": [182, 1], "end": [186, 16], "traced_tactics": [{"tactic": "rw [\u2190 Nat.cast_le (\u03b1 := WithBot \u2115), \u2190 degree_eq_natDegree]", "annotated_tactic": ["rw [\u2190 <a>Nat.cast_le</a> (\u03b1 := <a>WithBot</a> \u2115), \u2190 <a>degree_eq_natDegree</a>]", [{"full_name": "Nat.cast_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Order.lean", "def_pos": [124, 9], "def_end_pos": [124, 16]}, {"full_name": "WithBot", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [29, 5], "def_end_pos": [29, 12]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : coeff p n \u2260 0\n\u22a2 n \u2264 natDegree p", "state_after": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : coeff p n \u2260 0\n\u22a2 \u2191n \u2264 degree p\n\nR : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : coeff p n \u2260 0\n\u22a2 p \u2260 0"}, {"tactic": "exact le_degree_of_ne_zero h", "annotated_tactic": ["exact <a>le_degree_of_ne_zero</a> h", [{"full_name": "Polynomial.le_degree_of_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [177, 9], "def_end_pos": [177, 29]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : coeff p n \u2260 0\n\u22a2 \u2191n \u2264 degree p\n\nR : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : coeff p n \u2260 0\n\u22a2 p \u2260 0", "state_after": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : coeff p n \u2260 0\n\u22a2 p \u2260 0"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nh : coeff p n \u2260 0\n\u22a2 p \u2260 0", "state_after": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\nq r : R[X]\nh : coeff 0 n \u2260 0\n\u22a2 False"}, {"tactic": "exact h rfl", "annotated_tactic": ["exact h <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\nq r : R[X]\nh : coeff 0 n \u2260 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Hom.lean", "full_name": "MonoidWithZeroHom.comp_id", "start": [243, 1], "end": [243, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Order.lean", "full_name": "Finset.one_lt_prod", "start": [513, 1], "end": [514, 76], "traced_tactics": [{"tactic": "rw [prod_const_one]", "annotated_tactic": ["rw [<a>prod_const_one</a>]", [{"full_name": "Finset.prod_const_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [356, 9], "def_end_pos": [356, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nM : Type u_4\nN : Type u_5\nG : Type u_6\nk : Type u_7\nR : Type u_8\ninst\u271d : OrderedCancelCommMonoid M\nf g : \u03b9 \u2192 M\ns t : Finset \u03b9\nh : \u2200 i \u2208 s, 1 < f i\nhs : s.Nonempty\n\u22a2 1 \u2264 \u220f i in s, 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Control/Monad/Cont.lean", "full_name": "StateT.goto_mkLabel", "start": [221, 1], "end": [222, 86], "traced_tactics": [{"tactic": "cases x", "annotated_tactic": ["cases x", []], "state_before": "m : Type u \u2192 Type v\ninst\u271d : Monad m\n\u03b1 \u03b2 \u03c3 : Type u\nx : Label (\u03b1 \u00d7 \u03c3) m (\u03b2 \u00d7 \u03c3)\ni : \u03b1\n\u22a2 goto (mkLabel x) i = StateT.mk fun s => goto x (i, s)", "state_after": "case mk\nm : Type u \u2192 Type v\ninst\u271d : Monad m\n\u03b1 \u03b2 \u03c3 : Type u\ni : \u03b1\napply\u271d : \u03b1 \u00d7 \u03c3 \u2192 m (\u03b2 \u00d7 \u03c3)\n\u22a2 goto (mkLabel { apply := apply\u271d }) i = StateT.mk fun s => goto { apply := apply\u271d } (i, s)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk\nm : Type u \u2192 Type v\ninst\u271d : Monad m\n\u03b1 \u03b2 \u03c3 : Type u\ni : \u03b1\napply\u271d : \u03b1 \u00d7 \u03c3 \u2192 m (\u03b2 \u00d7 \u03c3)\n\u22a2 goto (mkLabel { apply := apply\u271d }) i = StateT.mk fun s => goto { apply := apply\u271d } (i, s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "RingHom.domain_nontrivial", "start": [598, 1], "end": [599, 77], "traced_tactics": [{"tactic": "rw [h, map_zero]", "annotated_tactic": ["rw [h, <a>map_zero</a>]", [{"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nx\u271d\u00b9 : NonAssocSemiring \u03b1\nx\u271d : NonAssocSemiring \u03b2\nf : \u03b1 \u2192+* \u03b2\nx y : \u03b1\ninst\u271d : Nontrivial \u03b2\nh : 1 = 0\n\u22a2 f 1 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Multilinear/Basic.lean", "full_name": "ContinuousMultilinearMap.ext", "start": [111, 1], "end": [112, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Finset.codisjoint_right", "start": [152, 1], "end": [153, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.eval_add", "start": [1182, 1], "end": [1183, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "interior_Ioc", "start": [1559, 1], "end": [1560, 82], "traced_tactics": [{"tactic": "rw [\u2190 Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]", "annotated_tactic": ["rw [\u2190 <a>Ioi_inter_Iic</a>, <a>interior_inter</a>, <a>interior_Ioi</a>, <a>interior_Iic</a>, <a>Ioi_inter_Iio</a>]", [{"full_name": "Set.Ioi_inter_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [626, 9], "def_end_pos": [626, 22]}, {"full_name": "interior_inter", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [318, 9], "def_end_pos": [318, 23]}, {"full_name": "interior_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/OrderClosed.lean", "def_pos": [199, 9], "def_end_pos": [199, 21]}, {"full_name": "interior_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [1535, 9], "def_end_pos": [1535, 21]}, {"full_name": "Set.Ioi_inter_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [630, 9], "def_end_pos": [630, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : DenselyOrdered \u03b1\na\u271d b\u271d : \u03b1\ns : Set \u03b1\ninst\u271d : NoMaxOrder \u03b1\na b : \u03b1\n\u22a2 interior (Ioc a b) = Ioo a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "full_name": "Complex.tendsto_log_nhdsWithin_im_nonneg_of_re_neg_of_im_zero", "start": [220, 1], "end": [223, 66], "traced_tactics": [{"tactic": "simpa only [log, arg_eq_pi_iff.2 \u27e8hre, him\u27e9] using\n  (continuousWithinAt_log_of_re_neg_of_im_zero hre him).tendsto", "annotated_tactic": ["simpa only [<a>log</a>, <a>arg_eq_pi_iff</a>.2 \u27e8hre, him\u27e9] using\n    (<a>continuousWithinAt_log_of_re_neg_of_im_zero</a> hre him).<a>tendsto</a>", [{"full_name": "Complex.log", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "def_pos": [29, 19], "def_end_pos": [29, 22]}, {"full_name": "Complex.arg_eq_pi_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "def_pos": [256, 9], "def_end_pos": [256, 22]}, {"full_name": "Complex.continuousWithinAt_log_of_re_neg_of_im_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "def_pos": [208, 9], "def_end_pos": [208, 52]}, {"full_name": "ContinuousWithinAt.tendsto", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [525, 9], "def_end_pos": [525, 35]}]], "state_before": "z : \u2102\nhre : z.re < 0\nhim : z.im = 0\n\u22a2 Tendsto log (\ud835\udcdd[{z | 0 \u2264 z.im}] z) (\ud835\udcdd (\u2191(Real.log (abs z)) + \u2191\u03c0 * I))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Real.lean", "full_name": "dist_smul_add_one_sub_smul_le", "start": [50, 1], "end": [59, 46], "traced_tactics": [{"tactic": "simp_rw [dist_eq_norm', \u2190 norm_smul, sub_smul, one_smul, smul_sub, \u2190 sub_sub, \u2190 sub_add,\n  sub_right_comm]", "annotated_tactic": ["simp_rw [<a>dist_eq_norm'</a>, \u2190 <a>norm_smul</a>, <a>sub_smul</a>, <a>one_smul</a>, <a>smul_sub</a>, \u2190 <a>sub_sub</a>, \u2190 <a>sub_add</a>,\n        <a>sub_right_comm</a>]", [{"full_name": "dist_eq_norm'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [414, 7], "def_end_pos": [414, 20]}, {"full_name": "norm_smul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/MulAction.lean", "def_pos": [90, 9], "def_end_pos": [90, 18]}, {"full_name": "sub_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [274, 9], "def_end_pos": [274, 17]}, {"full_name": "one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [481, 9], "def_end_pos": [481, 17]}, {"full_name": "smul_sub", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [1024, 9], "def_end_pos": [1024, 17]}, {"full_name": "sub_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [601, 3], "def_end_pos": [601, 14]}, {"full_name": "sub_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [606, 3], "def_end_pos": [606, 14]}, {"full_name": "sub_right_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [596, 3], "def_end_pos": [596, 14]}]], "state_before": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nr : \u211d\nx y : E\nh : r \u2208 Icc 0 1\n\u22a2 dist (r \u2022 x + (1 - r) \u2022 y) x = \u20161 - r\u2016 * \u2016x - y\u2016", "state_after": "no goals"}, {"tactic": "rw [Real.norm_eq_abs, abs_eq_self.mpr (sub_nonneg.mpr h.2), dist_eq_norm']", "annotated_tactic": ["rw [<a>Real.norm_eq_abs</a>, abs_eq_self.mpr (sub_nonneg.mpr h.2), <a>dist_eq_norm'</a>]", [{"full_name": "Real.norm_eq_abs", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [1837, 9], "def_end_pos": [1837, 20]}, {"full_name": "dist_eq_norm'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [414, 7], "def_end_pos": [414, 20]}]], "state_before": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nr : \u211d\nx y : E\nh : r \u2208 Icc 0 1\n\u22a2 \u20161 - r\u2016 * \u2016x - y\u2016 = (1 - r) * dist y x", "state_after": "no goals"}, {"tactic": "gcongr", "annotated_tactic": ["gcongr", []], "state_before": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nr : \u211d\nx y : E\nh : r \u2208 Icc 0 1\n\u22a2 (1 - r) * dist y x \u2264 (1 - 0) * dist y x", "state_after": "case h.h\nE : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nr : \u211d\nx y : E\nh : r \u2208 Icc 0 1\n\u22a2 0 \u2264 r"}, {"tactic": "exact h.1", "annotated_tactic": ["exact h.1", []], "state_before": "case h.h\nE : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nr : \u211d\nx y : E\nh : r \u2208 Icc 0 1\n\u22a2 0 \u2264 r", "state_after": "no goals"}, {"tactic": "rw [sub_zero, one_mul]", "annotated_tactic": ["rw [<a>sub_zero</a>, <a>one_mul</a>]", [{"full_name": "sub_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [407, 3], "def_end_pos": [407, 14]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nr : \u211d\nx y : E\nh : r \u2208 Icc 0 1\n\u22a2 (1 - 0) * dist y x = dist y x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.union_eq_union_iff_right", "start": [851, 1], "end": [852, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounded.lean", "full_name": "Set.unbounded_le_inter_not_le", "start": [322, 1], "end": [325, 34], "traced_tactics": [{"tactic": "rw [\u2190 not_bounded_iff, \u2190 not_bounded_iff, not_iff_not]", "annotated_tactic": ["rw [\u2190 <a>not_bounded_iff</a>, \u2190 <a>not_bounded_iff</a>, <a>not_iff_not</a>]", [{"full_name": "Set.not_bounded_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [556, 9], "def_end_pos": [556, 24]}, {"full_name": "Set.not_bounded_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [556, 9], "def_end_pos": [556, 24]}, {"full_name": "not_iff_not", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [449, 9], "def_end_pos": [449, 20]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 Unbounded (fun x x_1 => x \u2264 x_1) (s \u2229 {b | \u00acb \u2264 a}) \u2194 Unbounded (fun x x_1 => x \u2264 x_1) s", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 Bounded (fun x x_1 => x \u2264 x_1) (s \u2229 {b | \u00acb \u2264 a}) \u2194 Bounded (fun x x_1 => x \u2264 x_1) s"}, {"tactic": "exact bounded_le_inter_not_le a", "annotated_tactic": ["exact <a>bounded_le_inter_not_le</a> a", [{"full_name": "Set.bounded_le_inter_not_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounded.lean", "def_pos": [317, 9], "def_end_pos": [317, 32]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d : SemilatticeSup \u03b1\na : \u03b1\n\u22a2 Bounded (fun x x_1 => x \u2264 x_1) (s \u2229 {b | \u00acb \u2264 a}) \u2194 Bounded (fun x x_1 => x \u2264 x_1) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Indexes.lean", "full_name": "List.foldrIdxSpec_cons", "start": [224, 1], "end": [226, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Pointwise.lean", "full_name": "lowerBounds_smul_of_pos", "start": [47, 1], "end": [48, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "GroupTopology.toTopologicalSpace_le", "start": [2120, 1], "end": [2122, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.span_pair_add_mul_left", "start": [374, 1], "end": [386, 16], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z : R\n\u22a2 span {x + y * z, y} = span {x, y}", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d : R\n\u22a2 x\u271d \u2208 span {x + y * z, y} \u2194 x\u271d \u2208 span {x, y}"}, {"tactic": "rw [mem_span_pair, mem_span_pair]", "annotated_tactic": ["rw [<a>mem_span_pair</a>, <a>mem_span_pair</a>]", [{"full_name": "Ideal.mem_span_pair", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [369, 9], "def_end_pos": [369, 22]}, {"full_name": "Ideal.mem_span_pair", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [369, 9], "def_end_pos": [369, 22]}]], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d : R\n\u22a2 x\u271d \u2208 span {x + y * z, y} \u2194 x\u271d \u2208 span {x, y}", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d : R\n\u22a2 (\u2203 a b, a * (x + y * z) + b * y = x\u271d) \u2194 \u2203 a b, a * x + b * y = x\u271d"}, {"tactic": "exact\n  \u27e8fun \u27e8a, b, h\u27e9 =>\n    \u27e8a, b + a * z, by\n      rw [\u2190 h]\n      ring1\u27e9,\n    fun \u27e8a, b, h\u27e9 =>\n    \u27e8a, b - a * z, by\n      rw [\u2190 h]\n      ring1\u27e9\u27e9", "annotated_tactic": ["exact\n    \u27e8fun \u27e8a, b, h\u27e9 =>\n      \u27e8a, b + a * z, by\n        rw [\u2190 h]\n        ring1\u27e9,\n      fun \u27e8a, b, h\u27e9 =>\n      \u27e8a, b - a * z, by\n        rw [\u2190 h]\n        ring1\u27e9\u27e9", []], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d : R\n\u22a2 (\u2203 a b, a * (x + y * z) + b * y = x\u271d) \u2194 \u2203 a b, a * x + b * y = x\u271d", "state_after": "no goals"}, {"tactic": "rw [\u2190 h]", "annotated_tactic": ["rw [\u2190 h]", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b\u271d : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d\u00b9 : R\nx\u271d : \u2203 a b, a * (x + y * z) + b * y = x\u271d\u00b9\na b : R\nh : a * (x + y * z) + b * y = x\u271d\u00b9\n\u22a2 a * x + (b + a * z) * y = x\u271d\u00b9", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b\u271d : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d\u00b9 : R\nx\u271d : \u2203 a b, a * (x + y * z) + b * y = x\u271d\u00b9\na b : R\nh : a * (x + y * z) + b * y = x\u271d\u00b9\n\u22a2 a * x + (b + a * z) * y = a * (x + y * z) + b * y"}, {"tactic": "ring1", "annotated_tactic": ["ring1", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b\u271d : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d\u00b9 : R\nx\u271d : \u2203 a b, a * (x + y * z) + b * y = x\u271d\u00b9\na b : R\nh : a * (x + y * z) + b * y = x\u271d\u00b9\n\u22a2 a * x + (b + a * z) * y = a * (x + y * z) + b * y", "state_after": "no goals"}, {"tactic": "rw [\u2190 h]", "annotated_tactic": ["rw [\u2190 h]", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b\u271d : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d\u00b9 : R\nx\u271d : \u2203 a b, a * x + b * y = x\u271d\u00b9\na b : R\nh : a * x + b * y = x\u271d\u00b9\n\u22a2 a * (x + y * z) + (b - a * z) * y = x\u271d\u00b9", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b\u271d : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d\u00b9 : R\nx\u271d : \u2203 a b, a * x + b * y = x\u271d\u00b9\na b : R\nh : a * x + b * y = x\u271d\u00b9\n\u22a2 a * (x + y * z) + (b - a * z) * y = a * x + b * y"}, {"tactic": "ring1", "annotated_tactic": ["ring1", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b\u271d : \u03b1\nR : Type u\ninst\u271d : CommRing R\nx y z x\u271d\u00b9 : R\nx\u271d : \u2203 a b, a * x + b * y = x\u271d\u00b9\na b : R\nh : a * x + b * y = x\u271d\u00b9\n\u22a2 a * (x + y * z) + (b - a * z) * y = a * x + b * y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/PEquiv.lean", "full_name": "PEquiv.trans_eq_none", "start": [161, 1], "end": [165, 20], "traced_tactics": [{"tactic": "simp only [eq_none_iff_forall_not_mem, mem_trans, imp_iff_not_or.symm]", "annotated_tactic": ["simp only [<a>eq_none_iff_forall_not_mem</a>, <a>mem_trans</a>, imp_iff_not_or.symm]", [{"full_name": "Option.eq_none_iff_forall_not_mem", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean", "def_pos": [52, 9], "def_end_pos": [52, 35]}, {"full_name": "PEquiv.mem_trans", "def_path": ".lake/packages/mathlib/Mathlib/Data/PEquiv.lean", "def_pos": [151, 9], "def_end_pos": [151, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\ng : \u03b2 \u2243. \u03b3\na : \u03b1\n\u22a2 (PEquiv.trans f g) a = none \u2194 \u2200 (b : \u03b2) (c : \u03b3), b \u2209 f a \u2228 c \u2209 g b", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\ng : \u03b2 \u2243. \u03b3\na : \u03b1\n\u22a2 (\u2200 (a_1 : \u03b3), \u00ac\u2203 b \u2208 f a, a_1 \u2208 g b) \u2194 \u2200 (b : \u03b2) (c : \u03b3), b \u2208 f a \u2192 c \u2209 g b"}, {"tactic": "push_neg", "annotated_tactic": ["push_neg", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\ng : \u03b2 \u2243. \u03b3\na : \u03b1\n\u22a2 (\u2200 (a_1 : \u03b3), \u00ac\u2203 b \u2208 f a, a_1 \u2208 g b) \u2194 \u2200 (b : \u03b2) (c : \u03b3), b \u2208 f a \u2192 c \u2209 g b", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\ng : \u03b2 \u2243. \u03b3\na : \u03b1\n\u22a2 (\u2200 (a_1 : \u03b3), \u2200 b \u2208 f a, a_1 \u2209 g b) \u2194 \u2200 (b : \u03b2) (c : \u03b3), b \u2208 f a \u2192 c \u2209 g b"}, {"tactic": "exact forall_swap", "annotated_tactic": ["exact <a>forall_swap</a>", [{"full_name": "forall_swap", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [654, 9], "def_end_pos": [654, 20]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\ng : \u03b2 \u2243. \u03b3\na : \u03b1\n\u22a2 (\u2200 (a_1 : \u03b3), \u2200 b \u2208 f a, a_1 \u2209 g b) \u2194 \u2200 (b : \u03b2) (c : \u03b3), b \u2208 f a \u2192 c \u2209 g b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.count_map_eq_count", "start": [2637, 1], "end": [2644, 92], "traced_tactics": [{"tactic": "suffices (filter (fun a : \u03b1 => f x = f a) s).count x = card (filter (fun a : \u03b1 => f x = f a) s) by\n  rw [count, countP_map, \u2190 this]\n  exact count_filter_of_pos <| rfl", "annotated_tactic": ["suffices (<a>filter</a> (fun a : \u03b1 => f x = f a) s).<a>count</a> x = <a>card</a> (<a>filter</a> (fun a : \u03b1 => f x = f a) s) by\n    rw [<a>count</a>, <a>countP_map</a>, \u2190 this]\n    exact <a>count_filter_of_pos</a> <| <a>rfl</a>", [{"full_name": "Multiset.filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1970, 5], "def_end_pos": [1970, 11]}, {"full_name": "Multiset.count", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2427, 5], "def_end_pos": [2427, 10]}, {"full_name": "Multiset.card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [750, 5], "def_end_pos": [750, 9]}, {"full_name": "Multiset.filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1970, 5], "def_end_pos": [1970, 11]}, {"full_name": "Multiset.count", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2427, 5], "def_end_pos": [2427, 10]}, {"full_name": "Multiset.countP_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2361, 9], "def_end_pos": [2361, 19]}, {"full_name": "Multiset.count_filter_of_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2579, 9], "def_end_pos": [2579, 28]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\n\u22a2 count (f x) (map f s) = count x s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\n\u22a2 count x (filter (fun a => f x = f a) s) = card (filter (fun a => f x = f a) s)"}, {"tactic": "rw [count, countP_map, \u2190 this]", "annotated_tactic": ["rw [<a>count</a>, <a>countP_map</a>, \u2190 this]", [{"full_name": "Multiset.count", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2427, 5], "def_end_pos": [2427, 10]}, {"full_name": "Multiset.countP_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2361, 9], "def_end_pos": [2361, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\nthis : count x (filter (fun a => f x = f a) s) = card (filter (fun a => f x = f a) s)\n\u22a2 count (f x) (map f s) = count x s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\nthis : count x (filter (fun a => f x = f a) s) = card (filter (fun a => f x = f a) s)\n\u22a2 count x (filter (fun a => f x = f a) s) = count x s"}, {"tactic": "exact count_filter_of_pos <| rfl", "annotated_tactic": ["exact <a>count_filter_of_pos</a> <| <a>rfl</a>", [{"full_name": "Multiset.count_filter_of_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2579, 9], "def_end_pos": [2579, 28]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\nthis : count x (filter (fun a => f x = f a) s) = card (filter (fun a => f x = f a) s)\n\u22a2 count x (filter (fun a => f x = f a) s) = count x s", "state_after": "no goals"}, {"tactic": "rw [eq_replicate_card.2 fun b hb => (hf H (mem_filter.1 hb).left _).symm]", "annotated_tactic": ["rw [<a>eq_replicate_card</a>.2 fun b hb => (hf H (<a>mem_filter</a>.1 hb).<a>left</a> _).<a>symm</a>]", [{"full_name": "Multiset.eq_replicate_card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [962, 9], "def_end_pos": [962, 26]}, {"full_name": "Multiset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2028, 9], "def_end_pos": [2028, 19]}, {"full_name": "And.left", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [517, 3], "def_end_pos": [517, 7]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\n\u22a2 count x (filter (fun a => f x = f a) s) = card (filter (fun a => f x = f a) s)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\n\u22a2 count x (replicate (card (filter (fun a => f x = f a) s)) x) =\n    card (replicate (card (filter (fun a => f x = f a) s)) x)\n\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\n\u22a2 \u2200 b \u2208 filter (fun a => f x = f a) s, f x = f b"}, {"tactic": "simp only [count_replicate, eq_self_iff_true, if_true, card_replicate]", "annotated_tactic": ["simp only [<a>count_replicate</a>, <a>eq_self_iff_true</a>, <a>if_true</a>, <a>card_replicate</a>]", [{"full_name": "Multiset.count_replicate", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2533, 9], "def_end_pos": [2533, 24]}, {"full_name": "eq_self_iff_true", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1368, 9], "def_end_pos": [1368, 25]}, {"full_name": "if_true", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [24, 17], "def_end_pos": [24, 24]}, {"full_name": "Multiset.card_replicate", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [950, 17], "def_end_pos": [950, 31]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\n\u22a2 count x (replicate (card (filter (fun a => f x = f a) s)) x) =\n    card (replicate (card (filter (fun a => f x = f a) s)) x)", "state_after": "no goals"}, {"tactic": "simp only [mem_filter, beq_iff_eq, and_imp, @eq_comm _ (f x), imp_self, implies_true]", "annotated_tactic": ["simp only [<a>mem_filter</a>, <a>beq_iff_eq</a>, <a>and_imp</a>, @<a>eq_comm</a> _ (f x), <a>imp_self</a>, <a>implies_true</a>]", [{"full_name": "Multiset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2028, 9], "def_end_pos": [2028, 19]}, {"full_name": "beq_iff_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1314, 17], "def_end_pos": [1314, 27]}, {"full_name": "and_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [108, 17], "def_end_pos": [108, 24]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "imp_self", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1406, 17], "def_end_pos": [1406, 25]}, {"full_name": "implies_true", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [121, 17], "def_end_pos": [121, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ns\u271d : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nhf : Set.InjOn f {x | x \u2208 s}\nx : \u03b1\nH : x \u2208 s\n\u22a2 \u2200 b \u2208 filter (fun a => f x = f a) s, f x = f b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Functor.lean", "full_name": "Set.mem_coe_of_mem", "start": [92, 1], "end": [93, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Embedding/Basic.lean", "full_name": "Function.Embedding.setValue_eq", "start": [219, 1], "end": [221, 18], "traced_tactics": [{"tactic": "simp [setValue]", "annotated_tactic": ["simp [<a>setValue</a>]", [{"full_name": "Function.Embedding.setValue", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [200, 5], "def_end_pos": [200, 13]}]], "state_before": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u21aa \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b9 : (a' : \u03b1) \u2192 Decidable (a' = a)\ninst\u271d : (a' : \u03b1) \u2192 Decidable (f a' = b)\n\u22a2 (setValue f a b) a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.take_subset", "start": [2020, 1], "end": [2021, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Antitone.piecewise_eventually_eq_iInter", "start": [2034, 1], "end": [2041, 61], "traced_tactics": [{"tactic": "convert \u2190 (compl_anti.comp hs).piecewise_eventually_eq_iUnion g f a using 3", "annotated_tactic": ["convert \u2190 (compl_anti.comp hs).<a>piecewise_eventually_eq_iUnion</a> g f a using 3", [{"full_name": "Monotone.piecewise_eventually_eq_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [2023, 9], "def_end_pos": [2023, 48]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2\u271d : Type u_4\n\u03b3 : Type u_5\n\u03b2 : \u03b1 \u2192 Type u_6\ninst\u271d\u00b2 : Preorder \u03b9\ns : \u03b9 \u2192 Set \u03b1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 DecidablePred fun x => x \u2208 s i\ninst\u271d : DecidablePred fun x => x \u2208 \u22c2 i, s i\nhs : Antitone s\nf g : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\n\u22a2 \u2200\u1da0 (i : \u03b9) in atTop, Set.piecewise (s i) f g a = Set.piecewise (\u22c2 i, s i) f g a", "state_after": "case h.e'_2.h.h.e'_2\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2\u271d : Type u_4\n\u03b3 : Type u_5\n\u03b2 : \u03b1 \u2192 Type u_6\ninst\u271d\u00b2 : Preorder \u03b9\ns : \u03b9 \u2192 Set \u03b1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 DecidablePred fun x => x \u2208 s i\ninst\u271d : DecidablePred fun x => x \u2208 \u22c2 i, s i\nhs : Antitone s\nf g : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\nx\u271d : \u03b9\n\u22a2 Set.piecewise ((compl \u2218 s) x\u271d) g f a = Set.piecewise (s x\u271d) f g a\n\ncase h.e'_2.h.h.e'_3\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2\u271d : Type u_4\n\u03b3 : Type u_5\n\u03b2 : \u03b1 \u2192 Type u_6\ninst\u271d\u00b2 : Preorder \u03b9\ns : \u03b9 \u2192 Set \u03b1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 DecidablePred fun x => x \u2208 s i\ninst\u271d : DecidablePred fun x => x \u2208 \u22c2 i, s i\nhs : Antitone s\nf g : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\nx\u271d : \u03b9\n\u22a2 Set.piecewise (\u22c3 i, (compl \u2218 s) i) g f a = Set.piecewise (\u22c2 i, s i) f g a"}, {"tactic": "convert congr_fun (Set.piecewise_compl (s _) g f) a", "annotated_tactic": ["convert <a>congr_fun</a> (<a>Set.piecewise_compl</a> (s _) g f) a", [{"full_name": "congr_fun", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [74, 7], "def_end_pos": [74, 16]}, {"full_name": "Set.piecewise_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [1505, 9], "def_end_pos": [1505, 24]}]], "state_before": "case h.e'_2.h.h.e'_2\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2\u271d : Type u_4\n\u03b3 : Type u_5\n\u03b2 : \u03b1 \u2192 Type u_6\ninst\u271d\u00b2 : Preorder \u03b9\ns : \u03b9 \u2192 Set \u03b1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 DecidablePred fun x => x \u2208 s i\ninst\u271d : DecidablePred fun x => x \u2208 \u22c2 i, s i\nhs : Antitone s\nf g : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\nx\u271d : \u03b9\n\u22a2 Set.piecewise ((compl \u2218 s) x\u271d) g f a = Set.piecewise (s x\u271d) f g a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/GaloisConnection.lean", "full_name": "GaloisInsertion.l_sup_u", "start": [541, 1], "end": [545, 42], "traced_tactics": [{"tactic": "simp only [gi.l_u_eq]", "annotated_tactic": ["simp only [gi.l_u_eq]", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\n\u03ba : \u03b9 \u2192 Sort u_1\na\u271d a\u2081 a\u2082 : \u03b1\nb\u271d b\u2081 b\u2082 : \u03b2\nl : \u03b1 \u2192 \u03b2\nu : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeSup \u03b2\ngi : GaloisInsertion l u\na b : \u03b2\n\u22a2 l (u a) \u2294 l (u b) = a \u2294 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Basic.lean", "full_name": "Complex.hasSum_conj", "start": [643, 1], "end": [644, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.casesDiagOn_zero_succ", "start": [125, 9], "end": [128, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/NumberField/Basic.lean", "full_name": "NumberField.integralBasis_apply", "start": [168, 1], "end": [170, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.coe_val", "start": [406, 1], "end": [406, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.pos_iff_ne_zero'", "start": [335, 1], "end": [336, 91], "traced_tactics": [{"tactic": "rw [\u2190 val_fin_lt, val_zero', _root_.pos_iff_ne_zero, Ne.def, Ne.def, ext_iff, val_zero']", "annotated_tactic": ["rw [\u2190 <a>val_fin_lt</a>, <a>val_zero'</a>, <a>_root_.pos_iff_ne_zero</a>, <a>Ne.def</a>, <a>Ne.def</a>, <a>ext_iff</a>, <a>val_zero'</a>]", [{"full_name": "Fin.val_fin_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [221, 9], "def_end_pos": [221, 19]}, {"full_name": "Fin.val_zero'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 18]}, {"full_name": "pos_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [230, 3], "def_end_pos": [230, 14]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Fin.ext_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [39, 9], "def_end_pos": [39, 16]}, {"full_name": "Fin.val_zero'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 18]}]], "state_before": "n m : \u2115\ninst\u271d : NeZero n\na : Fin n\n\u22a2 0 < a \u2194 a \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Infinite.lean", "full_name": "Set.Ioc.infinite", "start": [60, 1], "end": [61, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean", "full_name": "isRoot_of_unity_iff", "start": [58, 1], "end": [61, 55], "traced_tactics": [{"tactic": "rw [\u2190 mem_nthRoots h, nthRoots, mem_roots <| X_pow_sub_C_ne_zero h _, C_1, \u2190\n    prod_cyclotomic_eq_X_pow_sub_one h, isRoot_prod]", "annotated_tactic": ["rw [\u2190 <a>mem_nthRoots</a> h, <a>nthRoots</a>, <a>mem_roots</a> <| <a>X_pow_sub_C_ne_zero</a> h _, <a>C_1</a>, \u2190\n      <a>prod_cyclotomic_eq_X_pow_sub_one</a> h, <a>isRoot_prod</a>]", [{"full_name": "Polynomial.mem_nthRoots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [934, 9], "def_end_pos": [934, 21]}, {"full_name": "Polynomial.nthRoots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [929, 5], "def_end_pos": [929, 13]}, {"full_name": "Polynomial.mem_roots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [728, 9], "def_end_pos": [728, 18]}, {"full_name": "Polynomial.X_pow_sub_C_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1607, 9], "def_end_pos": [1607, 28]}, {"full_name": "Polynomial.C_1", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [519, 9], "def_end_pos": [519, 12]}, {"full_name": "Polynomial.prod_cyclotomic_eq_X_pow_sub_one", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [362, 9], "def_end_pos": [362, 41]}, {"full_name": "Polynomial.isRoot_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [1212, 9], "def_end_pos": [1212, 20]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u00b3 : CommRing R\u271d\nn : \u2115\ninst\u271d\u00b2 : IsDomain R\u271d\nh : 0 < n\nR : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\n\u03b6 : R\n\u22a2 \u03b6 ^ n = 1 \u2194 \u2203 i \u2208 Nat.divisors n, IsRoot (cyclotomic i R) \u03b6", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.total_surjective", "start": [707, 1], "end": [711, 43], "traced_tactics": [{"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nh : Function.Surjective v\n\u22a2 Function.Surjective \u21d1(Finsupp.total \u03b1 M R v)", "state_after": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nh : Function.Surjective v\nx : M\n\u22a2 \u2203 a, (Finsupp.total \u03b1 M R v) a = x"}, {"tactic": "obtain \u27e8y, hy\u27e9 := h x", "annotated_tactic": ["obtain \u27e8y, hy\u27e9 := h x", []], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nh : Function.Surjective v\nx : M\n\u22a2 \u2203 a, (Finsupp.total \u03b1 M R v) a = x", "state_after": "case intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nh : Function.Surjective v\nx : M\ny : \u03b1\nhy : v y = x\n\u22a2 \u2203 a, (Finsupp.total \u03b1 M R v) a = x"}, {"tactic": "exact \u27e8Finsupp.single y 1, by simp [hy]\u27e9", "annotated_tactic": ["exact \u27e8<a>Finsupp.single</a> y 1, by simp [hy]\u27e9", [{"full_name": "Finsupp.single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [286, 5], "def_end_pos": [286, 11]}]], "state_before": "case intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nh : Function.Surjective v\nx : M\ny : \u03b1\nhy : v y = x\n\u22a2 \u2203 a, (Finsupp.total \u03b1 M R v) a = x", "state_after": "no goals"}, {"tactic": "simp [hy]", "annotated_tactic": ["simp [hy]", []], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nh : Function.Surjective v\nx : M\ny : \u03b1\nhy : v y = x\n\u22a2 (Finsupp.total \u03b1 M R v) (single y 1) = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/NNReal.lean", "full_name": "Real.coe_nnabs", "start": [1166, 1], "end": [1167, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/EMetricSpace/Basic.lean", "full_name": "EMetric.diam_pos_iff'", "start": [1154, 1], "end": [1155, 56], "traced_tactics": [{"tactic": "simp only [diam_pos_iff, Set.Nontrivial, exists_prop]", "annotated_tactic": ["simp only [<a>diam_pos_iff</a>, <a>Set.Nontrivial</a>, <a>exists_prop</a>]", [{"full_name": "EMetric.diam_pos_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean", "def_pos": [1151, 9], "def_end_pos": [1151, 21]}, {"full_name": "Set.Nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2436, 15], "def_end_pos": [2436, 25]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b3 : Type w\ninst\u271d : EMetricSpace \u03b3\ns : Set \u03b3\n\u22a2 0 < diam s \u2194 \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "Real.borel_eq_generateFrom_Iio_rat", "start": [1909, 1], "end": [1919, 64], "traced_tactics": [{"tactic": "rw [borel_eq_generateFrom_Iio]", "annotated_tactic": ["rw [<a>borel_eq_generateFrom_Iio</a>]", [{"full_name": "borel_eq_generateFrom_Iio", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "def_pos": [123, 9], "def_end_pos": [123, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\n\u22a2 borel \u211d = MeasurableSpace.generateFrom (\u22c3 a, {Iio \u2191a})", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\n\u22a2 MeasurableSpace.generateFrom (range Iio) = MeasurableSpace.generateFrom (\u22c3 a, {Iio \u2191a})"}, {"tactic": "refine le_antisymm\n  (generateFrom_le ?_)\n  (generateFrom_mono <| iUnion_subset fun q \u21a6 singleton_subset_iff.mpr <| mem_range_self _)", "annotated_tactic": ["refine <a>le_antisymm</a>\n    (<a>generateFrom_le</a> ?_)\n    (<a>generateFrom_mono</a> <| <a>iUnion_subset</a> fun q \u21a6 singleton_subset_iff.mpr <| <a>mem_range_self</a> _)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "MeasurableSpace.generateFrom_le", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [393, 9], "def_end_pos": [393, 24]}, {"full_name": "MeasurableSpace.generateFrom_mono", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [447, 9], "def_end_pos": [447, 26]}, {"full_name": "Set.iUnion_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [240, 9], "def_end_pos": [240, 22]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\n\u22a2 MeasurableSpace.generateFrom (range Iio) = MeasurableSpace.generateFrom (\u22c3 a, {Iio \u2191a})", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\n\u22a2 \u2200 t \u2208 range Iio, MeasurableSet t"}, {"tactic": "rintro _ \u27e8a, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8a, rfl\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\n\u22a2 \u2200 t \u2208 range Iio, MeasurableSet t", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\na : \u211d\n\u22a2 MeasurableSet (Iio a)"}, {"tactic": "have : IsLUB (range ((\u2191) : \u211a \u2192 \u211d) \u2229 Iio a) a := by\n  simp [isLUB_iff_le_iff, mem_upperBounds, \u2190 le_iff_forall_rat_lt_imp_le]", "annotated_tactic": ["have : <a>IsLUB</a> (<a>range</a> ((\u2191) : \u211a \u2192 \u211d) \u2229 <a>Iio</a> a) a := by\n    simp [<a>isLUB_iff_le_iff</a>, <a>mem_upperBounds</a>, \u2190 <a>le_iff_forall_rat_lt_imp_le</a>]", [{"full_name": "IsLUB", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [76, 5], "def_end_pos": [76, 10]}, {"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}, {"full_name": "Set.Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [54, 5], "def_end_pos": [54, 8]}, {"full_name": "isLUB_iff_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [325, 9], "def_end_pos": [325, 25]}, {"full_name": "mem_upperBounds", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [85, 9], "def_end_pos": [85, 24]}, {"full_name": "le_iff_forall_rat_lt_imp_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Archimedean.lean", "def_pos": [321, 9], "def_end_pos": [321, 36]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\na : \u211d\n\u22a2 MeasurableSet (Iio a)", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\na : \u211d\nthis : IsLUB (range Rat.cast \u2229 Iio a) a\n\u22a2 MeasurableSet (Iio a)"}, {"tactic": "rw [\u2190 this.biUnion_Iio_eq, \u2190 image_univ, \u2190 image_inter_preimage, univ_inter, biUnion_image]", "annotated_tactic": ["rw [\u2190 this.biUnion_Iio_eq, \u2190 <a>image_univ</a>, \u2190 <a>image_inter_preimage</a>, <a>univ_inter</a>, <a>biUnion_image</a>]", [{"full_name": "Set.image_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [692, 9], "def_end_pos": [692, 19]}, {"full_name": "Set.image_inter_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [516, 9], "def_end_pos": [516, 29]}, {"full_name": "Set.univ_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [988, 9], "def_end_pos": [988, 19]}, {"full_name": "Set.biUnion_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1711, 9], "def_end_pos": [1711, 22]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\na : \u211d\nthis : IsLUB (range Rat.cast \u2229 Iio a) a\n\u22a2 MeasurableSet (Iio a)", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\na : \u211d\nthis : IsLUB (range Rat.cast \u2229 Iio a) a\n\u22a2 MeasurableSet (\u22c3 y \u2208 Rat.cast \u207b\u00b9' Iio a, Iio \u2191y)"}, {"tactic": "exact MeasurableSet.biUnion (to_countable _)\n  fun b _ => GenerateMeasurable.basic (Iio (b : \u211d)) (by simp)", "annotated_tactic": ["exact <a>MeasurableSet.biUnion</a> (<a>to_countable</a> _)\n    fun b _ => <a>GenerateMeasurable.basic</a> (<a>Iio</a> (b : \u211d)) (by simp)", [{"full_name": "MeasurableSet.biUnion", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [131, 19], "def_end_pos": [131, 40]}, {"full_name": "Set.to_countable", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [53, 9], "def_end_pos": [53, 21]}, {"full_name": "MeasurableSpace.GenerateMeasurable.basic", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [364, 15], "def_end_pos": [364, 20]}, {"full_name": "Set.Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [54, 5], "def_end_pos": [54, 8]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\na : \u211d\nthis : IsLUB (range Rat.cast \u2229 Iio a) a\n\u22a2 MeasurableSet (\u22c3 y \u2208 Rat.cast \u207b\u00b9' Iio a, Iio \u2191y)", "state_after": "no goals"}, {"tactic": "simp [isLUB_iff_le_iff, mem_upperBounds, \u2190 le_iff_forall_rat_lt_imp_le]", "annotated_tactic": ["simp [<a>isLUB_iff_le_iff</a>, <a>mem_upperBounds</a>, \u2190 <a>le_iff_forall_rat_lt_imp_le</a>]", [{"full_name": "isLUB_iff_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [325, 9], "def_end_pos": [325, 25]}, {"full_name": "mem_upperBounds", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [85, 9], "def_end_pos": [85, 24]}, {"full_name": "le_iff_forall_rat_lt_imp_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Archimedean.lean", "def_pos": [321, 9], "def_end_pos": [321, 36]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\na : \u211d\n\u22a2 IsLUB (range Rat.cast \u2229 Iio a) a", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\na : \u211d\nthis : IsLUB (range Rat.cast \u2229 Iio a) a\nb : \u211a\nx\u271d : b \u2208 Rat.cast \u207b\u00b9' Iio a\n\u22a2 Iio \u2191b \u2208 \u22c3 a, {Iio \u2191a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/PartialHomeomorph.lean", "full_name": "PartialHomeomorph.IsImage.inter", "start": [609, 11], "end": [610, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Control/Lawful.lean", "full_name": "StateT.run_mk", "start": [77, 1], "end": [78, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "full_name": "MulHom.restrict_apply", "start": [823, 1], "end": [825, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/ModEq.lean", "full_name": "Dvd.dvd.modEq_zero_int", "start": [86, 1], "end": [87, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.span_zero_singleton", "start": [498, 1], "end": [500, 37], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\n\u22a2 span R {0} = \u22a5", "state_after": "case h\nR : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nx\u271d : M\n\u22a2 x\u271d \u2208 span R {0} \u2194 x\u271d \u2208 \u22a5"}, {"tactic": "simp [mem_span_singleton, eq_comm]", "annotated_tactic": ["simp [<a>mem_span_singleton</a>, <a>eq_comm</a>]", [{"full_name": "Submodule.mem_span_singleton", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [473, 9], "def_end_pos": [473, 27]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "case h\nR : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nx\u271d : M\n\u22a2 x\u271d \u2208 span R {0} \u2194 x\u271d \u2208 \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/RowCol.lean", "full_name": "Matrix.map_updateColumn", "start": [235, 1], "end": [239, 26], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\n\u03b1 : Type v\n\u03b2 : Type w\nM : Matrix m n \u03b1\ni : m\nj : n\nb : n \u2192 \u03b1\nc : m \u2192 \u03b1\ninst\u271d : DecidableEq n\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (updateColumn M j c) f = updateColumn (map M f) j (f \u2218 c)", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\n\u03b1 : Type v\n\u03b2 : Type w\nM : Matrix m n \u03b1\ni : m\nj : n\nb : n \u2192 \u03b1\nc : m \u2192 \u03b1\ninst\u271d : DecidableEq n\nf : \u03b1 \u2192 \u03b2\ni\u271d : m\nx\u271d : n\n\u22a2 map (updateColumn M j c) f i\u271d x\u271d = updateColumn (map M f) j (f \u2218 c) i\u271d x\u271d"}, {"tactic": "rw [updateColumn_apply, map_apply, map_apply, updateColumn_apply]", "annotated_tactic": ["rw [<a>updateColumn_apply</a>, <a>map_apply</a>, <a>map_apply</a>, <a>updateColumn_apply</a>]", [{"full_name": "Matrix.updateColumn_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/RowCol.lean", "def_pos": [207, 9], "def_end_pos": [207, 27]}, {"full_name": "Matrix.map_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [148, 9], "def_end_pos": [148, 18]}, {"full_name": "Matrix.map_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [148, 9], "def_end_pos": [148, 18]}, {"full_name": "Matrix.updateColumn_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/RowCol.lean", "def_pos": [207, 9], "def_end_pos": [207, 27]}]], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\n\u03b1 : Type v\n\u03b2 : Type w\nM : Matrix m n \u03b1\ni : m\nj : n\nb : n \u2192 \u03b1\nc : m \u2192 \u03b1\ninst\u271d : DecidableEq n\nf : \u03b1 \u2192 \u03b2\ni\u271d : m\nx\u271d : n\n\u22a2 map (updateColumn M j c) f i\u271d x\u271d = updateColumn (map M f) j (f \u2218 c) i\u271d x\u271d", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\n\u03b1 : Type v\n\u03b2 : Type w\nM : Matrix m n \u03b1\ni : m\nj : n\nb : n \u2192 \u03b1\nc : m \u2192 \u03b1\ninst\u271d : DecidableEq n\nf : \u03b1 \u2192 \u03b2\ni\u271d : m\nx\u271d : n\n\u22a2 f (if x\u271d = j then c i\u271d else M i\u271d x\u271d) = if x\u271d = j then (f \u2218 c) i\u271d else f (M i\u271d x\u271d)"}, {"tactic": "exact apply_ite f _ _ _", "annotated_tactic": ["exact <a>apply_ite</a> f _ _ _", [{"full_name": "apply_ite", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [36, 9], "def_end_pos": [36, 18]}]], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\n\u03b1 : Type v\n\u03b2 : Type w\nM : Matrix m n \u03b1\ni : m\nj : n\nb : n \u2192 \u03b1\nc : m \u2192 \u03b1\ninst\u271d : DecidableEq n\nf : \u03b1 \u2192 \u03b2\ni\u271d : m\nx\u271d : n\n\u22a2 f (if x\u271d = j then c i\u271d else M i\u271d x\u271d) = if x\u271d = j then (f \u2218 c) i\u271d else f (M i\u271d x\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Count.lean", "full_name": "List.count_bind", "start": [151, 1], "end": [152, 93], "traced_tactics": [{"tactic": "rw [List.bind, count_join, map_map]", "annotated_tactic": ["rw [<a>List.bind</a>, <a>count_join</a>, <a>map_map</a>]", [{"full_name": "List.bind", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [710, 25], "def_end_pos": [710, 29]}, {"full_name": "List.count_join", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Count.lean", "def_pos": [119, 9], "def_end_pos": [119, 19]}, {"full_name": "List.map_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [133, 17], "def_end_pos": [133, 24]}]], "state_before": "\u03b1\u271d : Type ?u.8606\nl\u271d : List \u03b1\u271d\ninst\u271d\u00b9 : DecidableEq \u03b1\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b2\nl : List \u03b1\nf : \u03b1 \u2192 List \u03b2\nx : \u03b2\n\u22a2 count x (List.bind l f) = sum (map (count x \u2218 f) l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.union_mul_inter_subset_union", "start": [474, 1], "end": [475, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.get_reverse_aux\u2081", "start": [1378, 1], "end": [1383, 80], "traced_tactics": [{"tactic": "rw [show i + length (a :: l) = i + 1 + length l from Nat.add_right_comm i (length l) 1]", "annotated_tactic": ["rw [show i + <a>length</a> (a :: l) = i + 1 + <a>length</a> l from <a>Nat.add_right_comm</a> i (<a>length</a> l) 1]", [{"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}, {"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}, {"full_name": "Nat.add_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}, {"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl r : List \u03b1\ni : \u2115\n\u22a2 \u2200 (h1 : i + length (a :: l) < length (reverseAux (a :: l) r)) (h2 : i < length r),\n    get (reverseAux (a :: l) r) { val := i + length (a :: l), isLt := h1 } = get r { val := i, isLt := h2 }", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl r : List \u03b1\ni : \u2115\n\u22a2 \u2200 (h1 : i + 1 + length l < length (reverseAux (a :: l) r)) (h2 : i < length r),\n    get (reverseAux (a :: l) r) { val := i + 1 + length l, isLt := h1 } = get r { val := i, isLt := h2 }"}, {"tactic": "exact fun h1 h2 => get_reverse_aux\u2081 l (a :: r) (i + 1) h1 (succ_lt_succ h2)", "annotated_tactic": ["exact fun h1 h2 => get_reverse_aux\u2081 l (a :: r) (i + 1) h1 (<a>succ_lt_succ</a> h2)", [{"full_name": "Nat.succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [216, 9], "def_end_pos": [216, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl r : List \u03b1\ni : \u2115\n\u22a2 \u2200 (h1 : i + 1 + length l < length (reverseAux (a :: l) r)) (h2 : i < length r),\n    get (reverseAux (a :: l) r) { val := i + 1 + length l, isLt := h1 } = get r { val := i, isLt := h2 }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_X_sub_C_le", "start": [1444, 1], "end": [1445, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Actions.lean", "full_name": "Subgroup.mk_smul", "start": [35, 1], "end": [36, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "full_name": "MeasureTheory.ae_le_set_union", "start": [475, 1], "end": [477, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.ite_univ", "start": [2278, 1], "end": [2278, 77], "traced_tactics": [{"tactic": "simp [Set.ite]", "annotated_tactic": ["simp [<a>Set.ite</a>]", [{"full_name": "Set.ite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2236, 15], "def_end_pos": [2236, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s s' : Set \u03b1\n\u22a2 Set.ite univ s s' = s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Eventually.exists_forall_of_atBot", "start": [349, 1], "end": [351, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Degrees.lean", "full_name": "MvPolynomial.degrees_sum", "start": [135, 1], "end": [137, 48], "traced_tactics": [{"tactic": "simp_rw [degrees_def]", "annotated_tactic": ["simp_rw [<a>degrees_def</a>]", [{"full_name": "MvPolynomial.degrees_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [86, 9], "def_end_pos": [86, 20]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03c3\ns : Finset \u03b9\nf : \u03b9 \u2192 MvPolynomial \u03c3 R\n\u22a2 degrees (\u2211 i in s, f i) \u2264 Finset.sup s fun i => degrees (f i)", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03c3\ns : Finset \u03b9\nf : \u03b9 \u2192 MvPolynomial \u03c3 R\n\u22a2 (Finset.sup (support (\u2211 i in s, f i)) fun s => toMultiset s) \u2264\n    Finset.sup s fun i => Finset.sup (support (f i)) fun s => toMultiset s"}, {"tactic": "exact supDegree_sum_le", "annotated_tactic": ["exact <a>supDegree_sum_le</a>", [{"full_name": "AddMonoidAlgebra.supDegree_sum_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Degree.lean", "def_pos": [250, 9], "def_end_pos": [250, 25]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03c3\ns : Finset \u03b9\nf : \u03b9 \u2192 MvPolynomial \u03c3 R\n\u22a2 (Finset.sup (support (\u2211 i in s, f i)) fun s => toMultiset s) \u2264\n    Finset.sup s fun i => Finset.sup (support (f i)) fun s => toMultiset s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "vectorSpan_range_eq_span_range_vsub_left", "start": [1116, 1], "end": [1119, 8], "traced_tactics": [{"tactic": "rw [vectorSpan_eq_span_vsub_set_left k (Set.mem_range_self i0), \u2190 Set.range_comp]", "annotated_tactic": ["rw [<a>vectorSpan_eq_span_vsub_set_left</a> k (<a>Set.mem_range_self</a> i0), \u2190 <a>Set.range_comp</a>]", [{"full_name": "vectorSpan_eq_span_vsub_set_left", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [1039, 9], "def_end_pos": [1039, 41]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}, {"full_name": "Set.range_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [722, 9], "def_end_pos": [722, 19]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\ni0 : \u03b9\n\u22a2 vectorSpan k (range p) = Submodule.span k (range fun i => p i0 -\u1d65 p i)", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\ni0 : \u03b9\n\u22a2 Submodule.span k (range ((fun x => p i0 -\u1d65 x) \u2218 p)) = Submodule.span k (range fun i => p i0 -\u1d65 p i)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\np : \u03b9 \u2192 P\ni0 : \u03b9\n\u22a2 Submodule.span k (range ((fun x => p i0 -\u1d65 x) \u2218 p)) = Submodule.span k (range fun i => p i0 -\u1d65 p i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Subfield.lean", "full_name": "Subfield.zsmul_mem", "start": [315, 11], "end": [316, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "LowerSet.mem_map", "start": [1118, 1], "end": [1120, 6], "traced_tactics": [{"tactic": "rw [\u2190 f.symm_symm, \u2190 symm_map, f.symm_symm]", "annotated_tactic": ["rw [\u2190 f.symm_symm, \u2190 <a>symm_map</a>, f.symm_symm]", [{"full_name": "LowerSet.symm_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/UpperLower/Basic.lean", "def_pos": [1113, 9], "def_end_pos": [1113, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf\u271d : \u03b1 \u2243o \u03b2\ns t : LowerSet \u03b1\na : \u03b1\nb\u271d : \u03b2\nf : \u03b1 \u2243o \u03b2\nb : \u03b2\n\u22a2 b \u2208 (map f) s \u2194 (OrderIso.symm f) b \u2208 s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf\u271d : \u03b1 \u2243o \u03b2\ns t : LowerSet \u03b1\na : \u03b1\nb\u271d : \u03b2\nf : \u03b1 \u2243o \u03b2\nb : \u03b2\n\u22a2 b \u2208 (OrderIso.symm (map (OrderIso.symm f))) s \u2194 (OrderIso.symm f) b \u2208 s"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf\u271d : \u03b1 \u2243o \u03b2\ns t : LowerSet \u03b1\na : \u03b1\nb\u271d : \u03b2\nf : \u03b1 \u2243o \u03b2\nb : \u03b2\n\u22a2 b \u2208 (OrderIso.symm (map (OrderIso.symm f))) s \u2194 (OrderIso.symm f) b \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "full_name": "NonUnitalSubsemiring.closure_union", "start": [755, 1], "end": [756, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.map_add", "start": [1237, 1], "end": [1238, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Basic.lean", "full_name": "MonoidHom.eq_of_eqOn_topM", "start": [608, 1], "end": [609, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "tsub_lt_tsub_iff_left_of_le", "start": [491, 1], "end": [492, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.foldl_hom\u2082", "start": [2485, 1], "end": [2490, 59], "traced_tactics": [{"tactic": "revert a b", "annotated_tactic": ["revert a b", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nl : List \u03b9\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nop\u2081 : \u03b1 \u2192 \u03b9 \u2192 \u03b1\nop\u2082 : \u03b2 \u2192 \u03b9 \u2192 \u03b2\nop\u2083 : \u03b3 \u2192 \u03b9 \u2192 \u03b3\na : \u03b1\nb : \u03b2\nh : \u2200 (a : \u03b1) (b : \u03b2) (i : \u03b9), f (op\u2081 a i) (op\u2082 b i) = op\u2083 (f a b) i\n\u22a2 f (foldl op\u2081 a l) (foldl op\u2082 b l) = foldl op\u2083 (f a b) l", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nl : List \u03b9\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nop\u2081 : \u03b1 \u2192 \u03b9 \u2192 \u03b1\nop\u2082 : \u03b2 \u2192 \u03b9 \u2192 \u03b2\nop\u2083 : \u03b3 \u2192 \u03b9 \u2192 \u03b3\nh : \u2200 (a : \u03b1) (b : \u03b2) (i : \u03b9), f (op\u2081 a i) (op\u2082 b i) = op\u2083 (f a b) i\n\u22a2 \u2200 (a : \u03b1) (b : \u03b2), f (foldl op\u2081 a l) (foldl op\u2082 b l) = foldl op\u2083 (f a b) l"}, {"tactic": "induction l <;> intros <;> [rfl; simp only [*, foldl]]", "annotated_tactic": ["induction l <;> intros <;> [rfl; simp only [*, <a>foldl</a>]]", [{"full_name": "List.foldl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2296, 5], "def_end_pos": [2296, 15]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nl : List \u03b9\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nop\u2081 : \u03b1 \u2192 \u03b9 \u2192 \u03b1\nop\u2082 : \u03b2 \u2192 \u03b9 \u2192 \u03b2\nop\u2083 : \u03b3 \u2192 \u03b9 \u2192 \u03b3\nh : \u2200 (a : \u03b1) (b : \u03b2) (i : \u03b9), f (op\u2081 a i) (op\u2082 b i) = op\u2083 (f a b) i\n\u22a2 \u2200 (a : \u03b1) (b : \u03b2), f (foldl op\u2081 a l) (foldl op\u2082 b l) = foldl op\u2083 (f a b) l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean", "full_name": "MeasureTheory.uIoc_ae_eq_interval", "start": [457, 1], "end": [458, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bornology/Constructions.lean", "full_name": "Bornology.IsBounded.image_eval", "start": [114, 1], "end": [116, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.inter_eq_inter_iff_right", "start": [979, 1], "end": [980, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Combination.lean", "full_name": "Finset.centerMass_smul", "start": [87, 1], "end": [88, 95], "traced_tactics": [{"tactic": "simp only [Finset.centerMass, Finset.smul_sum, (mul_smul _ _ _).symm, mul_comm c, mul_assoc]", "annotated_tactic": ["simp only [<a>Finset.centerMass</a>, <a>Finset.smul_sum</a>, (<a>mul_smul</a> _ _ _).<a>symm</a>, <a>mul_comm</a> c, <a>mul_assoc</a>]", [{"full_name": "Finset.centerMass", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Convex/Combination.lean", "def_pos": [42, 5], "def_end_pos": [42, 22]}, {"full_name": "Finset.smul_sum", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/BigOperators.lean", "def_pos": [52, 9], "def_end_pos": [52, 24]}, {"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "R : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9 : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2078 : LinearOrderedField R\ninst\u271d\u2077 : LinearOrderedField R'\ninst\u271d\u2076 : AddCommGroup E\ninst\u271d\u2075 : AddCommGroup F\ninst\u271d\u2074 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u00b3 : Module R E\ninst\u271d\u00b2 : Module R F\ninst\u271d\u00b9 : Module R \u03b1\ninst\u271d : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\nc : R\nt : Finset \u03b9\nw : \u03b9 \u2192 R\nz : \u03b9 \u2192 E\n\u22a2 (centerMass t w fun i => c \u2022 z i) = c \u2022 centerMass t w z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Sum/Lemmas.lean", "full_name": "Sum.lex_acc_inr", "start": [222, 1], "end": [230, 25], "traced_tactics": [{"tactic": "induction acb with\n| intro _ _ IH =>\n  constructor\n  intro y h\n  cases h with\n  | inr h' => exact IH _ h'\n  | sep => exact aca _", "annotated_tactic": ["induction acb with\n  | <a>intro</a> _ _ IH =>\n    constructor\n    intro y h\n    cases h with\n    | <a>inr</a> h' => exact IH _ h'\n    | <a>sep</a> => exact aca _", [{"full_name": "Acc.intro", "def_path": ".lake/packages/lean4/src/lean/Init/WF.lean", "def_pos": [13, 5], "def_end_pos": [13, 10]}, {"full_name": "Sum.Lex.inr", "def_path": ".lake/packages/std/Std/Data/Sum/Basic.lean", "def_pos": [144, 15], "def_end_pos": [144, 18]}, {"full_name": "Sum.Lex.sep", "def_path": ".lake/packages/std/Std/Data/Sum/Basic.lean", "def_pos": [146, 5], "def_end_pos": [146, 8]}]], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\naca : \u2200 (a : \u03b1\u271d), Acc (Lex r s) (inl a)\nb : \u03b2\u271d\nacb : Acc s b\n\u22a2 Acc (Lex r s) (inr b)", "state_after": "no goals"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case intro\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\naca : \u2200 (a : \u03b1\u271d), Acc (Lex r s) (inl a)\nb x\u271d : \u03b2\u271d\nh\u271d : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc s y\nIH : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc (Lex r s) (inr y)\n\u22a2 Acc (Lex r s) (inr x\u271d)", "state_after": "case intro.h\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\naca : \u2200 (a : \u03b1\u271d), Acc (Lex r s) (inl a)\nb x\u271d : \u03b2\u271d\nh\u271d : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc s y\nIH : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc (Lex r s) (inr y)\n\u22a2 \u2200 (y : \u03b1\u271d \u2295 \u03b2\u271d), Lex r s y (inr x\u271d) \u2192 Acc (Lex r s) y"}, {"tactic": "intro y h", "annotated_tactic": ["intro y h", []], "state_before": "case intro.h\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\naca : \u2200 (a : \u03b1\u271d), Acc (Lex r s) (inl a)\nb x\u271d : \u03b2\u271d\nh\u271d : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc s y\nIH : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc (Lex r s) (inr y)\n\u22a2 \u2200 (y : \u03b1\u271d \u2295 \u03b2\u271d), Lex r s y (inr x\u271d) \u2192 Acc (Lex r s) y", "state_after": "case intro.h\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\naca : \u2200 (a : \u03b1\u271d), Acc (Lex r s) (inl a)\nb x\u271d : \u03b2\u271d\nh\u271d : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc s y\nIH : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc (Lex r s) (inr y)\ny : \u03b1\u271d \u2295 \u03b2\u271d\nh : Lex r s y (inr x\u271d)\n\u22a2 Acc (Lex r s) y"}, {"tactic": "cases h with\n| inr h' => exact IH _ h'\n| sep => exact aca _", "annotated_tactic": ["cases h with\n    | <a>inr</a> h' => exact IH _ h'\n    | <a>sep</a> => exact aca _", [{"full_name": "Sum.Lex.inr", "def_path": ".lake/packages/std/Std/Data/Sum/Basic.lean", "def_pos": [144, 15], "def_end_pos": [144, 18]}, {"full_name": "Sum.Lex.sep", "def_path": ".lake/packages/std/Std/Data/Sum/Basic.lean", "def_pos": [146, 5], "def_end_pos": [146, 8]}]], "state_before": "case intro.h\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\naca : \u2200 (a : \u03b1\u271d), Acc (Lex r s) (inl a)\nb x\u271d : \u03b2\u271d\nh\u271d : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc s y\nIH : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc (Lex r s) (inr y)\ny : \u03b1\u271d \u2295 \u03b2\u271d\nh : Lex r s y (inr x\u271d)\n\u22a2 Acc (Lex r s) y", "state_after": "no goals"}, {"tactic": "exact IH _ h'", "annotated_tactic": ["exact IH _ h'", []], "state_before": "case intro.h.inr\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\naca : \u2200 (a : \u03b1\u271d), Acc (Lex r s) (inl a)\nb x\u271d : \u03b2\u271d\nh\u271d : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc s y\nIH : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc (Lex r s) (inr y)\nb\u2081\u271d : \u03b2\u271d\nh' : s b\u2081\u271d x\u271d\n\u22a2 Acc (Lex r s) (inr b\u2081\u271d)", "state_after": "no goals"}, {"tactic": "exact aca _", "annotated_tactic": ["exact aca _", []], "state_before": "case intro.h.sep\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\naca : \u2200 (a : \u03b1\u271d), Acc (Lex r s) (inl a)\nb x\u271d : \u03b2\u271d\nh\u271d : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc s y\nIH : \u2200 (y : \u03b2\u271d), s y x\u271d \u2192 Acc (Lex r s) (inr y)\na\u271d : \u03b1\u271d\n\u22a2 Acc (Lex r s) (inl a\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Equivalence.lean", "full_name": "CategoryTheory.Equivalence.Equivalence_mk'_counit", "start": [133, 1], "end": [135, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/GaloisConnection.lean", "full_name": "GaloisConnection.l_iSup", "start": [276, 1], "end": [280, 77], "traced_tactics": [{"tactic": "rw [range_comp, \u2190 sSup_range]", "annotated_tactic": ["rw [<a>range_comp</a>, \u2190 <a>sSup_range</a>]", [{"full_name": "Set.range_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [722, 9], "def_end_pos": [722, 19]}, {"full_name": "sSup_range", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [565, 9], "def_end_pos": [565, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\n\u03ba : \u03b9 \u2192 Sort u_1\na a\u2081 a\u2082 : \u03b1\nb b\u2081 b\u2082 : \u03b2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nl : \u03b1 \u2192 \u03b2\nu : \u03b2 \u2192 \u03b1\ngc : GaloisConnection l u\nf : \u03b9 \u2192 \u03b1\n\u22a2 IsLUB (range (l \u2218 f)) (l (iSup f))", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\n\u03ba : \u03b9 \u2192 Sort u_1\na a\u2081 a\u2082 : \u03b1\nb b\u2081 b\u2082 : \u03b2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nl : \u03b1 \u2192 \u03b2\nu : \u03b2 \u2192 \u03b1\ngc : GaloisConnection l u\nf : \u03b9 \u2192 \u03b1\n\u22a2 IsLUB (l '' range f) (l (sSup (range f)))"}, {"tactic": "exact gc.isLUB_l_image (isLUB_sSup _)", "annotated_tactic": ["exact gc.isLUB_l_image (<a>isLUB_sSup</a> _)", [{"full_name": "isLUB_sSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [82, 9], "def_end_pos": [82, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\n\u03ba : \u03b9 \u2192 Sort u_1\na a\u2081 a\u2082 : \u03b1\nb b\u2081 b\u2082 : \u03b2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nl : \u03b1 \u2192 \u03b2\nu : \u03b2 \u2192 \u03b1\ngc : GaloisConnection l u\nf : \u03b9 \u2192 \u03b1\n\u22a2 IsLUB (l '' range f) (l (sSup (range f)))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.range_castSucc", "start": [1093, 1], "end": [1095, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "Subtype.mk_eq_bot_iff", "start": [764, 1], "end": [766, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.union_def", "start": [715, 1], "end": [716, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean", "full_name": "ArithmeticFunction.coe_coe", "start": [204, 1], "end": [207, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\ninst\u271d : AddGroupWithOne R\nf : ArithmeticFunction \u2115\n\u22a2 \u2191\u2191f = \u2191f", "state_after": "case h\nR : Type u_1\ninst\u271d : AddGroupWithOne R\nf : ArithmeticFunction \u2115\nx\u271d : \u2115\n\u22a2 \u2191\u2191f x\u271d = \u2191f x\u271d"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\nR : Type u_1\ninst\u271d : AddGroupWithOne R\nf : ArithmeticFunction \u2115\nx\u271d : \u2115\n\u22a2 \u2191\u2191f x\u271d = \u2191f x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeAbelianGroup.lean", "full_name": "FreeAbelianGroup.lift.map_hom", "start": [129, 1], "end": [135, 31], "traced_tactics": [{"tactic": "show (g.comp (lift f)) a = lift (g \u2218 f) a", "annotated_tactic": ["show (g.comp (<a>lift</a> f)) a = <a>lift</a> (g \u2218 f) a", [{"full_name": "FreeAbelianGroup.lift", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/FreeAbelianGroup.lean", "def_pos": [99, 5], "def_end_pos": [99, 9]}, {"full_name": "FreeAbelianGroup.lift", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/FreeAbelianGroup.lean", "def_pos": [99, 5], "def_end_pos": [99, 9]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type v\ninst\u271d\u00b2 : AddCommGroup \u03b2\u271d\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : AddCommGroup \u03b3\na : FreeAbelianGroup \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192+ \u03b3\n\u22a2 g ((lift f) a) = (lift (\u21d1g \u2218 f)) a", "state_after": "\u03b1\u271d : Type u\n\u03b2\u271d : Type v\ninst\u271d\u00b2 : AddCommGroup \u03b2\u271d\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : AddCommGroup \u03b3\na : FreeAbelianGroup \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192+ \u03b3\n\u22a2 (AddMonoidHom.comp g (lift f)) a = (lift (\u21d1g \u2218 f)) a"}, {"tactic": "apply lift.unique", "annotated_tactic": ["apply <a>lift.unique</a>", [{"full_name": "FreeAbelianGroup.lift.unique", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/FreeAbelianGroup.lean", "def_pos": [118, 19], "def_end_pos": [118, 25]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type v\ninst\u271d\u00b2 : AddCommGroup \u03b2\u271d\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : AddCommGroup \u03b3\na : FreeAbelianGroup \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192+ \u03b3\n\u22a2 (AddMonoidHom.comp g (lift f)) a = (lift (\u21d1g \u2218 f)) a", "state_after": "case hg\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\ninst\u271d\u00b2 : AddCommGroup \u03b2\u271d\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : AddCommGroup \u03b3\na : FreeAbelianGroup \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192+ \u03b3\n\u22a2 \u2200 (x : \u03b1), (AddMonoidHom.comp g (lift f)) (of x) = (\u21d1g \u2218 f) x"}, {"tactic": "intro a", "annotated_tactic": ["intro a", []], "state_before": "case hg\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\ninst\u271d\u00b2 : AddCommGroup \u03b2\u271d\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : AddCommGroup \u03b3\na : FreeAbelianGroup \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192+ \u03b3\n\u22a2 \u2200 (x : \u03b1), (AddMonoidHom.comp g (lift f)) (of x) = (\u21d1g \u2218 f) x", "state_after": "case hg\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\ninst\u271d\u00b2 : AddCommGroup \u03b2\u271d\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : AddCommGroup \u03b3\na\u271d : FreeAbelianGroup \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192+ \u03b3\na : \u03b1\n\u22a2 (AddMonoidHom.comp g (lift f)) (of a) = (\u21d1g \u2218 f) a"}, {"tactic": "show g ((lift f) (of a)) = g (f a)", "annotated_tactic": ["show g ((<a>lift</a> f) (<a>of</a> a)) = g (f a)", [{"full_name": "FreeAbelianGroup.lift", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/FreeAbelianGroup.lean", "def_pos": [99, 5], "def_end_pos": [99, 9]}, {"full_name": "FreeAbelianGroup.of", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/FreeAbelianGroup.lean", "def_pos": [94, 5], "def_end_pos": [94, 7]}]], "state_before": "case hg\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\ninst\u271d\u00b2 : AddCommGroup \u03b2\u271d\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : AddCommGroup \u03b3\na\u271d : FreeAbelianGroup \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192+ \u03b3\na : \u03b1\n\u22a2 (AddMonoidHom.comp g (lift f)) (of a) = (\u21d1g \u2218 f) a", "state_after": "case hg\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\ninst\u271d\u00b2 : AddCommGroup \u03b2\u271d\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : AddCommGroup \u03b3\na\u271d : FreeAbelianGroup \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192+ \u03b3\na : \u03b1\n\u22a2 g ((lift f) (of a)) = g (f a)"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "bit0_neg", "start": [545, 1], "end": [545, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Basic.lean", "full_name": "UniformSpace.toTopologicalSpace_iInf", "start": [1322, 1], "end": [1325, 75], "traced_tactics": [{"tactic": "simp only [@nhds_eq_comap_uniformity _ (iInf u), nhds_iInf,\niInf_uniformity, @nhds_eq_comap_uniformity _ (u _), Filter.comap_iInf]", "annotated_tactic": ["simp only [@<a>nhds_eq_comap_uniformity</a> _ (<a>iInf</a> u), <a>nhds_iInf</a>,\n    <a>iInf_uniformity</a>, @<a>nhds_eq_comap_uniformity</a> _ (u _), <a>Filter.comap_iInf</a>]", [{"full_name": "nhds_eq_comap_uniformity", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [724, 9], "def_end_pos": [724, 33]}, {"full_name": "iInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [69, 5], "def_end_pos": [69, 9]}, {"full_name": "nhds_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [644, 9], "def_end_pos": [644, 18]}, {"full_name": "iInf_uniformity", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [1200, 9], "def_end_pos": [1200, 24]}, {"full_name": "nhds_eq_comap_uniformity", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [724, 9], "def_end_pos": [724, 33]}, {"full_name": "Filter.comap_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2369, 9], "def_end_pos": [2369, 19]}]], "state_before": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\n\u03b4 : Type ud\n\u03b9\u271d : Sort u_1\n\u03b9 : Sort u_2\nu : \u03b9 \u2192 UniformSpace \u03b1\na : \u03b1\n\u22a2 \ud835\udcdd a = \ud835\udcdd a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Indexes.lean", "full_name": "List.mapIdxGo_length", "start": [119, 1], "end": [125, 53], "traced_tactics": [{"tactic": "intro f l", "annotated_tactic": ["intro f l", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u22a2 \u2200 (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (l : List \u03b1) (arr : Array \u03b2), length (mapIdx.go f l arr) = length l + Array.size arr", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nl : List \u03b1\n\u22a2 \u2200 (arr : Array \u03b2), length (mapIdx.go f l arr) = length l + Array.size arr"}, {"tactic": "induction' l with head tail ih", "annotated_tactic": ["induction' l with head tail ih", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nl : List \u03b1\n\u22a2 \u2200 (arr : Array \u03b2), length (mapIdx.go f l arr) = length l + Array.size arr", "state_after": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (arr : Array \u03b2), length (mapIdx.go f [] arr) = length [] + Array.size arr\n\ncase cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\n\u22a2 \u2200 (arr : Array \u03b2), length (mapIdx.go f (head :: tail) arr) = length (head :: tail) + Array.size arr"}, {"tactic": "intro", "annotated_tactic": ["intro", []], "state_before": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (arr : Array \u03b2), length (mapIdx.go f [] arr) = length [] + Array.size arr", "state_after": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\narr\u271d : Array \u03b2\n\u22a2 length (mapIdx.go f [] arr\u271d) = length [] + Array.size arr\u271d"}, {"tactic": "simp only [mapIdx.go, Array.toList_eq, length_nil, zero_add]", "annotated_tactic": ["simp only [<a>mapIdx.go</a>, <a>Array.toList_eq</a>, <a>length_nil</a>, <a>zero_add</a>]", [{"full_name": "List.mapIdx.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [303, 17], "def_end_pos": [303, 19]}, {"full_name": "Array.toList_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [96, 17], "def_end_pos": [96, 26]}, {"full_name": "List.length_nil", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [77, 17], "def_end_pos": [77, 27]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\narr\u271d : Array \u03b2\n\u22a2 length (mapIdx.go f [] arr\u271d) = length [] + Array.size arr\u271d", "state_after": "no goals"}, {"tactic": "intro", "annotated_tactic": ["intro", []], "state_before": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\n\u22a2 \u2200 (arr : Array \u03b2), length (mapIdx.go f (head :: tail) arr) = length (head :: tail) + Array.size arr", "state_after": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\narr\u271d : Array \u03b2\n\u22a2 length (mapIdx.go f (head :: tail) arr\u271d) = length (head :: tail) + Array.size arr\u271d"}, {"tactic": "simp only [mapIdx.go]", "annotated_tactic": ["simp only [<a>mapIdx.go</a>]", [{"full_name": "List.mapIdx.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [303, 17], "def_end_pos": [303, 19]}]], "state_before": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\narr\u271d : Array \u03b2\n\u22a2 length (mapIdx.go f (head :: tail) arr\u271d) = length (head :: tail) + Array.size arr\u271d", "state_after": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\narr\u271d : Array \u03b2\n\u22a2 length (mapIdx.go f tail (Array.push arr\u271d (f (Array.size arr\u271d) head))) = length (head :: tail) + Array.size arr\u271d"}, {"tactic": "rw [ih]", "annotated_tactic": ["rw [ih]", []], "state_before": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\narr\u271d : Array \u03b2\n\u22a2 length (mapIdx.go f tail (Array.push arr\u271d (f (Array.size arr\u271d) head))) = length (head :: tail) + Array.size arr\u271d", "state_after": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\narr\u271d : Array \u03b2\n\u22a2 length tail + Array.size (Array.push arr\u271d (f (Array.size arr\u271d) head)) = length (head :: tail) + Array.size arr\u271d"}, {"tactic": "simp only [Array.size_push, length_cons]", "annotated_tactic": ["simp only [<a>Array.size_push</a>, <a>length_cons</a>]", [{"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "List.length_cons", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2332, 17], "def_end_pos": [2332, 33]}]], "state_before": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\narr\u271d : Array \u03b2\n\u22a2 length tail + Array.size (Array.push arr\u271d (f (Array.size arr\u271d) head)) = length (head :: tail) + Array.size arr\u271d", "state_after": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\narr\u271d : Array \u03b2\n\u22a2 length tail + (Array.size arr\u271d + 1) = Nat.succ (length tail) + Array.size arr\u271d"}, {"tactic": "simp only [Nat.add_succ, add_zero, Nat.add_comm]", "annotated_tactic": ["simp only [<a>Nat.add_succ</a>, <a>add_zero</a>, <a>Nat.add_comm</a>]", [{"full_name": "Nat.add_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 17]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "Nat.add_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}]], "state_before": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 (arr : Array \u03b2), length (mapIdx.go f tail arr) = length tail + Array.size arr\narr\u271d : Array \u03b2\n\u22a2 length tail + (Array.size arr\u271d + 1) = Nat.succ (length tail) + Array.size arr\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.mulVecLin_transpose", "start": [245, 9], "end": [247, 31], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d : Fintype m\nM : Matrix m n R\n\u22a2 mulVecLin M\u1d40 = vecMulLinear M", "state_after": "case h.h\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d : Fintype m\nM : Matrix m n R\nx\u271d\u00b9 : m \u2192 R\nx\u271d : n\n\u22a2 (mulVecLin M\u1d40) x\u271d\u00b9 x\u271d = (vecMulLinear M) x\u271d\u00b9 x\u271d"}, {"tactic": "simp [mulVec_transpose]", "annotated_tactic": ["simp [<a>mulVec_transpose</a>]", [{"full_name": "Matrix.mulVec_transpose", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1958, 9], "def_end_pos": [1958, 25]}]], "state_before": "case h.h\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d : Fintype m\nM : Matrix m n R\nx\u271d\u00b9 : m \u2192 R\nx\u271d : n\n\u22a2 (mulVecLin M\u1d40) x\u271d\u00b9 x\u271d = (vecMulLinear M) x\u271d\u00b9 x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "normalize_eq_normalize_iff", "start": [184, 1], "end": [186, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.sup'_eq_sup", "start": [1160, 1], "end": [1161, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Control/Basic.lean", "full_name": "fish_assoc", "start": [110, 1], "end": [112, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "full_name": "AffineMap.lineMap_apply_module", "start": [514, 1], "end": [515, 57], "traced_tactics": [{"tactic": "simp [lineMap_apply_module', smul_sub, sub_smul]", "annotated_tactic": ["simp [<a>lineMap_apply_module'</a>, <a>smul_sub</a>, <a>sub_smul</a>]", [{"full_name": "AffineMap.lineMap_apply_module'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "def_pos": [510, 9], "def_end_pos": [510, 30]}, {"full_name": "smul_sub", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [1024, 9], "def_end_pos": [1024, 17]}, {"full_name": "sub_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [274, 9], "def_end_pos": [274, 17]}]], "state_before": "k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\nV3 : Type u_6\nP3 : Type u_7\nV4 : Type u_8\nP4 : Type u_9\ninst\u271d\u00b9\u00b2 : Ring k\ninst\u271d\u00b9\u00b9 : AddCommGroup V1\ninst\u271d\u00b9\u2070 : Module k V1\ninst\u271d\u2079 : AffineSpace V1 P1\ninst\u271d\u2078 : AddCommGroup V2\ninst\u271d\u2077 : Module k V2\ninst\u271d\u2076 : AffineSpace V2 P2\ninst\u271d\u2075 : AddCommGroup V3\ninst\u271d\u2074 : Module k V3\ninst\u271d\u00b3 : AffineSpace V3 P3\ninst\u271d\u00b2 : AddCommGroup V4\ninst\u271d\u00b9 : Module k V4\ninst\u271d : AffineSpace V4 P4\np\u2080 p\u2081 : V1\nc : k\n\u22a2 (lineMap p\u2080 p\u2081) c = (1 - c) \u2022 p\u2080 + c \u2022 p\u2081", "state_after": "k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\nV3 : Type u_6\nP3 : Type u_7\nV4 : Type u_8\nP4 : Type u_9\ninst\u271d\u00b9\u00b2 : Ring k\ninst\u271d\u00b9\u00b9 : AddCommGroup V1\ninst\u271d\u00b9\u2070 : Module k V1\ninst\u271d\u2079 : AffineSpace V1 P1\ninst\u271d\u2078 : AddCommGroup V2\ninst\u271d\u2077 : Module k V2\ninst\u271d\u2076 : AffineSpace V2 P2\ninst\u271d\u2075 : AddCommGroup V3\ninst\u271d\u2074 : Module k V3\ninst\u271d\u00b3 : AffineSpace V3 P3\ninst\u271d\u00b2 : AddCommGroup V4\ninst\u271d\u00b9 : Module k V4\ninst\u271d : AffineSpace V4 P4\np\u2080 p\u2081 : V1\nc : k\n\u22a2 c \u2022 p\u2081 - c \u2022 p\u2080 + p\u2080 = p\u2080 - c \u2022 p\u2080 + c \u2022 p\u2081"}, {"tactic": "abel", "annotated_tactic": ["abel", []], "state_before": "k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\nV3 : Type u_6\nP3 : Type u_7\nV4 : Type u_8\nP4 : Type u_9\ninst\u271d\u00b9\u00b2 : Ring k\ninst\u271d\u00b9\u00b9 : AddCommGroup V1\ninst\u271d\u00b9\u2070 : Module k V1\ninst\u271d\u2079 : AffineSpace V1 P1\ninst\u271d\u2078 : AddCommGroup V2\ninst\u271d\u2077 : Module k V2\ninst\u271d\u2076 : AffineSpace V2 P2\ninst\u271d\u2075 : AddCommGroup V3\ninst\u271d\u2074 : Module k V3\ninst\u271d\u00b3 : AffineSpace V3 P3\ninst\u271d\u00b2 : AddCommGroup V4\ninst\u271d\u00b9 : Module k V4\ninst\u271d : AffineSpace V4 P4\np\u2080 p\u2081 : V1\nc : k\n\u22a2 c \u2022 p\u2081 - c \u2022 p\u2080 + p\u2080 = p\u2080 - c \u2022 p\u2080 + c \u2022 p\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "linearIndependent_iUnion_finite", "start": [829, 1], "end": [852, 90], "traced_tactics": [{"tactic": "nontriviality R", "annotated_tactic": ["nontriviality R", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\n\u22a2 LinearIndependent R fun ji => f ji.fst ji.snd", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\n\u22a2 LinearIndependent R fun ji => f ji.fst ji.snd"}, {"tactic": "apply LinearIndependent.of_subtype_range", "annotated_tactic": ["apply <a>LinearIndependent.of_subtype_range</a>", [{"full_name": "LinearIndependent.of_subtype_range", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [353, 8], "def_end_pos": [353, 42]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\n\u22a2 LinearIndependent R fun ji => f ji.fst ji.snd", "state_after": "case hf\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\n\u22a2 Injective fun ji => f ji.fst ji.snd\n\ncase a\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\n\u22a2 LinearIndependent (\u03b9 := { x // x \u2208 range fun ji => f ji.fst ji.snd }) R Subtype.val"}, {"tactic": "rw [range_sigma_eq_iUnion_range]", "annotated_tactic": ["rw [<a>range_sigma_eq_iUnion_range</a>]", [{"full_name": "Set.range_sigma_eq_iUnion_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1267, 9], "def_end_pos": [1267, 36]}]], "state_before": "case a\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\n\u22a2 LinearIndependent (\u03b9 := { x // x \u2208 range fun ji => f ji.fst ji.snd }) R Subtype.val", "state_after": "case a\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\n\u22a2 LinearIndependent (\u03b9 := { x // x \u2208 \u22c3 a, range fun b => f { fst := a, snd := b }.fst { fst := a, snd := b }.snd }) R\n    Subtype.val"}, {"tactic": "apply linearIndependent_iUnion_finite_subtype (fun j => (hindep j).to_subtype_range) hd", "annotated_tactic": ["apply <a>linearIndependent_iUnion_finite_subtype</a> (fun j => (hindep j).<a>to_subtype_range</a>) hd", [{"full_name": "linearIndependent_iUnion_finite_subtype", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [810, 9], "def_end_pos": [810, 48]}, {"full_name": "LinearIndependent.to_subtype_range", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [579, 9], "def_end_pos": [579, 43]}]], "state_before": "case a\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\n\u22a2 LinearIndependent (\u03b9 := { x // x \u2208 \u22c3 a, range fun b => f { fst := a, snd := b }.fst { fst := a, snd := b }.snd }) R\n    Subtype.val", "state_after": "no goals"}, {"tactic": "rintro \u27e8x\u2081, x\u2082\u27e9 \u27e8y\u2081, y\u2082\u27e9 hxy", "annotated_tactic": ["rintro \u27e8x\u2081, x\u2082\u27e9 \u27e8y\u2081, y\u2082\u27e9 hxy", []], "state_before": "case hf\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\n\u22a2 Injective fun ji => f ji.fst ji.snd", "state_after": "case hf.mk.mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }"}, {"tactic": "by_cases h_cases : x\u2081 = y\u2081", "annotated_tactic": ["by_cases h_cases : x\u2081 = y\u2081", []], "state_before": "case hf.mk.mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }", "state_after": "case pos\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : x\u2081 = y\u2081\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }\n\ncase neg\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }"}, {"tactic": "subst h_cases", "annotated_tactic": ["subst h_cases", []], "state_before": "case pos\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : x\u2081 = y\u2081\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }\n\ncase neg\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }", "state_after": "case pos\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := x\u2081, snd := y\u2082 }\n\ncase neg\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }"}, {"tactic": "apply Sigma.eq", "annotated_tactic": ["apply <a>Sigma.eq</a>", [{"full_name": "Sigma.eq", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Sigma/Basic.lean", "def_pos": [16, 19], "def_end_pos": [16, 27]}]], "state_before": "case pos\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := x\u2081, snd := y\u2082 }", "state_after": "case pos.a\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 Eq.recOn ?pos.h\u2081\u271d { fst := x\u2081, snd := x\u2082 }.snd = { fst := x\u2081, snd := y\u2082 }.snd\n\ncase pos.h\u2081\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 }.fst = { fst := x\u2081, snd := y\u2082 }.fst"}, {"tactic": "rw [LinearIndependent.injective (hindep _) hxy]", "annotated_tactic": ["rw [<a>LinearIndependent.injective</a> (hindep _) hxy]", [{"full_name": "LinearIndependent.injective", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [567, 9], "def_end_pos": [567, 36]}]], "state_before": "case pos.a\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 Eq.recOn ?pos.h\u2081\u271d { fst := x\u2081, snd := x\u2082 }.snd = { fst := x\u2081, snd := y\u2082 }.snd\n\ncase pos.h\u2081\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 }.fst = { fst := x\u2081, snd := y\u2082 }.fst", "state_after": "case pos.h\u2081\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 }.fst = { fst := x\u2081, snd := y\u2082 }.fst\n\ncase pos.h\u2081\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 }.fst = { fst := x\u2081, snd := y\u2082 }.fst"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case pos.h\u2081\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 }.fst = { fst := x\u2081, snd := y\u2082 }.fst\n\ncase pos.h\u2081\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 y\u2082 : \u03b9s x\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := y\u2082 }\n\u22a2 { fst := x\u2081, snd := x\u2082 }.fst = { fst := x\u2081, snd := y\u2082 }.fst", "state_after": "no goals"}, {"tactic": "have h0 : f x\u2081 x\u2082 = 0 := by\n  apply\n    disjoint_def.1 (hd x\u2081 {y\u2081} (finite_singleton y\u2081) fun h => h_cases (eq_of_mem_singleton h))\n      (f x\u2081 x\u2082) (subset_span (mem_range_self _))\n  rw [iSup_singleton]\n  simp only at hxy\n  rw [hxy]\n  exact subset_span (mem_range_self y\u2082)", "annotated_tactic": ["have h0 : f x\u2081 x\u2082 = 0 := by\n        apply\n          <a>disjoint_def</a>.1 (hd x\u2081 {y\u2081} (<a>finite_singleton</a> y\u2081) fun h => h_cases (<a>eq_of_mem_singleton</a> h))\n            (f x\u2081 x\u2082) (<a>subset_span</a> (<a>mem_range_self</a> _))\n        rw [<a>iSup_singleton</a>]\n        simp only at hxy\n        rw [hxy]\n        exact <a>subset_span</a> (<a>mem_range_self</a> y\u2082)", [{"full_name": "Submodule.disjoint_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [375, 9], "def_end_pos": [375, 21]}, {"full_name": "Set.finite_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [846, 9], "def_end_pos": [846, 25]}, {"full_name": "Set.eq_of_mem_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1263, 9], "def_end_pos": [1263, 28]}, {"full_name": "Submodule.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}, {"full_name": "iSup_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1430, 9], "def_end_pos": [1430, 23]}, {"full_name": "Submodule.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "case neg\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }", "state_after": "case neg\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\nh0 : f x\u2081 x\u2082 = 0\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }"}, {"tactic": "exact False.elim ((hindep x\u2081).ne_zero _ h0)", "annotated_tactic": ["exact <a>False.elim</a> ((hindep x\u2081).<a>ne_zero</a> _ h0)", [{"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}, {"full_name": "LinearIndependent.ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [200, 9], "def_end_pos": [200, 34]}]], "state_before": "case neg\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\nh0 : f x\u2081 x\u2082 = 0\n\u22a2 { fst := x\u2081, snd := x\u2082 } = { fst := y\u2081, snd := y\u2082 }", "state_after": "no goals"}, {"tactic": "apply\n  disjoint_def.1 (hd x\u2081 {y\u2081} (finite_singleton y\u2081) fun h => h_cases (eq_of_mem_singleton h))\n    (f x\u2081 x\u2082) (subset_span (mem_range_self _))", "annotated_tactic": ["apply\n          <a>disjoint_def</a>.1 (hd x\u2081 {y\u2081} (<a>finite_singleton</a> y\u2081) fun h => h_cases (<a>eq_of_mem_singleton</a> h))\n            (f x\u2081 x\u2082) (<a>subset_span</a> (<a>mem_range_self</a> _))", [{"full_name": "Submodule.disjoint_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [375, 9], "def_end_pos": [375, 21]}, {"full_name": "Set.finite_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [846, 9], "def_end_pos": [846, 25]}, {"full_name": "Set.eq_of_mem_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1263, 9], "def_end_pos": [1263, 28]}, {"full_name": "Submodule.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 f x\u2081 x\u2082 = 0", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 f x\u2081 x\u2082 \u2208 \u2a06 i \u2208 {y\u2081}, span R (range (f i))"}, {"tactic": "rw [iSup_singleton]", "annotated_tactic": ["rw [<a>iSup_singleton</a>]", [{"full_name": "iSup_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1430, 9], "def_end_pos": [1430, 23]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 f x\u2081 x\u2082 \u2208 \u2a06 i \u2208 {y\u2081}, span R (range (f i))", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 f x\u2081 x\u2082 \u2208 span R (range (f y\u2081))"}, {"tactic": "simp only at hxy", "annotated_tactic": ["simp only at hxy", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : (fun ji => f ji.fst ji.snd) { fst := x\u2081, snd := x\u2082 } = (fun ji => f ji.fst ji.snd) { fst := y\u2081, snd := y\u2082 }\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 f x\u2081 x\u2082 \u2208 span R (range (f y\u2081))", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : f x\u2081 x\u2082 = f y\u2081 y\u2082\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 f x\u2081 x\u2082 \u2208 span R (range (f y\u2081))"}, {"tactic": "rw [hxy]", "annotated_tactic": ["rw [hxy]", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : f x\u2081 x\u2082 = f y\u2081 y\u2082\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 f x\u2081 x\u2082 \u2208 span R (range (f y\u2081))", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : f x\u2081 x\u2082 = f y\u2081 y\u2082\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 f y\u2081 y\u2082 \u2208 span R (range (f y\u2081))"}, {"tactic": "exact subset_span (mem_range_self y\u2082)", "annotated_tactic": ["exact <a>subset_span</a> (<a>mem_range_self</a> y\u2082)", [{"full_name": "Submodule.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\n\u03b7 : Type u_8\n\u03b9s : \u03b7 \u2192 Type u_9\nf : (j : \u03b7) \u2192 \u03b9s j \u2192 M\nhindep : \u2200 (j : \u03b7), LinearIndependent R (f j)\nhd : \u2200 (i : \u03b7) (t : Set \u03b7), Set.Finite t \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))\na\u271d : Nontrivial R\nx\u2081 : \u03b7\nx\u2082 : \u03b9s x\u2081\ny\u2081 : \u03b7\ny\u2082 : \u03b9s y\u2081\nhxy : f x\u2081 x\u2082 = f y\u2081 y\u2082\nh_cases : \u00acx\u2081 = y\u2081\n\u22a2 f y\u2081 y\u2082 \u2208 span R (range (f y\u2081))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Minimal.lean", "full_name": "maximals_Ioc", "start": [472, 1], "end": [474, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Chain.lean", "full_name": "IsMaxChain.bot_mem", "start": [155, 1], "end": [156, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/RootsOfUnity/Minpoly.lean", "full_name": "IsPrimitiveRoot.minpoly_dvd_mod_p", "start": [109, 1], "end": [112, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.X_pow_comp", "start": [611, 1], "end": [614, 37], "traced_tactics": [{"tactic": "induction' k with k ih", "annotated_tactic": ["induction' k with k ih", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nk : \u2115\n\u22a2 comp (X ^ k) p = p ^ k", "state_after": "case zero\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\n\u22a2 comp (X ^ Nat.zero) p = p ^ Nat.zero\n\ncase succ\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nk : \u2115\nih : comp (X ^ k) p = p ^ k\n\u22a2 comp (X ^ Nat.succ k) p = p ^ Nat.succ k"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\n\u22a2 comp (X ^ Nat.zero) p = p ^ Nat.zero", "state_after": "no goals"}, {"tactic": "simp [pow_succ', mul_X_comp, ih]", "annotated_tactic": ["simp [<a>pow_succ'</a>, <a>mul_X_comp</a>, ih]", [{"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}, {"full_name": "Polynomial.mul_X_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [602, 9], "def_end_pos": [602, 19]}]], "state_before": "case succ\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nk : \u2115\nih : comp (X ^ k) p = p ^ k\n\u22a2 comp (X ^ Nat.succ k) p = p ^ Nat.succ k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean", "full_name": "IsPrimitiveRoot.sub_one_norm_two", "start": [440, 1], "end": [453, 99], "traced_tactics": [{"tactic": "have : 2 < (2 : \u2115+) ^ k := by\n  simp only [\u2190 coe_lt_coe, one_coe, pow_coe]\n  nth_rw 1 [\u2190 pow_one 2]\n  exact pow_lt_pow_right one_lt_two (lt_of_lt_of_le one_lt_two hk)", "annotated_tactic": ["have : 2 < (2 : \u2115+) ^ k := by\n    simp only [\u2190 <a>coe_lt_coe</a>, <a>one_coe</a>, <a>pow_coe</a>]\n    nth_rw 1 [\u2190 <a>pow_one</a> 2]\n    exact <a>pow_lt_pow_right</a> <a>one_lt_two</a> (<a>lt_of_lt_of_le</a> <a>one_lt_two</a> hk)", [{"full_name": "PNat.coe_lt_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/PNat/Defs.lean", "def_pos": [143, 9], "def_end_pos": [143, 19]}, {"full_name": "PNat.one_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/PNat/Defs.lean", "def_pos": [198, 9], "def_end_pos": [198, 16]}, {"full_name": "PNat.pow_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/PNat/Basic.lean", "def_pos": [277, 9], "def_end_pos": [277, 16]}, {"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}, {"full_name": "pow_lt_pow_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [262, 9], "def_end_pos": [262, 25]}, {"full_name": "one_lt_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [106, 7], "def_end_pos": [106, 17]}, {"full_name": "lt_of_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [109, 9], "def_end_pos": [109, 23]}, {"full_name": "one_lt_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [106, 7], "def_end_pos": [106, 17]}]], "state_before": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nhirr : Irreducible (cyclotomic (2 ^ k) K)\n\u22a2 (Algebra.norm K) (\u03b6 - 1) = 2", "state_after": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nhirr : Irreducible (cyclotomic (2 ^ k) K)\nthis : 2 < 2 ^ k\n\u22a2 (Algebra.norm K) (\u03b6 - 1) = 2"}, {"tactic": "replace hirr : Irreducible (cyclotomic ((2 : \u2115+) ^ k : \u2115+) K) := by simpa using hirr", "annotated_tactic": ["replace hirr : <a>Irreducible</a> (<a>cyclotomic</a> ((2 : \u2115+) ^ k : \u2115+) K) := by simpa using hirr", [{"full_name": "Irreducible", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [172, 11], "def_end_pos": [172, 22]}, {"full_name": "Polynomial.cyclotomic", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [253, 5], "def_end_pos": [253, 15]}]], "state_before": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nhirr : Irreducible (cyclotomic (2 ^ k) K)\nthis : 2 < 2 ^ k\n\u22a2 (Algebra.norm K) (\u03b6 - 1) = 2", "state_after": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nthis : 2 < 2 ^ k\nhirr : Irreducible (cyclotomic (\u2191(2 ^ k)) K)\n\u22a2 (Algebra.norm K) (\u03b6 - 1) = 2"}, {"tactic": "replace h\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k : \u2115+) := by simpa using h\u03b6", "annotated_tactic": ["replace h\u03b6 : <a>IsPrimitiveRoot</a> \u03b6 (2 ^ k : \u2115+) := by simpa using h\u03b6", [{"full_name": "IsPrimitiveRoot", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/RootsOfUnity/Basic.lean", "def_pos": [289, 11], "def_end_pos": [289, 26]}]], "state_before": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nthis : 2 < 2 ^ k\nhirr : Irreducible (cyclotomic (\u2191(2 ^ k)) K)\n\u22a2 (Algebra.norm K) (\u03b6 - 1) = 2", "state_after": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nthis : 2 < 2 ^ k\nhirr : Irreducible (cyclotomic (\u2191(2 ^ k)) K)\nh\u03b6 : IsPrimitiveRoot \u03b6 \u2191(2 ^ k)\n\u22a2 (Algebra.norm K) (\u03b6 - 1) = 2"}, {"tactic": "obtain \u27e8k\u2081, hk\u2081\u27e9 := exists_eq_succ_of_ne_zero (lt_of_lt_of_le zero_lt_two hk).ne.symm", "annotated_tactic": ["obtain \u27e8k\u2081, hk\u2081\u27e9 := <a>exists_eq_succ_of_ne_zero</a> (<a>lt_of_lt_of_le</a> <a>zero_lt_two</a> hk).ne.symm", [{"full_name": "Nat.exists_eq_succ_of_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [144, 9], "def_end_pos": [144, 34]}, {"full_name": "lt_of_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [109, 9], "def_end_pos": [109, 23]}, {"full_name": "zero_lt_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [71, 15], "def_end_pos": [71, 26]}]], "state_before": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nthis : 2 < 2 ^ k\nhirr : Irreducible (cyclotomic (\u2191(2 ^ k)) K)\nh\u03b6 : IsPrimitiveRoot \u03b6 \u2191(2 ^ k)\n\u22a2 (Algebra.norm K) (\u03b6 - 1) = 2", "state_after": "case intro\np n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nthis : 2 < 2 ^ k\nhirr : Irreducible (cyclotomic (\u2191(2 ^ k)) K)\nh\u03b6 : IsPrimitiveRoot \u03b6 \u2191(2 ^ k)\nk\u2081 : \u2115\nhk\u2081 : k = succ k\u2081\n\u22a2 (Algebra.norm K) (\u03b6 - 1) = 2"}, {"tactic": "simpa [hk\u2081, show ((2 : \u2115+) : \u2115) = 2 from rfl] using sub_one_norm_eq_eval_cyclotomic h\u03b6 this hirr", "annotated_tactic": ["simpa [hk\u2081, show ((2 : \u2115+) : \u2115) = 2 from <a>rfl</a>] using <a>sub_one_norm_eq_eval_cyclotomic</a> h\u03b6 this hirr", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "IsPrimitiveRoot.sub_one_norm_eq_eval_cyclotomic", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean", "def_pos": [255, 9], "def_end_pos": [255, 40]}]], "state_before": "case intro\np n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nthis : 2 < 2 ^ k\nhirr : Irreducible (cyclotomic (\u2191(2 ^ k)) K)\nh\u03b6 : IsPrimitiveRoot \u03b6 \u2191(2 ^ k)\nk\u2081 : \u2115\nhk\u2081 : k = succ k\u2081\n\u22a2 (Algebra.norm K) (\u03b6 - 1) = 2", "state_after": "no goals"}, {"tactic": "simp only [\u2190 coe_lt_coe, one_coe, pow_coe]", "annotated_tactic": ["simp only [\u2190 <a>coe_lt_coe</a>, <a>one_coe</a>, <a>pow_coe</a>]", [{"full_name": "PNat.coe_lt_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/PNat/Defs.lean", "def_pos": [143, 9], "def_end_pos": [143, 19]}, {"full_name": "PNat.one_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/PNat/Defs.lean", "def_pos": [198, 9], "def_end_pos": [198, 16]}, {"full_name": "PNat.pow_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/PNat/Basic.lean", "def_pos": [277, 9], "def_end_pos": [277, 16]}]], "state_before": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nhirr : Irreducible (cyclotomic (2 ^ k) K)\n\u22a2 2 < 2 ^ k", "state_after": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nhirr : Irreducible (cyclotomic (2 ^ k) K)\n\u22a2 \u21912 < \u21912 ^ k"}, {"tactic": "nth_rw 1 [\u2190 pow_one 2]", "annotated_tactic": ["nth_rw 1 [\u2190 <a>pow_one</a> 2]", [{"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}]], "state_before": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nhirr : Irreducible (cyclotomic (2 ^ k) K)\n\u22a2 \u21912 < \u21912 ^ k", "state_after": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nhirr : Irreducible (cyclotomic (2 ^ k) K)\n\u22a2 \u2191(2 ^ 1) < \u21912 ^ k"}, {"tactic": "exact pow_lt_pow_right one_lt_two (lt_of_lt_of_le one_lt_two hk)", "annotated_tactic": ["exact <a>pow_lt_pow_right</a> <a>one_lt_two</a> (<a>lt_of_lt_of_le</a> <a>one_lt_two</a> hk)", [{"full_name": "pow_lt_pow_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [262, 9], "def_end_pos": [262, 25]}, {"full_name": "one_lt_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [106, 7], "def_end_pos": [106, 17]}, {"full_name": "lt_of_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [109, 9], "def_end_pos": [109, 23]}, {"full_name": "one_lt_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [106, 7], "def_end_pos": [106, 17]}]], "state_before": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nhirr : Irreducible (cyclotomic (2 ^ k) K)\n\u22a2 \u2191(2 ^ 1) < \u21912 ^ k", "state_after": "no goals"}, {"tactic": "simpa using hirr", "annotated_tactic": ["simpa using hirr", []], "state_before": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nhirr : Irreducible (cyclotomic (2 ^ k) K)\nthis : 2 < 2 ^ k\n\u22a2 Irreducible (cyclotomic (\u2191(2 ^ k)) K)", "state_after": "no goals"}, {"tactic": "simpa using h\u03b6", "annotated_tactic": ["simpa using h\u03b6", []], "state_before": "p n : \u2115+\nA : Type w\nB : Type z\nK : Type u\nL : Type v\nC : Type w\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsCyclotomicExtension {n} A B\ninst\u271d\u00b2 : Field L\n\u03b6 : L\nh\u03b6\u271d : IsPrimitiveRoot \u03b6 \u2191n\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra K L\nk : \u2115\nh\u03b6 : IsPrimitiveRoot \u03b6 (2 ^ k)\nhk : 2 \u2264 k\nH : IsCyclotomicExtension {2 ^ k} K L\nthis : 2 < 2 ^ k\nhirr : Irreducible (cyclotomic (\u2191(2 ^ k)) K)\n\u22a2 IsPrimitiveRoot \u03b6 \u2191(2 ^ k)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.orderIsoMapComap_symm_apply'", "start": [579, 1], "end": [581, 30], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "mathd_algebra_206", "start": [1062, 1], "end": [1064, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "a b : \u211d\nf : \u211d \u2192 \u211d\nh\u2080 : \u2200 (x : \u211d), f x = x ^ 2 + a * x + b\nh\u2081 : 2 * a \u2260 b\nh\u2082 : f (2 * a) = 0\nh\u2083 : f b = 0\n\u22a2 a + b = -1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.mem_toSubmonoid", "start": [432, 1], "end": [433, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.nil_infix", "start": [1869, 1], "end": [1869, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "full_name": "hasSum_empty", "start": [37, 1], "end": [38, 31], "traced_tactics": [{"tactic": "convert @hasSum_zero \u03b1 \u03b2 _ _", "annotated_tactic": ["convert @<a>hasSum_zero</a> \u03b1 \u03b2 _ _", [{"full_name": "hasSum_zero", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "def_pos": [34, 9], "def_end_pos": [34, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na b : \u03b1\ns : Finset \u03b2\ninst\u271d : IsEmpty \u03b2\n\u22a2 HasSum f 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/EReal.lean", "full_name": "EReal.abs_neg", "start": [1237, 11], "end": [1240, 60], "traced_tactics": [{"tactic": "rw [abs_def, \u2190 coe_neg, abs_def, abs_neg]", "annotated_tactic": ["rw [<a>abs_def</a>, \u2190 <a>coe_neg</a>, <a>abs_def</a>, <a>abs_neg</a>]", [{"full_name": "EReal.abs_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/EReal.lean", "def_pos": [1212, 9], "def_end_pos": [1212, 16]}, {"full_name": "EReal.coe_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/EReal.lean", "def_pos": [899, 28], "def_end_pos": [899, 35]}, {"full_name": "EReal.abs_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/EReal.lean", "def_pos": [1212, 9], "def_end_pos": [1212, 16]}, {"full_name": "abs_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [86, 3], "def_end_pos": [86, 14]}]], "state_before": "x : \u211d\n\u22a2 EReal.abs (-\u2191x) = EReal.abs \u2191x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "PrincipalIdealRing.mem_submonoid_of_factors_subset_of_units_subset", "start": [351, 1], "end": [355, 53], "traced_tactics": [{"tactic": "rcases (factors_spec a ha).2 with \u27e8c, hc\u27e9", "annotated_tactic": ["rcases (<a>factors_spec</a> a ha).2 with \u27e8c, hc\u27e9", [{"full_name": "PrincipalIdealRing.factors_spec", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean", "def_pos": [340, 9], "def_end_pos": [340, 21]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsPrincipalIdealRing R\ns : Submonoid R\na : R\nha : a \u2260 0\nhfac : \u2200 b \u2208 factors a, b \u2208 s\nhunit : \u2200 (c : R\u02e3), \u2191c \u2208 s\n\u22a2 a \u2208 s", "state_after": "case intro\nR : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsPrincipalIdealRing R\ns : Submonoid R\na : R\nha : a \u2260 0\nhfac : \u2200 b \u2208 factors a, b \u2208 s\nhunit : \u2200 (c : R\u02e3), \u2191c \u2208 s\nc : R\u02e3\nhc : Multiset.prod (factors a) * \u2191c = a\n\u22a2 a \u2208 s"}, {"tactic": "rw [\u2190 hc]", "annotated_tactic": ["rw [\u2190 hc]", []], "state_before": "case intro\nR : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsPrincipalIdealRing R\ns : Submonoid R\na : R\nha : a \u2260 0\nhfac : \u2200 b \u2208 factors a, b \u2208 s\nhunit : \u2200 (c : R\u02e3), \u2191c \u2208 s\nc : R\u02e3\nhc : Multiset.prod (factors a) * \u2191c = a\n\u22a2 a \u2208 s", "state_after": "case intro\nR : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsPrincipalIdealRing R\ns : Submonoid R\na : R\nha : a \u2260 0\nhfac : \u2200 b \u2208 factors a, b \u2208 s\nhunit : \u2200 (c : R\u02e3), \u2191c \u2208 s\nc : R\u02e3\nhc : Multiset.prod (factors a) * \u2191c = a\n\u22a2 Multiset.prod (factors a) * \u2191c \u2208 s"}, {"tactic": "exact mul_mem (multiset_prod_mem _ hfac) (hunit _)", "annotated_tactic": ["exact <a>mul_mem</a> (<a>multiset_prod_mem</a> _ hfac) (hunit _)", [{"full_name": "MulMemClass.mul_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Basic.lean", "def_pos": [63, 3], "def_end_pos": [63, 10]}, {"full_name": "multiset_prod_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [85, 9], "def_end_pos": [85, 26]}]], "state_before": "case intro\nR : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsPrincipalIdealRing R\ns : Submonoid R\na : R\nha : a \u2260 0\nhfac : \u2200 b \u2208 factors a, b \u2208 s\nhunit : \u2200 (c : R\u02e3), \u2191c \u2208 s\nc : R\u02e3\nhc : Multiset.prod (factors a) * \u2191c = a\n\u22a2 Multiset.prod (factors a) * \u2191c \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Cauchy.lean", "full_name": "cauchySeq_shift", "start": [316, 1], "end": [324, 51], "traced_tactics": [{"tactic": "constructor <;> intro h", "annotated_tactic": ["constructor <;> intro h", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\n\u22a2 (CauchySeq fun n => u (n + k)) \u2194 CauchySeq u", "state_after": "case mp\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh : CauchySeq fun n => u (n + k)\n\u22a2 CauchySeq u\n\ncase mpr\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh : CauchySeq u\n\u22a2 CauchySeq fun n => u (n + k)"}, {"tactic": "rw [cauchySeq_iff] at h \u22a2", "annotated_tactic": ["rw [<a>cauchySeq_iff</a>] at h \u22a2", [{"full_name": "cauchySeq_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Cauchy.lean", "def_pos": [262, 9], "def_end_pos": [262, 22]}]], "state_before": "case mp\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh : CauchySeq fun n => u (n + k)\n\u22a2 CauchySeq u", "state_after": "case mp\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\n\u22a2 \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V"}, {"tactic": "intro V mV", "annotated_tactic": ["intro V mV", []], "state_before": "case mp\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\n\u22a2 \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V", "state_after": "case mp\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\nV : Set (\u03b1 \u00d7 \u03b1)\nmV : V \u2208 \ud835\udce4 \u03b1\n\u22a2 \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V"}, {"tactic": "obtain \u27e8N, h\u27e9 := h V mV", "annotated_tactic": ["obtain \u27e8N, h\u27e9 := h V mV", []], "state_before": "case mp\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\nV : Set (\u03b1 \u00d7 \u03b1)\nmV : V \u2208 \ud835\udce4 \u03b1\n\u22a2 \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V", "state_after": "case mp.intro\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh\u271d : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\nV : Set (\u03b1 \u00d7 \u03b1)\nmV : V \u2208 \ud835\udce4 \u03b1\nN : \u2115\nh : \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\n\u22a2 \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V"}, {"tactic": "use N + k", "annotated_tactic": ["use N + k", []], "state_before": "case mp.intro\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh\u271d : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\nV : Set (\u03b1 \u00d7 \u03b1)\nmV : V \u2208 \ud835\udce4 \u03b1\nN : \u2115\nh : \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\n\u22a2 \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh\u271d : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\nV : Set (\u03b1 \u00d7 \u03b1)\nmV : V \u2208 \ud835\udce4 \u03b1\nN : \u2115\nh : \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\n\u22a2 \u2200 k_1 \u2265 N + k, \u2200 l \u2265 N + k, (u k_1, u l) \u2208 V"}, {"tactic": "intro a ha b hb", "annotated_tactic": ["intro a ha b hb", []], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh\u271d : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\nV : Set (\u03b1 \u00d7 \u03b1)\nmV : V \u2208 \ud835\udce4 \u03b1\nN : \u2115\nh : \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\n\u22a2 \u2200 k_1 \u2265 N + k, \u2200 l \u2265 N + k, (u k_1, u l) \u2208 V", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh\u271d : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\nV : Set (\u03b1 \u00d7 \u03b1)\nmV : V \u2208 \ud835\udce4 \u03b1\nN : \u2115\nh : \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\na : \u2115\nha : a \u2265 N + k\nb : \u2115\nhb : b \u2265 N + k\n\u22a2 (u a, u b) \u2208 V"}, {"tactic": "convert h (a - k) (Nat.le_sub_of_add_le ha) (b - k) (Nat.le_sub_of_add_le hb) <;> omega", "annotated_tactic": ["convert h (a - k) (<a>Nat.le_sub_of_add_le</a> ha) (b - k) (<a>Nat.le_sub_of_add_le</a> hb) <;> omega", [{"full_name": "Nat.le_sub_of_add_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [701, 9], "def_end_pos": [701, 25]}, {"full_name": "Nat.le_sub_of_add_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [701, 9], "def_end_pos": [701, 25]}]], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh\u271d : \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\nV : Set (\u03b1 \u00d7 \u03b1)\nmV : V \u2208 \ud835\udce4 \u03b1\nN : \u2115\nh : \u2200 k_1 \u2265 N, \u2200 l \u2265 N, (u (k_1 + k), u (l + k)) \u2208 V\na : \u2115\nha : a \u2265 N + k\nb : \u2115\nhb : b \u2265 N + k\n\u22a2 (u a, u b) \u2208 V", "state_after": "no goals"}, {"tactic": "exact h.comp_tendsto (tendsto_add_atTop_nat k)", "annotated_tactic": ["exact h.comp_tendsto (<a>tendsto_add_atTop_nat</a> k)", [{"full_name": "Filter.tendsto_add_atTop_nat", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [1741, 9], "def_end_pos": [1741, 30]}]], "state_before": "case mpr\n\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nu : \u2115 \u2192 \u03b1\nk : \u2115\nh : CauchySeq u\n\u22a2 CauchySeq fun n => u (n + k)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Int/Basic.lean", "full_name": "Int.natAbs_lcm", "start": [166, 1], "end": [167, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dual.lean", "full_name": "Basis.toDualEquiv_apply", "start": [416, 1], "end": [417, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/DirectSum/Basic.lean", "full_name": "DirectSum.toAddMonoid_of", "start": [203, 1], "end": [204, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.replicate_succ", "start": [457, 1], "end": [457, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "disjoint_nhds_pure", "start": [549, 1], "end": [550, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Function.lean", "full_name": "ConcaveOn.left_le_of_le_right'", "start": [721, 1], "end": [724, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.cons_val_zero", "start": [132, 1], "end": [133, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/MvPowerSeries/Basic.lean", "full_name": "MvPolynomial.coe_bit0", "start": [835, 1], "end": [837, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.val_inj", "start": [161, 1], "end": [162, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Sort.lean", "full_name": "finSumEquivOfFinset_inl", "start": [47, 1], "end": [49, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Nodup.lean", "full_name": "Multiset.coe_nodup", "start": [33, 1], "end": [34, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean", "full_name": "MeasureTheory.Measure.restrict_iUnion_congr", "start": [396, 1], "end": [403, 97], "traced_tactics": [{"tactic": "refine' \u27e8fun h i => restrict_congr_mono (subset_iUnion _ _) h, fun h => _\u27e9", "annotated_tactic": ["refine' \u27e8fun h i => <a>restrict_congr_mono</a> (<a>subset_iUnion</a> _ _) h, fun h => _\u27e9", [{"full_name": "MeasureTheory.Measure.restrict_congr_mono", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [355, 9], "def_end_pos": [355, 28]}, {"full_name": "Set.subset_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [281, 9], "def_end_pos": [281, 22]}]], "state_before": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t : Set \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 restrict \u03bc (\u22c3 i, s i) = restrict \u03bd (\u22c3 i, s i) \u2194 \u2200 (i : \u03b9), restrict \u03bc (s i) = restrict \u03bd (s i)", "state_after": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t : Set \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\nh : \u2200 (i : \u03b9), restrict \u03bc (s i) = restrict \u03bd (s i)\n\u22a2 restrict \u03bc (\u22c3 i, s i) = restrict \u03bd (\u22c3 i, s i)"}, {"tactic": "ext1 t ht", "annotated_tactic": ["ext1 t ht", []], "state_before": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t : Set \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\nh : \u2200 (i : \u03b9), restrict \u03bc (s i) = restrict \u03bd (s i)\n\u22a2 restrict \u03bc (\u22c3 i, s i) = restrict \u03bd (\u22c3 i, s i)", "state_after": "case h\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t\u271d : Set \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\nh : \u2200 (i : \u03b9), restrict \u03bc (s i) = restrict \u03bd (s i)\nt : Set \u03b1\nht : MeasurableSet t\n\u22a2 \u2191\u2191(restrict \u03bc (\u22c3 i, s i)) t = \u2191\u2191(restrict \u03bd (\u22c3 i, s i)) t"}, {"tactic": "rw [iUnion_eq_iUnion_finset]", "annotated_tactic": ["rw [<a>iUnion_eq_iUnion_finset</a>]", [{"full_name": "Set.iUnion_eq_iUnion_finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [2042, 9], "def_end_pos": [2042, 32]}]], "state_before": "case h\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t\u271d : Set \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\nh : \u2200 (i : \u03b9), restrict \u03bc (s i) = restrict \u03bd (s i)\nt : Set \u03b1\nht : MeasurableSet t\nD : Directed (fun x x_1 => x \u2286 x_1) fun t => \u22c3 i \u2208 t, s i\n\u22a2 \u2191\u2191(restrict \u03bc (\u22c3 i, s i)) t = \u2191\u2191(restrict \u03bd (\u22c3 i, s i)) t", "state_after": "case h\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t\u271d : Set \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\nh : \u2200 (i : \u03b9), restrict \u03bc (s i) = restrict \u03bd (s i)\nt : Set \u03b1\nht : MeasurableSet t\nD : Directed (fun x x_1 => x \u2286 x_1) fun t => \u22c3 i \u2208 t, s i\n\u22a2 \u2191\u2191(restrict \u03bc (\u22c3 t, \u22c3 i \u2208 t, s i)) t = \u2191\u2191(restrict \u03bd (\u22c3 t, \u22c3 i \u2208 t, s i)) t"}, {"tactic": "simp only [restrict_iUnion_apply_eq_iSup D ht, restrict_finset_biUnion_congr.2 fun i _ => h i]", "annotated_tactic": ["simp only [<a>restrict_iUnion_apply_eq_iSup</a> D ht, <a>restrict_finset_biUnion_congr</a>.2 fun i _ => h i]", [{"full_name": "MeasureTheory.Measure.restrict_iUnion_apply_eq_iSup", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [320, 9], "def_end_pos": [320, 38]}, {"full_name": "MeasureTheory.Measure.restrict_finset_biUnion_congr", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [387, 9], "def_end_pos": [387, 38]}]], "state_before": "case h\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t\u271d : Set \u03b1\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set \u03b1\nh : \u2200 (i : \u03b9), restrict \u03bc (s i) = restrict \u03bd (s i)\nt : Set \u03b1\nht : MeasurableSet t\nD : Directed (fun x x_1 => x \u2286 x_1) fun t => \u22c3 i \u2208 t, s i\n\u22a2 \u2191\u2191(restrict \u03bc (\u22c3 t, \u22c3 i \u2208 t, s i)) t = \u2191\u2191(restrict \u03bd (\u22c3 t, \u22c3 i \u2208 t, s i)) t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_atBot_of_add_bdd_below_left'", "start": [783, 1], "end": [786, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/MonotoneConvergence.lean", "full_name": "tendsto_atBot_iInf", "start": [171, 1], "end": [172, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Hom.lean", "full_name": "MonoidWithZeroHom.toZeroHom_coe", "start": [137, 1], "end": [137, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.sum_nil", "start": [253, 9], "end": [253, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean", "full_name": "AddChar.to_mulShift_inj_of_isPrimitive", "start": [57, 1], "end": [64, 37], "traced_tactics": [{"tactic": "intro a b h", "annotated_tactic": ["intro a b h", []], "state_before": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\n\u22a2 Function.Injective (mulShift \u03c8)", "state_after": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 a = mulShift \u03c8 b\n\u22a2 a = b"}, {"tactic": "apply_fun fun x => x * mulShift \u03c8 (-b) at h", "annotated_tactic": ["apply_fun fun x => x * <a>mulShift</a> \u03c8 (-b) at h", [{"full_name": "AddChar.mulShift", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/AddChar.lean", "def_pos": [274, 5], "def_end_pos": [274, 13]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 a = mulShift \u03c8 b\n\u22a2 a = b", "state_after": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 a * mulShift \u03c8 (-b) = mulShift \u03c8 b * mulShift \u03c8 (-b)\n\u22a2 a = b"}, {"tactic": "simp only [mulShift_mul, mulShift_zero, add_right_neg] at h", "annotated_tactic": ["simp only [<a>mulShift_mul</a>, <a>mulShift_zero</a>, <a>add_right_neg</a>] at h", [{"full_name": "AddChar.mulShift_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/AddChar.lean", "def_pos": [300, 9], "def_end_pos": [300, 21]}, {"full_name": "AddChar.mulShift_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/AddChar.lean", "def_pos": [308, 9], "def_end_pos": [308, 22]}, {"full_name": "add_right_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1154, 3], "def_end_pos": [1154, 14]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 a * mulShift \u03c8 (-b) = mulShift \u03c8 b * mulShift \u03c8 (-b)\n\u22a2 a = b", "state_after": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 (a + -b) = 1\n\u22a2 a = b"}, {"tactic": "have h\u2082 := h\u03c8 (a + -b)", "annotated_tactic": ["have h\u2082 := h\u03c8 (a + -b)", []], "state_before": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 (a + -b) = 1\n\u22a2 a = b", "state_after": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 (a + -b) = 1\nh\u2082 : a + -b \u2260 0 \u2192 IsNontrivial (mulShift \u03c8 (a + -b))\n\u22a2 a = b"}, {"tactic": "rw [h, isNontrivial_iff_ne_trivial, \u2190 sub_eq_add_neg, sub_ne_zero] at h\u2082", "annotated_tactic": ["rw [h, <a>isNontrivial_iff_ne_trivial</a>, \u2190 <a>sub_eq_add_neg</a>, <a>sub_ne_zero</a>] at h\u2082", [{"full_name": "AddChar.isNontrivial_iff_ne_trivial", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/AddChar.lean", "def_pos": [185, 7], "def_end_pos": [185, 34]}, {"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}, {"full_name": "sub_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [892, 3], "def_end_pos": [892, 14]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 (a + -b) = 1\nh\u2082 : a + -b \u2260 0 \u2192 IsNontrivial (mulShift \u03c8 (a + -b))\n\u22a2 a = b", "state_after": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 (a + -b) = 1\nh\u2082 : a \u2260 b \u2192 1 \u2260 1\n\u22a2 a = b"}, {"tactic": "exact not_not.mp fun h => h\u2082 h rfl", "annotated_tactic": ["exact not_not.mp fun h => h\u2082 h <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : CommRing R\nR' : Type v\ninst\u271d : CommMonoid R'\n\u03c8 : AddChar R R'\nh\u03c8 : IsPrimitive \u03c8\na b : R\nh : mulShift \u03c8 (a + -b) = 1\nh\u2082 : a \u2260 b \u2192 1 \u2260 1\n\u22a2 a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Degrees.lean", "full_name": "MvPolynomial.degreeOf_mul_X_ne", "start": [305, 1], "end": [314, 87], "traced_tactics": [{"tactic": "classical\nrepeat' rw [degreeOf_eq_sup (R := R) i]\nrw [support_mul_X]\nsimp only [Finset.sup_map]\ncongr\next\nsimp only [Finsupp.single, Nat.one_ne_zero, add_right_eq_self, addRightEmbedding_apply, coe_mk,\n  Pi.add_apply, comp_apply, ite_eq_right_iff, Finsupp.coe_add, Pi.single_eq_of_ne h]", "annotated_tactic": ["classical\n  repeat' rw [<a>degreeOf_eq_sup</a> (R := R) i]\n  rw [<a>support_mul_X</a>]\n  simp only [<a>Finset.sup_map</a>]\n  congr\n  ext\n  simp only [<a>Finsupp.single</a>, <a>Nat.one_ne_zero</a>, <a>add_right_eq_self</a>, <a>addRightEmbedding_apply</a>, <a>coe_mk</a>,\n    <a>Pi.add_apply</a>, <a>comp_apply</a>, <a>ite_eq_right_iff</a>, <a>Finsupp.coe_add</a>, <a>Pi.single_eq_of_ne</a> h]", [{"full_name": "MvPolynomial.degreeOf_eq_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [247, 9], "def_end_pos": [247, 24]}, {"full_name": "MvPolynomial.support_mul_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [744, 9], "def_end_pos": [744, 22]}, {"full_name": "Finset.sup_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [67, 9], "def_end_pos": [67, 16]}, {"full_name": "Finsupp.single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [286, 5], "def_end_pos": [286, 11]}, {"full_name": "Nat.one_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [459, 19], "def_end_pos": [459, 30]}, {"full_name": "add_right_eq_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [240, 3], "def_end_pos": [240, 14]}, {"full_name": "addRightEmbedding_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Embedding.lean", "def_pos": [35, 24], "def_end_pos": [35, 29]}, {"full_name": "Finsupp.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [160, 9], "def_end_pos": [160, 15]}, {"full_name": "Pi.add_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [89, 3], "def_end_pos": [89, 14]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "ite_eq_right_iff", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [60, 17], "def_end_pos": [60, 33]}, {"full_name": "Finsupp.coe_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [1021, 26], "def_end_pos": [1021, 33]}, {"full_name": "Pi.single_eq_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [369, 3], "def_end_pos": [369, 14]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 degreeOf i (f * X j) = degreeOf i f", "state_after": "no goals"}, {"tactic": "repeat' rw [degreeOf_eq_sup (R := R) i]", "annotated_tactic": ["repeat' rw [<a>degreeOf_eq_sup</a> (R := R) i]", [{"full_name": "MvPolynomial.degreeOf_eq_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [247, 9], "def_end_pos": [247, 24]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 degreeOf i (f * X j) = degreeOf i f", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 (Finset.sup (support (f * X j)) fun m => m i) = Finset.sup (support f) fun m => m i"}, {"tactic": "rw [support_mul_X]", "annotated_tactic": ["rw [<a>support_mul_X</a>]", [{"full_name": "MvPolynomial.support_mul_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [744, 9], "def_end_pos": [744, 22]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 (Finset.sup (support (f * X j)) fun m => m i) = Finset.sup (support f) fun m => m i", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 (Finset.sup (Finset.map (addRightEmbedding (Finsupp.single j 1)) (support f)) fun m => m i) =\n    Finset.sup (support f) fun m => m i"}, {"tactic": "simp only [Finset.sup_map]", "annotated_tactic": ["simp only [<a>Finset.sup_map</a>]", [{"full_name": "Finset.sup_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [67, 9], "def_end_pos": [67, 16]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 (Finset.sup (Finset.map (addRightEmbedding (Finsupp.single j 1)) (support f)) fun m => m i) =\n    Finset.sup (support f) fun m => m i", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 Finset.sup (support f) ((fun m => m i) \u2218 \u21d1(addRightEmbedding (Finsupp.single j 1))) =\n    Finset.sup (support f) fun m => m i"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 Finset.sup (support f) ((fun m => m i) \u2218 \u21d1(addRightEmbedding (Finsupp.single j 1))) =\n    Finset.sup (support f) fun m => m i", "state_after": "case e_f\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 (fun m => m i) \u2218 \u21d1(addRightEmbedding (Finsupp.single j 1)) = fun m => m i"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "case e_f\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 (fun m => m i) \u2218 \u21d1(addRightEmbedding (Finsupp.single j 1)) = fun m => m i", "state_after": "case e_f.h\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\nx\u271d : \u03c3 \u2192\u2080 \u2115\n\u22a2 ((fun m => m i) \u2218 \u21d1(addRightEmbedding (Finsupp.single j 1))) x\u271d = x\u271d i"}, {"tactic": "simp only [Finsupp.single, Nat.one_ne_zero, add_right_eq_self, addRightEmbedding_apply, coe_mk,\n  Pi.add_apply, comp_apply, ite_eq_right_iff, Finsupp.coe_add, Pi.single_eq_of_ne h]", "annotated_tactic": ["simp only [<a>Finsupp.single</a>, <a>Nat.one_ne_zero</a>, <a>add_right_eq_self</a>, <a>addRightEmbedding_apply</a>, <a>coe_mk</a>,\n    <a>Pi.add_apply</a>, <a>comp_apply</a>, <a>ite_eq_right_iff</a>, <a>Finsupp.coe_add</a>, <a>Pi.single_eq_of_ne</a> h]", [{"full_name": "Finsupp.single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [286, 5], "def_end_pos": [286, 11]}, {"full_name": "Nat.one_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [459, 19], "def_end_pos": [459, 30]}, {"full_name": "add_right_eq_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [240, 3], "def_end_pos": [240, 14]}, {"full_name": "addRightEmbedding_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Embedding.lean", "def_pos": [35, 24], "def_end_pos": [35, 29]}, {"full_name": "Finsupp.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [160, 9], "def_end_pos": [160, 15]}, {"full_name": "Pi.add_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [89, 3], "def_end_pos": [89, 14]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "ite_eq_right_iff", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [60, 17], "def_end_pos": [60, 33]}, {"full_name": "Finsupp.coe_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [1021, 26], "def_end_pos": [1021, 33]}, {"full_name": "Pi.single_eq_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [369, 3], "def_end_pos": [369, 14]}]], "state_before": "case e_f.h\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\nx\u271d : \u03c3 \u2192\u2080 \u2115\n\u22a2 ((fun m => m i) \u2218 \u21d1(addRightEmbedding (Finsupp.single j 1))) x\u271d = x\u271d i", "state_after": "no goals"}, {"tactic": "rw [degreeOf_eq_sup (R := R) i]", "annotated_tactic": ["rw [<a>degreeOf_eq_sup</a> (R := R) i]", [{"full_name": "MvPolynomial.degreeOf_eq_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [247, 9], "def_end_pos": [247, 24]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 (Finset.sup (support (f * X j)) fun m => m i) = degreeOf i f", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ni j : \u03c3\nf : MvPolynomial \u03c3 R\nh : i \u2260 j\n\u22a2 (Finset.sup (support (f * X j)) fun m => m i) = Finset.sup (support f) fun m => m i"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.toLin_eq_toLin'", "start": [575, 1], "end": [576, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Subfield.lean", "full_name": "Subfield.one_mem", "start": [251, 11], "end": [252, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Block.lean", "full_name": "Matrix.BlockTriangular.submatrix", "start": [59, 11], "end": [60, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "full_name": "Real.logb_neg_iff", "start": [230, 1], "end": [232, 42], "traced_tactics": [{"tactic": "rw [\u2190 logb_one]", "annotated_tactic": ["rw [\u2190 <a>logb_one</a>]", [{"full_name": "Real.logb_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "def_pos": [53, 9], "def_end_pos": [53, 17]}]], "state_before": "b x y : \u211d\nhb : 1 < b\nh : 0 < x\n\u22a2 logb b x < 0 \u2194 x < 1", "state_after": "b x y : \u211d\nhb : 1 < b\nh : 0 < x\n\u22a2 logb b x < logb ?m.19064 1 \u2194 x < 1\n\nb x y : \u211d\nhb : 1 < b\nh : 0 < x\n\u22a2 \u211d"}, {"tactic": "exact logb_lt_logb_iff hb h zero_lt_one", "annotated_tactic": ["exact <a>logb_lt_logb_iff</a> hb h <a>zero_lt_one</a>", [{"full_name": "Real.logb_lt_logb_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "def_pos": [199, 9], "def_end_pos": [199, 25]}, {"full_name": "zero_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}]], "state_before": "b x y : \u211d\nhb : 1 < b\nh : 0 < x\n\u22a2 logb b x < logb ?m.19064 1 \u2194 x < 1\n\nb x y : \u211d\nhb : 1 < b\nh : 0 < x\n\u22a2 \u211d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/TFAE.lean", "full_name": "List.exists_tfae", "start": [109, 1], "end": [114, 46], "traced_tactics": [{"tactic": "simp only [TFAE, List.forall_mem_map_iff]", "annotated_tactic": ["simp only [<a>TFAE</a>, <a>List.forall_mem_map_iff</a>]", [{"full_name": "List.TFAE", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/TFAE.lean", "def_pos": [27, 5], "def_end_pos": [27, 9]}, {"full_name": "List.forall_mem_map_iff", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [213, 9], "def_end_pos": [213, 27]}]], "state_before": "\u03b1 : Type u_1\nl : List (\u03b1 \u2192 Prop)\nH : \u2200 (a : \u03b1), TFAE (map (fun p => p a) l)\n\u22a2 TFAE (map (fun p => \u2203 a, p a) l)", "state_after": "\u03b1 : Type u_1\nl : List (\u03b1 \u2192 Prop)\nH : \u2200 (a : \u03b1), TFAE (map (fun p => p a) l)\n\u22a2 \u2200 (j : \u03b1 \u2192 Prop), j \u2208 l \u2192 \u2200 (j_1 : \u03b1 \u2192 Prop), j_1 \u2208 l \u2192 ((\u2203 a, j a) \u2194 \u2203 a, j_1 a)"}, {"tactic": "intros p\u2081 hp\u2081 p\u2082 hp\u2082", "annotated_tactic": ["intros p\u2081 hp\u2081 p\u2082 hp\u2082", []], "state_before": "\u03b1 : Type u_1\nl : List (\u03b1 \u2192 Prop)\nH : \u2200 (a : \u03b1), TFAE (map (fun p => p a) l)\n\u22a2 \u2200 (j : \u03b1 \u2192 Prop), j \u2208 l \u2192 \u2200 (j_1 : \u03b1 \u2192 Prop), j_1 \u2208 l \u2192 ((\u2203 a, j a) \u2194 \u2203 a, j_1 a)", "state_after": "\u03b1 : Type u_1\nl : List (\u03b1 \u2192 Prop)\nH : \u2200 (a : \u03b1), TFAE (map (fun p => p a) l)\np\u2081 : \u03b1 \u2192 Prop\nhp\u2081 : p\u2081 \u2208 l\np\u2082 : \u03b1 \u2192 Prop\nhp\u2082 : p\u2082 \u2208 l\n\u22a2 (\u2203 a, p\u2081 a) \u2194 \u2203 a, p\u2082 a"}, {"tactic": "exact exists_congr fun a \u21a6 H a (p\u2081 a) (mem_map_of_mem (fun p \u21a6 p a) hp\u2081)\n  (p\u2082 a) (mem_map_of_mem (fun p \u21a6 p a) hp\u2082)", "annotated_tactic": ["exact <a>exists_congr</a> fun a \u21a6 H a (p\u2081 a) (<a>mem_map_of_mem</a> (fun p \u21a6 p a) hp\u2081)\n    (p\u2082 a) (<a>mem_map_of_mem</a> (fun p \u21a6 p a) hp\u2082)", [{"full_name": "exists_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [143, 9], "def_end_pos": [143, 21]}, {"full_name": "List.mem_map_of_mem", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [131, 9], "def_end_pos": [131, 23]}, {"full_name": "List.mem_map_of_mem", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [131, 9], "def_end_pos": [131, 23]}]], "state_before": "\u03b1 : Type u_1\nl : List (\u03b1 \u2192 Prop)\nH : \u2200 (a : \u03b1), TFAE (map (fun p => p a) l)\np\u2081 : \u03b1 \u2192 Prop\nhp\u2081 : p\u2081 \u2208 l\np\u2082 : \u03b1 \u2192 Prop\nhp\u2082 : p\u2082 \u2208 l\n\u22a2 (\u2203 a, p\u2081 a) \u2194 \u2203 a, p\u2082 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "norm_mul\u2083_le", "start": [542, 1], "end": [543, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Directed.lean", "full_name": "directed_of_isDirected_le", "start": [201, 1], "end": [203, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "full_name": "UniformEmbedding.denseEmbedding", "start": [241, 1], "end": [243, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Cauchy.lean", "full_name": "isComplete_iff_ultrafilter'", "start": [374, 1], "end": [376, 91], "traced_tactics": [{"tactic": "simp only [le_principal_iff, Ultrafilter.mem_coe]", "annotated_tactic": ["simp only [<a>le_principal_iff</a>, <a>Ultrafilter.mem_coe</a>]", [{"full_name": "Filter.le_principal_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [669, 9], "def_end_pos": [669, 25]}, {"full_name": "Ultrafilter.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Ultrafilter.lean", "def_pos": [76, 9], "def_end_pos": [76, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 \u2191l \u2264 \ud835\udcdf s \u2192 \u2203 x \u2208 s, \u2191l \u2264 \ud835\udcdd x) \u2194\n    \u2200 (l : Ultrafilter \u03b1), Cauchy \u2191l \u2192 s \u2208 l \u2192 \u2203 x \u2208 s, \u2191l \u2264 \ud835\udcdd x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Real.sin_pi_div_thirty_two", "start": [834, 1], "end": [838, 9], "traced_tactics": [{"tactic": "trans sin (\u03c0 / 2 ^ 5)", "annotated_tactic": ["trans <a>sin</a> (\u03c0 / 2 ^ 5)", [{"full_name": "Real.sin", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [115, 12], "def_end_pos": [115, 15]}]], "state_before": "x : \u211d\n\u22a2 sin (\u03c0 / 32) = sqrt (2 - sqrt (2 + sqrt (2 + sqrt 2))) / 2", "state_after": "x : \u211d\n\u22a2 sin (\u03c0 / 32) = sin (\u03c0 / 2 ^ 5)\n\nx : \u211d\n\u22a2 sin (\u03c0 / 2 ^ 5) = sqrt (2 - sqrt (2 + sqrt (2 + sqrt 2))) / 2"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "x : \u211d\n\u22a2 sin (\u03c0 / 32) = sin (\u03c0 / 2 ^ 5)", "state_after": "case e_x.e_a\nx : \u211d\n\u22a2 32 = 2 ^ 5"}, {"tactic": "norm_num", "annotated_tactic": ["norm_num", []], "state_before": "case e_x.e_a\nx : \u211d\n\u22a2 32 = 2 ^ 5", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "x : \u211d\n\u22a2 sin (\u03c0 / 2 ^ 5) = sqrt (2 - sqrt (2 + sqrt (2 + sqrt 2))) / 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.strictMono_iff", "start": [1217, 1], "end": [1222, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Pairwise.lean", "full_name": "List.pairwise_pair", "start": [106, 1], "end": [106, 71], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\n\u22a2 Pairwise R [a, b] \u2194 R a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "full_name": "Summable.op", "start": [220, 1], "end": [221, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Sort.lean", "full_name": "List.mergeSort_nil", "start": [520, 1], "end": [520, 70], "traced_tactics": [{"tactic": "rw [List.mergeSort]", "annotated_tactic": ["rw [<a>List.mergeSort</a>]", [{"full_name": "List.mergeSort", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sort.lean", "def_pos": [418, 5], "def_end_pos": [418, 14]}]], "state_before": "\u03b1 : Type uu\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel r\n\u22a2 mergeSort r [] = []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.div_empty", "start": [631, 1], "end": [632, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/Finite.lean", "full_name": "FiniteDimensional.finrank_zero_of_subsingleton", "start": [343, 1], "end": [344, 52], "traced_tactics": [{"tactic": "rw [finrank, rank_subsingleton', _root_.map_zero]", "annotated_tactic": ["rw [<a>finrank</a>, <a>rank_subsingleton'</a>, <a>_root_.map_zero</a>]", [{"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}, {"full_name": "rank_subsingleton'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finite.lean", "def_pos": [103, 9], "def_end_pos": [103, 27]}, {"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}]], "state_before": "R : Type u\nM M\u2081 : Type v\nM' : Type v'\n\u03b9 : Type w\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup M'\ninst\u271d\u2076 : AddCommGroup M\u2081\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M'\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\ninst\u271d : Subsingleton M\n\u22a2 finrank R M = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean", "full_name": "EuclideanDomain.gcdB_zero_left", "start": [269, 1], "end": [271, 28], "traced_tactics": [{"tactic": "unfold gcdB", "annotated_tactic": ["unfold <a>gcdB</a>", [{"full_name": "EuclideanDomain.gcdB", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/EuclideanDomain/Defs.lean", "def_pos": [258, 5], "def_end_pos": [258, 9]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\ns : R\n\u22a2 gcdB 0 s = 1", "state_after": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\ns : R\n\u22a2 (xgcd 0 s).2 = 1"}, {"tactic": "rw [xgcd, xgcd_zero_left]", "annotated_tactic": ["rw [<a>xgcd</a>, <a>xgcd_zero_left</a>]", [{"full_name": "EuclideanDomain.xgcd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/EuclideanDomain/Defs.lean", "def_pos": [248, 5], "def_end_pos": [248, 9]}, {"full_name": "EuclideanDomain.xgcd_zero_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/EuclideanDomain/Defs.lean", "def_pos": [233, 9], "def_end_pos": [233, 23]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\ns : R\n\u22a2 (xgcd 0 s).2 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Basic.lean", "full_name": "Equiv.pow_addRight", "start": [623, 1], "end": [624, 27], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : AddGroup \u03b1\na b : \u03b1\nn : \u2115\n\u22a2 Equiv.addRight a ^ n = Equiv.addRight (n \u2022 a)", "state_after": "case H\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : AddGroup \u03b1\na b : \u03b1\nn : \u2115\nx\u271d : \u03b1\n\u22a2 (Equiv.addRight a ^ n) x\u271d = (Equiv.addRight (n \u2022 a)) x\u271d"}, {"tactic": "simp [Perm.coe_pow]", "annotated_tactic": ["simp [<a>Perm.coe_pow</a>]", [{"full_name": "Equiv.Perm.coe_pow", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [103, 20], "def_end_pos": [103, 27]}]], "state_before": "case H\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : AddGroup \u03b1\na b : \u03b1\nn : \u2115\nx\u271d : \u03b1\n\u22a2 (Equiv.addRight a ^ n) x\u271d = (Equiv.addRight (n \u2022 a)) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "LowerSet.coe_inf", "start": [760, 1], "end": [761, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/LocalExtr.lean", "full_name": "IsLocalMinOn.congr", "start": [571, 8], "end": [573, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Interval.lean", "full_name": "Int.Ioc_eq_finset_map", "start": [90, 1], "end": [93, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "contDiff_single", "start": [1243, 1], "end": [1245, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Splits.lean", "full_name": "Polynomial.splits_pow", "start": [154, 1], "end": [156, 36], "traced_tactics": [{"tactic": "rw [\u2190 Finset.card_range n, \u2190 Finset.prod_const]", "annotated_tactic": ["rw [\u2190 <a>Finset.card_range</a> n, \u2190 <a>Finset.prod_const</a>]", [{"full_name": "Finset.card_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [199, 9], "def_end_pos": [199, 19]}, {"full_name": "Finset.prod_const", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1665, 9], "def_end_pos": [1665, 19]}]], "state_before": "R : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni : K \u2192+* L\nf : K[X]\nhf : Splits i f\nn : \u2115\n\u22a2 Splits i (f ^ n)", "state_after": "R : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni : K \u2192+* L\nf : K[X]\nhf : Splits i f\nn : \u2115\n\u22a2 Splits i (\u220f _x in Finset.range n, f)"}, {"tactic": "exact splits_prod i fun j _ => hf", "annotated_tactic": ["exact <a>splits_prod</a> i fun j _ => hf", [{"full_name": "Polynomial.splits_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Splits.lean", "def_pos": [146, 9], "def_end_pos": [146, 20]}]], "state_before": "R : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b2 : CommRing K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni : K \u2192+* L\nf : K[X]\nhf : Splits i f\nn : \u2115\n\u22a2 Splits i (\u220f _x in Finset.range n, f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/FractionRing.lean", "full_name": "IsFractionRing.mk'_mk_eq_div", "start": [158, 1], "end": [162, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.bind_some_right", "start": [592, 1], "end": [593, 41], "traced_tactics": [{"tactic": "erw [bind_some_eq_map]", "annotated_tactic": ["erw [<a>bind_some_eq_map</a>]", [{"full_name": "Part.bind_some_eq_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [524, 9], "def_end_pos": [524, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx : Part \u03b1\n\u22a2 Part.bind x some = x", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx : Part \u03b1\n\u22a2 map (fun a => a) x = x"}, {"tactic": "simp [map_id']", "annotated_tactic": ["simp [<a>map_id'</a>]", [{"full_name": "Part.map_id'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [587, 9], "def_end_pos": [587, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx : Part \u03b1\n\u22a2 map (fun a => a) x = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Units.lean", "full_name": "NormedRing.inverse_add_norm_diff_second_order", "start": [207, 1], "end": [211, 40], "traced_tactics": [{"tactic": "convert inverse_add_norm_diff_nth_order x 2 using 2", "annotated_tactic": ["convert <a>inverse_add_norm_diff_nth_order</a> x 2 using 2", [{"full_name": "NormedRing.inverse_add_norm_diff_nth_order", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Units.lean", "def_pos": [190, 9], "def_end_pos": [190, 40]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : CompleteSpace R\nx : R\u02e3\n\u22a2 (fun t => inverse (\u2191x + t) - \u2191x\u207b\u00b9 + \u2191x\u207b\u00b9 * t * \u2191x\u207b\u00b9) =O[\ud835\udcdd 0] fun t => \u2016t\u2016 ^ 2", "state_after": "case h.e'_7.h\nR : Type u_1\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : CompleteSpace R\nx : R\u02e3\nx\u271d : R\n\u22a2 inverse (\u2191x + x\u271d) - \u2191x\u207b\u00b9 + \u2191x\u207b\u00b9 * x\u271d * \u2191x\u207b\u00b9 = inverse (\u2191x + x\u271d) - (\u2211 i in range 2, (-\u2191x\u207b\u00b9 * x\u271d) ^ i) * \u2191x\u207b\u00b9"}, {"tactic": "simp only [sum_range_succ, sum_range_zero, zero_add, pow_zero, pow_one, add_mul, one_mul,\n  \u2190 sub_sub, neg_mul, sub_neg_eq_add]", "annotated_tactic": ["simp only [<a>sum_range_succ</a>, <a>sum_range_zero</a>, <a>zero_add</a>, <a>pow_zero</a>, <a>pow_one</a>, <a>add_mul</a>, <a>one_mul</a>,\n    \u2190 <a>sub_sub</a>, <a>neg_mul</a>, <a>sub_neg_eq_add</a>]", [{"full_name": "Finset.sum_range_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1446, 3], "def_end_pos": [1446, 14]}, {"full_name": "Finset.sum_range_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1489, 3], "def_end_pos": [1489, 14]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}, {"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}, {"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}, {"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "sub_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [601, 3], "def_end_pos": [601, 14]}, {"full_name": "neg_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [306, 9], "def_end_pos": [306, 16]}, {"full_name": "sub_neg_eq_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [528, 3], "def_end_pos": [528, 14]}]], "state_before": "case h.e'_7.h\nR : Type u_1\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : CompleteSpace R\nx : R\u02e3\nx\u271d : R\n\u22a2 inverse (\u2191x + x\u271d) - \u2191x\u207b\u00b9 + \u2191x\u207b\u00b9 * x\u271d * \u2191x\u207b\u00b9 = inverse (\u2191x + x\u271d) - (\u2211 i in range 2, (-\u2191x\u207b\u00b9 * x\u271d) ^ i) * \u2191x\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean", "full_name": "MeasureTheory.ite_ae_eq_of_measure_zero", "start": [463, 1], "end": [470, 31], "traced_tactics": [{"tactic": "have h_ss : s\u1d9c \u2286 { a : \u03b1 | ite (a \u2208 s) (f a) (g a) = g a } := fun x hx => by\n  simp [(Set.mem_compl_iff _ _).mp hx]", "annotated_tactic": ["have h_ss : s\u1d9c \u2286 { a : \u03b1 | <a>ite</a> (a \u2208 s) (f a) (g a) = g a } := fun x hx => by\n    simp [(<a>Set.mem_compl_iff</a> _ _).<a>mp</a> hx]", [{"full_name": "ite", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [962, 21], "def_end_pos": [962, 24]}, {"full_name": "Set.mem_compl_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [87, 17], "def_end_pos": [87, 30]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d t : Set \u03b1\n\u03b3 : Type u_5\nf g : \u03b1 \u2192 \u03b3\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs_zero : \u2191\u2191\u03bc s = 0\n\u22a2 (fun x => if x \u2208 s then f x else g x) =\u1da0[ae \u03bc] g", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d t : Set \u03b1\n\u03b3 : Type u_5\nf g : \u03b1 \u2192 \u03b3\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs_zero : \u2191\u2191\u03bc s = 0\nh_ss : s\u1d9c \u2286 {a | (if a \u2208 s then f a else g a) = g a}\n\u22a2 (fun x => if x \u2208 s then f x else g x) =\u1da0[ae \u03bc] g"}, {"tactic": "refine' measure_mono_null _ hs_zero", "annotated_tactic": ["refine' <a>measure_mono_null</a> _ hs_zero", [{"full_name": "MeasureTheory.measure_mono_null", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [199, 9], "def_end_pos": [199, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d t : Set \u03b1\n\u03b3 : Type u_5\nf g : \u03b1 \u2192 \u03b3\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs_zero : \u2191\u2191\u03bc s = 0\nh_ss : s\u1d9c \u2286 {a | (if a \u2208 s then f a else g a) = g a}\n\u22a2 (fun x => if x \u2208 s then f x else g x) =\u1da0[ae \u03bc] g", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d t : Set \u03b1\n\u03b3 : Type u_5\nf g : \u03b1 \u2192 \u03b3\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs_zero : \u2191\u2191\u03bc s = 0\nh_ss : s\u1d9c \u2286 {a | (if a \u2208 s then f a else g a) = g a}\n\u22a2 {x | (fun x => (fun x => if x \u2208 s then f x else g x) x = g x) x}\u1d9c \u2286 s"}, {"tactic": "conv_rhs => rw [\u2190 compl_compl s]", "annotated_tactic": ["conv_rhs => rw [\u2190 <a>compl_compl</a> s]", [{"full_name": "compl_compl", "def_path": ".lake/packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [656, 9], "def_end_pos": [656, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d t : Set \u03b1\n\u03b3 : Type u_5\nf g : \u03b1 \u2192 \u03b3\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs_zero : \u2191\u2191\u03bc s = 0\nh_ss : s\u1d9c \u2286 {a | (if a \u2208 s then f a else g a) = g a}\n\u22a2 {x | (fun x => (fun x => if x \u2208 s then f x else g x) x = g x) x}\u1d9c \u2286 s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d t : Set \u03b1\n\u03b3 : Type u_5\nf g : \u03b1 \u2192 \u03b3\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs_zero : \u2191\u2191\u03bc s = 0\nh_ss : s\u1d9c \u2286 {a | (if a \u2208 s then f a else g a) = g a}\n\u22a2 {x | (fun x => (fun x => if x \u2208 s then f x else g x) x = g x) x}\u1d9c \u2286 s\u1d9c\u1d9c"}, {"tactic": "rwa [Set.compl_subset_compl]", "annotated_tactic": ["rwa [<a>Set.compl_subset_compl</a>]", [{"full_name": "Set.compl_subset_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1737, 9], "def_end_pos": [1737, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d t : Set \u03b1\n\u03b3 : Type u_5\nf g : \u03b1 \u2192 \u03b3\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs_zero : \u2191\u2191\u03bc s = 0\nh_ss : s\u1d9c \u2286 {a | (if a \u2208 s then f a else g a) = g a}\n\u22a2 {x | (fun x => (fun x => if x \u2208 s then f x else g x) x = g x) x}\u1d9c \u2286 s\u1d9c\u1d9c", "state_after": "no goals"}, {"tactic": "simp [(Set.mem_compl_iff _ _).mp hx]", "annotated_tactic": ["simp [(<a>Set.mem_compl_iff</a> _ _).<a>mp</a> hx]", [{"full_name": "Set.mem_compl_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [87, 17], "def_end_pos": [87, 30]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d t : Set \u03b1\n\u03b3 : Type u_5\nf g : \u03b1 \u2192 \u03b3\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs_zero : \u2191\u2191\u03bc s = 0\nx : \u03b1\nhx : x \u2208 s\u1d9c\n\u22a2 x \u2208 {a | (if a \u2208 s then f a else g a) = g a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iUnion_iInter_ge_nat_add", "start": [2222, 1], "end": [2224, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/OrdConnected.lean", "full_name": "Set.image_subtype_val_Ioo", "start": [131, 1], "end": [134, 60], "traced_tactics": [{"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ns\u271d t s : Set \u03b1\ninst\u271d : OrdConnected s\nx y : \u2191s\n\u22a2 OrdConnected (range \u21d1(OrderEmbedding.subtype fun x => x \u2208 s))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Iio_ssubset_Iic_self", "start": [545, 1], "end": [546, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "IsCompact.preimage_continuous", "start": [1690, 1], "end": [1692, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean", "full_name": "LinearMap.mkContinuous_norm_le", "start": [552, 1], "end": [554, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.map_mk_eq_map_mk_of_rel", "start": [2967, 1], "end": [2969, 68], "traced_tactics": [{"tactic": "simp [ih, Quot.sound hab]", "annotated_tactic": ["simp [ih, <a>Quot.sound</a> hab]", [{"full_name": "Quot.sound", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1459, 7], "def_end_pos": [1459, 12]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Multiset \u03b1\nhst : Rel r s t\na\u271d b\u271d : \u03b1\nas\u271d bs\u271d : Multiset \u03b1\nhab : r a\u271d b\u271d\n_hst : Rel r as\u271d bs\u271d\nih : map (Quot.mk r) as\u271d = map (Quot.mk r) bs\u271d\n\u22a2 map (Quot.mk r) (a\u271d ::\u2098 as\u271d) = map (Quot.mk r) (b\u271d ::\u2098 bs\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.pairwise_append", "start": [1571, 1], "end": [1573, 74], "traced_tactics": [{"tactic": "induction l\u2081 <;> simp [*, or_imp, forall_and, and_assoc, and_left_comm]", "annotated_tactic": ["induction l\u2081 <;> simp [*, <a>or_imp</a>, <a>forall_and</a>, <a>and_assoc</a>, <a>and_left_comm</a>]", [{"full_name": "or_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 15]}, {"full_name": "forall_and", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [189, 9], "def_end_pos": [189, 19]}, {"full_name": "and_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [136, 9], "def_end_pos": [136, 18]}, {"full_name": "and_left_comm", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [41, 9], "def_end_pos": [41, 22]}]], "state_before": "\u03b1 : Type u_1\nR : \u03b1 \u2192 \u03b1 \u2192 Prop\nl\u2081 l\u2082 : List \u03b1\n\u22a2 Pairwise R (l\u2081 ++ l\u2082) \u2194 Pairwise R l\u2081 \u2227 Pairwise R l\u2082 \u2227 \u2200 (a : \u03b1), a \u2208 l\u2081 \u2192 \u2200 (b : \u03b1), b \u2208 l\u2082 \u2192 R a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "symmDiff_right_injective", "start": [517, 1], "end": [518, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "full_name": "MeasureTheory.SimpleFunc.const_lintegral", "start": [1086, 1], "end": [1090, 78], "traced_tactics": [{"tactic": "rw [lintegral]", "annotated_tactic": ["rw [<a>lintegral</a>]", [{"full_name": "MeasureTheory.SimpleFunc.lintegral", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [965, 5], "def_end_pos": [965, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\n\u22a2 lintegral (const \u03b1 c) \u03bc = c * \u2191\u2191\u03bc univ", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\n\u22a2 \u2211 x in SimpleFunc.range (const \u03b1 c), x * \u2191\u2191\u03bc (\u2191(const \u03b1 c) \u207b\u00b9' {x}) = c * \u2191\u2191\u03bc univ"}, {"tactic": "cases isEmpty_or_nonempty \u03b1", "annotated_tactic": ["cases <a>isEmpty_or_nonempty</a> \u03b1", [{"full_name": "isEmpty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [215, 9], "def_end_pos": [215, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\n\u22a2 \u2211 x in SimpleFunc.range (const \u03b1 c), x * \u2191\u2191\u03bc (\u2191(const \u03b1 c) \u207b\u00b9' {x}) = c * \u2191\u2191\u03bc univ", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\nh\u271d : IsEmpty \u03b1\n\u22a2 \u2211 x in SimpleFunc.range (const \u03b1 c), x * \u2191\u2191\u03bc (\u2191(const \u03b1 c) \u207b\u00b9' {x}) = c * \u2191\u2191\u03bc univ\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\nh\u271d : Nonempty \u03b1\n\u22a2 \u2211 x in SimpleFunc.range (const \u03b1 c), x * \u2191\u2191\u03bc (\u2191(const \u03b1 c) \u207b\u00b9' {x}) = c * \u2191\u2191\u03bc univ"}, {"tactic": "simp [\u03bc.eq_zero_of_isEmpty]", "annotated_tactic": ["simp [\u03bc.eq_zero_of_isEmpty]", []], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\nh\u271d : IsEmpty \u03b1\n\u22a2 \u2211 x in SimpleFunc.range (const \u03b1 c), x * \u2191\u2191\u03bc (\u2191(const \u03b1 c) \u207b\u00b9' {x}) = c * \u2191\u2191\u03bc univ", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\nh\u271d : Nonempty \u03b1\n\u22a2 \u2211 x in SimpleFunc.range (const \u03b1 c), x * \u2191\u2191\u03bc (\u2191(const \u03b1 c) \u207b\u00b9' {x}) = c * \u2191\u2191\u03bc univ", "state_after": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\nh\u271d : Nonempty \u03b1\n\u22a2 c * \u2191\u2191\u03bc (Function.const \u03b1 c \u207b\u00b9' {c}) = c * \u2191\u2191\u03bc univ"}, {"tactic": "unfold Function.const", "annotated_tactic": ["unfold <a>Function.const</a>", [{"full_name": "Function.const", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [66, 15], "def_end_pos": [66, 29]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\nh\u271d : Nonempty \u03b1\n\u22a2 c * \u2191\u2191\u03bc (Function.const \u03b1 c \u207b\u00b9' {c}) = c * \u2191\u2191\u03bc univ", "state_after": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\nh\u271d : Nonempty \u03b1\n\u22a2 c * \u2191\u2191\u03bc ((fun x => c) \u207b\u00b9' {c}) = c * \u2191\u2191\u03bc univ"}, {"tactic": "rw [preimage_const_of_mem (mem_singleton c)]", "annotated_tactic": ["rw [<a>preimage_const_of_mem</a> (<a>mem_singleton</a> c)]", [{"full_name": "Set.preimage_const_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [126, 9], "def_end_pos": [126, 30]}, {"full_name": "Set.mem_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1259, 9], "def_end_pos": [1259, 22]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nc : \u211d\u22650\u221e\nh\u271d : Nonempty \u03b1\n\u22a2 c * \u2191\u2191\u03bc ((fun x => c) \u207b\u00b9' {c}) = c * \u2191\u2191\u03bc univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "toIocMod_toIocMod", "start": [738, 1], "end": [739, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Int.gcd_comm", "start": [257, 1], "end": [258, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "full_name": "NonUnitalSubring.list_sum_mem", "start": [288, 11], "end": [289, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Noetherian.lean", "full_name": "isNoetherian_top_iff", "start": [126, 1], "end": [129, 87], "traced_tactics": [{"tactic": "constructor <;> intro h", "annotated_tactic": ["constructor <;> intro h", []], "state_before": "R : Type u_1\nM : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R P\n\u22a2 IsNoetherian R \u21a5\u22a4 \u2194 IsNoetherian R M", "state_after": "case mp\nR : Type u_1\nM : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R P\nh : IsNoetherian R \u21a5\u22a4\n\u22a2 IsNoetherian R M\n\ncase mpr\nR : Type u_1\nM : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R P\nh : IsNoetherian R M\n\u22a2 IsNoetherian R \u21a5\u22a4"}, {"tactic": "exact isNoetherian_of_linearEquiv (LinearEquiv.ofTop (\u22a4 : Submodule R M) rfl)", "annotated_tactic": ["exact <a>isNoetherian_of_linearEquiv</a> (<a>LinearEquiv.ofTop</a> (\u22a4 : <a>Submodule</a> R M) <a>rfl</a>)", [{"full_name": "isNoetherian_of_linearEquiv", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Noetherian.lean", "def_pos": [122, 9], "def_end_pos": [122, 36]}, {"full_name": "LinearEquiv.ofTop", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [758, 5], "def_end_pos": [758, 10]}, {"full_name": "Submodule", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [39, 11], "def_end_pos": [39, 20]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case mp\nR : Type u_1\nM : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R P\nh : IsNoetherian R \u21a5\u22a4\n\u22a2 IsNoetherian R M", "state_after": "no goals"}, {"tactic": "exact isNoetherian_of_linearEquiv (LinearEquiv.ofTop (\u22a4 : Submodule R M) rfl).symm", "annotated_tactic": ["exact <a>isNoetherian_of_linearEquiv</a> (<a>LinearEquiv.ofTop</a> (\u22a4 : <a>Submodule</a> R M) <a>rfl</a>).<a>symm</a>", [{"full_name": "isNoetherian_of_linearEquiv", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Noetherian.lean", "def_pos": [122, 9], "def_end_pos": [122, 36]}, {"full_name": "LinearEquiv.ofTop", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [758, 5], "def_end_pos": [758, 10]}, {"full_name": "Submodule", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [39, 11], "def_end_pos": [39, 20]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "LinearEquiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [270, 5], "def_end_pos": [270, 9]}]], "state_before": "case mpr\nR : Type u_1\nM : Type u_2\nP : Type u_3\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R P\nh : IsNoetherian R M\n\u22a2 IsNoetherian R \u21a5\u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.right_dom_of_mul_dom", "start": [729, 1], "end": [729, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Thickening.lean", "full_name": "Metric.mem_thickening_iff", "start": [134, 1], "end": [137, 56], "traced_tactics": [{"tactic": "have key_iff : \u2200 z : X, edist x z < ENNReal.ofReal \u03b4 \u2194 dist x z < \u03b4 := fun z \u21a6 by\n  rw [dist_edist, lt_ofReal_iff_toReal_lt (edist_ne_top _ _)]", "annotated_tactic": ["have key_iff : \u2200 z : X, <a>edist</a> x z < <a>ENNReal.ofReal</a> \u03b4 \u2194 <a>dist</a> x z < \u03b4 := fun z \u21a6 by\n    rw [<a>dist_edist</a>, <a>lt_ofReal_iff_toReal_lt</a> (<a>edist_ne_top</a> _ _)]", [{"full_name": "EDist.edist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean", "def_pos": [51, 3], "def_end_pos": [51, 8]}, {"full_name": "ENNReal.ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [198, 29], "def_end_pos": [198, 35]}, {"full_name": "Dist.dist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [84, 3], "def_end_pos": [84, 7]}, {"full_name": "dist_edist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [391, 9], "def_end_pos": [391, 19]}, {"full_name": "ENNReal.lt_ofReal_iff_toReal_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [330, 9], "def_end_pos": [330, 32]}, {"full_name": "edist_ne_top", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [338, 9], "def_end_pos": [338, 21]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\ns : Set \u03b1\nx\u271d : \u03b1\nX : Type u\ninst\u271d : PseudoMetricSpace X\nE : Set X\nx : X\n\u22a2 x \u2208 thickening \u03b4 E \u2194 \u2203 z \u2208 E, dist x z < \u03b4", "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\ns : Set \u03b1\nx\u271d : \u03b1\nX : Type u\ninst\u271d : PseudoMetricSpace X\nE : Set X\nx : X\nkey_iff : \u2200 (z : X), edist x z < ENNReal.ofReal \u03b4 \u2194 dist x z < \u03b4\n\u22a2 x \u2208 thickening \u03b4 E \u2194 \u2203 z \u2208 E, dist x z < \u03b4"}, {"tactic": "simp_rw [mem_thickening_iff_exists_edist_lt, key_iff]", "annotated_tactic": ["simp_rw [<a>mem_thickening_iff_exists_edist_lt</a>, key_iff]", [{"full_name": "Metric.mem_thickening_iff_exists_edist_lt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [102, 9], "def_end_pos": [102, 43]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\ns : Set \u03b1\nx\u271d : \u03b1\nX : Type u\ninst\u271d : PseudoMetricSpace X\nE : Set X\nx : X\nkey_iff : \u2200 (z : X), edist x z < ENNReal.ofReal \u03b4 \u2194 dist x z < \u03b4\n\u22a2 x \u2208 thickening \u03b4 E \u2194 \u2203 z \u2208 E, dist x z < \u03b4", "state_after": "no goals"}, {"tactic": "rw [dist_edist, lt_ofReal_iff_toReal_lt (edist_ne_top _ _)]", "annotated_tactic": ["rw [<a>dist_edist</a>, <a>lt_ofReal_iff_toReal_lt</a> (<a>edist_ne_top</a> _ _)]", [{"full_name": "dist_edist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [391, 9], "def_end_pos": [391, 19]}, {"full_name": "ENNReal.lt_ofReal_iff_toReal_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [330, 9], "def_end_pos": [330, 32]}, {"full_name": "edist_ne_top", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [338, 9], "def_end_pos": [338, 21]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b4 : \u211d\ns : Set \u03b1\nx\u271d : \u03b1\nX : Type u\ninst\u271d : PseudoMetricSpace X\nE : Set X\nx z : X\n\u22a2 edist x z < ENNReal.ofReal \u03b4 \u2194 dist x z < \u03b4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "List.toFinset_inter", "start": [3512, 1], "end": [3514, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\nl\u271d l'\u271d : List \u03b1\na : \u03b1\nl l' : List \u03b1\n\u22a2 toFinset (l \u2229 l') = toFinset l \u2229 toFinset l'", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\nl\u271d l'\u271d : List \u03b1\na : \u03b1\nl l' : List \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 toFinset (l \u2229 l') \u2194 a\u271d \u2208 toFinset l \u2229 toFinset l'"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\nl\u271d l'\u271d : List \u03b1\na : \u03b1\nl l' : List \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 toFinset (l \u2229 l') \u2194 a\u271d \u2208 toFinset l \u2229 toFinset l'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "Continuous.ext_on", "start": [1594, 1], "end": [1596, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.not_mem_top", "start": [641, 1], "end": [642, 5], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "full_name": "hasSum_zero", "start": [34, 1], "end": [34, 91], "traced_tactics": [{"tactic": "simp [HasSum, tendsto_const_nhds]", "annotated_tactic": ["simp [<a>HasSum</a>, <a>tendsto_const_nhds</a>]", [{"full_name": "HasSum", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [59, 5], "def_end_pos": [59, 11]}, {"full_name": "tendsto_const_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [975, 9], "def_end_pos": [975, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na b : \u03b1\ns : Finset \u03b2\n\u22a2 HasSum (fun x => 0) 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Function/Support.lean", "full_name": "Function.mulSupport_along_fiber_subset", "start": [217, 1], "end": [219, 42], "traced_tactics": [{"tactic": "simpa using hx", "annotated_tactic": ["simpa using hx", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nA : Type u_3\nB : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\nR : Type u_8\nS : Type u_9\nG : Type u_10\nM\u2080 : Type u_11\nG\u2080 : Type u_12\n\u03b9 : Sort u_13\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : One N\ninst\u271d : One P\nf : \u03b1 \u00d7 \u03b2 \u2192 M\na : \u03b1\nx : \u03b2\nhx : x \u2208 mulSupport fun b => f (a, b)\n\u22a2 (a, x) \u2208 mulSupport f \u2227 (a, x).2 = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Option/Basic.lean", "full_name": "Option.map_pmap", "start": [197, 1], "end": [199, 56], "traced_tactics": [{"tactic": "cases x <;> simp only [map_none', map_some', pmap]", "annotated_tactic": ["cases x <;> simp only [<a>map_none'</a>, <a>map_some'</a>, <a>pmap</a>]", [{"full_name": "Option.map_none'", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [90, 17], "def_end_pos": [90, 26]}, {"full_name": "Option.map_some'", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [91, 17], "def_end_pos": [91, 26]}, {"full_name": "Option.pmap", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Instances.lean", "def_pos": [68, 21], "def_end_pos": [68, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\np : \u03b1 \u2192 Prop\nf\u271d : (a : \u03b1) \u2192 p a \u2192 \u03b2\nx\u271d : Option \u03b1\ng : \u03b2 \u2192 \u03b3\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nx : Option \u03b1\nH : \u2200 (a : \u03b1), a \u2208 x \u2192 p a\n\u22a2 Option.map g (pmap f x H) = pmap (fun a h => g (f a h)) x H", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "tsub_self_add", "start": [353, 1], "end": [354, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean", "full_name": "ContinuousLinearMap.toSesqForm_apply_coe", "start": [1839, 1], "end": [1840, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/Finrank.lean", "full_name": "LinearEquiv.finrank_eq", "start": [113, 1], "end": [115, 66], "traced_tactics": [{"tactic": "unfold finrank", "annotated_tactic": ["unfold <a>finrank</a>", [{"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}]], "state_before": "R\u271d : Type u\nM\u271d : Type v\nN : Type w\ninst\u271d\u2079 : Ring R\u271d\ninst\u271d\u2078 : AddCommGroup M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\ninst\u271d\u2076 : AddCommGroup N\ninst\u271d\u2075 : Module R\u271d N\nR : Type u_1\nM : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\nf : M \u2243\u2097[R] M\u2082\n\u22a2 finrank R M = finrank R M\u2082", "state_after": "R\u271d : Type u\nM\u271d : Type v\nN : Type w\ninst\u271d\u2079 : Ring R\u271d\ninst\u271d\u2078 : AddCommGroup M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\ninst\u271d\u2076 : AddCommGroup N\ninst\u271d\u2075 : Module R\u271d N\nR : Type u_1\nM : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\nf : M \u2243\u2097[R] M\u2082\n\u22a2 toNat (Module.rank R M) = toNat (Module.rank R M\u2082)"}, {"tactic": "rw [\u2190 Cardinal.toNat_lift, f.lift_rank_eq, Cardinal.toNat_lift]", "annotated_tactic": ["rw [\u2190 <a>Cardinal.toNat_lift</a>, f.lift_rank_eq, <a>Cardinal.toNat_lift</a>]", [{"full_name": "Cardinal.toNat_lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/ToNat.lean", "def_pos": [165, 9], "def_end_pos": [165, 19]}, {"full_name": "Cardinal.toNat_lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/ToNat.lean", "def_pos": [165, 9], "def_end_pos": [165, 19]}]], "state_before": "R\u271d : Type u\nM\u271d : Type v\nN : Type w\ninst\u271d\u2079 : Ring R\u271d\ninst\u271d\u2078 : AddCommGroup M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\ninst\u271d\u2076 : AddCommGroup N\ninst\u271d\u2075 : Module R\u271d N\nR : Type u_1\nM : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\nf : M \u2243\u2097[R] M\u2082\n\u22a2 toNat (Module.rank R M) = toNat (Module.rank R M\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.prod_inter", "start": [139, 1], "end": [141, 54], "traced_tactics": [{"tactic": "ext \u27e8x, y\u27e9", "annotated_tactic": ["ext \u27e8x, y\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 s \u00d7\u02e2 (t\u2081 \u2229 t\u2082) = s \u00d7\u02e2 t\u2081 \u2229 s \u00d7\u02e2 t\u2082", "state_after": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 s \u00d7\u02e2 (t\u2081 \u2229 t\u2082) \u2194 (x, y) \u2208 s \u00d7\u02e2 t\u2081 \u2229 s \u00d7\u02e2 t\u2082"}, {"tactic": "simp only [\u2190 and_and_left, mem_inter_iff, mem_prod]", "annotated_tactic": ["simp only [\u2190 <a>and_and_left</a>, <a>mem_inter_iff</a>, <a>mem_prod</a>]", [{"full_name": "and_and_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [51, 9], "def_end_pos": [51, 21]}, {"full_name": "Set.mem_inter_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 22]}, {"full_name": "Set.mem_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [207, 9], "def_end_pos": [207, 17]}]], "state_before": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 s \u00d7\u02e2 (t\u2081 \u2229 t\u2082) \u2194 (x, y) \u2208 s \u00d7\u02e2 t\u2081 \u2229 s \u00d7\u02e2 t\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "group_inseparable_iff", "start": [1586, 1], "end": [1589, 24], "traced_tactics": [{"tactic": "rw [\u2190 singleton_one, \u2190 specializes_iff_mem_closure, specializes_comm, specializes_iff_inseparable,\n  \u2190 (Homeomorph.mulRight y\u207b\u00b9).embedding.inseparable_iff]", "annotated_tactic": ["rw [\u2190 <a>singleton_one</a>, \u2190 <a>specializes_iff_mem_closure</a>, <a>specializes_comm</a>, <a>specializes_iff_inseparable</a>,\n    \u2190 (<a>Homeomorph.mulRight</a> y\u207b\u00b9).embedding.inseparable_iff]", [{"full_name": "Set.singleton_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [95, 9], "def_end_pos": [95, 22]}, {"full_name": "specializes_iff_mem_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Inseparable.lean", "def_pos": [122, 9], "def_end_pos": [122, 36]}, {"full_name": "specializes_comm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [946, 9], "def_end_pos": [946, 25]}, {"full_name": "specializes_iff_inseparable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [951, 9], "def_end_pos": [951, 36]}, {"full_name": "Homeomorph.mulRight", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [101, 15], "def_end_pos": [101, 34]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nx y : G\n\u22a2 Inseparable x y \u2194 x / y \u2208 closure 1", "state_after": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nx y : G\n\u22a2 Inseparable ((Homeomorph.mulRight y\u207b\u00b9) x) ((Homeomorph.mulRight y\u207b\u00b9) y) \u2194 Inseparable (x / y) 1"}, {"tactic": "simp [div_eq_mul_inv]", "annotated_tactic": ["simp [<a>div_eq_mul_inv</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nx y : G\n\u22a2 Inseparable ((Homeomorph.mulRight y\u207b\u00b9) x) ((Homeomorph.mulRight y\u207b\u00b9) y) \u2194 Inseparable (x / y) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "full_name": "Matrix.SpecialLinearGroup.SL2_inv_expl_det", "start": [377, 1], "end": [383, 15], "traced_tactics": [{"tactic": "rw [Matrix.det_fin_two, mul_comm]", "annotated_tactic": ["rw [<a>Matrix.det_fin_two</a>, <a>mul_comm</a>]", [{"full_name": "Matrix.det_fin_two", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [791, 9], "def_end_pos": [791, 20]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\n\u22a2 det ![![\u2191A 1 1, -\u2191A 0 1], ![-\u2191A 1 0, \u2191A 0 0]] = 1", "state_after": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\n\u22a2 ![![\u2191A 1 1, -\u2191A 0 1], ![-\u2191A 1 0, \u2191A 0 0]] 1 1 * ![![\u2191A 1 1, -\u2191A 0 1], ![-\u2191A 1 0, \u2191A 0 0]] 0 0 -\n      ![![\u2191A 1 1, -\u2191A 0 1], ![-\u2191A 1 0, \u2191A 0 0]] 0 1 * ![![\u2191A 1 1, -\u2191A 0 1], ![-\u2191A 1 0, \u2191A 0 0]] 1 0 =\n    1"}, {"tactic": "simp only [cons_val_zero, cons_val_one, head_cons, mul_neg, neg_mul, neg_neg]", "annotated_tactic": ["simp only [<a>cons_val_zero</a>, <a>cons_val_one</a>, <a>head_cons</a>, <a>mul_neg</a>, <a>neg_mul</a>, <a>neg_neg</a>]", [{"full_name": "Matrix.cons_val_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [132, 9], "def_end_pos": [132, 22]}, {"full_name": "Matrix.cons_val_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [209, 9], "def_end_pos": [209, 21]}, {"full_name": "Matrix.head_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [152, 9], "def_end_pos": [152, 18]}, {"full_name": "mul_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [311, 9], "def_end_pos": [311, 16]}, {"full_name": "neg_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [306, 9], "def_end_pos": [306, 16]}, {"full_name": "neg_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [810, 3], "def_end_pos": [810, 14]}]], "state_before": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\n\u22a2 ![![\u2191A 1 1, -\u2191A 0 1], ![-\u2191A 1 0, \u2191A 0 0]] 1 1 * ![![\u2191A 1 1, -\u2191A 0 1], ![-\u2191A 1 0, \u2191A 0 0]] 0 0 -\n      ![![\u2191A 1 1, -\u2191A 0 1], ![-\u2191A 1 0, \u2191A 0 0]] 0 1 * ![![\u2191A 1 1, -\u2191A 0 1], ![-\u2191A 1 0, \u2191A 0 0]] 1 0 =\n    1", "state_after": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\n\u22a2 \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0 = 1"}, {"tactic": "have := A.2", "annotated_tactic": ["have := A.2", []], "state_before": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\n\u22a2 \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0 = 1", "state_after": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\nthis : det \u2191A = 1\n\u22a2 \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0 = 1"}, {"tactic": "rw [Matrix.det_fin_two] at this", "annotated_tactic": ["rw [<a>Matrix.det_fin_two</a>] at this", [{"full_name": "Matrix.det_fin_two", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [791, 9], "def_end_pos": [791, 20]}]], "state_before": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\nthis : det \u2191A = 1\n\u22a2 \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0 = 1", "state_after": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\nthis : \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0 = 1\n\u22a2 \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0 = 1"}, {"tactic": "convert this", "annotated_tactic": ["convert this", []], "state_before": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\nthis : \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0 = 1\n\u22a2 \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Prod.lean", "full_name": "Finset.product_sdiff_offDiag", "start": [381, 1], "end": [382, 99], "traced_tactics": [{"tactic": "rw [\u2190 diag_union_offDiag, union_sdiff_self, sdiff_eq_self_of_disjoint (disjoint_diag_offDiag _)]", "annotated_tactic": ["rw [\u2190 <a>diag_union_offDiag</a>, <a>union_sdiff_self</a>, <a>sdiff_eq_self_of_disjoint</a> (<a>disjoint_diag_offDiag</a> _)]", [{"full_name": "Finset.diag_union_offDiag", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Prod.lean", "def_pos": [367, 9], "def_end_pos": [367, 27]}, {"full_name": "Finset.union_sdiff_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2313, 9], "def_end_pos": [2313, 25]}, {"full_name": "Finset.sdiff_eq_self_of_disjoint", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2474, 9], "def_end_pos": [2474, 34]}, {"full_name": "Finset.disjoint_diag_offDiag", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Prod.lean", "def_pos": [372, 9], "def_end_pos": [372, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 s \u00d7\u02e2 s \\ offDiag s = diag s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_ne_zero_iff", "start": [2180, 1], "end": [2182, 16], "traced_tactics": [{"tactic": "rw [Ne, prod_eq_zero_iff]", "annotated_tactic": ["rw [<a>Ne</a>, <a>prod_eq_zero_iff</a>]", [{"full_name": "Ne", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [687, 18], "def_end_pos": [687, 20]}, {"full_name": "Finset.prod_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [2173, 9], "def_end_pos": [2173, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\ninst\u271d\u00b9 : Nontrivial \u03b2\ninst\u271d : NoZeroDivisors \u03b2\n\u22a2 \u220f x in s, f x \u2260 0 \u2194 \u2200 a \u2208 s, f a \u2260 0", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\ninst\u271d\u00b9 : Nontrivial \u03b2\ninst\u271d : NoZeroDivisors \u03b2\n\u22a2 (\u00ac\u2203 a \u2208 s, f a = 0) \u2194 \u2200 a \u2208 s, f a \u2260 0"}, {"tactic": "push_neg", "annotated_tactic": ["push_neg", []], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\ninst\u271d\u00b9 : Nontrivial \u03b2\ninst\u271d : NoZeroDivisors \u03b2\n\u22a2 (\u00ac\u2203 a \u2208 s, f a = 0) \u2194 \u2200 a \u2208 s, f a \u2260 0", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\ninst\u271d\u00b9 : Nontrivial \u03b2\ninst\u271d : NoZeroDivisors \u03b2\n\u22a2 (\u2200 a \u2208 s, f a \u2260 0) \u2194 \u2200 a \u2208 s, f a \u2260 0"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\ninst\u271d\u00b9 : Nontrivial \u03b2\ninst\u271d : NoZeroDivisors \u03b2\n\u22a2 (\u2200 a \u2208 s, f a \u2260 0) \u2194 \u2200 a \u2208 s, f a \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/PiSystem.lean", "full_name": "mem_piiUnionInter_of_measurableSet", "start": [495, 1], "end": [498, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "full_name": "Complex.cpow_def_of_ne_zero", "start": [40, 1], "end": [41, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/PNat/Basic.lean", "full_name": "PNat.natPred_lt_natPred", "start": [57, 1], "end": [58, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "IsG\u03b4.measurableSet", "start": [332, 1], "end": [334, 70], "traced_tactics": [{"tactic": "rcases h with \u27e8S, hSo, hSc, rfl\u27e9", "annotated_tactic": ["rcases h with \u27e8S, hSo, hSc, rfl\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u2070 : OpensMeasurableSpace \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b2\ninst\u271d\u2078 : MeasurableSpace \u03b2\ninst\u271d\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u2076 : TopologicalSpace \u03b3\ninst\u271d\u2075 : MeasurableSpace \u03b3\ninst\u271d\u2074 : BorelSpace \u03b3\ninst\u271d\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d : MeasurableSpace \u03b4\nh : IsG\u03b4 s\n\u22a2 MeasurableSet s", "state_after": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\nt u : Set \u03b1\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u2070 : OpensMeasurableSpace \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b2\ninst\u271d\u2078 : MeasurableSpace \u03b2\ninst\u271d\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u2076 : TopologicalSpace \u03b3\ninst\u271d\u2075 : MeasurableSpace \u03b3\ninst\u271d\u2074 : BorelSpace \u03b3\ninst\u271d\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d : MeasurableSpace \u03b4\nS : Set (Set \u03b1)\nhSo : \u2200 t \u2208 S, IsOpen t\nhSc : Set.Countable S\n\u22a2 MeasurableSet (\u22c2\u2080 S)"}, {"tactic": "exact MeasurableSet.sInter hSc fun t ht => (hSo t ht).measurableSet", "annotated_tactic": ["exact <a>MeasurableSet.sInter</a> hSc fun t ht => (hSo t ht).<a>measurableSet</a>", [{"full_name": "MeasurableSet.sInter", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [180, 9], "def_end_pos": [180, 29]}, {"full_name": "IsOpen.measurableSet", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "def_pos": [319, 9], "def_end_pos": [319, 29]}]], "state_before": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\nt u : Set \u03b1\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u2070 : OpensMeasurableSpace \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b2\ninst\u271d\u2078 : MeasurableSpace \u03b2\ninst\u271d\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u2076 : TopologicalSpace \u03b3\ninst\u271d\u2075 : MeasurableSpace \u03b3\ninst\u271d\u2074 : BorelSpace \u03b3\ninst\u271d\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d : MeasurableSpace \u03b4\nS : Set (Set \u03b1)\nhSo : \u2200 t \u2208 S, IsOpen t\nhSc : Set.Countable S\n\u22a2 MeasurableSet (\u22c2\u2080 S)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean", "full_name": "MeasureTheory.Measure.restrict_prod_eq_prod_univ", "start": [762, 1], "end": [765, 43], "traced_tactics": [{"tactic": "have : \u03bd = \u03bd.restrict Set.univ := Measure.restrict_univ.symm", "annotated_tactic": ["have : \u03bd = \u03bd.restrict <a>Set.univ</a> := Measure.restrict_univ.symm", [{"full_name": "Set.univ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [153, 5], "def_end_pos": [153, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\nE : Type u_6\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b1'\ninst\u271d\u2075 : MeasurableSpace \u03b2\ninst\u271d\u2074 : MeasurableSpace \u03b2'\ninst\u271d\u00b3 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\n\u22a2 Measure.prod (restrict \u03bc s) \u03bd = restrict (Measure.prod \u03bc \u03bd) (s \u00d7\u02e2 univ)", "state_after": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\nE : Type u_6\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b1'\ninst\u271d\u2075 : MeasurableSpace \u03b2\ninst\u271d\u2074 : MeasurableSpace \u03b2'\ninst\u271d\u00b3 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nthis : \u03bd = restrict \u03bd univ\n\u22a2 Measure.prod (restrict \u03bc s) \u03bd = restrict (Measure.prod \u03bc \u03bd) (s \u00d7\u02e2 univ)"}, {"tactic": "rw [this, Measure.prod_restrict, \u2190 this]", "annotated_tactic": ["rw [this, <a>Measure.prod_restrict</a>, \u2190 this]", [{"full_name": "MeasureTheory.Measure.prod_restrict", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/Prod/Basic.lean", "def_pos": [751, 9], "def_end_pos": [751, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\nE : Type u_6\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b1'\ninst\u271d\u2075 : MeasurableSpace \u03b2\ninst\u271d\u2074 : MeasurableSpace \u03b2'\ninst\u271d\u00b3 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nthis : \u03bd = restrict \u03bd univ\n\u22a2 Measure.prod (restrict \u03bc s) \u03bd = restrict (Measure.prod \u03bc \u03bd) (s \u00d7\u02e2 univ)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Monoid.lean", "full_name": "Set.Ioo_add_bij", "start": [51, 1], "end": [55, 34], "traced_tactics": [{"tactic": "rw [\u2190 Ioi_inter_Iio, \u2190 Ioi_inter_Iio]", "annotated_tactic": ["rw [\u2190 <a>Ioi_inter_Iio</a>, \u2190 <a>Ioi_inter_Iio</a>]", [{"full_name": "Set.Ioi_inter_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [630, 9], "def_end_pos": [630, 22]}, {"full_name": "Set.Ioi_inter_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [630, 9], "def_end_pos": [630, 22]}]], "state_before": "M : Type u_1\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid M\ninst\u271d : ExistsAddOfLE M\na b c d : M\n\u22a2 BijOn (fun x => x + d) (Ioo a b) (Ioo (a + d) (b + d))", "state_after": "M : Type u_1\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid M\ninst\u271d : ExistsAddOfLE M\na b c d : M\n\u22a2 BijOn (fun x => x + d) (Ioi a \u2229 Iio b) (Ioi (a + d) \u2229 Iio (b + d))"}, {"tactic": "exact\n  (Ioi_add_bij a d).inter_mapsTo (fun x hx => add_lt_add_right hx _) fun x hx =>\n    lt_of_add_lt_add_right hx.2", "annotated_tactic": ["exact\n    (<a>Ioi_add_bij</a> a d).<a>inter_mapsTo</a> (fun x hx => <a>add_lt_add_right</a> hx _) fun x hx =>\n      <a>lt_of_add_lt_add_right</a> hx.2", [{"full_name": "Set.Ioi_add_bij", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Monoid.lean", "def_pos": [35, 9], "def_end_pos": [35, 20]}, {"full_name": "Set.BijOn.inter_mapsTo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [979, 9], "def_end_pos": [979, 27]}, {"full_name": "add_lt_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [135, 32], "def_end_pos": [135, 48]}, {"full_name": "lt_of_add_lt_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [143, 15], "def_end_pos": [143, 37]}]], "state_before": "M : Type u_1\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid M\ninst\u271d : ExistsAddOfLE M\na b c d : M\n\u22a2 BijOn (fun x => x + d) (Ioi a \u2229 Iio b) (Ioi (a + d) \u2229 Iio (b + d))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/SuccPred.lean", "full_name": "Int.covBy_iff_succ_eq", "start": [76, 11], "end": [77, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WellFounded.lean", "full_name": "WellFounded.induction_bot", "start": [283, 1], "end": [285, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Defs.lean", "full_name": "smul_pos_iff_of_pos_left", "start": [461, 1], "end": [464, 83], "traced_tactics": [{"tactic": "simpa only [smul_zero] using smul_lt_smul_iff_of_pos_left ha (b\u2081 := 0) (b\u2082 := b)", "annotated_tactic": ["simpa only [<a>smul_zero</a>] using <a>smul_lt_smul_iff_of_pos_left</a> ha (b\u2081 := 0) (b\u2082 := b)", [{"full_name": "smul_zero", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [760, 9], "def_end_pos": [760, 18]}, {"full_name": "smul_lt_smul_iff_of_pos_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Module/Defs.lean", "def_pos": [285, 7], "def_end_pos": [285, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na a\u2081 a\u2082 : \u03b1\nb b\u2081 b\u2082 : \u03b2\ninst\u271d\u2076 : Zero \u03b1\ninst\u271d\u2075 : Zero \u03b2\ninst\u271d\u2074 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d : PosSMulReflectLT \u03b1 \u03b2\nha : 0 < a\n\u22a2 0 < a \u2022 b \u2194 0 < b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "orderOf_pow_dvd", "start": [279, 1], "end": [280, 79], "traced_tactics": [{"tactic": "rw [orderOf_dvd_iff_pow_eq_one, pow_right_comm, pow_orderOf_eq_one, one_pow]", "annotated_tactic": ["rw [<a>orderOf_dvd_iff_pow_eq_one</a>, <a>pow_right_comm</a>, <a>pow_orderOf_eq_one</a>, <a>one_pow</a>]", [{"full_name": "orderOf_dvd_iff_pow_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [272, 9], "def_end_pos": [272, 35]}, {"full_name": "pow_right_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [144, 9], "def_end_pos": [144, 23]}, {"full_name": "pow_orderOf_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [176, 9], "def_end_pos": [176, 27]}, {"full_name": "one_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [75, 9], "def_end_pos": [75, 16]}]], "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : Monoid G\na b x y : G\nn\u271d m n : \u2115\n\u22a2 orderOf (x ^ n) \u2223 orderOf x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "full_name": "ContinuousMultilinearMap.opNorm_nonneg", "start": [354, 1], "end": [355, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.inter_subset_inter_left", "start": [1771, 1], "end": [1772, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Perm.lean", "full_name": "List.Perm.foldl_eq'", "start": [299, 1], "end": [313, 63], "traced_tactics": [{"tactic": "induction p using recOnSwap' generalizing init with\n| nil => simp\n| cons x _p IH =>\n  simp only [foldl]\n  apply IH; intros; apply comm <;> exact .tail _ \u2039_\u203a\n| swap' x y _p IH =>\n  simp only [foldl]\n  rw [comm x (.tail _ <| .head _) y (.head _)]\n  apply IH; intros; apply comm <;> exact .tail _ (.tail _ \u2039_\u203a)\n| trans p\u2081 _p\u2082 IH\u2081 IH\u2082 =>\n  refine (IH\u2081 comm init).trans (IH\u2082 ?_ _)\n  intros; apply comm <;> apply p\u2081.symm.subset <;> assumption", "annotated_tactic": ["induction p using <a>recOnSwap'</a> generalizing init with\n  | <a>nil</a> => simp\n  | <a>cons</a> x _p IH =>\n    simp only [<a>foldl</a>]\n    apply IH; intros; apply comm <;> exact .tail _ \u2039_\u203a\n  | <a>swap'</a> x y _p IH =>\n    simp only [<a>foldl</a>]\n    rw [comm x (.tail _ <| .head _) y (.head _)]\n    apply IH; intros; apply comm <;> exact .tail _ (.tail _ \u2039_\u203a)\n  | <a>trans</a> p\u2081 _p\u2082 IH\u2081 IH\u2082 =>\n    refine (IH\u2081 comm init).<a>trans</a> (IH\u2082 ?_ _)\n    intros; apply comm <;> apply p\u2081.symm.subset <;> assumption", [{"full_name": "List.Perm.recOnSwap'", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [53, 25], "def_end_pos": [53, 40]}, {"full_name": "List.Perm.nil", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1560, 5], "def_end_pos": [1560, 8]}, {"full_name": "List.Perm.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1562, 5], "def_end_pos": [1562, 9]}, {"full_name": "List.foldl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2296, 5], "def_end_pos": [2296, 15]}, {"full_name": "List.Perm.swap'", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [46, 9], "def_end_pos": [46, 19]}, {"full_name": "List.foldl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2296, 5], "def_end_pos": [2296, 15]}, {"full_name": "List.Perm.trans", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1566, 5], "def_end_pos": [1566, 10]}, {"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}]], "state_before": "\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\np : l\u2081 ~ l\u2082\ncomm : \u2200 (x : \u03b1), x \u2208 l\u2081 \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081 \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x\ninit : \u03b2\n\u22a2 foldl f init l\u2081 = foldl f init l\u2082", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\ncomm : \u2200 (x : \u03b1), x \u2208 [] \u2192 \u2200 (y : \u03b1), y \u2208 [] \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x\ninit : \u03b2\n\u22a2 foldl f init [] = foldl f init []", "state_after": "no goals"}, {"tactic": "simp only [foldl]", "annotated_tactic": ["simp only [<a>foldl</a>]", [{"full_name": "List.foldl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2296, 5], "def_end_pos": [2296, 15]}]], "state_before": "case cons\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm : \u2200 (x_1 : \u03b1), x_1 \u2208 x :: l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y = f (f z y) x_1\ninit : \u03b2\n\u22a2 foldl f init (x :: l\u2081\u271d) = foldl f init (x :: l\u2082\u271d)", "state_after": "case cons\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm : \u2200 (x_1 : \u03b1), x_1 \u2208 x :: l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y = f (f z y) x_1\ninit : \u03b2\n\u22a2 foldl f (f init x) l\u2081\u271d = foldl f (f init x) l\u2082\u271d"}, {"tactic": "apply IH", "annotated_tactic": ["apply IH", []], "state_before": "case cons\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm : \u2200 (x_1 : \u03b1), x_1 \u2208 x :: l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y = f (f z y) x_1\ninit : \u03b2\n\u22a2 foldl f (f init x) l\u2081\u271d = foldl f (f init x) l\u2082\u271d", "state_after": "case cons.comm\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm : \u2200 (x_1 : \u03b1), x_1 \u2208 x :: l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y = f (f z y) x_1\ninit : \u03b2\n\u22a2 \u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x"}, {"tactic": "intros", "annotated_tactic": ["intros", []], "state_before": "case cons.comm\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm : \u2200 (x_1 : \u03b1), x_1 \u2208 x :: l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y = f (f z y) x_1\ninit : \u03b2\n\u22a2 \u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x", "state_after": "case cons.comm\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm : \u2200 (x_1 : \u03b1), x_1 \u2208 x :: l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y = f (f z y) x_1\ninit : \u03b2\nx\u271d : \u03b1\na\u271d\u00b9 : x\u271d \u2208 l\u2081\u271d\ny\u271d : \u03b1\na\u271d : y\u271d \u2208 l\u2081\u271d\nz\u271d : \u03b2\n\u22a2 f (f z\u271d x\u271d) y\u271d = f (f z\u271d y\u271d) x\u271d"}, {"tactic": "apply comm <;> exact .tail _ \u2039_\u203a", "annotated_tactic": ["apply comm <;> exact .tail _ \u2039_\u203a", []], "state_before": "case cons.comm\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm : \u2200 (x_1 : \u03b1), x_1 \u2208 x :: l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y = f (f z y) x_1\ninit : \u03b2\nx\u271d : \u03b1\na\u271d\u00b9 : x\u271d \u2208 l\u2081\u271d\ny\u271d : \u03b1\na\u271d : y\u271d \u2208 l\u2081\u271d\nz\u271d : \u03b2\n\u22a2 f (f z\u271d x\u271d) y\u271d = f (f z\u271d y\u271d) x\u271d", "state_after": "no goals"}, {"tactic": "simp only [foldl]", "annotated_tactic": ["simp only [<a>foldl</a>]", [{"full_name": "List.foldl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2296, 5], "def_end_pos": [2296, 15]}]], "state_before": "case swap'\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm :\n  \u2200 (x_1 : \u03b1), x_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (y_1 : \u03b1), y_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y_1 = f (f z y_1) x_1\ninit : \u03b2\n\u22a2 foldl f init (y :: x :: l\u2081\u271d) = foldl f init (x :: y :: l\u2082\u271d)", "state_after": "case swap'\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm :\n  \u2200 (x_1 : \u03b1), x_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (y_1 : \u03b1), y_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y_1 = f (f z y_1) x_1\ninit : \u03b2\n\u22a2 foldl f (f (f init y) x) l\u2081\u271d = foldl f (f (f init x) y) l\u2082\u271d"}, {"tactic": "rw [comm x (.tail _ <| .head _) y (.head _)]", "annotated_tactic": ["rw [comm x (.tail _ <| .head _) y (.head _)]", []], "state_before": "case swap'\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm :\n  \u2200 (x_1 : \u03b1), x_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (y_1 : \u03b1), y_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y_1 = f (f z y_1) x_1\ninit : \u03b2\n\u22a2 foldl f (f (f init y) x) l\u2081\u271d = foldl f (f (f init x) y) l\u2082\u271d", "state_after": "case swap'\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm :\n  \u2200 (x_1 : \u03b1), x_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (y_1 : \u03b1), y_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y_1 = f (f z y_1) x_1\ninit : \u03b2\n\u22a2 foldl f (f (f init y) x) l\u2081\u271d = foldl f (f (f init y) x) l\u2082\u271d"}, {"tactic": "apply IH", "annotated_tactic": ["apply IH", []], "state_before": "case swap'\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm :\n  \u2200 (x_1 : \u03b1), x_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (y_1 : \u03b1), y_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y_1 = f (f z y_1) x_1\ninit : \u03b2\n\u22a2 foldl f (f (f init y) x) l\u2081\u271d = foldl f (f (f init y) x) l\u2082\u271d", "state_after": "case swap'.comm\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm :\n  \u2200 (x_1 : \u03b1), x_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (y_1 : \u03b1), y_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y_1 = f (f z y_1) x_1\ninit : \u03b2\n\u22a2 \u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x"}, {"tactic": "intros", "annotated_tactic": ["intros", []], "state_before": "case swap'.comm\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm :\n  \u2200 (x_1 : \u03b1), x_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (y_1 : \u03b1), y_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y_1 = f (f z y_1) x_1\ninit : \u03b2\n\u22a2 \u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x", "state_after": "case swap'.comm\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm :\n  \u2200 (x_1 : \u03b1), x_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (y_1 : \u03b1), y_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y_1 = f (f z y_1) x_1\ninit : \u03b2\nx\u271d : \u03b1\na\u271d\u00b9 : x\u271d \u2208 l\u2081\u271d\ny\u271d : \u03b1\na\u271d : y\u271d \u2208 l\u2081\u271d\nz\u271d : \u03b2\n\u22a2 f (f z\u271d x\u271d) y\u271d = f (f z\u271d y\u271d) x\u271d"}, {"tactic": "apply comm <;> exact .tail _ (.tail _ \u2039_\u203a)", "annotated_tactic": ["apply comm <;> exact .tail _ (.tail _ \u2039_\u203a)", []], "state_before": "case swap'.comm\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\ncomm :\n  \u2200 (x_1 : \u03b1), x_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (y_1 : \u03b1), y_1 \u2208 y :: x :: l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x_1) y_1 = f (f z y_1) x_1\ninit : \u03b2\nx\u271d : \u03b1\na\u271d\u00b9 : x\u271d \u2208 l\u2081\u271d\ny\u271d : \u03b1\na\u271d : y\u271d \u2208 l\u2081\u271d\nz\u271d : \u03b2\n\u22a2 f (f z\u271d x\u271d) y\u271d = f (f z\u271d y\u271d) x\u271d", "state_after": "no goals"}, {"tactic": "refine (IH\u2081 comm init).trans (IH\u2082 ?_ _)", "annotated_tactic": ["refine (IH\u2081 comm init).<a>trans</a> (IH\u2082 ?_ _)", [{"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}]], "state_before": "case trans\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 l\u2081\u271d l\u2082\u271d l\u2083\u271d : List \u03b1\np\u2081 : l\u2081\u271d ~ l\u2082\u271d\n_p\u2082 : l\u2082\u271d ~ l\u2083\u271d\nIH\u2081 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\nIH\u2082 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2082\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2082\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2082\u271d = foldl f init l\u2083\u271d\ncomm : \u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x\ninit : \u03b2\n\u22a2 foldl f init l\u2081\u271d = foldl f init l\u2083\u271d", "state_after": "case trans\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 l\u2081\u271d l\u2082\u271d l\u2083\u271d : List \u03b1\np\u2081 : l\u2081\u271d ~ l\u2082\u271d\n_p\u2082 : l\u2082\u271d ~ l\u2083\u271d\nIH\u2081 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\nIH\u2082 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2082\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2082\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2082\u271d = foldl f init l\u2083\u271d\ncomm : \u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x\ninit : \u03b2\n\u22a2 \u2200 (x : \u03b1), x \u2208 l\u2082\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2082\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x"}, {"tactic": "intros", "annotated_tactic": ["intros", []], "state_before": "case trans\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 l\u2081\u271d l\u2082\u271d l\u2083\u271d : List \u03b1\np\u2081 : l\u2081\u271d ~ l\u2082\u271d\n_p\u2082 : l\u2082\u271d ~ l\u2083\u271d\nIH\u2081 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\nIH\u2082 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2082\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2082\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2082\u271d = foldl f init l\u2083\u271d\ncomm : \u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x\ninit : \u03b2\n\u22a2 \u2200 (x : \u03b1), x \u2208 l\u2082\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2082\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x", "state_after": "case trans\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 l\u2081\u271d l\u2082\u271d l\u2083\u271d : List \u03b1\np\u2081 : l\u2081\u271d ~ l\u2082\u271d\n_p\u2082 : l\u2082\u271d ~ l\u2083\u271d\nIH\u2081 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\nIH\u2082 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2082\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2082\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2082\u271d = foldl f init l\u2083\u271d\ncomm : \u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x\ninit : \u03b2\nx\u271d : \u03b1\na\u271d\u00b9 : x\u271d \u2208 l\u2082\u271d\ny\u271d : \u03b1\na\u271d : y\u271d \u2208 l\u2082\u271d\nz\u271d : \u03b2\n\u22a2 f (f z\u271d x\u271d) y\u271d = f (f z\u271d y\u271d) x\u271d"}, {"tactic": "apply comm <;> apply p\u2081.symm.subset <;> assumption", "annotated_tactic": ["apply comm <;> apply p\u2081.symm.subset <;> assumption", []], "state_before": "case trans\n\u03b2 : Type u_1\n\u03b1 : Type u_2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\nl\u2081 l\u2082 l\u2081\u271d l\u2082\u271d l\u2083\u271d : List \u03b1\np\u2081 : l\u2081\u271d ~ l\u2082\u271d\n_p\u2082 : l\u2082\u271d ~ l\u2083\u271d\nIH\u2081 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2081\u271d = foldl f init l\u2082\u271d\nIH\u2082 :\n  (\u2200 (x : \u03b1), x \u2208 l\u2082\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2082\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x) \u2192\n    \u2200 (init : \u03b2), foldl f init l\u2082\u271d = foldl f init l\u2083\u271d\ncomm : \u2200 (x : \u03b1), x \u2208 l\u2081\u271d \u2192 \u2200 (y : \u03b1), y \u2208 l\u2081\u271d \u2192 \u2200 (z : \u03b2), f (f z x) y = f (f z y) x\ninit : \u03b2\nx\u271d : \u03b1\na\u271d\u00b9 : x\u271d \u2208 l\u2082\u271d\ny\u271d : \u03b1\na\u271d : y\u271d \u2208 l\u2082\u271d\nz\u271d : \u03b2\n\u22a2 f (f z\u271d x\u271d) y\u271d = f (f z\u271d y\u271d) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.sup_toFinset", "start": [220, 1], "end": [222, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "full_name": "FreeMonoid.toList_symm", "start": [47, 1], "end": [47, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factors.lean", "full_name": "Nat.mem_factors", "start": [154, 1], "end": [156, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Subsemiring.coe_map", "start": [471, 1], "end": [472, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.mul_div_cancel_of_mod_eq_zero", "start": [400, 1], "end": [401, 57], "traced_tactics": [{"tactic": "have := mod_add_div a b", "annotated_tactic": ["have := <a>mod_add_div</a> a b", [{"full_name": "Int.mod_add_div", "def_path": ".lake/packages/std/Std/Data/Int/DivMod.lean", "def_pos": [176, 9], "def_end_pos": [176, 20]}]], "state_before": "a b : Int\nH : mod a b = 0\n\u22a2 b * div a b = a", "state_after": "a b : Int\nH : mod a b = 0\nthis : mod a b + b * div a b = a\n\u22a2 b * div a b = a"}, {"tactic": "rwa [H, Int.zero_add] at this", "annotated_tactic": ["rwa [H, <a>Int.zero_add</a>] at this", [{"full_name": "Int.zero_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [145, 27], "def_end_pos": [145, 35]}]], "state_before": "a b : Int\nH : mod a b = 0\nthis : mod a b + b * div a b = a\n\u22a2 b * div a b = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupIndep.lean", "full_name": "CompleteLattice.Independent.map_orderIso", "start": [456, 1], "end": [458, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "full_name": "AffineMap.id_linear", "start": [379, 1], "end": [380, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/FieldDivision.lean", "full_name": "Polynomial.degree_div_le", "start": [377, 1], "end": [380, 93], "traced_tactics": [{"tactic": "by_cases hq : q = 0", "annotated_tactic": ["by_cases hq : q = 0", []], "state_before": "R : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Field R\np\u271d q\u271d p q : R[X]\n\u22a2 degree (p / q) \u2264 degree p", "state_after": "case pos\nR : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Field R\np\u271d q\u271d p q : R[X]\nhq : q = 0\n\u22a2 degree (p / q) \u2264 degree p\n\ncase neg\nR : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Field R\np\u271d q\u271d p q : R[X]\nhq : \u00acq = 0\n\u22a2 degree (p / q) \u2264 degree p"}, {"tactic": "simp [hq]", "annotated_tactic": ["simp [hq]", []], "state_before": "case pos\nR : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Field R\np\u271d q\u271d p q : R[X]\nhq : q = 0\n\u22a2 degree (p / q) \u2264 degree p", "state_after": "no goals"}, {"tactic": "rw [div_def, mul_comm, degree_mul_leadingCoeff_inv _ hq]", "annotated_tactic": ["rw [<a>div_def</a>, <a>mul_comm</a>, <a>degree_mul_leadingCoeff_inv</a> _ hq]", [{"full_name": "Polynomial.div_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/FieldDivision.lean", "def_pos": [307, 9], "def_end_pos": [307, 16]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Polynomial.degree_mul_leadingCoeff_inv", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Lemmas.lean", "def_pos": [448, 9], "def_end_pos": [448, 36]}]], "state_before": "case neg\nR : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Field R\np\u271d q\u271d p q : R[X]\nhq : \u00acq = 0\n\u22a2 degree (p / q) \u2264 degree p", "state_after": "case neg\nR : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Field R\np\u271d q\u271d p q : R[X]\nhq : \u00acq = 0\n\u22a2 degree (p /\u2098 (q * C (leadingCoeff q)\u207b\u00b9)) \u2264 degree p"}, {"tactic": "exact degree_divByMonic_le _ _", "annotated_tactic": ["exact <a>degree_divByMonic_le</a> _ _", [{"full_name": "Polynomial.degree_divByMonic_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [295, 9], "def_end_pos": [295, 29]}]], "state_before": "case neg\nR : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Field R\np\u271d q\u271d p q : R[X]\nhq : \u00acq = 0\n\u22a2 degree (p /\u2098 (q * C (leadingCoeff q)\u207b\u00b9)) \u2264 degree p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "mul_lt_of_lt_one_of_lt", "start": [857, 1], "end": [863, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Minpoly/Field.lean", "full_name": "minpoly_algEquiv_toLinearMap", "start": [284, 1], "end": [299, 32], "traced_tactics": [{"tactic": "refine (minpoly.unique _ _ (monic_X_pow_sub_C _ h\u03c3.orderOf_pos.ne.symm) ?_ ?_).symm", "annotated_tactic": ["refine (<a>minpoly.unique</a> _ _ (<a>monic_X_pow_sub_C</a> _ h\u03c3.orderOf_pos.ne.symm) ?_ ?_).<a>symm</a>", [{"full_name": "minpoly.unique", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Field.lean", "def_pos": [53, 9], "def_end_pos": [53, 15]}, {"full_name": "Polynomial.monic_X_pow_sub_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [399, 9], "def_end_pos": [399, 26]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\n\u22a2 minpoly K (AlgEquiv.toLinearMap \u03c3) = X ^ orderOf \u03c3 - C 1", "state_after": "case refine_1\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\n\u22a2 (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) (X ^ orderOf \u03c3 - C 1) = 0\n\ncase refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\n\u22a2 \u2200 (q : K[X]), Monic q \u2192 (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) q = 0 \u2192 degree (X ^ orderOf \u03c3 - C 1) \u2264 degree q"}, {"tactic": "rw [(aeval \u03c3.toLinearMap).map_sub (X ^ orderOf \u03c3) (C (1 : K))]", "annotated_tactic": ["rw [(<a>aeval</a> \u03c3.toLinearMap).<a>map_sub</a> (<a>X</a> ^ <a>orderOf</a> \u03c3) (<a>C</a> (1 : K))]", [{"full_name": "Polynomial.aeval", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/AlgebraMap.lean", "def_pos": [171, 5], "def_end_pos": [171, 10]}, {"full_name": "AlgHom.map_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [481, 19], "def_end_pos": [481, 26]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "orderOf", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [154, 19], "def_end_pos": [154, 26]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}]], "state_before": "case refine_1\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\n\u22a2 (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) (X ^ orderOf \u03c3 - C 1) = 0", "state_after": "case refine_1\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\n\u22a2 (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) (X ^ orderOf \u03c3) - (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) (C 1) = 0"}, {"tactic": "simp [\u2190 AlgEquiv.pow_toLinearMap, pow_orderOf_eq_one]", "annotated_tactic": ["simp [\u2190 <a>AlgEquiv.pow_toLinearMap</a>, <a>pow_orderOf_eq_one</a>]", [{"full_name": "AlgEquiv.pow_toLinearMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Equiv.lean", "def_pos": [791, 7], "def_end_pos": [791, 22]}, {"full_name": "pow_orderOf_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [176, 9], "def_end_pos": [176, 27]}]], "state_before": "case refine_1\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\n\u22a2 (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) (X ^ orderOf \u03c3) - (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) (C 1) = 0", "state_after": "no goals"}, {"tactic": "intros q hq hs", "annotated_tactic": ["intros q hq hs", []], "state_before": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\n\u22a2 \u2200 (q : K[X]), Monic q \u2192 (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) q = 0 \u2192 degree (X ^ orderOf \u03c3 - C 1) \u2264 degree q", "state_after": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nhs : (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) q = 0\n\u22a2 degree (X ^ orderOf \u03c3 - C 1) \u2264 degree q"}, {"tactic": "rw [degree_eq_natDegree hq.ne_zero, degree_X_pow_sub_C h\u03c3.orderOf_pos, Nat.cast_le, \u2190 not_lt]", "annotated_tactic": ["rw [<a>degree_eq_natDegree</a> hq.ne_zero, <a>degree_X_pow_sub_C</a> h\u03c3.orderOf_pos, <a>Nat.cast_le</a>, \u2190 <a>not_lt</a>]", [{"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}, {"full_name": "Polynomial.degree_X_pow_sub_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1603, 9], "def_end_pos": [1603, 27]}, {"full_name": "Nat.cast_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Order.lean", "def_pos": [124, 9], "def_end_pos": [124, 16]}, {"full_name": "not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 15]}]], "state_before": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nhs : (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) q = 0\n\u22a2 degree (X ^ orderOf \u03c3 - C 1) \u2264 degree q", "state_after": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nhs : (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) q = 0\n\u22a2 \u00acnatDegree q < orderOf \u03c3"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nhs : (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) q = 0\n\u22a2 \u00acnatDegree q < orderOf \u03c3", "state_after": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nhs : (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) q = 0\nH : natDegree q < orderOf \u03c3\n\u22a2 False"}, {"tactic": "rw [aeval_eq_sum_range' H, \u2190 Fin.sum_univ_eq_sum_range] at hs", "annotated_tactic": ["rw [<a>aeval_eq_sum_range'</a> H, \u2190 <a>Fin.sum_univ_eq_sum_range</a>] at hs", [{"full_name": "Polynomial.aeval_eq_sum_range'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/AlgebraMap.lean", "def_pos": [402, 9], "def_end_pos": [402, 28]}, {"full_name": "Fin.sum_univ_eq_sum_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/BigOperators.lean", "def_pos": [157, 3], "def_end_pos": [157, 14]}]], "state_before": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nhs : (Polynomial.aeval (AlgEquiv.toLinearMap \u03c3)) q = 0\nH : natDegree q < orderOf \u03c3\n\u22a2 False", "state_after": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nhs : (Finset.sum Finset.univ fun i => coeff q \u2191i \u2022 AlgEquiv.toLinearMap \u03c3 ^ \u2191i) = 0\nH : natDegree q < orderOf \u03c3\n\u22a2 False"}, {"tactic": "simp_rw [\u2190 AlgEquiv.pow_toLinearMap] at hs", "annotated_tactic": ["simp_rw [\u2190 <a>AlgEquiv.pow_toLinearMap</a>] at hs", [{"full_name": "AlgEquiv.pow_toLinearMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Equiv.lean", "def_pos": [791, 7], "def_end_pos": [791, 22]}]], "state_before": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nhs : (Finset.sum Finset.univ fun i => coeff q \u2191i \u2022 AlgEquiv.toLinearMap \u03c3 ^ \u2191i) = 0\nH : natDegree q < orderOf \u03c3\n\u22a2 False", "state_after": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nH : natDegree q < orderOf \u03c3\nhs : (Finset.sum Finset.univ fun x => coeff q \u2191x \u2022 AlgEquiv.toLinearMap (\u03c3 ^ \u2191x)) = 0\n\u22a2 False"}, {"tactic": "apply hq.ne_zero", "annotated_tactic": ["apply hq.ne_zero", []], "state_before": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nH : natDegree q < orderOf \u03c3\nhs : (Finset.sum Finset.univ fun x => coeff q \u2191x \u2022 AlgEquiv.toLinearMap (\u03c3 ^ \u2191x)) = 0\n\u22a2 False", "state_after": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nH : natDegree q < orderOf \u03c3\nhs : (Finset.sum Finset.univ fun x => coeff q \u2191x \u2022 AlgEquiv.toLinearMap (\u03c3 ^ \u2191x)) = 0\n\u22a2 q = 0"}, {"tactic": "simpa using Fintype.linearIndependent_iff.mp\n  (((linearIndependent_algHom_toLinearMap' K L L).comp _ AlgEquiv.coe_algHom_injective).comp _\n    (Subtype.val_injective.comp ((finEquivPowers \u03c3 h\u03c3).injective)))\n  (q.coeff \u2218 (\u2191)) hs \u27e8_, H\u27e9", "annotated_tactic": ["simpa using Fintype.linearIndependent_iff.mp\n      (((<a>linearIndependent_algHom_toLinearMap'</a> K L L).<a>comp</a> _ <a>AlgEquiv.coe_algHom_injective</a>).<a>comp</a> _\n        (Subtype.val_injective.comp ((<a>finEquivPowers</a> \u03c3 h\u03c3).<a>injective</a>)))\n      (q.coeff \u2218 (\u2191)) hs \u27e8_, H\u27e9", [{"full_name": "linearIndependent_algHom_toLinearMap'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [1218, 7], "def_end_pos": [1218, 44]}, {"full_name": "LinearIndependent.comp", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [230, 9], "def_end_pos": [230, 31]}, {"full_name": "AlgEquiv.coe_algHom_injective", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Equiv.lean", "def_pos": [260, 9], "def_end_pos": [260, 29]}, {"full_name": "LinearIndependent.comp", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [230, 9], "def_end_pos": [230, 31]}, {"full_name": "finEquivPowers", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [611, 19], "def_end_pos": [611, 33]}, {"full_name": "Equiv.injective", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [200, 19], "def_end_pos": [200, 28]}]], "state_before": "case refine_2\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : CommRing L\ninst\u271d\u00b9 : IsDomain L\ninst\u271d : Algebra K L\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : IsOfFinOrder \u03c3\nq : K[X]\nhq : Monic q\nH : natDegree q < orderOf \u03c3\nhs : (Finset.sum Finset.univ fun x => coeff q \u2191x \u2022 AlgEquiv.toLinearMap (\u03c3 ^ \u2191x)) = 0\n\u22a2 q = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean", "full_name": "Nat.Ioc_filter_dvd_card_eq_div", "start": [978, 1], "end": [987, 78], "traced_tactics": [{"tactic": "induction' n with n IH", "annotated_tactic": ["induction' n with n IH", []], "state_before": "a b m n\u271d p\u271d n p : \u2115\n\u22a2 (Finset.filter (fun x => p \u2223 x) (Ioc 0 n)).card = n / p", "state_after": "case zero\na b m n p\u271d p : \u2115\n\u22a2 (Finset.filter (fun x => p \u2223 x) (Ioc 0 zero)).card = zero / p\n\ncase succ\na b m n\u271d p\u271d p n : \u2115\nIH : (Finset.filter (fun x => p \u2223 x) (Ioc 0 n)).card = n / p\n\u22a2 (Finset.filter (fun x => p \u2223 x) (Ioc 0 (succ n))).card = succ n / p"}, {"tactic": "simp [Nat.succ_div, add_ite, add_zero, h1, filter_insert, apply_ite card, card_insert_eq_ite, IH,\n  Finset.mem_filter, mem_Ioc, not_le.2 (lt_add_one n), Nat.succ_eq_add_one]", "annotated_tactic": ["simp [<a>Nat.succ_div</a>, <a>add_ite</a>, <a>add_zero</a>, h1, <a>filter_insert</a>, <a>apply_ite</a> <a>card</a>, <a>card_insert_eq_ite</a>, IH,\n    <a>Finset.mem_filter</a>, <a>mem_Ioc</a>, <a>not_le</a>.2 (<a>lt_add_one</a> n), <a>Nat.succ_eq_add_one</a>]", [{"full_name": "Nat.succ_div", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Order/Lemmas.lean", "def_pos": [124, 9], "def_end_pos": [124, 17]}, {"full_name": "add_ite", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [196, 3], "def_end_pos": [196, 14]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "Finset.filter_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2985, 9], "def_end_pos": [2985, 22]}, {"full_name": "apply_ite", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [36, 9], "def_end_pos": [36, 18]}, {"full_name": "Finset.card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [39, 15], "def_end_pos": [39, 19]}, {"full_name": "Finset.card_insert_eq_ite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [142, 9], "def_end_pos": [142, 27]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "Finset.mem_Ioc", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [337, 9], "def_end_pos": [337, 16]}, {"full_name": "not_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [367, 9], "def_end_pos": [367, 15]}, {"full_name": "lt_add_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [20, 7], "def_end_pos": [20, 17]}, {"full_name": "Nat.succ_eq_add_one", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 24]}]], "state_before": "case succ\na b m n\u271d p\u271d p n : \u2115\nIH : (Finset.filter (fun x => p \u2223 x) (Ioc 0 n)).card = n / p\nh1 : Ioc 0 (succ n) = insert (succ n) (Ioc 0 n)\n\u22a2 (Finset.filter (fun x => p \u2223 x) (Ioc 0 (succ n))).card = succ n / p", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\na b m n p\u271d p : \u2115\n\u22a2 (Finset.filter (fun x => p \u2223 x) (Ioc 0 zero)).card = zero / p", "state_after": "no goals"}, {"tactic": "rcases n.eq_zero_or_pos with (rfl | hn)", "annotated_tactic": ["rcases n.eq_zero_or_pos with (rfl | hn)", []], "state_before": "a b m n\u271d p\u271d p n : \u2115\nIH : (Finset.filter (fun x => p \u2223 x) (Ioc 0 n)).card = n / p\n\u22a2 Ioc 0 (succ n) = insert (succ n) (Ioc 0 n)", "state_after": "case inl\na b m n p\u271d p : \u2115\nIH : (Finset.filter (fun x => p \u2223 x) (Ioc 0 0)).card = 0 / p\n\u22a2 Ioc 0 (succ 0) = insert (succ 0) (Ioc 0 0)\n\ncase inr\na b m n\u271d p\u271d p n : \u2115\nIH : (Finset.filter (fun x => p \u2223 x) (Ioc 0 n)).card = n / p\nhn : n > 0\n\u22a2 Ioc 0 (succ n) = insert (succ n) (Ioc 0 n)"}, {"tactic": "simp_rw [\u2190 Ico_succ_succ, Ico_insert_right (succ_le_succ hn.le), Ico_succ_right]", "annotated_tactic": ["simp_rw [\u2190 <a>Ico_succ_succ</a>, <a>Ico_insert_right</a> (<a>succ_le_succ</a> hn.le), <a>Ico_succ_right</a>]", [{"full_name": "Nat.Ico_succ_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Interval.lean", "def_pos": [195, 9], "def_end_pos": [195, 22]}, {"full_name": "Finset.Ico_insert_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/LocallyFinite/Basic.lean", "def_pos": [575, 9], "def_end_pos": [575, 25]}, {"full_name": "Nat.succ_le_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1648, 9], "def_end_pos": [1648, 25]}, {"full_name": "Nat.Ico_succ_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Interval.lean", "def_pos": [180, 9], "def_end_pos": [180, 23]}]], "state_before": "case inr\na b m n\u271d p\u271d p n : \u2115\nIH : (Finset.filter (fun x => p \u2223 x) (Ioc 0 n)).card = n / p\nhn : n > 0\n\u22a2 Ioc 0 (succ n) = insert (succ n) (Ioc 0 n)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inl\na b m n p\u271d p : \u2115\nIH : (Finset.filter (fun x => p \u2223 x) (Ioc 0 0)).card = 0 / p\n\u22a2 Ioc 0 (succ 0) = insert (succ 0) (Ioc 0 0)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.rotate_cons_succ", "start": [116, 1], "end": [118, 63], "traced_tactics": [{"tactic": "rw [rotate_eq_rotate', rotate_eq_rotate', rotate'_cons_succ]", "annotated_tactic": ["rw [<a>rotate_eq_rotate'</a>, <a>rotate_eq_rotate'</a>, <a>rotate'_cons_succ</a>]", [{"full_name": "List.rotate_eq_rotate'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [108, 9], "def_end_pos": [108, 26]}, {"full_name": "List.rotate_eq_rotate'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [108, 9], "def_end_pos": [108, 26]}, {"full_name": "List.rotate'_cons_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [54, 9], "def_end_pos": [54, 26]}]], "state_before": "\u03b1 : Type u\nl : List \u03b1\na : \u03b1\nn : \u2115\n\u22a2 rotate (a :: l) (succ n) = rotate (l ++ [a]) n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearEquiv.eq_bot_of_equiv", "start": [808, 1], "end": [811, 43], "traced_tactics": [{"tactic": "refine' bot_unique (SetLike.le_def.2 fun b hb => (Submodule.mem_bot R).2 _)", "annotated_tactic": ["refine' <a>bot_unique</a> (<a>SetLike.le_def</a>.2 fun b hb => (<a>Submodule.mem_bot</a> R).2 _)", [{"full_name": "bot_unique", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [327, 9], "def_end_pos": [327, 19]}, {"full_name": "SetLike.le_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 15]}, {"full_name": "Submodule.mem_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [72, 9], "def_end_pos": [72, 16]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring R\u2082\ninst\u271d\u2077 : Semiring R\u2083\ninst\u271d\u2076 : Semiring R\u2084\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2083\ninst\u271d\u00b2 : AddCommMonoid M\u2084\nmodule_M : Module R M\nmodule_M\u2082 : Module R\u2082 M\u2082\nmodule_M\u2083 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\nre\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\nre\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nre\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\nre\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\nf : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M\ne\u271d : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\nh : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ne'' : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083\np q : Submodule R M\ninst\u271d : Module R\u2082 M\u2082\ne : \u21a5p \u2243\u209b\u2097[\u03c3\u2081\u2082] \u21a5\u22a5\n\u22a2 p = \u22a5", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring R\u2082\ninst\u271d\u2077 : Semiring R\u2083\ninst\u271d\u2076 : Semiring R\u2084\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2083\ninst\u271d\u00b2 : AddCommMonoid M\u2084\nmodule_M : Module R M\nmodule_M\u2082 : Module R\u2082 M\u2082\nmodule_M\u2083 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\nre\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\nre\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nre\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\nre\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\nf : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M\ne\u271d : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\nh : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ne'' : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083\np q : Submodule R M\ninst\u271d : Module R\u2082 M\u2082\ne : \u21a5p \u2243\u209b\u2097[\u03c3\u2081\u2082] \u21a5\u22a5\nb : M\nhb : b \u2208 p\n\u22a2 b = 0"}, {"tactic": "rw [\u2190 p.mk_eq_zero hb, \u2190 e.map_eq_zero_iff]", "annotated_tactic": ["rw [\u2190 p.mk_eq_zero hb, \u2190 e.map_eq_zero_iff]", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring R\u2082\ninst\u271d\u2077 : Semiring R\u2083\ninst\u271d\u2076 : Semiring R\u2084\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2083\ninst\u271d\u00b2 : AddCommMonoid M\u2084\nmodule_M : Module R M\nmodule_M\u2082 : Module R\u2082 M\u2082\nmodule_M\u2083 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\nre\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\nre\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nre\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\nre\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\nf : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M\ne\u271d : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\nh : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ne'' : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083\np q : Submodule R M\ninst\u271d : Module R\u2082 M\u2082\ne : \u21a5p \u2243\u209b\u2097[\u03c3\u2081\u2082] \u21a5\u22a5\nb : M\nhb : b \u2208 p\n\u22a2 b = 0", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring R\u2082\ninst\u271d\u2077 : Semiring R\u2083\ninst\u271d\u2076 : Semiring R\u2084\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2083\ninst\u271d\u00b2 : AddCommMonoid M\u2084\nmodule_M : Module R M\nmodule_M\u2082 : Module R\u2082 M\u2082\nmodule_M\u2083 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\nre\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\nre\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nre\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\nre\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\nf : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M\ne\u271d : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\nh : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ne'' : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083\np q : Submodule R M\ninst\u271d : Module R\u2082 M\u2082\ne : \u21a5p \u2243\u209b\u2097[\u03c3\u2081\u2082] \u21a5\u22a5\nb : M\nhb : b \u2208 p\n\u22a2 e { val := b, property := hb } = 0"}, {"tactic": "apply Submodule.eq_zero_of_bot_submodule", "annotated_tactic": ["apply <a>Submodule.eq_zero_of_bot_submodule</a>", [{"full_name": "Submodule.eq_zero_of_bot_submodule", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [426, 9], "def_end_pos": [426, 33]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring R\u2082\ninst\u271d\u2077 : Semiring R\u2083\ninst\u271d\u2076 : Semiring R\u2084\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2083\ninst\u271d\u00b2 : AddCommMonoid M\u2084\nmodule_M : Module R M\nmodule_M\u2082 : Module R\u2082 M\u2082\nmodule_M\u2083 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\nre\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\nre\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nre\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\nre\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\nf : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M\ne\u271d : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\nh : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ne'' : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083\np q : Submodule R M\ninst\u271d : Module R\u2082 M\u2082\ne : \u21a5p \u2243\u209b\u2097[\u03c3\u2081\u2082] \u21a5\u22a5\nb : M\nhb : b \u2208 p\n\u22a2 e { val := b, property := hb } = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Types.lean", "full_name": "equivEquivIso_inv", "start": [427, 1], "end": [428, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/Basic.lean", "full_name": "star_pow", "start": [213, 1], "end": [215, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Set.toFinset_compl", "start": [759, 1], "end": [761, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Set \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u2191s\ninst\u271d\u00b2 : Fintype \u2191t\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u2191s\u1d9c\n\u22a2 toFinset s\u1d9c = (toFinset s)\u1d9c", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Set \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u2191s\ninst\u271d\u00b2 : Fintype \u2191t\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u2191s\u1d9c\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 toFinset s\u1d9c \u2194 a\u271d \u2208 (toFinset s)\u1d9c"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Set \u03b1\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u2191s\ninst\u271d\u00b2 : Fintype \u2191t\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u2191s\u1d9c\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 toFinset s\u1d9c \u2194 a\u271d \u2208 (toFinset s)\u1d9c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "full_name": "tsum_eq_zero_iff", "start": [210, 1], "end": [211, 40], "traced_tactics": [{"tactic": "rw [\u2190 hasSum_zero_iff, hf.hasSum_iff]", "annotated_tactic": ["rw [\u2190 <a>hasSum_zero_iff</a>, hf.hasSum_iff]", [{"full_name": "hasSum_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "def_pos": [206, 9], "def_end_pos": [206, 24]}]], "state_before": "\u03b9 : Type u_1\n\u03ba : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b2 : CanonicallyOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\nhf : Summable f\n\u22a2 \u2211' (i : \u03b9), f i = 0 \u2194 \u2200 (x : \u03b9), f x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Operations.lean", "full_name": "ENNReal.add_lt_add", "start": [303, 11], "end": [309, 25], "traced_tactics": [{"tactic": "lift a to \u211d\u22650 using ac.ne_top", "annotated_tactic": ["lift a to \u211d\u22650 using ac.ne_top", []], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nac : a < c\nbd : b < d\n\u22a2 a + b < c + d", "state_after": "case intro\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nbd : b < d\na : \u211d\u22650\nac : \u2191a < c\n\u22a2 \u2191a + b < c + d"}, {"tactic": "lift b to \u211d\u22650 using bd.ne_top", "annotated_tactic": ["lift b to \u211d\u22650 using bd.ne_top", []], "state_before": "case intro\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nbd : b < d\na : \u211d\u22650\nac : \u2191a < c\n\u22a2 \u2191a + b < c + d", "state_after": "case intro.intro\nc d : \u211d\u22650\u221e\nr p q a : \u211d\u22650\nac : \u2191a < c\nb : \u211d\u22650\nbd : \u2191b < d\n\u22a2 \u2191a + \u2191b < c + d"}, {"tactic": "cases c", "annotated_tactic": ["cases c", []], "state_before": "case intro.intro\nc d : \u211d\u22650\u221e\nr p q a : \u211d\u22650\nac : \u2191a < c\nb : \u211d\u22650\nbd : \u2191b < d\n\u22a2 \u2191a + \u2191b < c + d", "state_after": "case intro.intro.none\nd : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\nbd : \u2191b < d\nac : \u2191a < none\n\u22a2 \u2191a + \u2191b < none + d\n\ncase intro.intro.some\nd : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\nbd : \u2191b < d\nval\u271d : \u211d\u22650\nac : \u2191a < some val\u271d\n\u22a2 \u2191a + \u2191b < some val\u271d + d"}, {"tactic": "cases d", "annotated_tactic": ["cases d", []], "state_before": "case intro.intro.some\nd : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\nbd : \u2191b < d\nval\u271d : \u211d\u22650\nac : \u2191a < some val\u271d\n\u22a2 \u2191a + \u2191b < some val\u271d + d", "state_after": "case intro.intro.some.none\nr p q a b val\u271d : \u211d\u22650\nac : \u2191a < some val\u271d\nbd : \u2191b < none\n\u22a2 \u2191a + \u2191b < some val\u271d + none\n\ncase intro.intro.some.some\nr p q a b val\u271d\u00b9 : \u211d\u22650\nac : \u2191a < some val\u271d\u00b9\nval\u271d : \u211d\u22650\nbd : \u2191b < some val\u271d\n\u22a2 \u2191a + \u2191b < some val\u271d\u00b9 + some val\u271d"}, {"tactic": "simp only [\u2190 coe_add, some_eq_coe, coe_lt_coe] at *", "annotated_tactic": ["simp only [\u2190 <a>coe_add</a>, <a>some_eq_coe</a>, <a>coe_lt_coe</a>] at *", [{"full_name": "ENNReal.coe_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [415, 26], "def_end_pos": [415, 33]}, {"full_name": "ENNReal.some_eq_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [174, 17], "def_end_pos": [174, 28]}, {"full_name": "ENNReal.coe_lt_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [379, 28], "def_end_pos": [379, 38]}]], "state_before": "case intro.intro.some.some\nr p q a b val\u271d\u00b9 : \u211d\u22650\nac : \u2191a < some val\u271d\u00b9\nval\u271d : \u211d\u22650\nbd : \u2191b < some val\u271d\n\u22a2 \u2191a + \u2191b < some val\u271d\u00b9 + some val\u271d", "state_after": "case intro.intro.some.some\nr p q a b val\u271d\u00b9 val\u271d : \u211d\u22650\nac : a < val\u271d\u00b9\nbd : b < val\u271d\n\u22a2 a + b < val\u271d\u00b9 + val\u271d"}, {"tactic": "exact add_lt_add ac bd", "annotated_tactic": ["exact <a>add_lt_add</a> ac bd", [{"full_name": "add_lt_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [167, 7], "def_end_pos": [167, 17]}]], "state_before": "case intro.intro.some.some\nr p q a b val\u271d\u00b9 val\u271d : \u211d\u22650\nac : a < val\u271d\u00b9\nbd : b < val\u271d\n\u22a2 a + b < val\u271d\u00b9 + val\u271d", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case intro.intro.none\nd : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\nbd : \u2191b < d\nac : \u2191a < none\n\u22a2 \u2191a + \u2191b < none + d", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case intro.intro.some.none\nr p q a b val\u271d : \u211d\u22650\nac : \u2191a < some val\u271d\nbd : \u2191b < none\n\u22a2 \u2191a + \u2191b < some val\u271d + none", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Adjoin/Basic.lean", "full_name": "Algebra.adjoin_union", "start": [143, 1], "end": [144, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Encodable/Basic.lean", "full_name": "Directed.rel_sequence", "start": [648, 1], "end": [651, 43], "traced_tactics": [{"tactic": "simp only [Directed.sequence, add_eq, add_zero, encodek, and_self]", "annotated_tactic": ["simp only [<a>Directed.sequence</a>, <a>add_eq</a>, <a>add_zero</a>, <a>encodek</a>, <a>and_self</a>]", [{"full_name": "Directed.sequence", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Encodable/Basic.lean", "def_pos": [630, 29], "def_end_pos": [630, 37]}, {"full_name": "Nat.add_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [84, 17], "def_end_pos": [84, 23]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "Encodable.encodek", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Encodable/Basic.lean", "def_pos": [53, 3], "def_end_pos": [53, 10]}, {"full_name": "and_self", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [105, 17], "def_end_pos": [105, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Encodable \u03b1\ninst\u271d : Inhabited \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nhf : Directed r f\na : \u03b1\n\u22a2 r (f a) (f (Directed.sequence f hf (encode a + 1)))", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Encodable \u03b1\ninst\u271d : Inhabited \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nhf : Directed r f\na : \u03b1\n\u22a2 r (f a) (f (Classical.choose \u22ef))"}, {"tactic": "exact (Classical.choose_spec (hf _ a)).2", "annotated_tactic": ["exact (<a>Classical.choose_spec</a> (hf _ a)).2", [{"full_name": "Classical.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [21, 9], "def_end_pos": [21, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Encodable \u03b1\ninst\u271d : Inhabited \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nhf : Directed r f\na : \u03b1\n\u22a2 r (f a) (f (Classical.choose \u22ef))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.map_fst_zip", "start": [338, 1], "end": [345, 35], "traced_tactics": [{"tactic": "simp [Nat.succ_le_succ_iff] at h", "annotated_tactic": ["simp [<a>Nat.succ_le_succ_iff</a>] at h", [{"full_name": "Nat.succ_le_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [104, 9], "def_end_pos": [104, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nhead\u271d\u00b9 : \u03b1\nas : List \u03b1\nhead\u271d : \u03b2\nbs : List \u03b2\nh : length (head\u271d\u00b9 :: as) \u2264 length (head\u271d :: bs)\n\u22a2 map Prod.fst (zip (head\u271d\u00b9 :: as) (head\u271d :: bs)) = head\u271d\u00b9 :: as", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nhead\u271d\u00b9 : \u03b1\nas : List \u03b1\nhead\u271d : \u03b2\nbs : List \u03b2\nh : length as \u2264 length bs\n\u22a2 map Prod.fst (zip (head\u271d\u00b9 :: as) (head\u271d :: bs)) = head\u271d\u00b9 :: as"}, {"tactic": "show _ :: map Prod.fst (zip as bs) = _ :: as", "annotated_tactic": ["show _ :: <a>map</a> <a>Prod.fst</a> (<a>zip</a> as bs) = _ :: as", [{"full_name": "List.map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [191, 19], "def_end_pos": [191, 22]}, {"full_name": "Prod.fst", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [481, 3], "def_end_pos": [481, 6]}, {"full_name": "List.zip", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [603, 5], "def_end_pos": [603, 8]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nhead\u271d\u00b9 : \u03b1\nas : List \u03b1\nhead\u271d : \u03b2\nbs : List \u03b2\nh : length as \u2264 length bs\n\u22a2 map Prod.fst (zip (head\u271d\u00b9 :: as) (head\u271d :: bs)) = head\u271d\u00b9 :: as", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nhead\u271d\u00b9 : \u03b1\nas : List \u03b1\nhead\u271d : \u03b2\nbs : List \u03b2\nh : length as \u2264 length bs\n\u22a2 (head\u271d\u00b9, head\u271d).fst :: map Prod.fst (zip as bs) = head\u271d\u00b9 :: as"}, {"tactic": "rw [map_fst_zip as bs h]", "annotated_tactic": ["rw [map_fst_zip as bs h]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nhead\u271d\u00b9 : \u03b1\nas : List \u03b1\nhead\u271d : \u03b2\nbs : List \u03b2\nh : length as \u2264 length bs\n\u22a2 (head\u271d\u00b9, head\u271d).fst :: map Prod.fst (zip as bs) = head\u271d\u00b9 :: as", "state_after": "no goals"}, {"tactic": "simp at h", "annotated_tactic": ["simp at h", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\nas : List \u03b1\nh : length (a :: as) \u2264 length []\n\u22a2 map Prod.fst (zip (a :: as) []) = a :: as", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.subset_biUnion_of_mem", "start": [842, 1], "end": [845, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Nat/Gcd.lean", "full_name": "Nat.Coprime.pow_right", "start": [352, 1], "end": [353, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/BigOperators.lean", "full_name": "Mathlib.Meta.List.range_zero'", "start": [100, 1], "end": [101, 72], "traced_tactics": [{"tactic": "rw [pn.out, Nat.cast_zero, List.range_zero]", "annotated_tactic": ["rw [pn.out, <a>Nat.cast_zero</a>, <a>List.range_zero</a>]", [{"full_name": "Nat.cast_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [123, 9], "def_end_pos": [123, 18]}, {"full_name": "List.range_zero", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2228, 17], "def_end_pos": [2228, 27]}]], "state_before": "n : \u2115\npn : NormNum.IsNat n 0\n\u22a2 List.range n = []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/StdBasis.lean", "full_name": "LinearMap.stdBasis_ne", "start": [71, 1], "end": [72, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "full_name": "Multiset.prod_map_neg", "start": [204, 1], "end": [206, 35], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b1\ns\u271d t : Multiset \u03b1\na : \u03b1\nm : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\ninst\u271d : HasDistribNeg \u03b1\ns : Multiset \u03b1\n\u22a2 \u2200 (a : List \u03b1), prod (map Neg.neg \u27e6a\u27e7) = (-1) ^ card \u27e6a\u27e7 * prod \u27e6a\u27e7", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean", "full_name": "MeasureTheory.ae_iff_prob_eq_one", "start": [301, 1], "end": [302, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iSup_range", "start": [1345, 1], "end": [1346, 37], "traced_tactics": [{"tactic": "rw [\u2190 iSup_subtype'', iSup_range']", "annotated_tactic": ["rw [\u2190 <a>iSup_subtype''</a>, <a>iSup_range'</a>]", [{"full_name": "iSup_subtype''", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1163, 9], "def_end_pos": [1163, 23]}, {"full_name": "iSup_range'", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [623, 9], "def_end_pos": [623, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g\u271d s t : \u03b9 \u2192 \u03b1\na b : \u03b1\ng : \u03b2 \u2192 \u03b1\nf : \u03b9 \u2192 \u03b2\n\u22a2 \u2a06 b \u2208 range f, g b = \u2a06 i, g (f i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.mem_image_elim_on", "start": [245, 1], "end": [246, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NoncommProd.lean", "full_name": "Finset.noncommProd_singleton", "start": [345, 1], "end": [350, 23], "traced_tactics": [{"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : Monoid \u03b3\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Set.Pairwise \u2191{a} fun a b => Commute (f a) (f b)", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : Monoid \u03b3\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Set.Pairwise {a} fun a b => Commute (f a) (f b)"}, {"tactic": "exact Set.pairwise_singleton _ _", "annotated_tactic": ["exact <a>Set.pairwise_singleton</a> _ _", [{"full_name": "Set.pairwise_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pairwise/Basic.lean", "def_pos": [89, 9], "def_end_pos": [89, 27]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : Monoid \u03b3\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Set.Pairwise {a} fun a b => Commute (f a) (f b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLatticeIntervals.lean", "full_name": "subset_sSup_of_within", "start": [57, 1], "end": [59, 81], "traced_tactics": [{"tactic": "simp [dif_pos, h, h', h'']", "annotated_tactic": ["simp [<a>dif_pos</a>, h, h', h'']", [{"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\ns : Set \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SupSet \u03b1\ninst\u271d : Inhabited \u2191s\nt : Set \u2191s\nh' : Set.Nonempty t\nh'' : BddAbove t\nh : sSup (Subtype.val '' t) \u2208 s\n\u22a2 sSup (Subtype.val '' t) = \u2191(sSup t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_dvd_prod_of_subset", "start": [1972, 1], "end": [1974, 66], "traced_tactics": [{"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "\u03b9\u271d : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommMonoid \u03b2\n\u03b9 : Type u_2\nM : Type u_3\ninst\u271d : CommMonoid M\ns t : Finset \u03b9\nf : \u03b9 \u2192 M\nh : s \u2286 t\n\u22a2 s.val \u2264 t.val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Seminorm.lean", "full_name": "GroupNorm.coe_lt_coe", "start": [810, 1], "end": [811, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "div_lt_iff", "start": [170, 1], "end": [171, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "add_le_mul_two_add", "start": [267, 1], "end": [271, 59], "traced_tactics": [{"tactic": "rw [mul_add, mul_two, add_assoc]", "annotated_tactic": ["rw [<a>mul_add</a>, <a>mul_two</a>, <a>add_assoc</a>]", [{"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "mul_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [190, 9], "def_end_pos": [190, 16]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\na b c d : \u03b1\na2 : 2 \u2264 a\nb0 : 0 \u2264 b\n\u22a2 a + (a + a * b) \u2264 a * (2 + b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Digits.lean", "full_name": "Nat.NormDigits.digits_one", "start": [839, 1], "end": [844, 75], "traced_tactics": [{"tactic": "have b2 : 1 < b :=\n  lt_iff_add_one_le.mpr (le_trans (add_le_add_right (lt_iff_add_one_le.mp n0) 1) nb)", "annotated_tactic": ["have b2 : 1 < b :=\n    lt_iff_add_one_le.mpr (<a>le_trans</a> (<a>add_le_add_right</a> (lt_iff_add_one_le.mp n0) 1) nb)", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "add_le_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [66, 32], "def_end_pos": [66, 48]}]], "state_before": "n\u271d b n : \u2115\nn0 : 0 < n\nnb : n < b\n\u22a2 digits b n = [n] \u2227 1 < b \u2227 0 < n", "state_after": "n\u271d b n : \u2115\nn0 : 0 < n\nnb : n < b\nb2 : 1 < b\n\u22a2 digits b n = [n] \u2227 1 < b \u2227 0 < n"}, {"tactic": "refine' \u27e8_, b2, n0\u27e9", "annotated_tactic": ["refine' \u27e8_, b2, n0\u27e9", []], "state_before": "n\u271d b n : \u2115\nn0 : 0 < n\nnb : n < b\nb2 : 1 < b\n\u22a2 digits b n = [n] \u2227 1 < b \u2227 0 < n", "state_after": "n\u271d b n : \u2115\nn0 : 0 < n\nnb : n < b\nb2 : 1 < b\n\u22a2 digits b n = [n]"}, {"tactic": "rw [Nat.digits_def' b2 n0, Nat.mod_eq_of_lt nb,\n  (Nat.div_eq_zero_iff ((zero_le n).trans_lt nb)).2 nb, Nat.digits_zero]", "annotated_tactic": ["rw [<a>Nat.digits_def'</a> b2 n0, <a>Nat.mod_eq_of_lt</a> nb,\n    (<a>Nat.div_eq_zero_iff</a> ((<a>zero_le</a> n).<a>trans_lt</a> nb)).2 nb, <a>Nat.digits_zero</a>]", [{"full_name": "Nat.digits_def'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [132, 9], "def_end_pos": [132, 20]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}, {"full_name": "Nat.div_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Order/Lemmas.lean", "def_pos": [80, 19], "def_end_pos": [80, 34]}, {"full_name": "Nat.zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1644, 9], "def_end_pos": [1644, 20]}, {"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}, {"full_name": "Nat.digits_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}]], "state_before": "n\u271d b n : \u2115\nn0 : 0 < n\nnb : n < b\nb2 : 1 < b\n\u22a2 digits b n = [n]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Bounded.lean", "full_name": "tendsto_dist_left_cocompact_atTop", "start": [599, 1], "end": [601, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/EventuallyConst.lean", "full_name": "Filter.HasBasis.eventuallyConst_iff'", "start": [37, 1], "end": [41, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Hom.lean", "full_name": "NormedAddGroupHom.norm_comp_le_of_le'", "start": [662, 1], "end": [665, 33], "traced_tactics": [{"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "V : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf g\u271d : NormedAddGroupHom V\u2081 V\u2082\ng : NormedAddGroupHom V\u2082 V\u2083\nC\u2081 C\u2082 C\u2083 : \u211d\nh : C\u2083 = C\u2082 * C\u2081\nhg : \u2016g\u2016 \u2264 C\u2082\nhf : \u2016f\u2016 \u2264 C\u2081\n\u22a2 \u2016NormedAddGroupHom.comp g f\u2016 \u2264 C\u2083", "state_after": "V : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf g\u271d : NormedAddGroupHom V\u2081 V\u2082\ng : NormedAddGroupHom V\u2082 V\u2083\nC\u2081 C\u2082 C\u2083 : \u211d\nh : C\u2083 = C\u2082 * C\u2081\nhg : \u2016g\u2016 \u2264 C\u2082\nhf : \u2016f\u2016 \u2264 C\u2081\n\u22a2 \u2016NormedAddGroupHom.comp g f\u2016 \u2264 C\u2082 * C\u2081"}, {"tactic": "exact norm_comp_le_of_le hg hf", "annotated_tactic": ["exact <a>norm_comp_le_of_le</a> hg hf", [{"full_name": "NormedAddGroupHom.norm_comp_le_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Hom.lean", "def_pos": [657, 9], "def_end_pos": [657, 27]}]], "state_before": "V : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf g\u271d : NormedAddGroupHom V\u2081 V\u2082\ng : NormedAddGroupHom V\u2082 V\u2083\nC\u2081 C\u2082 C\u2083 : \u211d\nh : C\u2083 = C\u2082 * C\u2081\nhg : \u2016g\u2016 \u2264 C\u2082\nhf : \u2016f\u2016 \u2264 C\u2081\n\u22a2 \u2016NormedAddGroupHom.comp g f\u2016 \u2264 C\u2082 * C\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "eventually_abs_sub_lt", "start": [1115, 1], "end": [1117, 94], "traced_tactics": [{"tactic": "simp only [abs_sub_comm, mem_principal_self]", "annotated_tactic": ["simp only [<a>abs_sub_comm</a>, <a>mem_principal_self</a>]", [{"full_name": "abs_sub_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [89, 3], "def_end_pos": [89, 14]}, {"full_name": "Filter.mem_principal_self", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [311, 9], "def_end_pos": [311, 27]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : OrderTopology \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\na \u03b5 : \u03b1\nh\u03b5 : 0 < \u03b5\n\u22a2 {x | (fun x => |x - a| < \u03b5) x} \u2208 \ud835\udcdf {b | |a - b| < \u03b5}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "t2Space_iff_disjoint_nhds", "start": [1221, 1], "end": [1224, 40], "traced_tactics": [{"tactic": "refine (t2Space_iff X).trans (forall\u2083_congr fun x y _ => ?_)", "annotated_tactic": ["refine (<a>t2Space_iff</a> X).<a>trans</a> (<a>forall\u2083_congr</a> fun x y _ => ?_)", [{"full_name": "t2Space_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [1208, 3], "def_end_pos": [1208, 9]}, {"full_name": "Iff.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [798, 9], "def_end_pos": [798, 18]}, {"full_name": "forall\u2083_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [157, 9], "def_end_pos": [157, 22]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\n\u22a2 T2Space X \u2194 Pairwise fun x y => Disjoint (\ud835\udcdd x) (\ud835\udcdd y)", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nx y : X\nx\u271d : x \u2260 y\n\u22a2 (fun x y => \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 Disjoint u v) x y \u2194 (fun x y => Disjoint (\ud835\udcdd x) (\ud835\udcdd y)) x y"}, {"tactic": "simp only [(nhds_basis_opens x).disjoint_iff (nhds_basis_opens y), exists_prop, \u2190 exists_and_left,\n  and_assoc, and_comm, and_left_comm]", "annotated_tactic": ["simp only [(<a>nhds_basis_opens</a> x).<a>disjoint_iff</a> (<a>nhds_basis_opens</a> y), <a>exists_prop</a>, \u2190 <a>exists_and_left</a>,\n    <a>and_assoc</a>, <a>and_comm</a>, <a>and_left_comm</a>]", [{"full_name": "nhds_basis_opens", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [791, 9], "def_end_pos": [791, 25]}, {"full_name": "Filter.HasBasis.disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [660, 9], "def_end_pos": [660, 30]}, {"full_name": "nhds_basis_opens", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [791, 9], "def_end_pos": [791, 25]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "exists_and_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [221, 17], "def_end_pos": [221, 32]}, {"full_name": "and_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [136, 9], "def_end_pos": [136, 18]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}, {"full_name": "and_left_comm", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [41, 9], "def_end_pos": [41, 22]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nx y : X\nx\u271d : x \u2260 y\n\u22a2 (fun x y => \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 Disjoint u v) x y \u2194 (fun x y => Disjoint (\ud835\udcdd x) (\ud835\udcdd y)) x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/DenseEmbedding.lean", "full_name": "Filter.HasBasis.hasBasis_of_denseInducing", "start": [364, 1], "end": [382, 38], "traced_tactics": [{"tactic": "rw [Filter.hasBasis_iff] at h \u22a2", "annotated_tactic": ["rw [<a>Filter.hasBasis_iff</a>] at h \u22a2", [{"full_name": "Filter.hasBasis_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [274, 9], "def_end_pos": [274, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : HasBasis (\ud835\udcdd x) p s\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\n\u22a2 HasBasis (\ud835\udcdd (f x)) p fun i => closure (f '' s i)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\n\u22a2 \u2200 (t : Set \u03b2), t \u2208 \ud835\udcdd (f x) \u2194 \u2203 i, p i \u2227 closure (f '' s i) \u2286 t"}, {"tactic": "intro T", "annotated_tactic": ["intro T", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\n\u22a2 \u2200 (t : Set \u03b2), t \u2208 \ud835\udcdd (f x) \u2194 \u2203 i, p i \u2227 closure (f '' s i) \u2286 t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\n\u22a2 T \u2208 \ud835\udcdd (f x) \u2194 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T"}, {"tactic": "refine' \u27e8fun hT => _, fun hT => _\u27e9", "annotated_tactic": ["refine' \u27e8fun hT => _, fun hT => _\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\n\u22a2 T \u2208 \ud835\udcdd (f x) \u2194 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\n\u22a2 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T\n\ncase refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : \u2203 i, p i \u2227 closure (f '' s i) \u2286 T\n\u22a2 T \u2208 \ud835\udcdd (f x)"}, {"tactic": "obtain \u27e8T', hT\u2081, hT\u2082, hT\u2083\u27e9 := exists_mem_nhds_isClosed_subset hT", "annotated_tactic": ["obtain \u27e8T', hT\u2081, hT\u2082, hT\u2083\u27e9 := <a>exists_mem_nhds_isClosed_subset</a> hT", [{"full_name": "exists_mem_nhds_isClosed_subset", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [1865, 9], "def_end_pos": [1865, 40]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\n\u22a2 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T", "state_after": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\nT' : Set \u03b2\nhT\u2081 : T' \u2208 \ud835\udcdd (f x)\nhT\u2082 : IsClosed T'\nhT\u2083 : T' \u2286 T\n\u22a2 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T"}, {"tactic": "have hT\u2084 : f \u207b\u00b9' T' \u2208 \ud835\udcdd x := by\n  rw [hf.toInducing.nhds_eq_comap x]\n  exact \u27e8T', hT\u2081, Subset.rfl\u27e9", "annotated_tactic": ["have hT\u2084 : f \u207b\u00b9' T' \u2208 \ud835\udcdd x := by\n      rw [hf.toInducing.nhds_eq_comap x]\n      exact \u27e8T', hT\u2081, <a>Subset.rfl</a>\u27e9", [{"full_name": "Set.Subset.rfl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [338, 9], "def_end_pos": [338, 19]}]], "state_before": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\nT' : Set \u03b2\nhT\u2081 : T' \u2208 \ud835\udcdd (f x)\nhT\u2082 : IsClosed T'\nhT\u2083 : T' \u2286 T\n\u22a2 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T", "state_after": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\nT' : Set \u03b2\nhT\u2081 : T' \u2208 \ud835\udcdd (f x)\nhT\u2082 : IsClosed T'\nhT\u2083 : T' \u2286 T\nhT\u2084 : f \u207b\u00b9' T' \u2208 \ud835\udcdd x\n\u22a2 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T"}, {"tactic": "obtain \u27e8i, hi, hi'\u27e9 := (h _).mp hT\u2084", "annotated_tactic": ["obtain \u27e8i, hi, hi'\u27e9 := (h _).<a>mp</a> hT\u2084", [{"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "case refine'_1.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\nT' : Set \u03b2\nhT\u2081 : T' \u2208 \ud835\udcdd (f x)\nhT\u2082 : IsClosed T'\nhT\u2083 : T' \u2286 T\nhT\u2084 : f \u207b\u00b9' T' \u2208 \ud835\udcdd x\n\u22a2 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T", "state_after": "case refine'_1.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\nT' : Set \u03b2\nhT\u2081 : T' \u2208 \ud835\udcdd (f x)\nhT\u2082 : IsClosed T'\nhT\u2083 : T' \u2286 T\nhT\u2084 : f \u207b\u00b9' T' \u2208 \ud835\udcdd x\ni : \u03b9\nhi : p i\nhi' : s i \u2286 f \u207b\u00b9' T'\n\u22a2 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T"}, {"tactic": "exact\n  \u27e8i, hi,\n    (closure_mono (image_subset f hi')).trans\n      (Subset.trans (closure_minimal (image_preimage_subset _ _) hT\u2082) hT\u2083)\u27e9", "annotated_tactic": ["exact\n      \u27e8i, hi,\n        (<a>closure_mono</a> (<a>image_subset</a> f hi')).<a>trans</a>\n          (<a>Subset.trans</a> (<a>closure_minimal</a> (<a>image_preimage_subset</a> _ _) hT\u2082) hT\u2083)\u27e9", [{"full_name": "closure_mono", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [436, 9], "def_end_pos": [436, 21]}, {"full_name": "Set.image_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [293, 9], "def_end_pos": [293, 21]}, {"full_name": "HasSubset.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [667, 7], "def_end_pos": [667, 29]}, {"full_name": "Set.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [343, 9], "def_end_pos": [343, 21]}, {"full_name": "closure_minimal", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [404, 9], "def_end_pos": [404, 24]}, {"full_name": "Set.image_preimage_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [484, 9], "def_end_pos": [484, 30]}]], "state_before": "case refine'_1.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\nT' : Set \u03b2\nhT\u2081 : T' \u2208 \ud835\udcdd (f x)\nhT\u2082 : IsClosed T'\nhT\u2083 : T' \u2286 T\nhT\u2084 : f \u207b\u00b9' T' \u2208 \ud835\udcdd x\ni : \u03b9\nhi : p i\nhi' : s i \u2286 f \u207b\u00b9' T'\n\u22a2 \u2203 i, p i \u2227 closure (f '' s i) \u2286 T", "state_after": "no goals"}, {"tactic": "rw [hf.toInducing.nhds_eq_comap x]", "annotated_tactic": ["rw [hf.toInducing.nhds_eq_comap x]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\nT' : Set \u03b2\nhT\u2081 : T' \u2208 \ud835\udcdd (f x)\nhT\u2082 : IsClosed T'\nhT\u2083 : T' \u2286 T\n\u22a2 f \u207b\u00b9' T' \u2208 \ud835\udcdd x", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\nT' : Set \u03b2\nhT\u2081 : T' \u2208 \ud835\udcdd (f x)\nhT\u2082 : IsClosed T'\nhT\u2083 : T' \u2286 T\n\u22a2 f \u207b\u00b9' T' \u2208 Filter.comap f (\ud835\udcdd (f x))"}, {"tactic": "exact \u27e8T', hT\u2081, Subset.rfl\u27e9", "annotated_tactic": ["exact \u27e8T', hT\u2081, <a>Subset.rfl</a>\u27e9", [{"full_name": "Set.Subset.rfl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [338, 9], "def_end_pos": [338, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : T \u2208 \ud835\udcdd (f x)\nT' : Set \u03b2\nhT\u2081 : T' \u2208 \ud835\udcdd (f x)\nhT\u2082 : IsClosed T'\nhT\u2083 : T' \u2286 T\n\u22a2 f \u207b\u00b9' T' \u2208 Filter.comap f (\ud835\udcdd (f x))", "state_after": "no goals"}, {"tactic": "obtain \u27e8i, hi, hi'\u27e9 := hT", "annotated_tactic": ["obtain \u27e8i, hi, hi'\u27e9 := hT", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\nhT : \u2203 i, p i \u2227 closure (f '' s i) \u2286 T\n\u22a2 T \u2208 \ud835\udcdd (f x)", "state_after": "case refine'_2.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\ni : \u03b9\nhi : p i\nhi' : closure (f '' s i) \u2286 T\n\u22a2 T \u2208 \ud835\udcdd (f x)"}, {"tactic": "suffices closure (f '' s i) \u2208 \ud835\udcdd (f x) by filter_upwards [this] using hi'", "annotated_tactic": ["suffices <a>closure</a> (f '' s i) \u2208 \ud835\udcdd (f x) by filter_upwards [this] using hi'", [{"full_name": "closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [116, 5], "def_end_pos": [116, 12]}]], "state_before": "case refine'_2.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\ni : \u03b9\nhi : p i\nhi' : closure (f '' s i) \u2286 T\n\u22a2 T \u2208 \ud835\udcdd (f x)", "state_after": "case refine'_2.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\ni : \u03b9\nhi : p i\nhi' : closure (f '' s i) \u2286 T\n\u22a2 closure (f '' s i) \u2208 \ud835\udcdd (f x)"}, {"tactic": "replace h := (h (s i)).mpr \u27e8i, hi, Subset.rfl\u27e9", "annotated_tactic": ["replace h := (h (s i)).<a>mpr</a> \u27e8i, hi, <a>Subset.rfl</a>\u27e9", [{"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}, {"full_name": "Set.Subset.rfl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [338, 9], "def_end_pos": [338, 19]}]], "state_before": "case refine'_2.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\ni : \u03b9\nhi : p i\nhi' : closure (f '' s i) \u2286 T\n\u22a2 closure (f '' s i) \u2208 \ud835\udcdd (f x)", "state_after": "case refine'_2.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\ni : \u03b9\nhi : p i\nhi' : closure (f '' s i) \u2286 T\nh : s i \u2208 \ud835\udcdd x\n\u22a2 closure (f '' s i) \u2208 \ud835\udcdd (f x)"}, {"tactic": "exact hf.closure_image_mem_nhds h", "annotated_tactic": ["exact hf.closure_image_mem_nhds h", []], "state_before": "case refine'_2.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\ni : \u03b9\nhi : p i\nhi' : closure (f '' s i) \u2286 T\nh : s i \u2208 \ud835\udcdd x\n\u22a2 closure (f '' s i) \u2208 \ud835\udcdd (f x)", "state_after": "no goals"}, {"tactic": "filter_upwards [this] using hi'", "annotated_tactic": ["filter_upwards [this] using hi'", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : T3Space \u03b2\n\u03b9 : Type u_5\ns : \u03b9 \u2192 Set \u03b1\np : \u03b9 \u2192 Prop\nx : \u03b1\nh : \u2200 (t : Set \u03b1), t \u2208 \ud835\udcdd x \u2194 \u2203 i, p i \u2227 s i \u2286 t\nf : \u03b1 \u2192 \u03b2\nhf : DenseInducing f\nT : Set \u03b2\ni : \u03b9\nhi : p i\nhi' : closure (f '' s i) \u2286 T\nthis : closure (f '' s i) \u2208 \ud835\udcdd (f x)\n\u22a2 T \u2208 \ud835\udcdd (f x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/Basic.lean", "full_name": "connectedComponentIn_eq", "start": [676, 1], "end": [681, 72], "traced_tactics": [{"tactic": "have hx : x \u2208 F := connectedComponentIn_nonempty_iff.mp \u27e8y, h\u27e9", "annotated_tactic": ["have hx : x \u2208 F := connectedComponentIn_nonempty_iff.mp \u27e8y, h\u27e9", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns t u v : Set \u03b1\nx y : \u03b1\nF : Set \u03b1\nh : y \u2208 connectedComponentIn F x\n\u22a2 connectedComponentIn F x = connectedComponentIn F y", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns t u v : Set \u03b1\nx y : \u03b1\nF : Set \u03b1\nh : y \u2208 connectedComponentIn F x\nhx : x \u2208 F\n\u22a2 connectedComponentIn F x = connectedComponentIn F y"}, {"tactic": "simp_rw [connectedComponentIn_eq_image hx] at h \u22a2", "annotated_tactic": ["simp_rw [<a>connectedComponentIn_eq_image</a> hx] at h \u22a2", [{"full_name": "connectedComponentIn_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/Basic.lean", "def_pos": [581, 9], "def_end_pos": [581, 38]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns t u v : Set \u03b1\nx y : \u03b1\nF : Set \u03b1\nh : y \u2208 connectedComponentIn F x\nhx : x \u2208 F\n\u22a2 connectedComponentIn F x = connectedComponentIn F y", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns t u v : Set \u03b1\nx y : \u03b1\nF : Set \u03b1\nhx : x \u2208 F\nh : y \u2208 Subtype.val '' connectedComponent { val := x, property := hx }\n\u22a2 Subtype.val '' connectedComponent { val := x, property := hx } = connectedComponentIn F y"}, {"tactic": "obtain \u27e8\u27e8y, hy\u27e9, h2y, rfl\u27e9 := h", "annotated_tactic": ["obtain \u27e8\u27e8y, hy\u27e9, h2y, rfl\u27e9 := h", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns t u v : Set \u03b1\nx y : \u03b1\nF : Set \u03b1\nhx : x \u2208 F\nh : y \u2208 Subtype.val '' connectedComponent { val := x, property := hx }\n\u22a2 Subtype.val '' connectedComponent { val := x, property := hx } = connectedComponentIn F y", "state_after": "case intro.mk.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns t u v : Set \u03b1\nx : \u03b1\nF : Set \u03b1\nhx : x \u2208 F\ny : \u03b1\nhy : y \u2208 F\nh2y : { val := y, property := hy } \u2208 connectedComponent { val := x, property := hx }\n\u22a2 Subtype.val '' connectedComponent { val := x, property := hx } = connectedComponentIn F \u2191{ val := y, property := hy }"}, {"tactic": "simp_rw [connectedComponentIn_eq_image hy, connectedComponent_eq h2y]", "annotated_tactic": ["simp_rw [<a>connectedComponentIn_eq_image</a> hy, <a>connectedComponent_eq</a> h2y]", [{"full_name": "connectedComponentIn_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/Basic.lean", "def_pos": [581, 9], "def_end_pos": [581, 38]}, {"full_name": "connectedComponent_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/Basic.lean", "def_pos": [663, 9], "def_end_pos": [663, 30]}]], "state_before": "case intro.mk.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns t u v : Set \u03b1\nx : \u03b1\nF : Set \u03b1\nhx : x \u2208 F\ny : \u03b1\nhy : y \u2208 F\nh2y : { val := y, property := hy } \u2208 connectedComponent { val := x, property := hx }\n\u22a2 Subtype.val '' connectedComponent { val := x, property := hx } = connectedComponentIn F \u2191{ val := y, property := hy }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearForm/DualLattice.lean", "full_name": "BilinForm.dualSubmodule_span_of_basis", "start": [82, 1], "end": [104, 19], "traced_tactics": [{"tactic": "cases nonempty_fintype \u03b9", "annotated_tactic": ["cases <a>nonempty_fintype</a> \u03b9", [{"full_name": "nonempty_fintype", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [442, 9], "def_end_pos": [442, 25]}]], "state_before": "R : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\n\u22a2 dualSubmodule B (Submodule.span R (Set.range \u21d1b)) = Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "case intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\n\u22a2 dualSubmodule B (Submodule.span R (Set.range \u21d1b)) = Submodule.span R (Set.range \u21d1(dualBasis B hB b))"}, {"tactic": "apply le_antisymm", "annotated_tactic": ["apply <a>le_antisymm</a>", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "case intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\n\u22a2 dualSubmodule B (Submodule.span R (Set.range \u21d1b)) = Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "case intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\n\u22a2 dualSubmodule B (Submodule.span R (Set.range \u21d1b)) \u2264 Submodule.span R (Set.range \u21d1(dualBasis B hB b))\n\ncase intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\n\u22a2 Submodule.span R (Set.range \u21d1(dualBasis B hB b)) \u2264 dualSubmodule B (Submodule.span R (Set.range \u21d1b))"}, {"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "case intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\n\u22a2 dualSubmodule B (Submodule.span R (Set.range \u21d1b)) \u2264 Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "case intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\n\u22a2 x \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))"}, {"tactic": "rw [\u2190 (B.dualBasis hB b).sum_repr x]", "annotated_tactic": ["rw [\u2190 (B.dualBasis hB b).<a>sum_repr</a> x]", [{"full_name": "Basis.sum_repr", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [931, 9], "def_end_pos": [931, 23]}]], "state_before": "case intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\n\u22a2 x \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "case intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\n\u22a2 (Finset.sum Finset.univ fun i => ((dualBasis B hB b).repr x) i \u2022 (dualBasis B hB b) i) \u2208\n    Submodule.span R (Set.range \u21d1(dualBasis B hB b))"}, {"tactic": "apply sum_mem", "annotated_tactic": ["apply <a>sum_mem</a>", [{"full_name": "sum_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [95, 3], "def_end_pos": [95, 14]}]], "state_before": "case intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\n\u22a2 (Finset.sum Finset.univ fun i => ((dualBasis B hB b).repr x) i \u2022 (dualBasis B hB b) i) \u2208\n    Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "case intro.a.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\n\u22a2 \u2200 c \u2208 Finset.univ,\n    ((dualBasis B hB b).repr x) c \u2022 (dualBasis B hB b) c \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))"}, {"tactic": "rintro i -", "annotated_tactic": ["rintro i -", []], "state_before": "case intro.a.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\n\u22a2 \u2200 c \u2208 Finset.univ,\n    ((dualBasis B hB b).repr x) c \u2022 (dualBasis B hB b) c \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "case intro.a.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\ni : \u03b9\n\u22a2 ((dualBasis B hB b).repr x) i \u2022 (dualBasis B hB b) i \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))"}, {"tactic": "obtain \u27e8r, hr\u27e9 := hx (b i) (Submodule.subset_span \u27e8_, rfl\u27e9)", "annotated_tactic": ["obtain \u27e8r, hr\u27e9 := hx (b i) (<a>Submodule.subset_span</a> \u27e8_, <a>rfl</a>\u27e9)", [{"full_name": "Submodule.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro.a.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\ni : \u03b9\n\u22a2 ((dualBasis B hB b).repr x) i \u2022 (dualBasis B hB b) i \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "case intro.a.h.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\ni : \u03b9\nr : R\nhr : (Algebra.linearMap R S) r = B.bilin x (b i)\n\u22a2 ((dualBasis B hB b).repr x) i \u2022 (dualBasis B hB b) i \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))"}, {"tactic": "simp only [dualBasis_repr_apply, \u2190 hr, Algebra.linearMap_apply, algebraMap_smul]", "annotated_tactic": ["simp only [<a>dualBasis_repr_apply</a>, \u2190 hr, <a>Algebra.linearMap_apply</a>, <a>algebraMap_smul</a>]", [{"full_name": "BilinForm.dualBasis_repr_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/BilinearForm/Properties.lean", "def_pos": [475, 9], "def_end_pos": [475, 29]}, {"full_name": "Algebra.linearMap_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [431, 9], "def_end_pos": [431, 24]}, {"full_name": "algebraMap_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [844, 9], "def_end_pos": [844, 24]}]], "state_before": "case intro.a.h.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\ni : \u03b9\nr : R\nhr : (Algebra.linearMap R S) r = B.bilin x (b i)\n\u22a2 ((dualBasis B hB b).repr x) i \u2022 (dualBasis B hB b) i \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "case intro.a.h.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\ni : \u03b9\nr : R\nhr : (Algebra.linearMap R S) r = B.bilin x (b i)\n\u22a2 r \u2022 (dualBasis B hB b) i \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))"}, {"tactic": "apply Submodule.smul_mem", "annotated_tactic": ["apply <a>Submodule.smul_mem</a>", [{"full_name": "Submodule.smul_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}]], "state_before": "case intro.a.h.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\ni : \u03b9\nr : R\nhr : (Algebra.linearMap R S) r = B.bilin x (b i)\n\u22a2 r \u2022 (dualBasis B hB b) i \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "case intro.a.h.intro.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\ni : \u03b9\nr : R\nhr : (Algebra.linearMap R S) r = B.bilin x (b i)\n\u22a2 (dualBasis B hB b) i \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))"}, {"tactic": "exact Submodule.subset_span \u27e8_, rfl\u27e9", "annotated_tactic": ["exact <a>Submodule.subset_span</a> \u27e8_, <a>rfl</a>\u27e9", [{"full_name": "Submodule.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro.a.h.intro.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\nx : M\nhx : x \u2208 dualSubmodule B (Submodule.span R (Set.range \u21d1b))\ni : \u03b9\nr : R\nhr : (Algebra.linearMap R S) r = B.bilin x (b i)\n\u22a2 (dualBasis B hB b) i \u2208 Submodule.span R (Set.range \u21d1(dualBasis B hB b))", "state_after": "no goals"}, {"tactic": "rw [Submodule.span_le]", "annotated_tactic": ["rw [<a>Submodule.span_le</a>]", [{"full_name": "Submodule.span_le", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [79, 9], "def_end_pos": [79, 16]}]], "state_before": "case intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\n\u22a2 Submodule.span R (Set.range \u21d1(dualBasis B hB b)) \u2264 dualSubmodule B (Submodule.span R (Set.range \u21d1b))", "state_after": "case intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\n\u22a2 Set.range \u21d1(dualBasis B hB b) \u2286 \u2191(dualSubmodule B (Submodule.span R (Set.range \u21d1b)))"}, {"tactic": "rintro _ \u27e8i, rfl\u27e9 y hy", "annotated_tactic": ["rintro _ \u27e8i, rfl\u27e9 y hy", []], "state_before": "case intro.a\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\n\u22a2 Set.range \u21d1(dualBasis B hB b) \u2286 \u2191(dualSubmodule B (Submodule.span R (Set.range \u21d1b)))", "state_after": "case intro.a.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\ny : M\nhy : y \u2208 Submodule.span R (Set.range \u21d1b)\n\u22a2 B.bilin ((dualBasis B hB b) i) y \u2208 1"}, {"tactic": "obtain \u27e8f, rfl\u27e9 := (mem_span_range_iff_exists_fun _).mp hy", "annotated_tactic": ["obtain \u27e8f, rfl\u27e9 := (<a>mem_span_range_iff_exists_fun</a> _).<a>mp</a> hy", [{"full_name": "mem_span_range_iff_exists_fun", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [1227, 9], "def_end_pos": [1227, 38]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "case intro.a.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\ny : M\nhy : y \u2208 Submodule.span R (Set.range \u21d1b)\n\u22a2 B.bilin ((dualBasis B hB b) i) y \u2208 1", "state_after": "case intro.a.intro.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\n\u22a2 B.bilin ((dualBasis B hB b) i) (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 1"}, {"tactic": "simp only [sum_right, bilin_smul_right]", "annotated_tactic": ["simp only [<a>sum_right</a>, <a>bilin_smul_right</a>]", [{"full_name": "BilinForm.sum_right", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/BilinearForm/Hom.lean", "def_pos": [105, 9], "def_end_pos": [105, 18]}, {"full_name": "BilinForm.bilin_smul_right", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/BilinearForm/Basic.lean", "def_pos": [57, 3], "def_end_pos": [57, 19]}]], "state_before": "case intro.a.intro.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\n\u22a2 B.bilin ((dualBasis B hB b) i) (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 1", "state_after": "case intro.a.intro.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\n\u22a2 (Finset.sum Finset.univ fun i_1 => B.bilin ((dualBasis B hB b) i) (f i_1 \u2022 b i_1)) \u2208 1"}, {"tactic": "apply sum_mem", "annotated_tactic": ["apply <a>sum_mem</a>", [{"full_name": "sum_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [95, 3], "def_end_pos": [95, 14]}]], "state_before": "case intro.a.intro.intro\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\n\u22a2 (Finset.sum Finset.univ fun i_1 => B.bilin ((dualBasis B hB b) i) (f i_1 \u2022 b i_1)) \u2208 1", "state_after": "case intro.a.intro.intro.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\n\u22a2 \u2200 c \u2208 Finset.univ, B.bilin ((dualBasis B hB b) i) (f c \u2022 b c) \u2208 1"}, {"tactic": "rintro j -", "annotated_tactic": ["rintro j -", []], "state_before": "case intro.a.intro.intro.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\n\u22a2 \u2200 c \u2208 Finset.univ, B.bilin ((dualBasis B hB b) i) (f c \u2022 b c) \u2208 1", "state_after": "case intro.a.intro.intro.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\nj : \u03b9\n\u22a2 B.bilin ((dualBasis B hB b) i) (f j \u2022 b j) \u2208 1"}, {"tactic": "rw [\u2190 IsScalarTower.algebraMap_smul S (f j), B.bilin_smul_right, apply_dualBasis_left,\n  mul_ite, mul_one, mul_zero, \u2190 (algebraMap R S).map_zero, \u2190 apply_ite]", "annotated_tactic": ["rw [\u2190 <a>IsScalarTower.algebraMap_smul</a> S (f j), B.bilin_smul_right, <a>apply_dualBasis_left</a>,\n      <a>mul_ite</a>, <a>mul_one</a>, <a>mul_zero</a>, \u2190 (<a>algebraMap</a> R S).<a>map_zero</a>, \u2190 <a>apply_ite</a>]", [{"full_name": "IsScalarTower.algebraMap_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Tower.lean", "def_pos": [88, 9], "def_end_pos": [88, 24]}, {"full_name": "BilinForm.apply_dualBasis_left", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/BilinearForm/Properties.lean", "def_pos": [481, 9], "def_end_pos": [481, 29]}, {"full_name": "mul_ite", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [197, 9], "def_end_pos": [197, 16]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "RingHom.map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [549, 19], "def_end_pos": [549, 27]}, {"full_name": "apply_ite", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [36, 9], "def_end_pos": [36, 18]}]], "state_before": "case intro.a.intro.intro.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\nj : \u03b9\n\u22a2 B.bilin ((dualBasis B hB b) i) (f j \u2022 b j) \u2208 1", "state_after": "case intro.a.intro.intro.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\nj : \u03b9\n\u22a2 (algebraMap R S) (if j = i then f j else 0) \u2208 1"}, {"tactic": "exact \u27e8_, rfl\u27e9", "annotated_tactic": ["exact \u27e8_, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro.a.intro.intro.h\nR : Type u_4\nS : Type u_3\nM : Type u_2\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module S M\ninst\u271d\u00b2 : IsScalarTower R S M\nB : BilinForm S M\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : DecidableEq \u03b9\nhB : Nondegenerate B\nb : Basis \u03b9 S M\nval\u271d : Fintype \u03b9\ni : \u03b9\nf : \u03b9 \u2192 R\nhy : (Finset.sum Finset.univ fun i => f i \u2022 b i) \u2208 Submodule.span R (Set.range \u21d1b)\nj : \u03b9\n\u22a2 (algebraMap R S) (if j = i then f j else 0) \u2208 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/QuotientGroup.lean", "full_name": "QuotientGroup.mk_zpow", "start": [189, 1], "end": [190, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/AlgebraMap.lean", "full_name": "Polynomial.ringHom_eval\u2082_cast_int_ringHom", "start": [139, 1], "end": [141, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "Real.Icc_eq_closedBall", "start": [1402, 1], "end": [1404, 65], "traced_tactics": [{"tactic": "rw [Real.closedBall_eq_Icc, \u2190 sub_div, add_comm, \u2190 sub_add, add_sub_cancel', add_self_div_two, \u2190\n  add_div, add_assoc, add_sub_cancel'_right, add_self_div_two]", "annotated_tactic": ["rw [<a>Real.closedBall_eq_Icc</a>, \u2190 <a>sub_div</a>, <a>add_comm</a>, \u2190 <a>sub_add</a>, <a>add_sub_cancel'</a>, <a>add_self_div_two</a>, \u2190\n    <a>add_div</a>, <a>add_assoc</a>, <a>add_sub_cancel'_right</a>, <a>add_self_div_two</a>]", [{"full_name": "Real.closedBall_eq_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1391, 9], "def_end_pos": [1391, 31]}, {"full_name": "sub_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Field/Basic.lean", "def_pos": [170, 9], "def_end_pos": [170, 16]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "sub_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [606, 3], "def_end_pos": [606, 14]}, {"full_name": "add_sub_cancel'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1026, 30], "def_end_pos": [1026, 45]}, {"full_name": "add_self_div_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [520, 9], "def_end_pos": [520, 25]}, {"full_name": "add_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Field/Basic.lean", "def_pos": [29, 9], "def_end_pos": [29, 16]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "add_sub_cancel'_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1031, 3], "def_end_pos": [1031, 14]}, {"full_name": "add_self_div_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [520, 9], "def_end_pos": [520, 25]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y : \u211d\n\u22a2 Icc x y = closedBall ((x + y) / 2) ((y - x) / 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Ring/Basic.lean", "full_name": "Mathlib.Tactic.Ring.neg_mul", "start": [532, 1], "end": [533, 73], "traced_tactics": [{"tactic": "subst_vars", "annotated_tactic": ["subst_vars", []], "state_before": "u : Lean.Level\nR\u271d : Type ?u.109085\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d\u00b9 : CommSemiring R\u271d\nR : Type u_1\ninst\u271d : Ring R\na\u2081 : R\na\u2082 : \u2115\na\u2083 b : R\nx\u271d : -a\u2083 = b\n\u22a2 -(a\u2081 ^ a\u2082 * a\u2083) = a\u2081 ^ a\u2082 * b", "state_after": "u : Lean.Level\nR\u271d : Type ?u.109085\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d\u00b9 : CommSemiring R\u271d\nR : Type u_1\ninst\u271d : Ring R\na\u2081 : R\na\u2082 : \u2115\na\u2083 : R\n\u22a2 -(a\u2081 ^ a\u2082 * a\u2083) = a\u2081 ^ a\u2082 * -a\u2083"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "u : Lean.Level\nR\u271d : Type ?u.109085\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d\u00b9 : CommSemiring R\u271d\nR : Type u_1\ninst\u271d : Ring R\na\u2081 : R\na\u2082 : \u2115\na\u2083 : R\n\u22a2 -(a\u2081 ^ a\u2082 * a\u2083) = a\u2081 ^ a\u2082 * -a\u2083", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.rightInvOn_id", "start": [1174, 1], "end": [1174, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.iInf_neBot_of_directed", "start": [943, 1], "end": [948, 40], "traced_tactics": [{"tactic": "cases isEmpty_or_nonempty \u03b9", "annotated_tactic": ["cases <a>isEmpty_or_nonempty</a> \u03b9", [{"full_name": "isEmpty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [215, 9], "def_end_pos": [215, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\nhn : Nonempty \u03b1\nhd : Directed (fun x x_1 => x \u2265 x_1) f\nhb : \u2200 (i : \u03b9), NeBot (f i)\n\u22a2 NeBot (iInf f)", "state_after": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\nhn : Nonempty \u03b1\nhd : Directed (fun x x_1 => x \u2265 x_1) f\nhb : \u2200 (i : \u03b9), NeBot (f i)\nh\u271d : IsEmpty \u03b9\n\u22a2 NeBot (iInf f)\n\ncase inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\nhn : Nonempty \u03b1\nhd : Directed (fun x x_1 => x \u2265 x_1) f\nhb : \u2200 (i : \u03b9), NeBot (f i)\nh\u271d : Nonempty \u03b9\n\u22a2 NeBot (iInf f)"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\nhn : Nonempty \u03b1\nhd : Directed (fun x x_1 => x \u2265 x_1) f\nhb : \u2200 (i : \u03b9), NeBot (f i)\nh\u271d : IsEmpty \u03b9\n\u22a2 NeBot (iInf f)", "state_after": "case inl.ne'\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\nhn : Nonempty \u03b1\nhd : Directed (fun x x_1 => x \u2265 x_1) f\nhb : \u2200 (i : \u03b9), NeBot (f i)\nh\u271d : IsEmpty \u03b9\n\u22a2 iInf f \u2260 \u22a5"}, {"tactic": "simp [iInf_of_empty f, top_ne_bot]", "annotated_tactic": ["simp [<a>iInf_of_empty</a> f, <a>top_ne_bot</a>]", [{"full_name": "iInf_of_empty", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1481, 9], "def_end_pos": [1481, 22]}, {"full_name": "top_ne_bot", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [889, 9], "def_end_pos": [889, 19]}]], "state_before": "case inl.ne'\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\nhn : Nonempty \u03b1\nhd : Directed (fun x x_1 => x \u2265 x_1) f\nhb : \u2200 (i : \u03b9), NeBot (f i)\nh\u271d : IsEmpty \u03b9\n\u22a2 iInf f \u2260 \u22a5", "state_after": "no goals"}, {"tactic": "exact iInf_neBot_of_directed' hd hb", "annotated_tactic": ["exact <a>iInf_neBot_of_directed'</a> hd hb", [{"full_name": "Filter.iInf_neBot_of_directed'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [935, 9], "def_end_pos": [935, 32]}]], "state_before": "case inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\nhn : Nonempty \u03b1\nhd : Directed (fun x x_1 => x \u2265 x_1) f\nhb : \u2200 (i : \u03b9), NeBot (f i)\nh\u271d : Nonempty \u03b9\n\u22a2 NeBot (iInf f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "toIcoDiv_add_left'", "start": [322, 1], "end": [323, 37], "traced_tactics": [{"tactic": "rw [add_comm, toIcoDiv_add_right']", "annotated_tactic": ["rw [<a>add_comm</a>, <a>toIcoDiv_add_right'</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "toIcoDiv_add_right'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [302, 9], "def_end_pos": [302, 28]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b\u271d c : \u03b1\nn : \u2124\na b : \u03b1\n\u22a2 toIcoDiv hp (p + a) b = toIcoDiv hp a b - 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Adjoin.lean", "full_name": "PowerBasis.equivAdjoinSimple_symm_gen", "start": [1416, 1], "end": [1418, 89], "traced_tactics": [{"tactic": "rw [equivAdjoinSimple, equivOfMinpoly_symm, equivOfMinpoly_gen, adjoin.powerBasis_gen]", "annotated_tactic": ["rw [<a>equivAdjoinSimple</a>, <a>equivOfMinpoly_symm</a>, <a>equivOfMinpoly_gen</a>, <a>adjoin.powerBasis_gen</a>]", [{"full_name": "PowerBasis.equivAdjoinSimple", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [1392, 19], "def_end_pos": [1392, 36]}, {"full_name": "PowerBasis.equivOfMinpoly_symm", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerBasis.lean", "def_pos": [412, 9], "def_end_pos": [412, 28]}, {"full_name": "PowerBasis.equivOfMinpoly_gen", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerBasis.lean", "def_pos": [406, 9], "def_end_pos": [406, 27]}, {"full_name": "IntermediateField.adjoin.powerBasis_gen", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [1126, 3], "def_end_pos": [1126, 8]}]], "state_before": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\npb : PowerBasis K L\n\u22a2 (AlgEquiv.symm (equivAdjoinSimple pb)) pb.gen = AdjoinSimple.gen K pb.gen", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.sigma_eq_sigmaTR", "start": [963, 10], "end": [966, 40], "traced_tactics": [{"tactic": "funext \u03b1 \u03b2 l\u2081 l\u2082", "annotated_tactic": ["funext \u03b1 \u03b2 l\u2081 l\u2082", []], "state_before": "\u22a2 @List.sigma = @sigmaTR", "state_after": "case h.h.h.h\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 List.sigma l\u2081 l\u2082 = sigmaTR l\u2081 l\u2082"}, {"tactic": "simp [List.sigma, sigmaTR]", "annotated_tactic": ["simp [<a>List.sigma</a>, <a>sigmaTR</a>]", [{"full_name": "List.sigma", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [956, 15], "def_end_pos": [956, 20]}, {"full_name": "List.sigmaTR", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [960, 5], "def_end_pos": [960, 12]}]], "state_before": "case h.h.h.h\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 List.sigma l\u2081 l\u2082 = sigmaTR l\u2081 l\u2082", "state_after": "case h.h.h.h\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 (List.bind l\u2081 fun a => map (Sigma.mk a) (l\u2082 a)) =\n    (foldl (fun acc a => foldl (fun acc b => Array.push acc { fst := a, snd := b }) acc (l\u2082 a)) #[] l\u2081).data"}, {"tactic": "rw [Array.foldl_data_eq_bind]", "annotated_tactic": ["rw [<a>Array.foldl_data_eq_bind</a>]", [{"full_name": "Array.foldl_data_eq_bind", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [166, 9], "def_end_pos": [166, 27]}]], "state_before": "case h.h.h.h\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 (List.bind l\u2081 fun a => map (Sigma.mk a) (l\u2082 a)) =\n    (foldl (fun acc a => foldl (fun acc b => Array.push acc { fst := a, snd := b }) acc (l\u2082 a)) #[] l\u2081).data", "state_after": "case h.h.h.h\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 (List.bind l\u2081 fun a => map (Sigma.mk a) (l\u2082 a)) = #[].data ++ List.bind l\u2081 ?h.h.h.h.G\n\ncase h.h.h.h.G\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 \u03b1 \u2192 List ((a : \u03b1) \u00d7 \u03b2 a)\n\ncase h.h.h.h.H\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 \u2200 (acc : Array ((a : \u03b1) \u00d7 \u03b2 a)) (a : \u03b1),\n    (foldl (fun acc b => Array.push acc { fst := a, snd := b }) acc (l\u2082 a)).data = acc.data ++ ?h.h.h.h.G a"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.h.h.h\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 (List.bind l\u2081 fun a => map (Sigma.mk a) (l\u2082 a)) = #[].data ++ List.bind l\u2081 ?h.h.h.h.G\n\ncase h.h.h.h.G\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 \u03b1 \u2192 List ((a : \u03b1) \u00d7 \u03b2 a)\n\ncase h.h.h.h.H\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 \u2200 (acc : Array ((a : \u03b1) \u00d7 \u03b2 a)) (a : \u03b1),\n    (foldl (fun acc b => Array.push acc { fst := a, snd := b }) acc (l\u2082 a)).data = acc.data ++ ?h.h.h.h.G a", "state_after": "case h.h.h.h.H\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 \u2200 (acc : Array ((a : \u03b1) \u00d7 \u03b2 a)) (a : \u03b1),\n    (foldl (fun acc b => Array.push acc { fst := a, snd := b }) acc (l\u2082 a)).data = acc.data ++ map (Sigma.mk a) (l\u2082 a)"}, {"tactic": "intros", "annotated_tactic": ["intros", []], "state_before": "case h.h.h.h.H\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\n\u22a2 \u2200 (acc : Array ((a : \u03b1) \u00d7 \u03b2 a)) (a : \u03b1),\n    (foldl (fun acc b => Array.push acc { fst := a, snd := b }) acc (l\u2082 a)).data = acc.data ++ map (Sigma.mk a) (l\u2082 a)", "state_after": "case h.h.h.h.H\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\nacc\u271d : Array ((a : \u03b1) \u00d7 \u03b2 a)\na\u271d : \u03b1\n\u22a2 (foldl (fun acc b => Array.push acc { fst := a\u271d, snd := b }) acc\u271d (l\u2082 a\u271d)).data =\n    acc\u271d.data ++ map (Sigma.mk a\u271d) (l\u2082 a\u271d)"}, {"tactic": "apply Array.foldl_data_eq_map", "annotated_tactic": ["apply <a>Array.foldl_data_eq_map</a>", [{"full_name": "Array.foldl_data_eq_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [172, 9], "def_end_pos": [172, 26]}]], "state_before": "case h.h.h.h.H\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_1\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03b2 a)\nacc\u271d : Array ((a : \u03b1) \u00d7 \u03b2 a)\na\u271d : \u03b1\n\u22a2 (foldl (fun acc b => Array.push acc { fst := a\u271d, snd := b }) acc\u271d (l\u2082 a\u271d)).data =\n    acc\u271d.data ++ map (Sigma.mk a\u271d) (l\u2082 a\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Linarith/Lemmas.lean", "full_name": "Linarith.lt_of_eq_of_lt", "start": [33, 1], "end": [34, 11], "traced_tactics": [{"tactic": "simp [*]", "annotated_tactic": ["simp [*]", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\na b : \u03b1\nha : a = 0\nhb : b < 0\n\u22a2 a + b < 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.norm_im_le_norm", "start": [764, 1], "end": [765, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Isomorphisms.lean", "full_name": "Submodule.card_quotient_mul_card_quotient", "start": [186, 1], "end": [190, 75], "traced_tactics": [{"tactic": "rw [Submodule.card_eq_card_quotient_mul_card (map T.mkQ S),\n  Fintype.card_eq.mpr \u27e8(quotientQuotientEquivQuotient T S hST).toEquiv\u27e9]", "annotated_tactic": ["rw [<a>Submodule.card_eq_card_quotient_mul_card</a> (<a>map</a> T.mkQ S),\n    Fintype.card_eq.mpr \u27e8(<a>quotientQuotientEquivQuotient</a> T S hST).<a>toEquiv</a>\u27e9]", [{"full_name": "Submodule.card_eq_card_quotient_mul_card", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [307, 9], "def_end_pos": [307, 39]}, {"full_name": "Submodule.map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [48, 5], "def_end_pos": [48, 8]}, {"full_name": "Submodule.quotientQuotientEquivQuotient", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Isomorphisms.lean", "def_pos": [177, 5], "def_end_pos": [177, 34]}, {"full_name": "LinearEquiv.toEquiv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [145, 5], "def_end_pos": [145, 12]}]], "state_before": "R : Type u_1\nM : Type u_2\nM\u2082 : Type u_3\nM\u2083 : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup M\u2082\ninst\u271d\u2076 : AddCommGroup M\u2083\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M\u2082\ninst\u271d\u00b3 : Module R M\u2083\nf : M \u2192\u2097[R] M\u2082\nS\u271d T\u271d : Submodule R M\nh : S\u271d \u2264 T\u271d\nS T : Submodule R M\nhST : T \u2264 S\ninst\u271d\u00b2 : DecidablePred fun x => x \u2208 map (mkQ T) S\ninst\u271d\u00b9 : Fintype (M \u29f8 S)\ninst\u271d : Fintype (M \u29f8 T)\n\u22a2 Fintype.card \u21a5(map (mkQ T) S) * Fintype.card (M \u29f8 S) = Fintype.card (M \u29f8 T)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Free/Basic.lean", "full_name": "CategoryTheory.FreeMonoidalCategory.mk_whiskerRight", "start": [211, 1], "end": [213, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Basic.lean", "full_name": "Submodule.smul_mem_iff", "start": [505, 1], "end": [506, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "full_name": "MeasureTheory.measure_symmDiff_ne_top", "start": [331, 1], "end": [332, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.mem_span_singleton_trans", "start": [544, 1], "end": [546, 44], "traced_tactics": [{"tactic": "rw [\u2190 SetLike.mem_coe, \u2190 singleton_subset_iff] at *", "annotated_tactic": ["rw [\u2190 <a>SetLike.mem_coe</a>, \u2190 <a>singleton_subset_iff</a>] at *", [{"full_name": "SetLike.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [180, 9], "def_end_pos": [180, 16]}, {"full_name": "Set.singleton_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1300, 9], "def_end_pos": [1300, 29]}]], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nx y z : M\nhxy : x \u2208 span R {y}\nhyz : y \u2208 span R {z}\n\u22a2 x \u2208 span R {z}", "state_after": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nx y z : M\nhxy : {x} \u2286 \u2191(span R {y})\nhyz : {y} \u2286 \u2191(span R {z})\n\u22a2 {x} \u2286 \u2191(span R {z})"}, {"tactic": "exact Submodule.subset_span_trans hxy hyz", "annotated_tactic": ["exact <a>Submodule.subset_span_trans</a> hxy hyz", [{"full_name": "Submodule.subset_span_trans", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [349, 9], "def_end_pos": [349, 26]}]], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nx y z : M\nhxy : {x} \u2286 \u2191(span R {y})\nhyz : {y} \u2286 \u2191(span R {z})\n\u22a2 {x} \u2286 \u2191(span R {z})", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Monoid.lean", "full_name": "Filter.Tendsto.const_mul", "start": [128, 1], "end": [130, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "full_name": "hasStrictFDerivAt_pi", "start": [420, 1], "end": [423, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "Filter.limUnder_eq_iff", "start": [1455, 1], "end": [1457, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Closure.lean", "full_name": "LowerAdjoint.not_mem_of_not_mem_closure", "start": [472, 1], "end": [473, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "RingHom.eqLocus_same", "start": [1198, 1], "end": [1199, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Function.lean", "full_name": "StrictConcaveOn.add", "start": [534, 1], "end": [536, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Basic.lean", "full_name": "pow_add", "start": [103, 1], "end": [106, 66], "traced_tactics": [{"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm n : \u2115\n\u22a2 a ^ (m + n) = a ^ m * a ^ n", "state_after": "case zero\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm : \u2115\n\u22a2 a ^ (m + Nat.zero) = a ^ m * a ^ Nat.zero\n\ncase succ\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm n : \u2115\nih : a ^ (m + n) = a ^ m * a ^ n\n\u22a2 a ^ (m + Nat.succ n) = a ^ m * a ^ Nat.succ n"}, {"tactic": "rw [Nat.add_zero, pow_zero, mul_one]", "annotated_tactic": ["rw [<a>Nat.add_zero</a>, <a>pow_zero</a>, <a>mul_one</a>]", [{"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}, {"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "case zero\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm : \u2115\n\u22a2 a ^ (m + Nat.zero) = a ^ m * a ^ Nat.zero", "state_after": "no goals"}, {"tactic": "rw [pow_succ', \u2190 mul_assoc, \u2190 ih, \u2190 pow_succ', Nat.add_assoc]", "annotated_tactic": ["rw [<a>pow_succ'</a>, \u2190 <a>mul_assoc</a>, \u2190 ih, \u2190 <a>pow_succ'</a>, <a>Nat.add_assoc</a>]", [{"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}, {"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "case succ\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm n : \u2115\nih : a ^ (m + n) = a ^ m * a ^ n\n\u22a2 a ^ (m + Nat.succ n) = a ^ m * a ^ Nat.succ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/AEMeasurableSequence.lean", "full_name": "aeSeq.mk_eq_fun_of_mem_aeSeqSet", "start": [50, 1], "end": [56, 19], "traced_tactics": [{"tactic": "rw [aeSeqSet, \u2190 compl_compl { x | \u2200 i, f i x = (hf i).mk (f i) x }, Set.compl_subset_compl]", "annotated_tactic": ["rw [<a>aeSeqSet</a>, \u2190 <a>compl_compl</a> { x | \u2200 i, f i x = (hf i).<a>mk</a> (f i) x }, <a>Set.compl_subset_compl</a>]", [{"full_name": "aeSeqSet", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/AEMeasurableSequence.lean", "def_pos": [36, 5], "def_end_pos": [36, 13]}, {"full_name": "compl_compl", "def_path": ".lake/packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [656, 9], "def_end_pos": [656, 20]}, {"full_name": "AEMeasurable.mk", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [720, 5], "def_end_pos": [720, 7]}, {"full_name": "Set.compl_subset_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1737, 9], "def_end_pos": [1737, 27]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2\n\u03bc : Measure \u03b1\np : \u03b1 \u2192 (\u03b9 \u2192 \u03b2) \u2192 Prop\nhf : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\nx : \u03b1\nhx : x \u2208 aeSeqSet hf p\ni : \u03b9\n\u22a2 aeSeqSet hf p \u2286 {x | \u2200 (i : \u03b9), f i x = AEMeasurable.mk (f i) \u22ef x}", "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2\n\u03bc : Measure \u03b1\np : \u03b1 \u2192 (\u03b9 \u2192 \u03b2) \u2192 Prop\nhf : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\nx : \u03b1\nhx : x \u2208 aeSeqSet hf p\ni : \u03b9\n\u22a2 {x | \u2200 (i : \u03b9), f i x = AEMeasurable.mk (f i) \u22ef x}\u1d9c \u2286\n    toMeasurable \u03bc {x | (\u2200 (i : \u03b9), f i x = AEMeasurable.mk (f i) \u22ef x) \u2227 p x fun n => f n x}\u1d9c"}, {"tactic": "refine' Set.Subset.trans (Set.compl_subset_compl.mpr fun x h => _) (subset_toMeasurable _ _)", "annotated_tactic": ["refine' <a>Set.Subset.trans</a> (Set.compl_subset_compl.mpr fun x h => _) (<a>subset_toMeasurable</a> _ _)", [{"full_name": "Set.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [343, 9], "def_end_pos": [343, 21]}, {"full_name": "MeasureTheory.subset_toMeasurable", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [631, 9], "def_end_pos": [631, 28]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2\n\u03bc : Measure \u03b1\np : \u03b1 \u2192 (\u03b9 \u2192 \u03b2) \u2192 Prop\nhf : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\nx : \u03b1\nhx : x \u2208 aeSeqSet hf p\ni : \u03b9\n\u22a2 {x | \u2200 (i : \u03b9), f i x = AEMeasurable.mk (f i) \u22ef x}\u1d9c \u2286\n    toMeasurable \u03bc {x | (\u2200 (i : \u03b9), f i x = AEMeasurable.mk (f i) \u22ef x) \u2227 p x fun n => f n x}\u1d9c", "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2\n\u03bc : Measure \u03b1\np : \u03b1 \u2192 (\u03b9 \u2192 \u03b2) \u2192 Prop\nhf : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\nx\u271d : \u03b1\nhx : x\u271d \u2208 aeSeqSet hf p\ni : \u03b9\nx : \u03b1\nh : x \u2208 {x | (\u2200 (i : \u03b9), f i x = AEMeasurable.mk (f i) \u22ef x) \u2227 p x fun n => f n x}\n\u22a2 x \u2208 {x | \u2200 (i : \u03b9), f i x = AEMeasurable.mk (f i) \u22ef x}"}, {"tactic": "exact h.1", "annotated_tactic": ["exact h.1", []], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2\n\u03bc : Measure \u03b1\np : \u03b1 \u2192 (\u03b9 \u2192 \u03b2) \u2192 Prop\nhf : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\nx\u271d : \u03b1\nhx : x\u271d \u2208 aeSeqSet hf p\ni : \u03b9\nx : \u03b1\nh : x \u2208 {x | (\u2200 (i : \u03b9), f i x = AEMeasurable.mk (f i) \u22ef x) \u2227 p x fun n => f n x}\n\u22a2 x \u2208 {x | \u2200 (i : \u03b9), f i x = AEMeasurable.mk (f i) \u22ef x}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.union_diff_self", "start": [2013, 1], "end": [2014, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.castLE_comp_castSucc", "start": [848, 1], "end": [850, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean", "full_name": "UniformFun.mono", "start": [359, 11], "end": [360, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/AddTorsor.lean", "full_name": "nndist_vadd_left", "start": [120, 1], "end": [121, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Relation.lean", "full_name": "reflTransGen_of_pred_of_ge", "start": [98, 1], "end": [100, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "AddMonoidAlgebra.single_mul_apply", "start": [1706, 1], "end": [1708, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factors.lean", "full_name": "Nat.le_of_mem_factors", "start": [162, 1], "end": [166, 46], "traced_tactics": [{"tactic": "rcases n.eq_zero_or_pos with (rfl | hn)", "annotated_tactic": ["rcases n.eq_zero_or_pos with (rfl | hn)", []], "state_before": "n p : \u2115\nh : p \u2208 factors n\n\u22a2 p \u2264 n", "state_after": "case inl\np : \u2115\nh : p \u2208 factors 0\n\u22a2 p \u2264 0\n\ncase inr\nn p : \u2115\nh : p \u2208 factors n\nhn : n > 0\n\u22a2 p \u2264 n"}, {"tactic": "rw [factors_zero] at h", "annotated_tactic": ["rw [<a>factors_zero</a>] at h", [{"full_name": "Nat.factors_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factors.lean", "def_pos": [44, 9], "def_end_pos": [44, 21]}]], "state_before": "case inl\np : \u2115\nh : p \u2208 factors 0\n\u22a2 p \u2264 0", "state_after": "case inl\np : \u2115\nh : p \u2208 []\n\u22a2 p \u2264 0"}, {"tactic": "cases h", "annotated_tactic": ["cases h", []], "state_before": "case inl\np : \u2115\nh : p \u2208 []\n\u22a2 p \u2264 0", "state_after": "no goals"}, {"tactic": "exact le_of_dvd hn (dvd_of_mem_factors h)", "annotated_tactic": ["exact <a>le_of_dvd</a> hn (<a>dvd_of_mem_factors</a> h)", [{"full_name": "Nat.le_of_dvd", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean", "def_pos": [52, 9], "def_end_pos": [52, 18]}, {"full_name": "Nat.dvd_of_mem_factors", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factors.lean", "def_pos": [148, 9], "def_end_pos": [148, 27]}]], "state_before": "case inr\nn p : \u2115\nh : p \u2208 factors n\nhn : n > 0\n\u22a2 p \u2264 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.isMaximal_iff", "start": [307, 1], "end": [317, 50], "traced_tactics": [{"tactic": "rw [lt_iff_le_not_le]", "annotated_tactic": ["rw [<a>lt_iff_le_not_le</a>]", [{"full_name": "lt_iff_le_not_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [54, 9], "def_end_pos": [54, 25]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI\u271d : Ideal \u03b1\na b : \u03b1\nI J : Ideal \u03b1\n\u22a2 I < J \u2192 J = \u22a4 \u2194 \u2200 (x : \u03b1), I \u2264 J \u2192 x \u2209 I \u2192 x \u2208 J \u2192 1 \u2208 J", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI\u271d : Ideal \u03b1\na b : \u03b1\nI J : Ideal \u03b1\n\u22a2 I \u2264 J \u2227 \u00acJ \u2264 I \u2192 J = \u22a4 \u2194 \u2200 (x : \u03b1), I \u2264 J \u2192 x \u2209 I \u2192 x \u2208 J \u2192 1 \u2208 J"}, {"tactic": "exact\n  \u27e8fun H x h hx\u2081 hx\u2082 => J.eq_top_iff_one.1 <| H \u27e8h, not_subset.2 \u27e8_, hx\u2082, hx\u2081\u27e9\u27e9,\n    fun H \u27e8h\u2081, h\u2082\u27e9 =>\n    let \u27e8x, xJ, xI\u27e9 := not_subset.1 h\u2082\n    J.eq_top_iff_one.2 <| H x h\u2081 xI xJ\u27e9", "annotated_tactic": ["exact\n            \u27e8fun H x h hx\u2081 hx\u2082 => J.eq_top_iff_one.1 <| H \u27e8h, <a>not_subset</a>.2 \u27e8_, hx\u2082, hx\u2081\u27e9\u27e9,\n              fun H \u27e8h\u2081, h\u2082\u27e9 =>\n              let \u27e8x, xJ, xI\u27e9 := <a>not_subset</a>.1 h\u2082\n              J.eq_top_iff_one.2 <| H x h\u2081 xI xJ\u27e9", [{"full_name": "Set.not_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [372, 9], "def_end_pos": [372, 19]}, {"full_name": "Set.not_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [372, 9], "def_end_pos": [372, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI\u271d : Ideal \u03b1\na b : \u03b1\nI J : Ideal \u03b1\n\u22a2 I \u2264 J \u2227 \u00acJ \u2264 I \u2192 J = \u22a4 \u2194 \u2200 (x : \u03b1), I \u2264 J \u2192 x \u2209 I \u2192 x \u2208 J \u2192 1 \u2208 J", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Defs.lean", "full_name": "Int.coe_nat_ediv", "start": [173, 1], "end": [173, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Logic.lean", "full_name": "congrFun\u2082", "start": [44, 1], "end": [47, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iInter_mono'", "start": [370, 1], "end": [374, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "round_zero", "start": [1441, 1], "end": [1441, 58], "traced_tactics": [{"tactic": "simp [round]", "annotated_tactic": ["simp [<a>round</a>]", [{"full_name": "round", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [1436, 5], "def_end_pos": [1436, 10]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\n\u22a2 round 0 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean", "full_name": "Polynomial.coeff_toSubring", "start": [426, 1], "end": [433, 8], "traced_tactics": [{"tactic": "simp only [toSubring, coeff_monomial, finset_sum_coeff, mem_support_iff, Finset.sum_ite_eq',\n  Ne.def, ite_not]", "annotated_tactic": ["simp only [<a>toSubring</a>, <a>coeff_monomial</a>, <a>finset_sum_coeff</a>, <a>mem_support_iff</a>, <a>Finset.sum_ite_eq'</a>,\n    <a>Ne.def</a>, <a>ite_not</a>]", [{"full_name": "Polynomial.toSubring", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Basic.lean", "def_pos": [415, 5], "def_end_pos": [415, 14]}, {"full_name": "Polynomial.coeff_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [688, 9], "def_end_pos": [688, 23]}, {"full_name": "Polynomial.finset_sum_coeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [108, 9], "def_end_pos": [108, 25]}, {"full_name": "Polynomial.mem_support_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [733, 9], "def_end_pos": [733, 24]}, {"full_name": "Finset.sum_ite_eq'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1241, 3], "def_end_pos": [1241, 14]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "ite_not", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [46, 17], "def_end_pos": [46, 24]}]], "state_before": "R : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\nn : \u2115\n\u22a2 \u2191(coeff (toSubring p T hp) n) = coeff p n", "state_after": "R : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\nn : \u2115\n\u22a2 \u2191(if coeff p n = 0 then 0 else { val := coeff p n, property := \u22ef }) = coeff p n"}, {"tactic": "split_ifs with h", "annotated_tactic": ["split_ifs with h", []], "state_before": "R : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\nn : \u2115\n\u22a2 \u2191(if coeff p n = 0 then 0 else { val := coeff p n, property := \u22ef }) = coeff p n", "state_after": "case pos\nR : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\nn : \u2115\nh : coeff p n = 0\n\u22a2 \u21910 = coeff p n\n\ncase neg\nR : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\nn : \u2115\nh : \u00accoeff p n = 0\n\u22a2 \u2191{ val := coeff p n, property := \u22ef } = coeff p n"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "case pos\nR : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\nn : \u2115\nh : coeff p n = 0\n\u22a2 \u21910 = coeff p n", "state_after": "case pos\nR : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\nn : \u2115\nh : coeff p n = 0\n\u22a2 \u21910 = 0"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case pos\nR : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\nn : \u2115\nh : coeff p n = 0\n\u22a2 \u21910 = 0", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case neg\nR : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\nn : \u2115\nh : \u00accoeff p n = 0\n\u22a2 \u2191{ val := coeff p n, property := \u22ef } = coeff p n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Fin.lean", "full_name": "Fin.prod_univ_one", "start": [106, 1], "end": [106, 81], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 1 \u2192 \u03b2\n\u22a2 \u220f i : Fin 1, f i = f 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "RingHom.ker_coe_equiv", "start": [2179, 1], "end": [2180, 70], "traced_tactics": [{"tactic": "simpa only [\u2190 injective_iff_ker_eq_bot] using EquivLike.injective f", "annotated_tactic": ["simpa only [\u2190 <a>injective_iff_ker_eq_bot</a>] using <a>EquivLike.injective</a> f", [{"full_name": "RingHom.injective_iff_ker_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [2169, 9], "def_end_pos": [2169, 33]}, {"full_name": "EquivLike.injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/FunLike/Equiv.lean", "def_pos": [167, 19], "def_end_pos": [167, 28]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nF : Type u_1\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : FunLike F R S\nrc : RingHomClass F R S\nf\u271d : F\nf : R \u2243+* S\n\u22a2 ker \u2191f = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.zipWithLeft'_eq_zipWithLeft'TR", "start": [1261, 10], "end": [1268, 28], "traced_tactics": [{"tactic": "funext \u03b1 \u03b2 \u03b3 f as bs", "annotated_tactic": ["funext \u03b1 \u03b2 \u03b3 f as bs", []], "state_before": "\u22a2 @zipWithLeft' = @zipWithLeft'TR", "state_after": "case h.h.h.h.h.h\n\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\nas : List \u03b1\nbs : List \u03b2\n\u22a2 zipWithLeft' f as bs = zipWithLeft'TR f as bs"}, {"tactic": "simp [zipWithLeft'TR]", "annotated_tactic": ["simp [<a>zipWithLeft'TR</a>]", [{"full_name": "List.zipWithLeft'TR", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1253, 15], "def_end_pos": [1253, 29]}]], "state_before": "case h.h.h.h.h.h\n\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\nas : List \u03b1\nbs : List \u03b2\n\u22a2 zipWithLeft' f as bs = zipWithLeft'TR f as bs", "state_after": "case h.h.h.h.h.h\n\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\nas : List \u03b1\nbs : List \u03b2\n\u22a2 zipWithLeft' f as bs = zipWithLeft'TR.go f as bs #[]"}, {"tactic": "simp [zipWithLeft'TR, go]", "annotated_tactic": ["simp [<a>zipWithLeft'TR</a>, go]", [{"full_name": "List.zipWithLeft'TR", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1253, 15], "def_end_pos": [1253, 29]}]], "state_before": "case h.h.h.h.h.h\n\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\nas : List \u03b1\nbs : List \u03b2\n\u22a2 zipWithLeft' f as bs = zipWithLeft'TR.go f as bs #[]", "state_after": "no goals"}, {"tactic": "simp [zipWithLeft'TR.go]", "annotated_tactic": ["simp [<a>zipWithLeft'TR.go</a>]", [{"full_name": "List.zipWithLeft'TR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1256, 3], "def_end_pos": [1256, 5]}]], "state_before": "\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\nas : List \u03b1\nbs\u271d : List \u03b2\nacc : Array \u03b3\nbs : List \u03b2\n\u22a2 zipWithLeft'TR.go f [] bs acc =\n    match zipWithLeft' f [] bs with\n    | (l, r) => (Array.toList acc ++ l, r)", "state_after": "no goals"}, {"tactic": "simp [zipWithLeft'TR.go, Array.foldl_data_eq_map]", "annotated_tactic": ["simp [<a>zipWithLeft'TR.go</a>, <a>Array.foldl_data_eq_map</a>]", [{"full_name": "List.zipWithLeft'TR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1256, 3], "def_end_pos": [1256, 5]}, {"full_name": "Array.foldl_data_eq_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [172, 9], "def_end_pos": [172, 26]}]], "state_before": "\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\nas : List \u03b1\nbs : List \u03b2\nacc : Array \u03b3\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\n\u22a2 zipWithLeft'TR.go f (head\u271d :: tail\u271d) [] acc =\n    match zipWithLeft' f (head\u271d :: tail\u271d) [] with\n    | (l, r) => (Array.toList acc ++ l, r)", "state_after": "no goals"}, {"tactic": "simp [zipWithLeft'TR.go, go _ as bs]", "annotated_tactic": ["simp [<a>zipWithLeft'TR.go</a>, go _ as bs]", [{"full_name": "List.zipWithLeft'TR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1256, 3], "def_end_pos": [1256, 5]}]], "state_before": "\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03b3 : Type u_1\nf : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\nas\u271d : List \u03b1\nbs\u271d : List \u03b2\nacc : Array \u03b3\na : \u03b1\nas : List \u03b1\nb : \u03b2\nbs : List \u03b2\n\u22a2 zipWithLeft'TR.go f (a :: as) (b :: bs) acc =\n    match zipWithLeft' f (a :: as) (b :: bs) with\n    | (l, r) => (Array.toList acc ++ l, r)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Lift.lean", "full_name": "Filter.lift_lift'_same_eq_lift'", "start": [365, 1], "end": [369, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Maps.lean", "full_name": "IsClosedMap.lift'_closure_map_eq", "start": [519, 1], "end": [525, 57], "traced_tactics": [{"tactic": "rw [map_lift'_eq2 (monotone_closure Y), map_lift'_eq (monotone_closure X)]", "annotated_tactic": ["rw [<a>map_lift'_eq2</a> (<a>monotone_closure</a> Y), <a>map_lift'_eq</a> (<a>monotone_closure</a> X)]", [{"full_name": "Filter.map_lift'_eq2", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Lift.lean", "def_pos": [304, 9], "def_end_pos": [304, 22]}, {"full_name": "monotone_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [440, 9], "def_end_pos": [440, 25]}, {"full_name": "Filter.map_lift'_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Lift.lean", "def_pos": [294, 9], "def_end_pos": [294, 21]}, {"full_name": "monotone_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [440, 9], "def_end_pos": [440, 25]}]], "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf_closed : IsClosedMap f\nf_cont : Continuous f\nF : Filter X\n\u22a2 Filter.lift' (map f F) closure = map f (Filter.lift' F closure)", "state_after": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf_closed : IsClosedMap f\nf_cont : Continuous f\nF : Filter X\n\u22a2 Filter.lift' F (closure \u2218 image f) = Filter.lift' F (image f \u2218 closure)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf_closed : IsClosedMap f\nf_cont : Continuous f\nF : Filter X\n\u22a2 Filter.lift' F (closure \u2218 image f) = Filter.lift' F (image f \u2218 closure)", "state_after": "case e_h\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf_closed : IsClosedMap f\nf_cont : Continuous f\nF : Filter X\n\u22a2 closure \u2218 image f = image f \u2218 closure"}, {"tactic": "ext s : 1", "annotated_tactic": ["ext s : 1", []], "state_before": "case e_h\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf_closed : IsClosedMap f\nf_cont : Continuous f\nF : Filter X\n\u22a2 closure \u2218 image f = image f \u2218 closure", "state_after": "case e_h.h\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf_closed : IsClosedMap f\nf_cont : Continuous f\nF : Filter X\ns : Set X\n\u22a2 (closure \u2218 image f) s = (image f \u2218 closure) s"}, {"tactic": "exact f_closed.closure_image_eq_of_continuous f_cont s", "annotated_tactic": ["exact f_closed.closure_image_eq_of_continuous f_cont s", []], "state_before": "case e_h.h\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf_closed : IsClosedMap f\nf_cont : Continuous f\nF : Filter X\ns : Set X\n\u22a2 (closure \u2218 image f) s = (image f \u2218 closure) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Defs.lean", "full_name": "AddLECancellable.le_tsub_of_add_le_left", "start": [210, 11], "end": [211, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/OrdConnected.lean", "full_name": "Set.ordConnected_iff_uIcc_subset", "start": [321, 1], "end": [323, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/PiSystem.lean", "full_name": "isPiSystem_Ioi", "start": [149, 1], "end": [150, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "Antitone.ne_of_lt_of_lt_nat", "start": [1144, 1], "end": [1147, 74], "traced_tactics": [{"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Preorder \u03b1\nf : \u2115 \u2192 \u03b1\nhf : Antitone f\nn : \u2115\nx : \u03b1\nh1 : f (n + 1) < x\nh2 : x < f n\na : \u2115\n\u22a2 f a \u2260 x", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Preorder \u03b1\nf : \u2115 \u2192 \u03b1\nhf : Antitone f\nn a : \u2115\nh1 : f (n + 1) < f a\nh2 : f a < f n\n\u22a2 False"}, {"tactic": "exact (hf.reflect_lt h2).not_le (Nat.le_of_lt_succ <| hf.reflect_lt h1)", "annotated_tactic": ["exact (hf.reflect_lt h2).<a>not_le</a> (<a>Nat.le_of_lt_succ</a> <| hf.reflect_lt h1)", [{"full_name": "LT.lt.not_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [348, 7], "def_end_pos": [348, 19]}, {"full_name": "Nat.le_of_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1697, 9], "def_end_pos": [1697, 26]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Preorder \u03b1\nf : \u2115 \u2192 \u03b1\nhf : Antitone f\nn a : \u2115\nh1 : f (n + 1) < f a\nh2 : f a < f n\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Instances.lean", "full_name": "Set.Icc.mk_one", "start": [74, 1], "end": [75, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "isOpen_induced_eq", "start": [849, 1], "end": [851, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.empty_ssubset", "start": [625, 1], "end": [626, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Inseparable.lean", "full_name": "Specializes.mem_closed", "start": [114, 1], "end": [115, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Function/Indicator.lean", "full_name": "Set.mulIndicator_image", "start": [253, 1], "end": [255, 57], "traced_tactics": [{"tactic": "rw [\u2190 mulIndicator_comp_right, preimage_image_eq _ hg]", "annotated_tactic": ["rw [\u2190 <a>mulIndicator_comp_right</a>, <a>preimage_image_eq</a> _ hg]", [{"full_name": "Set.mulIndicator_comp_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [245, 9], "def_end_pos": [245, 32]}, {"full_name": "Set.preimage_image_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [493, 9], "def_end_pos": [493, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns\u271d t : Set \u03b1\nf\u271d g\u271d : \u03b1 \u2192 M\na : \u03b1\ns : Set \u03b1\nf : \u03b2 \u2192 M\ng : \u03b1 \u2192 \u03b2\nhg : Injective g\nx : \u03b1\n\u22a2 mulIndicator (g '' s) f (g x) = mulIndicator s (f \u2218 g) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/EMetricSpace/Lipschitz.lean", "full_name": "LipschitzWith.of_edist_le", "start": [147, 11], "end": [148, 56], "traced_tactics": [{"tactic": "simp only [ENNReal.coe_one, one_mul, h]", "annotated_tactic": ["simp only [<a>ENNReal.coe_one</a>, <a>one_mul</a>, h]", [{"full_name": "ENNReal.coe_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [244, 28], "def_end_pos": [244, 35]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b2\nx\u271d y\u271d : \u03b1\nr : \u211d\u22650\u221e\nh : \u2200 (x y : \u03b1), edist (f x) (f y) \u2264 edist x y\nx y : \u03b1\n\u22a2 edist (f x) (f y) \u2264 \u21911 * edist x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Linear.lean", "full_name": "LinearMap.deriv", "start": [95, 11], "end": [96, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.comap_eval_neBot_iff'", "start": [2579, 1], "end": [2585, 41], "traced_tactics": [{"tactic": "cases' isEmpty_or_nonempty (\u2200 j, \u03b1 j) with H H", "annotated_tactic": ["cases' <a>isEmpty_or_nonempty</a> (\u2200 j, \u03b1 j) with H H", [{"full_name": "isEmpty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [215, 9], "def_end_pos": [215, 28]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\u271d\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1\u271d \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\u271d\nt : Set \u03b2\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\ni : \u03b9\nf : Filter (\u03b1 i)\n\u22a2 NeBot (comap (eval i) f) \u2194 (\u2200 (j : \u03b9), Nonempty (\u03b1 j)) \u2227 NeBot f", "state_after": "case inl\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\u271d\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1\u271d \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\u271d\nt : Set \u03b2\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\ni : \u03b9\nf : Filter (\u03b1 i)\nH : IsEmpty ((j : \u03b9) \u2192 \u03b1 j)\n\u22a2 NeBot (comap (eval i) f) \u2194 (\u2200 (j : \u03b9), Nonempty (\u03b1 j)) \u2227 NeBot f\n\ncase inr\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\u271d\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1\u271d \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\u271d\nt : Set \u03b2\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\ni : \u03b9\nf : Filter (\u03b1 i)\nH : Nonempty ((j : \u03b9) \u2192 \u03b1 j)\n\u22a2 NeBot (comap (eval i) f) \u2194 (\u2200 (j : \u03b9), Nonempty (\u03b1 j)) \u2227 NeBot f"}, {"tactic": "rw [filter_eq_bot_of_isEmpty (f.comap _), \u2190 not_iff_not]", "annotated_tactic": ["rw [<a>filter_eq_bot_of_isEmpty</a> (f.comap _), \u2190 <a>not_iff_not</a>]", [{"full_name": "Filter.filter_eq_bot_of_isEmpty", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [731, 9], "def_end_pos": [731, 33]}, {"full_name": "not_iff_not", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [449, 9], "def_end_pos": [449, 20]}]], "state_before": "case inl\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\u271d\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1\u271d \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\u271d\nt : Set \u03b2\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\ni : \u03b9\nf : Filter (\u03b1 i)\nH : IsEmpty ((j : \u03b9) \u2192 \u03b1 j)\n\u22a2 NeBot (comap (eval i) f) \u2194 (\u2200 (j : \u03b9), Nonempty (\u03b1 j)) \u2227 NeBot f", "state_after": "case inl\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\u271d\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1\u271d \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\u271d\nt : Set \u03b2\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\ni : \u03b9\nf : Filter (\u03b1 i)\nH : IsEmpty ((j : \u03b9) \u2192 \u03b1 j)\n\u22a2 \u00acNeBot \u22a5 \u2194 \u00ac((\u2200 (j : \u03b9), Nonempty (\u03b1 j)) \u2227 NeBot f)"}, {"tactic": "simp [\u2190 Classical.nonempty_pi]", "annotated_tactic": ["simp [\u2190 <a>Classical.nonempty_pi</a>]", [{"full_name": "Classical.nonempty_pi", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nonempty.lean", "def_pos": [168, 9], "def_end_pos": [168, 30]}]], "state_before": "case inl\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\u271d\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1\u271d \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\u271d\nt : Set \u03b2\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\ni : \u03b9\nf : Filter (\u03b1 i)\nH : IsEmpty ((j : \u03b9) \u2192 \u03b1 j)\n\u22a2 \u00acNeBot \u22a5 \u2194 \u00ac((\u2200 (j : \u03b9), Nonempty (\u03b1 j)) \u2227 NeBot f)", "state_after": "no goals"}, {"tactic": "have : \u2200 j, Nonempty (\u03b1 j) := Classical.nonempty_pi.1 H", "annotated_tactic": ["have : \u2200 j, <a>Nonempty</a> (\u03b1 j) := <a>Classical.nonempty_pi</a>.1 H", [{"full_name": "Nonempty", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [704, 17], "def_end_pos": [704, 25]}, {"full_name": "Classical.nonempty_pi", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nonempty.lean", "def_pos": [168, 9], "def_end_pos": [168, 30]}]], "state_before": "case inr\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\u271d\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1\u271d \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\u271d\nt : Set \u03b2\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\ni : \u03b9\nf : Filter (\u03b1 i)\nH : Nonempty ((j : \u03b9) \u2192 \u03b1 j)\n\u22a2 NeBot (comap (eval i) f) \u2194 (\u2200 (j : \u03b9), Nonempty (\u03b1 j)) \u2227 NeBot f", "state_after": "case inr\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\u271d\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1\u271d \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\u271d\nt : Set \u03b2\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\ni : \u03b9\nf : Filter (\u03b1 i)\nH : Nonempty ((j : \u03b9) \u2192 \u03b1 j)\nthis : \u2200 (j : \u03b9), Nonempty (\u03b1 j)\n\u22a2 NeBot (comap (eval i) f) \u2194 (\u2200 (j : \u03b9), Nonempty (\u03b1 j)) \u2227 NeBot f"}, {"tactic": "simp [comap_neBot_iff_frequently, *]", "annotated_tactic": ["simp [<a>comap_neBot_iff_frequently</a>, *]", [{"full_name": "Filter.comap_neBot_iff_frequently", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2522, 9], "def_end_pos": [2522, 35]}]], "state_before": "case inr\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\u271d\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1\u271d \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\u271d\nt : Set \u03b2\n\u03b9 : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\ni : \u03b9\nf : Filter (\u03b1 i)\nH : Nonempty ((j : \u03b9) \u2192 \u03b1 j)\nthis : \u2200 (j : \u03b9), Nonempty (\u03b1 j)\n\u22a2 NeBot (comap (eval i) f) \u2194 (\u2200 (j : \u03b9), Nonempty (\u03b1 j)) \u2227 NeBot f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "QuotientGroup.isOpenMap_coe", "start": [983, 1], "end": [987, 79], "traced_tactics": [{"tactic": "intro s s_op", "annotated_tactic": ["intro s s_op", []], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nN : Subgroup G\nn : Subgroup.Normal N\n\u22a2 IsOpenMap mk", "state_after": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nN : Subgroup G\nn : Subgroup.Normal N\ns : Set G\ns_op : IsOpen s\n\u22a2 IsOpen (mk '' s)"}, {"tactic": "change IsOpen (((\u2191) : G \u2192 G \u29f8 N) \u207b\u00b9' ((\u2191) '' s))", "annotated_tactic": ["change <a>IsOpen</a> (((\u2191) : G \u2192 G \u29f8 N) \u207b\u00b9' ((\u2191) '' s))", [{"full_name": "IsOpen", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [85, 5], "def_end_pos": [85, 11]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nN : Subgroup G\nn : Subgroup.Normal N\ns : Set G\ns_op : IsOpen s\n\u22a2 IsOpen (mk '' s)", "state_after": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nN : Subgroup G\nn : Subgroup.Normal N\ns : Set G\ns_op : IsOpen s\n\u22a2 IsOpen (mk \u207b\u00b9' (mk '' s))"}, {"tactic": "rw [QuotientGroup.preimage_image_mk N s]", "annotated_tactic": ["rw [<a>QuotientGroup.preimage_image_mk</a> N s]", [{"full_name": "QuotientGroup.preimage_image_mk", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Coset.lean", "def_pos": [545, 9], "def_end_pos": [545, 26]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nN : Subgroup G\nn : Subgroup.Normal N\ns : Set G\ns_op : IsOpen s\n\u22a2 IsOpen (mk \u207b\u00b9' (mk '' s))", "state_after": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nN : Subgroup G\nn : Subgroup.Normal N\ns : Set G\ns_op : IsOpen s\n\u22a2 IsOpen (\u22c3 x, (fun x_1 => x_1 * \u2191x) \u207b\u00b9' s)"}, {"tactic": "exact isOpen_iUnion fun n => (continuous_mul_right _).isOpen_preimage s s_op", "annotated_tactic": ["exact <a>isOpen_iUnion</a> fun n => (<a>continuous_mul_right</a> _).<a>isOpen_preimage</a> s s_op", [{"full_name": "isOpen_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 22]}, {"full_name": "continuous_mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Monoid.lean", "def_pos": [102, 9], "def_end_pos": [102, 29]}, {"full_name": "Continuous.isOpen_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [140, 3], "def_end_pos": [140, 18]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : TopologicalGroup G\nN : Subgroup G\nn : Subgroup.Normal N\ns : Set G\ns_op : IsOpen s\n\u22a2 IsOpen (\u22c3 x, (fun x_1 => x_1 * \u2191x) \u207b\u00b9' s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Noetherian.lean", "full_name": "Module.Finite.of_injective", "start": [162, 1], "end": [164, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UnitInterval.lean", "full_name": "iccHomeoI_apply_coe", "start": [344, 1], "end": [346, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/Result.lean", "full_name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq", "start": [171, 1], "end": [172, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "full_name": "ConjAct.ofConjAct_one", "start": [115, 1], "end": [116, 6], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Test.lean", "full_name": "amc12a_2021_p3", "start": [1142, 1], "end": [1147, 34], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "x y : \u2115\nh\u2080 : x + y = 17402\nh\u2081 : 10 \u2223 x\nh\u2082 : x / 10 = y\n\u22a2 \u2191x - \u2191y = 14238", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.real_smul_eq_coe_smul", "start": [110, 1], "end": [111, 86], "traced_tactics": [{"tactic": "rw [IsROrC.ofReal_alg, smul_one_smul]", "annotated_tactic": ["rw [<a>IsROrC.ofReal_alg</a>, <a>smul_one_smul</a>]", [{"full_name": "IsROrC.ofReal_alg", "def_path": ".lake/packages/mathlib/Mathlib/Data/IsROrC/Basic.lean", "def_pos": [102, 9], "def_end_pos": [102, 19]}, {"full_name": "smul_one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [683, 9], "def_end_pos": [683, 22]}]], "state_before": "K : Type u_1\nE : Type u_2\ninst\u271d\u2074 : IsROrC K\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module K E\ninst\u271d\u00b9 : Module \u211d E\ninst\u271d : IsScalarTower \u211d K E\nr : \u211d\nx : E\n\u22a2 r \u2022 x = \u2191r \u2022 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.le_untop'_iff", "start": [950, 1], "end": [952, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "full_name": "CategoryTheory.Limits.WidePullback.\u03c0_arrow", "start": [345, 1], "end": [346, 84], "traced_tactics": [{"tactic": "apply limit.w (WidePullbackShape.wideCospan _ _ _) (WidePullbackShape.Hom.term j)", "annotated_tactic": ["apply <a>limit.w</a> (<a>WidePullbackShape.wideCospan</a> _ _ _) (<a>WidePullbackShape.Hom.term</a> j)", [{"full_name": "CategoryTheory.Limits.limit.w", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/HasLimits.lean", "def_pos": [170, 9], "def_end_pos": [170, 16]}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.wideCospan", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "def_pos": [122, 5], "def_end_pos": [122, 15]}, {"full_name": "CategoryTheory.Limits.WidePullbackShape.Hom.term", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "def_pos": [62, 5], "def_end_pos": [62, 9]}]], "state_before": "J : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nj : J\n\u22a2 \u03c0 arrows j \u226b arrows j = base arrows", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Group/Arithmetic.lean", "full_name": "aemeasurable_inv_iff", "start": [485, 1], "end": [487, 65], "traced_tactics": [{"tactic": "simpa only [inv_inv] using h.inv", "annotated_tactic": ["simpa only [<a>inv_inv</a>] using h.inv", [{"full_name": "inv_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 16]}]], "state_before": "\u03b1\u271d : Type u_1\nG\u271d : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u2075 : Inv G\u271d\ninst\u271d\u2074 : MeasurableSpace G\u271d\ninst\u271d\u00b3 : MeasurableInv G\u271d\nm : MeasurableSpace \u03b1\nf\u271d : \u03b1 \u2192 G\u271d\n\u03bc : Measure \u03b1\nG : Type u_4\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : MeasurableSpace G\ninst\u271d : MeasurableInv G\nf : \u03b1 \u2192 G\nh : AEMeasurable (fun x => (f x)\u207b\u00b9) \u03bc\n\u22a2 AEMeasurable f \u03bc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Iso.lean", "full_name": "CategoryTheory.IsIso.inv_eq_inv", "start": [473, 1], "end": [474, 37], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "imo_1966_p5", "start": [945, 1], "end": [953, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "x a : \u2115 \u2192 \u211d\nh\u2080 : a 1 \u2260 a 2\nh\u2081 : a 1 \u2260 a 3\nh\u2082 : a 1 \u2260 a 4\nh\u2083 : a 2 \u2260 a 3\nh\u2084 : a 2 \u2260 a 4\nh\u2085 : a 3 \u2260 a 4\nh\u2086 : a 1 > a 2\nh\u2087 : a 2 > a 3\nh\u2088 : a 3 > a 4\nh\u2089 : |a 1 - a 2| * x 2 + |a 1 - a 3| * x 3 + |a 1 - a 4| * x 4 = 1\nh\u2081\u2080 : |a 2 - a 1| * x 1 + |a 2 - a 3| * x 3 + |a 2 - a 4| * x 4 = 1\nh\u2081\u2081 : |a 3 - a 1| * x 1 + |a 3 - a 2| * x 2 + |a 3 - a 4| * x 4 = 1\nh\u2081\u2082 : |a 4 - a 1| * x 1 + |a 4 - a 2| * x 2 + |a 4 - a 3| * x 3 = 1\n\u22a2 x 2 = 0 \u2227 x 3 = 0 \u2227 x 1 = 1 / |a 1 - a 4| \u2227 x 4 = 1 / |a 1 - a 4|", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "toIcoMod_add_left", "start": [491, 1], "end": [492, 36], "traced_tactics": [{"tactic": "rw [add_comm, toIcoMod_add_right]", "annotated_tactic": ["rw [<a>add_comm</a>, <a>toIcoMod_add_right</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "toIcoMod_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [471, 9], "def_end_pos": [471, 27]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b\u271d c : \u03b1\nn : \u2124\na b : \u03b1\n\u22a2 toIcoMod hp a (p + b) = toIcoMod hp a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Add.lean", "full_name": "HasFDerivWithinAt.add_const", "start": [188, 8], "end": [190, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "Continuous.isOpen_mulSupport", "start": [405, 1], "end": [407, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Fin.lean", "full_name": "finSuccEquiv_succ", "start": [201, 1], "end": [202, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Hom.lean", "full_name": "MulSemiringActionHom.coe_fn_coe", "start": [523, 1], "end": [524, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "IsGLB.exists_between", "start": [1148, 1], "end": [1150, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Module.lean", "full_name": "imaginaryPart_ofReal", "start": [581, 1], "end": [583, 52], "traced_tactics": [{"tactic": "ext1", "annotated_tactic": ["ext1", []], "state_before": "A : Type u_1\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\nr : \u211d\n\u22a2 \u2111 \u2191r = 0", "state_after": "case a\nA : Type u_1\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\nr : \u211d\n\u22a2 \u2191(\u2111 \u2191r) = \u21910"}, {"tactic": "simp [imaginaryPart_apply_coe, conj_ofReal]", "annotated_tactic": ["simp [<a>imaginaryPart_apply_coe</a>, <a>conj_ofReal</a>]", [{"full_name": "imaginaryPart_apply_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Module.lean", "def_pos": [460, 9], "def_end_pos": [460, 32]}, {"full_name": "Complex.conj_ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [549, 9], "def_end_pos": [549, 20]}]], "state_before": "case a\nA : Type u_1\ninst\u271d\u00b3 : AddCommGroup A\ninst\u271d\u00b2 : Module \u2102 A\ninst\u271d\u00b9 : StarAddMonoid A\ninst\u271d : StarModule \u2102 A\nr : \u211d\n\u22a2 \u2191(\u2111 \u2191r) = \u21910", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Inv.lean", "full_name": "ENNReal.add_thirds", "start": [463, 1], "end": [464, 78], "traced_tactics": [{"tactic": "rw [div_eq_mul_inv, \u2190 mul_add, \u2190 mul_add, inv_three_add_inv_three, mul_one]", "annotated_tactic": ["rw [<a>div_eq_mul_inv</a>, \u2190 <a>mul_add</a>, \u2190 <a>mul_add</a>, <a>inv_three_add_inv_three</a>, <a>mul_one</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "ENNReal.inv_three_add_inv_three", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Inv.lean", "def_pos": [452, 9], "def_end_pos": [452, 32]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "a\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\na : \u211d\u22650\u221e\n\u22a2 a / 3 + a / 3 + a / 3 = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/EraseLead.lean", "full_name": "Polynomial.card_support_eq_two", "start": [434, 1], "end": [444, 45], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, _\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, _\u27e9", []], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\n\u22a2 (support f).card = 2 \u2194 \u2203 k m, \u2203 (_ : k < m), \u2203 x y, \u2203 (_ : x \u2260 0) (_ : y \u2260 0), f = C x * X ^ k + C y * X ^ m", "state_after": "case refine'_1\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nh : (support f).card = 2\n\u22a2 \u2203 k m, \u2203 (_ : k < m), \u2203 x y, \u2203 (_ : x \u2260 0) (_ : y \u2260 0), f = C x * X ^ k + C y * X ^ m\n\ncase refine'_2\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\n\u22a2 (\u2203 k m, \u2203 (_ : k < m), \u2203 x y, \u2203 (_ : x \u2260 0) (_ : y \u2260 0), f = C x * X ^ k + C y * X ^ m) \u2192 (support f).card = 2"}, {"tactic": "obtain \u27e8k, x, hk, hx, rfl\u27e9 := card_support_eq.mp h", "annotated_tactic": ["obtain \u27e8k, x, hk, hx, rfl\u27e9 := card_support_eq.mp h", []], "state_before": "case refine'_1\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nh : (support f).card = 2\n\u22a2 \u2203 k m, \u2203 (_ : k < m), \u2203 x y, \u2203 (_ : x \u2260 0) (_ : y \u2260 0), f = C x * X ^ k + C y * X ^ m", "state_after": "case refine'_1.intro.intro.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nk : Fin 2 \u2192 \u2115\nx : Fin 2 \u2192 R\nhk : StrictMono k\nhx : \u2200 (i : Fin 2), x i \u2260 0\nh : (support (\u2211 i : Fin 2, C (x i) * X ^ k i)).card = 2\n\u22a2 \u2203 k_1 m,\n    \u2203 (_ : k_1 < m),\n      \u2203 x_1 y, \u2203 (_ : x_1 \u2260 0) (_ : y \u2260 0), \u2211 i : Fin 2, C (x i) * X ^ k i = C x_1 * X ^ k_1 + C y * X ^ m"}, {"tactic": "refine' \u27e8k 0, k 1, hk Nat.zero_lt_one, x 0, x 1, hx 0, hx 1, _\u27e9", "annotated_tactic": ["refine' \u27e8k 0, k 1, hk <a>Nat.zero_lt_one</a>, x 0, x 1, hx 0, hx 1, _\u27e9", [{"full_name": "Nat.zero_lt_one", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [429, 19], "def_end_pos": [429, 30]}]], "state_before": "case refine'_1.intro.intro.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nk : Fin 2 \u2192 \u2115\nx : Fin 2 \u2192 R\nhk : StrictMono k\nhx : \u2200 (i : Fin 2), x i \u2260 0\nh : (support (\u2211 i : Fin 2, C (x i) * X ^ k i)).card = 2\n\u22a2 \u2203 k_1 m,\n    \u2203 (_ : k_1 < m),\n      \u2203 x_1 y, \u2203 (_ : x_1 \u2260 0) (_ : y \u2260 0), \u2211 i : Fin 2, C (x i) * X ^ k i = C x_1 * X ^ k_1 + C y * X ^ m", "state_after": "case refine'_1.intro.intro.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nk : Fin 2 \u2192 \u2115\nx : Fin 2 \u2192 R\nhk : StrictMono k\nhx : \u2200 (i : Fin 2), x i \u2260 0\nh : (support (\u2211 i : Fin 2, C (x i) * X ^ k i)).card = 2\n\u22a2 \u2211 i : Fin 2, C (x i) * X ^ k i = C (x 0) * X ^ k 0 + C (x 1) * X ^ k 1"}, {"tactic": "rw [Fin.sum_univ_castSucc, Fin.sum_univ_one]", "annotated_tactic": ["rw [<a>Fin.sum_univ_castSucc</a>, <a>Fin.sum_univ_one</a>]", [{"full_name": "Fin.sum_univ_castSucc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [90, 3], "def_end_pos": [90, 14]}, {"full_name": "Fin.sum_univ_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [105, 15], "def_end_pos": [105, 27]}]], "state_before": "case refine'_1.intro.intro.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nk : Fin 2 \u2192 \u2115\nx : Fin 2 \u2192 R\nhk : StrictMono k\nhx : \u2200 (i : Fin 2), x i \u2260 0\nh : (support (\u2211 i : Fin 2, C (x i) * X ^ k i)).card = 2\n\u22a2 \u2211 i : Fin 2, C (x i) * X ^ k i = C (x 0) * X ^ k 0 + C (x 1) * X ^ k 1", "state_after": "case refine'_1.intro.intro.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nk : Fin 2 \u2192 \u2115\nx : Fin 2 \u2192 R\nhk : StrictMono k\nhx : \u2200 (i : Fin 2), x i \u2260 0\nh : (support (\u2211 i : Fin 2, C (x i) * X ^ k i)).card = 2\n\u22a2 C (x (Fin.castSucc 0)) * X ^ k (Fin.castSucc 0) + C (x (Fin.last 1)) * X ^ k (Fin.last 1) =\n    C (x 0) * X ^ k 0 + C (x 1) * X ^ k 1"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case refine'_1.intro.intro.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nk : Fin 2 \u2192 \u2115\nx : Fin 2 \u2192 R\nhk : StrictMono k\nhx : \u2200 (i : Fin 2), x i \u2260 0\nh : (support (\u2211 i : Fin 2, C (x i) * X ^ k i)).card = 2\n\u22a2 C (x (Fin.castSucc 0)) * X ^ k (Fin.castSucc 0) + C (x (Fin.last 1)) * X ^ k (Fin.last 1) =\n    C (x 0) * X ^ k 0 + C (x 1) * X ^ k 1", "state_after": "no goals"}, {"tactic": "rintro \u27e8k, m, hkm, x, y, hx, hy, rfl\u27e9", "annotated_tactic": ["rintro \u27e8k, m, hkm, x, y, hx, hy, rfl\u27e9", []], "state_before": "case refine'_2\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\n\u22a2 (\u2203 k m, \u2203 (_ : k < m), \u2203 x y, \u2203 (_ : x \u2260 0) (_ : y \u2260 0), f = C x * X ^ k + C y * X ^ m) \u2192 (support f).card = 2", "state_after": "case refine'_2.intro.intro.intro.intro.intro.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nk m : \u2115\nhkm : k < m\nx y : R\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 (support (C x * X ^ k + C y * X ^ m)).card = 2"}, {"tactic": "exact card_support_binomial hkm.ne hx hy", "annotated_tactic": ["exact <a>card_support_binomial</a> hkm.ne hx hy", [{"full_name": "Polynomial.card_support_binomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [236, 9], "def_end_pos": [236, 30]}]], "state_before": "case refine'_2.intro.intro.intro.intro.intro.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nk m : \u2115\nhkm : k < m\nx y : R\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 (support (C x * X ^ k + C y * X ^ m)).card = 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.ediv_neg'", "start": [93, 1], "end": [95, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean", "full_name": "PowerSeries.monomial_eq_mk", "start": [185, 1], "end": [186, 48], "traced_tactics": [{"tactic": "rw [coeff_monomial, coeff_mk]", "annotated_tactic": ["rw [<a>coeff_monomial</a>, <a>coeff_mk</a>]", [{"full_name": "PowerSeries.coeff_monomial", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerSeries/Basic.lean", "def_pos": [178, 9], "def_end_pos": [178, 23]}, {"full_name": "PowerSeries.coeff_mk", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerSeries/Basic.lean", "def_pos": [174, 9], "def_end_pos": [174, 17]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nn : \u2115\na : R\nm : \u2115\n\u22a2 (coeff R m) ((monomial R n) a) = (coeff R m) (mk fun m => if m = n then a else 0)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "MonoidHom.map_range", "start": [2682, 1], "end": [2683, 70], "traced_tactics": [{"tactic": "rw [range_eq_map, range_eq_map]", "annotated_tactic": ["rw [<a>range_eq_map</a>, <a>range_eq_map</a>]", [{"full_name": "MonoidHom.range_eq_map", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [2631, 9], "def_end_pos": [2631, 21]}, {"full_name": "MonoidHom.range_eq_map", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [2631, 9], "def_end_pos": [2631, 21]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : Group G'\ninst\u271d\u00b3 : Group G''\nA : Type u_4\ninst\u271d\u00b2 : AddGroup A\nN : Type u_5\nP : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : Group P\nK : Subgroup G\ng : N \u2192* P\nf : G \u2192* N\n\u22a2 map g (range f) = range (comp g f)", "state_after": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : Group G'\ninst\u271d\u00b3 : Group G''\nA : Type u_4\ninst\u271d\u00b2 : AddGroup A\nN : Type u_5\nP : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : Group P\nK : Subgroup G\ng : N \u2192* P\nf : G \u2192* N\n\u22a2 map g (map f \u22a4) = map (comp g f) \u22a4"}, {"tactic": "exact (\u22a4 : Subgroup G).map_map g f", "annotated_tactic": ["exact (\u22a4 : <a>Subgroup</a> G).<a>map_map</a> g f", [{"full_name": "Subgroup", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [353, 11], "def_end_pos": [353, 19]}, {"full_name": "Subgroup.map_map", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1435, 9], "def_end_pos": [1435, 16]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : Group G'\ninst\u271d\u00b3 : Group G''\nA : Type u_4\ninst\u271d\u00b2 : AddGroup A\nN : Type u_5\nP : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : Group P\nK : Subgroup G\ng : N \u2192* P\nf : G \u2192* N\n\u22a2 map g (map f \u22a4) = map (comp g f) \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "Cycle.toFinset_eq_nil", "start": [817, 1], "end": [818, 36], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Cycle \u03b1\n\u22a2 \u2200 (a : List \u03b1), toFinset (Quotient.mk'' a) = \u2205 \u2194 Quotient.mk'' a = nil", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "Int.norm_cast_real", "start": [1916, 1], "end": [1917, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Basic.lean", "full_name": "lt_imp_lt_of_le_imp_le", "start": [497, 1], "end": [499, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.ne_zero_of_mem_nthRootsFinset", "start": [1005, 1], "end": [1013, 25], "traced_tactics": [{"tactic": "nontriviality R", "annotated_tactic": ["nontriviality R", []], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\n\u03b7 : R\nh\u03b7 : \u03b7 \u2208 nthRootsFinset n R\n\u22a2 \u03b7 \u2260 0", "state_after": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\n\u03b7 : R\nh\u03b7 : \u03b7 \u2208 nthRootsFinset n R\ninst\u271d : Nontrivial R\n\u22a2 \u03b7 \u2260 0"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\n\u03b7 : R\nh\u03b7 : \u03b7 \u2208 nthRootsFinset n R\ninst\u271d : Nontrivial R\n\u22a2 \u03b7 \u2260 0", "state_after": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : Nontrivial R\nh\u03b7 : 0 \u2208 nthRootsFinset n R\n\u22a2 False"}, {"tactic": "cases n with\n| zero =>\n  simp only [Nat.zero_eq, nthRootsFinset_zero, not_mem_empty] at h\u03b7\n| succ n =>\n  rw [mem_nthRootsFinset n.succ_pos, zero_pow n.succ_ne_zero] at h\u03b7\n  exact zero_ne_one h\u03b7", "annotated_tactic": ["cases n with\n  | <a>zero</a> =>\n    simp only [<a>Nat.zero_eq</a>, <a>nthRootsFinset_zero</a>, <a>not_mem_empty</a>] at h\u03b7\n  | <a>succ</a> n =>\n    rw [<a>mem_nthRootsFinset</a> n.succ_pos, <a>zero_pow</a> n.succ_ne_zero] at h\u03b7\n    exact <a>zero_ne_one</a> h\u03b7", [{"full_name": "Nat.zero", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1068, 5], "def_end_pos": [1068, 9]}, {"full_name": "Nat.zero_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [83, 17], "def_end_pos": [83, 24]}, {"full_name": "Polynomial.nthRootsFinset_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [992, 9], "def_end_pos": [992, 28]}, {"full_name": "Finset.not_mem_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [554, 9], "def_end_pos": [554, 22]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Polynomial.mem_nthRootsFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [985, 9], "def_end_pos": [985, 27]}, {"full_name": "zero_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [159, 15], "def_end_pos": [159, 23]}, {"full_name": "zero_ne_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [55, 15], "def_end_pos": [55, 26]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : Nontrivial R\nh\u03b7 : 0 \u2208 nthRootsFinset n R\n\u22a2 False", "state_after": "no goals"}, {"tactic": "simp only [Nat.zero_eq, nthRootsFinset_zero, not_mem_empty] at h\u03b7", "annotated_tactic": ["simp only [<a>Nat.zero_eq</a>, <a>nthRootsFinset_zero</a>, <a>not_mem_empty</a>] at h\u03b7", [{"full_name": "Nat.zero_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [83, 17], "def_end_pos": [83, 24]}, {"full_name": "Polynomial.nthRootsFinset_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [992, 9], "def_end_pos": [992, 28]}, {"full_name": "Finset.not_mem_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [554, 9], "def_end_pos": [554, 22]}]], "state_before": "case zero\nR : Type u\nS : Type v\nT : Type w\na b : R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : Nontrivial R\nh\u03b7 : 0 \u2208 nthRootsFinset Nat.zero R\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [mem_nthRootsFinset n.succ_pos, zero_pow n.succ_ne_zero] at h\u03b7", "annotated_tactic": ["rw [<a>mem_nthRootsFinset</a> n.succ_pos, <a>zero_pow</a> n.succ_ne_zero] at h\u03b7", [{"full_name": "Polynomial.mem_nthRootsFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [985, 9], "def_end_pos": [985, 27]}, {"full_name": "zero_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [159, 15], "def_end_pos": [159, 23]}]], "state_before": "case succ\nR : Type u\nS : Type v\nT : Type w\na b : R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : Nontrivial R\nn : \u2115\nh\u03b7 : 0 \u2208 nthRootsFinset (Nat.succ n) R\n\u22a2 False", "state_after": "case succ\nR : Type u\nS : Type v\nT : Type w\na b : R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : Nontrivial R\nn : \u2115\nh\u03b7 : 0 = 1\n\u22a2 False"}, {"tactic": "exact zero_ne_one h\u03b7", "annotated_tactic": ["exact <a>zero_ne_one</a> h\u03b7", [{"full_name": "zero_ne_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [55, 15], "def_end_pos": [55, 26]}]], "state_before": "case succ\nR : Type u\nS : Type v\nT : Type w\na b : R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : Nontrivial R\nn : \u2115\nh\u03b7 : 0 = 1\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.image_affine_Icc'", "start": [871, 1], "end": [875, 50], "traced_tactics": [{"tactic": "rw [image_mul_left_Icc' h, image_add_const_Icc]", "annotated_tactic": ["rw [<a>image_mul_left_Icc'</a> h, <a>image_add_const_Icc</a>]", [{"full_name": "Set.image_mul_left_Icc'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Interval.lean", "def_pos": [826, 9], "def_end_pos": [826, 28]}, {"full_name": "Set.image_add_const_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Monoid.lean", "def_pos": [88, 9], "def_end_pos": [88, 28]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\na\u271d a : \u03b1\nh : 0 < a\nb c d : \u03b1\n\u22a2 (fun x => x + b) '' ((fun x => a * x) '' Icc c d) = Icc (a * c + b) (a * d + b)", "state_after": "no goals"}, {"tactic": "rwa [Set.image_image] at this", "annotated_tactic": ["rwa [<a>Set.image_image</a>] at this", [{"full_name": "Set.image_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [271, 9], "def_end_pos": [271, 20]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\na\u271d a : \u03b1\nh : 0 < a\nb c d : \u03b1\nthis : (fun x => x + b) '' ((fun x => a * x) '' Icc c d) = Icc (a * c + b) (a * d + b)\n\u22a2 (fun x => a * x + b) '' Icc c d = Icc (a * c + b) (a * d + b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "HasFTaylorSeriesUpToOn.zero_eq'", "start": [196, 1], "end": [199, 37], "traced_tactics": [{"tactic": "rw [\u2190 h.zero_eq x hx]", "annotated_tactic": ["rw [\u2190 h.zero_eq x hx]", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nh : HasFTaylorSeriesUpToOn n f p s\nx : E\nhx : x \u2208 s\n\u22a2 p x 0 = (LinearIsometryEquiv.symm (continuousMultilinearCurryFin0 \ud835\udd5c E F)) (f x)", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nh : HasFTaylorSeriesUpToOn n f p s\nx : E\nhx : x \u2208 s\n\u22a2 p x 0 = (LinearIsometryEquiv.symm (continuousMultilinearCurryFin0 \ud835\udd5c E F)) (ContinuousMultilinearMap.uncurry0 (p x 0))"}, {"tactic": "exact (p x 0).uncurry0_curry0.symm", "annotated_tactic": ["exact (p x 0).uncurry0_curry0.symm", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nh : HasFTaylorSeriesUpToOn n f p s\nx : E\nhx : x \u2208 s\n\u22a2 p x 0 = (LinearIsometryEquiv.symm (continuousMultilinearCurryFin0 \ud835\udd5c E F)) (ContinuousMultilinearMap.uncurry0 (p x 0))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/PathConnected.lean", "full_name": "Continuous.path_eval", "start": [225, 1], "end": [227, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Linarith/Lemmas.lean", "full_name": "Linarith.le_of_le_of_eq", "start": [36, 1], "end": [37, 11], "traced_tactics": [{"tactic": "simp [*]", "annotated_tactic": ["simp [*]", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\na b : \u03b1\nha : a \u2264 0\nhb : b = 0\n\u22a2 a + b \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Setoid/Basic.lean", "full_name": "Setoid.sSup_eq_eqvGen", "start": [227, 1], "end": [233, 59], "traced_tactics": [{"tactic": "rw [eqvGen_eq]", "annotated_tactic": ["rw [<a>eqvGen_eq</a>]", [{"full_name": "Setoid.eqvGen_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Setoid/Basic.lean", "def_pos": [201, 9], "def_end_pos": [201, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Setoid \u03b1)\n\u22a2 sSup S = EqvGen.Setoid fun x y => \u2203 r \u2208 S, Rel r x y", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Setoid \u03b1)\n\u22a2 sSup S = sInf {s | \u2200 \u2983x y : \u03b1\u2984, (\u2203 r \u2208 S, Rel r x y) \u2192 Rel s x y}"}, {"tactic": "apply congr_arg sInf", "annotated_tactic": ["apply <a>congr_arg</a> <a>sInf</a>", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "InfSet.sInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [48, 3], "def_end_pos": [48, 7]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Setoid \u03b1)\n\u22a2 sSup S = sInf {s | \u2200 \u2983x y : \u03b1\u2984, (\u2203 r \u2208 S, Rel r x y) \u2192 Rel s x y}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Setoid \u03b1)\n\u22a2 upperBounds S = {s | \u2200 \u2983x y : \u03b1\u2984, (\u2203 r \u2208 S, Rel r x y) \u2192 Rel s x y}"}, {"tactic": "simp only [upperBounds, le_def, and_imp, exists_imp]", "annotated_tactic": ["simp only [<a>upperBounds</a>, <a>le_def</a>, <a>and_imp</a>, <a>exists_imp</a>]", [{"full_name": "upperBounds", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 16]}, {"full_name": "Setoid.le_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Setoid/Basic.lean", "def_pos": [74, 9], "def_end_pos": [74, 15]}, {"full_name": "and_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [108, 17], "def_end_pos": [108, 24]}, {"full_name": "exists_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [133, 9], "def_end_pos": [133, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Setoid \u03b1)\n\u22a2 upperBounds S = {s | \u2200 \u2983x y : \u03b1\u2984, (\u2203 r \u2208 S, Rel r x y) \u2192 Rel s x y}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Setoid \u03b1)\n\u22a2 {x | \u2200 \u2983a : Setoid \u03b1\u2984, a \u2208 S \u2192 \u2200 {x_1 y : \u03b1}, Rel a x_1 y \u2192 Rel x x_1 y} =\n    {s | \u2200 \u2983x y : \u03b1\u2984, \u2200 x_1 \u2208 S, Rel x_1 x y \u2192 Rel s x y}"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Setoid \u03b1)\n\u22a2 {x | \u2200 \u2983a : Setoid \u03b1\u2984, a \u2208 S \u2192 \u2200 {x_1 y : \u03b1}, Rel a x_1 y \u2192 Rel x x_1 y} =\n    {s | \u2200 \u2983x y : \u03b1\u2984, \u2200 x_1 \u2208 S, Rel x_1 x y \u2192 Rel s x y}", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Setoid \u03b1)\nx\u271d : Setoid \u03b1\n\u22a2 x\u271d \u2208 {x | \u2200 \u2983a : Setoid \u03b1\u2984, a \u2208 S \u2192 \u2200 {x_1 y : \u03b1}, Rel a x_1 y \u2192 Rel x x_1 y} \u2194\n    x\u271d \u2208 {s | \u2200 \u2983x y : \u03b1\u2984, \u2200 x_1 \u2208 S, Rel x_1 x y \u2192 Rel s x y}"}, {"tactic": "exact \u27e8fun H x y r hr => H hr, fun H r hr x y => H r hr\u27e9", "annotated_tactic": ["exact \u27e8fun H x y r hr => H hr, fun H r hr x y => H r hr\u27e9", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Setoid \u03b1)\nx\u271d : Setoid \u03b1\n\u22a2 x\u271d \u2208 {x | \u2200 \u2983a : Setoid \u03b1\u2984, a \u2208 S \u2192 \u2200 {x_1 y : \u03b1}, Rel a x_1 y \u2192 Rel x x_1 y} \u2194\n    x\u271d \u2208 {s | \u2200 \u2983x y : \u03b1\u2984, \u2200 x_1 \u2208 S, Rel x_1 x y \u2192 Rel s x y}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/Order.lean", "full_name": "Int.le_add_of_neg_add_le_left", "start": [191, 11], "end": [193, 36], "traced_tactics": [{"tactic": "rw [Int.add_comm] at h", "annotated_tactic": ["rw [<a>Int.add_comm</a>] at h", [{"full_name": "Int.add_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [135, 19], "def_end_pos": [135, 27]}]], "state_before": "a b c : Int\nh : -b + a \u2264 c\n\u22a2 a \u2264 b + c", "state_after": "a b c : Int\nh : a + -b \u2264 c\n\u22a2 a \u2264 b + c"}, {"tactic": "exact Int.le_add_of_sub_left_le h", "annotated_tactic": ["exact <a>Int.le_add_of_sub_left_le</a> h", [{"full_name": "Int.le_add_of_sub_left_le", "def_path": ".lake/packages/std/Std/Data/Int/Order.lean", "def_pos": [179, 19], "def_end_pos": [179, 40]}]], "state_before": "a b c : Int\nh : a + -b \u2264 c\n\u22a2 a \u2264 b + c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean", "full_name": "UniformOnFun.ofFun_toFun", "start": [193, 1], "end": [193, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/SimpleModule.lean", "full_name": "LinearMap.bijective_of_ne_zero", "start": [387, 1], "end": [389, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "full_name": "EMetric.hausdorffEdist_self", "start": [286, 1], "end": [288, 44], "traced_tactics": [{"tactic": "simp only [hausdorffEdist_def, sup_idem, ENNReal.iSup_eq_zero]", "annotated_tactic": ["simp only [<a>hausdorffEdist_def</a>, <a>sup_idem</a>, <a>ENNReal.iSup_eq_zero</a>]", [{"full_name": "EMetric.hausdorffEdist_def", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [1, 1], "def_end_pos": [1, 1]}, {"full_name": "sup_idem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [221, 9], "def_end_pos": [221, 17]}, {"full_name": "ENNReal.iSup_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [653, 9], "def_end_pos": [653, 21]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 hausdorffEdist s s = 0", "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 i \u2208 s, infEdist i s = 0"}, {"tactic": "exact fun x hx => infEdist_zero_of_mem hx", "annotated_tactic": ["exact fun x hx => <a>infEdist_zero_of_mem</a> hx", [{"full_name": "EMetric.infEdist_zero_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [107, 9], "def_end_pos": [107, 29]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 i \u2208 s, infEdist i s = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "Continuous.Prod.mk", "start": [415, 1], "end": [416, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/MvPowerSeries/Basic.lean", "full_name": "MvPolynomial.coeToMvPowerSeries.algHom_apply", "start": [914, 1], "end": [916, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "coe_int_mem", "start": [90, 1], "end": [90, 92], "traced_tactics": [{"tactic": "simp only [\u2190 zsmul_one, zsmul_mem, one_mem]", "annotated_tactic": ["simp only [\u2190 <a>zsmul_one</a>, <a>zsmul_mem</a>, <a>one_mem</a>]", [{"full_name": "zsmul_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [334, 15], "def_end_pos": [334, 24]}, {"full_name": "zsmul_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [147, 3], "def_end_pos": [147, 14]}, {"full_name": "OneMemClass.one_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [71, 3], "def_end_pos": [71, 10]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b9 : Ring R\ninst\u271d : SetLike S R\nhSR : SubringClass S R\ns : S\nn : \u2124\n\u22a2 \u2191n \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sign.lean", "full_name": "SignType.nonpos_iff_ne_one", "start": [175, 1], "end": [175, 82], "traced_tactics": [{"tactic": "cases a <;> decide", "annotated_tactic": ["cases a <;> decide", []], "state_before": "a : SignType\n\u22a2 a \u2264 0 \u2194 a \u2260 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "StrictMono.minimal_of_minimal_image", "start": [893, 1], "end": [895, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.associator_inv_conjugation", "start": [657, 1], "end": [659, 47], "traced_tactics": [{"tactic": "rw [associator_naturality, inv_hom_id_assoc]", "annotated_tactic": ["rw [<a>associator_naturality</a>, <a>inv_hom_id_assoc</a>]", [{"full_name": "CategoryTheory.MonoidalCategory.associator_naturality", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Monoidal/Category.lean", "def_pos": [176, 3], "def_end_pos": [176, 24]}, {"full_name": "CategoryTheory.Iso.inv_hom_id_assoc", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [67, 12], "def_end_pos": [67, 34]}]], "state_before": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b2 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nU V W X\u271d Y\u271d Z\u271d X X' Y Y' Z Z' : C\nf : X \u27f6 X'\ng : Y \u27f6 Y'\nh : Z \u27f6 Z'\n\u22a2 f \u2297 g \u2297 h = (\u03b1_ X Y Z).inv \u226b ((f \u2297 g) \u2297 h) \u226b (\u03b1_ X' Y' Z').hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Star.lean", "full_name": "starConvex_pi", "start": [147, 1], "end": [149, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/Order.lean", "full_name": "Int.eq_negSucc_of_lt_zero", "start": [25, 1], "end": [27, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Finset.subtype_mono", "start": [763, 1], "end": [764, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/DiscreteCategory.lean", "full_name": "CategoryTheory.Discrete.functor_map_id", "start": [291, 1], "end": [295, 7], "traced_tactics": [{"tactic": "have h : f = \ud835\udfd9 j := by aesop_cat", "annotated_tactic": ["have h : f = \ud835\udfd9 j := by aesop_cat", []], "state_before": "J : Type v\u2081\nC : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} C\nF : Discrete J \u2964 C\nj : Discrete J\nf : j \u27f6 j\n\u22a2 F.map f = \ud835\udfd9 (F.obj j)", "state_after": "J : Type v\u2081\nC : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} C\nF : Discrete J \u2964 C\nj : Discrete J\nf : j \u27f6 j\nh : f = \ud835\udfd9 j\n\u22a2 F.map f = \ud835\udfd9 (F.obj j)"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "J : Type v\u2081\nC : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} C\nF : Discrete J \u2964 C\nj : Discrete J\nf : j \u27f6 j\nh : f = \ud835\udfd9 j\n\u22a2 F.map f = \ud835\udfd9 (F.obj j)", "state_after": "J : Type v\u2081\nC : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} C\nF : Discrete J \u2964 C\nj : Discrete J\nf : j \u27f6 j\nh : f = \ud835\udfd9 j\n\u22a2 F.map (\ud835\udfd9 j) = \ud835\udfd9 (F.obj j)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "J : Type v\u2081\nC : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} C\nF : Discrete J \u2964 C\nj : Discrete J\nf : j \u27f6 j\nh : f = \ud835\udfd9 j\n\u22a2 F.map (\ud835\udfd9 j) = \ud835\udfd9 (F.obj j)", "state_after": "no goals"}, {"tactic": "aesop_cat", "annotated_tactic": ["aesop_cat", []], "state_before": "J : Type v\u2081\nC : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} C\nF : Discrete J \u2964 C\nj : Discrete J\nf : j \u27f6 j\n\u22a2 f = \ud835\udfd9 j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.Measure.add_toOuterMeasure", "start": [795, 1], "end": [797, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "full_name": "NonUnitalSubring.coe_toAddSubgroup", "start": [353, 1], "end": [354, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Parity.lean", "full_name": "Int.even_coe_nat", "start": [208, 1], "end": [209, 39], "traced_tactics": [{"tactic": "rw_mod_cast [even_iff, Nat.even_iff]", "annotated_tactic": ["rw_mod_cast [<a>even_iff</a>, <a>Nat.even_iff</a>]", [{"full_name": "Int.even_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Parity.lean", "def_pos": [40, 9], "def_end_pos": [40, 17]}, {"full_name": "Nat.even_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Parity.lean", "def_pos": [38, 9], "def_end_pos": [38, 17]}]], "state_before": "m n\u271d : \u2124\nn : \u2115\n\u22a2 Even \u2191n \u2194 Even n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.not_mem_mono", "start": [368, 1], "end": [369, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "full_name": "NonUnitalSubsemiring.coe_map", "start": [301, 1], "end": [302, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "MeasurableSet.coe_compl", "start": [2104, 1], "end": [2105, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.ae_lt_top'", "start": [1645, 1], "end": [1648, 88], "traced_tactics": [{"tactic": "rwa [\u2190 lintegral_congr_ae hf.ae_eq_mk]", "annotated_tactic": ["rwa [\u2190 <a>lintegral_congr_ae</a> hf.ae_eq_mk]", [{"full_name": "MeasureTheory.lintegral_congr_ae", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [305, 9], "def_end_pos": [305, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : AEMeasurable f \u03bc\nh2f : \u222b\u207b (x : \u03b1), f x \u2202\u03bc \u2260 \u22a4\n\u22a2 \u222b\u207b (x : \u03b1), AEMeasurable.mk f hf x \u2202\u03bc \u2260 \u22a4", "state_after": "no goals"}, {"tactic": "rwa [hx]", "annotated_tactic": ["rwa [hx]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : AEMeasurable f \u03bc\nh2f : \u222b\u207b (x : \u03b1), f x \u2202\u03bc \u2260 \u22a4\nh2f_meas : \u222b\u207b (x : \u03b1), AEMeasurable.mk f hf x \u2202\u03bc \u2260 \u22a4\nx : \u03b1\nhx : f x = AEMeasurable.mk f hf x\nh : AEMeasurable.mk f hf x < \u22a4\n\u22a2 f x < \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.snd_swap", "start": [173, 1], "end": [174, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.degree_pos_of_monic_of_not_isUnit", "start": [405, 1], "end": [407, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Completion.lean", "full_name": "CauchyFilter.extend_pureCauchy", "start": [265, 1], "end": [268, 86], "traced_tactics": [{"tactic": "rw [extend, if_pos hf]", "annotated_tactic": ["rw [<a>extend</a>, <a>if_pos</a> hf]", [{"full_name": "CauchyFilter.extend", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Completion.lean", "def_pos": [255, 5], "def_end_pos": [255, 11]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b3 : UniformSpace \u03b1\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b3\ninst\u271d : T0Space \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : UniformContinuous f\na : \u03b1\n\u22a2 extend f (pureCauchy a) = f a", "state_after": "\u03b1 : Type u\ninst\u271d\u00b3 : UniformSpace \u03b1\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b3\ninst\u271d : T0Space \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : UniformContinuous f\na : \u03b1\n\u22a2 DenseInducing.extend \u22ef f (pureCauchy a) = f a"}, {"tactic": "exact uniformly_extend_of_ind uniformInducing_pureCauchy denseRange_pureCauchy hf _", "annotated_tactic": ["exact <a>uniformly_extend_of_ind</a> <a>uniformInducing_pureCauchy</a> <a>denseRange_pureCauchy</a> hf _", [{"full_name": "uniformly_extend_of_ind", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "def_pos": [514, 9], "def_end_pos": [514, 32]}, {"full_name": "CauchyFilter.uniformInducing_pureCauchy", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Completion.lean", "def_pos": [162, 9], "def_end_pos": [162, 35]}, {"full_name": "CauchyFilter.denseRange_pureCauchy", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Completion.lean", "def_pos": [181, 9], "def_end_pos": [181, 30]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b3 : UniformSpace \u03b1\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : UniformSpace \u03b2\ninst\u271d\u00b9 : UniformSpace \u03b3\ninst\u271d : T0Space \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : UniformContinuous f\na : \u03b1\n\u22a2 DenseInducing.extend \u22ef f (pureCauchy a) = f a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Membership.lean", "full_name": "SubmonoidClass.coe_multiset_prod", "start": [55, 1], "end": [57, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.prod_eq_biUnion_left", "start": [1949, 1], "end": [1950, 44], "traced_tactics": [{"tactic": "rw [iUnion_image_left, image2_mk_eq_prod]", "annotated_tactic": ["rw [<a>iUnion_image_left</a>, <a>image2_mk_eq_prod</a>]", [{"full_name": "Set.iUnion_image_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1890, 9], "def_end_pos": [1890, 26]}, {"full_name": "Set.image2_mk_eq_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [87, 15], "def_end_pos": [87, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s \u00d7\u02e2 t = \u22c3 a \u2208 s, (fun b => (a, b)) '' t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Int.dvd_of_dvd_mul_right_of_gcd_one", "start": [404, 1], "end": [407, 48], "traced_tactics": [{"tactic": "rw [mul_comm] at habc", "annotated_tactic": ["rw [<a>mul_comm</a>] at habc", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "a b c : \u2124\nhabc : a \u2223 b * c\nhab : gcd a b = 1\n\u22a2 a \u2223 c", "state_after": "a b c : \u2124\nhabc : a \u2223 c * b\nhab : gcd a b = 1\n\u22a2 a \u2223 c"}, {"tactic": "exact dvd_of_dvd_mul_left_of_gcd_one habc hab", "annotated_tactic": ["exact <a>dvd_of_dvd_mul_left_of_gcd_one</a> habc hab", [{"full_name": "Int.dvd_of_dvd_mul_left_of_gcd_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/GCD.lean", "def_pos": [392, 9], "def_end_pos": [392, 39]}]], "state_before": "a b c : \u2124\nhabc : a \u2223 c * b\nhab : gcd a b = 1\n\u22a2 a \u2223 c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "AffineSubspace.coe_vsub", "start": [395, 1], "end": [396, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.Dom.of_bind", "start": [506, 1], "end": [507, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.inclusion_injective", "start": [1001, 1], "end": [1002, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Equiv.lean", "full_name": "RingEquiv.coe_toAddEquiv", "start": [223, 1], "end": [224, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.subtypeDomain_def", "start": [1292, 1], "end": [1294, 68], "traced_tactics": [{"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 subtypeDomain p f = mk (Finset.subtype p (support f)) fun i => f \u2191\u2191i", "state_after": "case h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : Subtype p\n\u22a2 (subtypeDomain p f) i = (mk (Finset.subtype p (support f)) fun i => f \u2191\u2191i) i"}, {"tactic": "by_cases h2 : f i \u2260 0 <;> try simp at h2; dsimp; simp [h2]", "annotated_tactic": ["by_cases h2 : f i \u2260 0 <;> try simp at h2; dsimp; simp [h2]", []], "state_before": "case h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : Subtype p\n\u22a2 (subtypeDomain p f) i = (mk (Finset.subtype p (support f)) fun i => f \u2191\u2191i) i", "state_after": "no goals"}, {"tactic": "simp at h2", "annotated_tactic": ["simp at h2", []], "state_before": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : Subtype p\nh2 : \u00acf \u2191i \u2260 0\n\u22a2 (subtypeDomain p f) i = (mk (Finset.subtype p (support f)) fun i => f \u2191\u2191i) i", "state_after": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : Subtype p\nh2 : f \u2191i = 0\n\u22a2 (subtypeDomain p f) i = (mk (Finset.subtype p (support f)) fun i => f \u2191\u2191i) i"}, {"tactic": "dsimp", "annotated_tactic": ["dsimp", []], "state_before": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : Subtype p\nh2 : f \u2191i = 0\n\u22a2 (subtypeDomain p f) i = (mk (Finset.subtype p (support f)) fun i => f \u2191\u2191i) i", "state_after": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : Subtype p\nh2 : f \u2191i = 0\n\u22a2 f \u2191i = if i \u2208 Finset.subtype p (support f) then f \u2191i else 0"}, {"tactic": "simp [h2]", "annotated_tactic": ["simp [h2]", []], "state_before": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : Subtype p\nh2 : f \u2191i = 0\n\u22a2 f \u2191i = if i \u2208 Finset.subtype p (support f) then f \u2191i else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/DFinsupp.lean", "full_name": "CompleteLattice.independent_iff_dfinsupp_lsum_injective", "start": [529, 1], "end": [531, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "TopHom.coe_comp", "start": [272, 1], "end": [273, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.Measure.le_iff'", "start": [987, 1], "end": [987, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "eq_one_of_mul_le_one_left", "start": [1208, 1], "end": [1209, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/Subalgebra.lean", "full_name": "StarSubalgebra.bot_toSubalgebra", "start": [702, 1], "end": [702, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Nodup.lean", "full_name": "Option.toList_nodup", "start": [484, 1], "end": [486, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant.lean", "full_name": "RingEquiv.map_det", "start": [332, 1], "end": [334, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Cast/Order.lean", "full_name": "Nat.one_lt_ofNat", "start": [193, 1], "end": [194, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.toLinAlgEquiv_apply", "start": [798, 1], "end": [801, 61], "traced_tactics": [{"tactic": "rw [Matrix.toLinAlgEquiv'_apply, v\u2081.equivFun_symm_apply]", "annotated_tactic": ["rw [<a>Matrix.toLinAlgEquiv'_apply</a>, v\u2081.equivFun_symm_apply]", [{"full_name": "Matrix.toLinAlgEquiv'_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "def_pos": [513, 9], "def_end_pos": [513, 36]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM\u2083 : Type u_7\ninst\u271d\u00b9 : AddCommMonoid M\u2083\ninst\u271d : Module R M\u2083\nv\u2083 : Basis l R M\u2083\nM : Matrix n n R\nv : M\u2081\n\u22a2 (LinearEquiv.symm (Basis.equivFun v\u2081)) ((toLinAlgEquiv' M) \u21d1(v\u2081.repr v)) = \u2211 j : n, (M *\u1d65 \u21d1(v\u2081.repr v)) j \u2022 v\u2081 j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "full_name": "CategoryTheory.Limits.IsTerminal.comp_from", "start": [151, 1], "end": [153, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.eq_union_right", "start": [1887, 1], "end": [1887, 86], "traced_tactics": [{"tactic": "rw [union_comm, eq_union_left h]", "annotated_tactic": ["rw [<a>union_comm</a>, <a>eq_union_left</a> h]", [{"full_name": "Multiset.union_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1881, 9], "def_end_pos": [1881, 19]}, {"full_name": "Multiset.eq_union_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1760, 9], "def_end_pos": [1760, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns t u : Multiset \u03b1\na b : \u03b1\nh : s \u2264 t\n\u22a2 s \u222a t = t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "full_name": "Polynomial.le_trailingDegree_monomial", "start": [214, 1], "end": [216, 71], "traced_tactics": [{"tactic": "simp [ha]", "annotated_tactic": ["simp [ha]", []], "state_before": "R : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nthis : DecidableEq R := Classical.decEq R\nha : a = 0\n\u22a2 \u2191n \u2264 trailingDegree ((monomial n) a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "full_name": "PartialEquiv.right_inv", "start": [217, 1], "end": [218, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderEmbedding.wellFounded", "start": [660, 11], "end": [662, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.bind_assoc", "start": [538, 1], "end": [543, 59], "traced_tactics": [{"tactic": "simp only [mem_bind_iff]", "annotated_tactic": ["simp only [<a>mem_bind_iff</a>]", [{"full_name": "Part.mem_bind_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [492, 9], "def_end_pos": [492, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\n\u03b3 : Type u_4\nf : Part \u03b1\ng : \u03b1 \u2192 Part \u03b2\nk : \u03b2 \u2192 Part \u03b3\na : \u03b3\n\u22a2 a \u2208 Part.bind (Part.bind f g) k \u2194 a \u2208 Part.bind f fun x => Part.bind (g x) k", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\n\u03b3 : Type u_4\nf : Part \u03b1\ng : \u03b1 \u2192 Part \u03b2\nk : \u03b2 \u2192 Part \u03b3\na : \u03b3\n\u22a2 (\u2203 a_1, (\u2203 a \u2208 f, a_1 \u2208 g a) \u2227 a \u2208 k a_1) \u2194 \u2203 a_1 \u2208 f, \u2203 a_2 \u2208 g a_1, a \u2208 k a_2"}, {"tactic": "exact \u27e8fun \u27e8_, \u27e8_, h\u2081, h\u2082\u27e9, h\u2083\u27e9 => \u27e8_, h\u2081, _, h\u2082, h\u2083\u27e9,\n       fun \u27e8_, h\u2081, _, h\u2082, h\u2083\u27e9 => \u27e8_, \u27e8_, h\u2081, h\u2082\u27e9, h\u2083\u27e9\u27e9", "annotated_tactic": ["exact \u27e8fun \u27e8_, \u27e8_, h\u2081, h\u2082\u27e9, h\u2083\u27e9 => \u27e8_, h\u2081, _, h\u2082, h\u2083\u27e9,\n           fun \u27e8_, h\u2081, _, h\u2082, h\u2083\u27e9 => \u27e8_, \u27e8_, h\u2081, h\u2082\u27e9, h\u2083\u27e9\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\n\u03b3 : Type u_4\nf : Part \u03b1\ng : \u03b1 \u2192 Part \u03b2\nk : \u03b2 \u2192 Part \u03b3\na : \u03b3\n\u22a2 (\u2203 a_1, (\u2203 a \u2208 f, a_1 \u2208 g a) \u2227 a \u2208 k a_1) \u2194 \u2203 a_1 \u2208 f, \u2203 a_2 \u2208 g a_1, a \u2208 k a_2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.mul_le_mul_right", "start": [240, 1], "end": [241, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Abs.lean", "full_name": "Complex.abs_ofReal", "start": [75, 1], "end": [76, 63], "traced_tactics": [{"tactic": "simp [Complex.abs, normSq_ofReal, Real.sqrt_mul_self_eq_abs]", "annotated_tactic": ["simp [<a>Complex.abs</a>, <a>normSq_ofReal</a>, <a>Real.sqrt_mul_self_eq_abs</a>]", [{"full_name": "Complex.abs", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Abs.lean", "def_pos": [56, 19], "def_end_pos": [56, 37]}, {"full_name": "Complex.normSq_ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [621, 9], "def_end_pos": [621, 22]}, {"full_name": "Real.sqrt_mul_self_eq_abs", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Sqrt.lean", "def_pos": [239, 9], "def_end_pos": [239, 29]}]], "state_before": "r : \u211d\n\u22a2 abs \u2191r = |r|", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rat/Order.lean", "full_name": "Rat.nonneg_add", "start": [53, 11], "end": [61, 92], "traced_tactics": [{"tactic": "have d\u20810 : 0 < (d\u2081 : \u2124) := Int.coe_nat_pos.2 (Nat.pos_of_ne_zero h\u2081)", "annotated_tactic": ["have d\u20810 : 0 < (d\u2081 : \u2124) := <a>Int.coe_nat_pos</a>.2 (<a>Nat.pos_of_ne_zero</a> h\u2081)", [{"full_name": "Int.coe_nat_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [40, 9], "def_end_pos": [40, 20]}, {"full_name": "Nat.pos_of_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [298, 19], "def_end_pos": [298, 33]}]], "state_before": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 + n\u2082 /. \u2191d\u2082)", "state_after": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 + n\u2082 /. \u2191d\u2082)"}, {"tactic": "have d\u20820 : 0 < (d\u2082 : \u2124) := Int.coe_nat_pos.2 (Nat.pos_of_ne_zero h\u2082)", "annotated_tactic": ["have d\u20820 : 0 < (d\u2082 : \u2124) := <a>Int.coe_nat_pos</a>.2 (<a>Nat.pos_of_ne_zero</a> h\u2082)", [{"full_name": "Int.coe_nat_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [40, 9], "def_end_pos": [40, 20]}, {"full_name": "Nat.pos_of_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [298, 19], "def_end_pos": [298, 33]}]], "state_before": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 + n\u2082 /. \u2191d\u2082)", "state_after": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 + n\u2082 /. \u2191d\u2082)"}, {"tactic": "simp only [d\u20810, d\u20820, h\u2081, h\u2082, mul_pos, divInt_nonneg, add_def'', Ne.def,\n  Nat.cast_eq_zero, not_false_iff]", "annotated_tactic": ["simp only [d\u20810, d\u20820, h\u2081, h\u2082, <a>mul_pos</a>, <a>divInt_nonneg</a>, <a>add_def''</a>, <a>Ne.def</a>,\n        <a>Nat.cast_eq_zero</a>, <a>not_false_iff</a>]", [{"full_name": "mul_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [406, 7], "def_end_pos": [406, 14]}, {"full_name": "Rat.divInt_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Order.lean", "def_pos": [39, 9], "def_end_pos": [39, 22]}, {"full_name": "Rat.add_def''", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [162, 9], "def_end_pos": [162, 18]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Nat.cast_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharZero/Defs.lean", "def_pos": [79, 9], "def_end_pos": [79, 21]}, {"full_name": "not_false_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1359, 9], "def_end_pos": [1359, 22]}]], "state_before": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 + n\u2082 /. \u2191d\u2082)", "state_after": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\n\u22a2 0 \u2264 n\u2081 \u2192 0 \u2264 n\u2082 \u2192 0 \u2264 n\u2081 * \u2191d\u2082 + n\u2082 * \u2191d\u2081"}, {"tactic": "intro n\u20810 n\u20820", "annotated_tactic": ["intro n\u20810 n\u20820", []], "state_before": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\n\u22a2 0 \u2264 n\u2081 \u2192 0 \u2264 n\u2082 \u2192 0 \u2264 n\u2081 * \u2191d\u2082 + n\u2082 * \u2191d\u2081", "state_after": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\nn\u20810 : 0 \u2264 n\u2081\nn\u20820 : 0 \u2264 n\u2082\n\u22a2 0 \u2264 n\u2081 * \u2191d\u2082 + n\u2082 * \u2191d\u2081"}, {"tactic": "first |assumption|apply Int.ofNat_zero_le", "annotated_tactic": ["first |assumption|apply <a>Int.ofNat_zero_le</a>", [{"full_name": "Int.ofNat_zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [59, 9], "def_end_pos": [59, 22]}]], "state_before": "case hb.hb\na\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\nn\u20810 : 0 \u2264 n\u2081\nn\u20820 : 0 \u2264 n\u2082\n\u22a2 0 \u2264 \u2191d\u2081", "state_after": "no goals"}, {"tactic": "assumption", "annotated_tactic": ["assumption", []], "state_before": "case hb.ha\na\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\nn\u20810 : 0 \u2264 n\u2081\nn\u20820 : 0 \u2264 n\u2082\n\u22a2 0 \u2264 n\u2082", "state_after": "no goals"}, {"tactic": "apply Int.ofNat_zero_le", "annotated_tactic": ["apply <a>Int.ofNat_zero_le</a>", [{"full_name": "Int.ofNat_zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [59, 9], "def_end_pos": [59, 22]}]], "state_before": "case hb.hb\na\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\nn\u20810 : 0 \u2264 n\u2081\nn\u20820 : 0 \u2264 n\u2082\n\u22a2 0 \u2264 \u2191d\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.map_dvd", "start": [802, 1], "end": [803, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "full_name": "AffineMap.linear_bijective_iff", "start": [477, 1], "end": [479, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean", "full_name": "EuclideanDomain.GCD.induction", "start": [179, 1], "end": [189, 17], "traced_tactics": [{"tactic": "exact a0.symm \u25b8 H0 b", "annotated_tactic": ["exact a0.symm \u25b8 H0 b", []], "state_before": "R : Type u\ninst\u271d : EuclideanDomain R\nP : R \u2192 R \u2192 Prop\na b : R\nH0 : \u2200 (x : R), P 0 x\nH1 : \u2200 (a b : R), a \u2260 0 \u2192 P (b % a) a \u2192 P a b\na0 : a = 0\n\u22a2 P a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.union_ae_eq_left_iff_ae_subset", "start": [312, 1], "end": [318, 67], "traced_tactics": [{"tactic": "rw [ae_le_set]", "annotated_tactic": ["rw [<a>ae_le_set</a>]", [{"full_name": "MeasureTheory.ae_le_set", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [464, 9], "def_end_pos": [464, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nm : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns s\u2081 s\u2082 t : Set \u03b1\n\u22a2 s \u222a t =\u1d50[\u03bc] s \u2194 t \u2264\u1d50[\u03bc] s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nm : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns s\u2081 s\u2082 t : Set \u03b1\n\u22a2 s \u222a t =\u1d50[\u03bc] s \u2194 \u2191\u2191\u03bc (t \\ s) = 0"}, {"tactic": "refine'\n  \u27e8fun h => by simpa only [union_diff_left] using (ae_eq_set.mp h).1, fun h =>\n    eventuallyLE_antisymm_iff.mpr\n      \u27e8by rwa [ae_le_set, union_diff_left],\n        HasSubset.Subset.eventuallyLE <| subset_union_left s t\u27e9\u27e9", "annotated_tactic": ["refine'\n    \u27e8fun h => by simpa only [<a>union_diff_left</a>] using (ae_eq_set.mp h).1, fun h =>\n      eventuallyLE_antisymm_iff.mpr\n        \u27e8by rwa [<a>ae_le_set</a>, <a>union_diff_left</a>],\n          <a>HasSubset.Subset.eventuallyLE</a> <| <a>subset_union_left</a> s t\u27e9\u27e9", [{"full_name": "Set.union_diff_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1833, 9], "def_end_pos": [1833, 24]}, {"full_name": "MeasureTheory.ae_le_set", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [464, 9], "def_end_pos": [464, 18]}, {"full_name": "Set.union_diff_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1833, 9], "def_end_pos": [1833, 24]}, {"full_name": "HasSubset.Subset.eventuallyLE", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3281, 9], "def_end_pos": [3281, 38]}, {"full_name": "Set.subset_union_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [799, 9], "def_end_pos": [799, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nm : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns s\u2081 s\u2082 t : Set \u03b1\n\u22a2 s \u222a t =\u1d50[\u03bc] s \u2194 \u2191\u2191\u03bc (t \\ s) = 0", "state_after": "no goals"}, {"tactic": "simpa only [union_diff_left] using (ae_eq_set.mp h).1", "annotated_tactic": ["simpa only [<a>union_diff_left</a>] using (ae_eq_set.mp h).1", [{"full_name": "Set.union_diff_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1833, 9], "def_end_pos": [1833, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nm : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns s\u2081 s\u2082 t : Set \u03b1\nh : s \u222a t =\u1d50[\u03bc] s\n\u22a2 \u2191\u2191\u03bc (t \\ s) = 0", "state_after": "no goals"}, {"tactic": "rwa [ae_le_set, union_diff_left]", "annotated_tactic": ["rwa [<a>ae_le_set</a>, <a>union_diff_left</a>]", [{"full_name": "MeasureTheory.ae_le_set", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [464, 9], "def_end_pos": [464, 18]}, {"full_name": "Set.union_diff_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1833, 9], "def_end_pos": [1833, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nm : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns s\u2081 s\u2082 t : Set \u03b1\nh : \u2191\u2191\u03bc (t \\ s) = 0\n\u22a2 s \u222a t \u2264\u1d50[\u03bc] s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.map_add_range'", "start": [2130, 1], "end": [2132, 90], "traced_tactics": [{"tactic": "simp [range', map_add_range' _ (s + step) n step, Nat.add_assoc]", "annotated_tactic": ["simp [<a>range'</a>, map_add_range' _ (s + step) n step, <a>Nat.add_assoc</a>]", [{"full_name": "List.range'", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1107, 5], "def_end_pos": [1107, 11]}, {"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "a s n step : Nat\n\u22a2 map (fun x => a + x) (range' s (n + 1) step) = range' (a + s) (n + 1) step", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/Bilinear.lean", "full_name": "ContinuousLinearMap.opNorm_ext", "start": [47, 1], "end": [56, 17], "traced_tactics": [{"tactic": "rw [h x]", "annotated_tactic": ["rw [h x]", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2083\nf : E \u2192SL[\u03c3\u2081\u2082] F\ng : E \u2192SL[\u03c3\u2081\u2083] G\nh : \u2200 (x : E), \u2016f x\u2016 = \u2016g x\u2016\nx : E\n\u22a2 \u2016f x\u2016 \u2264 \u2016g\u2016 * \u2016x\u2016", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2083\nf : E \u2192SL[\u03c3\u2081\u2082] F\ng : E \u2192SL[\u03c3\u2081\u2083] G\nh : \u2200 (x : E), \u2016f x\u2016 = \u2016g x\u2016\nx : E\n\u22a2 \u2016g x\u2016 \u2264 \u2016g\u2016 * \u2016x\u2016"}, {"tactic": "exact le_opNorm _ _", "annotated_tactic": ["exact <a>le_opNorm</a> _ _", [{"full_name": "ContinuousLinearMap.le_opNorm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean", "def_pos": [236, 9], "def_end_pos": [236, 18]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2083\nf : E \u2192SL[\u03c3\u2081\u2082] F\ng : E \u2192SL[\u03c3\u2081\u2083] G\nh : \u2200 (x : E), \u2016f x\u2016 = \u2016g x\u2016\nx : E\n\u22a2 \u2016g x\u2016 \u2264 \u2016g\u2016 * \u2016x\u2016", "state_after": "no goals"}, {"tactic": "rw [\u2190 h z]", "annotated_tactic": ["rw [\u2190 h z]", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2083\nf : E \u2192SL[\u03c3\u2081\u2082] F\ng : E \u2192SL[\u03c3\u2081\u2083] G\nh : \u2200 (x : E), \u2016f x\u2016 = \u2016g x\u2016\nc : \u211d\nhc : c \u2265 0\nh\u2082 : \u2200 (x : E), \u2016f x\u2016 \u2264 c * \u2016x\u2016\nz : E\n\u22a2 \u2016g z\u2016 \u2264 c * \u2016z\u2016", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2083\nf : E \u2192SL[\u03c3\u2081\u2082] F\ng : E \u2192SL[\u03c3\u2081\u2083] G\nh : \u2200 (x : E), \u2016f x\u2016 = \u2016g x\u2016\nc : \u211d\nhc : c \u2265 0\nh\u2082 : \u2200 (x : E), \u2016f x\u2016 \u2264 c * \u2016x\u2016\nz : E\n\u22a2 \u2016f z\u2016 \u2264 c * \u2016z\u2016"}, {"tactic": "exact h\u2082 z", "annotated_tactic": ["exact h\u2082 z", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\ninst\u271d\u2077 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2076 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2074 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : FunLike \ud835\udcd5 E F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2083\nf : E \u2192SL[\u03c3\u2081\u2082] F\ng : E \u2192SL[\u03c3\u2081\u2083] G\nh : \u2200 (x : E), \u2016f x\u2016 = \u2016g x\u2016\nc : \u211d\nhc : c \u2265 0\nh\u2082 : \u2200 (x : E), \u2016f x\u2016 \u2264 c * \u2016x\u2016\nz : E\n\u22a2 \u2016f z\u2016 \u2264 c * \u2016z\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/NNReal.lean", "full_name": "Set.OrdConnected.preimage_coe_nnreal_real", "start": [1126, 1], "end": [1127, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Hom/Ring.lean", "full_name": "OrderRingIso.symm_bijective", "start": [484, 1], "end": [485, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/QuotientGroup.lean", "full_name": "QuotientGroup.eq_iff_div_mem", "start": [140, 1], "end": [143, 39], "traced_tactics": [{"tactic": "refine' eq_comm.trans (QuotientGroup.eq.trans _)", "annotated_tactic": ["refine' eq_comm.trans (QuotientGroup.eq.trans _)", []], "state_before": "G : Type u\ninst\u271d\u00b2 : Group G\nN\u271d : Subgroup G\nnN\u271d : Subgroup.Normal N\u271d\nH : Type v\ninst\u271d\u00b9 : Group H\nM : Type x\ninst\u271d : Monoid M\nN : Subgroup G\nnN : Subgroup.Normal N\nx y : G\n\u22a2 \u2191x = \u2191y \u2194 x / y \u2208 N", "state_after": "G : Type u\ninst\u271d\u00b2 : Group G\nN\u271d : Subgroup G\nnN\u271d : Subgroup.Normal N\u271d\nH : Type v\ninst\u271d\u00b9 : Group H\nM : Type x\ninst\u271d : Monoid M\nN : Subgroup G\nnN : Subgroup.Normal N\nx y : G\n\u22a2 y\u207b\u00b9 * x \u2208 N \u2194 x / y \u2208 N"}, {"tactic": "rw [nN.mem_comm_iff, div_eq_mul_inv]", "annotated_tactic": ["rw [nN.mem_comm_iff, <a>div_eq_mul_inv</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}]], "state_before": "G : Type u\ninst\u271d\u00b2 : Group G\nN\u271d : Subgroup G\nnN\u271d : Subgroup.Normal N\u271d\nH : Type v\ninst\u271d\u00b9 : Group H\nM : Type x\ninst\u271d : Monoid M\nN : Subgroup G\nnN : Subgroup.Normal N\nx y : G\n\u22a2 y\u207b\u00b9 * x \u2208 N \u2194 x / y \u2208 N", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Multiplicity.lean", "full_name": "multiplicity.multiplicity_ne_zero", "start": [208, 1], "end": [209, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Projection.lean", "full_name": "Submodule.linearProjOfIsCompl_apply_left", "start": [160, 1], "end": [161, 69], "traced_tactics": [{"tactic": "simp [linearProjOfIsCompl]", "annotated_tactic": ["simp [<a>linearProjOfIsCompl</a>]", [{"full_name": "Submodule.linearProjOfIsCompl", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Projection.lean", "def_pos": [153, 5], "def_end_pos": [153, 24]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\np q : Submodule R E\nS : Type u_5\ninst\u271d\u00b2 : Semiring S\nM : Type u_6\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module S M\nm : Submodule S M\nh : IsCompl p q\nx : \u21a5p\n\u22a2 (linearProjOfIsCompl p q h) \u2191x = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.aleph0_mul_ofNat", "start": [1786, 1], "end": [1787, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeAbelianGroup.lean", "full_name": "FreeAbelianGroup.map_of_apply", "start": [395, 1], "end": [396, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometry.coe_pow", "start": [449, 1], "end": [450, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.foldr_concat", "start": [2407, 1], "end": [2410, 44], "traced_tactics": [{"tactic": "simp only [List.foldr_append, List.foldr]", "annotated_tactic": ["simp only [<a>List.foldr_append</a>, <a>List.foldr</a>]", [{"full_name": "List.foldr_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [371, 17], "def_end_pos": [371, 29]}, {"full_name": "List.foldr", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [554, 19], "def_end_pos": [554, 24]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nb : \u03b2\nx : \u03b1\nxs : List \u03b1\n\u22a2 foldr f b (xs ++ [x]) = foldr f (f x b) xs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.floor_nonpos", "start": [708, 1], "end": [710, 30], "traced_tactics": [{"tactic": "rw [\u2190 @cast_le \u03b1, Int.cast_zero]", "annotated_tactic": ["rw [\u2190 @<a>cast_le</a> \u03b1, <a>Int.cast_zero</a>]", [{"full_name": "Int.cast_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [138, 9], "def_end_pos": [138, 16]}, {"full_name": "Int.cast_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 18]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\nha : a \u2264 0\n\u22a2 \u230aa\u230b \u2264 0", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\nha : a \u2264 0\n\u22a2 \u2191\u230aa\u230b \u2264 0"}, {"tactic": "exact (floor_le a).trans ha", "annotated_tactic": ["exact (<a>floor_le</a> a).<a>trans</a> ha", [{"full_name": "Int.floor_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [692, 9], "def_end_pos": [692, 17]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\nha : a \u2264 0\n\u22a2 \u2191\u230aa\u230b \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.replicate_sublist_replicate", "start": [618, 9], "end": [624, 48], "traced_tactics": [{"tactic": "refine \u27e8fun h => ?_, fun h => ?_\u27e9", "annotated_tactic": ["refine \u27e8fun h => ?_, fun h => ?_\u27e9", []], "state_before": "\u03b1 : Type u_1\nm n : Nat\na : \u03b1\n\u22a2 replicate m a <+ replicate n a \u2194 m \u2264 n", "state_after": "case refine_1\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\nh : replicate m a <+ replicate n a\n\u22a2 m \u2264 n\n\ncase refine_2\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\nh : m \u2264 n\n\u22a2 replicate m a <+ replicate n a"}, {"tactic": "have := h.length_le", "annotated_tactic": ["have := h.length_le", []], "state_before": "case refine_1\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\nh : replicate m a <+ replicate n a\n\u22a2 m \u2264 n", "state_after": "case refine_1\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\nh : replicate m a <+ replicate n a\nthis : length (replicate m a) \u2264 length (replicate n a)\n\u22a2 m \u2264 n"}, {"tactic": "simp only [length_replicate] at this \u22a2", "annotated_tactic": ["simp only [<a>length_replicate</a>] at this \u22a2", [{"full_name": "List.length_replicate", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [834, 17], "def_end_pos": [834, 33]}]], "state_before": "case refine_1\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\nh : replicate m a <+ replicate n a\nthis : length (replicate m a) \u2264 length (replicate n a)\n\u22a2 m \u2264 n", "state_after": "case refine_1\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\nh : replicate m a <+ replicate n a\nthis : m \u2264 n\n\u22a2 m \u2264 n"}, {"tactic": "exact this", "annotated_tactic": ["exact this", []], "state_before": "case refine_1\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\nh : replicate m a <+ replicate n a\nthis : m \u2264 n\n\u22a2 m \u2264 n", "state_after": "no goals"}, {"tactic": "induction h with\n| refl => apply Sublist.refl\n| step => simp [*, replicate, Sublist.cons]", "annotated_tactic": ["induction h with\n    | <a>refl</a> => apply <a>Sublist.refl</a>\n    | <a>step</a> => simp [*, <a>replicate</a>, <a>Sublist.cons</a>]", [{"full_name": "Nat.le.refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1623, 5], "def_end_pos": [1623, 9]}, {"full_name": "List.Sublist.refl", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [503, 17], "def_end_pos": [503, 29]}, {"full_name": "Nat.le.step", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1625, 5], "def_end_pos": [1625, 9]}, {"full_name": "List.replicate", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [803, 13], "def_end_pos": [803, 22]}, {"full_name": "List.Sublist.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [411, 5], "def_end_pos": [411, 9]}]], "state_before": "case refine_2\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\nh : m \u2264 n\n\u22a2 replicate m a <+ replicate n a", "state_after": "no goals"}, {"tactic": "apply Sublist.refl", "annotated_tactic": ["apply <a>Sublist.refl</a>", [{"full_name": "List.Sublist.refl", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [503, 17], "def_end_pos": [503, 29]}]], "state_before": "case refine_2.refl\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\n\u22a2 replicate m a <+ replicate m a", "state_after": "no goals"}, {"tactic": "simp [*, replicate, Sublist.cons]", "annotated_tactic": ["simp [*, <a>replicate</a>, <a>Sublist.cons</a>]", [{"full_name": "List.replicate", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [803, 13], "def_end_pos": [803, 22]}, {"full_name": "List.Sublist.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [411, 5], "def_end_pos": [411, 9]}]], "state_before": "case refine_2.step\n\u03b1 : Type u_1\nm n : Nat\na : \u03b1\nm\u271d : Nat\na\u271d : Nat.le m m\u271d\na_ih\u271d : replicate m a <+ replicate m\u271d a\n\u22a2 replicate m a <+ replicate (succ m\u271d) a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "Submodule.range_ker_disjoint", "start": [271, 1], "end": [277, 55], "traced_tactics": [{"tactic": "rw [LinearIndependent, Finsupp.total_comp, Finsupp.lmapDomain_total R _ f (fun _ \u21a6 rfl),\n  LinearMap.ker_comp] at hv", "annotated_tactic": ["rw [<a>LinearIndependent</a>, <a>Finsupp.total_comp</a>, <a>Finsupp.lmapDomain_total</a> R _ f (fun _ \u21a6 <a>rfl</a>),\n    <a>LinearMap.ker_comp</a>] at hv", [{"full_name": "LinearIndependent", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [100, 5], "def_end_pos": [100, 22]}, {"full_name": "Finsupp.total_comp", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [863, 9], "def_end_pos": [863, 19]}, {"full_name": "Finsupp.lmapDomain_total", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [742, 9], "def_end_pos": [742, 25]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "LinearMap.ker_comp", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [87, 9], "def_end_pos": [87, 17]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nf : M \u2192\u2097[R] M'\nhv : LinearIndependent R (\u21d1f \u2218 v)\n\u22a2 Disjoint (span R (range v)) (LinearMap.ker f)", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nf : M \u2192\u2097[R] M'\nhv : comap (Finsupp.total \u03b9 M R fun x => v x) (LinearMap.ker f) = \u22a5\n\u22a2 Disjoint (span R (range v)) (LinearMap.ker f)"}, {"tactic": "rw [disjoint_iff_inf_le, \u2190 Set.image_univ, Finsupp.span_image_eq_map_total,\n  map_inf_eq_map_inf_comap, hv, inf_bot_eq, map_bot]", "annotated_tactic": ["rw [<a>disjoint_iff_inf_le</a>, \u2190 <a>Set.image_univ</a>, <a>Finsupp.span_image_eq_map_total</a>,\n    <a>map_inf_eq_map_inf_comap</a>, hv, <a>inf_bot_eq</a>, <a>map_bot</a>]", [{"full_name": "disjoint_iff_inf_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [131, 9], "def_end_pos": [131, 28]}, {"full_name": "Set.image_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [692, 9], "def_end_pos": [692, 19]}, {"full_name": "Finsupp.span_image_eq_map_total", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [791, 9], "def_end_pos": [791, 32]}, {"full_name": "Submodule.map_inf_eq_map_inf_comap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [416, 9], "def_end_pos": [416, 33]}, {"full_name": "inf_bot_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [465, 7], "def_end_pos": [465, 17]}, {"full_name": "Submodule.map_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [234, 9], "def_end_pos": [234, 16]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nf : M \u2192\u2097[R] M'\nhv : comap (Finsupp.total \u03b9 M R fun x => v x) (LinearMap.ker f) = \u22a5\n\u22a2 Disjoint (span R (range v)) (LinearMap.ker f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean", "full_name": "SimpleGraph.not_mem_commonNeighbors_right", "start": [843, 1], "end": [844, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Control/Applicative.lean", "full_name": "Functor.Comp.seq_assoc", "start": [97, 1], "end": [99, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/OrderClosed.lean", "full_name": "isOpen_lt", "start": [743, 1], "end": [745, 68], "traced_tactics": [{"tactic": "simpa only [lt_iff_not_le] using (isClosed_le hg hf).isOpen_compl", "annotated_tactic": ["simpa only [<a>lt_iff_not_le</a>] using (<a>isClosed_le</a> hg hf).<a>isOpen_compl</a>", [{"full_name": "lt_iff_not_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [466, 9], "def_end_pos": [466, 22]}, {"full_name": "isClosed_le", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/OrderClosed.lean", "def_pos": [645, 9], "def_end_pos": [645, 20]}, {"full_name": "IsClosed.isOpen_compl", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [102, 3], "def_end_pos": [102, 15]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderClosedTopology \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : Continuous f\nhg : Continuous g\n\u22a2 IsOpen {b | f b < g b}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Inv.lean", "full_name": "ENNReal.inv_eq_zero", "start": [143, 11], "end": [144, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.surjective_iff_hasRightInverse", "start": [517, 1], "end": [518, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pointwise.lean", "full_name": "Filter.vsub_le_vsub_right", "start": [1184, 1], "end": [1185, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Quotient.lean", "full_name": "AddSubgroup.norm_normedMk", "start": [318, 1], "end": [325, 68], "traced_tactics": [{"tactic": "refine le_antisymm (norm_normedMk_le S) ?_", "annotated_tactic": ["refine <a>le_antisymm</a> (<a>norm_normedMk_le</a> S) ?_", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "AddSubgroup.norm_normedMk_le", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Quotient.lean", "def_pos": [302, 9], "def_end_pos": [302, 25]}]], "state_before": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\n\u22a2 \u2016normedMk S\u2016 = 1", "state_after": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\n\u22a2 1 \u2264 \u2016normedMk S\u2016"}, {"tactic": "obtain \u27e8x, hx\u27e9 : \u2203 x : M, 0 < \u2016(x : M \u29f8 S)\u2016 := by\n  refine (Set.nonempty_compl.2 h).imp fun x hx \u21a6 ?_\n  exact (norm_nonneg _).lt_of_ne' <| mt (quotient_norm_eq_zero_iff S x).1 hx", "annotated_tactic": ["obtain \u27e8x, hx\u27e9 : \u2203 x : M, 0 < \u2016(x : M \u29f8 S)\u2016 := by\n    refine (<a>Set.nonempty_compl</a>.2 h).<a>imp</a> fun x hx \u21a6 ?_\n    exact (<a>norm_nonneg</a> _).<a>lt_of_ne'</a> <| <a>mt</a> (<a>quotient_norm_eq_zero_iff</a> S x).1 hx", [{"full_name": "Set.nonempty_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1690, 9], "def_end_pos": [1690, 23]}, {"full_name": "Exists.imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [126, 9], "def_end_pos": [126, 19]}, {"full_name": "norm_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [551, 30], "def_end_pos": [551, 41]}, {"full_name": "LE.le.lt_of_ne'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [131, 7], "def_end_pos": [131, 22]}, {"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "quotient_norm_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Quotient.lean", "def_pos": [181, 9], "def_end_pos": [181, 34]}]], "state_before": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\n\u22a2 1 \u2264 \u2016normedMk S\u2016", "state_after": "case intro\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\nx : M\nhx : 0 < \u2016\u2191x\u2016\n\u22a2 1 \u2264 \u2016normedMk S\u2016"}, {"tactic": "refine (le_mul_iff_one_le_left hx).1 ?_", "annotated_tactic": ["refine (<a>le_mul_iff_one_le_left</a> hx).1 ?_", [{"full_name": "le_mul_iff_one_le_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [697, 7], "def_end_pos": [697, 29]}]], "state_before": "case intro\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\nx : M\nhx : 0 < \u2016\u2191x\u2016\n\u22a2 1 \u2264 \u2016normedMk S\u2016", "state_after": "case intro\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\nx : M\nhx : 0 < \u2016\u2191x\u2016\n\u22a2 \u2016\u2191x\u2016 \u2264 \u2016normedMk S\u2016 * \u2016\u2191x\u2016"}, {"tactic": "exact norm_lift_apply_le S.normedMk (fun x \u21a6 (eq_zero_iff x).2) x", "annotated_tactic": ["exact <a>norm_lift_apply_le</a> S.normedMk (fun x \u21a6 (<a>eq_zero_iff</a> x).2) x", [{"full_name": "QuotientAddGroup.norm_lift_apply_le", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Quotient.lean", "def_pos": [306, 9], "def_end_pos": [306, 51]}, {"full_name": "QuotientAddGroup.eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/QuotientGroup.lean", "def_pos": [119, 3], "def_end_pos": [119, 14]}]], "state_before": "case intro\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\nx : M\nhx : 0 < \u2016\u2191x\u2016\n\u22a2 \u2016\u2191x\u2016 \u2264 \u2016normedMk S\u2016 * \u2016\u2191x\u2016", "state_after": "no goals"}, {"tactic": "refine (Set.nonempty_compl.2 h).imp fun x hx \u21a6 ?_", "annotated_tactic": ["refine (<a>Set.nonempty_compl</a>.2 h).<a>imp</a> fun x hx \u21a6 ?_", [{"full_name": "Set.nonempty_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1690, 9], "def_end_pos": [1690, 23]}, {"full_name": "Exists.imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [126, 9], "def_end_pos": [126, 19]}]], "state_before": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\n\u22a2 \u2203 x, 0 < \u2016\u2191x\u2016", "state_after": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\nx : M\nhx : x \u2208 (\u2191(topologicalClosure S))\u1d9c\n\u22a2 0 < \u2016\u2191x\u2016"}, {"tactic": "exact (norm_nonneg _).lt_of_ne' <| mt (quotient_norm_eq_zero_iff S x).1 hx", "annotated_tactic": ["exact (<a>norm_nonneg</a> _).<a>lt_of_ne'</a> <| <a>mt</a> (<a>quotient_norm_eq_zero_iff</a> S x).1 hx", [{"full_name": "norm_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [551, 30], "def_end_pos": [551, 41]}, {"full_name": "LE.le.lt_of_ne'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [131, 7], "def_end_pos": [131, 22]}, {"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "quotient_norm_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Quotient.lean", "def_pos": [181, 9], "def_end_pos": [181, 34]}]], "state_before": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup M\ninst\u271d : SeminormedAddCommGroup N\nS : AddSubgroup M\nh : \u2191(topologicalClosure S) \u2260 univ\nx : M\nhx : x \u2208 (\u2191(topologicalClosure S))\u1d9c\n\u22a2 0 < \u2016\u2191x\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "lowerBounds_upperClosure", "start": [1623, 1], "end": [1625, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/Bounded.lean", "full_name": "Bornology.IsVonNBounded.neg", "start": [119, 11], "end": [121, 47], "traced_tactics": [{"tactic": "rw [\u2190 neg_neg U]", "annotated_tactic": ["rw [\u2190 <a>neg_neg</a> U]", [{"full_name": "neg_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [810, 3], "def_end_pos": [810, 14]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2074 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b3 : AddGroup E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : TopologicalAddGroup E\ninst\u271d : DistribMulAction \ud835\udd5c E\ns t : Set E\nhs : IsVonNBounded \ud835\udd5c s\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\n\u22a2 Absorbs \ud835\udd5c U (-s)", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2074 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b3 : AddGroup E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : TopologicalAddGroup E\ninst\u271d : DistribMulAction \ud835\udd5c E\ns t : Set E\nhs : IsVonNBounded \ud835\udd5c s\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\n\u22a2 Absorbs \ud835\udd5c (- -U) (-s)"}, {"tactic": "exact (hs <| neg_mem_nhds_zero _ hU).neg_neg", "annotated_tactic": ["exact (hs <| <a>neg_mem_nhds_zero</a> _ hU).<a>neg_neg</a>", [{"full_name": "neg_mem_nhds_zero", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [645, 3], "def_end_pos": [645, 14]}, {"full_name": "Absorbs.neg_neg", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bornology/Absorbs.lean", "def_pos": [211, 28], "def_end_pos": [211, 43]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2074 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b3 : AddGroup E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : TopologicalAddGroup E\ninst\u271d : DistribMulAction \ud835\udd5c E\ns t : Set E\nhs : IsVonNBounded \ud835\udd5c s\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\n\u22a2 Absorbs \ud835\udd5c (- -U) (-s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sum/Basic.lean", "full_name": "Sum.isSome_getLeft?_iff_isLeft", "start": [78, 9], "end": [79, 50], "traced_tactics": [{"tactic": "rw [isLeft_iff, Option.isSome_iff_exists]", "annotated_tactic": ["rw [<a>isLeft_iff</a>, <a>Option.isSome_iff_exists</a>]", [{"full_name": "Sum.isLeft_iff", "def_path": ".lake/packages/std/Std/Data/Sum/Lemmas.lean", "def_pos": [82, 9], "def_end_pos": [82, 19]}, {"full_name": "Option.isSome_iff_exists", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean", "def_pos": [59, 9], "def_end_pos": [59, 26]}]], "state_before": "\u03b1 : Type u\n\u03b1' : Type w\n\u03b2 : Type v\n\u03b2' : Type x\n\u03b3 : Type u_1\n\u03b4 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 Option.isSome (getLeft? x) = true \u2194 isLeft x = true", "state_after": "\u03b1 : Type u\n\u03b1' : Type w\n\u03b2 : Type v\n\u03b2' : Type x\n\u03b3 : Type u_1\n\u03b4 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 (\u2203 a, getLeft? x = some a) \u2194 \u2203 y, x = inl y"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b1' : Type w\n\u03b2 : Type v\n\u03b2' : Type x\n\u03b3 : Type u_1\n\u03b4 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 (\u2203 a, getLeft? x = some a) \u2194 \u2203 y, x = inl y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean", "full_name": "Ordinal.log_mod_opow_log_lt_log_self", "start": [385, 1], "end": [394, 44], "traced_tactics": [{"tactic": "rcases eq_or_ne (o % (b ^ log b o)) 0 with h | h", "annotated_tactic": ["rcases <a>eq_or_ne</a> (o % (b ^ <a>log</a> b o)) 0 with h | h", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}, {"full_name": "Ordinal.log", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [257, 5], "def_end_pos": [257, 8]}]], "state_before": "b o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\n\u22a2 log b (o % b ^ log b o) < log b o", "state_after": "case inl\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o = 0\n\u22a2 log b (o % b ^ log b o) < log b o\n\ncase inr\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 log b (o % b ^ log b o) < log b o"}, {"tactic": "rw [h, log_zero_right]", "annotated_tactic": ["rw [h, <a>log_zero_right</a>]", [{"full_name": "Ordinal.log_zero_right", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [284, 9], "def_end_pos": [284, 23]}]], "state_before": "case inl\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o = 0\n\u22a2 log b (o % b ^ log b o) < log b o", "state_after": "case inl\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o = 0\n\u22a2 0 < log b o"}, {"tactic": "apply log_pos hb ho hbo", "annotated_tactic": ["apply <a>log_pos</a> hb ho hbo", [{"full_name": "Ordinal.log_pos", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [343, 9], "def_end_pos": [343, 16]}]], "state_before": "case inl\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o = 0\n\u22a2 0 < log b o", "state_after": "no goals"}, {"tactic": "rw [\u2190 succ_le_iff, succ_log_def hb h]", "annotated_tactic": ["rw [\u2190 <a>succ_le_iff</a>, <a>succ_log_def</a> hb h]", [{"full_name": "Order.succ_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [343, 9], "def_end_pos": [343, 20]}, {"full_name": "Ordinal.succ_log_def", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [299, 9], "def_end_pos": [299, 21]}]], "state_before": "case inr\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 log b (o % b ^ log b o) < log b o", "state_after": "case inr\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 sInf {o_1 | o % b ^ log b o < b ^ o_1} \u2264 log b o"}, {"tactic": "apply csInf_le'", "annotated_tactic": ["apply <a>csInf_le'</a>", [{"full_name": "csInf_le'", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [1234, 9], "def_end_pos": [1234, 18]}]], "state_before": "case inr\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 sInf {o_1 | o % b ^ log b o < b ^ o_1} \u2264 log b o", "state_after": "case inr.h\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 log b o \u2208 {o_1 | o % b ^ log b o < b ^ o_1}"}, {"tactic": "apply mod_lt", "annotated_tactic": ["apply <a>mod_lt</a>", [{"full_name": "Ordinal.mod_lt", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1050, 9], "def_end_pos": [1050, 15]}]], "state_before": "case inr.h\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 log b o \u2208 {o_1 | o % b ^ log b o < b ^ o_1}", "state_after": "case inr.h.h\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 b ^ log b o \u2260 0"}, {"tactic": "rw [\u2190 Ordinal.pos_iff_ne_zero]", "annotated_tactic": ["rw [\u2190 <a>Ordinal.pos_iff_ne_zero</a>]", [{"full_name": "Ordinal.pos_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [406, 19], "def_end_pos": [406, 34]}]], "state_before": "case inr.h.h\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 b ^ log b o \u2260 0", "state_after": "case inr.h.h\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 0 < b ^ log b o"}, {"tactic": "exact opow_pos _ (zero_lt_one.trans hb)", "annotated_tactic": ["exact <a>opow_pos</a> _ (zero_lt_one.trans hb)", [{"full_name": "Ordinal.opow_pos", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [94, 9], "def_end_pos": [94, 17]}]], "state_before": "case inr.h.h\nb o : Ordinal.{u_1}\nhb : 1 < b\nho : o \u2260 0\nhbo : b \u2264 o\nh : o % b ^ log b o \u2260 0\n\u22a2 0 < b ^ log b o", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Defs.lean", "full_name": "PosSMulReflectLE_iff_posSMulReflectLT", "start": [708, 1], "end": [709, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/EReal.lean", "full_name": "EReal.neg_eq_zero_iff", "start": [936, 1], "end": [937, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.tsum_meas_le_meas_iUnion_of_disjoint", "start": [203, 1], "end": [207, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Cones.lean", "full_name": "CategoryTheory.Limits.Cocones.cocone_iso_of_hom_iso", "start": [529, 1], "end": [532, 79], "traced_tactics": [{"tactic": "aesop_cat", "annotated_tactic": ["aesop_cat", []], "state_before": "J : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF K : J \u2964 C\nc d : Cocone K\nf : c \u27f6 d\ni : IsIso f.hom\n\u22a2 f \u226b { hom := inv f.hom, w := \u22ef } = \ud835\udfd9 c \u2227 { hom := inv f.hom, w := \u22ef } \u226b f = \ud835\udfd9 d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.nsmul_lt_aleph0_iff", "start": [1664, 1], "end": [1671, 59], "traced_tactics": [{"tactic": "simpa using nat_lt_aleph0 0", "annotated_tactic": ["simpa using <a>nat_lt_aleph0</a> 0", [{"full_name": "Cardinal.nat_lt_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1527, 9], "def_end_pos": [1527, 22]}]], "state_before": "case zero\n\u03b1 \u03b2 : Type u\na : Cardinal.{u_1}\n\u22a2 Nat.zero \u2022 a < \u2135\u2080 \u2194 Nat.zero = 0 \u2228 a < \u2135\u2080", "state_after": "no goals"}, {"tactic": "simp only [Nat.succ_ne_zero, false_or_iff]", "annotated_tactic": ["simp only [<a>Nat.succ_ne_zero</a>, <a>false_or_iff</a>]", [{"full_name": "Nat.succ_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [465, 9], "def_end_pos": [465, 21]}, {"full_name": "false_or_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [178, 9], "def_end_pos": [178, 21]}]], "state_before": "case succ\n\u03b1 \u03b2 : Type u\na : Cardinal.{u_1}\nn : \u2115\n\u22a2 Nat.succ n \u2022 a < \u2135\u2080 \u2194 Nat.succ n = 0 \u2228 a < \u2135\u2080", "state_after": "case succ\n\u03b1 \u03b2 : Type u\na : Cardinal.{u_1}\nn : \u2115\n\u22a2 Nat.succ n \u2022 a < \u2135\u2080 \u2194 a < \u2135\u2080"}, {"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "case succ\n\u03b1 \u03b2 : Type u\na : Cardinal.{u_1}\nn : \u2115\n\u22a2 Nat.succ n \u2022 a < \u2135\u2080 \u2194 a < \u2135\u2080", "state_after": "case succ.zero\n\u03b1 \u03b2 : Type u\na : Cardinal.{u_1}\n\u22a2 Nat.succ Nat.zero \u2022 a < \u2135\u2080 \u2194 a < \u2135\u2080\n\ncase succ.succ\n\u03b1 \u03b2 : Type u\na : Cardinal.{u_1}\nn : \u2115\nih : Nat.succ n \u2022 a < \u2135\u2080 \u2194 a < \u2135\u2080\n\u22a2 Nat.succ (Nat.succ n) \u2022 a < \u2135\u2080 \u2194 a < \u2135\u2080"}, {"tactic": "rw [succ_nsmul, add_lt_aleph0_iff, ih, and_self_iff]", "annotated_tactic": ["rw [<a>succ_nsmul</a>, <a>add_lt_aleph0_iff</a>, ih, <a>and_self_iff</a>]", [{"full_name": "succ_nsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [655, 15], "def_end_pos": [655, 25]}, {"full_name": "Cardinal.add_lt_aleph0_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1654, 9], "def_end_pos": [1654, 26]}, {"full_name": "and_self_iff", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [20, 9], "def_end_pos": [20, 21]}]], "state_before": "case succ.succ\n\u03b1 \u03b2 : Type u\na : Cardinal.{u_1}\nn : \u2115\nih : Nat.succ n \u2022 a < \u2135\u2080 \u2194 a < \u2135\u2080\n\u22a2 Nat.succ (Nat.succ n) \u2022 a < \u2135\u2080 \u2194 a < \u2135\u2080", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case succ.zero\n\u03b1 \u03b2 : Type u\na : Cardinal.{u_1}\n\u22a2 Nat.succ Nat.zero \u2022 a < \u2135\u2080 \u2194 a < \u2135\u2080", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.leadingCoeff_X_pow_add_C", "start": [1547, 1], "end": [1551, 46], "traced_tactics": [{"tactic": "nontriviality R", "annotated_tactic": ["nontriviality R", []], "state_before": "R : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\nn : \u2115\nhn : 0 < n\nr : R\n\u22a2 leadingCoeff (X ^ n + C r) = 1", "state_after": "R : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\nn : \u2115\nhn : 0 < n\nr : R\na\u271d : Nontrivial R\n\u22a2 leadingCoeff (X ^ n + C r) = 1"}, {"tactic": "rw [leadingCoeff, natDegree_X_pow_add_C, coeff_add, coeff_X_pow_self, coeff_C,\n  if_neg (pos_iff_ne_zero.mp hn), add_zero]", "annotated_tactic": ["rw [<a>leadingCoeff</a>, <a>natDegree_X_pow_add_C</a>, <a>coeff_add</a>, <a>coeff_X_pow_self</a>, <a>coeff_C</a>,\n    <a>if_neg</a> (pos_iff_ne_zero.mp hn), <a>add_zero</a>]", [{"full_name": "Polynomial.leadingCoeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [74, 5], "def_end_pos": [74, 17]}, {"full_name": "Polynomial.natDegree_X_pow_add_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1524, 9], "def_end_pos": [1524, 30]}, {"full_name": "Polynomial.coeff_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [40, 9], "def_end_pos": [40, 18]}, {"full_name": "Polynomial.coeff_X_pow_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [211, 9], "def_end_pos": [211, 25]}, {"full_name": "Polynomial.coeff_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [741, 9], "def_end_pos": [741, 16]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\nn : \u2115\nhn : 0 < n\nr : R\na\u271d : Nontrivial R\n\u22a2 leadingCoeff (X ^ n + C r) = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Icc_eq_empty_of_lt", "start": [112, 1], "end": [113, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Circular.lean", "full_name": "btw_refl_left_right", "start": [291, 1], "end": [292, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/AddTorsor.lean", "full_name": "dist_vsub_cancel_left", "start": [142, 1], "end": [143, 79], "traced_tactics": [{"tactic": "rw [dist_eq_norm, vsub_sub_vsub_cancel_left, dist_comm, dist_eq_norm_vsub V]", "annotated_tactic": ["rw [<a>dist_eq_norm</a>, <a>vsub_sub_vsub_cancel_left</a>, <a>dist_comm</a>, <a>dist_eq_norm_vsub</a> V]", [{"full_name": "dist_eq_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [411, 7], "def_end_pos": [411, 19]}, {"full_name": "vsub_sub_vsub_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [250, 9], "def_end_pos": [250, 34]}, {"full_name": "dist_comm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [179, 9], "def_end_pos": [179, 18]}, {"full_name": "dist_eq_norm_vsub", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/AddTorsor.lean", "def_pos": [73, 9], "def_end_pos": [73, 26]}]], "state_before": "\u03b1 : Type u_1\nV : Type u_2\nP : Type u_3\nW : Type u_4\nQ : Type u_5\ninst\u271d\u2075 : SeminormedAddCommGroup V\ninst\u271d\u2074 : PseudoMetricSpace P\ninst\u271d\u00b3 : NormedAddTorsor V P\ninst\u271d\u00b2 : NormedAddCommGroup W\ninst\u271d\u00b9 : MetricSpace Q\ninst\u271d : NormedAddTorsor W Q\nx y z : P\n\u22a2 dist (x -\u1d65 y) (x -\u1d65 z) = dist y z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Real.cos_nonneg_of_mem_Icc", "start": [484, 1], "end": [485, 88], "traced_tactics": [{"tactic": "linarith [hx.1]", "annotated_tactic": ["linarith [hx.1]", []], "state_before": "x : \u211d\nhx : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)\n\u22a2 0 \u2264 x + \u03c0 / 2", "state_after": "no goals"}, {"tactic": "linarith [hx.2]", "annotated_tactic": ["linarith [hx.2]", []], "state_before": "x : \u211d\nhx : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)\n\u22a2 x + \u03c0 / 2 \u2264 \u03c0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Commute/Defs.lean", "full_name": "Commute.all", "start": [144, 11], "end": [145, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Integral.lean", "full_name": "IsLocalization.scaleRoots_commonDenom_mem_lifts", "start": [255, 1], "end": [275, 43], "traced_tactics": [{"tactic": "rw [Polynomial.lifts_iff_coeff_lifts]", "annotated_tactic": ["rw [<a>Polynomial.lifts_iff_coeff_lifts</a>]", [{"full_name": "Polynomial.lifts_iff_coeff_lifts", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Lifts.lean", "def_pos": [73, 9], "def_end_pos": [73, 30]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\n\u22a2 scaleRoots p ((algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p))) \u2208 lifts (algebraMap R R\u2098)", "state_after": "R : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\n\u22a2 \u2200 (n : \u2115),\n    coeff (scaleRoots p ((algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)))) n \u2208 Set.range \u21d1(algebraMap R R\u2098)"}, {"tactic": "intro n", "annotated_tactic": ["intro n", []], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\n\u22a2 \u2200 (n : \u2115),\n    coeff (scaleRoots p ((algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)))) n \u2208 Set.range \u21d1(algebraMap R R\u2098)", "state_after": "R : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\n\u22a2 coeff (scaleRoots p ((algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)))) n \u2208 Set.range \u21d1(algebraMap R R\u2098)"}, {"tactic": "rw [Polynomial.coeff_scaleRoots]", "annotated_tactic": ["rw [<a>Polynomial.coeff_scaleRoots</a>]", [{"full_name": "Polynomial.coeff_scaleRoots", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "def_pos": [35, 9], "def_end_pos": [35, 25]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\n\u22a2 coeff (scaleRoots p ((algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)))) n \u2208 Set.range \u21d1(algebraMap R R\u2098)", "state_after": "R : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)"}, {"tactic": "by_cases h\u2081 : n \u2208 p.support", "annotated_tactic": ["by_cases h\u2081 : n \u2208 p.support", []], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)", "state_after": "case pos\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)\n\ncase neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2209 support p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)"}, {"tactic": "by_cases h\u2082 : n = p.natDegree", "annotated_tactic": ["by_cases h\u2082 : n = p.natDegree", []], "state_before": "case pos\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)\n\ncase neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2209 support p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)", "state_after": "case pos\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : n = natDegree p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)\n\ncase neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)\n\ncase neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2209 support p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)"}, {"tactic": "rwa [h\u2082, Polynomial.coeff_natDegree, tsub_self, pow_zero, _root_.mul_one]", "annotated_tactic": ["rwa [h\u2082, <a>Polynomial.coeff_natDegree</a>, <a>tsub_self</a>, <a>pow_zero</a>, <a>_root_.mul_one</a>]", [{"full_name": "Polynomial.coeff_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [115, 9], "def_end_pos": [115, 24]}, {"full_name": "tsub_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [341, 9], "def_end_pos": [341, 18]}, {"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "case pos\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : n = natDegree p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)", "state_after": "no goals"}, {"tactic": "have : n + 1 \u2264 p.natDegree := lt_of_le_of_ne (Polynomial.le_natDegree_of_mem_supp _ h\u2081) h\u2082", "annotated_tactic": ["have : n + 1 \u2264 p.natDegree := <a>lt_of_le_of_ne</a> (<a>Polynomial.le_natDegree_of_mem_supp</a> _ h\u2081) h\u2082", [{"full_name": "lt_of_le_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [190, 9], "def_end_pos": [190, 23]}, {"full_name": "Polynomial.le_natDegree_of_mem_supp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [189, 9], "def_end_pos": [189, 33]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)", "state_after": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)"}, {"tactic": "rw [\u2190 tsub_add_cancel_of_le (le_tsub_of_add_le_left this), pow_add, pow_one, mul_comm,\n  _root_.mul_assoc, \u2190 map_pow]", "annotated_tactic": ["rw [\u2190 <a>tsub_add_cancel_of_le</a> (<a>le_tsub_of_add_le_left</a> this), <a>pow_add</a>, <a>pow_one</a>, <a>mul_comm</a>,\n      <a>_root_.mul_assoc</a>, \u2190 <a>map_pow</a>]", [{"full_name": "tsub_add_cancel_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [30, 9], "def_end_pos": [30, 30]}, {"full_name": "le_tsub_of_add_le_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [235, 9], "def_end_pos": [235, 31]}, {"full_name": "pow_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [103, 9], "def_end_pos": [103, 16]}, {"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "map_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [469, 9], "def_end_pos": [469, 16]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)", "state_after": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 (algebraMap R R\u2098) (\u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n - 1)) *\n      ((algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) * coeff p n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)"}, {"tactic": "change _ \u2208 (algebraMap R R\u2098).range", "annotated_tactic": ["change _ \u2208 (<a>algebraMap</a> R R\u2098).<a>range</a>", [{"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "RingHom.range", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Subring/Basic.lean", "def_pos": [593, 5], "def_end_pos": [593, 10]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 (algebraMap R R\u2098) (\u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n - 1)) *\n      ((algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) * coeff p n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)", "state_after": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 (algebraMap R R\u2098) (\u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n - 1)) *\n      ((algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) * coeff p n) \u2208\n    RingHom.range (algebraMap R R\u2098)"}, {"tactic": "apply mul_mem", "annotated_tactic": ["apply <a>mul_mem</a>", [{"full_name": "MulMemClass.mul_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Basic.lean", "def_pos": [63, 3], "def_end_pos": [63, 10]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 (algebraMap R R\u2098) (\u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n - 1)) *\n      ((algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) * coeff p n) \u2208\n    RingHom.range (algebraMap R R\u2098)", "state_after": "case neg.a\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 (algebraMap R R\u2098) (\u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n - 1)) \u2208 RingHom.range (algebraMap R R\u2098)\n\ncase neg.a\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) * coeff p n \u2208 RingHom.range (algebraMap R R\u2098)"}, {"tactic": "exact RingHom.mem_range_self _ _", "annotated_tactic": ["exact <a>RingHom.mem_range_self</a> _ _", [{"full_name": "RingHom.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Subring/Basic.lean", "def_pos": [612, 9], "def_end_pos": [612, 23]}]], "state_before": "case neg.a\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 (algebraMap R R\u2098) (\u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n - 1)) \u2208 RingHom.range (algebraMap R R\u2098)", "state_after": "no goals"}, {"tactic": "rw [\u2190 Algebra.smul_def]", "annotated_tactic": ["rw [\u2190 <a>Algebra.smul_def</a>]", [{"full_name": "Algebra.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}]], "state_before": "case neg.a\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) * coeff p n \u2208 RingHom.range (algebraMap R R\u2098)", "state_after": "case neg.a\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 \u2191(commonDenom M (support p) (coeff p)) \u2022 coeff p n \u2208 RingHom.range (algebraMap R R\u2098)"}, {"tactic": "exact \u27e8_, IsLocalization.map_integerMultiple M p.support p.coeff \u27e8n, h\u2081\u27e9\u27e9", "annotated_tactic": ["exact \u27e8_, <a>IsLocalization.map_integerMultiple</a> M p.support p.coeff \u27e8n, h\u2081\u27e9\u27e9", [{"full_name": "IsLocalization.map_integerMultiple", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Integer.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}]], "state_before": "case neg.a\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2208 support p\nh\u2082 : \u00acn = natDegree p\nthis : n + 1 \u2264 natDegree p\n\u22a2 \u2191(commonDenom M (support p) (coeff p)) \u2022 coeff p n \u2208 RingHom.range (algebraMap R R\u2098)", "state_after": "no goals"}, {"tactic": "rw [Polynomial.not_mem_support_iff] at h\u2081", "annotated_tactic": ["rw [<a>Polynomial.not_mem_support_iff</a>] at h\u2081", [{"full_name": "Polynomial.not_mem_support_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [738, 9], "def_end_pos": [738, 28]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : n \u2209 support p\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)", "state_after": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : coeff p n = 0\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)"}, {"tactic": "rw [h\u2081, zero_mul]", "annotated_tactic": ["rw [h\u2081, <a>zero_mul</a>]", [{"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : coeff p n = 0\n\u22a2 coeff p n * (algebraMap R R\u2098) \u2191(commonDenom M (support p) (coeff p)) ^ (natDegree p - n) \u2208\n    Set.range \u21d1(algebraMap R R\u2098)", "state_after": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : coeff p n = 0\n\u22a2 0 \u2208 Set.range \u21d1(algebraMap R R\u2098)"}, {"tactic": "exact zero_mem (algebraMap R R\u2098).range", "annotated_tactic": ["exact <a>zero_mem</a> (<a>algebraMap</a> R R\u2098).<a>range</a>", [{"full_name": "ZeroMemClass.zero_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [79, 3], "def_end_pos": [79, 11]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "RingHom.range", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Subring/Basic.lean", "def_pos": [593, 5], "def_end_pos": [593, 10]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nR\u2098 : Type u_4\nS\u2098 : Type u_5\ninst\u271d\u2075 : CommRing R\u2098\ninst\u271d\u2074 : CommRing S\u2098\ninst\u271d\u00b3 : Algebra R R\u2098\ninst\u271d\u00b2 : IsLocalization M R\u2098\ninst\u271d\u00b9 : Algebra S S\u2098\ninst\u271d : IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098\np : R\u2098[X]\nhp : leadingCoeff p \u2208 RingHom.range (algebraMap R R\u2098)\nn : \u2115\nh\u2081 : coeff p n = 0\n\u22a2 0 \u2208 Set.range \u21d1(algebraMap R R\u2098)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "full_name": "quadraticCharFun_one", "start": [80, 1], "end": [81, 85], "traced_tactics": [{"tactic": "simp only [quadraticCharFun, one_ne_zero, isSquare_one, if_true, if_false, id.def]", "annotated_tactic": ["simp only [<a>quadraticCharFun</a>, <a>one_ne_zero</a>, <a>isSquare_one</a>, <a>if_true</a>, <a>if_false</a>, <a>id.def</a>]", [{"full_name": "quadraticCharFun", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [43, 5], "def_end_pos": [43, 21]}, {"full_name": "one_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}, {"full_name": "isSquare_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Parity.lean", "def_pos": [102, 9], "def_end_pos": [102, 21]}, {"full_name": "if_true", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [24, 17], "def_end_pos": [24, 24]}, {"full_name": "if_false", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [26, 17], "def_end_pos": [26, 25]}, {"full_name": "id.def", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [22, 9], "def_end_pos": [22, 15]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Fintype F\ninst\u271d : DecidableEq F\n\u22a2 quadraticCharFun F 1 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Basic.lean", "full_name": "UniformSpace.comap_iInf", "start": [1266, 1], "end": [1269, 43], "traced_tactics": [{"tactic": "ext : 1", "annotated_tactic": ["ext : 1", []], "state_before": "\u03b1\u271d : Type ua\n\u03b2 : Type ub\n\u03b3\u271d : Type uc\n\u03b4 : Type ud\n\u03b9\u271d : Sort u_1\n\u03b9 : Sort u_2\n\u03b1 : Type u_3\n\u03b3 : Type u_4\nu : \u03b9 \u2192 UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 comap f (\u2a05 i, u i) = \u2a05 i, comap f (u i)", "state_after": "case a\n\u03b1\u271d : Type ua\n\u03b2 : Type ub\n\u03b3\u271d : Type uc\n\u03b4 : Type ud\n\u03b9\u271d : Sort u_1\n\u03b9 : Sort u_2\n\u03b1 : Type u_3\n\u03b3 : Type u_4\nu : \u03b9 \u2192 UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 \ud835\udce4 \u03b1 = \ud835\udce4 \u03b1"}, {"tactic": "simp [uniformity_comap, iInf_uniformity]", "annotated_tactic": ["simp [<a>uniformity_comap</a>, <a>iInf_uniformity</a>]", [{"full_name": "uniformity_comap", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [1244, 9], "def_end_pos": [1244, 25]}, {"full_name": "iInf_uniformity", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [1200, 9], "def_end_pos": [1200, 24]}]], "state_before": "case a\n\u03b1\u271d : Type ua\n\u03b2 : Type ub\n\u03b3\u271d : Type uc\n\u03b4 : Type ud\n\u03b9\u271d : Sort u_1\n\u03b9 : Sort u_2\n\u03b1 : Type u_3\n\u03b3 : Type u_4\nu : \u03b9 \u2192 UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 \ud835\udce4 \u03b1 = \ud835\udce4 \u03b1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompactlyGenerated/Basic.lean", "full_name": "CompleteLattice.isCompactElement_iff", "start": [83, 1], "end": [105, 95], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\n\u22a2 IsCompactElement k \u2194 \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s", "state_after": "case mp\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\n\u22a2 IsCompactElement k \u2192 \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\n\ncase mpr\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\n\u22a2 (\u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s) \u2192 IsCompactElement k"}, {"tactic": "intro H \u03b9 s hs", "annotated_tactic": ["intro H \u03b9 s hs", []], "state_before": "case mp\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\n\u22a2 IsCompactElement k \u2192 \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s", "state_after": "case mp\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\n\u22a2 \u2203 t, k \u2264 Finset.sup t s"}, {"tactic": "obtain \u27e8t, ht, ht'\u27e9 := H (Set.range s) hs", "annotated_tactic": ["obtain \u27e8t, ht, ht'\u27e9 := H (<a>Set.range</a> s) hs", [{"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}]], "state_before": "case mp\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\n\u22a2 \u2203 t, k \u2264 Finset.sup t s", "state_after": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\n\u22a2 \u2203 t, k \u2264 Finset.sup t s"}, {"tactic": "have : \u2200 x : t, \u2203 i, s i = x := fun x => ht x.prop", "annotated_tactic": ["have : \u2200 x : t, \u2203 i, s i = x := fun x => ht x.prop", []], "state_before": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\n\u22a2 \u2203 t, k \u2264 Finset.sup t s", "state_after": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nthis : \u2200 (x : { x // x \u2208 t }), \u2203 i, s i = \u2191x\n\u22a2 \u2203 t, k \u2264 Finset.sup t s"}, {"tactic": "choose f hf using this", "annotated_tactic": ["choose f hf using this", []], "state_before": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nthis : \u2200 (x : { x // x \u2208 t }), \u2203 i, s i = \u2191x\n\u22a2 \u2203 t, k \u2264 Finset.sup t s", "state_after": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\n\u22a2 \u2203 t, k \u2264 Finset.sup t s"}, {"tactic": "refine' \u27e8Finset.univ.image f, ht'.trans _\u27e9", "annotated_tactic": ["refine' \u27e8Finset.univ.image f, ht'.trans _\u27e9", []], "state_before": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\n\u22a2 \u2203 t, k \u2264 Finset.sup t s", "state_after": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\n\u22a2 Finset.sup t id \u2264 Finset.sup (Finset.image f Finset.univ) s"}, {"tactic": "rw [Finset.sup_le_iff]", "annotated_tactic": ["rw [<a>Finset.sup_le_iff</a>]", [{"full_name": "Finset.sup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [98, 19], "def_end_pos": [98, 29]}]], "state_before": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\n\u22a2 Finset.sup t id \u2264 Finset.sup (Finset.image f Finset.univ) s", "state_after": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\n\u22a2 \u2200 b \u2208 t, id b \u2264 Finset.sup (Finset.image f Finset.univ) s"}, {"tactic": "intro b hb", "annotated_tactic": ["intro b hb", []], "state_before": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\n\u22a2 \u2200 b \u2208 t, id b \u2264 Finset.sup (Finset.image f Finset.univ) s", "state_after": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\nb : \u03b1\nhb : b \u2208 t\n\u22a2 id b \u2264 Finset.sup (Finset.image f Finset.univ) s"}, {"tactic": "rw [\u2190 show s (f \u27e8b, hb\u27e9) = id b from hf _]", "annotated_tactic": ["rw [\u2190 show s (f \u27e8b, hb\u27e9) = <a>id</a> b from hf _]", [{"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\nb : \u03b1\nhb : b \u2208 t\n\u22a2 id b \u2264 Finset.sup (Finset.image f Finset.univ) s", "state_after": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\nb : \u03b1\nhb : b \u2208 t\n\u22a2 s (f { val := b, property := hb }) \u2264 Finset.sup (Finset.image f Finset.univ) s"}, {"tactic": "exact Finset.le_sup (Finset.mem_image_of_mem f <| Finset.mem_univ (Subtype.mk b hb))", "annotated_tactic": ["exact <a>Finset.le_sup</a> (<a>Finset.mem_image_of_mem</a> f <| <a>Finset.mem_univ</a> (<a>Subtype.mk</a> b hb))", [{"full_name": "Finset.le_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [111, 9], "def_end_pos": [111, 15]}, {"full_name": "Finset.mem_image_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [365, 9], "def_end_pos": [365, 25]}, {"full_name": "Finset.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [73, 9], "def_end_pos": [73, 17]}, {"full_name": "Subtype.mk", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [578, 11], "def_end_pos": [578, 18]}]], "state_before": "case mp.intro.intro\n\u03b9\u271d : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf\u271d : \u03b9\u271d \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : IsCompactElement k\n\u03b9 : Type u\ns : \u03b9 \u2192 \u03b1\nhs : k \u2264 iSup s\nt : Finset \u03b1\nht : \u2191t \u2286 range s\nht' : k \u2264 Finset.sup t id\nf : { x // x \u2208 t } \u2192 \u03b9\nhf : \u2200 (x : { x // x \u2208 t }), s (f x) = \u2191x\nb : \u03b1\nhb : b \u2208 t\n\u22a2 s (f { val := b, property := hb }) \u2264 Finset.sup (Finset.image f Finset.univ) s", "state_after": "no goals"}, {"tactic": "intro H s hs", "annotated_tactic": ["intro H s hs", []], "state_before": "case mpr\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\n\u22a2 (\u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s) \u2192 IsCompactElement k", "state_after": "case mpr\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\n\u22a2 \u2203 t, \u2191t \u2286 s \u2227 k \u2264 Finset.sup t id"}, {"tactic": "obtain \u27e8t, ht\u27e9 :=\n  H s Subtype.val\n    (by\n      delta iSup\n      rwa [Subtype.range_coe])", "annotated_tactic": ["obtain \u27e8t, ht\u27e9 :=\n        H s <a>Subtype.val</a>\n          (by\n            delta <a>iSup</a>\n            rwa [<a>Subtype.range_coe</a>])", [{"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}, {"full_name": "iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [64, 5], "def_end_pos": [64, 9]}, {"full_name": "Subtype.range_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1369, 9], "def_end_pos": [1369, 18]}]], "state_before": "case mpr\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\n\u22a2 \u2203 t, \u2191t \u2286 s \u2227 k \u2264 Finset.sup t id", "state_after": "case mpr.intro\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\nt : Finset \u2191s\nht : k \u2264 Finset.sup t Subtype.val\n\u22a2 \u2203 t, \u2191t \u2286 s \u2227 k \u2264 Finset.sup t id"}, {"tactic": "refine' \u27e8t.image Subtype.val, by simp, ht.trans _\u27e9", "annotated_tactic": ["refine' \u27e8t.image <a>Subtype.val</a>, by simp, ht.trans _\u27e9", [{"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}]], "state_before": "case mpr.intro\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\nt : Finset \u2191s\nht : k \u2264 Finset.sup t Subtype.val\n\u22a2 \u2203 t, \u2191t \u2286 s \u2227 k \u2264 Finset.sup t id", "state_after": "case mpr.intro\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\nt : Finset \u2191s\nht : k \u2264 Finset.sup t Subtype.val\n\u22a2 Finset.sup t Subtype.val \u2264 Finset.sup (Finset.image Subtype.val t) id"}, {"tactic": "rw [Finset.sup_le_iff]", "annotated_tactic": ["rw [<a>Finset.sup_le_iff</a>]", [{"full_name": "Finset.sup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [98, 19], "def_end_pos": [98, 29]}]], "state_before": "case mpr.intro\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\nt : Finset \u2191s\nht : k \u2264 Finset.sup t Subtype.val\n\u22a2 Finset.sup t Subtype.val \u2264 Finset.sup (Finset.image Subtype.val t) id", "state_after": "case mpr.intro\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\nt : Finset \u2191s\nht : k \u2264 Finset.sup t Subtype.val\n\u22a2 \u2200 b \u2208 t, \u2191b \u2264 Finset.sup (Finset.image Subtype.val t) id"}, {"tactic": "exact fun x hx => @Finset.le_sup _ _ _ _ _ id _ (Finset.mem_image_of_mem Subtype.val hx)", "annotated_tactic": ["exact fun x hx => @<a>Finset.le_sup</a> _ _ _ _ _ <a>id</a> _ (<a>Finset.mem_image_of_mem</a> <a>Subtype.val</a> hx)", [{"full_name": "Finset.le_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [111, 9], "def_end_pos": [111, 15]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "Finset.mem_image_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [365, 9], "def_end_pos": [365, 25]}, {"full_name": "Subtype.val", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [582, 3], "def_end_pos": [582, 6]}]], "state_before": "case mpr.intro\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\nt : Finset \u2191s\nht : k \u2264 Finset.sup t Subtype.val\n\u22a2 \u2200 b \u2208 t, \u2191b \u2264 Finset.sup (Finset.image Subtype.val t) id", "state_after": "no goals"}, {"tactic": "delta iSup", "annotated_tactic": ["delta <a>iSup</a>", [{"full_name": "iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [64, 5], "def_end_pos": [64, 9]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\n\u22a2 k \u2264 iSup Subtype.val", "state_after": "\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\n\u22a2 k \u2264 sSup (range Subtype.val)"}, {"tactic": "rwa [Subtype.range_coe]", "annotated_tactic": ["rwa [<a>Subtype.range_coe</a>]", [{"full_name": "Subtype.range_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1369, 9], "def_end_pos": [1369, 18]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\n\u22a2 k \u2264 sSup (range Subtype.val)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Sort u_1\n\u03b1\u271d : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\u271d\nf : \u03b9 \u2192 \u03b1\u271d\n\u03b1 : Type u\ninst\u271d : CompleteLattice \u03b1\nk : \u03b1\nH : \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t, k \u2264 Finset.sup t s\ns : Set \u03b1\nhs : k \u2264 sSup s\nt : Finset \u2191s\nht : k \u2264 Finset.sup t Subtype.val\n\u22a2 \u2191(Finset.image Subtype.val t) \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/Basic.lean", "full_name": "Algebra.rank_eq_of_equiv_equiv", "start": [233, 1], "end": [236, 64], "traced_tactics": [{"tactic": "simpa only [lift_id] using lift_rank_eq_of_equiv_equiv i j hc", "annotated_tactic": ["simpa only [<a>lift_id</a>] using <a>lift_rank_eq_of_equiv_equiv</a> i j hc", [{"full_name": "Cardinal.lift_id", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [224, 9], "def_end_pos": [224, 16]}, {"full_name": "Algebra.lift_rank_eq_of_equiv_equiv", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 36]}]], "state_before": "R\u271d : Type u\nR'\u271d : Type u'\nM M\u2081 : Type v\nM' : Type v'\ninst\u271d\u00b9\u2078 : Ring R\u271d\ninst\u271d\u00b9\u2077 : Ring R'\u271d\ninst\u271d\u00b9\u2076 : AddCommGroup M\ninst\u271d\u00b9\u2075 : AddCommGroup M'\ninst\u271d\u00b9\u2074 : AddCommGroup M\u2081\ninst\u271d\u00b9\u00b3 : Module R\u271d M\ninst\u271d\u00b9\u00b2 : Module R\u271d M'\ninst\u271d\u00b9\u00b9 : Module R\u271d M\u2081\ninst\u271d\u00b9\u2070 : Module R'\u271d M'\ninst\u271d\u2079 : Module R'\u271d M\u2081\nR : Type w\nS : Type v\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : Ring S\ninst\u271d\u2076 : Algebra R S\nR' : Type w'\nS'\u271d : Type v'\ninst\u271d\u2075 : CommRing R'\ninst\u271d\u2074 : Ring S'\u271d\ninst\u271d\u00b3 : Algebra R' S'\u271d\nS' : Type v\ninst\u271d\u00b2 : CommRing R'\ninst\u271d\u00b9 : Ring S'\ninst\u271d : Algebra R' S'\ni : R \u2243+* R'\nj : S \u2243+* S'\nhc : RingHom.comp (algebraMap R' S') (RingEquiv.toRingHom i) = RingHom.comp (RingEquiv.toRingHom j) (algebraMap R S)\n\u22a2 Module.rank R S = Module.rank R' S'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.ssubset_iff_insert", "start": [1159, 1], "end": [1161, 8], "traced_tactics": [{"tactic": "simp only [insert_subset_iff, exists_and_right, ssubset_def, not_subset]", "annotated_tactic": ["simp only [<a>insert_subset_iff</a>, <a>exists_and_right</a>, <a>ssubset_def</a>, <a>not_subset</a>]", [{"full_name": "Set.insert_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1139, 9], "def_end_pos": [1139, 26]}, {"full_name": "exists_and_right", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [224, 17], "def_end_pos": [224, 33]}, {"full_name": "Set.ssubset_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [330, 9], "def_end_pos": [330, 20]}, {"full_name": "Set.not_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [372, 9], "def_end_pos": [372, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u s t : Set \u03b1\n\u22a2 s \u2282 t \u2194 \u2203 a \u2209 s, insert a s \u2286 t", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u s t : Set \u03b1\n\u22a2 (s \u2286 t \u2227 \u2203 a \u2208 t, a \u2209 s) \u2194 \u2203 a \u2209 s, a \u2208 t \u2227 s \u2286 t"}, {"tactic": "aesop", "annotated_tactic": ["aesop", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u s t : Set \u03b1\n\u22a2 (s \u2286 t \u2227 \u2203 a \u2208 t, a \u2209 s) \u2194 \u2203 a \u2209 s, a \u2208 t \u2227 s \u2286 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "BotHom.coe_inf", "start": [542, 1], "end": [543, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "Real.dist_le_of_mem_uIcc", "start": [1366, 1], "end": [1368, 95], "traced_tactics": [{"tactic": "rwa [uIcc_comm]", "annotated_tactic": ["rwa [<a>uIcc_comm</a>]", [{"full_name": "Set.uIcc_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "def_pos": [78, 7], "def_end_pos": [78, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y x' y' : \u211d\nhx : x \u2208 uIcc x' y'\nhy : y \u2208 uIcc x' y'\n\u22a2 y \u2208 uIcc y' x'", "state_after": "no goals"}, {"tactic": "rwa [uIcc_comm]", "annotated_tactic": ["rwa [<a>uIcc_comm</a>]", [{"full_name": "Set.uIcc_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "def_pos": [78, 7], "def_end_pos": [78, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y x' y' : \u211d\nhx : x \u2208 uIcc x' y'\nhy : y \u2208 uIcc x' y'\n\u22a2 x \u2208 uIcc y' x'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "or_not", "start": [199, 1], "end": [199, 43], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Test.lean", "full_name": "mathd_numbertheory_517", "start": [1078, 1], "end": [1079, 40], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "\u22a2 121 * 122 * 123 % 4 = 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.Pos.addChar_right_comm", "start": [127, 1], "end": [130, 27], "traced_tactics": [{"tactic": "apply ext", "annotated_tactic": ["apply <a>ext</a>", [{"full_name": "String.Pos.ext", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [105, 16], "def_end_pos": [105, 19]}]], "state_before": "p : Pos\nc\u2081 c\u2082 : Char\n\u22a2 p + c\u2081 + c\u2082 = p + c\u2082 + c\u2081", "state_after": "case h\np : Pos\nc\u2081 c\u2082 : Char\n\u22a2 (p + c\u2081 + c\u2082).byteIdx = (p + c\u2082 + c\u2081).byteIdx"}, {"tactic": "repeat rw [pos_add_char]", "annotated_tactic": ["repeat rw [<a>pos_add_char</a>]", [{"full_name": "String.pos_add_char", "def_path": ".lake/packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [135, 17], "def_end_pos": [135, 29]}]], "state_before": "case h\np : Pos\nc\u2081 c\u2082 : Char\n\u22a2 (p + c\u2081 + c\u2082).byteIdx = (p + c\u2082 + c\u2081).byteIdx", "state_after": "case h\np : Pos\nc\u2081 c\u2082 : Char\n\u22a2 p.byteIdx + csize c\u2081 + csize c\u2082 = p.byteIdx + csize c\u2082 + csize c\u2081"}, {"tactic": "apply Nat.add_right_comm", "annotated_tactic": ["apply <a>Nat.add_right_comm</a>", [{"full_name": "Nat.add_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}]], "state_before": "case h\np : Pos\nc\u2081 c\u2082 : Char\n\u22a2 p.byteIdx + csize c\u2081 + csize c\u2082 = p.byteIdx + csize c\u2082 + csize c\u2081", "state_after": "no goals"}, {"tactic": "rw [pos_add_char]", "annotated_tactic": ["rw [<a>pos_add_char</a>]", [{"full_name": "String.pos_add_char", "def_path": ".lake/packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [135, 17], "def_end_pos": [135, 29]}]], "state_before": "case h\np : Pos\nc\u2081 c\u2082 : Char\n\u22a2 p.byteIdx + csize c\u2081 + csize c\u2082 = (p + c\u2082).byteIdx + csize c\u2081", "state_after": "case h\np : Pos\nc\u2081 c\u2082 : Char\n\u22a2 p.byteIdx + csize c\u2081 + csize c\u2082 = p.byteIdx + csize c\u2082 + csize c\u2081"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Basic.lean", "full_name": "Complex.im_tsum", "start": [687, 1], "end": [688, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Archimedean.lean", "full_name": "Nat.comap_cast_atTop", "start": [27, 1], "end": [29, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rat/Order.lean", "full_name": "Rat.nonneg_mul", "start": [64, 11], "end": [71, 23], "traced_tactics": [{"tactic": "have d\u20810 : 0 < (d\u2081 : \u2124) := Int.coe_nat_pos.2 (Nat.pos_of_ne_zero h\u2081)", "annotated_tactic": ["have d\u20810 : 0 < (d\u2081 : \u2124) := <a>Int.coe_nat_pos</a>.2 (<a>Nat.pos_of_ne_zero</a> h\u2081)", [{"full_name": "Int.coe_nat_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [40, 9], "def_end_pos": [40, 20]}, {"full_name": "Nat.pos_of_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [298, 19], "def_end_pos": [298, 33]}]], "state_before": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 * (n\u2082 /. \u2191d\u2082))", "state_after": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 * (n\u2082 /. \u2191d\u2082))"}, {"tactic": "have d\u20820 : 0 < (d\u2082 : \u2124) := Int.coe_nat_pos.2 (Nat.pos_of_ne_zero h\u2082)", "annotated_tactic": ["have d\u20820 : 0 < (d\u2082 : \u2124) := <a>Int.coe_nat_pos</a>.2 (<a>Nat.pos_of_ne_zero</a> h\u2082)", [{"full_name": "Int.coe_nat_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [40, 9], "def_end_pos": [40, 20]}, {"full_name": "Nat.pos_of_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [298, 19], "def_end_pos": [298, 33]}]], "state_before": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 * (n\u2082 /. \u2191d\u2082))", "state_after": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 * (n\u2082 /. \u2191d\u2082))"}, {"tactic": "rw [mul_def' d\u20810.ne.symm d\u20820.ne.symm, divInt_nonneg _ d\u20810, divInt_nonneg _ d\u20820,\n  divInt_nonneg _ (mul_pos d\u20810 d\u20820)]", "annotated_tactic": ["rw [<a>mul_def'</a> d\u20810.ne.symm d\u20820.ne.symm, <a>divInt_nonneg</a> _ d\u20810, <a>divInt_nonneg</a> _ d\u20820,\n        <a>divInt_nonneg</a> _ (<a>mul_pos</a> d\u20810 d\u20820)]", [{"full_name": "Rat.mul_def'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 17]}, {"full_name": "Rat.divInt_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Order.lean", "def_pos": [39, 9], "def_end_pos": [39, 22]}, {"full_name": "Rat.divInt_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Order.lean", "def_pos": [39, 9], "def_end_pos": [39, 22]}, {"full_name": "Rat.divInt_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Order.lean", "def_pos": [39, 9], "def_end_pos": [39, 22]}, {"full_name": "mul_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [406, 7], "def_end_pos": [406, 14]}]], "state_before": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\n\u22a2 Rat.Nonneg (n\u2081 /. \u2191d\u2081) \u2192 Rat.Nonneg (n\u2082 /. \u2191d\u2082) \u2192 Rat.Nonneg (n\u2081 /. \u2191d\u2081 * (n\u2082 /. \u2191d\u2082))", "state_after": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\n\u22a2 0 \u2264 n\u2081 \u2192 0 \u2264 n\u2082 \u2192 0 \u2264 n\u2081 * n\u2082"}, {"tactic": "apply mul_nonneg", "annotated_tactic": ["apply <a>mul_nonneg</a>", [{"full_name": "mul_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [437, 7], "def_end_pos": [437, 17]}]], "state_before": "a\u271d b\u271d c a b : \u211a\nn\u2081 : \u2124\nd\u2081 : \u2115\nh\u2081 : d\u2081 \u2260 0\nn\u2082 : \u2124\nd\u2082 : \u2115\nh\u2082 : d\u2082 \u2260 0\nd\u20810 : 0 < \u2191d\u2081\nd\u20820 : 0 < \u2191d\u2082\n\u22a2 0 \u2264 n\u2081 \u2192 0 \u2264 n\u2082 \u2192 0 \u2264 n\u2081 * n\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "GaloisConnection.l_csSup'", "start": [1452, 1], "end": [1453, 75], "traced_tactics": [{"tactic": "rw [gc.l_csSup hne hbdd, sSup_image']", "annotated_tactic": ["rw [gc.l_csSup hne hbdd, <a>sSup_image'</a>]", [{"full_name": "sSup_image'", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [628, 9], "def_end_pos": [628, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b2\ninst\u271d : Nonempty \u03b9\nl : \u03b1 \u2192 \u03b2\nu : \u03b2 \u2192 \u03b1\ngc : GaloisConnection l u\ns : Set \u03b1\nhne : Set.Nonempty s\nhbdd : BddAbove s\n\u22a2 l (sSup s) = sSup (l '' s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.le_generate_iff", "start": [371, 1], "end": [374, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean", "full_name": "PowerSeries.coeff_zero_eq_constantCoeff", "start": [226, 1], "end": [228, 6], "traced_tactics": [{"tactic": "rw [coeff, Finsupp.single_zero]", "annotated_tactic": ["rw [<a>coeff</a>, <a>Finsupp.single_zero</a>]", [{"full_name": "PowerSeries.coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerSeries/Basic.lean", "def_pos": [140, 5], "def_end_pos": [140, 10]}, {"full_name": "Finsupp.single_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [340, 9], "def_end_pos": [340, 20]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 \u21d1(coeff R 0) = \u21d1(constantCoeff R)", "state_after": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 \u21d1(MvPowerSeries.coeff R 0) = \u21d1(constantCoeff R)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 \u21d1(MvPowerSeries.coeff R 0) = \u21d1(constantCoeff R)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Power.lean", "full_name": "zpow_neg_mul_zpow_self", "start": [167, 1], "end": [169, 42], "traced_tactics": [{"tactic": "rw [zpow_neg]", "annotated_tactic": ["rw [<a>zpow_neg</a>]", [{"full_name": "zpow_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [293, 9], "def_end_pos": [293, 17]}]], "state_before": "G\u2080 : Type u_1\ninst\u271d : GroupWithZero G\u2080\nn : \u2124\nx : G\u2080\nh : x \u2260 0\n\u22a2 x ^ (-n) * x ^ n = 1", "state_after": "G\u2080 : Type u_1\ninst\u271d : GroupWithZero G\u2080\nn : \u2124\nx : G\u2080\nh : x \u2260 0\n\u22a2 (x ^ n)\u207b\u00b9 * x ^ n = 1"}, {"tactic": "exact inv_mul_cancel (zpow_ne_zero n h)", "annotated_tactic": ["exact <a>inv_mul_cancel</a> (<a>zpow_ne_zero</a> n h)", [{"full_name": "inv_mul_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NeZero.lean", "def_pos": [53, 9], "def_end_pos": [53, 23]}, {"full_name": "zpow_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Power.lean", "def_pos": [163, 9], "def_end_pos": [163, 21]}]], "state_before": "G\u2080 : Type u_1\ninst\u271d : GroupWithZero G\u2080\nn : \u2124\nx : G\u2080\nh : x \u2260 0\n\u22a2 (x ^ n)\u207b\u00b9 * x ^ n = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.filter_filter", "start": [471, 9], "end": [474, 46], "traced_tactics": [{"tactic": "apply ext'", "annotated_tactic": ["apply <a>ext'</a>", [{"full_name": "Array.ext'", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [790, 9], "def_end_pos": [790, 13]}]], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nl : Array \u03b1\n\u22a2 filter p (filter q l 0) 0 = filter (fun a => decide (p a = true \u2227 q a = true)) l 0", "state_after": "case h\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nl : Array \u03b1\n\u22a2 (filter p (filter q l 0) 0).data = (filter (fun a => decide (p a = true \u2227 q a = true)) l 0).data"}, {"tactic": "simp only [filter_data, List.filter_filter]", "annotated_tactic": ["simp only [<a>filter_data</a>, <a>List.filter_filter</a>]", [{"full_name": "Array.filter_data", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [460, 17], "def_end_pos": [460, 28]}, {"full_name": "List.filter_filter", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1409, 17], "def_end_pos": [1409, 30]}]], "state_before": "case h\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nl : Array \u03b1\n\u22a2 (filter p (filter q l 0) 0).data = (filter (fun a => decide (p a = true \u2227 q a = true)) l 0).data", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Order/Basic.lean", "full_name": "Nat.lt_one_iff", "start": [146, 1], "end": [147, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Finite.lean", "full_name": "Equiv.Perm.perm_inv_on_of_perm_on_finset", "start": [59, 1], "end": [67, 29], "traced_tactics": [{"tactic": "have h0 : \u2200 y \u2208 s, \u2203 (x : _) (hx : x \u2208 s), y = (fun i (_ : i \u2208 s) => f i) x hx :=\n  Finset.surj_on_of_inj_on_of_card_le (fun x hx => (fun i _ => f i) x hx) (fun a ha => h a ha)\n    (fun a\u2081 a\u2082 ha\u2081 ha\u2082 heq => (Equiv.apply_eq_iff_eq f).mp heq) rfl.ge", "annotated_tactic": ["have h0 : \u2200 y \u2208 s, \u2203 (x : _) (hx : x \u2208 s), y = (fun i (_ : i \u2208 s) => f i) x hx :=\n    <a>Finset.surj_on_of_inj_on_of_card_le</a> (fun x hx => (fun i _ => f i) x hx) (fun a ha => h a ha)\n      (fun a\u2081 a\u2082 ha\u2081 ha\u2082 heq => (<a>Equiv.apply_eq_iff_eq</a> f).<a>mp</a> heq) rfl.ge", [{"full_name": "Finset.surj_on_of_inj_on_of_card_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [400, 9], "def_end_pos": [400, 37]}, {"full_name": "Equiv.apply_eq_iff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [320, 9], "def_end_pos": [320, 24]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\n\u22a2 f\u207b\u00b9 y \u2208 s", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\n\u22a2 f\u207b\u00b9 y \u2208 s"}, {"tactic": "obtain \u27e8y2, hy2, heq\u27e9 := h0 y hy", "annotated_tactic": ["obtain \u27e8y2, hy2, heq\u27e9 := h0 y hy", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\n\u22a2 f\u207b\u00b9 y \u2208 s", "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 y \u2208 s"}, {"tactic": "convert hy2", "annotated_tactic": ["convert hy2", []], "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 y \u2208 s", "state_after": "case h.e'_4\n\u03b1 : Type u\n\u03b2 : Type v\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 y = y2"}, {"tactic": "rw [heq]", "annotated_tactic": ["rw [heq]", []], "state_before": "case h.e'_4\n\u03b1 : Type u\n\u03b2 : Type v\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 y = y2", "state_after": "case h.e'_4\n\u03b1 : Type u\n\u03b2 : Type v\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 ((fun i x => f i) y2 hy2) = y2"}, {"tactic": "simp only [inv_apply_self]", "annotated_tactic": ["simp only [<a>inv_apply_self</a>]", [{"full_name": "Equiv.Perm.inv_apply_self", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [76, 9], "def_end_pos": [76, 23]}]], "state_before": "case h.e'_4\n\u03b1 : Type u\n\u03b2 : Type v\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 ((fun i x => f i) y2 hy2) = y2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.insertNthTR_go_eq", "start": [554, 1], "end": [556, 78], "traced_tactics": [{"tactic": "simp [insertNthTR.go, insertNth]", "annotated_tactic": ["simp [<a>insertNthTR.go</a>, <a>insertNth</a>]", [{"full_name": "List.insertNthTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [549, 3], "def_end_pos": [549, 5]}, {"full_name": "List.insertNth", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [543, 5], "def_end_pos": [543, 14]}]], "state_before": "\u03b1\u271d : Type u_1\na : \u03b1\u271d\nacc : Array \u03b1\u271d\nn\u271d : Nat\n\u22a2 insertNthTR.go a (n\u271d + 1) [] acc = acc.data ++ insertNth (n\u271d + 1) a []", "state_after": "no goals"}, {"tactic": "simp [insertNthTR.go, insertNth, insertNthTR_go_eq n l]", "annotated_tactic": ["simp [<a>insertNthTR.go</a>, <a>insertNth</a>, insertNthTR_go_eq n l]", [{"full_name": "List.insertNthTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [549, 3], "def_end_pos": [549, 5]}, {"full_name": "List.insertNth", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [543, 5], "def_end_pos": [543, 14]}]], "state_before": "\u03b1\u271d : Type u_1\na\u271d : \u03b1\u271d\nacc : Array \u03b1\u271d\nn : Nat\na : \u03b1\u271d\nl : List \u03b1\u271d\n\u22a2 insertNthTR.go a\u271d (n + 1) (a :: l) acc = acc.data ++ insertNth (n + 1) a\u271d (a :: l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Operations.lean", "full_name": "ENNReal.sub_sub_cancel", "start": [451, 1], "end": [452, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Option.lean", "full_name": "Finset.mul_prod_eq_prod_insertNone", "start": [33, 1], "end": [35, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Isometry.lean", "full_name": "rotation_ne_conjLIE", "start": [65, 1], "end": [71, 23], "traced_tactics": [{"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "a : \u21a5circle\n\u22a2 rotation a \u2260 conjLIE", "state_after": "a : \u21a5circle\nh : rotation a = conjLIE\n\u22a2 False"}, {"tactic": "have h1 : rotation a 1 = conj 1 := LinearIsometryEquiv.congr_fun h 1", "annotated_tactic": ["have h1 : <a>rotation</a> a 1 = conj 1 := <a>LinearIsometryEquiv.congr_fun</a> h 1", [{"full_name": "rotation", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean", "def_pos": [41, 5], "def_end_pos": [41, 13]}, {"full_name": "LinearIsometryEquiv.congr_fun", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "def_pos": [602, 19], "def_end_pos": [602, 28]}]], "state_before": "a : \u21a5circle\nh : rotation a = conjLIE\n\u22a2 False", "state_after": "a : \u21a5circle\nh : rotation a = conjLIE\nh1 : (rotation a) 1 = (starRingEnd \u2102) 1\n\u22a2 False"}, {"tactic": "have hI : rotation a I = conj I := LinearIsometryEquiv.congr_fun h I", "annotated_tactic": ["have hI : <a>rotation</a> a <a>I</a> = conj <a>I</a> := <a>LinearIsometryEquiv.congr_fun</a> h <a>I</a>", [{"full_name": "rotation", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean", "def_pos": [41, 5], "def_end_pos": [41, 13]}, {"full_name": "Complex.I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [299, 5], "def_end_pos": [299, 6]}, {"full_name": "Complex.I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [299, 5], "def_end_pos": [299, 6]}, {"full_name": "LinearIsometryEquiv.congr_fun", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "def_pos": [602, 19], "def_end_pos": [602, 28]}, {"full_name": "Complex.I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [299, 5], "def_end_pos": [299, 6]}]], "state_before": "a : \u21a5circle\nh : rotation a = conjLIE\nh1 : (rotation a) 1 = (starRingEnd \u2102) 1\n\u22a2 False", "state_after": "a : \u21a5circle\nh : rotation a = conjLIE\nh1 : (rotation a) 1 = (starRingEnd \u2102) 1\nhI : (rotation a) I = (starRingEnd \u2102) I\n\u22a2 False"}, {"tactic": "rw [rotation_apply, RingHom.map_one, mul_one] at h1", "annotated_tactic": ["rw [<a>rotation_apply</a>, <a>RingHom.map_one</a>, <a>mul_one</a>] at h1", [{"full_name": "rotation_apply", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean", "def_pos": [50, 9], "def_end_pos": [50, 23]}, {"full_name": "RingHom.map_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [554, 19], "def_end_pos": [554, 26]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "a : \u21a5circle\nh : rotation a = conjLIE\nh1 : (rotation a) 1 = (starRingEnd \u2102) 1\nhI : (rotation a) I = (starRingEnd \u2102) I\n\u22a2 False", "state_after": "a : \u21a5circle\nh : rotation a = conjLIE\nh1 : \u2191a = 1\nhI : (rotation a) I = (starRingEnd \u2102) I\n\u22a2 False"}, {"tactic": "rw [rotation_apply, conj_I, \u2190 neg_one_mul, mul_left_inj' I_ne_zero, h1, eq_neg_self_iff] at hI", "annotated_tactic": ["rw [<a>rotation_apply</a>, <a>conj_I</a>, \u2190 <a>neg_one_mul</a>, <a>mul_left_inj'</a> <a>I_ne_zero</a>, h1, <a>eq_neg_self_iff</a>] at hI", [{"full_name": "rotation_apply", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean", "def_pos": [50, 9], "def_end_pos": [50, 23]}, {"full_name": "Complex.conj_I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [554, 9], "def_end_pos": [554, 15]}, {"full_name": "neg_one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [345, 9], "def_end_pos": [345, 20]}, {"full_name": "mul_left_inj'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [126, 9], "def_end_pos": [126, 22]}, {"full_name": "Complex.I_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [327, 15], "def_end_pos": [327, 24]}, {"full_name": "eq_neg_self_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharZero/Lemmas.lean", "def_pos": [117, 17], "def_end_pos": [117, 32]}]], "state_before": "a : \u21a5circle\nh : rotation a = conjLIE\nh1 : \u2191a = 1\nhI : (rotation a) I = (starRingEnd \u2102) I\n\u22a2 False", "state_after": "a : \u21a5circle\nh : rotation a = conjLIE\nh1 : \u2191a = 1\nhI : 1 = 0\n\u22a2 False"}, {"tactic": "exact one_ne_zero hI", "annotated_tactic": ["exact <a>one_ne_zero</a> hI", [{"full_name": "one_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}]], "state_before": "a : \u21a5circle\nh : rotation a = conjLIE\nh1 : \u2191a = 1\nhI : 1 = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.sup", "start": [748, 1], "end": [749, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Multilinear/Basic.lean", "full_name": "ContinuousMultilinearMap.mkPiAlgebraFin_apply", "start": [630, 1], "end": [632, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/NAry.lean", "full_name": "Filter.map_prod_eq_map\u2082'", "start": [58, 1], "end": [60, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Powerset.lean", "full_name": "Finset.empty_mem_powerset", "start": [48, 1], "end": [49, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Multiplicity.lean", "full_name": "Nat.multiplicity_eq_card_pow_dvd", "start": [61, 1], "end": [77, 35], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "m n b : \u2115\nhm : m \u2260 1\nhn : 0 < n\nhb : log m n < b\n\u22a2 multiplicity m n = \u2191(Ico 1 ((multiplicity m n).get \u22ef + 1)).card", "state_after": "no goals"}, {"tactic": "rw [mem_filter, mem_Ico, mem_Ico, Nat.lt_succ_iff, \u2190 @PartENat.coe_le_coe i,\n  PartENat.natCast_get, \u2190 pow_dvd_iff_le_multiplicity, and_right_comm]", "annotated_tactic": ["rw [<a>mem_filter</a>, <a>mem_Ico</a>, <a>mem_Ico</a>, <a>Nat.lt_succ_iff</a>, \u2190 @<a>PartENat.coe_le_coe</a> i,\n              <a>PartENat.natCast_get</a>, \u2190 <a>pow_dvd_iff_le_multiplicity</a>, <a>and_right_comm</a>]", [{"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "Finset.mem_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [332, 9], "def_end_pos": [332, 16]}, {"full_name": "Finset.mem_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [332, 9], "def_end_pos": [332, 16]}, {"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}, {"full_name": "PartENat.coe_le_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [310, 9], "def_end_pos": [310, 19]}, {"full_name": "PartENat.natCast_get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [179, 9], "def_end_pos": [179, 20]}, {"full_name": "multiplicity.pow_dvd_iff_le_multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [148, 9], "def_end_pos": [148, 36]}, {"full_name": "and_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [45, 9], "def_end_pos": [45, 23]}]], "state_before": "m n b : \u2115\nhm : m \u2260 1\nhn : 0 < n\nhb : log m n < b\ni : \u2115\n\u22a2 i \u2208 Ico 1 ((multiplicity m n).get \u22ef + 1) \u2194 i \u2208 filter (fun i => m ^ i \u2223 n) (Ico 1 b)", "state_after": "m n b : \u2115\nhm : m \u2260 1\nhn : 0 < n\nhb : log m n < b\ni : \u2115\n\u22a2 1 \u2264 i \u2227 m ^ i \u2223 n \u2194 (1 \u2264 i \u2227 m ^ i \u2223 n) \u2227 i < b"}, {"tactic": "refine' (and_iff_left_of_imp fun h => lt_of_le_of_lt _ hb).symm", "annotated_tactic": ["refine' (<a>and_iff_left_of_imp</a> fun h => <a>lt_of_le_of_lt</a> _ hb).<a>symm</a>", [{"full_name": "and_iff_left_of_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [148, 9], "def_end_pos": [148, 28]}, {"full_name": "lt_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}, {"full_name": "Iff.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [808, 9], "def_end_pos": [808, 17]}]], "state_before": "m n b : \u2115\nhm : m \u2260 1\nhn : 0 < n\nhb : log m n < b\ni : \u2115\n\u22a2 1 \u2264 i \u2227 m ^ i \u2223 n \u2194 (1 \u2264 i \u2227 m ^ i \u2223 n) \u2227 i < b", "state_after": "m n b : \u2115\nhm : m \u2260 1\nhn : 0 < n\nhb : log m n < b\ni : \u2115\nh : 1 \u2264 i \u2227 m ^ i \u2223 n\n\u22a2 i \u2264 log m n"}, {"tactic": "cases' m with m", "annotated_tactic": ["cases' m with m", []], "state_before": "m n b : \u2115\nhm : m \u2260 1\nhn : 0 < n\nhb : log m n < b\ni : \u2115\nh : 1 \u2264 i \u2227 m ^ i \u2223 n\n\u22a2 i \u2264 log m n", "state_after": "case zero\nn b : \u2115\nhn : 0 < n\ni : \u2115\nhm : zero \u2260 1\nhb : log zero n < b\nh : 1 \u2264 i \u2227 zero ^ i \u2223 n\n\u22a2 i \u2264 log zero n\n\ncase succ\nn b : \u2115\nhn : 0 < n\ni m : \u2115\nhm : succ m \u2260 1\nhb : log (succ m) n < b\nh : 1 \u2264 i \u2227 succ m ^ i \u2223 n\n\u22a2 i \u2264 log (succ m) n"}, {"tactic": "exact le_log_of_pow_le (one_lt_iff_ne_zero_and_ne_one.2 \u27e8m.succ_ne_zero, hm\u27e9)\n    (le_of_dvd hn h.2)", "annotated_tactic": ["exact <a>le_log_of_pow_le</a> (<a>one_lt_iff_ne_zero_and_ne_one</a>.2 \u27e8m.succ_ne_zero, hm\u27e9)\n                (<a>le_of_dvd</a> hn h.2)", [{"full_name": "Nat.le_log_of_pow_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [114, 9], "def_end_pos": [114, 25]}, {"full_name": "Nat.one_lt_iff_ne_zero_and_ne_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [127, 7], "def_end_pos": [127, 36]}, {"full_name": "Nat.le_of_dvd", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean", "def_pos": [52, 9], "def_end_pos": [52, 18]}]], "state_before": "case succ\nn b : \u2115\nhn : 0 < n\ni m : \u2115\nhm : succ m \u2260 1\nhb : log (succ m) n < b\nh : 1 \u2264 i \u2227 succ m ^ i \u2223 n\n\u22a2 i \u2264 log (succ m) n", "state_after": "no goals"}, {"tactic": "rw [zero_eq, zero_pow, zero_dvd_iff] at h", "annotated_tactic": ["rw [<a>zero_eq</a>, <a>zero_pow</a>, <a>zero_dvd_iff</a>] at h", [{"full_name": "Nat.zero_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [83, 17], "def_end_pos": [83, 24]}, {"full_name": "zero_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [159, 15], "def_end_pos": [159, 23]}, {"full_name": "zero_dvd_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean", "def_pos": [33, 9], "def_end_pos": [33, 21]}]], "state_before": "case zero\nn b : \u2115\nhn : 0 < n\ni : \u2115\nhm : zero \u2260 1\nhb : log zero n < b\nh : 1 \u2264 i \u2227 zero ^ i \u2223 n\n\u22a2 i \u2264 log zero n", "state_after": "case zero\nn b : \u2115\nhn : 0 < n\ni : \u2115\nhm : zero \u2260 1\nhb : log zero n < b\nh : 1 \u2264 i \u2227 n = 0\n\u22a2 i \u2264 log zero n\n\ncase zero\nn b : \u2115\nhn : 0 < n\ni : \u2115\nhm : zero \u2260 1\nhb : log zero n < b\nh : 1 \u2264 i \u2227 0 ^ i \u2223 n\n\u22a2 i \u2260 0"}, {"tactic": "exacts [(hn.ne' h.2).elim, one_le_iff_ne_zero.1 h.1]", "annotated_tactic": ["exacts [(hn.ne' h.2).<a>elim</a>, <a>one_le_iff_ne_zero</a>.1 h.1]", [{"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}, {"full_name": "Nat.one_le_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [124, 7], "def_end_pos": [124, 25]}]], "state_before": "case zero\nn b : \u2115\nhn : 0 < n\ni : \u2115\nhm : zero \u2260 1\nhb : log zero n < b\nh : 1 \u2264 i \u2227 n = 0\n\u22a2 i \u2264 log zero n\n\ncase zero\nn b : \u2115\nhn : 0 < n\ni : \u2115\nhm : zero \u2260 1\nhb : log zero n < b\nh : 1 \u2264 i \u2227 0 ^ i \u2223 n\n\u22a2 i \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Disjoint.subset_left_of_subset_union", "start": [2992, 1], "end": [2993, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Finset.univ_eq_attach", "start": [998, 1], "end": [999, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Sublists.lean", "full_name": "List.sublistsLen_succ_cons", "start": [272, 1], "end": [275, 23], "traced_tactics": [{"tactic": "rw [sublistsLen, sublistsLenAux, sublistsLenAux_eq, sublistsLenAux_eq, map_id,\n    append_nil]", "annotated_tactic": ["rw [<a>sublistsLen</a>, <a>sublistsLenAux</a>, <a>sublistsLenAux_eq</a>, <a>sublistsLenAux_eq</a>, <a>map_id</a>,\n      <a>append_nil</a>]", [{"full_name": "List.sublistsLen", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sublists.lean", "def_pos": [237, 5], "def_end_pos": [237, 16]}, {"full_name": "List.sublistsLenAux", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sublists.lean", "def_pos": [228, 5], "def_end_pos": [228, 19]}, {"full_name": "List.sublistsLenAux_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sublists.lean", "def_pos": [252, 9], "def_end_pos": [252, 26]}, {"full_name": "List.sublistsLenAux_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sublists.lean", "def_pos": [252, 9], "def_end_pos": [252, 26]}, {"full_name": "List.map_id", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [123, 17], "def_end_pos": [123, 23]}, {"full_name": "List.append_nil", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [133, 17], "def_end_pos": [133, 27]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b1 : Type u_1\nn : \u2115\na : \u03b1\nl : List \u03b1\n\u22a2 sublistsLen (n + 1) (a :: l) = sublistsLen (n + 1) l ++ map (cons a) (sublistsLen n l)", "state_after": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b1 : Type u_1\nn : \u2115\na : \u03b1\nl : List \u03b1\n\u22a2 sublistsLen (n + 1) l ++ map (id \u2218 cons a) (sublistsLen n l) = sublistsLen (n + 1) l ++ map (cons a) (sublistsLen n l)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b1 : Type u_1\nn : \u2115\na : \u03b1\nl : List \u03b1\n\u22a2 sublistsLen (n + 1) l ++ map (id \u2218 cons a) (sublistsLen n l) = sublistsLen (n + 1) l ++ map (cons a) (sublistsLen n l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Nat.xgcdAux_zero", "start": [52, 1], "end": [52, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.ofFinsupp_one", "start": [160, 1], "end": [161, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Order/Lemmas.lean", "full_name": "Nat.div_ne_zero_iff", "start": [86, 1], "end": [87, 52], "traced_tactics": [{"tactic": "rw [ne_eq, Nat.div_eq_zero_iff hb.bot_lt, not_lt]", "annotated_tactic": ["rw [<a>ne_eq</a>, <a>Nat.div_eq_zero_iff</a> hb.bot_lt, <a>not_lt</a>]", [{"full_name": "ne_eq", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [86, 17], "def_end_pos": [86, 22]}, {"full_name": "Nat.div_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Order/Lemmas.lean", "def_pos": [80, 19], "def_end_pos": [80, 34]}, {"full_name": "not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 15]}]], "state_before": "a b m n k : \u2115\nhb : b \u2260 0\n\u22a2 a / b \u2260 0 \u2194 b \u2264 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/Eq.lean", "full_name": "Mathlib.Meta.NormNum.isNat_eq_false", "start": [18, 1], "end": [20, 75], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : CharZero \u03b1\nn\u271d\u00b9 n\u271d : \u2115\nh : Nat.beq n\u271d\u00b9 n\u271d = false\n\u22a2 \u00ac\u2191n\u271d\u00b9 = \u2191n\u271d", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : CharZero \u03b1\nn\u271d\u00b9 n\u271d : \u2115\nh : Nat.beq n\u271d\u00b9 n\u271d = false\n\u22a2 \u00acn\u271d\u00b9 = n\u271d"}, {"tactic": "exact Nat.ne_of_beq_eq_false h", "annotated_tactic": ["exact <a>Nat.ne_of_beq_eq_false</a> h", [{"full_name": "Nat.ne_of_beq_eq_false", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1579, 9], "def_end_pos": [1579, 31]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : CharZero \u03b1\nn\u271d\u00b9 n\u271d : \u2115\nh : Nat.beq n\u271d\u00b9 n\u271d = false\n\u22a2 \u00acn\u271d\u00b9 = n\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/DirectSum/Module.lean", "full_name": "DirectSum.isInternal_ne_bot_iff", "start": [449, 1], "end": [452, 78], "traced_tactics": [{"tactic": "simp only [isInternal_submodule_iff_independent_and_iSup_eq_top]", "annotated_tactic": ["simp only [<a>isInternal_submodule_iff_independent_and_iSup_eq_top</a>]", [{"full_name": "DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/DirectSum/Module.lean", "def_pos": [432, 9], "def_end_pos": [432, 61]}]], "state_before": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_1\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\n\u22a2 (IsInternal fun i => A \u2191i) \u2194 IsInternal A", "state_after": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_1\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\n\u22a2 (CompleteLattice.Independent fun i => A \u2191i) \u2227 \u2a06 i, A \u2191i = \u22a4 \u2194 CompleteLattice.Independent A \u2227 iSup A = \u22a4"}, {"tactic": "exact Iff.and CompleteLattice.independent_ne_bot_iff_independent <| by simp", "annotated_tactic": ["exact <a>Iff.and</a> <a>CompleteLattice.independent_ne_bot_iff_independent</a> <| by simp", [{"full_name": "Iff.and", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [325, 7], "def_end_pos": [325, 14]}, {"full_name": "CompleteLattice.independent_ne_bot_iff_independent", "def_path": ".lake/packages/mathlib/Mathlib/Order/SupIndep.lean", "def_pos": [412, 9], "def_end_pos": [412, 43]}]], "state_before": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_1\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\n\u22a2 (CompleteLattice.Independent fun i => A \u2191i) \u2227 \u2a06 i, A \u2191i = \u22a4 \u2194 CompleteLattice.Independent A \u2227 iSup A = \u22a4", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_1\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\n\u22a2 \u2a06 i, A \u2191i = \u22a4 \u2194 iSup A = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.neg_one_le_sin", "start": [956, 1], "end": [957, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean", "full_name": "Polynomial.degree_list_prod", "start": [305, 1], "end": [306, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "full_name": "Ordinal.lift_type_le", "start": [715, 1], "end": [722, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Image.lean", "full_name": "Set.preimage_subtype_val_Iio", "start": [253, 1], "end": [253, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "MeasurableSet.coe_insert", "start": [2081, 1], "end": [2084, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Order/Basic.lean", "full_name": "Nat.add_eq_three_iff", "start": [177, 1], "end": [179, 8], "traced_tactics": [{"tactic": "omega", "annotated_tactic": ["omega", []], "state_before": "m n k l : \u2115\n\u22a2 m + n = 3 \u2194 m = 0 \u2227 n = 3 \u2228 m = 1 \u2227 n = 2 \u2228 m = 2 \u2227 n = 1 \u2228 m = 3 \u2227 n = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.closure_mono", "start": [865, 1], "end": [866, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.card_plift", "start": [383, 1], "end": [384, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/ModEq.lean", "full_name": "AddCommGroup.ModEq.sub_left_cancel'", "start": [252, 11], "end": [253, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/GroupWithZero.lean", "full_name": "tendsto_inv_iff\u2080", "start": [159, 1], "end": [161, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/Group.lean", "full_name": "Filter.Tendsto.abs", "start": [62, 11], "end": [64, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.eventually_top", "start": [1233, 1], "end": [1234, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "Antitone.map_iSup_le", "start": [954, 1], "end": [956, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "continuous_inf_dom_left\u2082", "start": [454, 1], "end": [461, 69], "traced_tactics": [{"tactic": "haveI := ta1", "annotated_tactic": ["haveI := ta1", []], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\n\u22a2 Sort ?u.25641", "state_after": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nthis : TopologicalSpace X\n\u22a2 Sort ?u.25641"}, {"tactic": "haveI := tb1", "annotated_tactic": ["haveI := tb1", []], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nthis : TopologicalSpace X\n\u22a2 Sort ?u.25641", "state_after": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nthis\u271d : TopologicalSpace X\nthis : TopologicalSpace Y\n\u22a2 Sort ?u.25641"}, {"tactic": "exact Continuous fun p : X \u00d7 Y => f p.1 p.2", "annotated_tactic": ["exact <a>Continuous</a> fun p : X \u00d7 Y => f p.1 p.2", [{"full_name": "Continuous", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [137, 11], "def_end_pos": [137, 21]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nthis\u271d : TopologicalSpace X\nthis : TopologicalSpace Y\n\u22a2 Sort ?u.25641", "state_after": "no goals"}, {"tactic": "haveI := ta1 \u2293 ta2", "annotated_tactic": ["haveI := ta1 \u2293 ta2", []], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\n\u22a2 Sort ?u.25644", "state_after": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nthis : TopologicalSpace X\n\u22a2 Sort ?u.25644"}, {"tactic": "haveI := tb1 \u2293 tb2", "annotated_tactic": ["haveI := tb1 \u2293 tb2", []], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nthis : TopologicalSpace X\n\u22a2 Sort ?u.25644", "state_after": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nthis\u271d : TopologicalSpace X\nthis : TopologicalSpace Y\n\u22a2 Sort ?u.25644"}, {"tactic": "exact Continuous fun p : X \u00d7 Y => f p.1 p.2", "annotated_tactic": ["exact <a>Continuous</a> fun p : X \u00d7 Y => f p.1 p.2", [{"full_name": "Continuous", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [137, 11], "def_end_pos": [137, 21]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type ?u.25627\nY : Type ?u.25633\nZ : Type ?u.25639\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nthis\u271d : TopologicalSpace X\nthis : TopologicalSpace Y\n\u22a2 Sort ?u.25644", "state_after": "no goals"}, {"tactic": "have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))", "annotated_tactic": ["have ha := @<a>continuous_inf_dom_left</a> _ _ <a>id</a> ta1 ta2 ta1 (@<a>continuous_id</a> _ (<a>id</a> _))", [{"full_name": "continuous_inf_dom_left", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [763, 9], "def_end_pos": [763, 32]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "continuous_id", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1582, 9], "def_end_pos": [1582, 22]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\n\u22a2 Continuous fun p => f p.1 p.2", "state_after": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2"}, {"tactic": "have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))", "annotated_tactic": ["have hb := @<a>continuous_inf_dom_left</a> _ _ <a>id</a> tb1 tb2 tb1 (@<a>continuous_id</a> _ (<a>id</a> _))", [{"full_name": "continuous_inf_dom_left", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [763, 9], "def_end_pos": [763, 32]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "continuous_id", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1582, 9], "def_end_pos": [1582, 22]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2", "state_after": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\nhb : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2"}, {"tactic": "have h_continuous_id := @Continuous.prod_map _ _ _ _ ta1 tb1 (ta1 \u2293 ta2) (tb1 \u2293 tb2) _ _ ha hb", "annotated_tactic": ["have h_continuous_id := @<a>Continuous.prod_map</a> _ _ _ _ ta1 tb1 (ta1 \u2293 ta2) (tb1 \u2293 tb2) _ _ ha hb", [{"full_name": "Continuous.prod_map", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [448, 9], "def_end_pos": [448, 28]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\nhb : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2", "state_after": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\nhb : Continuous id\nh_continuous_id : Continuous fun p => (id p.1, id p.2)\n\u22a2 Continuous fun p => f p.1 p.2"}, {"tactic": "exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id", "annotated_tactic": ["exact @<a>Continuous.comp</a> _ _ _ (<a>id</a> _) (<a>id</a> _) _ _ _ h h_continuous_id", [{"full_name": "Continuous.comp", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1590, 9], "def_end_pos": [1590, 24]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ\u271d : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\u271d\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\nhb : Continuous id\nh_continuous_id : Continuous fun p => (id p.1, id p.2)\n\u22a2 Continuous fun p => f p.1 p.2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Encodable/Basic.lean", "full_name": "ULower.ext", "start": [537, 11], "end": [538, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/DirectSum/Basic.lean", "full_name": "DirectSum.addHom_ext", "start": [172, 1], "end": [174, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Atoms.lean", "full_name": "covBy_iff_atom_Ici", "start": [230, 1], "end": [230, 88], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 a \u22d6 b \u2194 IsAtom { val := b, property := h }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.limsup_le_iSup", "start": [818, 1], "end": [819, 75], "traced_tactics": [{"tactic": "isBoundedDefault", "annotated_tactic": ["isBoundedDefault", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\ninst\u271d : CompleteLattice \u03b1\nf : Filter \u03b2\nu : \u03b2 \u2192 \u03b1\n\u22a2 IsCoboundedUnder (fun x x_1 => x \u2264 x_1) f u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsCoprime.mul_add_right_left", "start": [348, 1], "end": [350, 31], "traced_tactics": [{"tactic": "rw [add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime (z * y + x) y", "state_after": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime (x + z * y) y"}, {"tactic": "exact h.add_mul_right_left z", "annotated_tactic": ["exact h.add_mul_right_left z", []], "state_before": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime (x + z * y) y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Control/Monad/Basic.lean", "full_name": "map_eq_bind_pure_comp", "start": [44, 1], "end": [46, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Closure.lean", "full_name": "ClosureOperator.closure_sup_closure_left", "start": [237, 1], "end": [240, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Real.rpow_inv_lt_iff_of_neg", "start": [594, 1], "end": [596, 79], "traced_tactics": [{"tactic": "rw [\u2190 rpow_lt_rpow_iff_of_neg hy _ hz, rpow_inv_rpow _ hz.ne] <;> positivity", "annotated_tactic": ["rw [\u2190 <a>rpow_lt_rpow_iff_of_neg</a> hy _ hz, <a>rpow_inv_rpow</a> _ hz.ne] <;> positivity", [{"full_name": "Real.rpow_lt_rpow_iff_of_neg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [565, 7], "def_end_pos": [565, 30]}, {"full_name": "Real.rpow_inv_rpow", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [488, 15], "def_end_pos": [488, 28]}]], "state_before": "x y z : \u211d\nn : \u2115\nhx : 0 < x\nhy : 0 < y\nhz : z < 0\n\u22a2 x ^ z\u207b\u00b9 < y \u2194 y ^ z < x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/NumDen.lean", "full_name": "IsFractionRing.num_mul_den_eq_num_iff_eq'", "start": [82, 1], "end": [85, 51], "traced_tactics": [{"tactic": "simpa only [eq_comm, mk'_num_den] using eq_mk'_iff_mul_eq.mpr h", "annotated_tactic": ["simpa only [<a>eq_comm</a>, <a>mk'_num_den</a>] using eq_mk'_iff_mul_eq.mpr h", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "IsFractionRing.mk'_num_den", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/NumDen.lean", "def_pos": [65, 9], "def_end_pos": [65, 20]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nA : Type u_4\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : IsDomain A\ninst\u271d\u00b3 : UniqueFactorizationMonoid A\nK : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra A K\ninst\u271d : IsFractionRing A K\nx y : K\nh : y * (algebraMap A K) \u2191(den A x) = (algebraMap A K) (num A x)\n\u22a2 x = y", "state_after": "no goals"}, {"tactic": "rw [h, mk'_num_den]", "annotated_tactic": ["rw [h, <a>mk'_num_den</a>]", [{"full_name": "IsFractionRing.mk'_num_den", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/NumDen.lean", "def_pos": [65, 9], "def_end_pos": [65, 20]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Algebra R S\nP : Type u_3\ninst\u271d\u2076 : CommRing P\nA : Type u_4\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : IsDomain A\ninst\u271d\u00b3 : UniqueFactorizationMonoid A\nK : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra A K\ninst\u271d : IsFractionRing A K\nx y : K\nh : x = y\n\u22a2 y = mk' K (num A x) (den A x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sum/Basic.lean", "full_name": "Sum.swap_rightInverse", "start": [183, 1], "end": [184, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "full_name": "AffineIsometry.toAffineMap_injective", "start": [86, 1], "end": [88, 6], "traced_tactics": [{"tactic": "rintro \u27e8f, _\u27e9 \u27e8g, _\u27e9 rfl", "annotated_tactic": ["rintro \u27e8f, _\u27e9 \u27e8g, _\u27e9 rfl", []], "state_before": "\ud835\udd5c : Type u_1\nV : Type u_2\nV\u2081 : Type u_3\nV\u2081' : Type u_4\nV\u2082 : Type u_5\nV\u2083 : Type u_6\nV\u2084 : Type u_7\nP\u2081 : Type u_8\nP\u2081' : Type u_9\nP : Type u_10\nP\u2082 : Type u_11\nP\u2083 : Type u_12\nP\u2084 : Type u_13\ninst\u271d\u00b2\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b2\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2\u00b2 : NormedSpace \ud835\udd5c V\ninst\u271d\u00b2\u00b9 : PseudoMetricSpace P\ninst\u271d\u00b2\u2070 : NormedAddTorsor V P\ninst\u271d\u00b9\u2079 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9\u2078 : NormedSpace \ud835\udd5c V\u2081\ninst\u271d\u00b9\u2077 : PseudoMetricSpace P\u2081\ninst\u271d\u00b9\u2076 : NormedAddTorsor V\u2081 P\u2081\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup V\u2081'\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c V\u2081'\ninst\u271d\u00b9\u00b3 : MetricSpace P\u2081'\ninst\u271d\u00b9\u00b2 : NormedAddTorsor V\u2081' P\u2081'\ninst\u271d\u00b9\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c V\u2082\ninst\u271d\u2079 : PseudoMetricSpace P\u2082\ninst\u271d\u2078 : NormedAddTorsor V\u2082 P\u2082\ninst\u271d\u2077 : SeminormedAddCommGroup V\u2083\ninst\u271d\u2076 : NormedSpace \ud835\udd5c V\u2083\ninst\u271d\u2075 : PseudoMetricSpace P\u2083\ninst\u271d\u2074 : NormedAddTorsor V\u2083 P\u2083\ninst\u271d\u00b3 : SeminormedAddCommGroup V\u2084\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c V\u2084\ninst\u271d\u00b9 : PseudoMetricSpace P\u2084\ninst\u271d : NormedAddTorsor V\u2084 P\u2084\nf : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082\n\u22a2 Injective toAffineMap", "state_after": "case mk.mk\n\ud835\udd5c : Type u_1\nV : Type u_2\nV\u2081 : Type u_3\nV\u2081' : Type u_4\nV\u2082 : Type u_5\nV\u2083 : Type u_6\nV\u2084 : Type u_7\nP\u2081 : Type u_8\nP\u2081' : Type u_9\nP : Type u_10\nP\u2082 : Type u_11\nP\u2083 : Type u_12\nP\u2084 : Type u_13\ninst\u271d\u00b2\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b2\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2\u00b2 : NormedSpace \ud835\udd5c V\ninst\u271d\u00b2\u00b9 : PseudoMetricSpace P\ninst\u271d\u00b2\u2070 : NormedAddTorsor V P\ninst\u271d\u00b9\u2079 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9\u2078 : NormedSpace \ud835\udd5c V\u2081\ninst\u271d\u00b9\u2077 : PseudoMetricSpace P\u2081\ninst\u271d\u00b9\u2076 : NormedAddTorsor V\u2081 P\u2081\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup V\u2081'\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c V\u2081'\ninst\u271d\u00b9\u00b3 : MetricSpace P\u2081'\ninst\u271d\u00b9\u00b2 : NormedAddTorsor V\u2081' P\u2081'\ninst\u271d\u00b9\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c V\u2082\ninst\u271d\u2079 : PseudoMetricSpace P\u2082\ninst\u271d\u2078 : NormedAddTorsor V\u2082 P\u2082\ninst\u271d\u2077 : SeminormedAddCommGroup V\u2083\ninst\u271d\u2076 : NormedSpace \ud835\udd5c V\u2083\ninst\u271d\u2075 : PseudoMetricSpace P\u2083\ninst\u271d\u2074 : NormedAddTorsor V\u2083 P\u2083\ninst\u271d\u00b3 : SeminormedAddCommGroup V\u2084\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c V\u2084\ninst\u271d\u00b9 : PseudoMetricSpace P\u2084\ninst\u271d : NormedAddTorsor V\u2084 P\u2084\nf\u271d : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082\nf : P \u2192\u1d43[\ud835\udd5c] P\u2082\nnorm_map\u271d\u00b9 : \u2200 (x : V), \u2016f.linear x\u2016 = \u2016x\u2016\nnorm_map\u271d : \u2200 (x : V), \u2016{ toAffineMap := f, norm_map := norm_map\u271d\u00b9 }.linear x\u2016 = \u2016x\u2016\n\u22a2 { toAffineMap := f, norm_map := norm_map\u271d\u00b9 } =\n    { toAffineMap := { toAffineMap := f, norm_map := norm_map\u271d\u00b9 }.toAffineMap, norm_map := norm_map\u271d }"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk.mk\n\ud835\udd5c : Type u_1\nV : Type u_2\nV\u2081 : Type u_3\nV\u2081' : Type u_4\nV\u2082 : Type u_5\nV\u2083 : Type u_6\nV\u2084 : Type u_7\nP\u2081 : Type u_8\nP\u2081' : Type u_9\nP : Type u_10\nP\u2082 : Type u_11\nP\u2083 : Type u_12\nP\u2084 : Type u_13\ninst\u271d\u00b2\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b2\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2\u00b2 : NormedSpace \ud835\udd5c V\ninst\u271d\u00b2\u00b9 : PseudoMetricSpace P\ninst\u271d\u00b2\u2070 : NormedAddTorsor V P\ninst\u271d\u00b9\u2079 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9\u2078 : NormedSpace \ud835\udd5c V\u2081\ninst\u271d\u00b9\u2077 : PseudoMetricSpace P\u2081\ninst\u271d\u00b9\u2076 : NormedAddTorsor V\u2081 P\u2081\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup V\u2081'\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c V\u2081'\ninst\u271d\u00b9\u00b3 : MetricSpace P\u2081'\ninst\u271d\u00b9\u00b2 : NormedAddTorsor V\u2081' P\u2081'\ninst\u271d\u00b9\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c V\u2082\ninst\u271d\u2079 : PseudoMetricSpace P\u2082\ninst\u271d\u2078 : NormedAddTorsor V\u2082 P\u2082\ninst\u271d\u2077 : SeminormedAddCommGroup V\u2083\ninst\u271d\u2076 : NormedSpace \ud835\udd5c V\u2083\ninst\u271d\u2075 : PseudoMetricSpace P\u2083\ninst\u271d\u2074 : NormedAddTorsor V\u2083 P\u2083\ninst\u271d\u00b3 : SeminormedAddCommGroup V\u2084\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c V\u2084\ninst\u271d\u00b9 : PseudoMetricSpace P\u2084\ninst\u271d : NormedAddTorsor V\u2084 P\u2084\nf\u271d : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082\nf : P \u2192\u1d43[\ud835\udd5c] P\u2082\nnorm_map\u271d\u00b9 : \u2200 (x : V), \u2016f.linear x\u2016 = \u2016x\u2016\nnorm_map\u271d : \u2200 (x : V), \u2016{ toAffineMap := f, norm_map := norm_map\u271d\u00b9 }.linear x\u2016 = \u2016x\u2016\n\u22a2 { toAffineMap := f, norm_map := norm_map\u271d\u00b9 } =\n    { toAffineMap := { toAffineMap := f, norm_map := norm_map\u271d\u00b9 }.toAffineMap, norm_map := norm_map\u271d }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "prod_generateFrom_generateFrom_eq", "start": [668, 1], "end": [696, 83], "traced_tactics": [{"tactic": "simp_rw [\u2190 prod_iUnion, \u2190 sUnion_eq_biUnion, ht, prod_univ]", "annotated_tactic": ["simp_rw [\u2190 <a>prod_iUnion</a>, \u2190 <a>sUnion_eq_biUnion</a>, ht, <a>prod_univ</a>]", [{"full_name": "Set.prod_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1772, 9], "def_end_pos": [1772, 20]}, {"full_name": "Set.sUnion_eq_biUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1316, 9], "def_end_pos": [1316, 26]}, {"full_name": "Set.prod_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [101, 9], "def_end_pos": [101, 18]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : \u22c3\u2080 s = univ\nht : \u22c3\u2080 t = univ\nG : TopologicalSpace (X \u00d7 Y) := generateFrom {g | \u2203 u \u2208 s, \u2203 v \u2208 t, g = u \u00d7\u02e2 v}\nu : Set X\nhu : u \u2208 s\n\u22a2 \u22c3 v \u2208 t, u \u00d7\u02e2 v = Prod.fst \u207b\u00b9' u", "state_after": "no goals"}, {"tactic": "rw [\u2190 this]", "annotated_tactic": ["rw [\u2190 this]", []], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : \u22c3\u2080 s = univ\nht : \u22c3\u2080 t = univ\nG : TopologicalSpace (X \u00d7 Y) := generateFrom {g | \u2203 u \u2208 s, \u2203 v \u2208 t, g = u \u00d7\u02e2 v}\nu : Set X\nhu : u \u2208 s\nthis : \u22c3 v \u2208 t, u \u00d7\u02e2 v = Prod.fst \u207b\u00b9' u\n\u22a2 TopologicalSpace.IsOpen (Prod.fst \u207b\u00b9' u)", "state_after": "X\u271d : Type u\nY\u271d : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : \u22c3\u2080 s = univ\nht : \u22c3\u2080 t = univ\nG : TopologicalSpace (X \u00d7 Y) := generateFrom {g | \u2203 u \u2208 s, \u2203 v \u2208 t, g = u \u00d7\u02e2 v}\nu : Set X\nhu : u \u2208 s\nthis : \u22c3 v \u2208 t, u \u00d7\u02e2 v = Prod.fst \u207b\u00b9' u\n\u22a2 TopologicalSpace.IsOpen (\u22c3 v \u2208 t, u \u00d7\u02e2 v)"}, {"tactic": "exact\n  isOpen_iUnion fun v =>\n    isOpen_iUnion fun hv => GenerateOpen.basic _ \u27e8_, hu, _, hv, rfl\u27e9", "annotated_tactic": ["exact\n              <a>isOpen_iUnion</a> fun v =>\n                <a>isOpen_iUnion</a> fun hv => <a>GenerateOpen.basic</a> _ \u27e8_, hu, _, hv, <a>rfl</a>\u27e9", [{"full_name": "isOpen_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 22]}, {"full_name": "isOpen_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 22]}, {"full_name": "TopologicalSpace.GenerateOpen.basic", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [59, 5], "def_end_pos": [59, 10]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : \u22c3\u2080 s = univ\nht : \u22c3\u2080 t = univ\nG : TopologicalSpace (X \u00d7 Y) := generateFrom {g | \u2203 u \u2208 s, \u2203 v \u2208 t, g = u \u00d7\u02e2 v}\nu : Set X\nhu : u \u2208 s\nthis : \u22c3 v \u2208 t, u \u00d7\u02e2 v = Prod.fst \u207b\u00b9' u\n\u22a2 TopologicalSpace.IsOpen (\u22c3 v \u2208 t, u \u00d7\u02e2 v)", "state_after": "no goals"}, {"tactic": "simp_rw [\u2190 iUnion_prod_const, \u2190 sUnion_eq_biUnion, hs, univ_prod]", "annotated_tactic": ["simp_rw [\u2190 <a>iUnion_prod_const</a>, \u2190 <a>sUnion_eq_biUnion</a>, hs, <a>univ_prod</a>]", [{"full_name": "Set.iUnion_prod_const", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1793, 9], "def_end_pos": [1793, 26]}, {"full_name": "Set.sUnion_eq_biUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1316, 9], "def_end_pos": [1316, 26]}, {"full_name": "Set.univ_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [98, 9], "def_end_pos": [98, 18]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : \u22c3\u2080 s = univ\nht : \u22c3\u2080 t = univ\nG : TopologicalSpace (X \u00d7 Y) := generateFrom {g | \u2203 u \u2208 s, \u2203 v \u2208 t, g = u \u00d7\u02e2 v}\nv : Set Y\nhv : v \u2208 t\n\u22a2 \u22c3 u \u2208 s, u \u00d7\u02e2 v = Prod.snd \u207b\u00b9' v", "state_after": "no goals"}, {"tactic": "rw [\u2190 this]", "annotated_tactic": ["rw [\u2190 this]", []], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : \u22c3\u2080 s = univ\nht : \u22c3\u2080 t = univ\nG : TopologicalSpace (X \u00d7 Y) := generateFrom {g | \u2203 u \u2208 s, \u2203 v \u2208 t, g = u \u00d7\u02e2 v}\nv : Set Y\nhv : v \u2208 t\nthis : \u22c3 u \u2208 s, u \u00d7\u02e2 v = Prod.snd \u207b\u00b9' v\n\u22a2 TopologicalSpace.IsOpen (Prod.snd \u207b\u00b9' v)", "state_after": "X\u271d : Type u\nY\u271d : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : \u22c3\u2080 s = univ\nht : \u22c3\u2080 t = univ\nG : TopologicalSpace (X \u00d7 Y) := generateFrom {g | \u2203 u \u2208 s, \u2203 v \u2208 t, g = u \u00d7\u02e2 v}\nv : Set Y\nhv : v \u2208 t\nthis : \u22c3 u \u2208 s, u \u00d7\u02e2 v = Prod.snd \u207b\u00b9' v\n\u22a2 TopologicalSpace.IsOpen (\u22c3 u \u2208 s, u \u00d7\u02e2 v)"}, {"tactic": "exact\n  isOpen_iUnion fun u =>\n    isOpen_iUnion fun hu => GenerateOpen.basic _ \u27e8_, hu, _, hv, rfl\u27e9", "annotated_tactic": ["exact\n              <a>isOpen_iUnion</a> fun u =>\n                <a>isOpen_iUnion</a> fun hu => <a>GenerateOpen.basic</a> _ \u27e8_, hu, _, hv, <a>rfl</a>\u27e9", [{"full_name": "isOpen_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 22]}, {"full_name": "isOpen_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 22]}, {"full_name": "TopologicalSpace.GenerateOpen.basic", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [59, 5], "def_end_pos": [59, 10]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "X\u271d : Type u\nY\u271d : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\u271d\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nY : Type u_6\ns : Set (Set X)\nt : Set (Set Y)\nhs : \u22c3\u2080 s = univ\nht : \u22c3\u2080 t = univ\nG : TopologicalSpace (X \u00d7 Y) := generateFrom {g | \u2203 u \u2208 s, \u2203 v \u2208 t, g = u \u00d7\u02e2 v}\nv : Set Y\nhv : v \u2208 t\nthis : \u22c3 u \u2208 s, u \u00d7\u02e2 v = Prod.snd \u207b\u00b9' v\n\u22a2 TopologicalSpace.IsOpen (\u22c3 u \u2208 s, u \u00d7\u02e2 v)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/ModEq.lean", "full_name": "AddCommGroup.div_modEq_div", "start": [348, 1], "end": [349, 52], "traced_tactics": [{"tactic": "simp [ModEq, \u2190 sub_div, div_eq_iff hc, mul_assoc]", "annotated_tactic": ["simp [<a>ModEq</a>, \u2190 <a>sub_div</a>, <a>div_eq_iff</a> hc, <a>mul_assoc</a>]", [{"full_name": "AddCommGroup.ModEq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/ModEq.lean", "def_pos": [46, 5], "def_end_pos": [46, 10]}, {"full_name": "sub_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Field/Basic.lean", "def_pos": [170, 9], "def_end_pos": [170, 16]}, {"full_name": "div_eq_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [355, 22], "def_end_pos": [355, 32]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DivisionRing \u03b1\na b c p : \u03b1\nhc : c \u2260 0\n\u22a2 a / c \u2261 b / c [PMOD p] \u2194 a \u2261 b [PMOD p * c]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteBooleanAlgebra.lean", "full_name": "inf_sSup_eq", "start": [195, 1], "end": [196, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.DecEq_eq", "start": [716, 9], "end": [721, 72], "traced_tactics": [{"tactic": "funext l\u2081 l\u2082", "annotated_tactic": ["funext l\u2081 l\u2082", []], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\n\u22a2 List.beq = fun a b => decide (a = b)", "state_after": "case h.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\n\u22a2 List.beq l\u2081 l\u2082 = decide (l\u2081 = l\u2082)"}, {"tactic": "show (l\u2081 == l\u2082) = _", "annotated_tactic": ["show (l\u2081 == l\u2082) = _", []], "state_before": "case h.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\n\u22a2 List.beq l\u2081 l\u2082 = decide (l\u2081 = l\u2082)", "state_after": "case h.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\n\u22a2 (l\u2081 == l\u2082) = decide (l\u2081 = l\u2082)"}, {"tactic": "rw [Bool.eq_iff_eq_true_iff, @beq_iff_eq _ (_), decide_eq_true_iff]", "annotated_tactic": ["rw [<a>Bool.eq_iff_eq_true_iff</a>, @<a>beq_iff_eq</a> _ (_), <a>decide_eq_true_iff</a>]", [{"full_name": "Bool.eq_iff_eq_true_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Bool/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 27]}, {"full_name": "beq_iff_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1314, 17], "def_end_pos": [1314, 27]}, {"full_name": "decide_eq_true_iff", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [295, 9], "def_end_pos": [295, 27]}]], "state_before": "case h.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\u271d\na : \u03b1\u271d\n\u03b1 : Type u_3\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\n\u22a2 (l\u2081 == l\u2082) = decide (l\u2081 = l\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.span_le_restrictScalars", "start": [574, 1], "end": [576, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Minimal.lean", "full_name": "maximals_antichain", "start": [135, 1], "end": [136, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Fib/Basic.lean", "full_name": "Nat.fib_two_mul", "start": [177, 1], "end": [182, 9], "traced_tactics": [{"tactic": "cases n", "annotated_tactic": ["cases n", []], "state_before": "n : \u2115\n\u22a2 fib (2 * n) = fib n * (2 * fib (n + 1) - fib n)", "state_after": "case zero\n\n\u22a2 fib (2 * zero) = fib zero * (2 * fib (zero + 1) - fib zero)\n\ncase succ\nn\u271d : \u2115\n\u22a2 fib (2 * succ n\u271d) = fib (succ n\u271d) * (2 * fib (succ n\u271d + 1) - fib (succ n\u271d))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\n\n\u22a2 fib (2 * zero) = fib zero * (2 * fib (zero + 1) - fib zero)", "state_after": "no goals"}, {"tactic": "rw [Nat.succ_eq_add_one, two_mul, \u2190 add_assoc, fib_add, fib_add_two, two_mul]", "annotated_tactic": ["rw [<a>Nat.succ_eq_add_one</a>, <a>two_mul</a>, \u2190 <a>add_assoc</a>, <a>fib_add</a>, <a>fib_add_two</a>, <a>two_mul</a>]", [{"full_name": "Nat.succ_eq_add_one", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 24]}, {"full_name": "two_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [179, 9], "def_end_pos": [179, 16]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "Nat.fib_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Fib/Basic.lean", "def_pos": [168, 9], "def_end_pos": [168, 16]}, {"full_name": "Nat.fib_add_two", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Fib/Basic.lean", "def_pos": [90, 9], "def_end_pos": [90, 20]}, {"full_name": "two_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [179, 9], "def_end_pos": [179, 16]}]], "state_before": "case succ\nn\u271d : \u2115\n\u22a2 fib (2 * succ n\u271d) = fib (succ n\u271d) * (2 * fib (succ n\u271d + 1) - fib (succ n\u271d))", "state_after": "case succ\nn\u271d : \u2115\n\u22a2 fib (n\u271d + 1) * fib n\u271d + (fib n\u271d + fib (n\u271d + 1)) * fib (n\u271d + 1) =\n    fib (n\u271d + 1) * (fib n\u271d + fib (n\u271d + 1) + (fib n\u271d + fib (n\u271d + 1)) - fib (n\u271d + 1))"}, {"tactic": "simp only [\u2190 add_assoc, add_tsub_cancel_right]", "annotated_tactic": ["simp only [\u2190 <a>add_assoc</a>, <a>add_tsub_cancel_right</a>]", [{"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "add_tsub_cancel_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [357, 9], "def_end_pos": [357, 30]}]], "state_before": "case succ\nn\u271d : \u2115\n\u22a2 fib (n\u271d + 1) * fib n\u271d + (fib n\u271d + fib (n\u271d + 1)) * fib (n\u271d + 1) =\n    fib (n\u271d + 1) * (fib n\u271d + fib (n\u271d + 1) + (fib n\u271d + fib (n\u271d + 1)) - fib (n\u271d + 1))", "state_after": "case succ\nn\u271d : \u2115\n\u22a2 fib (n\u271d + 1) * fib n\u271d + (fib n\u271d + fib (n\u271d + 1)) * fib (n\u271d + 1) = fib (n\u271d + 1) * (fib n\u271d + fib (n\u271d + 1) + fib n\u271d)"}, {"tactic": "ring", "annotated_tactic": ["ring", []], "state_before": "case succ\nn\u271d : \u2115\n\u22a2 fib (n\u271d + 1) * fib n\u271d + (fib n\u271d + fib (n\u271d + 1)) * fib (n\u271d + 1) = fib (n\u271d + 1) * (fib n\u271d + fib (n\u271d + 1) + fib n\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Semicontinuous.lean", "full_name": "lowerSemicontinuousWithinAt_iff_le_liminf", "start": [320, 1], "end": [328, 69], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 LowerSemicontinuousWithinAt f s x \u2194 f x \u2264 liminf f (\ud835\udcdd[s] x)", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 LowerSemicontinuousWithinAt f s x \u2192 f x \u2264 liminf f (\ud835\udcdd[s] x)\n\ncase mpr\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 f x \u2264 liminf f (\ud835\udcdd[s] x) \u2192 LowerSemicontinuousWithinAt f s x"}, {"tactic": "exact fun hf y ylt => eventually_lt_of_lt_liminf (ylt.trans_le hf)", "annotated_tactic": ["exact fun hf y ylt => <a>eventually_lt_of_lt_liminf</a> (ylt.trans_le hf)", [{"full_name": "Filter.eventually_lt_of_lt_liminf", "def_path": ".lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean", "def_pos": [1267, 9], "def_end_pos": [1267, 35]}]], "state_before": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 f x \u2264 liminf f (\ud835\udcdd[s] x) \u2192 LowerSemicontinuousWithinAt f s x", "state_after": "no goals"}, {"tactic": "intro hf", "annotated_tactic": ["intro hf", []], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 LowerSemicontinuousWithinAt f s x \u2192 f x \u2264 liminf f (\ud835\udcdd[s] x)", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : LowerSemicontinuousWithinAt f s x\n\u22a2 f x \u2264 liminf f (\ud835\udcdd[s] x)"}, {"tactic": "unfold LowerSemicontinuousWithinAt at hf", "annotated_tactic": ["unfold <a>LowerSemicontinuousWithinAt</a> at hf", [{"full_name": "LowerSemicontinuousWithinAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Semicontinuous.lean", "def_pos": [84, 5], "def_end_pos": [84, 32]}]], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : LowerSemicontinuousWithinAt f s x\n\u22a2 f x \u2264 liminf f (\ud835\udcdd[s] x)", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : \u2200 y < f x, \u2200\u1da0 (x' : \u03b1) in \ud835\udcdd[s] x, y < f x'\n\u22a2 f x \u2264 liminf f (\ud835\udcdd[s] x)"}, {"tactic": "contrapose! hf", "annotated_tactic": ["contrapose! hf", []], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : \u2200 y < f x, \u2200\u1da0 (x' : \u03b1) in \ud835\udcdd[s] x, y < f x'\n\u22a2 f x \u2264 liminf f (\ud835\udcdd[s] x)", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : liminf f (\ud835\udcdd[s] x) < f x\n\u22a2 \u2203 y < f x, \u00ac\u2200\u1da0 (x' : \u03b1) in \ud835\udcdd[s] x, y < f x'"}, {"tactic": "obtain \u27e8y, lty, ylt\u27e9 := exists_between hf", "annotated_tactic": ["obtain \u27e8y, lty, ylt\u27e9 := <a>exists_between</a> hf", [{"full_name": "exists_between", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [1355, 9], "def_end_pos": [1355, 23]}]], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : liminf f (\ud835\udcdd[s] x) < f x\n\u22a2 \u2203 y < f x, \u00ac\u2200\u1da0 (x' : \u03b1) in \ud835\udcdd[s] x, y < f x'", "state_after": "case mp.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny\u271d z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : liminf f (\ud835\udcdd[s] x) < f x\ny : \u03b3\nlty : liminf f (\ud835\udcdd[s] x) < y\nylt : y < f x\n\u22a2 \u2203 y < f x, \u00ac\u2200\u1da0 (x' : \u03b1) in \ud835\udcdd[s] x, y < f x'"}, {"tactic": "use y", "annotated_tactic": ["use y", []], "state_before": "case mp.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny\u271d z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : liminf f (\ud835\udcdd[s] x) < f x\ny : \u03b3\nlty : liminf f (\ud835\udcdd[s] x) < y\nylt : y < f x\n\u22a2 \u2203 y < f x, \u00ac\u2200\u1da0 (x' : \u03b1) in \ud835\udcdd[s] x, y < f x'", "state_after": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny\u271d z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : liminf f (\ud835\udcdd[s] x) < f x\ny : \u03b3\nlty : liminf f (\ud835\udcdd[s] x) < y\nylt : y < f x\n\u22a2 y < f x \u2227 \u00ac\u2200\u1da0 (x' : \u03b1) in \ud835\udcdd[s] x, y < f x'"}, {"tactic": "exact \u27e8ylt, fun h => lty.not_le\n  (le_liminf_of_le (by isBoundedDefault) (h.mono fun _ hx => le_of_lt hx))\u27e9", "annotated_tactic": ["exact \u27e8ylt, fun h => lty.not_le\n      (<a>le_liminf_of_le</a> (by isBoundedDefault) (h.mono fun _ hx => <a>le_of_lt</a> hx))\u27e9", [{"full_name": "Filter.le_liminf_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean", "def_pos": [538, 9], "def_end_pos": [538, 24]}, {"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}]], "state_before": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny\u271d z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : liminf f (\ud835\udcdd[s] x) < f x\ny : \u03b3\nlty : liminf f (\ud835\udcdd[s] x) < y\nylt : y < f x\n\u22a2 y < f x \u2227 \u00ac\u2200\u1da0 (x' : \u03b1) in \ud835\udcdd[s] x, y < f x'", "state_after": "no goals"}, {"tactic": "isBoundedDefault", "annotated_tactic": ["isBoundedDefault", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\nx : \u03b1\ns t : Set \u03b1\ny\u271d z : \u03b2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CompleteLinearOrder \u03b3\ninst\u271d : DenselyOrdered \u03b3\nf : \u03b1 \u2192 \u03b3\nhf : liminf f (\ud835\udcdd[s] x) < f x\ny : \u03b3\nlty : liminf f (\ud835\udcdd[s] x) < y\nylt : y < f x\nh : \u2200\u1da0 (x' : \u03b1) in \ud835\udcdd[s] x, y < f x'\n\u22a2 IsCoboundedUnder (fun x x_1 => x \u2265 x_1) (\ud835\udcdd[s] x) f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.insertNth_removeNth_of_ge", "start": [1579, 1], "end": [1587, 97], "traced_tactics": [{"tactic": "simp [removeNth, insertNth]", "annotated_tactic": ["simp [<a>removeNth</a>, <a>insertNth</a>]", [{"full_name": "List.removeNth", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [339, 13], "def_end_pos": [339, 22]}, {"full_name": "List.insertNth", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [543, 5], "def_end_pos": [543, 14]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na head\u271d : \u03b1\nas : List \u03b1\nx\u271d\u00b9 : 0 < length (head\u271d :: as)\nx\u271d : 0 \u2264 0\n\u22a2 insertNth 0 a (removeNth (head\u271d :: as) 0) = removeNth (insertNth (0 + 1) a (head\u271d :: as)) 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.filter_subset", "start": [2782, 1], "end": [2783, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iSup_subtype", "start": [1144, 1], "end": [1146, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Complex.sin_pi_div_two_sub", "start": [1261, 1], "end": [1261, 98], "traced_tactics": [{"tactic": "simp [sub_eq_add_neg, sin_add]", "annotated_tactic": ["simp [<a>sub_eq_add_neg</a>, <a>sin_add</a>]", [{"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}, {"full_name": "Complex.sin_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [528, 9], "def_end_pos": [528, 16]}]], "state_before": "x : \u2102\n\u22a2 sin (\u2191\u03c0 / 2 - x) = cos x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.lmapDomain_total", "start": [742, 1], "end": [745, 63], "traced_tactics": [{"tactic": "ext l", "annotated_tactic": ["ext l", []], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nf : \u03b1 \u2192 \u03b1'\ng : M \u2192\u2097[R] M'\nh : \u2200 (i : \u03b1), g (v i) = v' (f i)\n\u22a2 Finsupp.total \u03b1' M' R v' \u2218\u2097 lmapDomain R R f = g \u2218\u2097 Finsupp.total \u03b1 M R v", "state_after": "case h.h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nf : \u03b1 \u2192 \u03b1'\ng : M \u2192\u2097[R] M'\nh : \u2200 (i : \u03b1), g (v i) = v' (f i)\nl : \u03b1\n\u22a2 ((Finsupp.total \u03b1' M' R v' \u2218\u2097 lmapDomain R R f) \u2218\u2097 lsingle l) 1 = ((g \u2218\u2097 Finsupp.total \u03b1 M R v) \u2218\u2097 lsingle l) 1"}, {"tactic": "simp [total_apply, Finsupp.sum_mapDomain_index, add_smul, h]", "annotated_tactic": ["simp [<a>total_apply</a>, <a>Finsupp.sum_mapDomain_index</a>, <a>add_smul</a>, h]", [{"full_name": "Finsupp.total_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [666, 9], "def_end_pos": [666, 20]}, {"full_name": "Finsupp.sum_mapDomain_index", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [584, 3], "def_end_pos": [584, 14]}, {"full_name": "add_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [92, 9], "def_end_pos": [92, 17]}]], "state_before": "case h.h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nf : \u03b1 \u2192 \u03b1'\ng : M \u2192\u2097[R] M'\nh : \u2200 (i : \u03b1), g (v i) = v' (f i)\nl : \u03b1\n\u22a2 ((Finsupp.total \u03b1' M' R v' \u2218\u2097 lmapDomain R R f) \u2218\u2097 lsingle l) 1 = ((g \u2218\u2097 Finsupp.total \u03b1 M R v) \u2218\u2097 lsingle l) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "orderOf_eq_card_powers", "start": [904, 1], "end": [907, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.card_le_three", "start": [126, 1], "end": [127, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.snd_surjective", "start": [146, 1], "end": [147, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.coe_disjiUnion", "start": [3659, 1], "end": [3660, 90], "traced_tactics": [{"tactic": "simp [Set.ext_iff, mem_disjiUnion, Set.mem_iUnion, iff_self_iff, mem_coe, imp_true_iff]", "annotated_tactic": ["simp [<a>Set.ext_iff</a>, <a>mem_disjiUnion</a>, <a>Set.mem_iUnion</a>, <a>iff_self_iff</a>, <a>mem_coe</a>, <a>imp_true_iff</a>]", [{"full_name": "Set.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [219, 9], "def_end_pos": [219, 16]}, {"full_name": "Finset.mem_disjiUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3654, 9], "def_end_pos": [3654, 23]}, {"full_name": "Set.mem_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [272, 9], "def_end_pos": [272, 19]}, {"full_name": "iff_self_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [198, 9], "def_end_pos": [198, 21]}, {"full_name": "Finset.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}, {"full_name": "imp_true_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1400, 9], "def_end_pos": [1400, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b1\nt t\u2081 t\u2082 : \u03b1 \u2192 Finset \u03b2\nh : Set.PairwiseDisjoint (\u2191s) t\n\u22a2 \u2191(disjiUnion s t h) = \u22c3 x \u2208 \u2191s, \u2191(t x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Quot.lean", "full_name": "Quotient.liftOn'_mk", "start": [815, 11], "end": [816, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/OrderHom.lean", "full_name": "Fin.predAbove_rev_right", "start": [421, 1], "end": [423, 35], "traced_tactics": [{"tactic": "rw [predAbove_rev_left, rev_rev]", "annotated_tactic": ["rw [<a>predAbove_rev_left</a>, <a>rev_rev</a>]", [{"full_name": "Fin.predAbove_rev_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/OrderHom.lean", "def_pos": [414, 9], "def_end_pos": [414, 27]}, {"full_name": "Fin.rev_rev", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [135, 17], "def_end_pos": [135, 24]}]], "state_before": "n : \u2115\np : Fin n\ni : Fin (n + 1)\n\u22a2 predAbove p (rev i) = rev (predAbove (rev p) i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.map_surjective_of_surjective", "start": [1672, 1], "end": [1673, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.measure_biUnion_toMeasurable", "start": [382, 1], "end": [385, 61], "traced_tactics": [{"tactic": "haveI := hc.toEncodable", "annotated_tactic": ["haveI := hc.toEncodable", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nm : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns\u271d s\u2081 s\u2082 t : Set \u03b1\nI : Set \u03b2\nhc : Set.Countable I\ns : \u03b2 \u2192 Set \u03b1\n\u22a2 \u2191\u2191\u03bc (\u22c3 b \u2208 I, toMeasurable \u03bc (s b)) = \u2191\u2191\u03bc (\u22c3 b \u2208 I, s b)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nm : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns\u271d s\u2081 s\u2082 t : Set \u03b1\nI : Set \u03b2\nhc : Set.Countable I\ns : \u03b2 \u2192 Set \u03b1\nthis : Encodable \u2191I\n\u22a2 \u2191\u2191\u03bc (\u22c3 b \u2208 I, toMeasurable \u03bc (s b)) = \u2191\u2191\u03bc (\u22c3 b \u2208 I, s b)"}, {"tactic": "simp only [biUnion_eq_iUnion, measure_iUnion_toMeasurable]", "annotated_tactic": ["simp only [<a>biUnion_eq_iUnion</a>, <a>measure_iUnion_toMeasurable</a>]", [{"full_name": "Set.biUnion_eq_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [874, 9], "def_end_pos": [874, 26]}, {"full_name": "MeasureTheory.measure_iUnion_toMeasurable", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "def_pos": [375, 9], "def_end_pos": [375, 36]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nm : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns\u271d s\u2081 s\u2082 t : Set \u03b1\nI : Set \u03b2\nhc : Set.Countable I\ns : \u03b2 \u2192 Set \u03b1\nthis : Encodable \u2191I\n\u22a2 \u2191\u2191\u03bc (\u22c3 b \u2208 I, toMeasurable \u03bc (s b)) = \u2191\u2191\u03bc (\u22c3 b \u2208 I, s b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean", "full_name": "ContinuousLinearMap.map_zero\u2082", "start": [295, 1], "end": [296, 30], "traced_tactics": [{"tactic": "rw [f.map_zero, zero_apply]", "annotated_tactic": ["rw [f.map_zero, <a>zero_apply</a>]", [{"full_name": "ContinuousLinearMap.zero_apply", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [635, 9], "def_end_pos": [635, 19]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9\u2075 : NormedAddCommGroup E\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9\u00b9 : NormedAddCommGroup G\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c G\nR : Type u_5\n\ud835\udd5c\u2082 : Type u_6\n\ud835\udd5c' : Type u_7\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\u2082\nM : Type u_8\ninst\u271d\u2077 : TopologicalSpace M\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\nG' : Type u_9\ninst\u271d\u2076 : NormedAddCommGroup G'\ninst\u271d\u2075 : NormedSpace \ud835\udd5c\u2082 G'\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' G'\ninst\u271d\u00b3 : SMulCommClass \ud835\udd5c\u2082 \ud835\udd5c' G'\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03c1\u2081\u2082 : R \u2192+* \ud835\udd5c'\nf : M \u2192SL[\u03c1\u2081\u2082] F \u2192SL[\u03c3\u2081\u2082] G'\ny : F\n\u22a2 (f 0) y = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Interval.lean", "full_name": "Fin.card_Icc", "start": [105, 1], "end": [106, 56], "traced_tactics": [{"tactic": "rw [\u2190 Nat.card_Icc, \u2190 map_valEmbedding_Icc, card_map]", "annotated_tactic": ["rw [\u2190 <a>Nat.card_Icc</a>, \u2190 <a>map_valEmbedding_Icc</a>, <a>card_map</a>]", [{"full_name": "Nat.card_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Interval.lean", "def_pos": [98, 9], "def_end_pos": [98, 17]}, {"full_name": "Fin.map_valEmbedding_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Interval.lean", "def_pos": [80, 9], "def_end_pos": [80, 29]}, {"full_name": "Finset.card_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [295, 9], "def_end_pos": [295, 17]}]], "state_before": "n : \u2115\na b : Fin n\n\u22a2 (Icc a b).card = \u2191b + 1 - \u2191a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.cast_injective_of_le", "start": [607, 1], "end": [616, 12], "traced_tactics": [{"tactic": "cases m with\n| zero => cases nzm; simp_all\n| succ m =>\n  rintro \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 f\n  simp only [cast, val, nat_cast_eq_nat_cast_iff',\n    Nat.mod_eq_of_lt (hx.trans_le h), Nat.mod_eq_of_lt (hy.trans_le h)] at f\n  apply Fin.ext\n  exact f", "annotated_tactic": ["cases m with\n  | <a>zero</a> => cases nzm; simp_all\n  | <a>succ</a> m =>\n    rintro \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 f\n    simp only [<a>cast</a>, <a>val</a>, <a>nat_cast_eq_nat_cast_iff'</a>,\n      <a>Nat.mod_eq_of_lt</a> (hx.trans_le h), <a>Nat.mod_eq_of_lt</a> (hy.trans_le h)] at f\n    apply <a>Fin.ext</a>\n    exact f", [{"full_name": "Nat.zero", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1068, 5], "def_end_pos": [1068, 9]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "ZMod.cast", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [157, 5], "def_end_pos": [157, 9]}, {"full_name": "ZMod.val", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "ZMod.nat_cast_eq_nat_cast_iff'", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [507, 9], "def_end_pos": [507, 34]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}, {"full_name": "Fin.ext", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [37, 16], "def_end_pos": [37, 19]}]], "state_before": "m n : \u2115\nnzm : NeZero m\nh : m \u2264 n\n\u22a2 Injective cast", "state_after": "no goals"}, {"tactic": "cases nzm", "annotated_tactic": ["cases nzm", []], "state_before": "case zero\nn : \u2115\nnzm : NeZero Nat.zero\nh : Nat.zero \u2264 n\n\u22a2 Injective cast", "state_after": "case zero.mk\nn : \u2115\nh : Nat.zero \u2264 n\nout\u271d : Nat.zero \u2260 0\n\u22a2 Injective cast"}, {"tactic": "simp_all", "annotated_tactic": ["simp_all", []], "state_before": "case zero.mk\nn : \u2115\nh : Nat.zero \u2264 n\nout\u271d : Nat.zero \u2260 0\n\u22a2 Injective cast", "state_after": "no goals"}, {"tactic": "rintro \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 f", "annotated_tactic": ["rintro \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 f", []], "state_before": "case succ\nn m : \u2115\nnzm : NeZero (Nat.succ m)\nh : Nat.succ m \u2264 n\n\u22a2 Injective cast", "state_after": "case succ.mk.mk\nn m : \u2115\nnzm : NeZero (Nat.succ m)\nh : Nat.succ m \u2264 n\nx : \u2115\nhx : x < m + 1\ny : \u2115\nhy : y < m + 1\nf : cast { val := x, isLt := hx } = cast { val := y, isLt := hy }\n\u22a2 { val := x, isLt := hx } = { val := y, isLt := hy }"}, {"tactic": "simp only [cast, val, nat_cast_eq_nat_cast_iff',\n  Nat.mod_eq_of_lt (hx.trans_le h), Nat.mod_eq_of_lt (hy.trans_le h)] at f", "annotated_tactic": ["simp only [<a>cast</a>, <a>val</a>, <a>nat_cast_eq_nat_cast_iff'</a>,\n      <a>Nat.mod_eq_of_lt</a> (hx.trans_le h), <a>Nat.mod_eq_of_lt</a> (hy.trans_le h)] at f", [{"full_name": "ZMod.cast", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [157, 5], "def_end_pos": [157, 9]}, {"full_name": "ZMod.val", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "ZMod.nat_cast_eq_nat_cast_iff'", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [507, 9], "def_end_pos": [507, 34]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}]], "state_before": "case succ.mk.mk\nn m : \u2115\nnzm : NeZero (Nat.succ m)\nh : Nat.succ m \u2264 n\nx : \u2115\nhx : x < m + 1\ny : \u2115\nhy : y < m + 1\nf : cast { val := x, isLt := hx } = cast { val := y, isLt := hy }\n\u22a2 { val := x, isLt := hx } = { val := y, isLt := hy }", "state_after": "case succ.mk.mk\nn m : \u2115\nnzm : NeZero (Nat.succ m)\nh : Nat.succ m \u2264 n\nx : \u2115\nhx : x < m + 1\ny : \u2115\nhy : y < m + 1\nf : x = y\n\u22a2 { val := x, isLt := hx } = { val := y, isLt := hy }"}, {"tactic": "apply Fin.ext", "annotated_tactic": ["apply <a>Fin.ext</a>", [{"full_name": "Fin.ext", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [37, 16], "def_end_pos": [37, 19]}]], "state_before": "case succ.mk.mk\nn m : \u2115\nnzm : NeZero (Nat.succ m)\nh : Nat.succ m \u2264 n\nx : \u2115\nhx : x < m + 1\ny : \u2115\nhy : y < m + 1\nf : x = y\n\u22a2 { val := x, isLt := hx } = { val := y, isLt := hy }", "state_after": "case succ.mk.mk.h\nn m : \u2115\nnzm : NeZero (Nat.succ m)\nh : Nat.succ m \u2264 n\nx : \u2115\nhx : x < m + 1\ny : \u2115\nhy : y < m + 1\nf : x = y\n\u22a2 \u2191{ val := x, isLt := hx } = \u2191{ val := y, isLt := hy }"}, {"tactic": "exact f", "annotated_tactic": ["exact f", []], "state_before": "case succ.mk.mk.h\nn m : \u2115\nnzm : NeZero (Nat.succ m)\nh : Nat.succ m \u2264 n\nx : \u2115\nhx : x < m + 1\ny : \u2115\nhy : y < m + 1\nf : x = y\n\u22a2 \u2191{ val := x, isLt := hx } = \u2191{ val := y, isLt := hy }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Option/Basic.lean", "full_name": "Option.mem_map", "start": [46, 1], "end": [46, 95], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2\ny : \u03b2\no : Option \u03b1\n\u22a2 y \u2208 Option.map f o \u2194 \u2203 x, x \u2208 o \u2227 f x = y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WellFounded.lean", "full_name": "WellFounded.eq_strictMono_iff_eq_range_aux", "start": [149, 9], "end": [160, 26], "traced_tactics": [{"tactic": "obtain \u27e8c, hc\u27e9 : g b \u2208 Set.range f := by\n  rw [hfg]\n  exact Set.mem_range_self b", "annotated_tactic": ["obtain \u27e8c, hc\u27e9 : g b \u2208 <a>Set.range</a> f := by\n    rw [hfg]\n    exact <a>Set.mem_range_self</a> b", [{"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\n\u22a2 f b \u2264 g b", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : f c = g b\n\u22a2 f b \u2264 g b"}, {"tactic": "cases' lt_or_le c b with hcb hbc", "annotated_tactic": ["cases' <a>lt_or_le</a> c b with hcb hbc", [{"full_name": "lt_or_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [330, 9], "def_end_pos": [330, 17]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : f c = g b\n\u22a2 f b \u2264 g b", "state_after": "case intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : f c = g b\nhcb : c < b\n\u22a2 f b \u2264 g b\n\ncase intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : f c = g b\nhbc : b \u2264 c\n\u22a2 f b \u2264 g b"}, {"tactic": "rw [hfg]", "annotated_tactic": ["rw [hfg]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\n\u22a2 g b \u2208 range f", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\n\u22a2 g b \u2208 range g"}, {"tactic": "exact Set.mem_range_self b", "annotated_tactic": ["exact <a>Set.mem_range_self</a> b", [{"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\n\u22a2 g b \u2208 range g", "state_after": "no goals"}, {"tactic": "rw [H c hcb] at hc", "annotated_tactic": ["rw [H c hcb] at hc", []], "state_before": "case intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : f c = g b\nhcb : c < b\n\u22a2 f b \u2264 g b", "state_after": "case intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : g c = g b\nhcb : c < b\n\u22a2 f b \u2264 g b"}, {"tactic": "rw [hg.injective hc] at hcb", "annotated_tactic": ["rw [hg.injective hc] at hcb", []], "state_before": "case intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : g c = g b\nhcb : c < b\n\u22a2 f b \u2264 g b", "state_after": "case intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : g c = g b\nhcb : b < b\n\u22a2 f b \u2264 g b"}, {"tactic": "exact hcb.false.elim", "annotated_tactic": ["exact hcb.false.elim", []], "state_before": "case intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : g c = g b\nhcb : b < b\n\u22a2 f b \u2264 g b", "state_after": "no goals"}, {"tactic": "rw [\u2190 hc]", "annotated_tactic": ["rw [\u2190 hc]", []], "state_before": "case intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : f c = g b\nhbc : b \u2264 c\n\u22a2 f b \u2264 g b", "state_after": "case intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : f c = g b\nhbc : b \u2264 c\n\u22a2 f b \u2264 f c"}, {"tactic": "exact hf.monotone hbc", "annotated_tactic": ["exact hf.monotone hbc", []], "state_before": "case intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf g : \u03b2 \u2192 \u03b3\nhf : StrictMono f\nhg : StrictMono g\nhfg : range f = range g\nb : \u03b2\nH : \u2200 a < b, f a = g a\nc : \u03b2\nhc : f c = g b\nhbc : b \u2264 c\n\u22a2 f b \u2264 f c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsCoprime.of_mul_add_left_right", "start": [229, 1], "end": [231, 32], "traced_tactics": [{"tactic": "rw [add_comm] at h", "annotated_tactic": ["rw [<a>add_comm</a>] at h", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (x * z + y)\n\u22a2 IsCoprime x y", "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (y + x * z)\n\u22a2 IsCoprime x y"}, {"tactic": "exact h.of_add_mul_left_right", "annotated_tactic": ["exact h.of_add_mul_left_right", []], "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (y + x * z)\n\u22a2 IsCoprime x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/Bilinear.lean", "full_name": "ContinuousLinearMap.flip_smul", "start": [200, 1], "end": [201, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "Cycle.Subsingleton.nodup", "start": [669, 1], "end": [674, 16], "traced_tactics": [{"tactic": "induction' s using Quot.inductionOn with l", "annotated_tactic": ["induction' s using <a>Quot.inductionOn</a> with l", [{"full_name": "Quot.inductionOn", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1483, 19], "def_end_pos": [1483, 30]}]], "state_before": "\u03b1 : Type u_1\ns : Cycle \u03b1\nh : Subsingleton s\n\u22a2 Nodup s", "state_after": "case h\n\u03b1 : Type u_1\nl : List \u03b1\nh : Subsingleton (Quot.mk Setoid.r l)\n\u22a2 Nodup (Quot.mk Setoid.r l)"}, {"tactic": "cases' l with hd tl", "annotated_tactic": ["cases' l with hd tl", []], "state_before": "case h\n\u03b1 : Type u_1\nl : List \u03b1\nh : Subsingleton (Quot.mk Setoid.r l)\n\u22a2 Nodup (Quot.mk Setoid.r l)", "state_after": "case h.nil\n\u03b1 : Type u_1\nh : Subsingleton (Quot.mk Setoid.r [])\n\u22a2 Nodup (Quot.mk Setoid.r [])\n\ncase h.cons\n\u03b1 : Type u_1\nhd : \u03b1\ntl : List \u03b1\nh : Subsingleton (Quot.mk Setoid.r (hd :: tl))\n\u22a2 Nodup (Quot.mk Setoid.r (hd :: tl))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.nil\n\u03b1 : Type u_1\nh : Subsingleton (Quot.mk Setoid.r [])\n\u22a2 Nodup (Quot.mk Setoid.r [])", "state_after": "no goals"}, {"tactic": "have : tl = [] := by simpa [Subsingleton, length_eq_zero, Nat.succ_le_succ_iff] using h", "annotated_tactic": ["have : tl = [] := by simpa [<a>Subsingleton</a>, <a>length_eq_zero</a>, <a>Nat.succ_le_succ_iff</a>] using h", [{"full_name": "Cycle.Subsingleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [590, 5], "def_end_pos": [590, 17]}, {"full_name": "List.length_eq_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [56, 9], "def_end_pos": [56, 23]}, {"full_name": "Nat.succ_le_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [104, 9], "def_end_pos": [104, 25]}]], "state_before": "case h.cons\n\u03b1 : Type u_1\nhd : \u03b1\ntl : List \u03b1\nh : Subsingleton (Quot.mk Setoid.r (hd :: tl))\n\u22a2 Nodup (Quot.mk Setoid.r (hd :: tl))", "state_after": "case h.cons\n\u03b1 : Type u_1\nhd : \u03b1\ntl : List \u03b1\nh : Subsingleton (Quot.mk Setoid.r (hd :: tl))\nthis : tl = []\n\u22a2 Nodup (Quot.mk Setoid.r (hd :: tl))"}, {"tactic": "simp [this]", "annotated_tactic": ["simp [this]", []], "state_before": "case h.cons\n\u03b1 : Type u_1\nhd : \u03b1\ntl : List \u03b1\nh : Subsingleton (Quot.mk Setoid.r (hd :: tl))\nthis : tl = []\n\u22a2 Nodup (Quot.mk Setoid.r (hd :: tl))", "state_after": "no goals"}, {"tactic": "simpa [Subsingleton, length_eq_zero, Nat.succ_le_succ_iff] using h", "annotated_tactic": ["simpa [<a>Subsingleton</a>, <a>length_eq_zero</a>, <a>Nat.succ_le_succ_iff</a>] using h", [{"full_name": "Cycle.Subsingleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [590, 5], "def_end_pos": [590, 17]}, {"full_name": "List.length_eq_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [56, 9], "def_end_pos": [56, 23]}, {"full_name": "Nat.succ_le_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [104, 9], "def_end_pos": [104, 25]}]], "state_before": "\u03b1 : Type u_1\nhd : \u03b1\ntl : List \u03b1\nh : Subsingleton (Quot.mk Setoid.r (hd :: tl))\n\u22a2 tl = []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.sup_def", "start": [41, 1], "end": [42, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.OuterMeasure.ext_nonempty", "start": [239, 1], "end": [241, 88], "traced_tactics": [{"tactic": "rw [he, empty', empty']", "annotated_tactic": ["rw [he, <a>empty'</a>, <a>empty'</a>]", [{"full_name": "MeasureTheory.OuterMeasure.empty'", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [91, 9], "def_end_pos": [91, 15]}, {"full_name": "MeasureTheory.OuterMeasure.empty'", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [91, 9], "def_end_pos": [91, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\nR' : Type u_4\nms : Set (OuterMeasure \u03b1)\nm \u03bc\u2081 \u03bc\u2082 : OuterMeasure \u03b1\nh : \u2200 (s : Set \u03b1), Set.Nonempty s \u2192 \u2191\u03bc\u2081 s = \u2191\u03bc\u2082 s\ns : Set \u03b1\nhe : s = \u2205\n\u22a2 \u2191\u03bc\u2081 s = \u2191\u03bc\u2082 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean", "full_name": "PowerSeries.X_pow_eq", "start": [292, 1], "end": [293, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.lt_succ_iff", "start": [338, 1], "end": [339, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Semiconj.lean", "full_name": "SemiconjBy.neg_left", "start": [57, 1], "end": [58, 49], "traced_tactics": [{"tactic": "simp only [SemiconjBy, h.eq, neg_mul, mul_neg]", "annotated_tactic": ["simp only [<a>SemiconjBy</a>, h.eq, <a>neg_mul</a>, <a>mul_neg</a>]", [{"full_name": "SemiconjBy", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Semiconj/Defs.lean", "def_pos": [37, 5], "def_end_pos": [37, 15]}, {"full_name": "neg_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [306, 9], "def_end_pos": [306, 16]}, {"full_name": "mul_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [311, 9], "def_end_pos": [311, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nR : Type x\ninst\u271d\u00b9 : Mul R\ninst\u271d : HasDistribNeg R\na x y : R\nh : SemiconjBy a x y\n\u22a2 SemiconjBy (-a) x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Nat.Odd.sub_even", "start": [206, 1], "end": [207, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/Order.lean", "full_name": "Int.le_of_lt_add_one", "start": [341, 1], "end": [341, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Closure.lean", "full_name": "LowerAdjoint.idempotent", "start": [358, 1], "end": [359, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/Alter.lean", "full_name": "Std.RBNode.WF.alter", "start": [394, 1], "end": [398, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Cardinal.add_one_of_aleph0_le", "start": [2412, 1], "end": [2414, 33], "traced_tactics": [{"tactic": "rw [add_comm, \u2190 card_ord c, \u2190 card_one, \u2190 card_add, one_add_of_omega_le]", "annotated_tactic": ["rw [<a>add_comm</a>, \u2190 <a>card_ord</a> c, \u2190 <a>card_one</a>, \u2190 <a>card_add</a>, <a>one_add_of_omega_le</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "Cardinal.card_ord", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1362, 9], "def_end_pos": [1362, 17]}, {"full_name": "Ordinal.card_one", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [625, 9], "def_end_pos": [625, 17]}, {"full_name": "Ordinal.card_add", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [896, 9], "def_end_pos": [896, 17]}, {"full_name": "Ordinal.one_add_of_omega_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [630, 9], "def_end_pos": [630, 28]}]], "state_before": "c : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 c\n\u22a2 c + 1 = c", "state_after": "c : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 c\n\u22a2 \u03c9 \u2264 ord c"}, {"tactic": "rwa [\u2190 ord_aleph0, ord_le_ord]", "annotated_tactic": ["rwa [\u2190 <a>ord_aleph0</a>, <a>ord_le_ord</a>]", [{"full_name": "Cardinal.ord_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [2403, 9], "def_end_pos": [2403, 19]}, {"full_name": "Cardinal.ord_le_ord", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1406, 9], "def_end_pos": [1406, 19]}]], "state_before": "c : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 c\n\u22a2 \u03c9 \u2264 ord c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Nilpotent.lean", "full_name": "Polynomial.isUnit_iff'", "start": [165, 1], "end": [170, 22], "traced_tactics": [{"tactic": "suffices P = C (eval 0 P) + X * (P /\u2098 X) by\n  conv_lhs => rw [this]; simp", "annotated_tactic": ["suffices P = <a>C</a> (<a>eval</a> 0 P) + <a>X</a> * (P /\u2098 <a>X</a>) by\n    conv_lhs => rw [this]; simp", [{"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}, {"full_name": "Polynomial.eval", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [315, 5], "def_end_pos": [315, 9]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}]], "state_before": "R : Type u_1\nr : R\ninst\u271d : CommRing R\nP : R[X]\n\u22a2 IsUnit P \u2194 IsUnit (eval 0 P) \u2227 IsNilpotent (P /\u2098 X)", "state_after": "R : Type u_1\nr : R\ninst\u271d : CommRing R\nP : R[X]\n\u22a2 P = C (eval 0 P) + X * (P /\u2098 X)"}, {"tactic": "conv_lhs => rw [\u2190 modByMonic_add_div P monic_X]", "annotated_tactic": ["conv_lhs => rw [\u2190 <a>modByMonic_add_div</a> P <a>monic_X</a>]", [{"full_name": "Polynomial.modByMonic_add_div", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [262, 9], "def_end_pos": [262, 27]}, {"full_name": "Polynomial.monic_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [885, 9], "def_end_pos": [885, 16]}]], "state_before": "R : Type u_1\nr : R\ninst\u271d : CommRing R\nP : R[X]\n\u22a2 P = C (eval 0 P) + X * (P /\u2098 X)", "state_after": "R : Type u_1\nr : R\ninst\u271d : CommRing R\nP : R[X]\n\u22a2 P %\u2098 X + X * (P /\u2098 X) = C (eval 0 P) + X * (P /\u2098 X)"}, {"tactic": "simp [modByMonic_X]", "annotated_tactic": ["simp [<a>modByMonic_X</a>]", [{"full_name": "Polynomial.modByMonic_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [640, 9], "def_end_pos": [640, 21]}]], "state_before": "R : Type u_1\nr : R\ninst\u271d : CommRing R\nP : R[X]\n\u22a2 P %\u2098 X + X * (P /\u2098 X) = C (eval 0 P) + X * (P /\u2098 X)", "state_after": "no goals"}, {"tactic": "conv_lhs => rw [this]; simp", "annotated_tactic": ["conv_lhs => rw [this]; simp", []], "state_before": "R : Type u_1\nr : R\ninst\u271d : CommRing R\nP : R[X]\nthis : P = C (eval 0 P) + X * (P /\u2098 X)\n\u22a2 IsUnit P \u2194 IsUnit (eval 0 P) \u2227 IsNilpotent (P /\u2098 X)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Subfield.lean", "full_name": "Subfield.sInf_toSubring", "start": [614, 1], "end": [625, 70], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : DivisionRing L\ninst\u271d : DivisionRing M\ns : Set (Subfield K)\n\u22a2 (sInf s).toSubring = \u2a05 t \u2208 s, t.toSubring", "state_after": "case h\nK : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : DivisionRing L\ninst\u271d : DivisionRing M\ns : Set (Subfield K)\nx : K\n\u22a2 x \u2208 (sInf s).toSubring \u2194 x \u2208 \u2a05 t \u2208 s, t.toSubring"}, {"tactic": "rw [mem_toSubring, mem_sInf]", "annotated_tactic": ["rw [<a>mem_toSubring</a>, <a>mem_sInf</a>]", [{"full_name": "Subfield.mem_toSubring", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Subfield.lean", "def_pos": [233, 9], "def_end_pos": [233, 22]}, {"full_name": "Subfield.mem_sInf", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Subfield.lean", "def_pos": [608, 9], "def_end_pos": [608, 17]}]], "state_before": "case h\nK : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : DivisionRing L\ninst\u271d : DivisionRing M\ns : Set (Subfield K)\nx : K\n\u22a2 x \u2208 (sInf s).toSubring \u2194 x \u2208 \u2a05 t \u2208 s, t.toSubring", "state_after": "case h\nK : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : DivisionRing L\ninst\u271d : DivisionRing M\ns : Set (Subfield K)\nx : K\n\u22a2 (\u2200 p \u2208 s, x \u2208 p) \u2194 x \u2208 \u2a05 t \u2208 s, t.toSubring"}, {"tactic": "erw [Subring.mem_sInf]", "annotated_tactic": ["erw [<a>Subring.mem_sInf</a>]", [{"full_name": "Subring.mem_sInf", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Subring/Basic.lean", "def_pos": [676, 9], "def_end_pos": [676, 17]}]], "state_before": "case h\nK : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : DivisionRing L\ninst\u271d : DivisionRing M\ns : Set (Subfield K)\nx : K\n\u22a2 (\u2200 p \u2208 s, x \u2208 p) \u2194 x \u2208 \u2a05 t \u2208 s, t.toSubring", "state_after": "case h\nK : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : DivisionRing L\ninst\u271d : DivisionRing M\ns : Set (Subfield K)\nx : K\n\u22a2 (\u2200 p \u2208 s, x \u2208 p) \u2194 \u2200 p \u2208 Set.range fun t => \u2a05 (_ : t \u2208 s), t.toSubring, x \u2208 p"}, {"tactic": "exact\n  \u27e8fun h p \u27e8p', hp\u27e9 => hp \u25b8 Subring.mem_sInf.mpr fun p \u27e8hp', hp\u27e9 => hp \u25b8 h _ hp', fun h p hp =>\n    h p.toSubring\n      \u27e8p,\n        Subring.ext fun x =>\n          \u27e8fun hx => Subring.mem_sInf.mp hx _ \u27e8hp, rfl\u27e9, fun hx =>\n            Subring.mem_sInf.mpr fun p' \u27e8_, p'_eq\u27e9 => p'_eq \u25b8 hx\u27e9\u27e9\u27e9", "annotated_tactic": ["exact\n    \u27e8fun h p \u27e8p', hp\u27e9 => hp \u25b8 Subring.mem_sInf.mpr fun p \u27e8hp', hp\u27e9 => hp \u25b8 h _ hp', fun h p hp =>\n      h p.toSubring\n        \u27e8p,\n          <a>Subring.ext</a> fun x =>\n            \u27e8fun hx => Subring.mem_sInf.mp hx _ \u27e8hp, <a>rfl</a>\u27e9, fun hx =>\n              Subring.mem_sInf.mpr fun p' \u27e8_, p'_eq\u27e9 => p'_eq \u25b8 hx\u27e9\u27e9\u27e9", [{"full_name": "Subring.ext", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Subring/Basic.lean", "def_pos": [197, 9], "def_end_pos": [197, 12]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case h\nK : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : DivisionRing L\ninst\u271d : DivisionRing M\ns : Set (Subfield K)\nx : K\n\u22a2 (\u2200 p \u2208 s, x \u2208 p) \u2194 \u2200 p \u2208 Set.range fun t => \u2a05 (_ : t \u2208 s), t.toSubring, x \u2208 p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "full_name": "AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem\u2080", "start": [573, 1], "end": [575, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "full_name": "DifferentiableAt.snd", "start": [295, 11], "end": [297, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/PartENat.lean", "full_name": "PartENat.withTopEquiv_symm_ofNat", "start": [796, 1], "end": [798, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.OuterMeasure.smul_apply", "start": [304, 1], "end": [305, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Pairwise.lean", "full_name": "List.pairwise_of_forall_mem_list", "start": [152, 1], "end": [156, 39], "traced_tactics": [{"tactic": "apply pairwise_iff_forall_sublist.mpr", "annotated_tactic": ["apply pairwise_iff_forall_sublist.mpr", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl\u271d l : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), a \u2208 l \u2192 \u2200 (b : \u03b1), b \u2208 l \u2192 r a b\n\u22a2 Pairwise r l", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl\u271d l : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), a \u2208 l \u2192 \u2200 (b : \u03b1), b \u2208 l \u2192 r a b\n\u22a2 \u2200 {a b : \u03b1}, [a, b] <+ l \u2192 r a b"}, {"tactic": "intro a b hab", "annotated_tactic": ["intro a b hab", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl\u271d l : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), a \u2208 l \u2192 \u2200 (b : \u03b1), b \u2208 l \u2192 r a b\n\u22a2 \u2200 {a b : \u03b1}, [a, b] <+ l \u2192 r a b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d : \u03b1\nl\u271d l : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), a \u2208 l \u2192 \u2200 (b : \u03b1), b \u2208 l \u2192 r a b\na b : \u03b1\nhab : [a, b] <+ l\n\u22a2 r a b"}, {"tactic": "apply h <;> (apply hab.subset; simp)", "annotated_tactic": ["apply h <;> (apply hab.subset; simp)", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d : \u03b1\nl\u271d l : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), a \u2208 l \u2192 \u2200 (b : \u03b1), b \u2208 l \u2192 r a b\na b : \u03b1\nhab : [a, b] <+ l\n\u22a2 r a b", "state_after": "no goals"}, {"tactic": "apply hab.subset", "annotated_tactic": ["apply hab.subset", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d : \u03b1\nl\u271d l : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), a \u2208 l \u2192 \u2200 (b : \u03b1), b \u2208 l \u2192 r a b\na b : \u03b1\nhab : [a, b] <+ l\n\u22a2 b \u2208 l", "state_after": "case a.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d : \u03b1\nl\u271d l : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), a \u2208 l \u2192 \u2200 (b : \u03b1), b \u2208 l \u2192 r a b\na b : \u03b1\nhab : [a, b] <+ l\n\u22a2 b \u2208 [a, b]"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d : \u03b1\nl\u271d l : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), a \u2208 l \u2192 \u2200 (b : \u03b1), b \u2208 l \u2192 r a b\na b : \u03b1\nhab : [a, b] <+ l\n\u22a2 b \u2208 [a, b]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.coprime_iff_inf_one", "start": [1687, 1], "end": [1697, 24], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 Associates.mk a \u2293 Associates.mk b = 1 \u2194 \u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 Associates.mk a \u2293 Associates.mk b = 1 \u2192 \u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d\n\ncase mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 (\u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) \u2192 Associates.mk a \u2293 Associates.mk b = 1"}, {"tactic": "intro hg p ha hb hp", "annotated_tactic": ["intro hg p ha hb hp", []], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 Associates.mk a \u2293 Associates.mk b = 1 \u2192 \u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : Associates.mk a \u2293 Associates.mk b = 1\np : \u03b1\nha : p \u2223 a\nhb : p \u2223 b\nhp : Prime p\n\u22a2 False"}, {"tactic": "refine' ((Associates.prime_mk _).mpr hp).not_unit (isUnit_of_dvd_one _)", "annotated_tactic": ["refine' ((<a>Associates.prime_mk</a> _).<a>mpr</a> hp).<a>not_unit</a> (<a>isUnit_of_dvd_one</a> _)", [{"full_name": "Associates.prime_mk", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [1091, 9], "def_end_pos": [1091, 17]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}, {"full_name": "Prime.not_unit", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [34, 9], "def_end_pos": [34, 17]}, {"full_name": "isUnit_of_dvd_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Units.lean", "def_pos": [143, 9], "def_end_pos": [143, 26]}]], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : Associates.mk a \u2293 Associates.mk b = 1\np : \u03b1\nha : p \u2223 a\nhb : p \u2223 b\nhp : Prime p\n\u22a2 False", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : Associates.mk a \u2293 Associates.mk b = 1\np : \u03b1\nha : p \u2223 a\nhb : p \u2223 b\nhp : Prime p\n\u22a2 Associates.mk p \u2223 1"}, {"tactic": "rw [\u2190 hg]", "annotated_tactic": ["rw [\u2190 hg]", []], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : Associates.mk a \u2293 Associates.mk b = 1\np : \u03b1\nha : p \u2223 a\nhb : p \u2223 b\nhp : Prime p\n\u22a2 Associates.mk p \u2223 1", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : Associates.mk a \u2293 Associates.mk b = 1\np : \u03b1\nha : p \u2223 a\nhb : p \u2223 b\nhp : Prime p\n\u22a2 Associates.mk p \u2223 Associates.mk a \u2293 Associates.mk b"}, {"tactic": "exact le_inf (mk_le_mk_of_dvd ha) (mk_le_mk_of_dvd hb)", "annotated_tactic": ["exact <a>le_inf</a> (<a>mk_le_mk_of_dvd</a> ha) (<a>mk_le_mk_of_dvd</a> hb)", [{"full_name": "le_inf", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [377, 9], "def_end_pos": [377, 15]}, {"full_name": "Associates.mk_le_mk_of_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [1000, 9], "def_end_pos": [1000, 24]}, {"full_name": "Associates.mk_le_mk_of_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [1000, 9], "def_end_pos": [1000, 24]}]], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : Associates.mk a \u2293 Associates.mk b = 1\np : \u03b1\nha : p \u2223 a\nhb : p \u2223 b\nhp : Prime p\n\u22a2 Associates.mk p \u2223 Associates.mk a \u2293 Associates.mk b", "state_after": "no goals"}, {"tactic": "contrapose", "annotated_tactic": ["contrapose", []], "state_before": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 (\u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) \u2192 Associates.mk a \u2293 Associates.mk b = 1", "state_after": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 \u00acAssociates.mk a \u2293 Associates.mk b = 1 \u2192 \u00ac\u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d"}, {"tactic": "intro hg hc", "annotated_tactic": ["intro hg hc", []], "state_before": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 \u00acAssociates.mk a \u2293 Associates.mk b = 1 \u2192 \u00ac\u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d", "state_after": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : \u00acAssociates.mk a \u2293 Associates.mk b = 1\nhc : \u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d\n\u22a2 False"}, {"tactic": "obtain \u27e8p, hp, hpa, hpb\u27e9 := exists_prime_dvd_of_not_inf_one ha0 hb0 hg", "annotated_tactic": ["obtain \u27e8p, hp, hpa, hpb\u27e9 := <a>exists_prime_dvd_of_not_inf_one</a> ha0 hb0 hg", [{"full_name": "Associates.exists_prime_dvd_of_not_inf_one", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1665, 9], "def_end_pos": [1665, 40]}]], "state_before": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : \u00acAssociates.mk a \u2293 Associates.mk b = 1\nhc : \u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d\n\u22a2 False", "state_after": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : \u00acAssociates.mk a \u2293 Associates.mk b = 1\nhc : \u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d\np : \u03b1\nhp : Prime p\nhpa : p \u2223 a\nhpb : p \u2223 b\n\u22a2 False"}, {"tactic": "exact hc hpa hpb hp", "annotated_tactic": ["exact hc hpa hpb hp", []], "state_before": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na b : \u03b1\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhg : \u00acAssociates.mk a \u2293 Associates.mk b = 1\nhc : \u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d\np : \u03b1\nhp : Prime p\nhpa : p \u2223 a\nhpb : p \u2223 b\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.union_finset_finite_of_range_finite", "start": [1051, 1], "end": [1054, 44], "traced_tactics": [{"tactic": "rw [\u2190 biUnion_range]", "annotated_tactic": ["rw [\u2190 <a>biUnion_range</a>]", [{"full_name": "Set.biUnion_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1689, 9], "def_end_pos": [1689, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\nf : \u03b1 \u2192 Finset \u03b2\nh : Set.Finite (range f)\n\u22a2 Set.Finite (\u22c3 a, \u2191(f a))", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\nf : \u03b1 \u2192 Finset \u03b2\nh : Set.Finite (range f)\n\u22a2 Set.Finite (\u22c3 x \u2208 range fun a => f a, \u2191x)"}, {"tactic": "exact h.biUnion fun y _ => y.finite_toSet", "annotated_tactic": ["exact h.biUnion fun y _ => y.finite_toSet", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\nf : \u03b1 \u2192 Finset \u03b2\nh : Set.Finite (range f)\n\u22a2 Set.Finite (\u22c3 x \u2208 range fun a => f a, \u2191x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.map_eq_comap_of_inverse", "start": [3189, 1], "end": [3191, 85], "traced_tactics": [{"tactic": "rw [coe_map, coe_comap, Set.image_eq_preimage_of_inverse hl hr]", "annotated_tactic": ["rw [<a>coe_map</a>, <a>coe_comap</a>, <a>Set.image_eq_preimage_of_inverse</a> hl hr]", [{"full_name": "Subgroup.coe_map", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1399, 9], "def_end_pos": [1399, 16]}, {"full_name": "Subgroup.coe_comap", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1345, 9], "def_end_pos": [1345, 18]}, {"full_name": "Set.image_eq_preimage_of_inverse", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [406, 9], "def_end_pos": [406, 37]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d f : G \u2192* N\ng : N \u2192* G\nhl : LeftInverse \u21d1g \u21d1f\nhr : Function.RightInverse \u21d1g \u21d1f\nH : Subgroup G\n\u22a2 \u2191(map f H) = \u2191(comap g H)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Semicontinuous.lean", "full_name": "ContinuousWithinAt.upperSemicontinuousWithinAt", "start": [899, 1], "end": [900, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/EReal.lean", "full_name": "EReal.toReal_zero", "start": [272, 1], "end": [273, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/StructuredArrow.lean", "full_name": "CategoryTheory.StructuredArrow.mkPostcomp_id", "start": [157, 1], "end": [157, 100], "traced_tactics": [{"tactic": "aesop_cat", "annotated_tactic": ["aesop_cat", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nS S' S'' : D\nY Y' Y'' : C\nT T' : C \u2964 D\nf : S \u27f6 T.obj Y\n\u22a2 mk f = mk (f \u226b T.map (\ud835\udfd9 Y))", "state_after": "no goals"}, {"tactic": "aesop_cat", "annotated_tactic": ["aesop_cat", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nS S' S'' : D\nY Y' Y'' : C\nT T' : C \u2964 D\nf : S \u27f6 T.obj Y\n\u22a2 mkPostcomp f (\ud835\udfd9 Y) = eqToHom \u22ef", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.symm_apply_le", "start": [1000, 1], "end": [1001, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Pointwise.lean", "full_name": "Submodule.mem_set_smul", "start": [453, 1], "end": [464, 61], "traced_tactics": [{"tactic": "fconstructor", "annotated_tactic": ["fconstructor", []], "state_before": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\n\u22a2 x \u2208 sR \u2022 N \u2194 \u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)", "state_after": "case mp\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\n\u22a2 x \u2208 sR \u2022 N \u2192 \u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)\n\ncase mpr\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\n\u22a2 (\u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)) \u2192 x \u2208 sR \u2022 N"}, {"tactic": "intros h", "annotated_tactic": ["intros h", []], "state_before": "case mp\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\n\u22a2 x \u2208 sR \u2022 N \u2192 \u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)", "state_after": "case mp\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\nh : x \u2208 sR \u2022 N\n\u22a2 \u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)"}, {"tactic": "rw [set_smul_eq_map] at h", "annotated_tactic": ["rw [<a>set_smul_eq_map</a>] at h", [{"full_name": "Submodule.set_smul_eq_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Pointwise.lean", "def_pos": [425, 7], "def_end_pos": [425, 22]}]], "state_before": "case mp\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\nh : x \u2208 sR \u2022 N\n\u22a2 \u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)", "state_after": "case mp\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\nh : x \u2208 map (Submodule.subtype N \u2218\u2097 (Finsupp.lsum R) (DistribMulAction.toLinearMap R \u21a5N)) (Finsupp.supported (\u21a5N) R sR)\n\u22a2 \u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)"}, {"tactic": "obtain \u27e8c, hc, rfl\u27e9 := h", "annotated_tactic": ["obtain \u27e8c, hc, rfl\u27e9 := h", []], "state_before": "case mp\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\nh : x \u2208 map (Submodule.subtype N \u2218\u2097 (Finsupp.lsum R) (DistribMulAction.toLinearMap R \u21a5N)) (Finsupp.supported (\u21a5N) R sR)\n\u22a2 \u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)", "state_after": "case mp.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\ninst\u271d : SMulCommClass R R \u21a5N\nc : R \u2192\u2080 \u21a5N\nhc : c \u2208 \u2191(Finsupp.supported (\u21a5N) R sR)\n\u22a2 \u2203 c_1,\n    \u2191c_1.support \u2286 sR \u2227\n      (Submodule.subtype N \u2218\u2097 (Finsupp.lsum R) (DistribMulAction.toLinearMap R \u21a5N)) c =\n        \u2191(Finsupp.sum c_1 fun r m => r \u2022 m)"}, {"tactic": "exact \u27e8c, hc, rfl\u27e9", "annotated_tactic": ["exact \u27e8c, hc, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case mp.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\ninst\u271d : SMulCommClass R R \u21a5N\nc : R \u2192\u2080 \u21a5N\nhc : c \u2208 \u2191(Finsupp.supported (\u21a5N) R sR)\n\u22a2 \u2203 c_1,\n    \u2191c_1.support \u2286 sR \u2227\n      (Submodule.subtype N \u2218\u2097 (Finsupp.lsum R) (DistribMulAction.toLinearMap R \u21a5N)) c =\n        \u2191(Finsupp.sum c_1 fun r m => r \u2022 m)", "state_after": "no goals"}, {"tactic": "rw [mem_set_smul_def, Submodule.mem_sInf]", "annotated_tactic": ["rw [<a>mem_set_smul_def</a>, <a>Submodule.mem_sInf</a>]", [{"full_name": "Submodule.mem_set_smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Pointwise.lean", "def_pos": [347, 7], "def_end_pos": [347, 23]}, {"full_name": "Submodule.mem_sInf", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [256, 9], "def_end_pos": [256, 17]}]], "state_before": "case mpr\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\n\u22a2 (\u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)) \u2192 x \u2208 sR \u2022 N", "state_after": "case mpr\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\n\u22a2 (\u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)) \u2192\n    \u2200 p \u2208 {p | \u2200 \u2983r : R\u2984 {n : M}, r \u2208 sR \u2192 n \u2208 N \u2192 r \u2022 n \u2208 p}, x \u2208 p"}, {"tactic": "rintro \u27e8c, hc1, rfl\u27e9 p hp", "annotated_tactic": ["rintro \u27e8c, hc1, rfl\u27e9 p hp", []], "state_before": "case mpr\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\nx : M\ninst\u271d : SMulCommClass R R \u21a5N\n\u22a2 (\u2203 c, \u2191c.support \u2286 sR \u2227 x = \u2191(Finsupp.sum c fun r m => r \u2022 m)) \u2192\n    \u2200 p \u2208 {p | \u2200 \u2983r : R\u2984 {n : M}, r \u2208 sR \u2192 n \u2208 N \u2192 r \u2022 n \u2208 p}, x \u2208 p", "state_after": "case mpr.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\ninst\u271d : SMulCommClass R R \u21a5N\nc : R \u2192\u2080 \u21a5N\nhc1 : \u2191c.support \u2286 sR\np : Submodule R M\nhp : p \u2208 {p | \u2200 \u2983r : R\u2984 {n : M}, r \u2208 sR \u2192 n \u2208 N \u2192 r \u2022 n \u2208 p}\n\u22a2 \u2191(Finsupp.sum c fun r m => r \u2022 m) \u2208 p"}, {"tactic": "simp only [Finsupp.sum, AddSubmonoid.coe_finset_sum, coe_toAddSubmonoid, SetLike.val_smul]", "annotated_tactic": ["simp only [<a>Finsupp.sum</a>, <a>AddSubmonoid.coe_finset_sum</a>, <a>coe_toAddSubmonoid</a>, <a>SetLike.val_smul</a>]", [{"full_name": "Finsupp.sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [47, 3], "def_end_pos": [47, 14]}, {"full_name": "AddSubmonoid.coe_finset_sum", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [123, 3], "def_end_pos": [123, 14]}, {"full_name": "Submodule.coe_toAddSubmonoid", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [148, 9], "def_end_pos": [148, 27]}, {"full_name": "SetLike.val_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/SubMulAction.lean", "def_pos": [110, 19], "def_end_pos": [110, 27]}]], "state_before": "case mpr.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\ninst\u271d : SMulCommClass R R \u21a5N\nc : R \u2192\u2080 \u21a5N\nhc1 : \u2191c.support \u2286 sR\np : Submodule R M\nhp : p \u2208 {p | \u2200 \u2983r : R\u2984 {n : M}, r \u2208 sR \u2192 n \u2208 N \u2192 r \u2022 n \u2208 p}\n\u22a2 \u2191(Finsupp.sum c fun r m => r \u2022 m) \u2208 p", "state_after": "case mpr.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\ninst\u271d : SMulCommClass R R \u21a5N\nc : R \u2192\u2080 \u21a5N\nhc1 : \u2191c.support \u2286 sR\np : Submodule R M\nhp : p \u2208 {p | \u2200 \u2983r : R\u2984 {n : M}, r \u2208 sR \u2192 n \u2208 N \u2192 r \u2022 n \u2208 p}\n\u22a2 (Finset.sum c.support fun x => x \u2022 \u2191(c x)) \u2208 p"}, {"tactic": "exact Submodule.sum_mem _ fun r hr \u21a6 hp (hc1 hr) (c _).2", "annotated_tactic": ["exact <a>Submodule.sum_mem</a> _ fun r hr \u21a6 hp (hc1 hr) (c _).2", [{"full_name": "Submodule.sum_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [235, 19], "def_end_pos": [235, 26]}]], "state_before": "case mpr.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nS : Type u_4\ninst\u271d\u2074 : Monoid S\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : DistribMulAction S M\nsR : Set R\ns : Set S\nN : Submodule R M\ninst\u271d : SMulCommClass R R \u21a5N\nc : R \u2192\u2080 \u21a5N\nhc1 : \u2191c.support \u2286 sR\np : Submodule R M\nhp : p \u2208 {p | \u2200 \u2983r : R\u2984 {n : M}, r \u2208 sR \u2192 n \u2208 N \u2192 r \u2022 n \u2208 p}\n\u22a2 (Finset.sum c.support fun x => x \u2022 \u2191(c x)) \u2208 p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Algebraic.lean", "full_name": "Algebra.isAlgebraic_iff_isIntegral", "start": [227, 11], "end": [229, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.Nontrivial.ne_singleton", "start": [827, 1], "end": [828, 48], "traced_tactics": [{"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Finset \u03b1\na b : \u03b1\nhs : Finset.Nontrivial s\n\u22a2 s \u2260 {a}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b : \u03b1\nhs : Finset.Nontrivial {a}\n\u22a2 False"}, {"tactic": "exact not_nontrivial_singleton hs", "annotated_tactic": ["exact <a>not_nontrivial_singleton</a> hs", [{"full_name": "Finset.not_nontrivial_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [824, 9], "def_end_pos": [824, 33]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b : \u03b1\nhs : Finset.Nontrivial {a}\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Abs.lean", "full_name": "Complex.abs_re_le_abs", "start": [159, 1], "end": [162, 53], "traced_tactics": [{"tactic": "rw [normSq_apply, \u2190 sq]", "annotated_tactic": ["rw [<a>normSq_apply</a>, \u2190 <a>sq</a>]", [{"full_name": "Complex.normSq_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [616, 9], "def_end_pos": [616, 21]}, {"full_name": "sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [91, 41], "def_end_pos": [91, 43]}]], "state_before": "z : \u2102\n\u22a2 z.re ^ 2 \u2264 normSq z", "state_after": "z : \u2102\n\u22a2 z.re ^ 2 \u2264 z.re ^ 2 + z.im * z.im"}, {"tactic": "exact le_add_of_nonneg_right (mul_self_nonneg _)", "annotated_tactic": ["exact <a>le_add_of_nonneg_right</a> (<a>mul_self_nonneg</a> _)", [{"full_name": "le_add_of_nonneg_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [391, 15], "def_end_pos": [391, 37]}, {"full_name": "mul_self_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [1218, 7], "def_end_pos": [1218, 22]}]], "state_before": "z : \u2102\n\u22a2 z.re ^ 2 \u2264 z.re ^ 2 + z.im * z.im", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.lt_one_iff_zero", "start": [1524, 1], "end": [1525, 39], "traced_tactics": [{"tactic": "simpa using lt_succ_bot_iff (a := c)", "annotated_tactic": ["simpa using <a>lt_succ_bot_iff</a> (a := c)", [{"full_name": "Order.lt_succ_bot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [545, 9], "def_end_pos": [545, 24]}]], "state_before": "\u03b1 \u03b2 : Type u\nc : Cardinal.{u_1}\n\u22a2 c < 1 \u2194 c = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounded.lean", "full_name": "Set.unbounded_gt_of_unbounded_ge", "start": [129, 1], "end": [132, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/PartENat.lean", "full_name": "PartENat.dom_some", "start": [88, 1], "end": [89, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bornology/Constructions.lean", "full_name": "Bornology.IsBounded.image_fst", "start": [63, 1], "end": [64, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/ProjIcc.lean", "full_name": "Set.IccExtend_apply", "start": [214, 1], "end": [215, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/DenseEmbedding.lean", "full_name": "DenseInducing.extend_eq", "start": [162, 1], "end": [163, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_mul_const_atTop_iff_neg", "start": [1234, 1], "end": [1236, 62], "traced_tactics": [{"tactic": "simp only [mul_comm _ r, tendsto_const_mul_atTop_iff_neg h]", "annotated_tactic": ["simp only [<a>mul_comm</a> _ r, <a>tendsto_const_mul_atTop_iff_neg</a> h]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Filter.tendsto_const_mul_atTop_iff_neg", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [1227, 9], "def_end_pos": [1227, 40]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u00b9 : LinearOrderedField \u03b1\nl : Filter \u03b2\nf : \u03b2 \u2192 \u03b1\nr : \u03b1\ninst\u271d : NeBot l\nh : Tendsto f l atBot\n\u22a2 Tendsto (fun x => f x * r) l atTop \u2194 r < 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "full_name": "MultilinearMap.mkPiRing_eq_zero_iff", "start": [1209, 1], "end": [1210, 40], "traced_tactics": [{"tactic": "rw [\u2190 mkPiRing_zero, mkPiRing_eq_iff]", "annotated_tactic": ["rw [\u2190 <a>mkPiRing_zero</a>, <a>mkPiRing_eq_iff</a>]", [{"full_name": "MultilinearMap.mkPiRing_zero", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Multilinear/Basic.lean", "def_pos": [1205, 9], "def_end_pos": [1205, 22]}, {"full_name": "MultilinearMap.mkPiRing_eq_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Multilinear/Basic.lean", "def_pos": [1196, 9], "def_end_pos": [1196, 24]}]], "state_before": "R : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn : \u2115\nM : Fin (Nat.succ n) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddCommMonoid (M\u2081 i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : (i : Fin (Nat.succ n)) \u2192 Module R (M i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (M\u2081 i)\ninst\u271d\u00b9 : Module R M\u2082\nf f' : MultilinearMap R M\u2081 M\u2082\ninst\u271d : Fintype \u03b9\nz : M\u2082\n\u22a2 MultilinearMap.mkPiRing R \u03b9 z = 0 \u2194 z = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.exists_add_eq_of_codisjoint", "start": [433, 1], "end": [436, 48], "traced_tactics": [{"tactic": "suffices x \u2208 p \u2294 p' by exact Submodule.mem_sup.mp this", "annotated_tactic": ["suffices x \u2208 p \u2294 p' by exact Submodule.mem_sup.mp this", []], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nh : Codisjoint p p'\nx : M\n\u22a2 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x", "state_after": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nh : Codisjoint p p'\nx : M\n\u22a2 x \u2208 p \u2294 p'"}, {"tactic": "simpa only [h.eq_top] using Submodule.mem_top", "annotated_tactic": ["simpa only [h.eq_top] using <a>Submodule.mem_top</a>", [{"full_name": "Submodule.mem_top", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [159, 9], "def_end_pos": [159, 16]}]], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nh : Codisjoint p p'\nx : M\n\u22a2 x \u2208 p \u2294 p'", "state_after": "no goals"}, {"tactic": "exact Submodule.mem_sup.mp this", "annotated_tactic": ["exact Submodule.mem_sup.mp this", []], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u2074 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nh : Codisjoint p p'\nx : M\nthis : x \u2208 p \u2294 p'\n\u22a2 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "TopHom.dual_comp", "start": [750, 1], "end": [752, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Sum/Lemmas.lean", "full_name": "Sum.Lex.mono_right", "start": [211, 1], "end": [212, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.indexOf_inj", "start": [1386, 1], "end": [1393, 79], "traced_tactics": [{"tactic": "have x_eq_y :\n    get l \u27e8indexOf x l, indexOf_lt_length.2 hx\u27e9 =\n    get l \u27e8indexOf y l, indexOf_lt_length.2 hy\u27e9 := by\n  simp only [h]", "annotated_tactic": ["have x_eq_y :\n        <a>get</a> l \u27e8<a>indexOf</a> x l, <a>indexOf_lt_length</a>.2 hx\u27e9 =\n        <a>get</a> l \u27e8<a>indexOf</a> y l, <a>indexOf_lt_length</a>.2 hy\u27e9 := by\n      simp only [h]", [{"full_name": "List.get", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2345, 5], "def_end_pos": [2345, 13]}, {"full_name": "List.indexOf", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [336, 5], "def_end_pos": [336, 12]}, {"full_name": "List.indexOf_lt_length", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1165, 9], "def_end_pos": [1165, 26]}, {"full_name": "List.get", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2345, 5], "def_end_pos": [2345, 13]}, {"full_name": "List.indexOf", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [336, 5], "def_end_pos": [336, 12]}, {"full_name": "List.indexOf_lt_length", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1165, 9], "def_end_pos": [1165, 26]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx y : \u03b1\nhx : x \u2208 l\nhy : y \u2208 l\nh : indexOf x l = indexOf y l\n\u22a2 x = y", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx y : \u03b1\nhx : x \u2208 l\nhy : y \u2208 l\nh : indexOf x l = indexOf y l\nx_eq_y : get l { val := indexOf x l, isLt := \u22ef } = get l { val := indexOf y l, isLt := \u22ef }\n\u22a2 x = y"}, {"tactic": "simp only [indexOf_get] at x_eq_y", "annotated_tactic": ["simp only [<a>indexOf_get</a>] at x_eq_y", [{"full_name": "List.indexOf_get", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1362, 9], "def_end_pos": [1362, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx y : \u03b1\nhx : x \u2208 l\nhy : y \u2208 l\nh : indexOf x l = indexOf y l\nx_eq_y : get l { val := indexOf x l, isLt := \u22ef } = get l { val := indexOf y l, isLt := \u22ef }\n\u22a2 x = y", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx y : \u03b1\nhx : x \u2208 l\nhy : y \u2208 l\nh : indexOf x l = indexOf y l\nx_eq_y : x = y\n\u22a2 x = y"}, {"tactic": "exact x_eq_y", "annotated_tactic": ["exact x_eq_y", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx y : \u03b1\nhx : x \u2208 l\nhy : y \u2208 l\nh : indexOf x l = indexOf y l\nx_eq_y : x = y\n\u22a2 x = y", "state_after": "no goals"}, {"tactic": "simp only [h]", "annotated_tactic": ["simp only [h]", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx y : \u03b1\nhx : x \u2208 l\nhy : y \u2208 l\nh : indexOf x l = indexOf y l\n\u22a2 get l { val := indexOf x l, isLt := \u22ef } = get l { val := indexOf y l, isLt := \u22ef }", "state_after": "no goals"}, {"tactic": "subst h", "annotated_tactic": ["subst h", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx y : \u03b1\nhx : x \u2208 l\nhy : y \u2208 l\nh : x = y\n\u22a2 indexOf x l = indexOf y l", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nhx hy : x \u2208 l\n\u22a2 indexOf x l = indexOf x l"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nhx hy : x \u2208 l\n\u22a2 indexOf x l = indexOf x l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean", "full_name": "tendsto_self_mul_const_pow_of_abs_lt_one", "start": [255, 1], "end": [257, 80], "traced_tactics": [{"tactic": "simpa only [pow_one] using tendsto_pow_const_mul_const_pow_of_abs_lt_one 1 hr", "annotated_tactic": ["simpa only [<a>pow_one</a>] using <a>tendsto_pow_const_mul_const_pow_of_abs_lt_one</a> 1 hr", [{"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}, {"full_name": "tendsto_pow_const_mul_const_pow_of_abs_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecificLimits/Normed.lean", "def_pos": [236, 9], "def_end_pos": [236, 54]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nr : \u211d\nhr : |r| < 1\n\u22a2 Tendsto (fun n => \u2191n * r ^ n) atTop (\ud835\udcdd 0)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/LegendreSymbol.lean", "full_name": "Mathlib.Meta.NormNum.jacobiSymNat.even_odd\u2083", "start": [158, 1], "end": [162, 42], "traced_tactics": [{"tactic": "simp only [jacobiSymNat, \u2190 hr, \u2190 hc, Int.ofNat_ediv, Nat.cast_ofNat]", "annotated_tactic": ["simp only [<a>jacobiSymNat</a>, \u2190 hr, \u2190 hc, <a>Int.ofNat_ediv</a>, <a>Nat.cast_ofNat</a>]", [{"full_name": "Mathlib.Meta.NormNum.jacobiSymNat", "def_path": ".lake/packages/mathlib/Mathlib/Tactic/NormNum/LegendreSymbol.lean", "def_pos": [55, 5], "def_end_pos": [55, 17]}, {"full_name": "Int.ofNat_ediv", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean", "def_pos": [25, 28], "def_end_pos": [25, 38]}, {"full_name": "Nat.cast_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [75, 28], "def_end_pos": [75, 42]}]], "state_before": "a b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 3\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 jacobiSymNat a b = -r", "state_after": "a b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 3\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 jacobiSym (\u2191a) b = -jacobiSym (\u2191a / 2) b"}, {"tactic": "rw [\u2190 jacobiSym.even_odd (mod_cast ha), if_pos (by simp [hb])]", "annotated_tactic": ["rw [\u2190 <a>jacobiSym.even_odd</a> (mod_cast ha), <a>if_pos</a> (by simp [hb])]", [{"full_name": "jacobiSym.even_odd", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "def_pos": [369, 9], "def_end_pos": [369, 17]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}]], "state_before": "a b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 3\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 jacobiSym (\u2191a) b = -jacobiSym (\u2191a / 2) b", "state_after": "a b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 3\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 b % 2 = 1"}, {"tactic": "rw [\u2190 Nat.mod_mod_of_dvd, hb]", "annotated_tactic": ["rw [\u2190 <a>Nat.mod_mod_of_dvd</a>, hb]", [{"full_name": "Nat.mod_mod_of_dvd", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [695, 17], "def_end_pos": [695, 31]}]], "state_before": "a b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 3\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 b % 2 = 1", "state_after": "case h\na b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 3\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 2 \u2223 8"}, {"tactic": "norm_num", "annotated_tactic": ["norm_num", []], "state_before": "case h\na b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 3\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 2 \u2223 8", "state_after": "no goals"}, {"tactic": "simp [hb]", "annotated_tactic": ["simp [hb]", []], "state_before": "a b c : \u2115\nr : \u2124\nha : a % 2 = 0\nhb : b % 8 = 3\nhc : a / 2 = c\nhr : jacobiSymNat c b = r\n\u22a2 b % 8 = 3 \u2228 b % 8 = 5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Fintype.lean", "full_name": "Equiv.extendSubtype_apply_of_not_mem", "start": [138, 1], "end": [142, 74], "traced_tactics": [{"tactic": "dsimp only [extendSubtype]", "annotated_tactic": ["dsimp only [<a>extendSubtype</a>]", [{"full_name": "Equiv.extendSubtype", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Fintype.lean", "def_pos": [121, 22], "def_end_pos": [121, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : \u00acp x\n\u22a2 (extendSubtype e) x = \u2191((toCompl e) { val := x, property := hx })", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : \u00acp x\n\u22a2 (subtypeCongr e (toCompl e)) x = \u2191((toCompl e) { val := x, property := hx })"}, {"tactic": "simp only [subtypeCongr, Equiv.trans_apply, Equiv.sumCongr_apply]", "annotated_tactic": ["simp only [<a>subtypeCongr</a>, <a>Equiv.trans_apply</a>, <a>Equiv.sumCongr_apply</a>]", [{"full_name": "Equiv.subtypeCongr", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [613, 5], "def_end_pos": [613, 17]}, {"full_name": "Equiv.trans_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [280, 17], "def_end_pos": [280, 28]}, {"full_name": "Equiv.sumCongr_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [297, 9], "def_end_pos": [297, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : \u00acp x\n\u22a2 (subtypeCongr e (toCompl e)) x = \u2191((toCompl e) { val := x, property := hx })", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : \u00acp x\n\u22a2 (sumCompl fun x => q x) (Sum.map (\u21d1e) (\u21d1(toCompl e)) ((sumCompl fun x => p x).symm x)) =\n    \u2191((toCompl e) { val := x, property := hx })"}, {"tactic": "rw [sumCompl_apply_symm_of_neg _ _ hx, Sum.map_inr, sumCompl_apply_inr]", "annotated_tactic": ["rw [<a>sumCompl_apply_symm_of_neg</a> _ _ hx, <a>Sum.map_inr</a>, <a>sumCompl_apply_inr</a>]", [{"full_name": "Equiv.sumCompl_apply_symm_of_neg", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [606, 9], "def_end_pos": [606, 35]}, {"full_name": "Sum.map_inr", "def_path": ".lake/packages/std/Std/Data/Sum/Basic.lean", "def_pos": [97, 17], "def_end_pos": [97, 24]}, {"full_name": "Equiv.sumCompl_apply_inr", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [594, 9], "def_end_pos": [594, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : \u00acp x\n\u22a2 (sumCompl fun x => q x) (Sum.map (\u21d1e) (\u21d1(toCompl e)) ((sumCompl fun x => p x).symm x)) =\n    \u2191((toCompl e) { val := x, property := hx })", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Degrees.lean", "full_name": "MvPolynomial.degreeOf_mul_X_eq", "start": [319, 1], "end": [326, 37], "traced_tactics": [{"tactic": "classical\nrepeat' rw [degreeOf]\napply (Multiset.count_le_of_le j (degrees_mul f (X j))).trans\nsimp only [Multiset.count_add, add_le_add_iff_left]\nconvert Multiset.count_le_of_le j (degrees_X' (R := R) j)\nrw [Multiset.count_singleton_self]", "annotated_tactic": ["classical\n  repeat' rw [degreeOf]\n  apply (<a>Multiset.count_le_of_le</a> j (<a>degrees_mul</a> f (<a>X</a> j))).<a>trans</a>\n  simp only [<a>Multiset.count_add</a>, <a>add_le_add_iff_left</a>]\n  convert <a>Multiset.count_le_of_le</a> j (<a>degrees_X'</a> (R := R) j)\n  rw [<a>Multiset.count_singleton_self</a>]", [{"full_name": "Multiset.count_le_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2456, 9], "def_end_pos": [2456, 23]}, {"full_name": "MvPolynomial.degrees_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}, {"full_name": "MvPolynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [190, 5], "def_end_pos": [190, 6]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "Multiset.count_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2478, 9], "def_end_pos": [2478, 18]}, {"full_name": "add_le_add_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [82, 3], "def_end_pos": [82, 14]}, {"full_name": "Multiset.count_le_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2456, 9], "def_end_pos": [2456, 23]}, {"full_name": "MvPolynomial.degrees_X'", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [108, 9], "def_end_pos": [108, 19]}, {"full_name": "Multiset.count_singleton_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2469, 9], "def_end_pos": [2469, 29]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 degreeOf j (f * X j) \u2264 degreeOf j f + 1", "state_after": "no goals"}, {"tactic": "repeat' rw [degreeOf]", "annotated_tactic": ["repeat' rw [degreeOf]", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 degreeOf j (f * X j) \u2264 degreeOf j f + 1", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 Multiset.count j (degrees (f * X j)) \u2264 Multiset.count j (degrees f) + 1"}, {"tactic": "apply (Multiset.count_le_of_le j (degrees_mul f (X j))).trans", "annotated_tactic": ["apply (<a>Multiset.count_le_of_le</a> j (<a>degrees_mul</a> f (<a>X</a> j))).<a>trans</a>", [{"full_name": "Multiset.count_le_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2456, 9], "def_end_pos": [2456, 23]}, {"full_name": "MvPolynomial.degrees_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}, {"full_name": "MvPolynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [190, 5], "def_end_pos": [190, 6]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 Multiset.count j (degrees (f * X j)) \u2264 Multiset.count j (degrees f) + 1", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 Multiset.count j (degrees f + degrees (X j)) \u2264 Multiset.count j (degrees f) + 1"}, {"tactic": "simp only [Multiset.count_add, add_le_add_iff_left]", "annotated_tactic": ["simp only [<a>Multiset.count_add</a>, <a>add_le_add_iff_left</a>]", [{"full_name": "Multiset.count_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2478, 9], "def_end_pos": [2478, 18]}, {"full_name": "add_le_add_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [82, 3], "def_end_pos": [82, 14]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 Multiset.count j (degrees f + degrees (X j)) \u2264 Multiset.count j (degrees f) + 1", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 Multiset.count j (degrees (X j)) \u2264 1"}, {"tactic": "convert Multiset.count_le_of_le j (degrees_X' (R := R) j)", "annotated_tactic": ["convert <a>Multiset.count_le_of_le</a> j (<a>degrees_X'</a> (R := R) j)", [{"full_name": "Multiset.count_le_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2456, 9], "def_end_pos": [2456, 23]}, {"full_name": "MvPolynomial.degrees_X'", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [108, 9], "def_end_pos": [108, 19]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 Multiset.count j (degrees (X j)) \u2264 1", "state_after": "case h.e'_4\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 1 = Multiset.count j {j}"}, {"tactic": "rw [Multiset.count_singleton_self]", "annotated_tactic": ["rw [<a>Multiset.count_singleton_self</a>]", [{"full_name": "Multiset.count_singleton_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2469, 9], "def_end_pos": [2469, 29]}]], "state_before": "case h.e'_4\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 1 = Multiset.count j {j}", "state_after": "no goals"}, {"tactic": "rw [degreeOf]", "annotated_tactic": ["rw [degreeOf]", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 Multiset.count j (degrees (f * X j)) \u2264 degreeOf j f + 1", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nj : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 Multiset.count j (degrees (f * X j)) \u2264 Multiset.count j (degrees f) + 1"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Divisors.lean", "full_name": "Nat.mem_divisors_prime_pow", "start": [358, 1], "end": [360, 86], "traced_tactics": [{"tactic": "rw [mem_divisors, Nat.dvd_prime_pow pp, and_iff_left (ne_of_gt (pow_pos pp.pos k))]", "annotated_tactic": ["rw [<a>mem_divisors</a>, <a>Nat.dvd_prime_pow</a> pp, <a>and_iff_left</a> (<a>ne_of_gt</a> (<a>pow_pos</a> pp.pos k))]", [{"full_name": "Nat.mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [96, 9], "def_end_pos": [96, 21]}, {"full_name": "Nat.dvd_prime_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Prime.lean", "def_pos": [690, 9], "def_end_pos": [690, 22]}, {"full_name": "and_iff_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [54, 9], "def_end_pos": [54, 21]}, {"full_name": "Nat.ne_of_gt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [373, 9], "def_end_pos": [373, 17]}, {"full_name": "pow_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [559, 9], "def_end_pos": [559, 16]}]], "state_before": "n p : \u2115\npp : Prime p\nk x : \u2115\n\u22a2 x \u2208 divisors (p ^ k) \u2194 \u2203 j \u2264 k, x = p ^ j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "nhdsWithin_compl_singleton_le", "start": [421, 1], "end": [425, 29], "traced_tactics": [{"tactic": "rcases eq_or_ne x y with rfl|hy", "annotated_tactic": ["rcases <a>eq_or_ne</a> x y with rfl|hy", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx y : X\n\u22a2 \ud835\udcdd[\u2260] x \u2264 \ud835\udcdd[{y}\u1d9c] x", "state_after": "case inl\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\n\u22a2 \ud835\udcdd[\u2260] x \u2264 \ud835\udcdd[\u2260] x\n\ncase inr\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx y : X\nhy : x \u2260 y\n\u22a2 \ud835\udcdd[\u2260] x \u2264 \ud835\udcdd[{y}\u1d9c] x"}, {"tactic": "exact Eq.le rfl", "annotated_tactic": ["exact <a>Eq.le</a> <a>rfl</a>", [{"full_name": "Eq.le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [156, 7], "def_end_pos": [156, 12]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case inl\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx : X\n\u22a2 \ud835\udcdd[\u2260] x \u2264 \ud835\udcdd[\u2260] x", "state_after": "no goals"}, {"tactic": "rw [Ne.nhdsWithin_compl_singleton hy]", "annotated_tactic": ["rw [<a>Ne.nhdsWithin_compl_singleton</a> hy]", [{"full_name": "Ne.nhdsWithin_compl_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [411, 9], "def_end_pos": [411, 38]}]], "state_before": "case inr\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx y : X\nhy : x \u2260 y\n\u22a2 \ud835\udcdd[\u2260] x \u2264 \ud835\udcdd[{y}\u1d9c] x", "state_after": "case inr\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx y : X\nhy : x \u2260 y\n\u22a2 \ud835\udcdd[\u2260] x \u2264 \ud835\udcdd x"}, {"tactic": "exact nhdsWithin_le_nhds", "annotated_tactic": ["exact <a>nhdsWithin_le_nhds</a>", [{"full_name": "nhdsWithin_le_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [201, 9], "def_end_pos": [201, 27]}]], "state_before": "case inr\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T1Space X\nx y : X\nhy : x \u2260 y\n\u22a2 \ud835\udcdd[\u2260] x \u2264 \ud835\udcdd x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/Subalgebra.lean", "full_name": "StarSubalgebra.mem_carrier", "start": [80, 1], "end": [81, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "full_name": "Polynomial.TrailingMonic.def", "start": [70, 1], "end": [71, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.PreservesPullback.iso_hom_fst", "start": [115, 1], "end": [117, 31], "traced_tactics": [{"tactic": "simp [PreservesPullback.iso]", "annotated_tactic": ["simp [<a>PreservesPullback.iso</a>]", [{"full_name": "CategoryTheory.Limits.PreservesPullback.iso", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Preserves/Shapes/Pullbacks.lean", "def_pos": [110, 5], "def_end_pos": [110, 26]}]], "state_before": "C : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} D\nG : C \u2964 D\nW X Y Z : C\nf : X \u27f6 Z\ng : Y \u27f6 Z\nh : W \u27f6 X\nk : W \u27f6 Y\ncomm : h \u226b f = k \u226b g\ninst\u271d\u00b2 : PreservesLimit (cospan f g) G\ninst\u271d\u00b9 : HasPullback f g\ninst\u271d : HasPullback (G.map f) (G.map g)\n\u22a2 (iso G f g).hom \u226b pullback.fst = G.map pullback.fst", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.coe_equivMapOfInjective_apply", "start": [164, 1], "end": [166, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "lt_of_one_div_lt_one_div", "start": [483, 1], "end": [484, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.modByMonic_eq_sub_mul_div", "start": [240, 1], "end": [259, 24], "traced_tactics": [{"tactic": "have _wf := div_wf_lemma h hq", "annotated_tactic": ["have _wf := <a>div_wf_lemma</a> h hq", [{"full_name": "Polynomial.div_wf_lemma", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [91, 9], "def_end_pos": [91, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n\u22a2 p %\u2098 q = p - q * (p /\u2098 q)", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\n\u22a2 p %\u2098 q = p - q * (p /\u2098 q)"}, {"tactic": "have ih := modByMonic_eq_sub_mul_div\n  (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq", "annotated_tactic": ["have ih := modByMonic_eq_sub_mul_div\n        (p - q * (<a>C</a> (<a>leadingCoeff</a> p) * <a>X</a> ^ (<a>natDegree</a> p - <a>natDegree</a> q))) hq", [{"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}, {"full_name": "Polynomial.leadingCoeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [74, 5], "def_end_pos": [74, 17]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [69, 5], "def_end_pos": [69, 14]}, {"full_name": "Polynomial.natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [69, 5], "def_end_pos": [69, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\n\u22a2 p %\u2098 q = p - q * (p /\u2098 q)", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) %\u2098 q =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 p %\u2098 q = p - q * (p /\u2098 q)"}, {"tactic": "unfold modByMonic divByMonic divModByMonicAux", "annotated_tactic": ["unfold <a>modByMonic</a> <a>divByMonic</a> <a>divModByMonicAux</a>", [{"full_name": "Polynomial.modByMonic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [125, 5], "def_end_pos": [125, 15]}, {"full_name": "Polynomial.divByMonic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [119, 5], "def_end_pos": [119, 15]}, {"full_name": "Polynomial.divModByMonicAux", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [106, 19], "def_end_pos": [106, 35]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) %\u2098 q =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 p %\u2098 q = p - q * (p /\u2098 q)", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) %\u2098 q =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (if h : Monic q then\n      (if h_1 : degree q \u2264 degree p \u2227 p \u2260 0 then\n          let z := C (leadingCoeff p) * X ^ (natDegree p - natDegree q);\n          let_fun _wf := \u22ef;\n          let dm := divModByMonicAux (p - q * z) \u22ef;\n          (z + dm.1, dm.2)\n        else (0, p)).2\n    else p) =\n    p -\n      q *\n        if h : Monic q then\n          (if h_1 : degree q \u2264 degree p \u2227 p \u2260 0 then\n              let z := C (leadingCoeff p) * X ^ (natDegree p - natDegree q);\n              let_fun _wf := \u22ef;\n              let dm := divModByMonicAux (p - q * z) \u22ef;\n              (z + dm.1, dm.2)\n            else (0, p)).1\n        else 0"}, {"tactic": "dsimp", "annotated_tactic": ["dsimp", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) %\u2098 q =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (if h : Monic q then\n      (if h_1 : degree q \u2264 degree p \u2227 p \u2260 0 then\n          let z := C (leadingCoeff p) * X ^ (natDegree p - natDegree q);\n          let_fun _wf := \u22ef;\n          let dm := divModByMonicAux (p - q * z) \u22ef;\n          (z + dm.1, dm.2)\n        else (0, p)).2\n    else p) =\n    p -\n      q *\n        if h : Monic q then\n          (if h_1 : degree q \u2264 degree p \u2227 p \u2260 0 then\n              let z := C (leadingCoeff p) * X ^ (natDegree p - natDegree q);\n              let_fun _wf := \u22ef;\n              let dm := divModByMonicAux (p - q * z) \u22ef;\n              (z + dm.1, dm.2)\n            else (0, p)).1\n        else 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) %\u2098 q =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (if h : Monic q then\n      (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n          (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n              (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n            (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n        else (0, p)).2\n    else p) =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0"}, {"tactic": "rw [dif_pos hq, if_pos h]", "annotated_tactic": ["rw [<a>dif_pos</a> hq, <a>if_pos</a> h]", [{"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) %\u2098 q =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (if h : Monic q then\n      (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n          (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n              (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n            (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n        else (0, p)).2\n    else p) =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) %\u2098 q =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n          (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n        (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2).2 =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0"}, {"tactic": "rw [modByMonic, dif_pos hq] at ih", "annotated_tactic": ["rw [<a>modByMonic</a>, <a>dif_pos</a> hq] at ih", [{"full_name": "Polynomial.modByMonic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [125, 5], "def_end_pos": [125, 15]}, {"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) %\u2098 q =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n          (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n        (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2).2 =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq).2 =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n          (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n        (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2).2 =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0"}, {"tactic": "refine' ih.trans _", "annotated_tactic": ["refine' ih.trans _", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq).2 =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n          (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n        (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2).2 =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq).2 =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q) =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0"}, {"tactic": "unfold divByMonic", "annotated_tactic": ["unfold <a>divByMonic</a>", [{"full_name": "Polynomial.divByMonic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [119, 5], "def_end_pos": [119, 15]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq).2 =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q) =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq).2 =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q *\n        if hq : Monic q then (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq).1\n        else 0) =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0"}, {"tactic": "rw [dif_pos hq, dif_pos hq, if_pos h, mul_add, sub_add_eq_sub_sub]", "annotated_tactic": ["rw [<a>dif_pos</a> hq, <a>dif_pos</a> hq, <a>if_pos</a> h, <a>mul_add</a>, <a>sub_add_eq_sub_sub</a>]", [{"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}, {"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "sub_add_eq_sub_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [621, 3], "def_end_pos": [621, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : degree q \u2264 degree p \u2227 p \u2260 0\n_wf : degree (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) < degree p\nih :\n  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq).2 =\n    p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q * ((p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) /\u2098 q)\n\u22a2 (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)) -\n      q *\n        if hq : Monic q then (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) hq).1\n        else 0) =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0", "state_after": "no goals"}, {"tactic": "unfold modByMonic divByMonic divModByMonicAux", "annotated_tactic": ["unfold <a>modByMonic</a> <a>divByMonic</a> <a>divModByMonicAux</a>", [{"full_name": "Polynomial.modByMonic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [125, 5], "def_end_pos": [125, 15]}, {"full_name": "Polynomial.divByMonic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [119, 5], "def_end_pos": [119, 15]}, {"full_name": "Polynomial.divModByMonicAux", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [106, 19], "def_end_pos": [106, 35]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : \u00ac(degree q \u2264 degree p \u2227 p \u2260 0)\n\u22a2 p %\u2098 q = p - q * (p /\u2098 q)", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : \u00ac(degree q \u2264 degree p \u2227 p \u2260 0)\n\u22a2 (if h : Monic q then\n      (if h_1 : degree q \u2264 degree p \u2227 p \u2260 0 then\n          let z := C (leadingCoeff p) * X ^ (natDegree p - natDegree q);\n          let_fun _wf := \u22ef;\n          let dm := divModByMonicAux (p - q * z) \u22ef;\n          (z + dm.1, dm.2)\n        else (0, p)).2\n    else p) =\n    p -\n      q *\n        if h : Monic q then\n          (if h_1 : degree q \u2264 degree p \u2227 p \u2260 0 then\n              let z := C (leadingCoeff p) * X ^ (natDegree p - natDegree q);\n              let_fun _wf := \u22ef;\n              let dm := divModByMonicAux (p - q * z) \u22ef;\n              (z + dm.1, dm.2)\n            else (0, p)).1\n        else 0"}, {"tactic": "dsimp", "annotated_tactic": ["dsimp", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : \u00ac(degree q \u2264 degree p \u2227 p \u2260 0)\n\u22a2 (if h : Monic q then\n      (if h_1 : degree q \u2264 degree p \u2227 p \u2260 0 then\n          let z := C (leadingCoeff p) * X ^ (natDegree p - natDegree q);\n          let_fun _wf := \u22ef;\n          let dm := divModByMonicAux (p - q * z) \u22ef;\n          (z + dm.1, dm.2)\n        else (0, p)).2\n    else p) =\n    p -\n      q *\n        if h : Monic q then\n          (if h_1 : degree q \u2264 degree p \u2227 p \u2260 0 then\n              let z := C (leadingCoeff p) * X ^ (natDegree p - natDegree q);\n              let_fun _wf := \u22ef;\n              let dm := divModByMonicAux (p - q * z) \u22ef;\n              (z + dm.1, dm.2)\n            else (0, p)).1\n        else 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : \u00ac(degree q \u2264 degree p \u2227 p \u2260 0)\n\u22a2 (if h : Monic q then\n      (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n          (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n              (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n            (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n        else (0, p)).2\n    else p) =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0"}, {"tactic": "rw [dif_pos hq, if_neg h, dif_pos hq, if_neg h, mul_zero, sub_zero]", "annotated_tactic": ["rw [<a>dif_pos</a> hq, <a>if_neg</a> h, <a>dif_pos</a> hq, <a>if_neg</a> h, <a>mul_zero</a>, <a>sub_zero</a>]", [{"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "sub_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [407, 3], "def_end_pos": [407, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q\u271d p q : R[X]\nhq : Monic q\nthis : DecidableEq R := Classical.decEq R\nh : \u00ac(degree q \u2264 degree p \u2227 p \u2260 0)\n\u22a2 (if h : Monic q then\n      (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n          (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n              (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n            (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n        else (0, p)).2\n    else p) =\n    p -\n      q *\n        if h : Monic q then\n          (if degree q \u2264 degree p \u2227 \u00acp = 0 then\n              (C (leadingCoeff p) * X ^ (natDegree p - natDegree q) +\n                  (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).1,\n                (divModByMonicAux (p - q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q))) \u22ef).2)\n            else (0, p)).1\n        else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.map_const", "start": [2246, 1], "end": [2248, 34], "traced_tactics": [{"tactic": "ext s", "annotated_tactic": ["ext s", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\ninst\u271d : NeBot f\nc : \u03b2\n\u22a2 map (fun x => c) f = pure c", "state_after": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt : Set \u03b2\ninst\u271d : NeBot f\nc : \u03b2\ns : Set \u03b2\n\u22a2 s \u2208 map (fun x => c) f \u2194 s \u2208 pure c"}, {"tactic": "by_cases h : c \u2208 s <;> simp [h]", "annotated_tactic": ["by_cases h : c \u2208 s <;> simp [h]", []], "state_before": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt : Set \u03b2\ninst\u271d : NeBot f\nc : \u03b2\ns : Set \u03b2\n\u22a2 s \u2208 map (fun x => c) f \u2194 s \u2208 pure c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean", "full_name": "IsCyclotomicExtension.two_pow_norm_zeta_sub_one", "start": [539, 1], "end": [541, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sum/Order.lean", "full_name": "WithBot.orderIsoPUnitSumLex_toLex", "start": [759, 1], "end": [760, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csSup_Ioc", "start": [786, 1], "end": [787, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "HasFTaylorSeriesUpToOn.contDiffOn", "start": [640, 1], "end": [645, 26], "traced_tactics": [{"tactic": "intro x hx m hm", "annotated_tactic": ["intro x hx m hm", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n : \u2115\u221e\np f' : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhf : HasFTaylorSeriesUpToOn n f f' s\n\u22a2 ContDiffOn \ud835\udd5c n f s", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np f' : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhf : HasFTaylorSeriesUpToOn n f f' s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p u"}, {"tactic": "use s", "annotated_tactic": ["use s", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np f' : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhf : HasFTaylorSeriesUpToOn n f f' s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p u", "state_after": "case h\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np f' : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhf : HasFTaylorSeriesUpToOn n f f' s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 s \u2208 \ud835\udcdd[insert x s] x \u2227 \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p s"}, {"tactic": "simp only [Set.insert_eq_of_mem hx, self_mem_nhdsWithin, true_and_iff]", "annotated_tactic": ["simp only [<a>Set.insert_eq_of_mem</a> hx, <a>self_mem_nhdsWithin</a>, <a>true_and_iff</a>]", [{"full_name": "Set.insert_eq_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1122, 9], "def_end_pos": [1122, 25]}, {"full_name": "self_mem_nhdsWithin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [148, 9], "def_end_pos": [148, 28]}, {"full_name": "true_and_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [140, 9], "def_end_pos": [140, 21]}]], "state_before": "case h\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np f' : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhf : HasFTaylorSeriesUpToOn n f f' s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 s \u2208 \ud835\udcdd[insert x s] x \u2227 \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p s", "state_after": "case h\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np f' : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhf : HasFTaylorSeriesUpToOn n f f' s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p s"}, {"tactic": "exact \u27e8f', hf.of_le hm\u27e9", "annotated_tactic": ["exact \u27e8f', hf.of_le hm\u27e9", []], "state_before": "case h\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np f' : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhf : HasFTaylorSeriesUpToOn n f f' s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Control/Monad/Cont.lean", "full_name": "ExceptT.goto_mkLabel", "start": [129, 1], "end": [131, 15], "traced_tactics": [{"tactic": "cases x", "annotated_tactic": ["cases x", []], "state_before": "m : Type u \u2192 Type v\ninst\u271d : Monad m\n\u03b1 \u03b2 \u03b5 : Type u\nx : Label (Except \u03b5 \u03b1) m \u03b2\ni : \u03b1\n\u22a2 goto (mkLabel x) i = mk (Except.ok <$> goto x (Except.ok i))", "state_after": "case mk\nm : Type u \u2192 Type v\ninst\u271d : Monad m\n\u03b1 \u03b2 \u03b5 : Type u\ni : \u03b1\napply\u271d : Except \u03b5 \u03b1 \u2192 m \u03b2\n\u22a2 goto (mkLabel { apply := apply\u271d }) i = mk (Except.ok <$> goto { apply := apply\u271d } (Except.ok i))"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk\nm : Type u \u2192 Type v\ninst\u271d : Monad m\n\u03b1 \u03b2 \u03b5 : Type u\ni : \u03b1\napply\u271d : Except \u03b5 \u03b1 \u2192 m \u03b2\n\u22a2 goto (mkLabel { apply := apply\u271d }) i = mk (Except.ok <$> goto { apply := apply\u271d } (Except.ok i))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.prod_top", "start": [1103, 1], "end": [1103, 73], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra R B\nS : Subalgebra R A\nS\u2081 : Subalgebra R B\n\u22a2 prod \u22a4 \u22a4 = \u22a4", "state_after": "case h\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra R B\nS : Subalgebra R A\nS\u2081 : Subalgebra R B\nx\u271d : A \u00d7 B\n\u22a2 x\u271d \u2208 prod \u22a4 \u22a4 \u2194 x\u271d \u2208 \u22a4"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra R B\nS : Subalgebra R A\nS\u2081 : Subalgebra R B\nx\u271d : A \u00d7 B\n\u22a2 x\u271d \u2208 prod \u22a4 \u22a4 \u2194 x\u271d \u2208 \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "full_name": "NonUnitalSubsemiring.sInf_toSubsemigroup", "start": [444, 1], "end": [446, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "full_name": "EMetric.hausdorffEdist_triangle", "start": [373, 1], "end": [391, 95], "traced_tactics": [{"tactic": "rw [hausdorffEdist_def]", "annotated_tactic": ["rw [<a>hausdorffEdist_def</a>]", [{"full_name": "EMetric.hausdorffEdist_def", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [1, 1], "def_end_pos": [1, 1]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 hausdorffEdist s u \u2264 hausdorffEdist s t + hausdorffEdist t u", "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 (\u2a06 x \u2208 s, infEdist x u) \u2294 \u2a06 y \u2208 u, infEdist y s \u2264 hausdorffEdist s t + hausdorffEdist t u"}, {"tactic": "simp only [sup_le_iff, iSup_le_iff]", "annotated_tactic": ["simp only [<a>sup_le_iff</a>, <a>iSup_le_iff</a>]", [{"full_name": "sup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [150, 9], "def_end_pos": [150, 19]}, {"full_name": "iSup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [853, 9], "def_end_pos": [853, 20]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 (\u2a06 x \u2208 s, infEdist x u) \u2294 \u2a06 y \u2208 u, infEdist y s \u2264 hausdorffEdist s t + hausdorffEdist t u", "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 i \u2208 s, infEdist i u \u2264 hausdorffEdist s t + hausdorffEdist t u) \u2227\n    \u2200 i \u2208 u, infEdist i s \u2264 hausdorffEdist s t + hausdorffEdist t u"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 i \u2208 s, infEdist i u \u2264 hausdorffEdist s t + hausdorffEdist t u) \u2227\n    \u2200 i \u2208 u, infEdist i s \u2264 hausdorffEdist s t + hausdorffEdist t u", "state_after": "case left\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 i \u2208 s, infEdist i u \u2264 hausdorffEdist s t + hausdorffEdist t u\n\ncase right\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 i \u2208 u, infEdist i s \u2264 hausdorffEdist s t + hausdorffEdist t u"}, {"tactic": "show \u2200 x \u2208 s, infEdist x u \u2264 hausdorffEdist s t + hausdorffEdist t u", "annotated_tactic": ["show \u2200 x \u2208 s, <a>infEdist</a> x u \u2264 <a>hausdorffEdist</a> s t + <a>hausdorffEdist</a> t u", [{"full_name": "EMetric.infEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [71, 5], "def_end_pos": [71, 13]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}]], "state_before": "case left\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 i \u2208 s, infEdist i u \u2264 hausdorffEdist s t + hausdorffEdist t u", "state_after": "case left\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 x \u2208 s, infEdist x u \u2264 hausdorffEdist s t + hausdorffEdist t u"}, {"tactic": "exact fun x xs =>\n  calc\n    infEdist x u \u2264 infEdist x t + hausdorffEdist t u :=\n      infEdist_le_infEdist_add_hausdorffEdist\n    _ \u2264 hausdorffEdist s t + hausdorffEdist t u :=\n      add_le_add_right (infEdist_le_hausdorffEdist_of_mem xs) _", "annotated_tactic": ["exact fun x xs =>\n      calc\n        <a>infEdist</a> x u \u2264 <a>infEdist</a> x t + <a>hausdorffEdist</a> t u :=\n          <a>infEdist_le_infEdist_add_hausdorffEdist</a>\n        _ \u2264 <a>hausdorffEdist</a> s t + <a>hausdorffEdist</a> t u :=\n          <a>add_le_add_right</a> (<a>infEdist_le_hausdorffEdist_of_mem</a> xs) _", [{"full_name": "EMetric.infEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [71, 5], "def_end_pos": [71, 13]}, {"full_name": "EMetric.infEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [71, 5], "def_end_pos": [71, 13]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "EMetric.infEdist_le_infEdist_add_hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [335, 9], "def_end_pos": [335, 48]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "add_le_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [66, 32], "def_end_pos": [66, 48]}, {"full_name": "EMetric.infEdist_le_hausdorffEdist_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [317, 9], "def_end_pos": [317, 42]}]], "state_before": "case left\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 x \u2208 s, infEdist x u \u2264 hausdorffEdist s t + hausdorffEdist t u", "state_after": "no goals"}, {"tactic": "show \u2200 x \u2208 u, infEdist x s \u2264 hausdorffEdist s t + hausdorffEdist t u", "annotated_tactic": ["show \u2200 x \u2208 u, <a>infEdist</a> x s \u2264 <a>hausdorffEdist</a> s t + <a>hausdorffEdist</a> t u", [{"full_name": "EMetric.infEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [71, 5], "def_end_pos": [71, 13]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}]], "state_before": "case right\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 i \u2208 u, infEdist i s \u2264 hausdorffEdist s t + hausdorffEdist t u", "state_after": "case right\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 x \u2208 u, infEdist x s \u2264 hausdorffEdist s t + hausdorffEdist t u"}, {"tactic": "exact fun x xu =>\n  calc\n    infEdist x s \u2264 infEdist x t + hausdorffEdist t s :=\n      infEdist_le_infEdist_add_hausdorffEdist\n    _ \u2264 hausdorffEdist u t + hausdorffEdist t s :=\n      add_le_add_right (infEdist_le_hausdorffEdist_of_mem xu) _\n    _ = hausdorffEdist s t + hausdorffEdist t u := by simp [hausdorffEdist_comm, add_comm]", "annotated_tactic": ["exact fun x xu =>\n      calc\n        <a>infEdist</a> x s \u2264 <a>infEdist</a> x t + <a>hausdorffEdist</a> t s :=\n          <a>infEdist_le_infEdist_add_hausdorffEdist</a>\n        _ \u2264 <a>hausdorffEdist</a> u t + <a>hausdorffEdist</a> t s :=\n          <a>add_le_add_right</a> (<a>infEdist_le_hausdorffEdist_of_mem</a> xu) _\n        _ = <a>hausdorffEdist</a> s t + <a>hausdorffEdist</a> t u := by simp [<a>hausdorffEdist_comm</a>, <a>add_comm</a>]", [{"full_name": "EMetric.infEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [71, 5], "def_end_pos": [71, 13]}, {"full_name": "EMetric.infEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [71, 5], "def_end_pos": [71, 13]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "EMetric.infEdist_le_infEdist_add_hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [335, 9], "def_end_pos": [335, 48]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "add_le_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [66, 32], "def_end_pos": [66, 48]}, {"full_name": "EMetric.infEdist_le_hausdorffEdist_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [317, 9], "def_end_pos": [317, 42]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "EMetric.hausdorffEdist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [275, 17], "def_end_pos": [275, 31]}, {"full_name": "EMetric.hausdorffEdist_comm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [292, 9], "def_end_pos": [292, 28]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "case right\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 x \u2208 u, infEdist x s \u2264 hausdorffEdist s t + hausdorffEdist t u", "state_after": "no goals"}, {"tactic": "simp [hausdorffEdist_comm, add_comm]", "annotated_tactic": ["simp [<a>hausdorffEdist_comm</a>, <a>add_comm</a>]", [{"full_name": "EMetric.hausdorffEdist_comm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [292, 9], "def_end_pos": [292, 28]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx\u271d y : \u03b1\ns t u : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\nx : \u03b1\nxu : x \u2208 u\n\u22a2 hausdorffEdist u t + hausdorffEdist t s = hausdorffEdist s t + hausdorffEdist t u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Pointwise.lean", "full_name": "Real.sSup_smul_of_nonpos", "start": [91, 1], "end": [100, 48], "traced_tactics": [{"tactic": "obtain rfl | hs := s.eq_empty_or_nonempty", "annotated_tactic": ["obtain rfl | hs := s.eq_empty_or_nonempty", []], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\ns : Set \u211d\n\u22a2 sSup (a \u2022 s) = a \u2022 sInf s", "state_after": "case inl\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\n\u22a2 sSup (a \u2022 \u2205) = a \u2022 sInf \u2205\n\ncase inr\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\ns : Set \u211d\nhs : Set.Nonempty s\n\u22a2 sSup (a \u2022 s) = a \u2022 sInf s"}, {"tactic": "obtain rfl | ha' := ha.eq_or_lt", "annotated_tactic": ["obtain rfl | ha' := ha.eq_or_lt", []], "state_before": "case inr\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\ns : Set \u211d\nhs : Set.Nonempty s\n\u22a2 sSup (a \u2022 s) = a \u2022 sInf s", "state_after": "case inr.inl\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\ns : Set \u211d\nhs : Set.Nonempty s\nha : 0 \u2264 0\n\u22a2 sSup (0 \u2022 s) = 0 \u2022 sInf s\n\ncase inr.inr\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\ns : Set \u211d\nhs : Set.Nonempty s\nha' : a < 0\n\u22a2 sSup (a \u2022 s) = a \u2022 sInf s"}, {"tactic": "by_cases h : BddBelow s", "annotated_tactic": ["by_cases h : <a>BddBelow</a> s", [{"full_name": "BddBelow", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [61, 5], "def_end_pos": [61, 13]}]], "state_before": "case inr.inr\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\ns : Set \u211d\nhs : Set.Nonempty s\nha' : a < 0\n\u22a2 sSup (a \u2022 s) = a \u2022 sInf s", "state_after": "case pos\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\ns : Set \u211d\nhs : Set.Nonempty s\nha' : a < 0\nh : BddBelow s\n\u22a2 sSup (a \u2022 s) = a \u2022 sInf s\n\ncase neg\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\ns : Set \u211d\nhs : Set.Nonempty s\nha' : a < 0\nh : \u00acBddBelow s\n\u22a2 sSup (a \u2022 s) = a \u2022 sInf s"}, {"tactic": "rw [smul_set_empty, Real.sSup_empty, Real.sInf_empty, smul_zero]", "annotated_tactic": ["rw [<a>smul_set_empty</a>, <a>Real.sSup_empty</a>, <a>Real.sInf_empty</a>, <a>smul_zero</a>]", [{"full_name": "Set.smul_set_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [327, 9], "def_end_pos": [327, 23]}, {"full_name": "Real.sSup_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Archimedean.lean", "def_pos": [177, 9], "def_end_pos": [177, 19]}, {"full_name": "Real.sInf_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Archimedean.lean", "def_pos": [208, 9], "def_end_pos": [208, 19]}, {"full_name": "smul_zero", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [760, 9], "def_end_pos": [760, 18]}]], "state_before": "case inl\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\n\u22a2 sSup (a \u2022 \u2205) = a \u2022 sInf \u2205", "state_after": "no goals"}, {"tactic": "rw [zero_smul_set hs, zero_smul]", "annotated_tactic": ["rw [<a>zero_smul_set</a> hs, <a>zero_smul</a>]", [{"full_name": "Set.zero_smul_set", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [834, 17], "def_end_pos": [834, 30]}, {"full_name": "zero_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}]], "state_before": "case inr.inl\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\ns : Set \u211d\nhs : Set.Nonempty s\nha : 0 \u2264 0\n\u22a2 sSup (0 \u2022 s) = 0 \u2022 sInf s", "state_after": "case inr.inl\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\ns : Set \u211d\nhs : Set.Nonempty s\nha : 0 \u2264 0\n\u22a2 sSup 0 = 0"}, {"tactic": "exact csSup_singleton 0", "annotated_tactic": ["exact <a>csSup_singleton</a> 0", [{"full_name": "csSup_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [667, 9], "def_end_pos": [667, 24]}]], "state_before": "case inr.inl\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\ns : Set \u211d\nhs : Set.Nonempty s\nha : 0 \u2264 0\n\u22a2 sSup 0 = 0", "state_after": "no goals"}, {"tactic": "exact ((OrderIso.smulRightDual \u211d ha').map_csInf' hs h).symm", "annotated_tactic": ["exact ((<a>OrderIso.smulRightDual</a> \u211d ha').<a>map_csInf'</a> hs h).<a>symm</a>", [{"full_name": "OrderIso.smulRightDual", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Module/Defs.lean", "def_pos": [1013, 5], "def_end_pos": [1013, 27]}, {"full_name": "OrderIso.map_csInf'", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [1518, 9], "def_end_pos": [1518, 19]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case pos\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\ns : Set \u211d\nhs : Set.Nonempty s\nha' : a < 0\nh : BddBelow s\n\u22a2 sSup (a \u2022 s) = a \u2022 sInf s", "state_after": "no goals"}, {"tactic": "rw [Real.sSup_of_not_bddAbove (mt (bddAbove_smul_iff_of_neg ha').1 h),\n    Real.sInf_of_not_bddBelow h, smul_zero]", "annotated_tactic": ["rw [<a>Real.sSup_of_not_bddAbove</a> (<a>mt</a> (<a>bddAbove_smul_iff_of_neg</a> ha').1 h),\n        <a>Real.sInf_of_not_bddBelow</a> h, <a>smul_zero</a>]", [{"full_name": "Real.sSup_of_not_bddAbove", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Archimedean.lean", "def_pos": [195, 9], "def_end_pos": [195, 29]}, {"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "bddAbove_smul_iff_of_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Module/Pointwise.lean", "def_pos": [105, 15], "def_end_pos": [105, 39]}, {"full_name": "Real.sInf_of_not_bddBelow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Archimedean.lean", "def_pos": [222, 9], "def_end_pos": [222, 29]}, {"full_name": "smul_zero", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [760, 9], "def_end_pos": [760, 18]}]], "state_before": "case neg\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Module \u03b1 \u211d\ninst\u271d : OrderedSMul \u03b1 \u211d\na : \u03b1\nha : a \u2264 0\ns : Set \u211d\nhs : Set.Nonempty s\nha' : a < 0\nh : \u00acBddBelow s\n\u22a2 sSup (a \u2022 s) = a \u2022 sInf s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/PEquiv.lean", "full_name": "PEquiv.ofSet_symm", "start": [249, 1], "end": [250, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Degrees.lean", "full_name": "MvPolynomial.degreeOf_eq_sup", "start": [247, 1], "end": [253, 7], "traced_tactics": [{"tactic": "classical\nrw [degreeOf_def, degrees, Multiset.count_finset_sup]\ncongr\next\nsimp", "annotated_tactic": ["classical\n  rw [<a>degreeOf_def</a>, <a>degrees</a>, <a>Multiset.count_finset_sup</a>]\n  congr\n  ext\n  simp", [{"full_name": "MvPolynomial.degreeOf_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [243, 9], "def_end_pos": [243, 21]}, {"full_name": "MvPolynomial.degrees", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [81, 5], "def_end_pos": [81, 12]}, {"full_name": "Multiset.count_finset_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1949, 9], "def_end_pos": [1949, 25]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nn : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 degreeOf n f = Finset.sup (support f) fun m => m n", "state_after": "no goals"}, {"tactic": "rw [degreeOf_def, degrees, Multiset.count_finset_sup]", "annotated_tactic": ["rw [<a>degreeOf_def</a>, <a>degrees</a>, <a>Multiset.count_finset_sup</a>]", [{"full_name": "MvPolynomial.degreeOf_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [243, 9], "def_end_pos": [243, 21]}, {"full_name": "MvPolynomial.degrees", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [81, 5], "def_end_pos": [81, 12]}, {"full_name": "Multiset.count_finset_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1949, 9], "def_end_pos": [1949, 25]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nn : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 degreeOf n f = Finset.sup (support f) fun m => m n", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nn : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 (Finset.sup (support f) fun a => Multiset.count n (toMultiset a)) = Finset.sup (support f) fun m => m n"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nn : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 (Finset.sup (support f) fun a => Multiset.count n (toMultiset a)) = Finset.sup (support f) fun m => m n", "state_after": "case e_f\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nn : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 (fun a => Multiset.count n (toMultiset a)) = fun m => m n"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "case e_f\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nn : \u03c3\nf : MvPolynomial \u03c3 R\n\u22a2 (fun a => Multiset.count n (toMultiset a)) = fun m => m n", "state_after": "case e_f.h\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nn : \u03c3\nf : MvPolynomial \u03c3 R\nx\u271d : \u03c3 \u2192\u2080 \u2115\n\u22a2 Multiset.count n (toMultiset x\u271d) = x\u271d n"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case e_f.h\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nn : \u03c3\nf : MvPolynomial \u03c3 R\nx\u271d : \u03c3 \u2192\u2080 \u2115\n\u22a2 Multiset.count n (toMultiset x\u271d) = x\u271d n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Perm.lean", "full_name": "List.Perm.pmap", "start": [165, 1], "end": [171, 88], "traced_tactics": [{"tactic": "induction p with\n| nil => simp\n| cons x _p IH => simp [IH, Perm.cons]\n| swap x y => simp [swap]\n| trans _p\u2081 p\u2082 IH\u2081 IH\u2082 => exact IH\u2081.trans (IH\u2082 (H\u2081 := fun a m => H\u2082 a (p\u2082.subset m)))", "annotated_tactic": ["induction p with\n  | <a>nil</a> => simp\n  | <a>cons</a> x _p IH => simp [IH, <a>Perm.cons</a>]\n  | <a>swap</a> x y => simp [<a>swap</a>]\n  | <a>trans</a> _p\u2081 p\u2082 IH\u2081 IH\u2082 => exact IH\u2081.trans (IH\u2082 (H\u2081 := fun a m => H\u2082 a (p\u2082.subset m)))", [{"full_name": "List.Perm.nil", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1560, 5], "def_end_pos": [1560, 8]}, {"full_name": "List.Perm.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1562, 5], "def_end_pos": [1562, 9]}, {"full_name": "List.Perm.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1562, 5], "def_end_pos": [1562, 9]}, {"full_name": "List.Perm.swap", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1564, 5], "def_end_pos": [1564, 9]}, {"full_name": "List.Perm.swap", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1564, 5], "def_end_pos": [1564, 9]}, {"full_name": "List.Perm.trans", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1566, 5], "def_end_pos": [1566, 10]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\np\u271d : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p\u271d a \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\np : l\u2081 ~ l\u2082\nH\u2081 : \u2200 (a : \u03b1), a \u2208 l\u2081 \u2192 p\u271d a\nH\u2082 : \u2200 (a : \u03b1), a \u2208 l\u2082 \u2192 p\u271d a\n\u22a2 List.pmap f l\u2081 H\u2081 ~ List.pmap f l\u2082 H\u2082", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nH\u2081 H\u2082 : \u2200 (a : \u03b1), a \u2208 [] \u2192 p a\n\u22a2 List.pmap f [] H\u2081 ~ List.pmap f [] H\u2082", "state_after": "no goals"}, {"tactic": "simp [IH, Perm.cons]", "annotated_tactic": ["simp [IH, <a>Perm.cons</a>]", [{"full_name": "List.Perm.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1562, 5], "def_end_pos": [1562, 9]}]], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\n_p : l\u2081\u271d ~ l\u2082\u271d\nIH : \u2200 {H\u2081 : \u2200 (a : \u03b1), a \u2208 l\u2081\u271d \u2192 p a} {H\u2082 : \u2200 (a : \u03b1), a \u2208 l\u2082\u271d \u2192 p a}, List.pmap f l\u2081\u271d H\u2081 ~ List.pmap f l\u2082\u271d H\u2082\nH\u2081 : \u2200 (a : \u03b1), a \u2208 x :: l\u2081\u271d \u2192 p a\nH\u2082 : \u2200 (a : \u03b1), a \u2208 x :: l\u2082\u271d \u2192 p a\n\u22a2 List.pmap f (x :: l\u2081\u271d) H\u2081 ~ List.pmap f (x :: l\u2082\u271d) H\u2082", "state_after": "no goals"}, {"tactic": "simp [swap]", "annotated_tactic": ["simp [<a>swap</a>]", [{"full_name": "List.Perm.swap", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1564, 5], "def_end_pos": [1564, 9]}]], "state_before": "case swap\n\u03b1 : Type u_1\n\u03b2 : Type u_2\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d : List \u03b1\nH\u2081 : \u2200 (a : \u03b1), a \u2208 y :: x :: l\u271d \u2192 p a\nH\u2082 : \u2200 (a : \u03b1), a \u2208 x :: y :: l\u271d \u2192 p a\n\u22a2 List.pmap f (y :: x :: l\u271d) H\u2081 ~ List.pmap f (x :: y :: l\u271d) H\u2082", "state_after": "no goals"}, {"tactic": "exact IH\u2081.trans (IH\u2082 (H\u2081 := fun a m => H\u2082 a (p\u2082.subset m)))", "annotated_tactic": ["exact IH\u2081.trans (IH\u2082 (H\u2081 := fun a m => H\u2082 a (p\u2082.subset m)))", []], "state_before": "case trans\n\u03b1 : Type u_1\n\u03b2 : Type u_2\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nl\u2081 l\u2082 l\u2081\u271d l\u2082\u271d l\u2083\u271d : List \u03b1\n_p\u2081 : l\u2081\u271d ~ l\u2082\u271d\np\u2082 : l\u2082\u271d ~ l\u2083\u271d\nIH\u2081 : \u2200 {H\u2081 : \u2200 (a : \u03b1), a \u2208 l\u2081\u271d \u2192 p a} {H\u2082 : \u2200 (a : \u03b1), a \u2208 l\u2082\u271d \u2192 p a}, List.pmap f l\u2081\u271d H\u2081 ~ List.pmap f l\u2082\u271d H\u2082\nIH\u2082 : \u2200 {H\u2081 : \u2200 (a : \u03b1), a \u2208 l\u2082\u271d \u2192 p a} {H\u2082 : \u2200 (a : \u03b1), a \u2208 l\u2083\u271d \u2192 p a}, List.pmap f l\u2082\u271d H\u2081 ~ List.pmap f l\u2083\u271d H\u2082\nH\u2081 : \u2200 (a : \u03b1), a \u2208 l\u2081\u271d \u2192 p a\nH\u2082 : \u2200 (a : \u03b1), a \u2208 l\u2083\u271d \u2192 p a\n\u22a2 List.pmap f l\u2081\u271d H\u2081 ~ List.pmap f l\u2083\u271d H\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.toAlgHom_toLinearMap", "start": [596, 1], "end": [597, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Nat/Gcd.lean", "full_name": "Nat.dvd_lcm_left", "start": [177, 1], "end": [178, 76], "traced_tactics": [{"tactic": "rw [\u2190 Nat.mul_div_assoc m (Nat.gcd_dvd_right m n)]", "annotated_tactic": ["rw [\u2190 <a>Nat.mul_div_assoc</a> m (<a>Nat.gcd_dvd_right</a> m n)]", [{"full_name": "Nat.mul_div_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [902, 19], "def_end_pos": [902, 32]}, {"full_name": "Nat.gcd_dvd_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [61, 9], "def_end_pos": [61, 22]}]], "state_before": "m n : Nat\n\u22a2 lcm m n = m * (n / gcd m n)", "state_after": "m n : Nat\n\u22a2 lcm m n = m * n / gcd m n"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "m n : Nat\n\u22a2 lcm m n = m * n / gcd m n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "mul_sub_mul_div_mul_neg_iff", "start": [1030, 1], "end": [1032, 58], "traced_tactics": [{"tactic": "rw [mul_comm b c, \u2190 div_sub_div _ _ hc hd, sub_lt_zero]", "annotated_tactic": ["rw [<a>mul_comm</a> b c, \u2190 <a>div_sub_div</a> _ _ hc hd, <a>sub_lt_zero</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "div_sub_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Field/Basic.lean", "def_pos": [228, 9], "def_end_pos": [228, 20]}, {"full_name": "sub_lt_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [906, 7], "def_end_pos": [906, 18]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nhc : c \u2260 0\nhd : d \u2260 0\n\u22a2 (a * d - b * c) / (c * d) < 0 \u2194 a / c < b / d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.swap_self", "start": [1624, 1], "end": [1625, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Quot.lean", "full_name": "Quotient.map_mk", "start": [255, 1], "end": [257, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "Set.EqOn.of_subset_closure", "start": [1616, 1], "end": [1623, 97], "traced_tactics": [{"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : T2Space Y\ns t : Set X\nf g : X \u2192 Y\nh : EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : s \u2286 t\nhts : t \u2286 closure s\n\u22a2 EqOn f g t", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : T2Space Y\ns t : Set X\nf g : X \u2192 Y\nh : EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : s \u2286 t\nhts : t \u2286 closure s\nx : X\nhx : x \u2208 t\n\u22a2 f x = g x"}, {"tactic": "have : (\ud835\udcdd[s] x).NeBot := mem_closure_iff_clusterPt.mp (hts hx)", "annotated_tactic": ["have : (\ud835\udcdd[s] x).<a>NeBot</a> := mem_closure_iff_clusterPt.mp (hts hx)", [{"full_name": "Filter.NeBot", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [509, 7], "def_end_pos": [509, 12]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : T2Space Y\ns t : Set X\nf g : X \u2192 Y\nh : EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : s \u2286 t\nhts : t \u2286 closure s\nx : X\nhx : x \u2208 t\n\u22a2 f x = g x", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : T2Space Y\ns t : Set X\nf g : X \u2192 Y\nh : EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : s \u2286 t\nhts : t \u2286 closure s\nx : X\nhx : x \u2208 t\nthis : NeBot (\ud835\udcdd[s] x)\n\u22a2 f x = g x"}, {"tactic": "exact\n  tendsto_nhds_unique_of_eventuallyEq ((hf x hx).mono_left <| nhdsWithin_mono _ hst)\n    ((hg x hx).mono_left <| nhdsWithin_mono _ hst) (h.eventuallyEq_of_mem self_mem_nhdsWithin)", "annotated_tactic": ["exact\n    <a>tendsto_nhds_unique_of_eventuallyEq</a> ((hf x hx).<a>mono_left</a> <| <a>nhdsWithin_mono</a> _ hst)\n      ((hg x hx).<a>mono_left</a> <| <a>nhdsWithin_mono</a> _ hst) (h.eventuallyEq_of_mem <a>self_mem_nhdsWithin</a>)", [{"full_name": "tendsto_nhds_unique_of_eventuallyEq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [1323, 9], "def_end_pos": [1323, 44]}, {"full_name": "Filter.Tendsto.mono_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3078, 9], "def_end_pos": [3078, 26]}, {"full_name": "nhdsWithin_mono", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [160, 9], "def_end_pos": [160, 24]}, {"full_name": "Filter.Tendsto.mono_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3078, 9], "def_end_pos": [3078, 26]}, {"full_name": "nhdsWithin_mono", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [160, 9], "def_end_pos": [160, 24]}, {"full_name": "self_mem_nhdsWithin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [148, 9], "def_end_pos": [148, 28]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\nZ : Type u_3\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : T2Space Y\ns t : Set X\nf g : X \u2192 Y\nh : EqOn f g s\nhf : ContinuousOn f t\nhg : ContinuousOn g t\nhst : s \u2286 t\nhts : t \u2286 closure s\nx : X\nhx : x \u2208 t\nthis : NeBot (\ud835\udcdd[s] x)\n\u22a2 f x = g x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/CompactOpen.lean", "full_name": "ContinuousMap.compactOpen_eq_iInf_induced", "start": [232, 1], "end": [240, 6], "traced_tactics": [{"tactic": "refine le_antisymm (le_iInf\u2082 fun s _ \u21a6 compactOpen_le_induced s) ?_", "annotated_tactic": ["refine <a>le_antisymm</a> (<a>le_iInf\u2082</a> fun s _ \u21a6 <a>compactOpen_le_induced</a> s) ?_", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "le_iInf\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [776, 9], "def_end_pos": [776, 17]}, {"full_name": "ContinuousMap.compactOpen_le_induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/CompactOpen.lean", "def_pos": [222, 9], "def_end_pos": [222, 31]}]], "state_before": "\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nK : Set X\nU : Set Y\n\u22a2 compactOpen = \u2a05 K, \u2a05 (_ : IsCompact K), induced (restrict K) compactOpen", "state_after": "\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nK : Set X\nU : Set Y\n\u22a2 \u2a05 K, \u2a05 (_ : IsCompact K), induced (restrict K) compactOpen \u2264 compactOpen"}, {"tactic": "refine le_generateFrom <| forall_image2_iff.2 fun K (hK : IsCompact K) U hU \u21a6 ?_", "annotated_tactic": ["refine <a>le_generateFrom</a> <| <a>forall_image2_iff</a>.2 fun K (hK : <a>IsCompact</a> K) U hU \u21a6 ?_", [{"full_name": "le_generateFrom", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [558, 9], "def_end_pos": [558, 24]}, {"full_name": "Set.forall_image2_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [58, 9], "def_end_pos": [58, 26]}, {"full_name": "IsCompact", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [273, 5], "def_end_pos": [273, 14]}]], "state_before": "\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nK : Set X\nU : Set Y\n\u22a2 \u2a05 K, \u2a05 (_ : IsCompact K), induced (restrict K) compactOpen \u2264 compactOpen", "state_after": "\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nK\u271d : Set X\nU\u271d : Set Y\nK : Set X\nhK : IsCompact K\nU : Set Y\nhU : U \u2208 {U | IsOpen U}\n\u22a2 IsOpen {f | MapsTo (\u21d1f) K U}"}, {"tactic": "convert isOpen_induced (isOpen_setOf_mapsTo (isCompact_iff_isCompact_univ.1 hK) hU)", "annotated_tactic": ["convert <a>isOpen_induced</a> (<a>isOpen_setOf_mapsTo</a> (<a>isCompact_iff_isCompact_univ</a>.1 hK) hU)", [{"full_name": "isOpen_induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [854, 9], "def_end_pos": [854, 23]}, {"full_name": "ContinuousMap.isOpen_setOf_mapsTo", "def_path": ".lake/packages/mathlib/Mathlib/Topology/CompactOpen.lean", "def_pos": [63, 9], "def_end_pos": [63, 28]}, {"full_name": "isCompact_iff_isCompact_univ", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/Compact.lean", "def_pos": [953, 9], "def_end_pos": [953, 37]}]], "state_before": "\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nK\u271d : Set X\nU\u271d : Set Y\nK : Set X\nhK : IsCompact K\nU : Set Y\nhU : U \u2208 {U | IsOpen U}\n\u22a2 IsOpen {f | MapsTo (\u21d1f) K U}", "state_after": "case h.e'_3\n\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nK\u271d : Set X\nU\u271d : Set Y\nK : Set X\nhK : IsCompact K\nU : Set Y\nhU : U \u2208 {U | IsOpen U}\n\u22a2 {f | MapsTo (\u21d1f) K U} = restrict K \u207b\u00b9' {f | MapsTo (\u21d1f) univ U}"}, {"tactic": "simp only [mapsTo_univ_iff, Subtype.forall]", "annotated_tactic": ["simp only [<a>mapsTo_univ_iff</a>, <a>Subtype.forall</a>]", [{"full_name": "Set.mapsTo_univ_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [534, 7], "def_end_pos": [534, 22]}, {"full_name": "Subtype.forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [43, 19], "def_end_pos": [43, 27]}]], "state_before": "case h.e'_3\n\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nK\u271d : Set X\nU\u271d : Set Y\nK : Set X\nhK : IsCompact K\nU : Set Y\nhU : U \u2208 {U | IsOpen U}\n\u22a2 {f | MapsTo (\u21d1f) K U} = restrict K \u207b\u00b9' {f | MapsTo (\u21d1f) univ U}", "state_after": "case h.e'_3\n\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nK\u271d : Set X\nU\u271d : Set Y\nK : Set X\nhK : IsCompact K\nU : Set Y\nhU : U \u2208 {U | IsOpen U}\n\u22a2 {f | MapsTo (\u21d1f) K U} = restrict K \u207b\u00b9' {f | \u2200 (a : X) (b : a \u2208 K), f { val := a, property := b } \u2208 U}"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.e'_3\n\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nK\u271d : Set X\nU\u271d : Set Y\nK : Set X\nhK : IsCompact K\nU : Set Y\nhU : U \u2208 {U | IsOpen U}\n\u22a2 {f | MapsTo (\u21d1f) K U} = restrict K \u207b\u00b9' {f | \u2200 (a : X) (b : a \u2208 K), f { val := a, property := b } \u2208 U}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.zero_div_subset", "start": [1283, 1], "end": [1283, 81], "traced_tactics": [{"tactic": "simp [subset_def, mem_div]", "annotated_tactic": ["simp [<a>subset_def</a>, <a>mem_div</a>]", [{"full_name": "Set.subset_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [326, 9], "def_end_pos": [326, 19]}, {"full_name": "Set.mem_div", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [607, 9], "def_end_pos": [607, 16]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : GroupWithZero \u03b1\ns\u271d t s : Set \u03b1\n\u22a2 0 / s \u2286 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "ofDual_hnot", "start": [924, 1], "end": [925, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Maps.lean", "full_name": "IsOpenMap.of_sections", "start": [363, 1], "end": [370, 37], "traced_tactics": [{"tactic": "rw [map_map, hgf.comp_eq_id, map_id]", "annotated_tactic": ["rw [<a>map_map</a>, hgf.comp_eq_id, <a>map_id</a>]", [{"full_name": "Filter.map_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1992, 9], "def_end_pos": [1992, 16]}, {"full_name": "Filter.map_id", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1977, 9], "def_end_pos": [1977, 15]}]], "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng\u271d : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nh : \u2200 (x : X), \u2203 g, ContinuousAt g (f x) \u2227 g (f x) = x \u2227 Function.RightInverse g f\nx : X\ng : Y \u2192 X\nhgc : ContinuousAt g (f x)\nhgx : g (f x) = x\nhgf : Function.RightInverse g f\n\u22a2 \ud835\udcdd (f x) = map f (map g (\ud835\udcdd (f x)))", "state_after": "no goals"}, {"tactic": "rw [hgx]", "annotated_tactic": ["rw [hgx]", []], "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng\u271d : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nh : \u2200 (x : X), \u2203 g, ContinuousAt g (f x) \u2227 g (f x) = x \u2227 Function.RightInverse g f\nx : X\ng : Y \u2192 X\nhgc : ContinuousAt g (f x)\nhgx : g (f x) = x\nhgf : Function.RightInverse g f\n\u22a2 map f (\ud835\udcdd (g (f x))) = map f (\ud835\udcdd x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometryEquiv.coe_injective", "start": [579, 1], "end": [580, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "AffineSubspace.mem_comap", "start": [1708, 1], "end": [1709, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.graphOn_singleton", "start": [764, 1], "end": [766, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.tendsto_coe_sub", "start": [682, 11], "end": [684, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Theta.lean", "full_name": "Asymptotics.IsTheta.isLittleO_congr_right", "start": [179, 1], "end": [180, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image2_left_identity", "start": [360, 1], "end": [364, 68], "traced_tactics": [{"tactic": "rw [image2_singleton_left, show f a = id from funext h, image_id]", "annotated_tactic": ["rw [<a>image2_singleton_left</a>, show f a = <a>id</a> from <a>funext</a> h, <a>image_id</a>]", [{"full_name": "Set.image2_singleton_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [168, 9], "def_end_pos": [168, 30]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "funext", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1805, 9], "def_end_pos": [1805, 15]}, {"full_name": "Set.image_id", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [376, 9], "def_end_pos": [376, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt\u271d t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na\u271d a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\na : \u03b1\nh : \u2200 (b : \u03b2), f a b = b\nt : Set \u03b2\n\u22a2 image2 f {a} t = t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.comp_whiskerRight", "start": [252, 1], "end": [254, 53], "traced_tactics": [{"tactic": "simp only [\u2190 tensorHom_id, \u2190 tensor_comp, id_comp]", "annotated_tactic": ["simp only [\u2190 <a>tensorHom_id</a>, \u2190 <a>tensor_comp</a>, <a>id_comp</a>]", [{"full_name": "CategoryTheory.MonoidalCategory.tensorHom_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Monoidal/Category.lean", "def_pos": [229, 9], "def_end_pos": [229, 21]}, {"full_name": "CategoryTheory.MonoidalCategory.tensor_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Monoidal/Category.lean", "def_pos": [167, 3], "def_end_pos": [167, 14]}, {"full_name": "CategoryTheory.Category.id_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [164, 3], "def_end_pos": [164, 10]}]], "state_before": "C : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nW X Y : C\nf : W \u27f6 X\ng : X \u27f6 Y\nZ : C\n\u22a2 (f \u226b g) \u25b7 Z = f \u25b7 Z \u226b g \u25b7 Z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "full_name": "Polynomial.natTrailingDegree_eq_of_trailingDegree_eq_some", "start": [133, 1], "end": [137, 91], "traced_tactics": [{"tactic": "rw [hp0] at h", "annotated_tactic": ["rw [hp0] at h", []], "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nn : \u2115\nh : trailingDegree p = \u2191n\nhp0 : p = 0\n\u22a2 False", "state_after": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nn : \u2115\nh : trailingDegree 0 = \u2191n\nhp0 : p = 0\n\u22a2 False"}, {"tactic": "exact Option.noConfusion h", "annotated_tactic": ["exact <a>Option.noConfusion</a> h", [{"full_name": "Option.noConfusion", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2222, 11], "def_end_pos": [2222, 17]}]], "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nn : \u2115\nh : trailingDegree 0 = \u2191n\nhp0 : p = 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rwa [\u2190 trailingDegree_eq_natTrailingDegree hp0]", "annotated_tactic": ["rwa [\u2190 <a>trailingDegree_eq_natTrailingDegree</a> hp0]", [{"full_name": "Polynomial.trailingDegree_eq_natTrailingDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "def_pos": [102, 9], "def_end_pos": [102, 44]}]], "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nn : \u2115\nh : trailingDegree p = \u2191n\nhp0 : p \u2260 0\n\u22a2 \u2191(natTrailingDegree p) = \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean", "full_name": "Real.hasStrictDerivAt_exp", "start": [193, 1], "end": [194, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Nodup.lean", "full_name": "List.nodup_cons", "start": [39, 1], "end": [40, 50], "traced_tactics": [{"tactic": "simp only [Nodup, pairwise_cons, forall_mem_ne]", "annotated_tactic": ["simp only [<a>Nodup</a>, <a>pairwise_cons</a>, <a>forall_mem_ne</a>]", [{"full_name": "List.Nodup", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1094, 5], "def_end_pos": [1094, 10]}, {"full_name": "List.pairwise_cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1041, 17], "def_end_pos": [1041, 30]}, {"full_name": "List.forall_mem_ne", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Nodup.lean", "def_pos": [29, 9], "def_end_pos": [29, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d b a : \u03b1\nl : List \u03b1\n\u22a2 Nodup (a :: l) \u2194 a \u2209 l \u2227 Nodup l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean", "full_name": "AddChar.PrimitiveAddChar.prim", "start": [104, 1], "end": [105, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/Over.lean", "full_name": "CategoryTheory.Over.map_map_left", "start": [182, 1], "end": [183, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.map_mapRange_eq_iff", "start": [1413, 1], "end": [1419, 6], "traced_tactics": [{"tactic": "rw [MvPolynomial.ext_iff]", "annotated_tactic": ["rw [<a>MvPolynomial.ext_iff</a>]", [{"full_name": "MvPolynomial.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [614, 9], "def_end_pos": [614, 16]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\n\u22a2 (map f) (mapRange g hg \u03c6) = \u03c6 \u2194 \u2200 (d : \u03c3 \u2192\u2080 \u2115), f (g (coeff d \u03c6)) = coeff d \u03c6", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\n\u22a2 (\u2200 (m : \u03c3 \u2192\u2080 \u2115), coeff m ((map f) (mapRange g hg \u03c6)) = coeff m \u03c6) \u2194 \u2200 (d : \u03c3 \u2192\u2080 \u2115), f (g (coeff d \u03c6)) = coeff d \u03c6"}, {"tactic": "apply forall_congr'", "annotated_tactic": ["apply <a>forall_congr'</a>", [{"full_name": "forall_congr'", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\n\u22a2 (\u2200 (m : \u03c3 \u2192\u2080 \u2115), coeff m ((map f) (mapRange g hg \u03c6)) = coeff m \u03c6) \u2194 \u2200 (d : \u03c3 \u2192\u2080 \u2115), f (g (coeff d \u03c6)) = coeff d \u03c6", "state_after": "case h\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\n\u22a2 \u2200 (a : \u03c3 \u2192\u2080 \u2115), coeff a ((map f) (mapRange g hg \u03c6)) = coeff a \u03c6 \u2194 f (g (coeff a \u03c6)) = coeff a \u03c6"}, {"tactic": "intro m", "annotated_tactic": ["intro m", []], "state_before": "case h\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\n\u22a2 \u2200 (a : \u03c3 \u2192\u2080 \u2115), coeff a ((map f) (mapRange g hg \u03c6)) = coeff a \u03c6 \u2194 f (g (coeff a \u03c6)) = coeff a \u03c6", "state_after": "case h\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 coeff m ((map f) (mapRange g hg \u03c6)) = coeff m \u03c6 \u2194 f (g (coeff m \u03c6)) = coeff m \u03c6"}, {"tactic": "rw [coeff_map]", "annotated_tactic": ["rw [<a>coeff_map</a>]", [{"full_name": "MvPolynomial.coeff_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1304, 9], "def_end_pos": [1304, 18]}]], "state_before": "case h\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 coeff m ((map f) (mapRange g hg \u03c6)) = coeff m \u03c6 \u2194 f (g (coeff m \u03c6)) = coeff m \u03c6", "state_after": "case h\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 f (coeff m (mapRange g hg \u03c6)) = coeff m \u03c6 \u2194 f (g (coeff m \u03c6)) = coeff m \u03c6"}, {"tactic": "apply eq_iff_eq_cancel_right.mpr", "annotated_tactic": ["apply eq_iff_eq_cancel_right.mpr", []], "state_before": "case h\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 f (coeff m (mapRange g hg \u03c6)) = coeff m \u03c6 \u2194 f (g (coeff m \u03c6)) = coeff m \u03c6", "state_after": "case h.a\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 f (coeff m (mapRange g hg \u03c6)) = f (g (coeff m \u03c6))"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.a\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\ng : S\u2081 \u2192 R\nhg : g 0 = 0\n\u03c6 : MvPolynomial \u03c3 S\u2081\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 f (coeff m (mapRange g hg \u03c6)) = f (g (coeff m \u03c6))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Exponent.lean", "full_name": "Monoid.exponent_min'", "start": [175, 1], "end": [179, 24], "traced_tactics": [{"tactic": "rw [exponent, dif_pos]", "annotated_tactic": ["rw [<a>exponent</a>, <a>dif_pos</a>]", [{"full_name": "Monoid.exponent", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Exponent.lean", "def_pos": [76, 19], "def_end_pos": [76, 27]}, {"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}]], "state_before": "G : Type u\ninst\u271d : Monoid G\nn : \u2115\nhpos : 0 < n\nhG : \u2200 (g : G), g ^ n = 1\n\u22a2 exponent G \u2264 n", "state_after": "G : Type u\ninst\u271d : Monoid G\nn : \u2115\nhpos : 0 < n\nhG : \u2200 (g : G), g ^ n = 1\n\u22a2 Nat.find ?hc \u2264 n\n\ncase hc\nG : Type u\ninst\u271d : Monoid G\nn : \u2115\nhpos : 0 < n\nhG : \u2200 (g : G), g ^ n = 1\n\u22a2 ExponentExists G"}, {"tactic": "apply Nat.find_min'", "annotated_tactic": ["apply <a>Nat.find_min'</a>", [{"full_name": "Nat.find_min'", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Lemmas.lean", "def_pos": [726, 19], "def_end_pos": [726, 28]}]], "state_before": "G : Type u\ninst\u271d : Monoid G\nn : \u2115\nhpos : 0 < n\nhG : \u2200 (g : G), g ^ n = 1\n\u22a2 Nat.find ?hc \u2264 n", "state_after": "case h\nG : Type u\ninst\u271d : Monoid G\nn : \u2115\nhpos : 0 < n\nhG : \u2200 (g : G), g ^ n = 1\n\u22a2 0 < n \u2227 \u2200 (g : G), g ^ n = 1"}, {"tactic": "exact \u27e8hpos, hG\u27e9", "annotated_tactic": ["exact \u27e8hpos, hG\u27e9", []], "state_before": "case h\nG : Type u\ninst\u271d : Monoid G\nn : \u2115\nhpos : 0 < n\nhG : \u2200 (g : G), g ^ n = 1\n\u22a2 0 < n \u2227 \u2200 (g : G), g ^ n = 1", "state_after": "no goals"}, {"tactic": "exact \u27e8n, hpos, hG\u27e9", "annotated_tactic": ["exact \u27e8n, hpos, hG\u27e9", []], "state_before": "case hc\nG : Type u\ninst\u271d : Monoid G\nn : \u2115\nhpos : 0 < n\nhG : \u2200 (g : G), g ^ n = 1\n\u22a2 ExponentExists G", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Sign.lean", "full_name": "Equiv.Perm.sign_eq_sign_of_equiv", "start": [500, 1], "end": [503, 33], "traced_tactics": [{"tactic": "have hg : g = (e.symm.trans f).trans e := Equiv.ext <| by simp [h]", "annotated_tactic": ["have hg : g = (e.symm.trans f).<a>trans</a> e := <a>Equiv.ext</a> <| by simp [h]", [{"full_name": "Equiv.trans", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [184, 15], "def_end_pos": [184, 20]}, {"full_name": "Equiv.ext", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [130, 16], "def_end_pos": [130, 19]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\nf : Perm \u03b1\ng : Perm \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (x : \u03b1), e (f x) = g (e x)\n\u22a2 sign f = sign g", "state_after": "\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\nf : Perm \u03b1\ng : Perm \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (x : \u03b1), e (f x) = g (e x)\nhg : g = (e.symm.trans f).trans e\n\u22a2 sign f = sign g"}, {"tactic": "rw [hg, sign_symm_trans_trans]", "annotated_tactic": ["rw [hg, <a>sign_symm_trans_trans</a>]", [{"full_name": "Equiv.Perm.sign_symm_trans_trans", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [429, 9], "def_end_pos": [429, 30]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\nf : Perm \u03b1\ng : Perm \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (x : \u03b1), e (f x) = g (e x)\nhg : g = (e.symm.trans f).trans e\n\u22a2 sign f = sign g", "state_after": "no goals"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\nf : Perm \u03b1\ng : Perm \u03b2\ne : \u03b1 \u2243 \u03b2\nh : \u2200 (x : \u03b1), e (f x) = g (e x)\n\u22a2 \u2200 (x : \u03b2), g x = ((e.symm.trans f).trans e) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Fin.univ_succ", "start": [876, 1], "end": [879, 25], "traced_tactics": [{"tactic": "simp [map_eq_image]", "annotated_tactic": ["simp [<a>map_eq_image</a>]", [{"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\n\u22a2 0 \u2209 map { toFun := succ, inj' := \u22ef } univ", "state_after": "no goals"}, {"tactic": "simp [map_eq_image]", "annotated_tactic": ["simp [<a>map_eq_image</a>]", [{"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\n\u22a2 univ = cons 0 (map { toFun := succ, inj' := \u22ef } univ) \u22ef", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Function.Involutive.toPerm_symm", "start": [1786, 1], "end": [1787, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Control/Basic.lean", "full_name": "joinM_pure", "start": [159, 1], "end": [160, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/ProjIcc.lean", "full_name": "Set.projIic_coe", "start": [128, 1], "end": [128, 86], "traced_tactics": [{"tactic": "cases x", "annotated_tactic": ["cases x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nx\u271d : \u03b1\nx : \u2191(Iic b)\n\u22a2 projIic b \u2191x = x", "state_after": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nx val\u271d : \u03b1\nproperty\u271d : val\u271d \u2208 Iic b\n\u22a2 projIic b \u2191{ val := val\u271d, property := property\u271d } = { val := val\u271d, property := property\u271d }"}, {"tactic": "apply projIic_of_mem", "annotated_tactic": ["apply <a>projIic_of_mem</a>", [{"full_name": "Set.projIic_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/ProjIcc.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}]], "state_before": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nx val\u271d : \u03b1\nproperty\u271d : val\u271d \u2208 Iic b\n\u22a2 projIic b \u2191{ val := val\u271d, property := property\u271d } = { val := val\u271d, property := property\u271d }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Membership.lean", "full_name": "MulMemClass.mul_mem_add_closure", "start": [736, 1], "end": [745, 91], "traced_tactics": [{"tactic": "revert a", "annotated_tactic": ["revert a", []], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\na b : R\nha : a \u2208 AddSubmonoid.closure \u2191S\nhb : b \u2208 AddSubmonoid.closure \u2191S\n\u22a2 a * b \u2208 AddSubmonoid.closure \u2191S", "state_after": "M : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\nb : R\nhb : b \u2208 AddSubmonoid.closure \u2191S\n\u22a2 \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * b \u2208 AddSubmonoid.closure \u2191S"}, {"tactic": "refine' @AddSubmonoid.closure_induction _ _ _\n  (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S)\n    _ hb _ _ _ <;> clear hb b", "annotated_tactic": ["refine' @<a>AddSubmonoid.closure_induction</a> _ _ _\n    (fun z => \u2200 {a : R}, a \u2208 <a>AddSubmonoid.closure</a> \u2191S \u2192 a * z \u2208 <a>AddSubmonoid.closure</a> \u2191S)\n      _ hb _ _ _ <;> clear hb b", [{"full_name": "AddSubmonoid.closure_induction", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [440, 3], "def_end_pos": [440, 14]}, {"full_name": "AddSubmonoid.closure", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [383, 3], "def_end_pos": [383, 14]}, {"full_name": "AddSubmonoid.closure", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [383, 3], "def_end_pos": [383, 14]}]], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\nb : R\nhb : b \u2208 AddSubmonoid.closure \u2191S\n\u22a2 \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * b \u2208 AddSubmonoid.closure \u2191S", "state_after": "case refine'_1\nM : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\n\u22a2 \u2200 x \u2208 \u2191S, (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) x\n\ncase refine'_2\nM : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\n\u22a2 (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) 0\n\ncase refine'_3\nM : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\n\u22a2 \u2200 (x y : R),\n    (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) x \u2192\n      (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) y \u2192\n        (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) (x + y)"}, {"tactic": "exact fun r hr b hb => MulMemClass.mul_right_mem_add_closure hb hr", "annotated_tactic": ["exact fun r hr b hb => <a>MulMemClass.mul_right_mem_add_closure</a> hb hr", [{"full_name": "MulMemClass.mul_right_mem_add_closure", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [723, 9], "def_end_pos": [723, 34]}]], "state_before": "case refine'_1\nM : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\n\u22a2 \u2200 x \u2208 \u2191S, (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) x", "state_after": "no goals"}, {"tactic": "exact fun _ => by simp only [mul_zero, (AddSubmonoid.closure (S : Set R)).zero_mem]", "annotated_tactic": ["exact fun _ => by simp only [<a>mul_zero</a>, (<a>AddSubmonoid.closure</a> (S : <a>Set</a> R)).<a>zero_mem</a>]", [{"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "AddSubmonoid.closure", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [383, 3], "def_end_pos": [383, 14]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "AddSubmonoid.zero_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [225, 3], "def_end_pos": [225, 14]}]], "state_before": "case refine'_2\nM : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\n\u22a2 (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) 0", "state_after": "no goals"}, {"tactic": "simp only [mul_zero, (AddSubmonoid.closure (S : Set R)).zero_mem]", "annotated_tactic": ["simp only [<a>mul_zero</a>, (<a>AddSubmonoid.closure</a> (S : <a>Set</a> R)).<a>zero_mem</a>]", [{"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "AddSubmonoid.closure", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [383, 3], "def_end_pos": [383, 14]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "AddSubmonoid.zero_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [225, 3], "def_end_pos": [225, 14]}]], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\na\u271d : R\nx\u271d : a\u271d \u2208 AddSubmonoid.closure \u2191S\n\u22a2 a\u271d * 0 \u2208 AddSubmonoid.closure \u2191S", "state_after": "no goals"}, {"tactic": "simp_rw [mul_add]", "annotated_tactic": ["simp_rw [<a>mul_add</a>]", [{"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}]], "state_before": "case refine'_3\nM : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\n\u22a2 \u2200 (x y : R),\n    (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) x \u2192\n      (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) y \u2192\n        (fun z => \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * z \u2208 AddSubmonoid.closure \u2191S) (x + y)", "state_after": "case refine'_3\nM : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\n\u22a2 \u2200 (x y : R),\n    (\u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * x \u2208 AddSubmonoid.closure \u2191S) \u2192\n      (\u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * y \u2208 AddSubmonoid.closure \u2191S) \u2192\n        \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * x + a * y \u2208 AddSubmonoid.closure \u2191S"}, {"tactic": "exact fun r s hr hs b hb => (AddSubmonoid.closure (S : Set R)).add_mem (hr hb) (hs hb)", "annotated_tactic": ["exact fun r s hr hs b hb => (<a>AddSubmonoid.closure</a> (S : <a>Set</a> R)).<a>add_mem</a> (hr hb) (hs hb)", [{"full_name": "AddSubmonoid.closure", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [383, 3], "def_end_pos": [383, 14]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "AddSubmonoid.add_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [232, 3], "def_end_pos": [232, 14]}]], "state_before": "case refine'_3\nM : Type u_1\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9 : SetLike M R\ninst\u271d : MulMemClass M R\nS : M\n\u22a2 \u2200 (x y : R),\n    (\u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * x \u2208 AddSubmonoid.closure \u2191S) \u2192\n      (\u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * y \u2208 AddSubmonoid.closure \u2191S) \u2192\n        \u2200 {a : R}, a \u2208 AddSubmonoid.closure \u2191S \u2192 a * x + a * y \u2208 AddSubmonoid.closure \u2191S", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "Subsingleton.isWellOrder", "start": [480, 1], "end": [485, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units/Hom.lean", "full_name": "Units.coe_map_inv", "start": [76, 1], "end": [76, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/PathConnected.lean", "full_name": "Path.coe_mk", "start": [146, 1], "end": [147, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.left_inv'", "start": [179, 1], "end": [179, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Defs.lean", "full_name": "Finsupp.single_eq_of_ne", "start": [326, 1], "end": [327, 42], "traced_tactics": [{"tactic": "classical exact Pi.single_eq_of_ne' h _", "annotated_tactic": ["classical exact <a>Pi.single_eq_of_ne'</a> h _", [{"full_name": "Pi.single_eq_of_ne'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [376, 3], "def_end_pos": [376, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d : Zero M\na a' : \u03b1\nb : M\nh : a \u2260 a'\n\u22a2 (single a b) a' = 0", "state_after": "no goals"}, {"tactic": "exact Pi.single_eq_of_ne' h _", "annotated_tactic": ["exact <a>Pi.single_eq_of_ne'</a> h _", [{"full_name": "Pi.single_eq_of_ne'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [376, 3], "def_end_pos": [376, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d : Zero M\na a' : \u03b1\nb : M\nh : a \u2260 a'\n\u22a2 (single a b) a' = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "full_name": "Cardinal.lift_lt_univ'", "start": [1506, 1], "end": [1509, 13], "traced_tactics": [{"tactic": "have := lift_lt.{_, max (u+1) v}.2 (lift_lt_univ c)", "annotated_tactic": ["have := <a>lift_lt</a>.{_, max (u+1) v}.2 (<a>lift_lt_univ</a> c)", [{"full_name": "Cardinal.lift_lt", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [363, 9], "def_end_pos": [363, 16]}, {"full_name": "Cardinal.lift_lt_univ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1501, 9], "def_end_pos": [1501, 21]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nc : Cardinal.{u}\n\u22a2 lift.{max (u + 1) v, u} c < univ.{u, v}", "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nc : Cardinal.{u}\nthis : lift.{max (u + 1) v, u + 1} (lift.{u + 1, u} c) < lift.{max (u + 1) v, u + 1} univ.{u, u + 1}\n\u22a2 lift.{max (u + 1) v, u} c < univ.{u, v}"}, {"tactic": "rw [lift_lift, lift_univ, univ_umax.{u,v}] at this", "annotated_tactic": ["rw [<a>lift_lift</a>, <a>lift_univ</a>, <a>univ_umax</a>.{u,v}] at this", [{"full_name": "Cardinal.lift_lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [236, 9], "def_end_pos": [236, 18]}, {"full_name": "Cardinal.lift_univ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1493, 9], "def_end_pos": [1493, 18]}, {"full_name": "Cardinal.univ_umax", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1497, 9], "def_end_pos": [1497, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nc : Cardinal.{u}\nthis : lift.{max (u + 1) v, u + 1} (lift.{u + 1, u} c) < lift.{max (u + 1) v, u + 1} univ.{u, u + 1}\n\u22a2 lift.{max (u + 1) v, u} c < univ.{u, v}", "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nc : Cardinal.{u}\nthis : lift.{max (u + 1) v, u} c < univ.{u, v}\n\u22a2 lift.{max (u + 1) v, u} c < univ.{u, v}"}, {"tactic": "exact this", "annotated_tactic": ["exact this", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nc : Cardinal.{u}\nthis : lift.{max (u + 1) v, u} c < univ.{u, v}\n\u22a2 lift.{max (u + 1) v, u} c < univ.{u, v}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Dilation.lean", "full_name": "Dilation.mapsTo_closedBall", "start": [540, 1], "end": [542, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Ordered.lean", "full_name": "left_le_lineMap_iff_le", "start": [133, 1], "end": [134, 74], "traced_tactics": [{"tactic": "rw [lineMap_apply_zero]", "annotated_tactic": ["rw [<a>lineMap_apply_zero</a>]", [{"full_name": "AffineMap.lineMap_apply_zero", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "def_pos": [546, 9], "def_end_pos": [546, 27]}]], "state_before": "k : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : LinearOrderedField k\ninst\u271d\u00b2 : OrderedAddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : OrderedSMul k E\na b : E\nr r' : k\nh : 0 < r\n\u22a2 a \u2264 (lineMap a b) r \u2194 (lineMap a b) 0 \u2264 (lineMap a b) r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Field/Basic.lean", "full_name": "norm_mul", "start": [672, 1], "end": [673, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.zero_mul_subset", "start": [1147, 1], "end": [1147, 81], "traced_tactics": [{"tactic": "simp [subset_def, mem_mul]", "annotated_tactic": ["simp [<a>subset_def</a>, <a>mem_mul</a>]", [{"full_name": "Set.subset_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [326, 9], "def_end_pos": [326, 19]}, {"full_name": "Set.mem_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [341, 9], "def_end_pos": [341, 16]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : MulZeroClass \u03b1\ns\u271d t s : Set \u03b1\n\u22a2 0 * s \u2286 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Between.lean", "full_name": "mem_const_vadd_affineSegment", "start": [117, 1], "end": [119, 79], "traced_tactics": [{"tactic": "rw [\u2190 affineSegment_const_vadd_image, (AddAction.injective v).mem_set_image]", "annotated_tactic": ["rw [\u2190 <a>affineSegment_const_vadd_image</a>, (<a>AddAction.injective</a> v).<a>mem_set_image</a>]", [{"full_name": "affineSegment_const_vadd_image", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Convex/Between.lean", "def_pos": [91, 9], "def_end_pos": [91, 39]}, {"full_name": "AddAction.injective", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [150, 3], "def_end_pos": [150, 14]}, {"full_name": "Function.Injective.mem_set_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [219, 9], "def_end_pos": [219, 48]}]], "state_before": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2076 : OrderedRing R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module R V'\ninst\u271d : AddTorsor V' P'\nx y z : P\nv : V\n\u22a2 v +\u1d65 z \u2208 affineSegment R (v +\u1d65 x) (v +\u1d65 y) \u2194 z \u2208 affineSegment R x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.fin_param", "start": [1121, 1], "end": [1124, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Homeomorph.lean", "full_name": "Equiv.toHomeomorph_refl", "start": [819, 1], "end": [820, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/NNReal.lean", "full_name": "NNReal.lt_iff_exists_rat_btwn", "start": [569, 1], "end": [577, 45], "traced_tactics": [{"tactic": "simp [Real.coe_toNNReal _ this, NNReal.coe_lt_coe.symm, haq, hqb]", "annotated_tactic": ["simp [<a>Real.coe_toNNReal</a> _ this, NNReal.coe_lt_coe.symm, haq, hqb]", [{"full_name": "Real.coe_toNNReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [122, 9], "def_end_pos": [122, 33]}]], "state_before": "r r\u2081 r\u2082 : \u211d\u22650\nx y : \u211d\na b : \u211d\u22650\nh : \u2191a < \u2191b\nq : \u211a\nhaq : \u2191a < \u2191q\nhqb : \u2191q < \u2191b\nthis : 0 \u2264 \u2191q\n\u22a2 a < Real.toNNReal \u2191q \u2227 Real.toNNReal \u2191q < b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Submonoid.subsemiringClosure_coe", "start": [795, 1], "end": [797, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "isLeast_univ", "start": [835, 1], "end": [836, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.natAbs_valMinAbs_le", "start": [1104, 1], "end": [1110, 35], "traced_tactics": [{"tactic": "rw [Nat.le_div_two_iff_mul_two_le]", "annotated_tactic": ["rw [<a>Nat.le_div_two_iff_mul_two_le</a>]", [{"full_name": "Nat.le_div_two_iff_mul_two_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [1054, 9], "def_end_pos": [1054, 45]}]], "state_before": "n : \u2115\ninst\u271d : NeZero n\nx : ZMod n\n\u22a2 Int.natAbs (valMinAbs x) \u2264 n / 2", "state_after": "n : \u2115\ninst\u271d : NeZero n\nx : ZMod n\n\u22a2 \u2191(Int.natAbs (valMinAbs x)) * 2 \u2264 \u2191n"}, {"tactic": "cases' x.valMinAbs.natAbs_eq with h h", "annotated_tactic": ["cases' x.valMinAbs.natAbs_eq with h h", []], "state_before": "n : \u2115\ninst\u271d : NeZero n\nx : ZMod n\n\u22a2 \u2191(Int.natAbs (valMinAbs x)) * 2 \u2264 \u2191n", "state_after": "case inl\nn : \u2115\ninst\u271d : NeZero n\nx : ZMod n\nh : valMinAbs x = \u2191(Int.natAbs (valMinAbs x))\n\u22a2 \u2191(Int.natAbs (valMinAbs x)) * 2 \u2264 \u2191n\n\ncase inr\nn : \u2115\ninst\u271d : NeZero n\nx : ZMod n\nh : valMinAbs x = -\u2191(Int.natAbs (valMinAbs x))\n\u22a2 \u2191(Int.natAbs (valMinAbs x)) * 2 \u2264 \u2191n"}, {"tactic": "rw [\u2190 h]", "annotated_tactic": ["rw [\u2190 h]", []], "state_before": "case inl\nn : \u2115\ninst\u271d : NeZero n\nx : ZMod n\nh : valMinAbs x = \u2191(Int.natAbs (valMinAbs x))\n\u22a2 \u2191(Int.natAbs (valMinAbs x)) * 2 \u2264 \u2191n", "state_after": "case inl\nn : \u2115\ninst\u271d : NeZero n\nx : ZMod n\nh : valMinAbs x = \u2191(Int.natAbs (valMinAbs x))\n\u22a2 valMinAbs x * 2 \u2264 \u2191n"}, {"tactic": "exact x.valMinAbs_mem_Ioc.2", "annotated_tactic": ["exact x.valMinAbs_mem_Ioc.2", []], "state_before": "case inl\nn : \u2115\ninst\u271d : NeZero n\nx : ZMod n\nh : valMinAbs x = \u2191(Int.natAbs (valMinAbs x))\n\u22a2 valMinAbs x * 2 \u2264 \u2191n", "state_after": "no goals"}, {"tactic": "rw [\u2190 neg_le_neg_iff, \u2190 neg_mul, \u2190 h]", "annotated_tactic": ["rw [\u2190 <a>neg_le_neg_iff</a>, \u2190 <a>neg_mul</a>, \u2190 h]", [{"full_name": "neg_le_neg_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [342, 3], "def_end_pos": [342, 14]}, {"full_name": "neg_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [306, 9], "def_end_pos": [306, 16]}]], "state_before": "case inr\nn : \u2115\ninst\u271d : NeZero n\nx : ZMod n\nh : valMinAbs x = -\u2191(Int.natAbs (valMinAbs x))\n\u22a2 \u2191(Int.natAbs (valMinAbs x)) * 2 \u2264 \u2191n", "state_after": "case inr\nn : \u2115\ninst\u271d : NeZero n\nx : ZMod n\nh : valMinAbs x = -\u2191(Int.natAbs (valMinAbs x))\n\u22a2 -\u2191n \u2264 valMinAbs x * 2"}, {"tactic": "exact x.valMinAbs_mem_Ioc.1.le", "annotated_tactic": ["exact x.valMinAbs_mem_Ioc.1.<a>le</a>", [{"full_name": "LT.lt.le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [139, 7], "def_end_pos": [139, 15]}]], "state_before": "case inr\nn : \u2115\ninst\u271d : NeZero n\nx : ZMod n\nh : valMinAbs x = -\u2191(Int.natAbs (valMinAbs x))\n\u22a2 -\u2191n \u2264 valMinAbs x * 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "full_name": "EMetric.infEdist_closure_pos_iff_not_mem_closure", "start": [188, 1], "end": [190, 58], "traced_tactics": [{"tactic": "rw [infEdist_closure, infEdist_pos_iff_not_mem_closure]", "annotated_tactic": ["rw [<a>infEdist_closure</a>, <a>infEdist_pos_iff_not_mem_closure</a>]", [{"full_name": "EMetric.infEdist_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [151, 9], "def_end_pos": [151, 25]}, {"full_name": "EMetric.infEdist_pos_iff_not_mem_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [183, 9], "def_end_pos": [183, 41]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx\u271d y : \u03b1\ns t : Set \u03b1\n\u03a6 : \u03b1 \u2192 \u03b2\nx : \u03b1\nE : Set \u03b1\n\u22a2 0 < infEdist x (closure E) \u2194 x \u2209 closure E", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "full_name": "Real.Angle.abs_cos_eq_abs_sin_of_two_zsmul_add_two_zsmul_eq_pi", "start": [766, 1], "end": [769, 62], "traced_tactics": [{"tactic": "exact abs_cos_eq_abs_sin_of_two_nsmul_add_two_nsmul_eq_pi h", "annotated_tactic": ["exact <a>abs_cos_eq_abs_sin_of_two_nsmul_add_two_nsmul_eq_pi</a> h", [{"full_name": "Real.Angle.abs_cos_eq_abs_sin_of_two_nsmul_add_two_nsmul_eq_pi", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "def_pos": [760, 9], "def_end_pos": [760, 60]}]], "state_before": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 + 2 \u2022 \u03c8 = \u2191\u03c0\n\u22a2 |cos \u03b8| = |sin \u03c8|", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.diagonal_eq_univ", "start": [517, 1], "end": [517, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.get?_of_mem", "start": [734, 1], "end": [735, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Derivative.lean", "full_name": "Polynomial.derivative_apply", "start": [53, 1], "end": [54, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Trace.lean", "full_name": "Matrix.trace_mul_cycle'", "start": [178, 1], "end": [180, 42], "traced_tactics": [{"tactic": "rw [\u2190 Matrix.mul_assoc, trace_mul_comm]", "annotated_tactic": ["rw [\u2190 <a>Matrix.mul_assoc</a>, <a>trace_mul_comm</a>]", [{"full_name": "Matrix.mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1185, 19], "def_end_pos": [1185, 28]}, {"full_name": "Matrix.trace_mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Trace.lean", "def_pos": [169, 9], "def_end_pos": [169, 23]}]], "state_before": "\u03b9 : Type u_1\nm : Type u_2\nn : Type u_3\np : Type u_4\n\u03b1 : Type u_5\nR : Type u_6\nS : Type u_7\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype p\ninst\u271d : NonUnitalCommSemiring R\nA : Matrix m n R\nB : Matrix n p R\nC : Matrix p m R\n\u22a2 trace (A * (B * C)) = trace (C * (A * B))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.set_biInter_insert_update", "start": [2260, 1], "end": [2262, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/LinearCombination.lean", "full_name": "Mathlib.Tactic.LinearCombination.pf_sub_c", "start": [42, 1], "end": [42, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.isEmpty_cons", "start": [139, 9], "end": [139, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "full_name": "ContinuousMultilinearMap.norm_ofSubsingleton_id_le", "start": [620, 1], "end": [623, 39], "traced_tactics": [{"tactic": "rw [norm_ofSubsingleton]", "annotated_tactic": ["rw [<a>norm_ofSubsingleton</a>]", [{"full_name": "ContinuousMultilinearMap.norm_ofSubsingleton", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "def_pos": [598, 9], "def_end_pos": [598, 28]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2078 : Fintype \u03b9\ninst\u271d\u00b9\u2077 : Fintype \u03b9'\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2075 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u2074 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u00b9\u2070 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2079 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2078 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2077 : SeminormedAddCommGroup G\ninst\u271d\u2076 : NormedSpace \ud835\udd5c G\ninst\u271d\u2075 : SeminormedAddCommGroup G'\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G'\nc : \ud835\udd5c\nf g : ContinuousMultilinearMap \ud835\udd5c E G\nm : (i : \u03b9) \u2192 E i\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b3 : NormedField \ud835\udd5c'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c' G\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c \ud835\udd5c' G\ninst\u271d : Subsingleton \u03b9\ni : \u03b9\n\u22a2 \u2016(ofSubsingleton \ud835\udd5c G G i) (ContinuousLinearMap.id \ud835\udd5c G)\u2016 \u2264 1", "state_after": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2078 : Fintype \u03b9\ninst\u271d\u00b9\u2077 : Fintype \u03b9'\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2075 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u2074 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u00b9\u2070 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2079 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2078 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2077 : SeminormedAddCommGroup G\ninst\u271d\u2076 : NormedSpace \ud835\udd5c G\ninst\u271d\u2075 : SeminormedAddCommGroup G'\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G'\nc : \ud835\udd5c\nf g : ContinuousMultilinearMap \ud835\udd5c E G\nm : (i : \u03b9) \u2192 E i\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b3 : NormedField \ud835\udd5c'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c' G\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c \ud835\udd5c' G\ninst\u271d : Subsingleton \u03b9\ni : \u03b9\n\u22a2 \u2016ContinuousLinearMap.id \ud835\udd5c G\u2016 \u2264 1"}, {"tactic": "apply ContinuousLinearMap.norm_id_le", "annotated_tactic": ["apply <a>ContinuousLinearMap.norm_id_le</a>", [{"full_name": "ContinuousLinearMap.norm_id_le", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean", "def_pos": [226, 9], "def_end_pos": [226, 19]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2078 : Fintype \u03b9\ninst\u271d\u00b9\u2077 : Fintype \u03b9'\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2075 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u2074 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u00b9\u2070 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2079 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2078 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2077 : SeminormedAddCommGroup G\ninst\u271d\u2076 : NormedSpace \ud835\udd5c G\ninst\u271d\u2075 : SeminormedAddCommGroup G'\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G'\nc : \ud835\udd5c\nf g : ContinuousMultilinearMap \ud835\udd5c E G\nm : (i : \u03b9) \u2192 E i\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b3 : NormedField \ud835\udd5c'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c' G\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c \ud835\udd5c' G\ninst\u271d : Subsingleton \u03b9\ni : \u03b9\n\u22a2 \u2016ContinuousLinearMap.id \ud835\udd5c G\u2016 \u2264 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Maps.lean", "full_name": "IsClosedMap.of_nonempty", "start": [468, 1], "end": [472, 21], "traced_tactics": [{"tactic": "intro s hs", "annotated_tactic": ["intro s hs", []], "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nh : \u2200 (s : Set X), IsClosed s \u2192 Set.Nonempty s \u2192 IsClosed (f '' s)\n\u22a2 IsClosedMap f", "state_after": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nh : \u2200 (s : Set X), IsClosed s \u2192 Set.Nonempty s \u2192 IsClosed (f '' s)\ns : Set X\nhs : IsClosed s\n\u22a2 IsClosed (f '' s)"}, {"tactic": "rcases eq_empty_or_nonempty s with h2s | h2s", "annotated_tactic": ["rcases <a>eq_empty_or_nonempty</a> s with h2s | h2s", [{"full_name": "Set.eq_empty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [609, 9], "def_end_pos": [609, 29]}]], "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nh : \u2200 (s : Set X), IsClosed s \u2192 Set.Nonempty s \u2192 IsClosed (f '' s)\ns : Set X\nhs : IsClosed s\n\u22a2 IsClosed (f '' s)", "state_after": "case inl\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nh : \u2200 (s : Set X), IsClosed s \u2192 Set.Nonempty s \u2192 IsClosed (f '' s)\ns : Set X\nhs : IsClosed s\nh2s : s = \u2205\n\u22a2 IsClosed (f '' s)\n\ncase inr\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nh : \u2200 (s : Set X), IsClosed s \u2192 Set.Nonempty s \u2192 IsClosed (f '' s)\ns : Set X\nhs : IsClosed s\nh2s : Set.Nonempty s\n\u22a2 IsClosed (f '' s)"}, {"tactic": "simp_rw [h2s, image_empty, isClosed_empty]", "annotated_tactic": ["simp_rw [h2s, <a>image_empty</a>, <a>isClosed_empty</a>]", [{"full_name": "Set.image_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [309, 9], "def_end_pos": [309, 20]}, {"full_name": "isClosed_empty", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [175, 17], "def_end_pos": [175, 31]}]], "state_before": "case inl\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nh : \u2200 (s : Set X), IsClosed s \u2192 Set.Nonempty s \u2192 IsClosed (f '' s)\ns : Set X\nhs : IsClosed s\nh2s : s = \u2205\n\u22a2 IsClosed (f '' s)", "state_after": "no goals"}, {"tactic": "exact h s hs h2s", "annotated_tactic": ["exact h s hs h2s", []], "state_before": "case inr\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nh : \u2200 (s : Set X), IsClosed s \u2192 Set.Nonempty s \u2192 IsClosed (f '' s)\ns : Set X\nhs : IsClosed s\nh2s : Set.Nonempty s\n\u22a2 IsClosed (f '' s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "round_one", "start": [1445, 1], "end": [1445, 57], "traced_tactics": [{"tactic": "simp [round]", "annotated_tactic": ["simp [<a>round</a>]", [{"full_name": "round", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [1436, 5], "def_end_pos": [1436, 10]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\n\u22a2 round 1 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Basic.lean", "full_name": "hasDerivAt_deriv_iff", "start": [437, 1], "end": [438, 55], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Test.lean", "full_name": "algebra_absapbon1pabsapbleqsumabsaon1pabsa", "start": [712, 1], "end": [714, 90], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "a b : \u211d\n\u22a2 |a + b| / (1 + |a + b|) \u2264 |a| / (1 + |a|) + |b| / (1 + |b|)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Quotient.lean", "full_name": "Submodule.Quotient.eq'", "start": [77, 11], "end": [78, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Ker.lean", "full_name": "Filter.ker_def", "start": [27, 1], "end": [27, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Complex.exp_conj", "start": [245, 1], "end": [252, 57], "traced_tactics": [{"tactic": "dsimp [exp]", "annotated_tactic": ["dsimp [<a>exp</a>]", [{"full_name": "Complex.exp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [54, 5], "def_end_pos": [54, 8]}]], "state_before": "x y : \u2102\n\u22a2 cexp ((starRingEnd \u2102) x) = (starRingEnd \u2102) (cexp x)", "state_after": "x y : \u2102\n\u22a2 CauSeq.lim (exp' ((starRingEnd \u2102) x)) = (starRingEnd \u2102) (CauSeq.lim (exp' x))"}, {"tactic": "rw [\u2190 lim_conj]", "annotated_tactic": ["rw [\u2190 <a>lim_conj</a>]", [{"full_name": "Complex.lim_conj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Abs.lean", "def_pos": [343, 9], "def_end_pos": [343, 17]}]], "state_before": "x y : \u2102\n\u22a2 CauSeq.lim (exp' ((starRingEnd \u2102) x)) = (starRingEnd \u2102) (CauSeq.lim (exp' x))", "state_after": "x y : \u2102\n\u22a2 CauSeq.lim (exp' ((starRingEnd \u2102) x)) = CauSeq.lim (cauSeqConj (exp' x))"}, {"tactic": "refine' congr_arg CauSeq.lim (CauSeq.ext fun _ => _)", "annotated_tactic": ["refine' <a>congr_arg</a> <a>CauSeq.lim</a> (<a>CauSeq.ext</a> fun _ => _)", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "CauSeq.lim", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/Completion.lean", "def_pos": [337, 19], "def_end_pos": [337, 22]}, {"full_name": "CauSeq.ext", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/Basic.lean", "def_pos": [185, 9], "def_end_pos": [185, 12]}]], "state_before": "x y : \u2102\n\u22a2 CauSeq.lim (exp' ((starRingEnd \u2102) x)) = CauSeq.lim (cauSeqConj (exp' x))", "state_after": "x y : \u2102\nx\u271d : \u2115\n\u22a2 \u2191(exp' ((starRingEnd \u2102) x)) x\u271d = \u2191(cauSeqConj (exp' x)) x\u271d"}, {"tactic": "dsimp [exp', Function.comp_def, cauSeqConj]", "annotated_tactic": ["dsimp [<a>exp'</a>, <a>Function.comp_def</a>, <a>cauSeqConj</a>]", [{"full_name": "Complex.exp'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [47, 5], "def_end_pos": [47, 9]}, {"full_name": "Function.comp_def", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [37, 9], "def_end_pos": [37, 26]}, {"full_name": "Complex.cauSeqConj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Abs.lean", "def_pos": [339, 19], "def_end_pos": [339, 29]}]], "state_before": "x y : \u2102\nx\u271d : \u2115\n\u22a2 \u2191(exp' ((starRingEnd \u2102) x)) x\u271d = \u2191(cauSeqConj (exp' x)) x\u271d", "state_after": "x y : \u2102\nx\u271d : \u2115\n\u22a2 \u2211 m in range x\u271d, (starRingEnd \u2102) x ^ m / \u2191(Nat.factorial m) =\n    (starRingEnd \u2102) (\u2211 m in range x\u271d, x ^ m / \u2191(Nat.factorial m))"}, {"tactic": "rw [(starRingEnd _).map_sum]", "annotated_tactic": ["rw [(<a>starRingEnd</a> _).<a>map_sum</a>]", [{"full_name": "starRingEnd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Star/Basic.lean", "def_pos": [379, 5], "def_end_pos": [379, 16]}, {"full_name": "RingHom.map_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [260, 19], "def_end_pos": [260, 34]}]], "state_before": "x y : \u2102\nx\u271d : \u2115\n\u22a2 \u2211 m in range x\u271d, (starRingEnd \u2102) x ^ m / \u2191(Nat.factorial m) =\n    (starRingEnd \u2102) (\u2211 m in range x\u271d, x ^ m / \u2191(Nat.factorial m))", "state_after": "x y : \u2102\nx\u271d : \u2115\n\u22a2 \u2211 m in range x\u271d, (starRingEnd \u2102) x ^ m / \u2191(Nat.factorial m) =\n    \u2211 x_1 in range x\u271d, (starRingEnd \u2102) (x ^ x_1 / \u2191(Nat.factorial x_1))"}, {"tactic": "refine' sum_congr rfl fun n _ => _", "annotated_tactic": ["refine' <a>sum_congr</a> <a>rfl</a> fun n _ => _", [{"full_name": "Finset.sum_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [381, 3], "def_end_pos": [381, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "x y : \u2102\nx\u271d : \u2115\n\u22a2 \u2211 m in range x\u271d, (starRingEnd \u2102) x ^ m / \u2191(Nat.factorial m) =\n    \u2211 x_1 in range x\u271d, (starRingEnd \u2102) (x ^ x_1 / \u2191(Nat.factorial x_1))", "state_after": "x y : \u2102\nx\u271d\u00b9 n : \u2115\nx\u271d : n \u2208 range x\u271d\u00b9\n\u22a2 (starRingEnd \u2102) x ^ n / \u2191(Nat.factorial n) = (starRingEnd \u2102) (x ^ n / \u2191(Nat.factorial n))"}, {"tactic": "rw [map_div\u2080, map_pow, \u2190 ofReal_nat_cast, conj_ofReal]", "annotated_tactic": ["rw [<a>map_div\u2080</a>, <a>map_pow</a>, \u2190 <a>ofReal_nat_cast</a>, <a>conj_ofReal</a>]", [{"full_name": "map_div\u2080", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "def_pos": [71, 9], "def_end_pos": [71, 17]}, {"full_name": "map_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [469, 9], "def_end_pos": [469, 16]}, {"full_name": "Complex.ofReal_nat_cast", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [808, 9], "def_end_pos": [808, 24]}, {"full_name": "Complex.conj_ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [549, 9], "def_end_pos": [549, 20]}]], "state_before": "x y : \u2102\nx\u271d\u00b9 n : \u2115\nx\u271d : n \u2208 range x\u271d\u00b9\n\u22a2 (starRingEnd \u2102) x ^ n / \u2191(Nat.factorial n) = (starRingEnd \u2102) (x ^ n / \u2191(Nat.factorial n))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.Sigma.univ", "start": [1292, 1], "end": [1294, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "div_mul_div_comm", "start": [657, 1], "end": [657, 72], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivisionCommMonoid \u03b1\na b c d : \u03b1\n\u22a2 a / b * (c / d) = a * c / (b * d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.mul_top", "start": [803, 1], "end": [804, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Prod.lean", "full_name": "MulHom.prod_unique", "start": [401, 1], "end": [402, 71], "traced_tactics": [{"tactic": "simp only [prod_apply, coe_fst, coe_snd, comp_apply]", "annotated_tactic": ["simp only [<a>prod_apply</a>, <a>coe_fst</a>, <a>coe_snd</a>, <a>comp_apply</a>]", [{"full_name": "MulHom.prod_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [383, 9], "def_end_pos": [383, 19]}, {"full_name": "MulHom.coe_fst", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [353, 9], "def_end_pos": [353, 16]}, {"full_name": "MulHom.coe_snd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [359, 9], "def_end_pos": [359, 16]}, {"full_name": "MulHom.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [942, 9], "def_end_pos": [942, 26]}]], "state_before": "A : Type u_1\nB : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Mul N\ninst\u271d : Mul P\nf : M \u2192\u2099* N \u00d7 P\nx : M\n\u22a2 (MulHom.prod (comp (fst N P) f) (comp (snd N P) f)) x = f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.inf_limsup", "start": [1148, 1], "end": [1149, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "lt_mul_of_lt_of_one_le'", "start": [861, 1], "end": [863, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearEquiv.coe_toLinearEquiv", "start": [1899, 1], "end": [1900, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Pointwise.lean", "full_name": "ball_sub_ball", "start": [359, 1], "end": [361, 58], "traced_tactics": [{"tactic": "simp_rw [sub_eq_add_neg, neg_ball, ball_add_ball h\u03b5 h\u03b4]", "annotated_tactic": ["simp_rw [<a>sub_eq_add_neg</a>, <a>neg_ball</a>, <a>ball_add_ball</a> h\u03b5 h\u03b4]", [{"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}, {"full_name": "neg_ball", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Pointwise.lean", "def_pos": [107, 3], "def_end_pos": [107, 14]}, {"full_name": "ball_add_ball", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Pointwise.lean", "def_pos": [354, 9], "def_end_pos": [354, 22]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx y z : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\na b : E\n\u22a2 Metric.ball a \u03b5 - Metric.ball b \u03b4 = Metric.ball (a - b) (\u03b5 + \u03b4)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Log.lean", "full_name": "Nat.log_one_right", "start": [83, 1], "end": [84, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Lattice.lean", "full_name": "ContinuousWithinAt.finset_sup_apply", "start": [306, 1], "end": [309, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.restrict_extend_compl_range", "start": [124, 1], "end": [127, 32], "traced_tactics": [{"tactic": "classical\nexact restrict_dite_compl _ _", "annotated_tactic": ["classical\n  exact <a>restrict_dite_compl</a> _ _", [{"full_name": "Set.restrict_dite_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [87, 9], "def_end_pos": [87, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ng' : \u03b2 \u2192 \u03b3\n\u22a2 restrict (range f)\u1d9c (extend f g g') = g' \u2218 Subtype.val", "state_after": "no goals"}, {"tactic": "exact restrict_dite_compl _ _", "annotated_tactic": ["exact <a>restrict_dite_compl</a> _ _", [{"full_name": "Set.restrict_dite_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [87, 9], "def_end_pos": [87, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ng' : \u03b2 \u2192 \u03b3\n\u22a2 restrict (range f)\u1d9c (extend f g g') = g' \u2218 Subtype.val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearForm/Properties.lean", "full_name": "BilinForm.IsAdjointPair.comp", "start": [259, 1], "end": [261, 57], "traced_tactics": [{"tactic": "rw [LinearMap.comp_apply, LinearMap.comp_apply, h', h]", "annotated_tactic": ["rw [<a>LinearMap.comp_apply</a>, <a>LinearMap.comp_apply</a>, h', h]", [{"full_name": "LinearMap.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 19]}, {"full_name": "LinearMap.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 19]}]], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2078 : CommSemiring R\ninst\u271d\u00b9\u2077 : AddCommMonoid M\ninst\u271d\u00b9\u2076 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u2075 : CommRing R\u2081\ninst\u271d\u00b9\u2074 : AddCommGroup M\u2081\ninst\u271d\u00b9\u00b3 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u00b9\u00b2 : Field K\ninst\u271d\u00b9\u00b9 : AddCommGroup V\ninst\u271d\u00b9\u2070 : Module K V\nM'\u271d : Type u_7\nM''\u271d : Type u_8\ninst\u271d\u2079 : AddCommMonoid M'\u271d\ninst\u271d\u2078 : AddCommMonoid M''\u271d\ninst\u271d\u2077 : Module R M'\u271d\ninst\u271d\u2076 : Module R M''\u271d\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u2075 : AddCommMonoid M'\ninst\u271d\u2074 : Module R M'\nB' : BilinForm R M'\nf f'\u271d : M \u2192\u2097[R] M'\ng g'\u271d : M' \u2192\u2097[R] M\nM\u2081' : Type u_10\ninst\u271d\u00b3 : AddCommGroup M\u2081'\ninst\u271d\u00b2 : Module R\u2081 M\u2081'\nB\u2081' : BilinForm R\u2081 M\u2081'\nf\u2081 f\u2081' : M\u2081 \u2192\u2097[R\u2081] M\u2081'\ng\u2081 g\u2081' : M\u2081' \u2192\u2097[R\u2081] M\u2081\nB\u2082' : BilinForm R M'\nf\u2082 f\u2082' : M \u2192\u2097[R] M'\ng\u2082 g\u2082' : M' \u2192\u2097[R] M\nM'' : Type u_11\ninst\u271d\u00b9 : AddCommMonoid M''\ninst\u271d : Module R M''\nB'' : BilinForm R M''\nf' : M' \u2192\u2097[R] M''\ng' : M'' \u2192\u2097[R] M'\nh : IsAdjointPair B B' f g\nh' : IsAdjointPair B' B'' f' g'\nx : M\ny : M''\n\u22a2 B''.bilin ((f' \u2218\u2097 f) x) y = B.bilin x ((g \u2218\u2097 g') y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/RootsOfUnity/Basic.lean", "full_name": "IsPrimitiveRoot.geom_sum_eq_zero", "start": [694, 1], "end": [697, 49], "traced_tactics": [{"tactic": "refine' eq_zero_of_ne_zero_of_mul_left_eq_zero (sub_ne_zero_of_ne (h\u03b6.ne_one hk).symm) _", "annotated_tactic": ["refine' <a>eq_zero_of_ne_zero_of_mul_left_eq_zero</a> (<a>sub_ne_zero_of_ne</a> (h\u03b6.ne_one hk).<a>symm</a>) _", [{"full_name": "eq_zero_of_ne_zero_of_mul_left_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "def_pos": [193, 9], "def_end_pos": [193, 47]}, {"full_name": "sub_ne_zero_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [453, 3], "def_end_pos": [453, 14]}, {"full_name": "Ne.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [702, 9], "def_end_pos": [702, 16]}]], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : CommMonoid N\ninst\u271d\u00b2 : DivisionCommMonoid G\nk l : \u2115\ninst\u271d\u00b9 : CommRing R\n\u03b6\u271d : R\u02e3\nh : IsPrimitiveRoot \u03b6\u271d k\ninst\u271d : IsDomain R\n\u03b6 : R\nh\u03b6 : IsPrimitiveRoot \u03b6 k\nhk : 1 < k\n\u22a2 \u2211 i in range k, \u03b6 ^ i = 0", "state_after": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : CommMonoid N\ninst\u271d\u00b2 : DivisionCommMonoid G\nk l : \u2115\ninst\u271d\u00b9 : CommRing R\n\u03b6\u271d : R\u02e3\nh : IsPrimitiveRoot \u03b6\u271d k\ninst\u271d : IsDomain R\n\u03b6 : R\nh\u03b6 : IsPrimitiveRoot \u03b6 k\nhk : 1 < k\n\u22a2 (1 - \u03b6) * \u2211 i in range k, \u03b6 ^ i = 0"}, {"tactic": "rw [mul_neg_geom_sum, h\u03b6.pow_eq_one, sub_self]", "annotated_tactic": ["rw [<a>mul_neg_geom_sum</a>, h\u03b6.pow_eq_one, <a>sub_self</a>]", [{"full_name": "mul_neg_geom_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GeomSum.lean", "def_pos": [246, 9], "def_end_pos": [246, 25]}, {"full_name": "sub_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [813, 30], "def_end_pos": [813, 38]}]], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : CommMonoid N\ninst\u271d\u00b2 : DivisionCommMonoid G\nk l : \u2115\ninst\u271d\u00b9 : CommRing R\n\u03b6\u271d : R\u02e3\nh : IsPrimitiveRoot \u03b6\u271d k\ninst\u271d : IsDomain R\n\u03b6 : R\nh\u03b6 : IsPrimitiveRoot \u03b6 k\nhk : 1 < k\n\u22a2 (1 - \u03b6) * \u2211 i in range k, \u03b6 ^ i = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/ToNat.lean", "full_name": "Cardinal.aleph0_toNat", "start": [131, 1], "end": [132, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.tsum_coe_eq", "start": [788, 11], "end": [789, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.coe_pow", "start": [409, 1], "end": [410, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Real.antitone_rpow_of_base_le_one", "start": [831, 1], "end": [835, 32], "traced_tactics": [{"tactic": "rcases lt_or_eq_of_le hb\u2081 with hb\u2081 | rfl", "annotated_tactic": ["rcases <a>lt_or_eq_of_le</a> hb\u2081 with hb\u2081 | rfl", [{"full_name": "lt_or_eq_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [222, 9], "def_end_pos": [222, 23]}]], "state_before": "x y z : \u211d\nn : \u2115\nb : \u211d\nhb\u2080 : 0 < b\nhb\u2081 : b \u2264 1\n\u22a2 Antitone (rpow b)", "state_after": "case inl\nx y z : \u211d\nn : \u2115\nb : \u211d\nhb\u2080 : 0 < b\nhb\u2081\u271d : b \u2264 1\nhb\u2081 : b < 1\n\u22a2 Antitone (rpow b)\n\ncase inr\nx y z : \u211d\nn : \u2115\nhb\u2080 : 0 < 1\nhb\u2081 : 1 \u2264 1\n\u22a2 Antitone (rpow 1)"}, {"tactic": "case inl => exact (strictAnti_rpow_of_base_lt_one hb\u2080 hb\u2081).antitone", "annotated_tactic": ["case inl => exact (<a>strictAnti_rpow_of_base_lt_one</a> hb\u2080 hb\u2081).<a>antitone</a>", [{"full_name": "Real.strictAnti_rpow_of_base_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [824, 7], "def_end_pos": [824, 37]}, {"full_name": "StrictAnti.antitone", "def_path": ".lake/packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [504, 19], "def_end_pos": [504, 38]}]], "state_before": "case inl\nx y z : \u211d\nn : \u2115\nb : \u211d\nhb\u2080 : 0 < b\nhb\u2081\u271d : b \u2264 1\nhb\u2081 : b < 1\n\u22a2 Antitone (rpow b)\n\ncase inr\nx y z : \u211d\nn : \u2115\nhb\u2080 : 0 < 1\nhb\u2081 : 1 \u2264 1\n\u22a2 Antitone (rpow 1)", "state_after": "case inr\nx y z : \u211d\nn : \u2115\nhb\u2080 : 0 < 1\nhb\u2081 : 1 \u2264 1\n\u22a2 Antitone (rpow 1)"}, {"tactic": "case inr => intro _ _ _; simp", "annotated_tactic": ["case inr => intro _ _ _; simp", []], "state_before": "case inr\nx y z : \u211d\nn : \u2115\nhb\u2080 : 0 < 1\nhb\u2081 : 1 \u2264 1\n\u22a2 Antitone (rpow 1)", "state_after": "no goals"}, {"tactic": "exact (strictAnti_rpow_of_base_lt_one hb\u2080 hb\u2081).antitone", "annotated_tactic": ["exact (<a>strictAnti_rpow_of_base_lt_one</a> hb\u2080 hb\u2081).<a>antitone</a>", [{"full_name": "Real.strictAnti_rpow_of_base_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [824, 7], "def_end_pos": [824, 37]}, {"full_name": "StrictAnti.antitone", "def_path": ".lake/packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [504, 19], "def_end_pos": [504, 38]}]], "state_before": "x y z : \u211d\nn : \u2115\nb : \u211d\nhb\u2080 : 0 < b\nhb\u2081\u271d : b \u2264 1\nhb\u2081 : b < 1\n\u22a2 Antitone (rpow b)", "state_after": "no goals"}, {"tactic": "intro _ _ _", "annotated_tactic": ["intro _ _ _", []], "state_before": "x y z : \u211d\nn : \u2115\nhb\u2080 : 0 < 1\nhb\u2081 : 1 \u2264 1\n\u22a2 Antitone (rpow 1)", "state_after": "x y z : \u211d\nn : \u2115\nhb\u2080 : 0 < 1\nhb\u2081 : 1 \u2264 1\na\u271d\u00b9 b\u271d : \u211d\na\u271d : a\u271d\u00b9 \u2264 b\u271d\n\u22a2 rpow 1 b\u271d \u2264 rpow 1 a\u271d\u00b9"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "x y z : \u211d\nn : \u2115\nhb\u2080 : 0 < 1\nhb\u2081 : 1 \u2264 1\na\u271d\u00b9 b\u271d : \u211d\na\u271d : a\u271d\u00b9 \u2264 b\u271d\n\u22a2 rpow 1 b\u271d \u2264 rpow 1 a\u271d\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "exists_apply_eq_apply'", "start": [766, 1], "end": [766, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Group.conj_mem_conjugatesOfSet", "start": [2468, 1], "end": [2471, 76], "traced_tactics": [{"tactic": "rcases mem_conjugatesOfSet_iff.1 H with \u27e8a, h\u2081, h\u2082\u27e9", "annotated_tactic": ["rcases <a>mem_conjugatesOfSet_iff</a>.1 H with \u27e8a, h\u2081, h\u2082\u27e9", [{"full_name": "Group.mem_conjugatesOfSet_iff", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [2443, 9], "def_end_pos": [2443, 32]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Group G'\ninst\u271d\u00b9 : Group G''\nA : Type u_4\ninst\u271d : AddGroup A\ns : Set G\nx c : G\nH : x \u2208 conjugatesOfSet s\n\u22a2 c * x * c\u207b\u00b9 \u2208 conjugatesOfSet s", "state_after": "case intro.intro\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Group G'\ninst\u271d\u00b9 : Group G''\nA : Type u_4\ninst\u271d : AddGroup A\ns : Set G\nx c : G\nH : x \u2208 conjugatesOfSet s\na : G\nh\u2081 : a \u2208 s\nh\u2082 : IsConj a x\n\u22a2 c * x * c\u207b\u00b9 \u2208 conjugatesOfSet s"}, {"tactic": "exact mem_conjugatesOfSet_iff.2 \u27e8a, h\u2081, h\u2082.trans (isConj_iff.2 \u27e8c, rfl\u27e9)\u27e9", "annotated_tactic": ["exact <a>mem_conjugatesOfSet_iff</a>.2 \u27e8a, h\u2081, h\u2082.trans (<a>isConj_iff</a>.2 \u27e8c, <a>rfl</a>\u27e9)\u27e9", [{"full_name": "Group.mem_conjugatesOfSet_iff", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [2443, 9], "def_end_pos": [2443, 32]}, {"full_name": "isConj_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Conj.lean", "def_pos": [89, 9], "def_end_pos": [89, 19]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro.intro\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Group G'\ninst\u271d\u00b9 : Group G''\nA : Type u_4\ninst\u271d : AddGroup A\ns : Set G\nx c : G\nH : x \u2208 conjugatesOfSet s\na : G\nh\u2081 : a \u2208 s\nh\u2082 : IsConj a x\n\u22a2 c * x * c\u207b\u00b9 \u2208 conjugatesOfSet s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.gc_map_comap", "start": [2316, 1], "end": [2317, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "full_name": "Cardinal.add_eq_right_iff", "start": [804, 1], "end": [805, 33], "traced_tactics": [{"tactic": "rw [add_comm, add_eq_left_iff]", "annotated_tactic": ["rw [<a>add_comm</a>, <a>add_eq_left_iff</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "Cardinal.add_eq_left_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [784, 9], "def_end_pos": [784, 24]}]], "state_before": "a b : Cardinal.{u_1}\n\u22a2 a + b = b \u2194 max \u2135\u2080 a \u2264 b \u2228 a = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Notation.lean", "full_name": "Matrix.mul_fin_three", "start": [488, 1], "end": [500, 76], "traced_tactics": [{"tactic": "ext i j", "annotated_tactic": ["ext i j", []], "state_before": "\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\n\u22a2 of ![![a\u2081\u2081, a\u2081\u2082, a\u2081\u2083], ![a\u2082\u2081, a\u2082\u2082, a\u2082\u2083], ![a\u2083\u2081, a\u2083\u2082, a\u2083\u2083]] *\n      of ![![b\u2081\u2081, b\u2081\u2082, b\u2081\u2083], ![b\u2082\u2081, b\u2082\u2082, b\u2082\u2083], ![b\u2083\u2081, b\u2083\u2082, b\u2083\u2083]] =\n    of\n      ![![a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081 + a\u2081\u2083 * b\u2083\u2081, a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082 + a\u2081\u2083 * b\u2083\u2082, a\u2081\u2081 * b\u2081\u2083 + a\u2081\u2082 * b\u2082\u2083 + a\u2081\u2083 * b\u2083\u2083],\n        ![a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081 + a\u2082\u2083 * b\u2083\u2081, a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082 + a\u2082\u2083 * b\u2083\u2082, a\u2082\u2081 * b\u2081\u2083 + a\u2082\u2082 * b\u2082\u2083 + a\u2082\u2083 * b\u2083\u2083],\n        ![a\u2083\u2081 * b\u2081\u2081 + a\u2083\u2082 * b\u2082\u2081 + a\u2083\u2083 * b\u2083\u2081, a\u2083\u2081 * b\u2081\u2082 + a\u2083\u2082 * b\u2082\u2082 + a\u2083\u2083 * b\u2083\u2082, a\u2083\u2081 * b\u2081\u2083 + a\u2083\u2082 * b\u2082\u2083 + a\u2083\u2083 * b\u2083\u2083]]", "state_after": "case a.h\n\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\ni j : Fin 3\n\u22a2 (of ![![a\u2081\u2081, a\u2081\u2082, a\u2081\u2083], ![a\u2082\u2081, a\u2082\u2082, a\u2082\u2083], ![a\u2083\u2081, a\u2083\u2082, a\u2083\u2083]] *\n        of ![![b\u2081\u2081, b\u2081\u2082, b\u2081\u2083], ![b\u2082\u2081, b\u2082\u2082, b\u2082\u2083], ![b\u2083\u2081, b\u2083\u2082, b\u2083\u2083]])\n      i j =\n    of\n      ![![a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081 + a\u2081\u2083 * b\u2083\u2081, a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082 + a\u2081\u2083 * b\u2083\u2082, a\u2081\u2081 * b\u2081\u2083 + a\u2081\u2082 * b\u2082\u2083 + a\u2081\u2083 * b\u2083\u2083],\n        ![a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081 + a\u2082\u2083 * b\u2083\u2081, a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082 + a\u2082\u2083 * b\u2083\u2082, a\u2082\u2081 * b\u2081\u2083 + a\u2082\u2082 * b\u2082\u2083 + a\u2082\u2083 * b\u2083\u2083],\n        ![a\u2083\u2081 * b\u2081\u2081 + a\u2083\u2082 * b\u2082\u2081 + a\u2083\u2083 * b\u2083\u2081, a\u2083\u2081 * b\u2081\u2082 + a\u2083\u2082 * b\u2082\u2082 + a\u2083\u2083 * b\u2083\u2082, a\u2083\u2081 * b\u2081\u2083 + a\u2083\u2082 * b\u2082\u2083 + a\u2083\u2083 * b\u2083\u2083]]\n      i j"}, {"tactic": "fin_cases i <;> fin_cases j\n  <;> simp [Matrix.mul_apply, dotProduct, Fin.sum_univ_succ, \u2190 add_assoc]", "annotated_tactic": ["fin_cases i <;> fin_cases j\n    <;> simp [<a>Matrix.mul_apply</a>, <a>dotProduct</a>, <a>Fin.sum_univ_succ</a>, \u2190 <a>add_assoc</a>]", [{"full_name": "Matrix.mul_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [968, 9], "def_end_pos": [968, 18]}, {"full_name": "Matrix.dotProduct", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [752, 5], "def_end_pos": [752, 15]}, {"full_name": "Fin.sum_univ_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [80, 3], "def_end_pos": [80, 14]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}]], "state_before": "case a.h\n\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\na\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1\ni j : Fin 3\n\u22a2 (of ![![a\u2081\u2081, a\u2081\u2082, a\u2081\u2083], ![a\u2082\u2081, a\u2082\u2082, a\u2082\u2083], ![a\u2083\u2081, a\u2083\u2082, a\u2083\u2083]] *\n        of ![![b\u2081\u2081, b\u2081\u2082, b\u2081\u2083], ![b\u2082\u2081, b\u2082\u2082, b\u2082\u2083], ![b\u2083\u2081, b\u2083\u2082, b\u2083\u2083]])\n      i j =\n    of\n      ![![a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081 + a\u2081\u2083 * b\u2083\u2081, a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082 + a\u2081\u2083 * b\u2083\u2082, a\u2081\u2081 * b\u2081\u2083 + a\u2081\u2082 * b\u2082\u2083 + a\u2081\u2083 * b\u2083\u2083],\n        ![a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081 + a\u2082\u2083 * b\u2083\u2081, a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082 + a\u2082\u2083 * b\u2083\u2082, a\u2082\u2081 * b\u2081\u2083 + a\u2082\u2082 * b\u2082\u2083 + a\u2082\u2083 * b\u2083\u2083],\n        ![a\u2083\u2081 * b\u2081\u2081 + a\u2083\u2082 * b\u2082\u2081 + a\u2083\u2083 * b\u2083\u2081, a\u2083\u2081 * b\u2081\u2082 + a\u2083\u2082 * b\u2082\u2082 + a\u2083\u2083 * b\u2083\u2082, a\u2083\u2081 * b\u2081\u2083 + a\u2083\u2082 * b\u2082\u2083 + a\u2083\u2083 * b\u2083\u2083]]\n      i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Ker.lean", "full_name": "LinearMap.ker_eq_bot_of_inverse", "start": [116, 1], "end": [118, 91], "traced_tactics": [{"tactic": "rw [\u2190 id_apply (R := R) m, \u2190 h, comp_apply, hm, g.map_zero]", "annotated_tactic": ["rw [\u2190 <a>id_apply</a> (R := R) m, \u2190 h, <a>comp_apply</a>, hm, g.map_zero]", [{"full_name": "LinearMap.id_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [274, 9], "def_end_pos": [274, 17]}, {"full_name": "LinearMap.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 19]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nK : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\nV : Type u_10\nV\u2082 : Type u_11\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : Semiring R\u2082\ninst\u271d\u00b9\u00b9 : Semiring R\u2083\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u2077 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R\u2082 M\u2082\ninst\u271d\u2074 : Module R\u2083 M\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c4\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u00b3 : RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083\nF : Type u_12\ninst\u271d\u00b2 : FunLike F M M\u2082\ninst\u271d\u00b9 : SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2081] M\nh : comp g f = id\nm : M\nhm : f m = 0\n\u22a2 m = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Totient.lean", "full_name": "Nat.totient_even", "start": [129, 1], "end": [135, 98], "traced_tactics": [{"tactic": "haveI : Fact (1 < n) := \u27e8one_lt_two.trans hn\u27e9", "annotated_tactic": ["haveI : <a>Fact</a> (1 < n) := \u27e8one_lt_two.trans hn\u27e9", [{"full_name": "Fact", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [114, 7], "def_end_pos": [114, 11]}]], "state_before": "n : \u2115\nhn : 2 < n\n\u22a2 Even (\u03c6 n)", "state_after": "n : \u2115\nhn : 2 < n\nthis : Fact (1 < n)\n\u22a2 Even (\u03c6 n)"}, {"tactic": "haveI : NeZero n := NeZero.of_gt hn", "annotated_tactic": ["haveI : <a>NeZero</a> n := <a>NeZero.of_gt</a> hn", [{"full_name": "NeZero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [25, 7], "def_end_pos": [25, 13]}, {"full_name": "NeZero.of_gt", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [301, 9], "def_end_pos": [301, 14]}]], "state_before": "n : \u2115\nhn : 2 < n\nthis : Fact (1 < n)\n\u22a2 Even (\u03c6 n)", "state_after": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 Even (\u03c6 n)"}, {"tactic": "suffices 2 = orderOf (-1 : (ZMod n)\u02e3) by\n  rw [\u2190 ZMod.card_units_eq_totient, even_iff_two_dvd, this]\n  exact orderOf_dvd_card", "annotated_tactic": ["suffices 2 = <a>orderOf</a> (-1 : (<a>ZMod</a> n)\u02e3) by\n    rw [\u2190 <a>ZMod.card_units_eq_totient</a>, <a>even_iff_two_dvd</a>, this]\n    exact <a>orderOf_dvd_card</a>", [{"full_name": "orderOf", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [154, 19], "def_end_pos": [154, 26]}, {"full_name": "ZMod", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Defs.lean", "def_pos": [94, 5], "def_end_pos": [94, 9]}, {"full_name": "ZMod.card_units_eq_totient", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Totient.lean", "def_pos": [117, 9], "def_end_pos": [117, 42]}, {"full_name": "even_iff_two_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Parity.lean", "def_pos": [282, 9], "def_end_pos": [282, 25]}, {"full_name": "orderOf_dvd_card", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [1015, 9], "def_end_pos": [1015, 25]}]], "state_before": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 Even (\u03c6 n)", "state_after": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 2 = orderOf (-1)"}, {"tactic": "rw [\u2190 orderOf_units, Units.coe_neg_one, orderOf_neg_one, ringChar.eq (ZMod n) n, if_neg hn.ne']", "annotated_tactic": ["rw [\u2190 <a>orderOf_units</a>, <a>Units.coe_neg_one</a>, <a>orderOf_neg_one</a>, <a>ringChar.eq</a> (<a>ZMod</a> n) n, <a>if_neg</a> hn.ne']", [{"full_name": "orderOf_units", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [384, 9], "def_end_pos": [384, 22]}, {"full_name": "Units.coe_neg_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Units.lean", "def_pos": [42, 19], "def_end_pos": [42, 30]}, {"full_name": "orderOf_neg_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharP/Two.lean", "def_pos": [135, 9], "def_end_pos": [135, 24]}, {"full_name": "ringChar.eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharP/Basic.lean", "def_pos": [243, 9], "def_end_pos": [243, 11]}, {"full_name": "ZMod", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Defs.lean", "def_pos": [94, 5], "def_end_pos": [94, 9]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}]], "state_before": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 2 = orderOf (-1)", "state_after": "no goals"}, {"tactic": "rw [\u2190 ZMod.card_units_eq_totient, even_iff_two_dvd, this]", "annotated_tactic": ["rw [\u2190 <a>ZMod.card_units_eq_totient</a>, <a>even_iff_two_dvd</a>, this]", [{"full_name": "ZMod.card_units_eq_totient", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Totient.lean", "def_pos": [117, 9], "def_end_pos": [117, 42]}, {"full_name": "even_iff_two_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Parity.lean", "def_pos": [282, 9], "def_end_pos": [282, 25]}]], "state_before": "n : \u2115\nhn : 2 < n\nthis\u271d\u00b9 : Fact (1 < n)\nthis\u271d : NeZero n\nthis : 2 = orderOf (-1)\n\u22a2 Even (\u03c6 n)", "state_after": "n : \u2115\nhn : 2 < n\nthis\u271d\u00b9 : Fact (1 < n)\nthis\u271d : NeZero n\nthis : 2 = orderOf (-1)\n\u22a2 orderOf (-1) \u2223 Fintype.card (ZMod n)\u02e3"}, {"tactic": "exact orderOf_dvd_card", "annotated_tactic": ["exact <a>orderOf_dvd_card</a>", [{"full_name": "orderOf_dvd_card", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [1015, 9], "def_end_pos": [1015, 25]}]], "state_before": "n : \u2115\nhn : 2 < n\nthis\u271d\u00b9 : Fact (1 < n)\nthis\u271d : NeZero n\nthis : 2 = orderOf (-1)\n\u22a2 orderOf (-1) \u2223 Fintype.card (ZMod n)\u02e3", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Continuum.lean", "full_name": "Cardinal.lift_continuum", "start": [42, 1], "end": [43, 73], "traced_tactics": [{"tactic": "rw [\u2190 two_power_aleph0, lift_two_power, lift_aleph0, two_power_aleph0]", "annotated_tactic": ["rw [\u2190 <a>two_power_aleph0</a>, <a>lift_two_power</a>, <a>lift_aleph0</a>, <a>two_power_aleph0</a>]", [{"full_name": "Cardinal.two_power_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Continuum.lean", "def_pos": [37, 9], "def_end_pos": [37, 25]}, {"full_name": "Cardinal.lift_two_power", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [651, 9], "def_end_pos": [651, 23]}, {"full_name": "Cardinal.lift_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1287, 9], "def_end_pos": [1287, 20]}, {"full_name": "Cardinal.two_power_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Continuum.lean", "def_pos": [37, 9], "def_end_pos": [37, 25]}]], "state_before": "\u22a2 lift.{v, u_1} \ud835\udd20 = \ud835\udd20", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.mk_le_mk", "start": [190, 1], "end": [192, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Iterate.lean", "full_name": "Function.involutive_iff_iter_2_eq_id", "start": [251, 1], "end": [252, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.cofinite.limsup_set_eq", "start": [1219, 1], "end": [1220, 79], "traced_tactics": [{"tactic": "simp only [\u2190 cofinite.blimsup_true s, cofinite.blimsup_set_eq, true_and_iff]", "annotated_tactic": ["simp only [\u2190 cofinite.blimsup_true s, <a>cofinite.blimsup_set_eq</a>, <a>true_and_iff</a>]", [{"full_name": "Filter.cofinite.blimsup_set_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean", "def_pos": [1200, 9], "def_end_pos": [1200, 32]}, {"full_name": "true_and_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [140, 9], "def_end_pos": [140, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\n\ud835\udcd5 : Filter \u03b9\na : \u03b1\n\u22a2 limsup s cofinite = {x | Set.Infinite {n | x \u2208 s n}}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Basic.lean", "full_name": "Module.eq_zero_of_zero_eq_one", "start": [198, 1], "end": [199, 48], "traced_tactics": [{"tactic": "rw [\u2190 one_smul R x, \u2190 zero_eq_one, zero_smul]", "annotated_tactic": ["rw [\u2190 <a>one_smul</a> R x, \u2190 zero_eq_one, <a>zero_smul</a>]", [{"full_name": "one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [481, 9], "def_end_pos": [481, 17]}, {"full_name": "zero_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}]], "state_before": "\u03b1 : Type u_1\nR : Type u_2\nk : Type u_3\nS : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nr s : R\nx y : M\nzero_eq_one : 0 = 1\n\u22a2 x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_dite_of_false", "start": [1409, 1], "end": [1412, 80], "traced_tactics": [{"tactic": "refine prod_bij' (fun x hx => \u27e8x, hx\u27e9) (fun x _ \u21a6 x) ?_ ?_ ?_ ?_ ?_ <;> aesop", "annotated_tactic": ["refine <a>prod_bij'</a> (fun x hx => \u27e8x, hx\u27e9) (fun x _ \u21a6 x) ?_ ?_ ?_ ?_ ?_ <;> aesop", [{"full_name": "Finset.prod_bij'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [640, 9], "def_end_pos": [640, 18]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\np : \u03b1 \u2192 Prop\nhp : DecidablePred p\nh : \u2200 x \u2208 s, \u00acp x\nf : (x : \u03b1) \u2192 p x \u2192 \u03b2\ng : (x : \u03b1) \u2192 \u00acp x \u2192 \u03b2\n\u22a2 (\u220f x in s, if hx : p x then f x hx else g x hx) = \u220f x : { x // x \u2208 s }, g \u2191x \u22ef", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "continuous_iff_le_induced", "start": [678, 1], "end": [680, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Support.lean", "full_name": "image_eq_one_of_nmem_mulTSupport", "start": [69, 1], "end": [70, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Ultrafilter.lean", "full_name": "Ultrafilter.empty_not_mem", "start": [166, 1], "end": [167, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "Substring.Valid.atEnd", "start": [1049, 1], "end": [1050, 74], "traced_tactics": [{"tactic": "simp [h.atEnd, h.toString]", "annotated_tactic": ["simp [h.atEnd, h.toString]", []], "state_before": "p : Nat\nx\u271d : Substring\nh\u271d : Valid x\u271d\nw\u271d\u00b2 w\u271d\u00b9 w\u271d : List Char\nh : ValidFor w\u271d\u00b2 w\u271d\u00b9 w\u271d x\u271d\n\u22a2 Substring.atEnd x\u271d { byteIdx := p } = true \u2194 p = utf8ByteSize (toString x\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "dist_div_eq_dist_mul_left", "start": [506, 1], "end": [507, 47], "traced_tactics": [{"tactic": "rw [\u2190 dist_mul_right _ _ b, div_mul_cancel']", "annotated_tactic": ["rw [\u2190 <a>dist_mul_right</a> _ _ b, <a>div_mul_cancel'</a>]", [{"full_name": "dist_mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/IsometricSMul.lean", "def_pos": [372, 9], "def_end_pos": [372, 23]}, {"full_name": "div_mul_cancel'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [808, 9], "def_end_pos": [808, 24]}]], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b2 : SeminormedGroup E\ninst\u271d\u00b9 : SeminormedGroup F\ninst\u271d : SeminormedGroup G\ns : Set E\na\u271d a\u2081 a\u2082 b\u271d b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\na b c : E\n\u22a2 dist (a / b) c = dist a (c * b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean", "full_name": "SimpleGraph.sdiff_eq_deleteEdges", "start": [928, 1], "end": [930, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b9 : Sort u_1\nV : Type u\nG\u271d : SimpleGraph V\na b c u v w : V\ne : Sym2 V\nG G' : SimpleGraph V\n\u22a2 G \\ G' = deleteEdges G (edgeSet G')", "state_after": "case Adj.h.h.a\n\u03b9 : Sort u_1\nV : Type u\nG\u271d : SimpleGraph V\na b c u v w : V\ne : Sym2 V\nG G' : SimpleGraph V\nx\u271d\u00b9 x\u271d : V\n\u22a2 (G \\ G').Adj x\u271d\u00b9 x\u271d \u2194 (deleteEdges G (edgeSet G')).Adj x\u271d\u00b9 x\u271d"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case Adj.h.h.a\n\u03b9 : Sort u_1\nV : Type u\nG\u271d : SimpleGraph V\na b c u v w : V\ne : Sym2 V\nG G' : SimpleGraph V\nx\u271d\u00b9 x\u271d : V\n\u22a2 (G \\ G').Adj x\u271d\u00b9 x\u271d \u2194 (deleteEdges G (edgeSet G')).Adj x\u271d\u00b9 x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/EventuallyConst.lean", "full_name": "Filter.eventuallyConst_atTop_nat", "start": [157, 1], "end": [164, 48], "traced_tactics": [{"tactic": "rw [eventuallyConst_atTop]", "annotated_tactic": ["rw [<a>eventuallyConst_atTop</a>]", [{"full_name": "Filter.eventuallyConst_atTop", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/EventuallyConst.lean", "def_pos": [152, 7], "def_end_pos": [152, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nl : Filter \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nf : \u2115 \u2192 \u03b1\n\u22a2 EventuallyConst f atTop \u2194 \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 f (m + 1) = f m", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nl : Filter \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nf : \u2115 \u2192 \u03b1\n\u22a2 (\u2203 i, \u2200 (j : \u2115), i \u2264 j \u2192 f j = f i) \u2194 \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 f (m + 1) = f m"}, {"tactic": "refine exists_congr fun n \u21a6 \u27e8fun h m hm \u21a6 ?_, fun h m hm \u21a6 ?_\u27e9", "annotated_tactic": ["refine <a>exists_congr</a> fun n \u21a6 \u27e8fun h m hm \u21a6 ?_, fun h m hm \u21a6 ?_\u27e9", [{"full_name": "exists_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [143, 9], "def_end_pos": [143, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nl : Filter \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nf : \u2115 \u2192 \u03b1\n\u22a2 (\u2203 i, \u2200 (j : \u2115), i \u2264 j \u2192 f j = f i) \u2194 \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 f (m + 1) = f m", "state_after": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nl : Filter \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nf : \u2115 \u2192 \u03b1\nn : \u2115\nh : \u2200 (j : \u2115), n \u2264 j \u2192 f j = f n\nm : \u2115\nhm : n \u2264 m\n\u22a2 f (m + 1) = f m\n\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nl : Filter \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nf : \u2115 \u2192 \u03b1\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 f (m + 1) = f m\nm : \u2115\nhm : n \u2264 m\n\u22a2 f m = f n"}, {"tactic": "exact (h (m + 1) (hm.trans m.le_succ)).trans (h m hm).symm", "annotated_tactic": ["exact (h (m + 1) (hm.trans m.le_succ)).<a>trans</a> (h m hm).<a>symm</a>", [{"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nl : Filter \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nf : \u2115 \u2192 \u03b1\nn : \u2115\nh : \u2200 (j : \u2115), n \u2264 j \u2192 f j = f n\nm : \u2115\nhm : n \u2264 m\n\u22a2 f (m + 1) = f m", "state_after": "no goals"}, {"tactic": "induction m, hm using Nat.le_induction with\n| base => rfl\n| succ m hm ihm => exact (h m hm).trans ihm", "annotated_tactic": ["induction m, hm using <a>Nat.le_induction</a> with\n    | base => rfl\n    | <a>succ</a> m hm ihm => exact (h m hm).<a>trans</a> ihm", [{"full_name": "Nat.le_induction", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [478, 7], "def_end_pos": [478, 19]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}]], "state_before": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nl : Filter \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nf : \u2115 \u2192 \u03b1\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 f (m + 1) = f m\nm : \u2115\nhm : n \u2264 m\n\u22a2 f m = f n", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case refine_2.base\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nl : Filter \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nf : \u2115 \u2192 \u03b1\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 f (m + 1) = f m\nm : \u2115\n\u22a2 f n = f n", "state_after": "no goals"}, {"tactic": "exact (h m hm).trans ihm", "annotated_tactic": ["exact (h m hm).<a>trans</a> ihm", [{"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}]], "state_before": "case refine_2.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nl : Filter \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\nf : \u2115 \u2192 \u03b1\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 f (m + 1) = f m\nm\u271d m : \u2115\nhm : n \u2264 m\nihm : f m = f n\n\u22a2 f (m + 1) = f n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Logic.lean", "full_name": "not_or_of_not", "start": [184, 1], "end": [184, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "atTop_le_nhds_top", "start": [540, 1], "end": [541, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Ring.lean", "full_name": "hasSum_mul_right_iff", "start": [94, 1], "end": [95, 95], "traced_tactics": [{"tactic": "simpa only [mul_inv_cancel_right\u2080 h] using H.mul_right a\u2082\u207b\u00b9", "annotated_tactic": ["simpa only [<a>mul_inv_cancel_right\u2080</a> h] using H.mul_right a\u2082\u207b\u00b9", [{"full_name": "mul_inv_cancel_right\u2080", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [209, 9], "def_end_pos": [209, 30]}]], "state_before": "\u03b9 : Type u_1\n\u03ba : Type u_2\nR : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b2 : DivisionSemiring \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSemiring \u03b1\nf g : \u03b9 \u2192 \u03b1\na a\u2081 a\u2082 : \u03b1\nh : a\u2082 \u2260 0\nH : HasSum (fun i => f i * a\u2082) (a\u2081 * a\u2082)\n\u22a2 HasSum f a\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Degrees.lean", "full_name": "MvPolynomial.degrees_add", "start": [130, 1], "end": [132, 48], "traced_tactics": [{"tactic": "simp_rw [degrees_def]", "annotated_tactic": ["simp_rw [<a>degrees_def</a>]", [{"full_name": "MvPolynomial.degrees_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [86, 9], "def_end_pos": [86, 20]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np\u271d q\u271d : MvPolynomial \u03c3 R\ninst\u271d : DecidableEq \u03c3\np q : MvPolynomial \u03c3 R\n\u22a2 degrees (p + q) \u2264 degrees p \u2294 degrees q", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np\u271d q\u271d : MvPolynomial \u03c3 R\ninst\u271d : DecidableEq \u03c3\np q : MvPolynomial \u03c3 R\n\u22a2 (Finset.sup (support (p + q)) fun s => toMultiset s) \u2264\n    (Finset.sup (support p) fun s => toMultiset s) \u2294 Finset.sup (support q) fun s => toMultiset s"}, {"tactic": "exact supDegree_add_le", "annotated_tactic": ["exact <a>supDegree_add_le</a>", [{"full_name": "AddMonoidAlgebra.supDegree_add_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Degree.lean", "def_pos": [237, 9], "def_end_pos": [237, 25]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np\u271d q\u271d : MvPolynomial \u03c3 R\ninst\u271d : DecidableEq \u03c3\np q : MvPolynomial \u03c3 R\n\u22a2 (Finset.sup (support (p + q)) fun s => toMultiset s) \u2264\n    (Finset.sup (support p) fun s => toMultiset s) \u2294 Finset.sup (support q) fun s => toMultiset s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "full_name": "aemeasurable_restrict_iff_comap_subtype", "start": [272, 1], "end": [274, 93], "traced_tactics": [{"tactic": "rw [\u2190 map_comap_subtype_coe hs, (MeasurableEmbedding.subtype_coe hs).aemeasurable_map_iff]", "annotated_tactic": ["rw [\u2190 <a>map_comap_subtype_coe</a> hs, (<a>MeasurableEmbedding.subtype_coe</a> hs).<a>aemeasurable_map_iff</a>]", [{"full_name": "map_comap_subtype_coe", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [953, 9], "def_end_pos": [953, 30]}, {"full_name": "MeasurableEmbedding.subtype_coe", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [1289, 9], "def_end_pos": [1289, 20]}, {"full_name": "MeasurableEmbedding.aemeasurable_map_iff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/AEMeasurable.lean", "def_pos": [256, 9], "def_end_pos": [256, 49]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\nR : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\nf\u271d g : \u03b1 \u2192 \u03b2\n\u03bc\u271d \u03bd : Measure \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 AEMeasurable f (Measure.restrict \u03bc s) \u2194 AEMeasurable (f \u2218 Subtype.val) (Measure.comap Subtype.val \u03bc)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Equiv.lean", "full_name": "RingEquiv.toNonUnitalRingHom_commutes", "start": [714, 1], "end": [716, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pairwise.lean", "full_name": "Set.PairwiseDisjoint.biUnion_finset", "start": [62, 1], "end": [71, 87], "traced_tactics": [{"tactic": "rintro a ha b hb hab", "annotated_tactic": ["rintro a ha b hb hab", []], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\n\u22a2 PairwiseDisjoint (\u22c3 i \u2208 s, \u2191(g i)) f", "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na : \u03b9\nha : a \u2208 \u22c3 i \u2208 s, \u2191(g i)\nb : \u03b9\nhb : b \u2208 \u22c3 i \u2208 s, \u2191(g i)\nhab : a \u2260 b\n\u22a2 (Disjoint on f) a b"}, {"tactic": "simp_rw [Set.mem_iUnion] at ha hb", "annotated_tactic": ["simp_rw [<a>Set.mem_iUnion</a>] at ha hb", [{"full_name": "Set.mem_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [272, 9], "def_end_pos": [272, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na : \u03b9\nha : a \u2208 \u22c3 i \u2208 s, \u2191(g i)\nb : \u03b9\nhb : b \u2208 \u22c3 i \u2208 s, \u2191(g i)\nhab : a \u2260 b\n\u22a2 (Disjoint on f) a b", "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nha : \u2203 i, \u2203 (_ : i \u2208 s), a \u2208 \u2191(g i)\nhb : \u2203 i, \u2203 (_ : i \u2208 s), b \u2208 \u2191(g i)\n\u22a2 (Disjoint on f) a b"}, {"tactic": "obtain \u27e8c, hc, ha\u27e9 := ha", "annotated_tactic": ["obtain \u27e8c, hc, ha\u27e9 := ha", []], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nha : \u2203 i, \u2203 (_ : i \u2208 s), a \u2208 \u2191(g i)\nhb : \u2203 i, \u2203 (_ : i \u2208 s), b \u2208 \u2191(g i)\n\u22a2 (Disjoint on f) a b", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nhb : \u2203 i, \u2203 (_ : i \u2208 s), b \u2208 \u2191(g i)\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\n\u22a2 (Disjoint on f) a b"}, {"tactic": "obtain \u27e8d, hd, hb\u27e9 := hb", "annotated_tactic": ["obtain \u27e8d, hd, hb\u27e9 := hb", []], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nhb : \u2203 i, \u2203 (_ : i \u2208 s), b \u2208 \u2191(g i)\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\n\u22a2 (Disjoint on f) a b", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\n\u22a2 (Disjoint on f) a b"}, {"tactic": "obtain hcd | hcd := eq_or_ne (g c) (g d)", "annotated_tactic": ["obtain hcd | hcd := <a>eq_or_ne</a> (g c) (g d)", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\n\u22a2 (Disjoint on f) a b", "state_after": "case intro.intro.intro.intro.inl\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\nhcd : g c = g d\n\u22a2 (Disjoint on f) a b\n\ncase intro.intro.intro.intro.inr\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\nhcd : g c \u2260 g d\n\u22a2 (Disjoint on f) a b"}, {"tactic": "exact hg d hd (by rwa [hcd] at ha) hb hab", "annotated_tactic": ["exact hg d hd (by rwa [hcd] at ha) hb hab", []], "state_before": "case intro.intro.intro.intro.inl\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\nhcd : g c = g d\n\u22a2 (Disjoint on f) a b", "state_after": "no goals"}, {"tactic": "rwa [hcd] at ha", "annotated_tactic": ["rwa [hcd] at ha", []], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\nhcd : g c = g d\n\u22a2 a \u2208 \u2191(g d)", "state_after": "no goals"}, {"tactic": "exact (hs hc hd (ne_of_apply_ne _ hcd)).mono (Finset.le_sup ha) (Finset.le_sup hb)", "annotated_tactic": ["exact (hs hc hd (<a>ne_of_apply_ne</a> _ hcd)).<a>mono</a> (<a>Finset.le_sup</a> ha) (<a>Finset.le_sup</a> hb)", [{"full_name": "ne_of_apply_ne", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [62, 9], "def_end_pos": [62, 23]}, {"full_name": "Disjoint.mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [71, 9], "def_end_pos": [71, 22]}, {"full_name": "Finset.le_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [111, 9], "def_end_pos": [111, 15]}, {"full_name": "Finset.le_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [111, 9], "def_end_pos": [111, 15]}]], "state_before": "case intro.intro.intro.intro.inr\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : PairwiseDisjoint s fun i' => sup (g i') f\nhg : \u2200 i \u2208 s, PairwiseDisjoint (\u2191(g i)) f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 \u2191(g c)\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 \u2191(g d)\nhcd : g c \u2260 g d\n\u22a2 (Disjoint on f) a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.set_eventuallyEq_iff_inf_principal", "start": [1864, 1], "end": [1866, 96], "traced_tactics": [{"tactic": "simp only [eventuallyLE_antisymm_iff, le_antisymm_iff, set_eventuallyLE_iff_inf_principal_le]", "annotated_tactic": ["simp only [<a>eventuallyLE_antisymm_iff</a>, <a>le_antisymm_iff</a>, <a>set_eventuallyLE_iff_inf_principal_le</a>]", [{"full_name": "Filter.eventuallyLE_antisymm_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1736, 9], "def_end_pos": [1736, 34]}, {"full_name": "le_antisymm_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [186, 9], "def_end_pos": [186, 24]}, {"full_name": "Filter.set_eventuallyLE_iff_inf_principal_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1858, 9], "def_end_pos": [1858, 46]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\ns t : Set \u03b1\nl : Filter \u03b1\n\u22a2 s =\u1da0[l] t \u2194 l \u2293 \ud835\udcdf s = l \u2293 \ud835\udcdf t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean", "full_name": "Nat.ord_proj_dvd_ord_proj_iff_dvd", "start": [558, 1], "end": [565, 47], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, fun hab p => ord_proj_dvd_ord_proj_of_dvd hb0 hab p\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, fun hab p => <a>ord_proj_dvd_ord_proj_of_dvd</a> hb0 hab p\u27e9", [{"full_name": "Nat.ord_proj_dvd_ord_proj_of_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean", "def_pos": [550, 9], "def_end_pos": [550, 37]}]], "state_before": "a\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 (\u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p) \u2194 a \u2223 b", "state_after": "a\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\n\u22a2 a \u2223 b"}, {"tactic": "rw [\u2190 factorization_le_iff_dvd ha0 hb0]", "annotated_tactic": ["rw [\u2190 <a>factorization_le_iff_dvd</a> ha0 hb0]", [{"full_name": "Nat.factorization_le_iff_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean", "def_pos": [409, 9], "def_end_pos": [409, 33]}]], "state_before": "a\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\n\u22a2 a \u2223 b", "state_after": "a\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\n\u22a2 factorization a \u2264 factorization b"}, {"tactic": "intro q", "annotated_tactic": ["intro q", []], "state_before": "a\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\n\u22a2 factorization a \u2264 factorization b", "state_after": "a\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\nq : \u2115\n\u22a2 (factorization a) q \u2264 (factorization b) q"}, {"tactic": "rcases le_or_lt q 1 with (hq_le | hq1)", "annotated_tactic": ["rcases <a>le_or_lt</a> q 1 with (hq_le | hq1)", [{"full_name": "le_or_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [334, 9], "def_end_pos": [334, 17]}]], "state_before": "a\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\nq : \u2115\n\u22a2 (factorization a) q \u2264 (factorization b) q", "state_after": "case inl\na\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\nq : \u2115\nhq_le : q \u2264 1\n\u22a2 (factorization a) q \u2264 (factorization b) q\n\ncase inr\na\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\nq : \u2115\nhq1 : 1 < q\n\u22a2 (factorization a) q \u2264 (factorization b) q"}, {"tactic": "exact (pow_dvd_pow_iff_le_right hq1).1 (h q)", "annotated_tactic": ["exact (<a>pow_dvd_pow_iff_le_right</a> hq1).1 (h q)", [{"full_name": "Nat.pow_dvd_pow_iff_le_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [934, 9], "def_end_pos": [934, 33]}]], "state_before": "case inr\na\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\nq : \u2115\nhq1 : 1 < q\n\u22a2 (factorization a) q \u2264 (factorization b) q", "state_after": "no goals"}, {"tactic": "interval_cases q <;> simp", "annotated_tactic": ["interval_cases q <;> simp", []], "state_before": "case inl\na\u271d b\u271d m n p a b : \u2115\nha0 : a \u2260 0\nhb0 : b \u2260 0\nh : \u2200 (p : \u2115), p ^ (factorization a) p \u2223 p ^ (factorization b) p\nq : \u2115\nhq_le : q \u2264 1\n\u22a2 (factorization a) q \u2264 (factorization b) q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.closedBall_add_closedBall_subset", "start": [788, 1], "end": [792, 58], "traced_tactics": [{"tactic": "rintro x \u27e8y\u2081, hy\u2081, y\u2082, hy\u2082, rfl\u27e9", "annotated_tactic": ["rintro x \u27e8y\u2081, hy\u2081, y\u2082, hy\u2082, rfl\u27e9", []], "state_before": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : SMul \ud835\udd5c E\np\u271d : Seminorm \ud835\udd5c E\nx y : E\nr : \u211d\np : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nx\u2081 x\u2082 : E\n\u22a2 closedBall p x\u2081 r\u2081 + closedBall p x\u2082 r\u2082 \u2286 closedBall p (x\u2081 + x\u2082) (r\u2081 + r\u2082)", "state_after": "case intro.intro.intro.intro\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : SMul \ud835\udd5c E\np\u271d : Seminorm \ud835\udd5c E\nx y : E\nr : \u211d\np : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nx\u2081 x\u2082 y\u2081 : E\nhy\u2081 : y\u2081 \u2208 closedBall p x\u2081 r\u2081\ny\u2082 : E\nhy\u2082 : y\u2082 \u2208 closedBall p x\u2082 r\u2082\n\u22a2 (fun x x_1 => x + x_1) y\u2081 y\u2082 \u2208 closedBall p (x\u2081 + x\u2082) (r\u2081 + r\u2082)"}, {"tactic": "rw [mem_closedBall, add_sub_add_comm]", "annotated_tactic": ["rw [<a>mem_closedBall</a>, <a>add_sub_add_comm</a>]", [{"full_name": "Seminorm.mem_closedBall", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [680, 9], "def_end_pos": [680, 23]}, {"full_name": "add_sub_add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [661, 3], "def_end_pos": [661, 14]}]], "state_before": "case intro.intro.intro.intro\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : SMul \ud835\udd5c E\np\u271d : Seminorm \ud835\udd5c E\nx y : E\nr : \u211d\np : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nx\u2081 x\u2082 y\u2081 : E\nhy\u2081 : y\u2081 \u2208 closedBall p x\u2081 r\u2081\ny\u2082 : E\nhy\u2082 : y\u2082 \u2208 closedBall p x\u2082 r\u2082\n\u22a2 (fun x x_1 => x + x_1) y\u2081 y\u2082 \u2208 closedBall p (x\u2081 + x\u2082) (r\u2081 + r\u2082)", "state_after": "case intro.intro.intro.intro\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : SMul \ud835\udd5c E\np\u271d : Seminorm \ud835\udd5c E\nx y : E\nr : \u211d\np : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nx\u2081 x\u2082 y\u2081 : E\nhy\u2081 : y\u2081 \u2208 closedBall p x\u2081 r\u2081\ny\u2082 : E\nhy\u2082 : y\u2082 \u2208 closedBall p x\u2082 r\u2082\n\u22a2 p (y\u2081 - x\u2081 + (y\u2082 - x\u2082)) \u2264 r\u2081 + r\u2082"}, {"tactic": "exact (map_add_le_add p _ _).trans (add_le_add hy\u2081 hy\u2082)", "annotated_tactic": ["exact (<a>map_add_le_add</a> p _ _).<a>trans</a> (<a>add_le_add</a> hy\u2081 hy\u2082)", [{"full_name": "SubadditiveHomClass.map_add_le_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Hom/Basic.lean", "def_pos": [86, 3], "def_end_pos": [86, 17]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "add_le_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [205, 32], "def_end_pos": [205, 42]}]], "state_before": "case intro.intro.intro.intro\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : SMul \ud835\udd5c E\np\u271d : Seminorm \ud835\udd5c E\nx y : E\nr : \u211d\np : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nx\u2081 x\u2082 y\u2081 : E\nhy\u2081 : y\u2081 \u2208 closedBall p x\u2081 r\u2081\ny\u2082 : E\nhy\u2082 : y\u2082 \u2208 closedBall p x\u2082 r\u2082\n\u22a2 p (y\u2081 - x\u2081 + (y\u2082 - x\u2082)) \u2264 r\u2081 + r\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Determinant.lean", "full_name": "LinearMap.det_eq_det_toMatrix_of_finset", "start": [194, 1], "end": [197, 67], "traced_tactics": [{"tactic": "have : \u2203 s : Finset M, Nonempty (Basis s A M) := \u27e8s, \u27e8b\u27e9\u27e9", "annotated_tactic": ["have : \u2203 s : <a>Finset</a> M, <a>Nonempty</a> (<a>Basis</a> s A M) := \u27e8s, \u27e8b\u27e9\u27e9", [{"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}, {"full_name": "Nonempty", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [704, 17], "def_end_pos": [704, 25]}, {"full_name": "Basis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [90, 11], "def_end_pos": [90, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\nM : Type u_2\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\nM' : Type u_3\ninst\u271d\u2077 : AddCommGroup M'\ninst\u271d\u2076 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b9 : Fintype \u03ba\ninst\u271d : DecidableEq M\ns : Finset M\nb : Basis { x // x \u2208 s } A M\nf : M \u2192\u2097[A] M\n\u22a2 LinearMap.det f = det ((toMatrix b b) f)", "state_after": "R : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\nM : Type u_2\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\nM' : Type u_3\ninst\u271d\u2077 : AddCommGroup M'\ninst\u271d\u2076 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b9 : Fintype \u03ba\ninst\u271d : DecidableEq M\ns : Finset M\nb : Basis { x // x \u2208 s } A M\nf : M \u2192\u2097[A] M\nthis : \u2203 s, Nonempty (Basis { x // x \u2208 s } A M)\n\u22a2 LinearMap.det f = det ((toMatrix b b) f)"}, {"tactic": "rw [LinearMap.coe_det, dif_pos, detAux_def'' _ b] <;> assumption", "annotated_tactic": ["rw [<a>LinearMap.coe_det</a>, <a>dif_pos</a>, <a>detAux_def''</a> _ b] <;> assumption", [{"full_name": "LinearMap.coe_det", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [178, 9], "def_end_pos": [178, 16]}, {"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}, {"full_name": "LinearMap.detAux_def''", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [145, 9], "def_end_pos": [145, 21]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2070 : CommRing R\nM : Type u_2\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\nM' : Type u_3\ninst\u271d\u2077 : AddCommGroup M'\ninst\u271d\u2076 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b9 : Fintype \u03ba\ninst\u271d : DecidableEq M\ns : Finset M\nb : Basis { x // x \u2208 s } A M\nf : M \u2192\u2097[A] M\nthis : \u2203 s, Nonempty (Basis { x // x \u2208 s } A M)\n\u22a2 LinearMap.det f = det ((toMatrix b b) f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "LinearIndependent.totalEquiv_apply_coe", "start": [883, 1], "end": [884, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Irreducible.dvd_irreducible_iff_associated", "start": [653, 1], "end": [655, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/WithTop.lean", "full_name": "WithBot.bot_lt_mul'", "start": [270, 1], "end": [271, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.real_smul_ofReal", "start": [276, 1], "end": [277, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Expand.lean", "full_name": "Polynomial.monic_expand_iff", "start": [179, 1], "end": [180, 44], "traced_tactics": [{"tactic": "simp only [Monic, leadingCoeff_expand hp]", "annotated_tactic": ["simp only [<a>Monic</a>, <a>leadingCoeff_expand</a> hp]", [{"full_name": "Polynomial.Monic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [79, 5], "def_end_pos": [79, 10]}, {"full_name": "Polynomial.leadingCoeff_expand", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Expand.lean", "def_pos": [175, 9], "def_end_pos": [175, 28]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\np\u271d q p : \u2115\nf : R[X]\nhp : 0 < p\n\u22a2 Monic ((expand R p) f) \u2194 Monic f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioc_subset_Icc_self", "start": [513, 1], "end": [513, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sym/Basic.lean", "full_name": "Sym.map_cons", "start": [402, 1], "end": [403, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Join.lean", "full_name": "List.join_filter_ne_nil", "start": [58, 1], "end": [60, 55], "traced_tactics": [{"tactic": "simp [join_filter_not_isEmpty, \u2190 isEmpty_iff_eq_nil]", "annotated_tactic": ["simp [<a>join_filter_not_isEmpty</a>, \u2190 <a>isEmpty_iff_eq_nil</a>]", [{"full_name": "List.join_filter_not_isEmpty", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Join.lean", "def_pos": [46, 9], "def_end_pos": [46, 32]}, {"full_name": "List.isEmpty_iff_eq_nil", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [617, 9], "def_end_pos": [617, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidablePred fun l => l \u2260 []\nL : List (List \u03b1)\n\u22a2 join (filter (fun l => decide (l \u2260 [])) L) = join L", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.preimage_add_const_Ico", "start": [197, 1], "end": [198, 25], "traced_tactics": [{"tactic": "simp [\u2190 Ici_inter_Iio]", "annotated_tactic": ["simp [\u2190 <a>Ici_inter_Iio</a>]", [{"full_name": "Set.Ici_inter_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [622, 9], "def_end_pos": [622, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedAddCommGroup \u03b1\na b c : \u03b1\n\u22a2 (fun x => x + a) \u207b\u00b9' Ico b c = Ico (b - a) (c - a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Monoid.lean", "full_name": "ContinuousMul.of_nhds_one", "start": [266, 1], "end": [294, 82], "traced_tactics": [{"tactic": "rw [continuous_iff_continuousAt]", "annotated_tactic": ["rw [<a>continuous_iff_continuousAt</a>]", [{"full_name": "continuous_iff_continuousAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1635, 9], "def_end_pos": [1635, 36]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\n\u22a2 Continuous fun p => p.1 * p.2", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\n\u22a2 \u2200 (x : M \u00d7 M), ContinuousAt (fun p => p.1 * p.2) x"}, {"tactic": "rintro \u27e8x\u2080, y\u2080\u27e9", "annotated_tactic": ["rintro \u27e8x\u2080, y\u2080\u27e9", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\n\u22a2 \u2200 (x : M \u00d7 M), ContinuousAt (fun p => p.1 * p.2) x", "state_after": "case mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (x\u2080, y\u2080)"}, {"tactic": "have key\u2082 : ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x := by\n  ext x\n  simp [mul_assoc]", "annotated_tactic": ["have key\u2082 : ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x := by\n      ext x\n      simp [<a>mul_assoc</a>]", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "case mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (x\u2080, y\u2080)", "state_after": "case mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\nkey\u2082 : ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x\n\u22a2 ContinuousAt (fun p => p.1 * p.2) (x\u2080, y\u2080)"}, {"tactic": "ext p", "annotated_tactic": ["ext p", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\n\u22a2 (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1", "state_after": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\np : M \u00d7 M\n\u22a2 x\u2080 * p.1 * (p.2 * y\u2080) = (((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1) p"}, {"tactic": "simp [uncurry, mul_assoc]", "annotated_tactic": ["simp [<a>uncurry</a>, <a>mul_assoc</a>]", [{"full_name": "Function.uncurry", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [224, 5], "def_end_pos": [224, 12]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\np : M \u00d7 M\n\u22a2 x\u2080 * p.1 * (p.2 * y\u2080) = (((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1) p", "state_after": "no goals"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\n\u22a2 ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x", "state_after": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\nx : M\n\u22a2 ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) x = x\u2080 * y\u2080 * x"}, {"tactic": "simp [mul_assoc]", "annotated_tactic": ["simp [<a>mul_assoc</a>]", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\nx : M\n\u22a2 ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) x = x\u2080 * y\u2080 * x", "state_after": "no goals"}, {"tactic": "rw [nhds_prod_eq]", "annotated_tactic": ["rw [<a>nhds_prod_eq</a>]", [{"full_name": "nhds_prod_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [534, 9], "def_end_pos": [534, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\nkey\u2082 : ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x\n\u22a2 map (uncurry fun x x_1 => x * x_1) (\ud835\udcdd (x\u2080, y\u2080)) = map (uncurry fun x x_1 => x * x_1) (\ud835\udcdd x\u2080 \u00d7\u02e2 \ud835\udcdd y\u2080)", "state_after": "no goals"}, {"tactic": "simp (config := { unfoldPartialApp := true }) only [uncurry]", "annotated_tactic": ["simp (config := { unfoldPartialApp := <a>true</a> }) only [<a>uncurry</a>]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}, {"full_name": "Function.uncurry", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [224, 5], "def_end_pos": [224, 12]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\nkey\u2082 : ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x\n\u22a2 map (uncurry fun x x_1 => x * x_1) (\ud835\udcdd x\u2080 \u00d7\u02e2 \ud835\udcdd y\u2080) = map (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1)", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\nkey\u2082 : ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x\n\u22a2 map (fun a => a.1 * a.2) (\ud835\udcdd x\u2080 \u00d7\u02e2 \ud835\udcdd y\u2080) = map (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1)"}, {"tactic": "simp_rw [hleft x\u2080, hright y\u2080, prod_map_map_eq, Filter.map_map, Function.comp_def]", "annotated_tactic": ["simp_rw [hleft x\u2080, hright y\u2080, <a>prod_map_map_eq</a>, <a>Filter.map_map</a>, <a>Function.comp_def</a>]", [{"full_name": "Filter.prod_map_map_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [336, 9], "def_end_pos": [336, 24]}, {"full_name": "Filter.map_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1992, 9], "def_end_pos": [1992, 16]}, {"full_name": "Function.comp_def", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [37, 9], "def_end_pos": [37, 26]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\nkey\u2082 : ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x\n\u22a2 map (fun a => a.1 * a.2) (\ud835\udcdd x\u2080 \u00d7\u02e2 \ud835\udcdd y\u2080) = map (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1)", "state_after": "no goals"}, {"tactic": "rw [key, \u2190 Filter.map_map]", "annotated_tactic": ["rw [key, \u2190 <a>Filter.map_map</a>]", [{"full_name": "Filter.map_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1992, 9], "def_end_pos": [1992, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\nkey\u2082 : ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x\n\u22a2 map (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) =\n    map ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) (map (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1))", "state_after": "no goals"}, {"tactic": "rw [\u2190 Filter.map_map, \u2190 hright, hleft y\u2080, Filter.map_map, key\u2082, \u2190 hleft]", "annotated_tactic": ["rw [\u2190 <a>Filter.map_map</a>, \u2190 hright, hleft y\u2080, <a>Filter.map_map</a>, key\u2082, \u2190 hleft]", [{"full_name": "Filter.map_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1992, 9], "def_end_pos": [1992, 16]}, {"full_name": "Filter.map_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1992, 9], "def_end_pos": [1992, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM\u271d : Type u_3\nN : Type u_4\nX : Type u_5\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace M\u271d\ninst\u271d\u00b3 : Mul M\u271d\ninst\u271d\u00b2 : ContinuousMul M\u271d\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : TopologicalSpace M\nhmul : Tendsto (uncurry fun x x_1 => x * x_1) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1)\nhleft : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)\nhright : \u2200 (x\u2080 : M), \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)\nx\u2080 y\u2080 : M\nkey : (fun p => x\u2080 * p.1 * (p.2 * y\u2080)) = ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) \u2218 uncurry fun x x_1 => x * x_1\nkey\u2082 : ((fun x => x\u2080 * x) \u2218 fun x => y\u2080 * x) = fun x => x\u2080 * y\u2080 * x\n\u22a2 map ((fun x => x\u2080 * x) \u2218 fun x => x * y\u2080) (\ud835\udcdd 1) = \ud835\udcdd (x\u2080 * y\u2080)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Bitwise.lean", "full_name": "Nat.bit_mod_two_eq_zero_iff", "start": [98, 1], "end": [101, 43], "traced_tactics": [{"tactic": "rw [bit_mod_two]", "annotated_tactic": ["rw [<a>bit_mod_two</a>]", [{"full_name": "Nat.bit_mod_two", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [93, 7], "def_end_pos": [93, 18]}]], "state_before": "f : Bool \u2192 Bool \u2192 Bool\na : Bool\nx : \u2115\n\u22a2 bit a x % 2 = 0 \u2194 (!a) = true", "state_after": "f : Bool \u2192 Bool \u2192 Bool\na : Bool\nx : \u2115\n\u22a2 (if a = true then 1 else 0) = 0 \u2194 (!a) = true"}, {"tactic": "split_ifs <;> simp_all", "annotated_tactic": ["split_ifs <;> simp_all", []], "state_before": "f : Bool \u2192 Bool \u2192 Bool\na : Bool\nx : \u2115\n\u22a2 (if a = true then 1 else 0) = 0 \u2194 (!a) = true", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Integer.lean", "full_name": "IsLocalization.isInteger_smul", "start": [65, 1], "end": [68, 56], "traced_tactics": [{"tactic": "rcases hb with \u27e8b', hb\u27e9", "annotated_tactic": ["rcases hb with \u27e8b', hb\u27e9", []], "state_before": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d : CommSemiring P\na : R\nb : S\nhb : IsInteger R b\n\u22a2 IsInteger R (a \u2022 b)", "state_after": "case intro\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d : CommSemiring P\na : R\nb : S\nb' : R\nhb : (algebraMap R S) b' = b\n\u22a2 IsInteger R (a \u2022 b)"}, {"tactic": "use a * b'", "annotated_tactic": ["use a * b'", []], "state_before": "case intro\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d : CommSemiring P\na : R\nb : S\nb' : R\nhb : (algebraMap R S) b' = b\n\u22a2 IsInteger R (a \u2022 b)", "state_after": "case h\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d : CommSemiring P\na : R\nb : S\nb' : R\nhb : (algebraMap R S) b' = b\n\u22a2 (algebraMap R S) (a * b') = a \u2022 b"}, {"tactic": "rw [\u2190 hb, (algebraMap R S).map_mul, Algebra.smul_def]", "annotated_tactic": ["rw [\u2190 hb, (<a>algebraMap</a> R S).<a>map_mul</a>, <a>Algebra.smul_def</a>]", [{"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "RingHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "Algebra.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}]], "state_before": "case h\nR : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\ninst\u271d\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d : CommSemiring P\na : R\nb : S\nb' : R\nhb : (algebraMap R S) b' = b\n\u22a2 (algebraMap R S) (a * b') = a \u2022 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.induction_on_min_value", "start": [1889, 1], "end": [1891, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Chain.lean", "full_name": "IsChain.mono", "start": [72, 1], "end": [73, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Block.lean", "full_name": "Matrix.blockDiag_map", "start": [528, 1], "end": [530, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ico_subset_Icc_union_Ioo", "start": [1593, 1], "end": [1594, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Sum.lean", "full_name": "Finset.map_inl_disjUnion_map_inr", "start": [60, 1], "end": [63, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/TensorProduct/Basic.lean", "full_name": "LinearMap.lTensor_smul", "start": [1215, 1], "end": [1216, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Hom.lean", "full_name": "NormedAddGroupHom.Equalizer.comm_sq\u2082", "start": [959, 1], "end": [961, 53], "traced_tactics": [{"tactic": "rw [comp_assoc, hf, \u2190 comp_assoc, hf', comp_assoc]", "annotated_tactic": ["rw [<a>comp_assoc</a>, hf, \u2190 <a>comp_assoc</a>, hf', <a>comp_assoc</a>]", [{"full_name": "NormedAddGroupHom.comp_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Hom.lean", "def_pos": [696, 9], "def_end_pos": [696, 19]}, {"full_name": "NormedAddGroupHom.comp_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Hom.lean", "def_pos": [696, 9], "def_end_pos": [696, 19]}, {"full_name": "NormedAddGroupHom.comp_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Hom.lean", "def_pos": [696, 9], "def_end_pos": [696, 19]}]], "state_before": "V : Type u_1\nW : Type u_2\nV\u2081 : Type u_3\nV\u2082 : Type u_4\nV\u2083 : Type u_5\ninst\u271d\u2077 : SeminormedAddCommGroup V\ninst\u271d\u2076 : SeminormedAddCommGroup W\ninst\u271d\u2075 : SeminormedAddCommGroup V\u2081\ninst\u271d\u2074 : SeminormedAddCommGroup V\u2082\ninst\u271d\u00b3 : SeminormedAddCommGroup V\u2083\nf : NormedAddGroupHom V W\nW\u2081 : Type u_6\nW\u2082 : Type u_7\nW\u2083 : Type u_8\ninst\u271d\u00b2 : SeminormedAddCommGroup W\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup W\u2082\ninst\u271d : SeminormedAddCommGroup W\u2083\ng : NormedAddGroupHom V W\nf\u2081 g\u2081 : NormedAddGroupHom V\u2081 W\u2081\nf\u2082 g\u2082 : NormedAddGroupHom V\u2082 W\u2082\nf\u2083 g\u2083 : NormedAddGroupHom V\u2083 W\u2083\n\u03c6 : NormedAddGroupHom V\u2081 V\u2082\n\u03c8 : NormedAddGroupHom W\u2081 W\u2082\n\u03c6' : NormedAddGroupHom V\u2082 V\u2083\n\u03c8' : NormedAddGroupHom W\u2082 W\u2083\nhf : NormedAddGroupHom.comp \u03c8 f\u2081 = NormedAddGroupHom.comp f\u2082 \u03c6\nhf' : NormedAddGroupHom.comp \u03c8' f\u2082 = NormedAddGroupHom.comp f\u2083 \u03c6'\n\u22a2 NormedAddGroupHom.comp (NormedAddGroupHom.comp \u03c8' \u03c8) f\u2081 = NormedAddGroupHom.comp f\u2083 (NormedAddGroupHom.comp \u03c6' \u03c6)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Nontrivial/Defs.lean", "full_name": "Decidable.exists_ne", "start": [45, 11], "end": [50, 26], "traced_tactics": [{"tactic": "rcases exists_pair_ne \u03b1 with \u27e8y, y', h\u27e9", "annotated_tactic": ["rcases <a>exists_pair_ne</a> \u03b1 with \u27e8y, y', h\u27e9", [{"full_name": "exists_pair_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [40, 9], "def_end_pos": [40, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nontrivial \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\n\u22a2 \u2203 y, y \u2260 x", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nontrivial \u03b1\ninst\u271d : DecidableEq \u03b1\nx y y' : \u03b1\nh : y \u2260 y'\n\u22a2 \u2203 y, y \u2260 x"}, {"tactic": "by_cases hx:x = y", "annotated_tactic": ["by_cases hx:x = y", []], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nontrivial \u03b1\ninst\u271d : DecidableEq \u03b1\nx y y' : \u03b1\nh : y \u2260 y'\n\u22a2 \u2203 y, y \u2260 x", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nontrivial \u03b1\ninst\u271d : DecidableEq \u03b1\nx y y' : \u03b1\nh : y \u2260 y'\nhx : x = y\n\u22a2 \u2203 y, y \u2260 x\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nontrivial \u03b1\ninst\u271d : DecidableEq \u03b1\nx y y' : \u03b1\nh : y \u2260 y'\nhx : \u00acx = y\n\u22a2 \u2203 y, y \u2260 x"}, {"tactic": "rw [\u2190 hx] at h", "annotated_tactic": ["rw [\u2190 hx] at h", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nontrivial \u03b1\ninst\u271d : DecidableEq \u03b1\nx y y' : \u03b1\nh : y \u2260 y'\nhx : x = y\n\u22a2 \u2203 y, y \u2260 x", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nontrivial \u03b1\ninst\u271d : DecidableEq \u03b1\nx y y' : \u03b1\nh : x \u2260 y'\nhx : x = y\n\u22a2 \u2203 y, y \u2260 x"}, {"tactic": "exact \u27e8y', h.symm\u27e9", "annotated_tactic": ["exact \u27e8y', h.symm\u27e9", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nontrivial \u03b1\ninst\u271d : DecidableEq \u03b1\nx y y' : \u03b1\nh : x \u2260 y'\nhx : x = y\n\u22a2 \u2203 y, y \u2260 x", "state_after": "no goals"}, {"tactic": "exact \u27e8y, Ne.symm hx\u27e9", "annotated_tactic": ["exact \u27e8y, <a>Ne.symm</a> hx\u27e9", [{"full_name": "Ne.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [702, 9], "def_end_pos": [702, 16]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nontrivial \u03b1\ninst\u271d : DecidableEq \u03b1\nx y y' : \u03b1\nh : y \u2260 y'\nhx : \u00acx = y\n\u22a2 \u2203 y, y \u2260 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dual.lean", "full_name": "Submodule.dualQuotEquivDualAnnihilator_apply", "start": [1358, 1], "end": [1360, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.ceil_int", "start": [651, 1], "end": [652, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.card_roots", "start": [683, 1], "end": [687, 62], "traced_tactics": [{"tactic": "classical\nunfold roots\nrw [dif_neg hp0]\nexact (Classical.choose_spec (exists_multiset_roots hp0)).1", "annotated_tactic": ["classical\n  unfold <a>roots</a>\n  rw [<a>dif_neg</a> hp0]\n  exact (<a>Classical.choose_spec</a> (<a>exists_multiset_roots</a> hp0)).1", [{"full_name": "Polynomial.roots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [663, 19], "def_end_pos": [663, 24]}, {"full_name": "dif_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [949, 9], "def_end_pos": [949, 16]}, {"full_name": "Classical.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [21, 9], "def_end_pos": [21, 20]}, {"full_name": "Polynomial.exists_multiset_roots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [613, 9], "def_end_pos": [613, 30]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nhp0 : p \u2260 0\n\u22a2 \u2191(Multiset.card (roots p)) \u2264 degree p", "state_after": "no goals"}, {"tactic": "unfold roots", "annotated_tactic": ["unfold <a>roots</a>", [{"full_name": "Polynomial.roots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [663, 19], "def_end_pos": [663, 24]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nhp0 : p \u2260 0\n\u22a2 \u2191(Multiset.card (roots p)) \u2264 degree p", "state_after": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nhp0 : p \u2260 0\n\u22a2 \u2191(Multiset.card (if h : p = 0 then \u2205 else Classical.choose \u22ef)) \u2264 degree p"}, {"tactic": "rw [dif_neg hp0]", "annotated_tactic": ["rw [<a>dif_neg</a> hp0]", [{"full_name": "dif_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [949, 9], "def_end_pos": [949, 16]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nhp0 : p \u2260 0\n\u22a2 \u2191(Multiset.card (if h : p = 0 then \u2205 else Classical.choose \u22ef)) \u2264 degree p", "state_after": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nhp0 : p \u2260 0\n\u22a2 \u2191(Multiset.card (Classical.choose \u22ef)) \u2264 degree p"}, {"tactic": "exact (Classical.choose_spec (exists_multiset_roots hp0)).1", "annotated_tactic": ["exact (<a>Classical.choose_spec</a> (<a>exists_multiset_roots</a> hp0)).1", [{"full_name": "Classical.choose_spec", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [21, 9], "def_end_pos": [21, 20]}, {"full_name": "Polynomial.exists_multiset_roots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [613, 9], "def_end_pos": [613, 30]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nhp0 : p \u2260 0\n\u22a2 \u2191(Multiset.card (Classical.choose \u22ef)) \u2264 degree p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "AlgHom.coe_codRestrict", "start": [605, 1], "end": [607, 6], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "mathd_numbertheory_22", "start": [612, 1], "end": [614, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "b : \u2115\nh\u2080 : b < 10\nh\u2081 : Nat.sqrt (10 * b + 6) * Nat.sqrt (10 * b + 6) = 10 * b + 6\n\u22a2 b = 3 \u2228 b = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "xor_true", "start": [296, 9], "end": [297, 55], "traced_tactics": [{"tactic": "simp (config := { unfoldPartialApp := true }) [Xor']", "annotated_tactic": ["simp (config := { unfoldPartialApp := <a>true</a> }) [<a>Xor'</a>]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}, {"full_name": "Xor'", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [96, 5], "def_end_pos": [96, 9]}]], "state_before": "\u22a2 Xor' True = Not", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "OrderIso.isBoundedUnder_ge_comp", "start": [342, 1], "end": [344, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean", "full_name": "Set.pairwiseDisjoint_insert", "start": [281, 1], "end": [284, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "Submodule.fst_map_snd", "start": [635, 1], "end": [639, 37], "traced_tactics": [{"tactic": "rw [eq_bot_iff]", "annotated_tactic": ["rw [<a>eq_bot_iff</a>]", [{"full_name": "eq_bot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [331, 9], "def_end_pos": [331, 19]}]], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 map (snd R M M\u2082) (fst R M M\u2082) = \u22a5", "state_after": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 map (snd R M M\u2082) (fst R M M\u2082) \u2264 \u22a5"}, {"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 map (snd R M M\u2082) (fst R M M\u2082) \u2264 \u22a5", "state_after": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\u2082\n\u22a2 x \u2208 map (snd R M M\u2082) (fst R M M\u2082) \u2192 x \u2208 \u22a5"}, {"tactic": "simp only [fst, comap_bot, mem_map, mem_ker, snd_apply, eq_comm, Prod.exists, exists_eq_left,\n  exists_const, mem_bot, imp_self]", "annotated_tactic": ["simp only [<a>fst</a>, <a>comap_bot</a>, <a>mem_map</a>, <a>mem_ker</a>, <a>snd_apply</a>, <a>eq_comm</a>, <a>Prod.exists</a>, <a>exists_eq_left</a>,\n    <a>exists_const</a>, <a>mem_bot</a>, <a>imp_self</a>]", [{"full_name": "Submodule.fst", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [607, 5], "def_end_pos": [607, 8]}, {"full_name": "Submodule.comap_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [265, 9], "def_end_pos": [265, 18]}, {"full_name": "Submodule.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [89, 9], "def_end_pos": [89, 16]}, {"full_name": "LinearMap.mem_ker", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [65, 9], "def_end_pos": [65, 16]}, {"full_name": "LinearMap.snd_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [81, 9], "def_end_pos": [81, 18]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "Prod.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [40, 9], "def_end_pos": [40, 17]}, {"full_name": "exists_eq_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [215, 17], "def_end_pos": [215, 31]}, {"full_name": "exists_const", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [135, 17], "def_end_pos": [135, 29]}, {"full_name": "Submodule.mem_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [72, 9], "def_end_pos": [72, 16]}, {"full_name": "imp_self", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1406, 17], "def_end_pos": [1406, 25]}]], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\u2082\n\u22a2 x \u2208 map (snd R M M\u2082) (fst R M M\u2082) \u2192 x \u2208 \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.exp_lt_exp", "start": [1220, 1], "end": [1221, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "full_name": "AffineIsometry.injective", "start": [161, 11], "end": [162, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "Cycle.chain_range_succ", "start": [965, 8], "end": [967, 92], "traced_tactics": [{"tactic": "rw [range_succ, \u2190 coe_cons_eq_coe_append, chain_coe_cons, \u2190 range_succ, chain_range_succ]", "annotated_tactic": ["rw [<a>range_succ</a>, \u2190 <a>coe_cons_eq_coe_append</a>, <a>chain_coe_cons</a>, \u2190 <a>range_succ</a>, <a>chain_range_succ</a>]", [{"full_name": "List.range_succ", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2225, 9], "def_end_pos": [2225, 19]}, {"full_name": "Cycle.coe_cons_eq_coe_append", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [479, 9], "def_end_pos": [479, 31]}, {"full_name": "Cycle.chain_coe_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [937, 9], "def_end_pos": [937, 23]}, {"full_name": "List.range_succ", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2225, 9], "def_end_pos": [2225, 19]}, {"full_name": "List.chain_range_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Range.lean", "def_pos": [109, 9], "def_end_pos": [109, 25]}]], "state_before": "\u03b1 : Type u_1\nr : \u2115 \u2192 \u2115 \u2192 Prop\nn : \u2115\n\u22a2 Chain r \u2191(range (Nat.succ n)) \u2194 r n 0 \u2227 \u2200 m < n, r m (Nat.succ m)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean", "full_name": "PowerSeries.coeff_zero_X", "start": [275, 1], "end": [277, 66], "traced_tactics": [{"tactic": "erw [coeff, Finsupp.single_zero, X, MvPowerSeries.coeff_zero_X]", "annotated_tactic": ["erw [<a>coeff</a>, <a>Finsupp.single_zero</a>, <a>X</a>, <a>MvPowerSeries.coeff_zero_X</a>]", [{"full_name": "PowerSeries.coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerSeries/Basic.lean", "def_pos": [140, 5], "def_end_pos": [140, 10]}, {"full_name": "Finsupp.single_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [340, 9], "def_end_pos": [340, 20]}, {"full_name": "PowerSeries.X", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerSeries/Basic.lean", "def_pos": [215, 5], "def_end_pos": [215, 6]}, {"full_name": "MvPowerSeries.coeff_zero_X", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/MvPowerSeries/Basic.lean", "def_pos": [396, 9], "def_end_pos": [396, 21]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 (coeff R 0) X = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.inr_comp_pushoutSymmetry_inv", "start": [1613, 1], "end": [1614, 87], "traced_tactics": [{"tactic": "simp [Iso.comp_inv_eq]", "annotated_tactic": ["simp [<a>Iso.comp_inv_eq</a>]", [{"full_name": "CategoryTheory.Iso.comp_inv_eq", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [219, 9], "def_end_pos": [219, 20]}]], "state_before": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nW X Y Z : C\nf : X \u27f6 Y\ng : X \u27f6 Z\ninst\u271d : HasPushout f g\n\u22a2 pushout.inr \u226b (pushoutSymmetry f g).inv = pushout.inl", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "divp_mul_cancel", "start": [512, 1], "end": [513, 60], "traced_tactics": [{"tactic": "rw [Units.inv_mul, mul_one]", "annotated_tactic": ["rw [<a>Units.inv_mul</a>, <a>mul_one</a>]", [{"full_name": "Units.inv_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [249, 9], "def_end_pos": [249, 16]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na\u271d b c a : \u03b1\nu : \u03b1\u02e3\n\u22a2 a * (\u2191u\u207b\u00b9 * \u2191u) = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.aroots_X", "start": [1108, 1], "end": [1110, 34], "traced_tactics": [{"tactic": "rw [aroots_def, map_X, roots_X]", "annotated_tactic": ["rw [<a>aroots_def</a>, <a>map_X</a>, <a>roots_X</a>]", [{"full_name": "Polynomial.aroots_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1081, 9], "def_end_pos": [1081, 19]}, {"full_name": "Polynomial.map_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [720, 9], "def_end_pos": [720, 14]}, {"full_name": "Polynomial.roots_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\np q : R[X]\ninst\u271d\u00b3 : CommRing T\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra T S\n\u22a2 aroots X S = {0}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Kleene.lean", "full_name": "kstar_mul_le_self", "start": [215, 1], "end": [216, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.IsNormal.eq_iff_zero_and_succ", "start": [1990, 1], "end": [1999, 20], "traced_tactics": [{"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nh : f = g\n\u22a2 f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)", "state_after": "no goals"}, {"tactic": "induction' a using limitRecOn with _ _ _ ho H", "annotated_tactic": ["induction' a using <a>limitRecOn</a> with _ _ _ ho H", [{"full_name": "Ordinal.limitRecOn", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [309, 5], "def_end_pos": [309, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\na : Ordinal.{u}\n\u22a2 f a = g a", "state_after": "case H\u2081\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\n\u22a2 f 0 = g 0\n\ncase H\u2082\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\na\u271d : f o\u271d = g o\u271d\n\u22a2 f (succ o\u271d) = g (succ o\u271d)\n\ncase H\u2083\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\n\u22a2 f o\u271d = g o\u271d"}, {"tactic": "any_goals solve_by_elim", "annotated_tactic": ["any_goals solve_by_elim", []], "state_before": "case H\u2081\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\n\u22a2 f 0 = g 0\n\ncase H\u2082\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\na\u271d : f o\u271d = g o\u271d\n\u22a2 f (succ o\u271d) = g (succ o\u271d)\n\ncase H\u2083\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\n\u22a2 f o\u271d = g o\u271d", "state_after": "case H\u2083\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\n\u22a2 f o\u271d = g o\u271d"}, {"tactic": "rw [\u2190 IsNormal.bsup_eq.{u, u} hf ho, \u2190 IsNormal.bsup_eq.{u, u} hg ho]", "annotated_tactic": ["rw [\u2190 <a>IsNormal.bsup_eq</a>.{u, u} hf ho, \u2190 <a>IsNormal.bsup_eq</a>.{u, u} hg ho]", [{"full_name": "Ordinal.IsNormal.bsup_eq", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1962, 9], "def_end_pos": [1962, 25]}, {"full_name": "Ordinal.IsNormal.bsup_eq", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1962, 9], "def_end_pos": [1962, 25]}]], "state_before": "case H\u2083\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\n\u22a2 f o\u271d = g o\u271d", "state_after": "case H\u2083\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\n\u22a2 (Ordinal.bsup o\u271d fun x x_1 => f x) = Ordinal.bsup o\u271d fun x x_1 => g x"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case H\u2083\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\n\u22a2 (Ordinal.bsup o\u271d fun x x_1 => f x) = Ordinal.bsup o\u271d fun x x_1 => g x", "state_after": "case H\u2083.e_f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\n\u22a2 (fun x x_1 => f x) = fun x x_1 => g x"}, {"tactic": "ext b hb", "annotated_tactic": ["ext b hb", []], "state_before": "case H\u2083.e_f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\n\u22a2 (fun x x_1 => f x) = fun x x_1 => g x", "state_after": "case H\u2083.e_f.h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\nb : Ordinal.{u}\nhb : b < o\u271d\n\u22a2 f b = g b"}, {"tactic": "exact H b hb", "annotated_tactic": ["exact H b hb", []], "state_before": "case H\u2083.e_f.h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\nb : Ordinal.{u}\nhb : b < o\u271d\n\u22a2 f b = g b", "state_after": "no goals"}, {"tactic": "solve_by_elim", "annotated_tactic": ["solve_by_elim", []], "state_before": "case H\u2083\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nf g : Ordinal.{u} \u2192 Ordinal.{u}\nhf : IsNormal f\nhg : IsNormal g\nx\u271d : f 0 = g 0 \u2227 \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\nh\u2081 : f 0 = g 0\nh\u2082 : \u2200 (a : Ordinal.{u}), f a = g a \u2192 f (succ a) = g (succ a)\no\u271d : Ordinal.{u}\nho : IsLimit o\u271d\nH : \u2200 o' < o\u271d, f o' = g o'\n\u22a2 f o\u271d = g o\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Add.lean", "full_name": "derivWithin_neg", "start": [267, 1], "end": [268, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/ENat.lean", "full_name": "Cardinal.toENatAux_le_nat", "start": [173, 1], "end": [176, 72], "traced_tactics": [{"tactic": "cases lt_or_le x \u2135\u2080 with\n| inl hx => lift x to \u2115 using hx; simp\n| inr hx => simp [toENatAux_eq_top hx, (nat_lt_aleph0 n).trans_le hx]", "annotated_tactic": ["cases <a>lt_or_le</a> x \u2135\u2080 with\n  | <a>inl</a> hx => lift x to \u2115 using hx; simp\n  | <a>inr</a> hx => simp [<a>toENatAux_eq_top</a> hx, (<a>nat_lt_aleph0</a> n).<a>trans_le</a> hx]", [{"full_name": "lt_or_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [330, 9], "def_end_pos": [330, 17]}, {"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "Cardinal.toENatAux_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/ENat.lean", "def_pos": [159, 7], "def_end_pos": [159, 23]}, {"full_name": "Cardinal.nat_lt_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1527, 9], "def_end_pos": [1527, 22]}, {"full_name": "LT.lt.trans_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [145, 7], "def_end_pos": [145, 21]}]], "state_before": "x : Cardinal.{u_1}\nn : \u2115\n\u22a2 toENatAux x \u2264 \u2191n \u2194 x \u2264 \u2191n", "state_after": "no goals"}, {"tactic": "lift x to \u2115 using hx", "annotated_tactic": ["lift x to \u2115 using hx", []], "state_before": "case inl\nx : Cardinal.{u_1}\nn : \u2115\nhx : x < \u2135\u2080\n\u22a2 toENatAux x \u2264 \u2191n \u2194 x \u2264 \u2191n", "state_after": "case inl.intro\nn x : \u2115\n\u22a2 toENatAux \u2191x \u2264 \u2191n \u2194 \u2191x \u2264 \u2191n"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inl.intro\nn x : \u2115\n\u22a2 toENatAux \u2191x \u2264 \u2191n \u2194 \u2191x \u2264 \u2191n", "state_after": "no goals"}, {"tactic": "simp [toENatAux_eq_top hx, (nat_lt_aleph0 n).trans_le hx]", "annotated_tactic": ["simp [<a>toENatAux_eq_top</a> hx, (<a>nat_lt_aleph0</a> n).<a>trans_le</a> hx]", [{"full_name": "Cardinal.toENatAux_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/ENat.lean", "def_pos": [159, 7], "def_end_pos": [159, 23]}, {"full_name": "Cardinal.nat_lt_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1527, 9], "def_end_pos": [1527, 22]}, {"full_name": "LT.lt.trans_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [145, 7], "def_end_pos": [145, 21]}]], "state_before": "case inr\nx : Cardinal.{u_1}\nn : \u2115\nhx : \u2135\u2080 \u2264 x\n\u22a2 toENatAux x \u2264 \u2191n \u2194 x \u2264 \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "full_name": "Polynomial.integralNormalization_zero", "start": [44, 1], "end": [45, 31], "traced_tactics": [{"tactic": "simp [integralNormalization]", "annotated_tactic": ["simp [<a>integralNormalization</a>]", [{"full_name": "Polynomial.integralNormalization", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "def_pos": [38, 19], "def_end_pos": [38, 40]}]], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\n\u22a2 integralNormalization 0 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearForm/Hom.lean", "full_name": "BilinForm.toLin_symm", "start": [180, 1], "end": [182, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Cardinal.sup_lt_ord_of_isRegular", "start": [1070, 1], "end": [1072, 34], "traced_tactics": [{"tactic": "rwa [hc.cof_eq]", "annotated_tactic": ["rwa [hc.cof_eq]", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type (max u_2 u_3)\nf : \u03b9 \u2192 Ordinal.{max u_2 u_3}\nc : Cardinal.{max u_2 u_3}\nhc : IsRegular c\nh\u03b9 : #\u03b9 < c\n\u22a2 #\u03b9 < Ordinal.cof (ord c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Option.range_eq", "start": [1493, 1], "end": [1494, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.sSup_add", "start": [596, 1], "end": [597, 34], "traced_tactics": [{"tactic": "rw [sSup_eq_iSup, biSup_add hs]", "annotated_tactic": ["rw [<a>sSup_eq_iSup</a>, <a>biSup_add</a> hs]", [{"full_name": "sSup_eq_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [878, 9], "def_end_pos": [878, 21]}, {"full_name": "ENNReal.biSup_add", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [586, 9], "def_end_pos": [586, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns\u271d s : Set \u211d\u22650\u221e\nhs : Set.Nonempty s\n\u22a2 sSup s + a = \u2a06 b \u2208 s, b + a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearMap.coe_codRestrict", "start": [1042, 1], "end": [1044, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/TensorProduct/Basic.lean", "full_name": "TensorProduct.leftComm_tmul", "start": [1034, 1], "end": [1035, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/Compact.lean", "full_name": "IsCompact.image", "start": [119, 1], "end": [120, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Permutation.lean", "full_name": "List.map_permutationsAux", "start": [234, 1], "end": [240, 83], "traced_tactics": [{"tactic": "refine' permutationsAux.rec (by simp) _", "annotated_tactic": ["refine' <a>permutationsAux.rec</a> (by simp) _", [{"full_name": "List.permutationsAux.rec", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [224, 5], "def_end_pos": [224, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (ts is : List \u03b1), map (map f) (permutationsAux ts is) = permutationsAux (map f ts) (map f is)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (t : \u03b1) (ts is : List \u03b1),\n    map (map f) (permutationsAux ts (t :: is)) = permutationsAux (map f ts) (map f (t :: is)) \u2192\n      map (map f) (permutationsAux is []) = permutationsAux (map f is) (map f []) \u2192\n        map (map f) (permutationsAux (t :: ts) is) = permutationsAux (map f (t :: ts)) (map f is)"}, {"tactic": "introv IH1 IH2", "annotated_tactic": ["introv IH1 IH2", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (t : \u03b1) (ts is : List \u03b1),\n    map (map f) (permutationsAux ts (t :: is)) = permutationsAux (map f ts) (map f (t :: is)) \u2192\n      map (map f) (permutationsAux is []) = permutationsAux (map f is) (map f []) \u2192\n        map (map f) (permutationsAux (t :: ts) is) = permutationsAux (map f (t :: ts)) (map f is)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nt : \u03b1\nts is : List \u03b1\nIH1 : map (map f) (permutationsAux ts (t :: is)) = permutationsAux (map f ts) (map f (t :: is))\nIH2 : map (map f) (permutationsAux is []) = permutationsAux (map f is) (map f [])\n\u22a2 map (map f) (permutationsAux (t :: ts) is) = permutationsAux (map f (t :: ts)) (map f is)"}, {"tactic": "rw [map] at IH2", "annotated_tactic": ["rw [<a>map</a>] at IH2", [{"full_name": "List.map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [191, 19], "def_end_pos": [191, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nt : \u03b1\nts is : List \u03b1\nIH1 : map (map f) (permutationsAux ts (t :: is)) = permutationsAux (map f ts) (map f (t :: is))\nIH2 : map (map f) (permutationsAux is []) = permutationsAux (map f is) (map f [])\n\u22a2 map (map f) (permutationsAux (t :: ts) is) = permutationsAux (map f (t :: ts)) (map f is)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nt : \u03b1\nts is : List \u03b1\nIH1 : map (map f) (permutationsAux ts (t :: is)) = permutationsAux (map f ts) (map f (t :: is))\nIH2 : map (map f) (permutationsAux is []) = permutationsAux (map f is) []\n\u22a2 map (map f) (permutationsAux (t :: ts) is) = permutationsAux (map f (t :: ts)) (map f is)"}, {"tactic": "simp only [foldr_permutationsAux2, map_append, map, map_map_permutationsAux2, permutations,\n  bind_map, IH1, append_assoc, permutationsAux_cons, cons_bind, \u2190 IH2, map_bind]", "annotated_tactic": ["simp only [<a>foldr_permutationsAux2</a>, <a>map_append</a>, <a>map</a>, <a>map_map_permutationsAux2</a>, <a>permutations</a>,\n    <a>bind_map</a>, IH1, <a>append_assoc</a>, <a>permutationsAux_cons</a>, <a>cons_bind</a>, \u2190 IH2, <a>map_bind</a>]", [{"full_name": "List.foldr_permutationsAux2", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Permutation.lean", "def_pos": [176, 9], "def_end_pos": [176, 31]}, {"full_name": "List.map_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [120, 17], "def_end_pos": [120, 27]}, {"full_name": "List.map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [191, 19], "def_end_pos": [191, 22]}, {"full_name": "List.map_map_permutationsAux2", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Permutation.lean", "def_pos": [124, 9], "def_end_pos": [124, 33]}, {"full_name": "List.permutations", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [245, 5], "def_end_pos": [245, 17]}, {"full_name": "List.bind_map", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [380, 9], "def_end_pos": [380, 17]}, {"full_name": "List.append_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [143, 9], "def_end_pos": [143, 21]}, {"full_name": "List.permutationsAux_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Permutation.lean", "def_pos": [222, 9], "def_end_pos": [222, 29]}, {"full_name": "List.cons_bind", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [140, 17], "def_end_pos": [140, 26]}, {"full_name": "List.map_bind", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [166, 9], "def_end_pos": [166, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nt : \u03b1\nts is : List \u03b1\nIH1 : map (map f) (permutationsAux ts (t :: is)) = permutationsAux (map f ts) (map f (t :: is))\nIH2 : map (map f) (permutationsAux is []) = permutationsAux (map f is) []\n\u22a2 map (map f) (permutationsAux (t :: ts) is) = permutationsAux (map f (t :: ts)) (map f is)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (is : List \u03b1), map (map f) (permutationsAux [] is) = permutationsAux (map f []) (map f is)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Powerset.lean", "full_name": "Multiset.powersetCard_coe'", "start": [240, 1], "end": [241, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "measurableSet_Ioc", "start": [630, 1], "end": [631, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/LocalRing.lean", "full_name": "LocalRing.ResidueField.map_comp", "start": [420, 1], "end": [423, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "one_div_neg", "start": [78, 1], "end": [79, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Ring/Basic.lean", "full_name": "Mathlib.Tactic.Ring.toProd_pf", "start": [870, 1], "end": [871, 70], "traced_tactics": [{"tactic": "simp [*]", "annotated_tactic": ["simp [*]", []], "state_before": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\na a' : R\np : a = a'\n\u22a2 a = a' ^ Nat.rawCast 1 * Nat.rawCast 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.tail_cons", "start": [157, 1], "end": [159, 17], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\nx : \u03b1\nu : Fin m \u2192 \u03b1\n\u22a2 vecTail (vecCons x u) = u", "state_after": "case h\n\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\nx : \u03b1\nu : Fin m \u2192 \u03b1\nx\u271d : Fin m\n\u22a2 vecTail (vecCons x u) x\u271d = u x\u271d"}, {"tactic": "simp [vecTail]", "annotated_tactic": ["simp [<a>vecTail</a>]", [{"full_name": "Matrix.vecTail", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [98, 5], "def_end_pos": [98, 12]}]], "state_before": "case h\n\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\nx : \u03b1\nu : Fin m \u2192 \u03b1\nx\u271d : Fin m\n\u22a2 vecTail (vecCons x u) x\u271d = u x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.card_mul", "start": [704, 1], "end": [705, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Pointwise.lean", "full_name": "cthickening_closedBall", "start": [348, 1], "end": [351, 50], "traced_tactics": [{"tactic": "rw [\u2190 cthickening_singleton _ h\u03b4, cthickening_cthickening h\u03b5 h\u03b4,\n    cthickening_singleton _ (add_nonneg h\u03b5 h\u03b4)]", "annotated_tactic": ["rw [\u2190 <a>cthickening_singleton</a> _ h\u03b4, <a>cthickening_cthickening</a> h\u03b5 h\u03b4,\n      <a>cthickening_singleton</a> _ (<a>add_nonneg</a> h\u03b5 h\u03b4)]", [{"full_name": "Metric.cthickening_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [248, 9], "def_end_pos": [248, 30]}, {"full_name": "cthickening_cthickening", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Pointwise.lean", "def_pos": [321, 9], "def_end_pos": [321, 32]}, {"full_name": "Metric.cthickening_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [248, 9], "def_end_pos": [248, 30]}, {"full_name": "add_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [1092, 24], "def_end_pos": [1092, 34]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y z : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 cthickening \u03b5 (Metric.closedBall x \u03b4) = Metric.closedBall x (\u03b5 + \u03b4)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.lintegral_inter_add_diff", "start": [1361, 1], "end": [1363, 61], "traced_tactics": [{"tactic": "rw [\u2190 lintegral_add_measure, restrict_inter_add_diff _ hB]", "annotated_tactic": ["rw [\u2190 <a>lintegral_add_measure</a>, <a>restrict_inter_add_diff</a> _ hB]", [{"full_name": "MeasureTheory.lintegral_add_measure", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [618, 9], "def_end_pos": [618, 30]}, {"full_name": "MeasureTheory.Measure.restrict_inter_add_diff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [252, 9], "def_end_pos": [252, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nB : Set \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nA : Set \u03b1\nhB : MeasurableSet B\n\u22a2 \u222b\u207b (x : \u03b1) in A \u2229 B, f x \u2202\u03bc + \u222b\u207b (x : \u03b1) in A \\ B, f x \u2202\u03bc = \u222b\u207b (x : \u03b1) in A, f x \u2202\u03bc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/CommRing.lean", "full_name": "MvPolynomial.C_neg", "start": [67, 1], "end": [68, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.coe_iSup_of_directed", "start": [1316, 1], "end": [1318, 52], "traced_tactics": [{"tactic": "simp [mem_iSup_of_directed hS]", "annotated_tactic": ["simp [<a>mem_iSup_of_directed</a> hS]", [{"full_name": "Subgroup.mem_iSup_of_directed", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1300, 9], "def_end_pos": [1300, 29]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\nk : Set G\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\nS : \u03b9 \u2192 Subgroup G\nhS : Directed (fun x x_1 => x \u2264 x_1) S\nx : G\n\u22a2 x \u2208 \u2191(\u2a06 i, S i) \u2194 x \u2208 \u22c3 i, \u2191(S i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "measurableSet_Ici", "start": [544, 1], "end": [545, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "le_div_self", "start": [438, 1], "end": [439, 66], "traced_tactics": [{"tactic": "simpa only [div_one] using div_le_div_of_nonneg_left ha hb\u2080 hb\u2081", "annotated_tactic": ["simpa only [<a>div_one</a>] using <a>div_le_div_of_nonneg_left</a> ha hb\u2080 hb\u2081", [{"full_name": "div_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [408, 9], "def_end_pos": [408, 16]}, {"full_name": "div_le_div_of_nonneg_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [364, 7], "def_end_pos": [364, 32]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 \u2264 a\nhb\u2080 : 0 < b\nhb\u2081 : b \u2264 1\n\u22a2 a \u2264 a / b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "Filter.principal_isMeasurablyGenerated_iff", "start": [1991, 1], "end": [1997, 15], "traced_tactics": [{"tactic": "refine' \u27e8_, fun hs => \u27e8fun t ht => \u27e8s, mem_principal_self s, hs, ht\u27e9\u27e9\u27e9", "annotated_tactic": ["refine' \u27e8_, fun hs => \u27e8fun t ht => \u27e8s, <a>mem_principal_self</a> s, hs, ht\u27e9\u27e9\u27e9", [{"full_name": "Filter.mem_principal_self", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [311, 9], "def_end_pos": [311, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 IsMeasurablyGenerated (\ud835\udcdf s) \u2194 MeasurableSet s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 IsMeasurablyGenerated (\ud835\udcdf s) \u2192 MeasurableSet s"}, {"tactic": "rintro \u27e8hs\u27e9", "annotated_tactic": ["rintro \u27e8hs\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\n\u22a2 IsMeasurablyGenerated (\ud835\udcdf s) \u2192 MeasurableSet s", "state_after": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : \u2200 \u2983s_1 : Set \u03b1\u2984, s_1 \u2208 \ud835\udcdf s \u2192 \u2203 t \u2208 \ud835\udcdf s, MeasurableSet t \u2227 t \u2286 s_1\n\u22a2 MeasurableSet s"}, {"tactic": "rcases hs (mem_principal_self s) with \u27e8t, ht, htm, hts\u27e9", "annotated_tactic": ["rcases hs (<a>mem_principal_self</a> s) with \u27e8t, ht, htm, hts\u27e9", [{"full_name": "Filter.mem_principal_self", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [311, 9], "def_end_pos": [311, 27]}]], "state_before": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : \u2200 \u2983s_1 : Set \u03b1\u2984, s_1 \u2208 \ud835\udcdf s \u2192 \u2203 t \u2208 \ud835\udcdf s, MeasurableSet t \u2227 t \u2286 s_1\n\u22a2 MeasurableSet s", "state_after": "case mk.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t\u271d u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : \u2200 \u2983s_1 : Set \u03b1\u2984, s_1 \u2208 \ud835\udcdf s \u2192 \u2203 t \u2208 \ud835\udcdf s, MeasurableSet t \u2227 t \u2286 s_1\nt : Set \u03b1\nht : t \u2208 \ud835\udcdf s\nhtm : MeasurableSet t\nhts : t \u2286 s\n\u22a2 MeasurableSet s"}, {"tactic": "have : t = s := hts.antisymm ht", "annotated_tactic": ["have : t = s := hts.antisymm ht", []], "state_before": "case mk.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t\u271d u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : \u2200 \u2983s_1 : Set \u03b1\u2984, s_1 \u2208 \ud835\udcdf s \u2192 \u2203 t \u2208 \ud835\udcdf s, MeasurableSet t \u2227 t \u2286 s_1\nt : Set \u03b1\nht : t \u2208 \ud835\udcdf s\nhtm : MeasurableSet t\nhts : t \u2286 s\n\u22a2 MeasurableSet s", "state_after": "case mk.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t\u271d u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : \u2200 \u2983s_1 : Set \u03b1\u2984, s_1 \u2208 \ud835\udcdf s \u2192 \u2203 t \u2208 \ud835\udcdf s, MeasurableSet t \u2227 t \u2286 s_1\nt : Set \u03b1\nht : t \u2208 \ud835\udcdf s\nhtm : MeasurableSet t\nhts : t \u2286 s\nthis : t = s\n\u22a2 MeasurableSet s"}, {"tactic": "rwa [\u2190 this]", "annotated_tactic": ["rwa [\u2190 this]", []], "state_before": "case mk.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t\u271d u : Set \u03b1\ninst\u271d : MeasurableSpace \u03b1\ns : Set \u03b1\nhs : \u2200 \u2983s_1 : Set \u03b1\u2984, s_1 \u2208 \ud835\udcdf s \u2192 \u2203 t \u2208 \ud835\udcdf s, MeasurableSet t \u2227 t \u2286 s_1\nt : Set \u03b1\nht : t \u2208 \ud835\udcdf s\nhtm : MeasurableSet t\nhts : t \u2286 s\nthis : t = s\n\u22a2 MeasurableSet s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean", "full_name": "Polynomial.isNoetherianRing", "start": [944, 11], "end": [1017, 58], "traced_tactics": [{"tactic": "infer_instance", "annotated_tactic": ["infer_instance", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\ninst : IsNoetherianRing R\nI : Ideal R[X]\n\u22a2 IsNoetherian R R", "state_after": "no goals"}, {"tactic": "refine' WellFounded.not_lt_min (wellFounded_submodule_gt R R) _ _ _", "annotated_tactic": ["refine' <a>WellFounded.not_lt_min</a> (<a>wellFounded_submodule_gt</a> R R) _ _ _", [{"full_name": "WellFounded.not_lt_min", "def_path": ".lake/packages/mathlib/Mathlib/Order/WellFounded.lean", "def_pos": [76, 9], "def_end_pos": [76, 19]}, {"full_name": "wellFounded_submodule_gt", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Noetherian.lean", "def_pos": [340, 9], "def_end_pos": [340, 33]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nk : \u2115\nh : N < k\nx : R\nhx : x \u2208 Ideal.leadingCoeffNth I k\nhxm : x \u2209 M\nthis : IsNoetherian R R\n\u22a2 \u00acM < Ideal.leadingCoeffNth I k", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nk : \u2115\nh : N < k\nx : R\nhx : x \u2208 Ideal.leadingCoeffNth I k\nhxm : x \u2209 M\nthis : IsNoetherian R R\n\u22a2 Ideal.leadingCoeffNth I k \u2208 Set.range (Ideal.leadingCoeffNth I)"}, {"tactic": "exact \u27e8k, rfl\u27e9", "annotated_tactic": ["exact \u27e8k, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nk : \u2115\nh : N < k\nx : R\nhx : x \u2208 Ideal.leadingCoeffNth I k\nhxm : x \u2209 M\nthis : IsNoetherian R R\n\u22a2 Ideal.leadingCoeffNth I k \u2208 Set.range (Ideal.leadingCoeffNth I)", "state_after": "no goals"}, {"tactic": "have : Submodule.span R[X] \u2191s = Ideal.span \u2191s := rfl", "annotated_tactic": ["have : <a>Submodule.span</a> R[X] \u2191s = <a>Ideal.span</a> \u2191s := <a>rfl</a>", [{"full_name": "Submodule.span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [49, 5], "def_end_pos": [49, 9]}, {"full_name": "Ideal.span", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [114, 5], "def_end_pos": [114, 9]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\n\u22a2 I \u2264 Submodule.span R[X] \u2191s", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\n\u22a2 I \u2264 Submodule.span R[X] \u2191s"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\n\u22a2 I \u2264 Submodule.span R[X] \u2191s", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\n\u22a2 I \u2264 Ideal.span \u2191s"}, {"tactic": "intro p hp", "annotated_tactic": ["intro p hp", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\n\u22a2 I \u2264 Ideal.span \u2191s", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "generalize hn : p.natDegree = k", "annotated_tactic": ["generalize hn : p.natDegree = k", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nk : \u2115\nhn : natDegree p = k\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "induction' k using Nat.strong_induction_on with k ih generalizing p", "annotated_tactic": ["induction' k using <a>Nat.strong_induction_on</a> with k ih generalizing p", [{"full_name": "Nat.strong_induction_on", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Lemmas.lean", "def_pos": [501, 19], "def_end_pos": [501, 38]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nk : \u2115\nhn : natDegree p = k\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "rcases le_or_lt k N with h | h", "annotated_tactic": ["rcases <a>le_or_lt</a> k N with h | h", [{"full_name": "le_or_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [334, 9], "def_end_pos": [334, 17]}]], "state_before": "case h\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inl\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : k \u2264 N\n\u22a2 p \u2208 Ideal.span \u2191s\n\ncase h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "subst k", "annotated_tactic": ["subst k", []], "state_before": "case h.inl\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : k \u2264 N\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inl\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nih : \u2200 m < natDegree p, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\nh : natDegree p \u2264 N\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "refine' hs2 \u27e8Polynomial.mem_degreeLE.2\n  (le_trans Polynomial.degree_le_natDegree <| WithBot.coe_le_coe.2 h), hp\u27e9", "annotated_tactic": ["refine' hs2 \u27e8<a>Polynomial.mem_degreeLE</a>.2\n            (<a>le_trans</a> <a>Polynomial.degree_le_natDegree</a> <| <a>WithBot.coe_le_coe</a>.2 h), hp\u27e9", [{"full_name": "Polynomial.mem_degreeLE", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Basic.lean", "def_pos": [67, 9], "def_end_pos": [67, 21]}, {"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "Polynomial.degree_le_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [169, 9], "def_end_pos": [169, 28]}, {"full_name": "WithBot.coe_le_coe", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [218, 9], "def_end_pos": [218, 19]}]], "state_before": "case h.inl\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nih : \u2200 m < natDegree p, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\nh : natDegree p \u2264 N\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "no goals"}, {"tactic": "have hp0 : p \u2260 0 := by\n  rintro rfl\n  cases hn\n  exact Nat.not_lt_zero _ h", "annotated_tactic": ["have hp0 : p \u2260 0 := by\n            rintro rfl\n            cases hn\n            exact <a>Nat.not_lt_zero</a> _ h", [{"full_name": "Nat.not_lt_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1641, 9], "def_end_pos": [1641, 24]}]], "state_before": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "have : (0 : R) \u2260 1 := by\n  intro h\n  apply hp0\n  ext i\n  refine' (mul_one _).symm.trans _\n  rw [\u2190 h, mul_zero]\n  rfl", "annotated_tactic": ["have : (0 : R) \u2260 1 := by\n            intro h\n            apply hp0\n            ext i\n            refine' (<a>mul_one</a> _).symm.trans _\n            rw [\u2190 h, <a>mul_zero</a>]\n            rfl", [{"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}]], "state_before": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis : 0 \u2260 1\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "haveI : Nontrivial R := \u27e8\u27e80, 1, this\u27e9\u27e9", "annotated_tactic": ["haveI : <a>Nontrivial</a> R := \u27e8\u27e80, 1, this\u27e9\u27e9", [{"full_name": "Nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [31, 7], "def_end_pos": [31, 17]}]], "state_before": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis : 0 \u2260 1\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "have : p.leadingCoeff \u2208 I.leadingCoeffNth N := by\n  rw [HN]\n  exact hm2 k ((I.mem_leadingCoeffNth _ _).2\n    \u27e8_, hp, hn \u25b8 Polynomial.degree_le_natDegree, rfl\u27e9)", "annotated_tactic": ["have : p.leadingCoeff \u2208 I.leadingCoeffNth N := by\n            rw [HN]\n            exact hm2 k ((I.mem_leadingCoeffNth _ _).2\n              \u27e8_, hp, hn \u25b8 <a>Polynomial.degree_le_natDegree</a>, <a>rfl</a>\u27e9)", [{"full_name": "Polynomial.degree_le_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [169, 9], "def_end_pos": [169, 28]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nthis : leadingCoeff p \u2208 Ideal.leadingCoeffNth I N\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "rw [I.mem_leadingCoeffNth] at this", "annotated_tactic": ["rw [I.mem_leadingCoeffNth] at this", []], "state_before": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nthis : leadingCoeff p \u2208 Ideal.leadingCoeffNth I N\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nthis : \u2203 p_1 \u2208 I, degree p_1 \u2264 \u2191N \u2227 leadingCoeff p_1 = leadingCoeff p\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "rcases this with \u27e8q, hq, hdq, hlqp\u27e9", "annotated_tactic": ["rcases this with \u27e8q, hq, hdq, hlqp\u27e9", []], "state_before": "case h.inr\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nthis : \u2203 p_1 \u2208 I, degree p_1 \u2264 \u2191N \u2227 leadingCoeff p_1 = leadingCoeff p\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "have hq0 : q \u2260 0 := by\n  intro H\n  rw [\u2190 Polynomial.leadingCoeff_eq_zero] at H\n  rw [hlqp, Polynomial.leadingCoeff_eq_zero] at H\n  exact hp0 H", "annotated_tactic": ["have hq0 : q \u2260 0 := by\n            intro H\n            rw [\u2190 <a>Polynomial.leadingCoeff_eq_zero</a>] at H\n            rw [hlqp, <a>Polynomial.leadingCoeff_eq_zero</a>] at H\n            exact hp0 H", [{"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [678, 9], "def_end_pos": [678, 29]}, {"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [678, 9], "def_end_pos": [678, 29]}]], "state_before": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "have h2 : p.leadingCoeff = (q * Polynomial.X ^ (k - q.natDegree)).leadingCoeff := by\n  rw [\u2190 hlqp, Polynomial.leadingCoeff_mul_X_pow]", "annotated_tactic": ["have h2 : p.leadingCoeff = (q * <a>Polynomial.X</a> ^ (k - q.natDegree)).<a>leadingCoeff</a> := by\n            rw [\u2190 hlqp, <a>Polynomial.leadingCoeff_mul_X_pow</a>]", [{"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.leadingCoeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [74, 5], "def_end_pos": [74, 17]}, {"full_name": "Polynomial.leadingCoeff_mul_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1077, 9], "def_end_pos": [1077, 31]}]], "state_before": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "have := Polynomial.degree_sub_lt h1 hp0 h2", "annotated_tactic": ["have := <a>Polynomial.degree_sub_lt</a> h1 hp0 h2", [{"full_name": "Polynomial.degree_sub_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1426, 9], "def_end_pos": [1426, 22]}]], "state_before": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < degree p\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "rw [Polynomial.degree_eq_natDegree hp0] at this", "annotated_tactic": ["rw [<a>Polynomial.degree_eq_natDegree</a> hp0] at this", [{"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}]], "state_before": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < degree p\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\n\u22a2 p \u2208 Ideal.span \u2191s"}, {"tactic": "rw [\u2190 sub_add_cancel p (q * Polynomial.X ^ (k - q.natDegree))]", "annotated_tactic": ["rw [\u2190 <a>sub_add_cancel</a> p (q * <a>Polynomial.X</a> ^ (k - q.natDegree))]", [{"full_name": "sub_add_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [807, 30], "def_end_pos": [807, 44]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}]], "state_before": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\n\u22a2 p \u2208 Ideal.span \u2191s", "state_after": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\n\u22a2 p - q * X ^ (k - natDegree q) + q * X ^ (k - natDegree q) \u2208 Ideal.span \u2191s"}, {"tactic": "refine' (Ideal.span \u2191s).add_mem _ ((Ideal.span \u2191s).mul_mem_right _ _)", "annotated_tactic": ["refine' (<a>Ideal.span</a> \u2191s).<a>add_mem</a> _ ((<a>Ideal.span</a> \u2191s).<a>mul_mem_right</a> _ _)", [{"full_name": "Ideal.span", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [114, 5], "def_end_pos": [114, 9]}, {"full_name": "Ideal.add_mem", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [62, 19], "def_end_pos": [62, 26]}, {"full_name": "Ideal.span", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [114, 5], "def_end_pos": [114, 9]}, {"full_name": "Ideal.mul_mem_right", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [570, 9], "def_end_pos": [570, 22]}]], "state_before": "case h.inr.intro.intro.intro\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\n\u22a2 p - q * X ^ (k - natDegree q) + q * X ^ (k - natDegree q) \u2208 Ideal.span \u2191s", "state_after": "case h.inr.intro.intro.intro.refine'_1\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\n\u22a2 p - q * X ^ (k - natDegree q) \u2208 Ideal.span \u2191s\n\ncase h.inr.intro.intro.intro.refine'_2\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\n\u22a2 q \u2208 Ideal.span \u2191s"}, {"tactic": "exact hs2 \u27e8Polynomial.mem_degreeLE.2 hdq, hq\u27e9", "annotated_tactic": ["exact hs2 \u27e8<a>Polynomial.mem_degreeLE</a>.2 hdq, hq\u27e9", [{"full_name": "Polynomial.mem_degreeLE", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Basic.lean", "def_pos": [67, 9], "def_end_pos": [67, 21]}]], "state_before": "case h.inr.intro.intro.intro.refine'_2\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\n\u22a2 q \u2208 Ideal.span \u2191s", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\n\u22a2 p \u2260 0", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\nh : N < k\nhp : 0 \u2208 I\nhn : natDegree 0 = k\n\u22a2 False"}, {"tactic": "cases hn", "annotated_tactic": ["cases hn", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\nh : N < k\nhp : 0 \u2208 I\nhn : natDegree 0 = k\n\u22a2 False", "state_after": "case refl\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nhp : 0 \u2208 I\nih : \u2200 m < natDegree 0, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\nh : N < natDegree 0\n\u22a2 False"}, {"tactic": "exact Nat.not_lt_zero _ h", "annotated_tactic": ["exact <a>Nat.not_lt_zero</a> _ h", [{"full_name": "Nat.not_lt_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1641, 9], "def_end_pos": [1641, 24]}]], "state_before": "case refl\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nhp : 0 \u2208 I\nih : \u2200 m < natDegree 0, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\nh : N < natDegree 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\n\u22a2 0 \u2260 1", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\n\u22a2 False"}, {"tactic": "apply hp0", "annotated_tactic": ["apply hp0", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\n\u22a2 False", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\n\u22a2 p = 0"}, {"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\n\u22a2 p = 0", "state_after": "case a\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\ni : \u2115\n\u22a2 coeff p i = coeff 0 i"}, {"tactic": "refine' (mul_one _).symm.trans _", "annotated_tactic": ["refine' (<a>mul_one</a> _).symm.trans _", [{"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "case a\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\ni : \u2115\n\u22a2 coeff p i = coeff 0 i", "state_after": "case a\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\ni : \u2115\n\u22a2 coeff p i * 1 = coeff 0 i"}, {"tactic": "rw [\u2190 h, mul_zero]", "annotated_tactic": ["rw [\u2190 h, <a>mul_zero</a>]", [{"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}]], "state_before": "case a\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\ni : \u2115\n\u22a2 coeff p i * 1 = coeff 0 i", "state_after": "case a\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\ni : \u2115\n\u22a2 0 = coeff 0 i"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case a\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh\u271d : N < k\nhp0 : p \u2260 0\nh : 0 = 1\ni : \u2115\n\u22a2 0 = coeff 0 i", "state_after": "no goals"}, {"tactic": "rw [HN]", "annotated_tactic": ["rw [HN]", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\n\u22a2 leadingCoeff p \u2208 Ideal.leadingCoeffNth I N", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\n\u22a2 leadingCoeff p \u2208 M"}, {"tactic": "exact hm2 k ((I.mem_leadingCoeffNth _ _).2\n  \u27e8_, hp, hn \u25b8 Polynomial.degree_le_natDegree, rfl\u27e9)", "annotated_tactic": ["exact hm2 k ((I.mem_leadingCoeffNth _ _).2\n              \u27e8_, hp, hn \u25b8 <a>Polynomial.degree_le_natDegree</a>, <a>rfl</a>\u27e9)", [{"full_name": "Polynomial.degree_le_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [169, 9], "def_end_pos": [169, 28]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\n\u22a2 leadingCoeff p \u2208 M", "state_after": "no goals"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\n\u22a2 q \u2260 0", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nH : q = 0\n\u22a2 False"}, {"tactic": "rw [\u2190 Polynomial.leadingCoeff_eq_zero] at H", "annotated_tactic": ["rw [\u2190 <a>Polynomial.leadingCoeff_eq_zero</a>] at H", [{"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [678, 9], "def_end_pos": [678, 29]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nH : q = 0\n\u22a2 False", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nH : leadingCoeff q = 0\n\u22a2 False"}, {"tactic": "rw [hlqp, Polynomial.leadingCoeff_eq_zero] at H", "annotated_tactic": ["rw [hlqp, <a>Polynomial.leadingCoeff_eq_zero</a>] at H", [{"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [678, 9], "def_end_pos": [678, 29]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nH : leadingCoeff q = 0\n\u22a2 False", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nH : p = 0\n\u22a2 False"}, {"tactic": "exact hp0 H", "annotated_tactic": ["exact hp0 H", []], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nH : p = 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [Polynomial.degree_mul', Polynomial.degree_X_pow]", "annotated_tactic": ["rw [<a>Polynomial.degree_mul'</a>, <a>Polynomial.degree_X_pow</a>]", [{"full_name": "Polynomial.degree_mul'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [985, 9], "def_end_pos": [985, 20]}, {"full_name": "Polynomial.degree_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1338, 9], "def_end_pos": [1338, 21]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 degree p = degree (q * X ^ (k - natDegree q))", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 degree p = degree q + \u2191(k - natDegree q)\n\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 leadingCoeff q * leadingCoeff (X ^ (k - natDegree q)) \u2260 0"}, {"tactic": "rw [Polynomial.degree_eq_natDegree hp0, Polynomial.degree_eq_natDegree hq0]", "annotated_tactic": ["rw [<a>Polynomial.degree_eq_natDegree</a> hp0, <a>Polynomial.degree_eq_natDegree</a> hq0]", [{"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 degree p = degree q + \u2191(k - natDegree q)\n\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 leadingCoeff q * leadingCoeff (X ^ (k - natDegree q)) \u2260 0", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 \u2191(natDegree p) = \u2191(natDegree q) + \u2191(k - natDegree q)\n\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 leadingCoeff q * leadingCoeff (X ^ (k - natDegree q)) \u2260 0"}, {"tactic": "rw [\u2190 Nat.cast_add, add_tsub_cancel_of_le, hn]", "annotated_tactic": ["rw [\u2190 <a>Nat.cast_add</a>, <a>add_tsub_cancel_of_le</a>, hn]", [{"full_name": "Nat.cast_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [155, 9], "def_end_pos": [155, 17]}, {"full_name": "add_tsub_cancel_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [24, 9], "def_end_pos": [24, 30]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 \u2191(natDegree p) = \u2191(natDegree q) + \u2191(k - natDegree q)\n\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 leadingCoeff q * leadingCoeff (X ^ (k - natDegree q)) \u2260 0", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 natDegree q \u2264 k\n\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 leadingCoeff q * leadingCoeff (X ^ (k - natDegree q)) \u2260 0"}, {"tactic": "rw [Polynomial.leadingCoeff_X_pow, mul_one]", "annotated_tactic": ["rw [<a>Polynomial.leadingCoeff_X_pow</a>, <a>mul_one</a>]", [{"full_name": "Polynomial.leadingCoeff_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [870, 9], "def_end_pos": [870, 27]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 leadingCoeff q * leadingCoeff (X ^ (k - natDegree q)) \u2260 0", "state_after": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 leadingCoeff q \u2260 0"}, {"tactic": "exact mt Polynomial.leadingCoeff_eq_zero.1 hq0", "annotated_tactic": ["exact <a>mt</a> <a>Polynomial.leadingCoeff_eq_zero</a>.1 hq0", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [678, 9], "def_end_pos": [678, 29]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 leadingCoeff q \u2260 0", "state_after": "no goals"}, {"tactic": "refine' le_trans (Polynomial.natDegree_le_of_degree_le hdq) (le_of_lt h)", "annotated_tactic": ["refine' <a>le_trans</a> (<a>Polynomial.natDegree_le_of_degree_le</a> hdq) (<a>le_of_lt</a> h)", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "Polynomial.natDegree_le_of_degree_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [231, 35], "def_end_pos": [231, 60]}, {"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\n\u22a2 natDegree q \u2264 k", "state_after": "no goals"}, {"tactic": "rw [\u2190 hlqp, Polynomial.leadingCoeff_mul_X_pow]", "annotated_tactic": ["rw [\u2190 hlqp, <a>Polynomial.leadingCoeff_mul_X_pow</a>]", [{"full_name": "Polynomial.leadingCoeff_mul_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1077, 9], "def_end_pos": [1077, 31]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b9 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d : 0 \u2260 1\nthis : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\n\u22a2 leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))", "state_after": "no goals"}, {"tactic": "by_cases hpq : p - q * Polynomial.X ^ (k - q.natDegree) = 0", "annotated_tactic": ["by_cases hpq : p - q * <a>Polynomial.X</a> ^ (k - q.natDegree) = 0", [{"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}]], "state_before": "case h.inr.intro.intro.intro.refine'_1\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\n\u22a2 p - q * X ^ (k - natDegree q) \u2208 Ideal.span \u2191s", "state_after": "case pos\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\nhpq : p - q * X ^ (k - natDegree q) = 0\n\u22a2 p - q * X ^ (k - natDegree q) \u2208 Ideal.span \u2191s\n\ncase neg\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\nhpq : \u00acp - q * X ^ (k - natDegree q) = 0\n\u22a2 p - q * X ^ (k - natDegree q) \u2208 Ideal.span \u2191s"}, {"tactic": "refine' ih _ _ (I.sub_mem hp (I.mul_mem_right _ hq)) rfl", "annotated_tactic": ["refine' ih _ _ (I.sub_mem hp (I.mul_mem_right _ hq)) <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case neg\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\nhpq : \u00acp - q * X ^ (k - natDegree q) = 0\n\u22a2 p - q * X ^ (k - natDegree q) \u2208 Ideal.span \u2191s", "state_after": "case neg\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\nhpq : \u00acp - q * X ^ (k - natDegree q) = 0\n\u22a2 natDegree (p - q * X ^ (k - natDegree q)) < k"}, {"tactic": "rwa [Polynomial.degree_eq_natDegree hpq, Nat.cast_lt, hn] at this", "annotated_tactic": ["rwa [<a>Polynomial.degree_eq_natDegree</a> hpq, <a>Nat.cast_lt</a>, hn] at this", [{"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}, {"full_name": "Nat.cast_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Order.lean", "def_pos": [129, 9], "def_end_pos": [129, 16]}]], "state_before": "case neg\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\nhpq : \u00acp - q * X ^ (k - natDegree q) = 0\n\u22a2 natDegree (p - q * X ^ (k - natDegree q)) < k", "state_after": "no goals"}, {"tactic": "rw [hpq]", "annotated_tactic": ["rw [hpq]", []], "state_before": "case pos\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\nhpq : p - q * X ^ (k - natDegree q) = 0\n\u22a2 p - q * X ^ (k - natDegree q) \u2208 Ideal.span \u2191s", "state_after": "case pos\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\nhpq : p - q * X ^ (k - natDegree q) = 0\n\u22a2 0 \u2208 Ideal.span \u2191s"}, {"tactic": "exact Ideal.zero_mem _", "annotated_tactic": ["exact <a>Ideal.zero_mem</a> _", [{"full_name": "Ideal.zero_mem", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [58, 19], "def_end_pos": [58, 27]}]], "state_before": "case pos\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM\u271d : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : AddCommGroup M\u271d\ninst\u271d : Module R M\u271d\ninst : IsNoetherianRing R\nI : Ideal R[X]\nM : Submodule R R := WellFounded.min \u22ef (Set.range (Ideal.leadingCoeffNth I)) \u22ef\nhm : M \u2208 Set.range (Ideal.leadingCoeffNth I)\nN : \u2115\nHN : Ideal.leadingCoeffNth I N = M\ns : Finset R[X]\nhs : Submodule.span R \u2191s = Ideal.degreeLE I \u2191N\nhm2 : \u2200 (k : \u2115), Ideal.leadingCoeffNth I k \u2264 M\nhs2 : \u2200 {x : R[X]}, x \u2208 Ideal.degreeLE I \u2191N \u2192 x \u2208 Ideal.span \u2191s\nthis\u271d\u00b2 : Submodule.span R[X] \u2191s = Ideal.span \u2191s\nk : \u2115\nih : \u2200 m < k, \u2200 \u2983p : R[X]\u2984, p \u2208 I \u2192 natDegree p = m \u2192 p \u2208 Ideal.span \u2191s\np : R[X]\nhp : p \u2208 I\nhn : natDegree p = k\nh : N < k\nhp0 : p \u2260 0\nthis\u271d\u00b9 : 0 \u2260 1\nthis\u271d : Nontrivial R\nq : R[X]\nhq : q \u2208 I\nhdq : degree q \u2264 \u2191N\nhlqp : leadingCoeff q = leadingCoeff p\nhq0 : q \u2260 0\nh1 : degree p = degree (q * X ^ (k - natDegree q))\nh2 : leadingCoeff p = leadingCoeff (q * X ^ (k - natDegree q))\nthis : degree (p - q * X ^ (k - natDegree q)) < \u2191(natDegree p)\nhpq : p - q * X ^ (k - natDegree q) = 0\n\u22a2 0 \u2208 Ideal.span \u2191s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Quot.lean", "full_name": "Quotient.map\u2082'_mk''", "start": [767, 1], "end": [770, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/StdBasis.lean", "full_name": "Pi.basisFun_equivFun", "start": [290, 1], "end": [291, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Sqrt.lean", "full_name": "Real.sqrt_div_self", "start": [434, 1], "end": [434, 83], "traced_tactics": [{"tactic": "rw [sqrt_div_self', one_div]", "annotated_tactic": ["rw [<a>sqrt_div_self'</a>, <a>one_div</a>]", [{"full_name": "Real.sqrt_div_self'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Sqrt.lean", "def_pos": [431, 9], "def_end_pos": [431, 23]}, {"full_name": "one_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [386, 9], "def_end_pos": [386, 16]}]], "state_before": "x : \u211d\n\u22a2 sqrt x / x = (sqrt x)\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sym/Basic.lean", "full_name": "Sym.mem_fill_iff", "start": [550, 1], "end": [552, 62], "traced_tactics": [{"tactic": "rw [fill, mem_cast, mem_append_iff, or_comm, mem_replicate]", "annotated_tactic": ["rw [<a>fill</a>, <a>mem_cast</a>, <a>mem_append_iff</a>, <a>or_comm</a>, <a>mem_replicate</a>]", [{"full_name": "Sym.fill", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sym/Basic.lean", "def_pos": [541, 5], "def_end_pos": [541, 9]}, {"full_name": "Sym.mem_cast", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sym/Basic.lean", "def_pos": [504, 9], "def_end_pos": [504, 17]}, {"full_name": "Sym.mem_append_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sym/Basic.lean", "def_pos": [534, 9], "def_end_pos": [534, 23]}, {"full_name": "or_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [818, 9], "def_end_pos": [818, 16]}, {"full_name": "Sym.mem_replicate", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sym/Basic.lean", "def_pos": [296, 9], "def_end_pos": [296, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn n' m : \u2115\ns\u271d : Sym \u03b1 n\na\u271d b\u271d a b : \u03b1\ni : Fin (n + 1)\ns : Sym \u03b1 (n - \u2191i)\n\u22a2 a \u2208 fill b i s \u2194 \u2191i \u2260 0 \u2227 a = b \u2228 a \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Option/Basic.lean", "full_name": "Option.orElse_eq_none", "start": [393, 1], "end": [396, 39], "traced_tactics": [{"tactic": "cases o", "annotated_tactic": ["cases o", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no o' : Option \u03b1\n\u22a2 (HOrElse.hOrElse o fun x => o') = none \u2194 o = none \u2227 o' = none", "state_after": "case none\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\n\u22a2 (HOrElse.hOrElse none fun x => o') = none \u2194 none = none \u2227 o' = none\n\ncase some\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\nval\u271d : \u03b1\n\u22a2 (HOrElse.hOrElse (some val\u271d) fun x => o') = none \u2194 some val\u271d = none \u2227 o' = none"}, {"tactic": "simp only [true_and, none_orElse, eq_self_iff_true]", "annotated_tactic": ["simp only [<a>true_and</a>, <a>none_orElse</a>, <a>eq_self_iff_true</a>]", [{"full_name": "true_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [102, 17], "def_end_pos": [102, 25]}, {"full_name": "Option.none_orElse", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean", "def_pos": [185, 17], "def_end_pos": [185, 28]}, {"full_name": "eq_self_iff_true", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1368, 9], "def_end_pos": [1368, 25]}]], "state_before": "case none\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\n\u22a2 (HOrElse.hOrElse none fun x => o') = none \u2194 none = none \u2227 o' = none", "state_after": "no goals"}, {"tactic": "simp only [some_orElse, false_and]", "annotated_tactic": ["simp only [<a>some_orElse</a>, <a>false_and</a>]", [{"full_name": "Option.some_orElse", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean", "def_pos": [183, 17], "def_end_pos": [183, 28]}, {"full_name": "false_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [104, 17], "def_end_pos": [104, 26]}]], "state_before": "case some\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\nval\u271d : \u03b1\n\u22a2 (HOrElse.hOrElse (some val\u271d) fun x => o') = none \u2194 some val\u271d = none \u2227 o' = none", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "full_name": "MeasureTheory.SimpleFunc.pow_apply", "start": [611, 1], "end": [612, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/TotallyDisconnected.lean", "full_name": "isTotallyDisconnected_of_isTotallySeparated", "start": [203, 1], "end": [212, 33], "traced_tactics": [{"tactic": "intro t hts ht x x_in y y_in", "annotated_tactic": ["intro t hts ht x x_in y y_in", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns\u271d t u v s : Set \u03b1\nH : IsTotallySeparated s\n\u22a2 IsTotallyDisconnected s", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns\u271d t\u271d u v s : Set \u03b1\nH : IsTotallySeparated s\nt : Set \u03b1\nhts : t \u2286 s\nht : IsPreconnected t\nx : \u03b1\nx_in : x \u2208 t\ny : \u03b1\ny_in : y \u2208 t\n\u22a2 x = y"}, {"tactic": "by_contra h", "annotated_tactic": ["by_contra h", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns\u271d t\u271d u v s : Set \u03b1\nH : IsTotallySeparated s\nt : Set \u03b1\nhts : t \u2286 s\nht : IsPreconnected t\nx : \u03b1\nx_in : x \u2208 t\ny : \u03b1\ny_in : y \u2208 t\n\u22a2 x = y", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns\u271d t\u271d u v s : Set \u03b1\nH : IsTotallySeparated s\nt : Set \u03b1\nhts : t \u2286 s\nht : IsPreconnected t\nx : \u03b1\nx_in : x \u2208 t\ny : \u03b1\ny_in : y \u2208 t\nh : \u00acx = y\n\u22a2 False"}, {"tactic": "obtain\n  \u27e8u : Set \u03b1, v : Set \u03b1, hu : IsOpen u, hv : IsOpen v, hxu : x \u2208 u, hyv : y \u2208 v, hs : s \u2286 u \u222a v,\n    huv\u27e9 :=\n  H x (hts x_in) y (hts y_in) h", "annotated_tactic": ["obtain\n    \u27e8u : <a>Set</a> \u03b1, v : <a>Set</a> \u03b1, hu : <a>IsOpen</a> u, hv : <a>IsOpen</a> v, hxu : x \u2208 u, hyv : y \u2208 v, hs : s \u2286 u \u222a v,\n      huv\u27e9 :=\n    H x (hts x_in) y (hts y_in) h", [{"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "IsOpen", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [85, 5], "def_end_pos": [85, 11]}, {"full_name": "IsOpen", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [85, 5], "def_end_pos": [85, 11]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns\u271d t\u271d u v s : Set \u03b1\nH : IsTotallySeparated s\nt : Set \u03b1\nhts : t \u2286 s\nht : IsPreconnected t\nx : \u03b1\nx_in : x \u2208 t\ny : \u03b1\ny_in : y \u2208 t\nh : \u00acx = y\n\u22a2 False", "state_after": "case intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns\u271d t\u271d u\u271d v\u271d s : Set \u03b1\nH : IsTotallySeparated s\nt : Set \u03b1\nhts : t \u2286 s\nht : IsPreconnected t\nx : \u03b1\nx_in : x \u2208 t\ny : \u03b1\ny_in : y \u2208 t\nh : \u00acx = y\nu v : Set \u03b1\nhu : IsOpen u\nhv : IsOpen v\nhxu : x \u2208 u\nhyv : y \u2208 v\nhs : s \u2286 u \u222a v\nhuv : Disjoint u v\n\u22a2 False"}, {"tactic": "refine' (ht _ _ hu hv (hts.trans hs) \u27e8x, x_in, hxu\u27e9 \u27e8y, y_in, hyv\u27e9).ne_empty _", "annotated_tactic": ["refine' (ht _ _ hu hv (hts.trans hs) \u27e8x, x_in, hxu\u27e9 \u27e8y, y_in, hyv\u27e9).<a>ne_empty</a> _", [{"full_name": "Set.Nonempty.ne_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [596, 8], "def_end_pos": [596, 25]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns\u271d t\u271d u\u271d v\u271d s : Set \u03b1\nH : IsTotallySeparated s\nt : Set \u03b1\nhts : t \u2286 s\nht : IsPreconnected t\nx : \u03b1\nx_in : x \u2208 t\ny : \u03b1\ny_in : y \u2208 t\nh : \u00acx = y\nu v : Set \u03b1\nhu : IsOpen u\nhv : IsOpen v\nhxu : x \u2208 u\nhyv : y \u2208 v\nhs : s \u2286 u \u222a v\nhuv : Disjoint u v\n\u22a2 False", "state_after": "case intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns\u271d t\u271d u\u271d v\u271d s : Set \u03b1\nH : IsTotallySeparated s\nt : Set \u03b1\nhts : t \u2286 s\nht : IsPreconnected t\nx : \u03b1\nx_in : x \u2208 t\ny : \u03b1\ny_in : y \u2208 t\nh : \u00acx = y\nu v : Set \u03b1\nhu : IsOpen u\nhv : IsOpen v\nhxu : x \u2208 u\nhyv : y \u2208 v\nhs : s \u2286 u \u222a v\nhuv : Disjoint u v\n\u22a2 t \u2229 (u \u2229 v) = \u2205"}, {"tactic": "rw [huv.inter_eq, inter_empty]", "annotated_tactic": ["rw [huv.inter_eq, <a>inter_empty</a>]", [{"full_name": "Set.inter_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [899, 9], "def_end_pos": [899, 20]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d : TopologicalSpace \u03b1\ns\u271d t\u271d u\u271d v\u271d s : Set \u03b1\nH : IsTotallySeparated s\nt : Set \u03b1\nhts : t \u2286 s\nht : IsPreconnected t\nx : \u03b1\nx_in : x \u2208 t\ny : \u03b1\ny_in : y \u2208 t\nh : \u00acx = y\nu v : Set \u03b1\nhu : IsOpen u\nhv : IsOpen v\nhxu : x \u2208 u\nhyv : y \u2208 v\nhs : s \u2286 u \u222a v\nhuv : Disjoint u v\n\u22a2 t \u2229 (u \u2229 v) = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.IsCycleOn.range_zpow", "start": [946, 1], "end": [948, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.ceil_intCast", "start": [1222, 1], "end": [1223, 60], "traced_tactics": [{"tactic": "rw [ceil_le, Int.cast_le]", "annotated_tactic": ["rw [<a>ceil_le</a>, <a>Int.cast_le</a>]", [{"full_name": "Int.ceil_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [1187, 9], "def_end_pos": [1187, 16]}, {"full_name": "Int.cast_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [138, 9], "def_end_pos": [138, 16]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz\u271d : \u2124\na\u271d : \u03b1\nz a : \u2124\n\u22a2 \u2308\u2191z\u2309 \u2264 a \u2194 z \u2264 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "Monotone.const_mul'", "start": [1304, 1], "end": [1305, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "NonUnitalRingHom.coe_copy", "start": [155, 1], "end": [156, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/MvPolynomial.lean", "full_name": "Matrix.mvPolynomialX_mapMatrix_eval", "start": [57, 1], "end": [60, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "Odd.mul", "start": [409, 1], "end": [413, 37], "traced_tactics": [{"tactic": "rintro \u27e8m, rfl\u27e9 \u27e8n, rfl\u27e9", "annotated_tactic": ["rintro \u27e8m, rfl\u27e9 \u27e8n, rfl\u27e9", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n : \u03b1\n\u22a2 Odd m \u2192 Odd n \u2192 Odd (m * n)", "state_after": "case intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n : \u03b1\n\u22a2 Odd ((2 * m + 1) * (2 * n + 1))"}, {"tactic": "refine' \u27e82 * m * n + n + m, _\u27e9", "annotated_tactic": ["refine' \u27e82 * m * n + n + m, _\u27e9", []], "state_before": "case intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n : \u03b1\n\u22a2 Odd ((2 * m + 1) * (2 * n + 1))", "state_after": "case intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n : \u03b1\n\u22a2 (2 * m + 1) * (2 * n + 1) = 2 * (2 * m * n + n + m) + 1"}, {"tactic": "rw [mul_add, add_mul, mul_one, \u2190 add_assoc, one_mul, mul_assoc, \u2190 mul_add, \u2190 mul_add, \u2190 mul_assoc,\n  \u2190 Nat.cast_two, \u2190 Nat.cast_comm]", "annotated_tactic": ["rw [<a>mul_add</a>, <a>add_mul</a>, <a>mul_one</a>, \u2190 <a>add_assoc</a>, <a>one_mul</a>, <a>mul_assoc</a>, \u2190 <a>mul_add</a>, \u2190 <a>mul_add</a>, \u2190 <a>mul_assoc</a>,\n    \u2190 <a>Nat.cast_two</a>, \u2190 <a>Nat.cast_comm</a>]", [{"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "Nat.cast_two", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [201, 9], "def_end_pos": [201, 17]}, {"full_name": "Nat.cast_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Commute.lean", "def_pos": [33, 9], "def_end_pos": [33, 18]}]], "state_before": "case intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n : \u03b1\n\u22a2 (2 * m + 1) * (2 * n + 1) = 2 * (2 * m * n + n + m) + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/Compact.lean", "full_name": "Set.Infinite.exists_accPt_of_subset_isCompact", "start": [806, 1], "end": [809, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "measurable_pi_iff", "start": [906, 1], "end": [908, 60], "traced_tactics": [{"tactic": "simp_rw [measurable_iff_comap_le, MeasurableSpace.pi, MeasurableSpace.comap_iSup,\n  MeasurableSpace.comap_comp, Function.comp, iSup_le_iff]", "annotated_tactic": ["simp_rw [<a>measurable_iff_comap_le</a>, <a>MeasurableSpace.pi</a>, <a>MeasurableSpace.comap_iSup</a>,\n    <a>MeasurableSpace.comap_comp</a>, <a>Function.comp</a>, <a>iSup_le_iff</a>]", [{"full_name": "measurable_iff_comap_le", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [221, 9], "def_end_pos": [221, 32]}, {"full_name": "MeasurableSpace.pi", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [900, 10], "def_end_pos": [900, 28]}, {"full_name": "MeasurableSpace.comap_iSup", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [159, 9], "def_end_pos": [159, 19]}, {"full_name": "MeasurableSpace.comap_comp", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [120, 9], "def_end_pos": [120, 19]}, {"full_name": "Function.comp", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}, {"full_name": "iSup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [853, 9], "def_end_pos": [853, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns t u : Set \u03b1\n\u03c0 : \u03b4 \u2192 Type u_6\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : (a : \u03b4) \u2192 MeasurableSpace (\u03c0 a)\ninst\u271d : MeasurableSpace \u03b3\ng : \u03b1 \u2192 (a : \u03b4) \u2192 \u03c0 a\n\u22a2 Measurable g \u2194 \u2200 (a : \u03b4), Measurable fun x => g x a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.mem_one", "start": [82, 1], "end": [83, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.map_equiv_eq_comap_symm", "start": [1473, 1], "end": [1475, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/CharP/Basic.lean", "full_name": "CharP.ringChar_ne_one", "start": [485, 1], "end": [489, 40], "traced_tactics": [{"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "R : Type u_1\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : Nontrivial R\n\u22a2 ringChar R \u2260 1", "state_after": "R : Type u_1\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : Nontrivial R\nh : ringChar R = 1\n\u22a2 False"}, {"tactic": "apply zero_ne_one' R", "annotated_tactic": ["apply <a>zero_ne_one'</a> R", [{"full_name": "zero_ne_one'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [78, 7], "def_end_pos": [78, 19]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : Nontrivial R\nh : ringChar R = 1\n\u22a2 False", "state_after": "R : Type u_1\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : Nontrivial R\nh : ringChar R = 1\n\u22a2 0 = 1"}, {"tactic": "symm", "annotated_tactic": ["symm", []], "state_before": "R : Type u_1\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : Nontrivial R\nh : ringChar R = 1\n\u22a2 0 = 1", "state_after": "R : Type u_1\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : Nontrivial R\nh : ringChar R = 1\n\u22a2 1 = 0"}, {"tactic": "rw [\u2190 Nat.cast_one, ringChar.spec, h]", "annotated_tactic": ["rw [\u2190 <a>Nat.cast_one</a>, <a>ringChar.spec</a>, h]", [{"full_name": "Nat.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [150, 9], "def_end_pos": [150, 17]}, {"full_name": "ringChar.spec", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharP/Basic.lean", "def_pos": [238, 9], "def_end_pos": [238, 13]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : Nontrivial R\nh : ringChar R = 1\n\u22a2 1 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.eventually_ge_atTop", "start": [194, 1], "end": [195, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iInter_congr_Prop", "start": [171, 1], "end": [173, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/CauSeq/BigOperators.lean", "full_name": "IsCauSeq.geo_series", "start": [185, 1], "end": [201, 11], "traced_tactics": [{"tactic": "have hx1' : abv x \u2260 1 := fun h \u21a6 by simp [h, lt_irrefl] at hx1", "annotated_tactic": ["have hx1' : abv x \u2260 1 := fun h \u21a6 by simp [h, <a>lt_irrefl</a>] at hx1", [{"full_name": "lt_irrefl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [73, 9], "def_end_pos": [73, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\n\u22a2 IsCauSeq abv fun n => \u2211 m in range n, x ^ m", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\n\u22a2 IsCauSeq abv fun n => \u2211 m in range n, x ^ m"}, {"tactic": "refine of_abv ?_", "annotated_tactic": ["refine <a>of_abv</a> ?_", [{"full_name": "IsCauSeq.of_abv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/BigOperators.lean", "def_pos": [53, 7], "def_end_pos": [53, 13]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\n\u22a2 IsCauSeq abv fun n => \u2211 m in range n, x ^ m", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\n\u22a2 IsCauSeq abs fun m => \u2211 n in range m, abv (x ^ n)"}, {"tactic": "simp only [abv_pow abv, geom_sum_eq hx1']", "annotated_tactic": ["simp only [<a>abv_pow</a> abv, <a>geom_sum_eq</a> hx1']", [{"full_name": "IsAbsoluteValue.abv_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/AbsoluteValue.lean", "def_pos": [392, 9], "def_end_pos": [392, 16]}, {"full_name": "geom_sum_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GeomSum.lean", "def_pos": [276, 9], "def_end_pos": [276, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\n\u22a2 IsCauSeq abs fun m => \u2211 n in range m, abv (x ^ n)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\n\u22a2 IsCauSeq abs fun m => (abv x ^ m - 1) / (abv x - 1)"}, {"tactic": "conv in _ / _ => rw [\u2190 neg_div_neg_eq, neg_sub, neg_sub]", "annotated_tactic": ["conv in _ / _ => rw [\u2190 <a>neg_div_neg_eq</a>, <a>neg_sub</a>, <a>neg_sub</a>]", [{"full_name": "neg_div_neg_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Field/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 23]}, {"full_name": "neg_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [471, 3], "def_end_pos": [471, 14]}, {"full_name": "neg_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [471, 3], "def_end_pos": [471, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\n\u22a2 IsCauSeq abs fun m => (abv x ^ m - 1) / (abv x - 1)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\n\u22a2 IsCauSeq abs fun m => (1 - abv x ^ m) / (1 - abv x)"}, {"tactic": "have : 0 < 1 - abv x := sub_pos.2 hx1", "annotated_tactic": ["have : 0 < 1 - abv x := <a>sub_pos</a>.2 hx1", [{"full_name": "sub_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [886, 30], "def_end_pos": [886, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\n\u22a2 IsCauSeq abs fun m => (1 - abv x ^ m) / (1 - abv x)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\n\u22a2 IsCauSeq abs fun m => (1 - abv x ^ m) / (1 - abv x)"}, {"tactic": "refine' @of_mono_bounded _ _ _ _ ((1 : \u03b1) / (1 - abv x)) 0 _ _", "annotated_tactic": ["refine' @<a>of_mono_bounded</a> _ _ _ _ ((1 : \u03b1) / (1 - abv x)) 0 _ _", [{"full_name": "IsCauSeq.of_mono_bounded", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/BigOperators.lean", "def_pos": [180, 7], "def_end_pos": [180, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\n\u22a2 IsCauSeq abs fun m => (1 - abv x ^ m) / (1 - abv x)", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\n\u22a2 \u2200 n \u2265 0, |(1 - abv x ^ n) / (1 - abv x)| \u2264 1 / (1 - abv x)\n\ncase refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\n\u22a2 \u2200 n \u2265 0, (1 - abv x ^ n) / (1 - abv x) \u2264 (1 - abv x ^ Nat.succ n) / (1 - abv x)"}, {"tactic": "simp [h, lt_irrefl] at hx1", "annotated_tactic": ["simp [h, <a>lt_irrefl</a>] at hx1", [{"full_name": "lt_irrefl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [73, 9], "def_end_pos": [73, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nh : abv x = 1\n\u22a2 False", "state_after": "no goals"}, {"tactic": "intro n _", "annotated_tactic": ["intro n _", []], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\n\u22a2 \u2200 n \u2265 0, |(1 - abv x ^ n) / (1 - abv x)| \u2264 1 / (1 - abv x)", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 |(1 - abv x ^ n) / (1 - abv x)| \u2264 1 / (1 - abv x)"}, {"tactic": "rw [abs_of_nonneg]", "annotated_tactic": ["rw [<a>abs_of_nonneg</a>]", [{"full_name": "abs_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [94, 3], "def_end_pos": [94, 14]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 |(1 - abv x ^ n) / (1 - abv x)| \u2264 1 / (1 - abv x)", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 (1 - abv x ^ n) / (1 - abv x) \u2264 1 / (1 - abv x)\n\ncase refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 0 \u2264 (1 - abv x ^ n) / (1 - abv x)"}, {"tactic": "gcongr", "annotated_tactic": ["gcongr", []], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 (1 - abv x ^ n) / (1 - abv x) \u2264 1 / (1 - abv x)\n\ncase refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 0 \u2264 (1 - abv x ^ n) / (1 - abv x)", "state_after": "case refine'_1.hab\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 1 - abv x ^ n \u2264 1\n\ncase refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 0 \u2264 (1 - abv x ^ n) / (1 - abv x)"}, {"tactic": "refine' div_nonneg (sub_nonneg.2 _) (sub_nonneg.2 <| le_of_lt hx1)", "annotated_tactic": ["refine' <a>div_nonneg</a> (<a>sub_nonneg</a>.2 _) (<a>sub_nonneg</a>.2 <| <a>le_of_lt</a> hx1)", [{"full_name": "div_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [95, 9], "def_end_pos": [95, 19]}, {"full_name": "sub_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [720, 30], "def_end_pos": [720, 40]}, {"full_name": "sub_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [720, 30], "def_end_pos": [720, 40]}, {"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 0 \u2264 (1 - abv x ^ n) / (1 - abv x)", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 abv x ^ n \u2264 1"}, {"tactic": "exact pow_le_one _ (by positivity) hx1.le", "annotated_tactic": ["exact <a>pow_le_one</a> _ (by positivity) hx1.le", [{"full_name": "pow_le_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [181, 9], "def_end_pos": [181, 19]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 abv x ^ n \u2264 1", "state_after": "no goals"}, {"tactic": "exact sub_le_self _ (abv_pow abv x n \u25b8 abv_nonneg _ _)", "annotated_tactic": ["exact <a>sub_le_self</a> _ (<a>abv_pow</a> abv x n \u25b8 <a>abv_nonneg</a> _ _)", [{"full_name": "sub_le_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [371, 11], "def_end_pos": [371, 22]}, {"full_name": "IsAbsoluteValue.abv_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/AbsoluteValue.lean", "def_pos": [392, 9], "def_end_pos": [392, 16]}, {"full_name": "IsAbsoluteValue.abv_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/AbsoluteValue.lean", "def_pos": [314, 7], "def_end_pos": [314, 17]}]], "state_before": "case refine'_1.hab\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 1 - abv x ^ n \u2264 1", "state_after": "no goals"}, {"tactic": "positivity", "annotated_tactic": ["positivity", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 0 \u2264 abv x", "state_after": "no goals"}, {"tactic": "intro n _", "annotated_tactic": ["intro n _", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\n\u22a2 \u2200 n \u2265 0, (1 - abv x ^ n) / (1 - abv x) \u2264 (1 - abv x ^ Nat.succ n) / (1 - abv x)", "state_after": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 (1 - abv x ^ n) / (1 - abv x) \u2264 (1 - abv x ^ Nat.succ n) / (1 - abv x)"}, {"tactic": "rw [\u2190 one_mul (abv x ^ n), pow_succ]", "annotated_tactic": ["rw [\u2190 <a>one_mul</a> (abv x ^ n), <a>pow_succ</a>]", [{"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 (1 - abv x ^ n) / (1 - abv x) \u2264 (1 - abv x ^ Nat.succ n) / (1 - abv x)", "state_after": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 (1 - 1 * abv x ^ n) / (1 - abv x) \u2264 (1 - abv x * abv x ^ n) / (1 - abv x)"}, {"tactic": "gcongr", "annotated_tactic": ["gcongr", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nf g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : Nontrivial \u03b2\nx : \u03b2\nhx1 : abv x < 1\nhx1' : abv x \u2260 1\nthis : 0 < 1 - abv x\nn : \u2115\na\u271d : n \u2265 0\n\u22a2 (1 - 1 * abv x ^ n) / (1 - abv x) \u2264 (1 - abv x * abv x ^ n) / (1 - abv x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/Quiver/Path.lean", "full_name": "Quiver.Path.comp_inj_right", "start": [157, 1], "end": [158, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/WithZero/Defs.lean", "full_name": "WithZero.covariantClass_add_le", "start": [112, 11], "end": [127, 33], "traced_tactics": [{"tactic": "refine \u27e8fun a b c hbc => ?_\u27e9", "annotated_tactic": ["refine \u27e8fun a b c hbc => ?_\u27e9", []], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\n\u22a2 CovariantClass (WithZero \u03b1) (WithZero \u03b1) (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1", "state_after": "\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na b c : WithZero \u03b1\nhbc : b \u2264 c\n\u22a2 a + b \u2264 a + c"}, {"tactic": "induction a using WithZero.recZeroCoe", "annotated_tactic": ["induction a using <a>WithZero.recZeroCoe</a>", [{"full_name": "WithZero.recZeroCoe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/WithOne/Defs.lean", "def_pos": [108, 3], "def_end_pos": [108, 14]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na b c : WithZero \u03b1\nhbc : b \u2264 c\n\u22a2 a + b \u2264 a + c", "state_after": "case h\u2081\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nb c : WithZero \u03b1\nhbc : b \u2264 c\n\u22a2 0 + b \u2264 0 + c\n\ncase h\u2082\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nb c : WithZero \u03b1\nhbc : b \u2264 c\na\u271d : \u03b1\n\u22a2 \u2191a\u271d + b \u2264 \u2191a\u271d + c"}, {"tactic": "induction b using WithZero.recZeroCoe", "annotated_tactic": ["induction b using <a>WithZero.recZeroCoe</a>", [{"full_name": "WithZero.recZeroCoe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/WithOne/Defs.lean", "def_pos": [108, 3], "def_end_pos": [108, 14]}]], "state_before": "case h\u2082\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nb c : WithZero \u03b1\nhbc : b \u2264 c\na\u271d : \u03b1\n\u22a2 \u2191a\u271d + b \u2264 \u2191a\u271d + c", "state_after": "case h\u2082.h\u2081\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nc : WithZero \u03b1\na\u271d : \u03b1\nhbc : 0 \u2264 c\n\u22a2 \u2191a\u271d + 0 \u2264 \u2191a\u271d + c\n\ncase h\u2082.h\u2082\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nc : WithZero \u03b1\na\u271d\u00b9 a\u271d : \u03b1\nhbc : \u2191a\u271d \u2264 c\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d \u2264 \u2191a\u271d\u00b9 + c"}, {"tactic": "rwa [zero_add, zero_add]", "annotated_tactic": ["rwa [<a>zero_add</a>, <a>zero_add</a>]", [{"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "case h\u2081\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nb c : WithZero \u03b1\nhbc : b \u2264 c\n\u22a2 0 + b \u2264 0 + c", "state_after": "no goals"}, {"tactic": "rw [add_zero]", "annotated_tactic": ["rw [<a>add_zero</a>]", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "case h\u2082.h\u2081\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nc : WithZero \u03b1\na\u271d : \u03b1\nhbc : 0 \u2264 c\n\u22a2 \u2191a\u271d + 0 \u2264 \u2191a\u271d + c", "state_after": "case h\u2082.h\u2081\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nc : WithZero \u03b1\na\u271d : \u03b1\nhbc : 0 \u2264 c\n\u22a2 \u2191a\u271d \u2264 \u2191a\u271d + c"}, {"tactic": "induction c using WithZero.recZeroCoe", "annotated_tactic": ["induction c using <a>WithZero.recZeroCoe</a>", [{"full_name": "WithZero.recZeroCoe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/WithOne/Defs.lean", "def_pos": [108, 3], "def_end_pos": [108, 14]}]], "state_before": "case h\u2082.h\u2081\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nc : WithZero \u03b1\na\u271d : \u03b1\nhbc : 0 \u2264 c\n\u22a2 \u2191a\u271d \u2264 \u2191a\u271d + c", "state_after": "case h\u2082.h\u2081.h\u2081\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d : \u03b1\nhbc : 0 \u2264 0\n\u22a2 \u2191a\u271d \u2264 \u2191a\u271d + 0\n\ncase h\u2082.h\u2081.h\u2082\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d : \u03b1\nhbc : 0 \u2264 \u2191a\u271d\n\u22a2 \u2191a\u271d\u00b9 \u2264 \u2191a\u271d\u00b9 + \u2191a\u271d"}, {"tactic": "rw [add_zero]", "annotated_tactic": ["rw [<a>add_zero</a>]", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "case h\u2082.h\u2081.h\u2081\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d : \u03b1\nhbc : 0 \u2264 0\n\u22a2 \u2191a\u271d \u2264 \u2191a\u271d + 0", "state_after": "no goals"}, {"tactic": "rw [\u2190 coe_add, coe_le_coe]", "annotated_tactic": ["rw [\u2190 <a>coe_add</a>, <a>coe_le_coe</a>]", [{"full_name": "WithZero.coe_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/WithOne/Defs.lean", "def_pos": [193, 3], "def_end_pos": [193, 14]}, {"full_name": "WithZero.coe_le_coe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/WithZero/Defs.lean", "def_pos": [68, 9], "def_end_pos": [68, 19]}]], "state_before": "case h\u2082.h\u2081.h\u2082\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d : \u03b1\nhbc : 0 \u2264 \u2191a\u271d\n\u22a2 \u2191a\u271d\u00b9 \u2264 \u2191a\u271d\u00b9 + \u2191a\u271d", "state_after": "case h\u2082.h\u2081.h\u2082\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d : \u03b1\nhbc : 0 \u2264 \u2191a\u271d\n\u22a2 a\u271d\u00b9 \u2264 a\u271d\u00b9 + a\u271d"}, {"tactic": "exact le_add_of_nonneg_right (h _)", "annotated_tactic": ["exact <a>le_add_of_nonneg_right</a> (h _)", [{"full_name": "le_add_of_nonneg_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [391, 15], "def_end_pos": [391, 37]}]], "state_before": "case h\u2082.h\u2081.h\u2082\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d : \u03b1\nhbc : 0 \u2264 \u2191a\u271d\n\u22a2 a\u271d\u00b9 \u2264 a\u271d\u00b9 + a\u271d", "state_after": "no goals"}, {"tactic": "rcases WithBot.coe_le_iff.1 hbc with \u27e8c, rfl, hbc'\u27e9", "annotated_tactic": ["rcases <a>WithBot.coe_le_iff</a>.1 hbc with \u27e8c, rfl, hbc'\u27e9", [{"full_name": "WithBot.coe_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [252, 9], "def_end_pos": [252, 19]}]], "state_before": "case h\u2082.h\u2082\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\nc : WithZero \u03b1\na\u271d\u00b9 a\u271d : \u03b1\nhbc : \u2191a\u271d \u2264 c\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d \u2264 \u2191a\u271d\u00b9 + c", "state_after": "case h\u2082.h\u2082.intro.intro\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d c : \u03b1\nhbc' : a\u271d \u2264 c\nhbc : \u2191a\u271d \u2264 \u2191c\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d \u2264 \u2191a\u271d\u00b9 + \u2191c"}, {"tactic": "refine le_trans ?_ (le_of_eq <| coe_add _ _)", "annotated_tactic": ["refine <a>le_trans</a> ?_ (<a>le_of_eq</a> <| <a>coe_add</a> _ _)", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "le_of_eq", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [66, 9], "def_end_pos": [66, 17]}, {"full_name": "WithZero.coe_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/WithOne/Defs.lean", "def_pos": [193, 3], "def_end_pos": [193, 14]}]], "state_before": "case h\u2082.h\u2082.intro.intro\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d c : \u03b1\nhbc' : a\u271d \u2264 c\nhbc : \u2191a\u271d \u2264 \u2191c\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d \u2264 \u2191a\u271d\u00b9 + \u2191c", "state_after": "case h\u2082.h\u2082.intro.intro\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d c : \u03b1\nhbc' : a\u271d \u2264 c\nhbc : \u2191a\u271d \u2264 \u2191c\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d \u2264 \u2191(a\u271d\u00b9 + c)"}, {"tactic": "rw [\u2190 coe_add, coe_le_coe]", "annotated_tactic": ["rw [\u2190 <a>coe_add</a>, <a>coe_le_coe</a>]", [{"full_name": "WithZero.coe_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/WithOne/Defs.lean", "def_pos": [193, 3], "def_end_pos": [193, 14]}, {"full_name": "WithZero.coe_le_coe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/WithZero/Defs.lean", "def_pos": [68, 9], "def_end_pos": [68, 19]}]], "state_before": "case h\u2082.h\u2082.intro.intro\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d c : \u03b1\nhbc' : a\u271d \u2264 c\nhbc : \u2191a\u271d \u2264 \u2191c\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d \u2264 \u2191(a\u271d\u00b9 + c)", "state_after": "case h\u2082.h\u2082.intro.intro\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d c : \u03b1\nhbc' : a\u271d \u2264 c\nhbc : \u2191a\u271d \u2264 \u2191c\n\u22a2 a\u271d\u00b9 + a\u271d \u2264 a\u271d\u00b9 + c"}, {"tactic": "exact add_le_add_left hbc' _", "annotated_tactic": ["exact <a>add_le_add_left</a> hbc' _", [{"full_name": "add_le_add_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [49, 32], "def_end_pos": [49, 47]}]], "state_before": "case h\u2082.h\u2082.intro.intro\n\u03b1 : Type u\ninst\u271d\u00b2 : AddZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nh : \u2200 (a : \u03b1), 0 \u2264 a\na\u271d\u00b9 a\u271d c : \u03b1\nhbc' : a\u271d \u2264 c\nhbc : \u2191a\u271d \u2264 \u2191c\n\u22a2 a\u271d\u00b9 + a\u271d \u2264 a\u271d\u00b9 + c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.iInf_neBot_iff_of_directed'", "start": [964, 1], "end": [966, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/Constructions.lean", "full_name": "rank_span_le", "start": [429, 1], "end": [433, 44], "traced_tactics": [{"tactic": "rw [Finsupp.span_eq_range_total, \u2190 lift_strictMono.le_iff_le]", "annotated_tactic": ["rw [<a>Finsupp.span_eq_range_total</a>, \u2190 lift_strictMono.le_iff_le]", [{"full_name": "Finsupp.span_eq_range_total", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [773, 9], "def_end_pos": [773, 28]}]], "state_before": "R S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M\u2081\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M'\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : StrongRankCondition R\ns : Set M\n\u22a2 Module.rank R \u21a5(span R s) \u2264 #\u2191s", "state_after": "R S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M\u2081\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M'\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : StrongRankCondition R\ns : Set M\n\u22a2 lift.{?u.470789, v} (Module.rank R \u21a5(LinearMap.range (Finsupp.total (\u2191s) M R Subtype.val))) \u2264 lift.{?u.470789, v} #\u2191s"}, {"tactic": "refine (lift_rank_range_le _).trans ?_", "annotated_tactic": ["refine (<a>lift_rank_range_le</a> _).<a>trans</a> ?_", [{"full_name": "lift_rank_range_le", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Basic.lean", "def_pos": [257, 9], "def_end_pos": [257, 27]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}]], "state_before": "R S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M\u2081\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M'\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : StrongRankCondition R\ns : Set M\n\u22a2 lift.{?u.470789, v} (Module.rank R \u21a5(LinearMap.range (Finsupp.total (\u2191s) M R Subtype.val))) \u2264 lift.{?u.470789, v} #\u2191s", "state_after": "R S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M\u2081\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M'\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : StrongRankCondition R\ns : Set M\n\u22a2 lift.{v, max u v} (Module.rank R (\u2191s \u2192\u2080 R)) \u2264 lift.{max u v, v} #\u2191s"}, {"tactic": "rw [rank_finsupp_self]", "annotated_tactic": ["rw [<a>rank_finsupp_self</a>]", [{"full_name": "rank_finsupp_self", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "def_pos": [168, 9], "def_end_pos": [168, 26]}]], "state_before": "R S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M\u2081\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M'\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : StrongRankCondition R\ns : Set M\n\u22a2 lift.{v, max u v} (Module.rank R (\u2191s \u2192\u2080 R)) \u2264 lift.{max u v, v} #\u2191s", "state_after": "R S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M\u2081\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M'\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : StrongRankCondition R\ns : Set M\n\u22a2 lift.{v, max u v} (lift.{u, v} #\u2191s) \u2264 lift.{max u v, v} #\u2191s"}, {"tactic": "simp only [lift_lift, ge_iff_le, le_refl]", "annotated_tactic": ["simp only [<a>lift_lift</a>, <a>ge_iff_le</a>, <a>le_refl</a>]", [{"full_name": "Cardinal.lift_lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [236, 9], "def_end_pos": [236, 18]}, {"full_name": "ge_iff_le", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1935, 17], "def_end_pos": [1935, 26]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "R S : Type u\nM : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9 : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M\u2081\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M'\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : StrongRankCondition R\ns : Set M\n\u22a2 lift.{v, max u v} (lift.{u, v} #\u2191s) \u2264 lift.{max u v, v} #\u2191s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "contDiffOn_succ_iff_fderivWithin", "start": [1131, 1], "end": [1147, 55], "traced_tactics": [{"tactic": "refine' \u27e8fun H => _, fun h => contDiffOn_succ_of_fderivWithin h.1 h.2\u27e9", "annotated_tactic": ["refine' \u27e8fun H => _, fun h => <a>contDiffOn_succ_of_fderivWithin</a> h.1 h.2\u27e9", [{"full_name": "contDiffOn_succ_of_fderivWithin", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [1121, 9], "def_end_pos": [1121, 40]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\n\u22a2 ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s \u2194 DifferentiableOn \ud835\udd5c f s \u2227 ContDiffOn \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\n\u22a2 DifferentiableOn \ud835\udd5c f s \u2227 ContDiffOn \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s"}, {"tactic": "refine' \u27e8H.differentiableOn (WithTop.coe_le_coe.2 (Nat.le_add_left 1 n)), fun x hx => _\u27e9", "annotated_tactic": ["refine' \u27e8H.differentiableOn (<a>WithTop.coe_le_coe</a>.2 (<a>Nat.le_add_left</a> 1 n)), fun x hx => _\u27e9", [{"full_name": "WithTop.coe_le_coe", "def_path": ".lake/packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [888, 9], "def_end_pos": [888, 19]}, {"full_name": "Nat.le_add_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [337, 9], "def_end_pos": [337, 20]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\n\u22a2 DifferentiableOn \ud835\udd5c f s \u2227 ContDiffOn \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x"}, {"tactic": "rcases contDiffWithinAt_succ_iff_hasFDerivWithinAt.1 (H x hx) with \u27e8u, hu, f', hff', hf'\u27e9", "annotated_tactic": ["rcases <a>contDiffWithinAt_succ_iff_hasFDerivWithinAt</a>.1 (H x hx) with \u27e8u, hu, f', hff', hf'\u27e9", [{"full_name": "contDiffWithinAt_succ_iff_hasFDerivWithinAt", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [553, 9], "def_end_pos": [553, 52]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x", "state_after": "case intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x"}, {"tactic": "rcases mem_nhdsWithin.1 hu with \u27e8o, o_open, xo, ho\u27e9", "annotated_tactic": ["rcases <a>mem_nhdsWithin</a>.1 hu with \u27e8o, o_open, xo, ho\u27e9", [{"full_name": "mem_nhdsWithin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [90, 9], "def_end_pos": [90, 23]}]], "state_before": "case intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x", "state_after": "case intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : o \u2229 insert x s \u2286 u\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x"}, {"tactic": "rw [inter_comm, insert_eq_of_mem hx] at ho", "annotated_tactic": ["rw [<a>inter_comm</a>, <a>insert_eq_of_mem</a> hx] at ho", [{"full_name": "Set.inter_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [908, 9], "def_end_pos": [908, 19]}, {"full_name": "Set.insert_eq_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1122, 9], "def_end_pos": [1122, 25]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : o \u2229 insert x s \u2286 u\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x", "state_after": "case intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x"}, {"tactic": "have := hf'.mono ho", "annotated_tactic": ["have := hf'.mono ho", []], "state_before": "case intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x", "state_after": "case intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis : ContDiffWithinAt \ud835\udd5c (\u2191n) f' (s \u2229 o) x\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x"}, {"tactic": "rw [contDiffWithinAt_inter' (mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds o_open xo))] at this", "annotated_tactic": ["rw [<a>contDiffWithinAt_inter'</a> (<a>mem_nhdsWithin_of_mem_nhds</a> (<a>IsOpen.mem_nhds</a> o_open xo))] at this", [{"full_name": "contDiffWithinAt_inter'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [506, 9], "def_end_pos": [506, 32]}, {"full_name": "mem_nhdsWithin_of_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [144, 9], "def_end_pos": [144, 35]}, {"full_name": "IsOpen.mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [854, 9], "def_end_pos": [854, 24]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis : ContDiffWithinAt \ud835\udd5c (\u2191n) f' (s \u2229 o) x\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x", "state_after": "case intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x"}, {"tactic": "apply this.congr_of_eventually_eq' _ hx", "annotated_tactic": ["apply this.congr_of_eventually_eq' _ hx", []], "state_before": "case intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) (fun y => fderivWithin \ud835\udd5c f s y) s x", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\n\u22a2 (fun y => fderivWithin \ud835\udd5c f s y) =\u1da0[\ud835\udcdd[s] x] f'"}, {"tactic": "have : o \u2229 s \u2208 \ud835\udcdd[s] x := mem_nhdsWithin.2 \u27e8o, o_open, xo, Subset.refl _\u27e9", "annotated_tactic": ["have : o \u2229 s \u2208 \ud835\udcdd[s] x := <a>mem_nhdsWithin</a>.2 \u27e8o, o_open, xo, <a>Subset.refl</a> _\u27e9", [{"full_name": "mem_nhdsWithin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [90, 9], "def_end_pos": [90, 23]}, {"full_name": "Set.Subset.refl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [335, 9], "def_end_pos": [335, 20]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\n\u22a2 (fun y => fderivWithin \ud835\udd5c f s y) =\u1da0[\ud835\udcdd[s] x] f'", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis\u271d : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\nthis : o \u2229 s \u2208 \ud835\udcdd[s] x\n\u22a2 (fun y => fderivWithin \ud835\udd5c f s y) =\u1da0[\ud835\udcdd[s] x] f'"}, {"tactic": "rw [inter_comm] at this", "annotated_tactic": ["rw [<a>inter_comm</a>] at this", [{"full_name": "Set.inter_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [908, 9], "def_end_pos": [908, 19]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis\u271d : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\nthis : o \u2229 s \u2208 \ud835\udcdd[s] x\n\u22a2 (fun y => fderivWithin \ud835\udd5c f s y) =\u1da0[\ud835\udcdd[s] x] f'", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis\u271d : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\nthis : s \u2229 o \u2208 \ud835\udcdd[s] x\n\u22a2 (fun y => fderivWithin \ud835\udd5c f s y) =\u1da0[\ud835\udcdd[s] x] f'"}, {"tactic": "refine Filter.eventuallyEq_of_mem this fun y hy => ?_", "annotated_tactic": ["refine <a>Filter.eventuallyEq_of_mem</a> this fun y hy => ?_", [{"full_name": "Filter.eventuallyEq_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1497, 9], "def_end_pos": [1497, 28]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis\u271d : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\nthis : s \u2229 o \u2208 \ud835\udcdd[s] x\n\u22a2 (fun y => fderivWithin \ud835\udd5c f s y) =\u1da0[\ud835\udcdd[s] x] f'", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis\u271d : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\nthis : s \u2229 o \u2208 \ud835\udcdd[s] x\ny : E\nhy : y \u2208 s \u2229 o\n\u22a2 fderivWithin \ud835\udd5c f s y = f' y"}, {"tactic": "have A : fderivWithin \ud835\udd5c f (s \u2229 o) y = f' y :=\n  ((hff' y (ho hy)).mono ho).fderivWithin (hs.inter o_open y hy)", "annotated_tactic": ["have A : <a>fderivWithin</a> \ud835\udd5c f (s \u2229 o) y = f' y :=\n    ((hff' y (ho hy)).<a>mono</a> ho).<a>fderivWithin</a> (hs.inter o_open y hy)", [{"full_name": "fderivWithin", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [185, 17], "def_end_pos": [185, 29]}, {"full_name": "HasFDerivWithinAt.mono", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [376, 16], "def_end_pos": [376, 38]}, {"full_name": "HasFDerivWithinAt.fderivWithin", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [615, 19], "def_end_pos": [615, 49]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis\u271d : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\nthis : s \u2229 o \u2208 \ud835\udcdd[s] x\ny : E\nhy : y \u2208 s \u2229 o\n\u22a2 fderivWithin \ud835\udd5c f s y = f' y", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis\u271d : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\nthis : s \u2229 o \u2208 \ud835\udcdd[s] x\ny : E\nhy : y \u2208 s \u2229 o\nA : fderivWithin \ud835\udd5c f (s \u2229 o) y = f' y\n\u22a2 fderivWithin \ud835\udd5c f s y = f' y"}, {"tactic": "rwa [fderivWithin_inter (o_open.mem_nhds hy.2)] at A", "annotated_tactic": ["rwa [<a>fderivWithin_inter</a> (o_open.mem_nhds hy.2)] at A", [{"full_name": "fderivWithin_inter", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [692, 9], "def_end_pos": [692, 27]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhs : UniqueDiffOn \ud835\udd5c s\nH : ContDiffOn \ud835\udd5c (\u2191(n + 1)) f s\nx : E\nhx : x \u2208 s\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhff' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\no : Set E\no_open : IsOpen o\nxo : x \u2208 o\nho : s \u2229 o \u2286 u\nthis\u271d : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\nthis : s \u2229 o \u2208 \ud835\udcdd[s] x\ny : E\nhy : y \u2208 s \u2229 o\nA : fderivWithin \ud835\udd5c f (s \u2229 o) y = f' y\n\u22a2 fderivWithin \ud835\udd5c f s y = f' y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Pi/Lemmas.lean", "full_name": "Pi.single_mul", "start": [355, 1], "end": [357, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "DenseRange.nonempty", "start": [1823, 1], "end": [1824, 24], "traced_tactics": []}]