[{"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/OpenPos.lean", "full_name": "LE.le.isOpenPosMeasure", "start": [80, 1], "end": [81, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Bitwise.lean", "full_name": "Int.bodd_zero", "start": [27, 1], "end": [28, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "full_name": "PartialEquiv.pi_symm_apply", "start": [1030, 1], "end": [1032, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "mul_pos_iff", "start": [1092, 1], "end": [1094, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Iterate.lean", "full_name": "Function.Semiconj\u2082.iterate", "start": [179, 1], "end": [181, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Disjoint.lean", "full_name": "Set.Ioc_disjoint_Ioc", "start": [147, 1], "end": [149, 32], "traced_tactics": [{"tactic": "have h : _ \u2194 min (toDual a\u2081) (toDual b\u2081) \u2264 max (toDual a\u2082) (toDual b\u2082) := Ico_disjoint_Ico", "annotated_tactic": ["have h : _ \u2194 <a>min</a> (<a>toDual</a> a\u2081) (<a>toDual</a> b\u2081) \u2264 <a>max</a> (<a>toDual</a> a\u2082) (<a>toDual</a> b\u2082) := <a>Ico_disjoint_Ico</a>", [{"full_name": "Min.min", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1130, 3], "def_end_pos": [1130, 6]}, {"full_name": "OrderDual.toDual", "def_path": ".lake/packages/mathlib/Mathlib/Order/Synonym.lean", "def_pos": [50, 5], "def_end_pos": [50, 11]}, {"full_name": "OrderDual.toDual", "def_path": ".lake/packages/mathlib/Mathlib/Order/Synonym.lean", "def_pos": [50, 5], "def_end_pos": [50, 11]}, {"full_name": "Max.max", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1117, 3], "def_end_pos": [1117, 6]}, {"full_name": "OrderDual.toDual", "def_path": ".lake/packages/mathlib/Mathlib/Order/Synonym.lean", "def_pos": [50, 5], "def_end_pos": [50, 11]}, {"full_name": "OrderDual.toDual", "def_path": ".lake/packages/mathlib/Mathlib/Order/Synonym.lean", "def_pos": [50, 5], "def_end_pos": [50, 11]}, {"full_name": "Set.Ico_disjoint_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Disjoint.lean", "def_pos": [141, 9], "def_end_pos": [141, 25]}]], "state_before": "\u03b9 : Sort u\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d : LinearOrder \u03b1\na\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\n\u22a2 Disjoint (Ioc a\u2081 a\u2082) (Ioc b\u2081 b\u2082) \u2194 min a\u2082 b\u2082 \u2264 max a\u2081 b\u2081", "state_after": "\u03b9 : Sort u\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d : LinearOrder \u03b1\na\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\nh :\n  Disjoint (Ico (toDual a\u2082) (toDual a\u2081)) (Ico (toDual b\u2082) (toDual b\u2081)) \u2194\n    min (toDual a\u2081) (toDual b\u2081) \u2264 max (toDual a\u2082) (toDual b\u2082)\n\u22a2 Disjoint (Ioc a\u2081 a\u2082) (Ioc b\u2081 b\u2082) \u2194 min a\u2082 b\u2082 \u2264 max a\u2081 b\u2081"}, {"tactic": "simpa only [dual_Ico] using h", "annotated_tactic": ["simpa only [<a>dual_Ico</a>] using h", [{"full_name": "Set.dual_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [256, 9], "def_end_pos": [256, 17]}]], "state_before": "\u03b9 : Sort u\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d : LinearOrder \u03b1\na\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\nh :\n  Disjoint (Ico (toDual a\u2082) (toDual a\u2081)) (Ico (toDual b\u2082) (toDual b\u2081)) \u2194\n    min (toDual a\u2081) (toDual b\u2081) \u2264 max (toDual a\u2082) (toDual b\u2082)\n\u22a2 Disjoint (Ioc a\u2081 a\u2082) (Ioc b\u2081 b\u2082) \u2194 min a\u2082 b\u2082 \u2264 max a\u2081 b\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "full_name": "NonUnitalRingHom.mem_range_self", "start": [491, 1], "end": [492, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_smul_le", "start": [1169, 1], "end": [1172, 21], "traced_tactics": [{"tactic": "refine (degree_le_iff_coeff_zero _ _).2 fun m hm => ?_", "annotated_tactic": ["refine (<a>degree_le_iff_coeff_zero</a> _ _).2 fun m hm => ?_", [{"full_name": "Polynomial.degree_le_iff_coeff_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1156, 9], "def_end_pos": [1156, 33]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d\u00b9 p\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\n\u22a2 degree (a \u2022 p) \u2264 degree p", "state_after": "R : Type u\nS : Type v\na\u271d b c d : R\nn m\u271d : \u2115\ninst\u271d : Semiring R\np\u271d\u00b9 p\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\nm : \u2115\nhm : degree p < \u2191m\n\u22a2 coeff (a \u2022 p) m = 0"}, {"tactic": "rw [degree_lt_iff_coeff_zero] at hm", "annotated_tactic": ["rw [<a>degree_lt_iff_coeff_zero</a>] at hm", [{"full_name": "Polynomial.degree_lt_iff_coeff_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1163, 9], "def_end_pos": [1163, 33]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn m\u271d : \u2115\ninst\u271d : Semiring R\np\u271d\u00b9 p\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\nm : \u2115\nhm : degree p < \u2191m\n\u22a2 coeff (a \u2022 p) m = 0", "state_after": "R : Type u\nS : Type v\na\u271d b c d : R\nn m\u271d : \u2115\ninst\u271d : Semiring R\np\u271d\u00b9 p\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\nm : \u2115\nhm : \u2200 (m_1 : \u2115), m \u2264 m_1 \u2192 coeff p m_1 = 0\n\u22a2 coeff (a \u2022 p) m = 0"}, {"tactic": "simp [hm m le_rfl]", "annotated_tactic": ["simp [hm m <a>le_rfl</a>]", [{"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn m\u271d : \u2115\ninst\u271d : Semiring R\np\u271d\u00b9 p\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\nm : \u2115\nhm : \u2200 (m_1 : \u2115), m \u2264 m_1 \u2192 coeff p m_1 = 0\n\u22a2 coeff (a \u2022 p) m = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.set_lintegral_subtype", "start": [1498, 1], "end": [1501, 75], "traced_tactics": [{"tactic": "rw [(MeasurableEmbedding.subtype_coe hs).restrict_comap, lintegral_subtype_comap hs,\n  restrict_restrict hs, inter_eq_right.2 (Subtype.coe_image_subset _ _)]", "annotated_tactic": ["rw [(<a>MeasurableEmbedding.subtype_coe</a> hs).<a>restrict_comap</a>, <a>lintegral_subtype_comap</a> hs,\n    <a>restrict_restrict</a> hs, <a>inter_eq_right</a>.2 (<a>Subtype.coe_image_subset</a> _ _)]", [{"full_name": "MeasurableEmbedding.subtype_coe", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [1289, 9], "def_end_pos": [1289, 20]}, {"full_name": "MeasurableEmbedding.restrict_comap", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [935, 7], "def_end_pos": [935, 21]}, {"full_name": "MeasureTheory.lintegral_subtype_comap", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [1494, 9], "def_end_pos": [1494, 32]}, {"full_name": "MeasureTheory.Measure.restrict_restrict", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [185, 9], "def_end_pos": [185, 26]}, {"full_name": "Set.inter_eq_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [952, 15], "def_end_pos": [952, 29]}, {"full_name": "Subtype.coe_image_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1398, 9], "def_end_pos": [1398, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\nt : Set \u2191s\nf : \u03b1 \u2192 \u211d\u22650\u221e\n\u22a2 \u222b\u207b (x : \u2191s) in t, f \u2191x \u2202Measure.comap Subtype.val \u03bc = \u222b\u207b (x : \u03b1) in Subtype.val '' t, f x \u2202\u03bc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "full_name": "AffineIsometryEquiv.toIsometryEquiv_refl", "start": [506, 1], "end": [507, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "BoundedOrderHom.ext", "start": [616, 1], "end": [617, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.psigmaCongrRight_trans", "start": [724, 1], "end": [727, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Finset.mem_range_iff_mem_finset_range_of_mod_eq", "start": [616, 1], "end": [627, 91], "traced_tactics": [{"tactic": "simpa [h]", "annotated_tactic": ["simpa [h]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb c : \u03b2\ninst\u271d : DecidableEq \u03b1\nf : \u2124 \u2192 \u03b1\na : \u03b1\nn : \u2115\nhn : 0 < n\nh : \u2200 (i : \u2124), f (i % \u2191n) = f i\nthis : (\u2203 i, f (i % \u2191n) = a) \u2194 \u2203 i < n, f \u2191i = a\n\u22a2 a \u2208 Set.range f \u2194 a \u2208 image (fun i => f \u2191i) (range n)", "state_after": "no goals"}, {"tactic": "rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg this]", "annotated_tactic": ["rw [\u2190 <a>Int.ofNat_lt</a>, <a>Int.toNat_of_nonneg</a> this]", [{"full_name": "Int.ofNat_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [77, 28], "def_end_pos": [77, 36]}, {"full_name": "Int.toNat_of_nonneg", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [461, 17], "def_end_pos": [461, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb c : \u03b2\ninst\u271d : DecidableEq \u03b1\nf : \u2124 \u2192 \u03b1\na : \u03b1\nn : \u2115\nhn : 0 < n\nh : \u2200 (i : \u2124), f (i % \u2191n) = f i\nhn' : 0 < \u2191n\nx\u271d : \u2203 i, f (i % \u2191n) = a\ni : \u2124\nhi : f (i % \u2191n) = a\nthis : 0 \u2264 i % \u2191n\n\u22a2 Int.toNat (i % \u2191n) < n \u2227 f \u2191(Int.toNat (i % \u2191n)) = a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb c : \u03b2\ninst\u271d : DecidableEq \u03b1\nf : \u2124 \u2192 \u03b1\na : \u03b1\nn : \u2115\nhn : 0 < n\nh : \u2200 (i : \u2124), f (i % \u2191n) = f i\nhn' : 0 < \u2191n\nx\u271d : \u2203 i, f (i % \u2191n) = a\ni : \u2124\nhi : f (i % \u2191n) = a\nthis : 0 \u2264 i % \u2191n\n\u22a2 i % \u2191n < \u2191n \u2227 f (i % \u2191n) = a"}, {"tactic": "exact \u27e8Int.emod_lt_of_pos i hn', hi\u27e9", "annotated_tactic": ["exact \u27e8<a>Int.emod_lt_of_pos</a> i hn', hi\u27e9", [{"full_name": "Int.emod_lt_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean", "def_pos": [137, 9], "def_end_pos": [137, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb c : \u03b2\ninst\u271d : DecidableEq \u03b1\nf : \u2124 \u2192 \u03b1\na : \u03b1\nn : \u2115\nhn : 0 < n\nh : \u2200 (i : \u2124), f (i % \u2191n) = f i\nhn' : 0 < \u2191n\nx\u271d : \u2203 i, f (i % \u2191n) = a\ni : \u2124\nhi : f (i % \u2191n) = a\nthis : 0 \u2264 i % \u2191n\n\u22a2 i % \u2191n < \u2191n \u2227 f (i % \u2191n) = a", "state_after": "no goals"}, {"tactic": "rw [Int.emod_eq_of_lt (Int.ofNat_zero_le _) (Int.ofNat_lt_ofNat_of_lt hi), ha]", "annotated_tactic": ["rw [<a>Int.emod_eq_of_lt</a> (<a>Int.ofNat_zero_le</a> _) (<a>Int.ofNat_lt_ofNat_of_lt</a> hi), ha]", [{"full_name": "Int.emod_eq_of_lt", "def_path": ".lake/packages/std/Std/Data/Int/DivMod.lean", "def_pos": [241, 9], "def_end_pos": [241, 22]}, {"full_name": "Int.ofNat_zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [59, 9], "def_end_pos": [59, 22]}, {"full_name": "Int.ofNat_lt_ofNat_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Int/Order.lean", "def_pos": [41, 30], "def_end_pos": [41, 50]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b2\nf\u271d g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na\u271d : \u03b1\nb c : \u03b2\ninst\u271d : DecidableEq \u03b1\nf : \u2124 \u2192 \u03b1\na : \u03b1\nn : \u2115\nhn : 0 < n\nh : \u2200 (i : \u2124), f (i % \u2191n) = f i\nhn' : 0 < \u2191n\nx\u271d : \u2203 i < n, f \u2191i = a\ni : \u2115\nhi : i < n\nha : f \u2191i = a\n\u22a2 f (\u2191i % \u2191n) = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Commute/Basic.lean", "full_name": "Commute.conj_iff", "start": [95, 11], "end": [96, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Principal.lean", "full_name": "Ordinal.principal_add_of_le_one", "start": [120, 1], "end": [123, 28], "traced_tactics": [{"tactic": "rcases le_one_iff.1 ho with (rfl | rfl)", "annotated_tactic": ["rcases <a>le_one_iff</a>.1 ho with (rfl | rfl)", [{"full_name": "Ordinal.le_one_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1087, 9], "def_end_pos": [1087, 19]}]], "state_before": "o : Ordinal.{u_1}\nho : o \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) o", "state_after": "case inl\nho : 0 \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) 0\n\ncase inr\nho : 1 \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) 1"}, {"tactic": "exact principal_zero", "annotated_tactic": ["exact <a>principal_zero</a>", [{"full_name": "Ordinal.principal_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Principal.lean", "def_pos": [57, 9], "def_end_pos": [57, 23]}]], "state_before": "case inl\nho : 0 \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) 0", "state_after": "no goals"}, {"tactic": "exact principal_add_one", "annotated_tactic": ["exact <a>principal_add_one</a>", [{"full_name": "Ordinal.principal_add_one", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Principal.lean", "def_pos": [116, 9], "def_end_pos": [116, 26]}]], "state_before": "case inr\nho : 1 \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean", "full_name": "Set.PairwiseDisjoint.range", "start": [313, 1], "end": [316, 87], "traced_tactics": [{"tactic": "rintro _ \u27e8x, rfl\u27e9 _ \u27e8y, rfl\u27e9 hxy", "annotated_tactic": ["rintro _ \u27e8x, rfl\u27e9 _ \u27e8y, rfl\u27e9 hxy", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns t : Set \u03b9\nf g\u271d : \u03b9 \u2192 \u03b1\ng : \u2191s \u2192 \u03b9\nhg : \u2200 (i : \u2191s), f (g i) \u2264 f \u2191i\nht : PairwiseDisjoint s f\n\u22a2 PairwiseDisjoint (Set.range g) f", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns t : Set \u03b9\nf g\u271d : \u03b9 \u2192 \u03b1\ng : \u2191s \u2192 \u03b9\nhg : \u2200 (i : \u2191s), f (g i) \u2264 f \u2191i\nht : PairwiseDisjoint s f\nx y : \u2191s\nhxy : g x \u2260 g y\n\u22a2 (Disjoint on f) (g x) (g y)"}, {"tactic": "exact ((ht x.2 y.2) fun h => hxy <| congr_arg g <| Subtype.ext h).mono (hg x) (hg y)", "annotated_tactic": ["exact ((ht x.2 y.2) fun h => hxy <| <a>congr_arg</a> g <| <a>Subtype.ext</a> h).<a>mono</a> (hg x) (hg y)", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "Subtype.ext", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [65, 19], "def_end_pos": [65, 22]}, {"full_name": "Disjoint.mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [71, 9], "def_end_pos": [71, 22]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns t : Set \u03b9\nf g\u271d : \u03b9 \u2192 \u03b1\ng : \u2191s \u2192 \u03b9\nhg : \u2200 (i : \u2191s), f (g i) \u2264 f \u2191i\nht : PairwiseDisjoint s f\nx y : \u2191s\nhxy : g x \u2260 g y\n\u22a2 (Disjoint on f) (g x) (g y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/AddTorsor.lean", "full_name": "neg_vsub_eq_vsub_rev", "start": [153, 1], "end": [155, 39], "traced_tactics": [{"tactic": "refine' neg_eq_of_add_eq_zero_right (vadd_right_cancel p\u2081 _)", "annotated_tactic": ["refine' <a>neg_eq_of_add_eq_zero_right</a> (<a>vadd_right_cancel</a> p\u2081 _)", [{"full_name": "neg_eq_of_add_eq_zero_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1075, 3], "def_end_pos": [1075, 14]}, {"full_name": "vadd_right_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [97, 9], "def_end_pos": [97, 26]}]], "state_before": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np\u2081 p\u2082 : P\n\u22a2 -(p\u2081 -\u1d65 p\u2082) = p\u2082 -\u1d65 p\u2081", "state_after": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np\u2081 p\u2082 : P\n\u22a2 p\u2081 -\u1d65 p\u2082 + (p\u2082 -\u1d65 p\u2081) +\u1d65 p\u2081 = 0 +\u1d65 p\u2081"}, {"tactic": "rw [vsub_add_vsub_cancel, vsub_self]", "annotated_tactic": ["rw [<a>vsub_add_vsub_cancel</a>, <a>vsub_self</a>]", [{"full_name": "vsub_add_vsub_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [145, 9], "def_end_pos": [145, 29]}, {"full_name": "vsub_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [123, 9], "def_end_pos": [123, 18]}]], "state_before": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np\u2081 p\u2082 : P\n\u22a2 p\u2081 -\u1d65 p\u2082 + (p\u2082 -\u1d65 p\u2081) +\u1d65 p\u2081 = 0 +\u1d65 p\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.IsSuffix.subset", "start": [1908, 11], "end": [1909, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.size_extract_loop", "start": [598, 1], "end": [608, 90], "traced_tactics": [{"tactic": "induction size using Nat.recAux generalizing start bs with\n| zero => rw [extract_loop_zero, Nat.zero_min, Nat.add_zero]\n| succ size ih =>\n  if h : start < as.size then\n    rw [extract_loop_succ (h:=h), ih, size_push, Nat.add_assoc, \u2190Nat.add_min_add_left,\n      Nat.sub_succ, Nat.one_add, Nat.one_add, Nat.succ_pred_eq_of_pos (Nat.sub_pos_of_lt h)]\n  else\n    have h := Nat.le_of_not_gt h\n    rw [extract_loop_of_ge (h:=h), Nat.sub_eq_zero_of_le h, Nat.min_zero, Nat.add_zero]", "annotated_tactic": ["induction size using <a>Nat.recAux</a> generalizing start bs with\n  | <a>zero</a> => rw [<a>extract_loop_zero</a>, <a>Nat.zero_min</a>, <a>Nat.add_zero</a>]\n  | <a>succ</a> size ih =>\n    if h : start < as.size then\n      rw [<a>extract_loop_succ</a> (h:=h), ih, <a>size_push</a>, <a>Nat.add_assoc</a>, \u2190<a>Nat.add_min_add_left</a>,\n        <a>Nat.sub_succ</a>, <a>Nat.one_add</a>, <a>Nat.one_add</a>, <a>Nat.succ_pred_eq_of_pos</a> (<a>Nat.sub_pos_of_lt</a> h)]\n    else\n      have h := <a>Nat.le_of_not_gt</a> h\n      rw [<a>extract_loop_of_ge</a> (h:=h), <a>Nat.sub_eq_zero_of_le</a> h, <a>Nat.min_zero</a>, <a>Nat.add_zero</a>]", [{"full_name": "Nat.recAux", "def_path": ".lake/packages/std/Std/Data/Nat/Basic.lean", "def_pos": [13, 15], "def_end_pos": [13, 21]}, {"full_name": "Nat.zero", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1068, 5], "def_end_pos": [1068, 9]}, {"full_name": "Array.extract_loop_zero", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [569, 9], "def_end_pos": [569, 26]}, {"full_name": "Nat.zero_min", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [340, 27], "def_end_pos": [340, 35]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Array.extract_loop_succ", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}, {"full_name": "Nat.add_min_add_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [451, 19], "def_end_pos": [451, 35]}, {"full_name": "Nat.sub_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [248, 9], "def_end_pos": [248, 17]}, {"full_name": "Nat.one_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 16]}, {"full_name": "Nat.one_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 16]}, {"full_name": "Nat.succ_pred_eq_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [573, 9], "def_end_pos": [573, 28]}, {"full_name": "Nat.sub_pos_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [737, 19], "def_end_pos": [737, 32]}, {"full_name": "Nat.le_of_not_gt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [370, 19], "def_end_pos": [370, 31]}, {"full_name": "Array.extract_loop_of_ge", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [576, 9], "def_end_pos": [576, 27]}, {"full_name": "Nat.sub_eq_zero_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [679, 19], "def_end_pos": [679, 36]}, {"full_name": "Nat.min_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [342, 27], "def_end_pos": [342, 35]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}]], "state_before": "\u03b1 : Type u_1\nas bs : Array \u03b1\nsize start : Nat\n\u22a2 Array.size (extract.loop as size start bs) = Array.size bs + min size (Array.size as - start)", "state_after": "no goals"}, {"tactic": "rw [extract_loop_zero, Nat.zero_min, Nat.add_zero]", "annotated_tactic": ["rw [<a>extract_loop_zero</a>, <a>Nat.zero_min</a>, <a>Nat.add_zero</a>]", [{"full_name": "Array.extract_loop_zero", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [569, 9], "def_end_pos": [569, 26]}, {"full_name": "Nat.zero_min", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [340, 27], "def_end_pos": [340, 35]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}]], "state_before": "case zero\n\u03b1 : Type u_1\nas bs : Array \u03b1\nstart : Nat\n\u22a2 size (extract.loop as 0 start bs) = size bs + min 0 (size as - start)", "state_after": "no goals"}, {"tactic": "if h : start < as.size then\n  rw [extract_loop_succ (h:=h), ih, size_push, Nat.add_assoc, \u2190Nat.add_min_add_left,\n    Nat.sub_succ, Nat.one_add, Nat.one_add, Nat.succ_pred_eq_of_pos (Nat.sub_pos_of_lt h)]\nelse\n  have h := Nat.le_of_not_gt h\n  rw [extract_loop_of_ge (h:=h), Nat.sub_eq_zero_of_le h, Nat.min_zero, Nat.add_zero]", "annotated_tactic": ["if h : start < as.size then\n      rw [<a>extract_loop_succ</a> (h:=h), ih, <a>size_push</a>, <a>Nat.add_assoc</a>, \u2190<a>Nat.add_min_add_left</a>,\n        <a>Nat.sub_succ</a>, <a>Nat.one_add</a>, <a>Nat.one_add</a>, <a>Nat.succ_pred_eq_of_pos</a> (<a>Nat.sub_pos_of_lt</a> h)]\n    else\n      have h := <a>Nat.le_of_not_gt</a> h\n      rw [<a>extract_loop_of_ge</a> (h:=h), <a>Nat.sub_eq_zero_of_le</a> h, <a>Nat.min_zero</a>, <a>Nat.add_zero</a>]", [{"full_name": "Array.extract_loop_succ", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}, {"full_name": "Nat.add_min_add_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [451, 19], "def_end_pos": [451, 35]}, {"full_name": "Nat.sub_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [248, 9], "def_end_pos": [248, 17]}, {"full_name": "Nat.one_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 16]}, {"full_name": "Nat.one_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 16]}, {"full_name": "Nat.succ_pred_eq_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [573, 9], "def_end_pos": [573, 28]}, {"full_name": "Nat.sub_pos_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [737, 19], "def_end_pos": [737, 32]}, {"full_name": "Nat.le_of_not_gt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [370, 19], "def_end_pos": [370, 31]}, {"full_name": "Array.extract_loop_of_ge", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [576, 9], "def_end_pos": [576, 27]}, {"full_name": "Nat.sub_eq_zero_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [679, 19], "def_end_pos": [679, 36]}, {"full_name": "Nat.min_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [342, 27], "def_end_pos": [342, 35]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}]], "state_before": "case succ\n\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat),\n    Array.size (extract.loop as size start bs) = Array.size bs + min size (Array.size as - start)\nbs : Array \u03b1\nstart : Nat\n\u22a2 Array.size (extract.loop as (size + 1) start bs) = Array.size bs + min (size + 1) (Array.size as - start)", "state_after": "no goals"}, {"tactic": "rw [extract_loop_succ (h:=h), ih, size_push, Nat.add_assoc, \u2190Nat.add_min_add_left,\n  Nat.sub_succ, Nat.one_add, Nat.one_add, Nat.succ_pred_eq_of_pos (Nat.sub_pos_of_lt h)]", "annotated_tactic": ["rw [<a>extract_loop_succ</a> (h:=h), ih, <a>size_push</a>, <a>Nat.add_assoc</a>, \u2190<a>Nat.add_min_add_left</a>,\n        <a>Nat.sub_succ</a>, <a>Nat.one_add</a>, <a>Nat.one_add</a>, <a>Nat.succ_pred_eq_of_pos</a> (<a>Nat.sub_pos_of_lt</a> h)]", [{"full_name": "Array.extract_loop_succ", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [572, 9], "def_end_pos": [572, 26]}, {"full_name": "Array.size_push", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [79, 17], "def_end_pos": [79, 26]}, {"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}, {"full_name": "Nat.add_min_add_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [451, 19], "def_end_pos": [451, 35]}, {"full_name": "Nat.sub_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [248, 9], "def_end_pos": [248, 17]}, {"full_name": "Nat.one_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 16]}, {"full_name": "Nat.one_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 16]}, {"full_name": "Nat.succ_pred_eq_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [573, 9], "def_end_pos": [573, 28]}, {"full_name": "Nat.sub_pos_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [737, 19], "def_end_pos": [737, 32]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat),\n    Array.size (extract.loop as size start bs) = Array.size bs + min size (Array.size as - start)\nbs : Array \u03b1\nstart : Nat\nh : start < Array.size as\n\u22a2 Array.size (extract.loop as (size + 1) start bs) = Array.size bs + min (size + 1) (Array.size as - start)", "state_after": "no goals"}, {"tactic": "have h := Nat.le_of_not_gt h", "annotated_tactic": ["have h := <a>Nat.le_of_not_gt</a> h", [{"full_name": "Nat.le_of_not_gt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [370, 19], "def_end_pos": [370, 31]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat),\n    Array.size (extract.loop as size start bs) = Array.size bs + min size (Array.size as - start)\nbs : Array \u03b1\nstart : Nat\nh : \u00acstart < Array.size as\n\u22a2 Array.size (extract.loop as (size + 1) start bs) = Array.size bs + min (size + 1) (Array.size as - start)", "state_after": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat),\n    Array.size (extract.loop as size start bs) = Array.size bs + min size (Array.size as - start)\nbs : Array \u03b1\nstart : Nat\nh\u271d : \u00acstart < Array.size as\nh : Array.size as \u2264 start\n\u22a2 Array.size (extract.loop as (size + 1) start bs) = Array.size bs + min (size + 1) (Array.size as - start)"}, {"tactic": "rw [extract_loop_of_ge (h:=h), Nat.sub_eq_zero_of_le h, Nat.min_zero, Nat.add_zero]", "annotated_tactic": ["rw [<a>extract_loop_of_ge</a> (h:=h), <a>Nat.sub_eq_zero_of_le</a> h, <a>Nat.min_zero</a>, <a>Nat.add_zero</a>]", [{"full_name": "Array.extract_loop_of_ge", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [576, 9], "def_end_pos": [576, 27]}, {"full_name": "Nat.sub_eq_zero_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [679, 19], "def_end_pos": [679, 36]}, {"full_name": "Nat.min_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [342, 27], "def_end_pos": [342, 35]}, {"full_name": "Nat.add_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [586, 27], "def_end_pos": [586, 39]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nsize : Nat\nih :\n  \u2200 (bs : Array \u03b1) (start : Nat),\n    Array.size (extract.loop as size start bs) = Array.size bs + min size (Array.size as - start)\nbs : Array \u03b1\nstart : Nat\nh\u271d : \u00acstart < Array.size as\nh : Array.size as \u2264 start\n\u22a2 Array.size (extract.loop as (size + 1) start bs) = Array.size bs + min (size + 1) (Array.size as - start)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.range_subset", "start": [3165, 1], "end": [3166, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "measurableSet_bddAbove_range", "start": [1375, 1], "end": [1398, 47], "traced_tactics": [{"tactic": "rcases isEmpty_or_nonempty \u03b1 with h\u03b1|h\u03b1", "annotated_tactic": ["rcases <a>isEmpty_or_nonempty</a> \u03b1 with h\u03b1|h\u03b1", [{"full_name": "isEmpty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [215, 9], "def_end_pos": [215, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : IsEmpty \u03b1\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}"}, {"tactic": "have A : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c} := by\n  intro i c\n  exact measurableSet_le (hf i) measurable_const", "annotated_tactic": ["have A : \u2200 (i : \u03b9) (c : \u03b1), <a>MeasurableSet</a> {x | f i x \u2264 c} := by\n    intro i c\n    exact <a>measurableSet_le</a> (hf i) <a>measurable_const</a>", [{"full_name": "MeasurableSet", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [63, 5], "def_end_pos": [63, 18]}, {"full_name": "measurableSet_le", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "def_pos": [600, 9], "def_end_pos": [600, 25]}, {"full_name": "measurable_const", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [588, 9], "def_end_pos": [588, 25]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}", "state_after": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}"}, {"tactic": "have B : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 i, f i x \u2264 c} := by\n  intro c\n  rw [setOf_forall]\n  exact MeasurableSet.iInter (fun i \u21a6 A i c)", "annotated_tactic": ["have B : \u2200 (c : \u03b1), <a>MeasurableSet</a> {x | \u2200 i, f i x \u2264 c} := by\n    intro c\n    rw [<a>setOf_forall</a>]\n    exact <a>MeasurableSet.iInter</a> (fun i \u21a6 A i c)", [{"full_name": "MeasurableSet", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [63, 5], "def_end_pos": [63, 18]}, {"full_name": "Set.setOf_forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [236, 9], "def_end_pos": [236, 21]}, {"full_name": "MeasurableSet.iInter", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [160, 9], "def_end_pos": [160, 29]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}", "state_after": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}"}, {"tactic": "obtain \u27e8u, hu\u27e9 : \u2203 (u : \u2115 \u2192 \u03b1), Tendsto u atTop atTop := exists_seq_tendsto (atTop : Filter \u03b1)", "annotated_tactic": ["obtain \u27e8u, hu\u27e9 : \u2203 (u : \u2115 \u2192 \u03b1), <a>Tendsto</a> u <a>atTop</a> <a>atTop</a> := <a>exists_seq_tendsto</a> (<a>atTop</a> : <a>Filter</a> \u03b1)", [{"full_name": "Filter.Tendsto", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2962, 5], "def_end_pos": [2962, 12]}, {"full_name": "Filter.atTop", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [42, 5], "def_end_pos": [42, 10]}, {"full_name": "Filter.atTop", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [42, 5], "def_end_pos": [42, 10]}, {"full_name": "Filter.exists_seq_tendsto", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [1897, 9], "def_end_pos": [1897, 27]}, {"full_name": "Filter.atTop", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [42, 5], "def_end_pos": [42, 10]}, {"full_name": "Filter", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [91, 11], "def_end_pos": [91, 17]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}", "state_after": "case inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}"}, {"tactic": "rw [this, setOf_exists]", "annotated_tactic": ["rw [this, <a>setOf_exists</a>]", [{"full_name": "Set.setOf_exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [232, 9], "def_end_pos": [232, 21]}]], "state_before": "case inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nthis : {b | BddAbove (range fun i => f i b)} = {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}", "state_after": "case inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nthis : {b | BddAbove (range fun i => f i b)} = {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}\n\u22a2 MeasurableSet (\u22c3 i, {x | \u2200 (i_1 : \u03b9), f i_1 x \u2264 u i})"}, {"tactic": "exact MeasurableSet.iUnion (fun n \u21a6 B (u n))", "annotated_tactic": ["exact <a>MeasurableSet.iUnion</a> (fun n \u21a6 B (u n))", [{"full_name": "MeasurableSet.iUnion", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [116, 19], "def_end_pos": [116, 39]}]], "state_before": "case inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nthis : {b | BddAbove (range fun i => f i b)} = {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}\n\u22a2 MeasurableSet (\u22c3 i, {x | \u2200 (i_1 : \u03b9), f i_1 x \u2264 u i})", "state_after": "no goals"}, {"tactic": "have : \u2200 b, range (fun i \u21a6 f i b) = \u2205 := fun b \u21a6 eq_empty_of_isEmpty _", "annotated_tactic": ["have : \u2200 b, <a>range</a> (fun i \u21a6 f i b) = \u2205 := fun b \u21a6 <a>eq_empty_of_isEmpty</a> _", [{"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}, {"full_name": "Set.eq_empty_of_isEmpty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [568, 9], "def_end_pos": [568, 28]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : IsEmpty \u03b1\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : IsEmpty \u03b1\nthis : \u2200 (b : \u03b4), (range fun i => f i b) = \u2205\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}"}, {"tactic": "simp [this]", "annotated_tactic": ["simp [this]", []], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : IsEmpty \u03b1\nthis : \u2200 (b : \u03b4), (range fun i => f i b) = \u2205\n\u22a2 MeasurableSet {b | BddAbove (range fun i => f i b)}", "state_after": "no goals"}, {"tactic": "intro i c", "annotated_tactic": ["intro i c", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\n\u22a2 \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\ni : \u03b9\nc : \u03b1\n\u22a2 MeasurableSet {x | f i x \u2264 c}"}, {"tactic": "exact measurableSet_le (hf i) measurable_const", "annotated_tactic": ["exact <a>measurableSet_le</a> (hf i) <a>measurable_const</a>", [{"full_name": "measurableSet_le", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "def_pos": [600, 9], "def_end_pos": [600, 25]}, {"full_name": "measurable_const", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [588, 9], "def_end_pos": [588, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\ni : \u03b9\nc : \u03b1\n\u22a2 MeasurableSet {x | f i x \u2264 c}", "state_after": "no goals"}, {"tactic": "intro c", "annotated_tactic": ["intro c", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\n\u22a2 \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nc : \u03b1\n\u22a2 MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}"}, {"tactic": "rw [setOf_forall]", "annotated_tactic": ["rw [<a>setOf_forall</a>]", [{"full_name": "Set.setOf_forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [236, 9], "def_end_pos": [236, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nc : \u03b1\n\u22a2 MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nc : \u03b1\n\u22a2 MeasurableSet (\u22c2 i, {x | f i x \u2264 c})"}, {"tactic": "exact MeasurableSet.iInter (fun i \u21a6 A i c)", "annotated_tactic": ["exact <a>MeasurableSet.iInter</a> (fun i \u21a6 A i c)", [{"full_name": "MeasurableSet.iInter", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [160, 9], "def_end_pos": [160, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nc : \u03b1\n\u22a2 MeasurableSet (\u22c2 i, {x | f i x \u2264 c})", "state_after": "no goals"}, {"tactic": "apply Subset.antisymm", "annotated_tactic": ["apply <a>Subset.antisymm</a>", [{"full_name": "Set.Subset.antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [351, 9], "def_end_pos": [351, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\n\u22a2 {b | BddAbove (range fun i => f i b)} = {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}", "state_after": "case h\u2081\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\n\u22a2 {b | BddAbove (range fun i => f i b)} \u2286 {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}\n\ncase h\u2082\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\n\u22a2 {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n} \u2286 {b | BddAbove (range fun i => f i b)}"}, {"tactic": "rintro x \u27e8c, hc\u27e9", "annotated_tactic": ["rintro x \u27e8c, hc\u27e9", []], "state_before": "case h\u2081\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\n\u22a2 {b | BddAbove (range fun i => f i b)} \u2286 {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}", "state_after": "case h\u2081.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nc : \u03b1\nhc : c \u2208 upperBounds (range fun i => f i x)\n\u22a2 x \u2208 {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}"}, {"tactic": "obtain \u27e8n, hn\u27e9 : \u2203 n, c \u2264 u n := (tendsto_atTop.1 hu c).exists", "annotated_tactic": ["obtain \u27e8n, hn\u27e9 : \u2203 n, c \u2264 u n := (<a>tendsto_atTop</a>.1 hu c).<a>exists</a>", [{"full_name": "Filter.tendsto_atTop", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [406, 9], "def_end_pos": [406, 22]}, {"full_name": "Filter.Eventually.exists", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1327, 9], "def_end_pos": [1327, 26]}]], "state_before": "case h\u2081.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nc : \u03b1\nhc : c \u2208 upperBounds (range fun i => f i x)\n\u22a2 x \u2208 {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}", "state_after": "case h\u2081.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nc : \u03b1\nhc : c \u2208 upperBounds (range fun i => f i x)\nn : \u2115\nhn : c \u2264 u n\n\u22a2 x \u2208 {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}"}, {"tactic": "exact \u27e8n, fun i \u21a6 (hc ((mem_range_self i))).trans hn\u27e9", "annotated_tactic": ["exact \u27e8n, fun i \u21a6 (hc ((<a>mem_range_self</a> i))).<a>trans</a> hn\u27e9", [{"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}]], "state_before": "case h\u2081.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nc : \u03b1\nhc : c \u2208 upperBounds (range fun i => f i x)\nn : \u2115\nhn : c \u2264 u n\n\u22a2 x \u2208 {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n}", "state_after": "no goals"}, {"tactic": "rintro x \u27e8n, hn\u27e9", "annotated_tactic": ["rintro x \u27e8n, hn\u27e9", []], "state_before": "case h\u2082\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\n\u22a2 {x | \u2203 n, \u2200 (i : \u03b9), f i x \u2264 u n} \u2286 {b | BddAbove (range fun i => f i b)}", "state_after": "case h\u2082.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nn : \u2115\nhn : \u2200 (i : \u03b9), f i x \u2264 u n\n\u22a2 x \u2208 {b | BddAbove (range fun i => f i b)}"}, {"tactic": "refine \u27e8u n, ?_\u27e9", "annotated_tactic": ["refine \u27e8u n, ?_\u27e9", []], "state_before": "case h\u2082.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nn : \u2115\nhn : \u2200 (i : \u03b9), f i x \u2264 u n\n\u22a2 x \u2208 {b | BddAbove (range fun i => f i b)}", "state_after": "case h\u2082.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nn : \u2115\nhn : \u2200 (i : \u03b9), f i x \u2264 u n\n\u22a2 u n \u2208 upperBounds (range fun i => f i x)"}, {"tactic": "rintro - \u27e8i, rfl\u27e9", "annotated_tactic": ["rintro - \u27e8i, rfl\u27e9", []], "state_before": "case h\u2082.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nn : \u2115\nhn : \u2200 (i : \u03b9), f i x \u2264 u n\n\u22a2 u n \u2208 upperBounds (range fun i => f i x)", "state_after": "case h\u2082.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nn : \u2115\nhn : \u2200 (i : \u03b9), f i x \u2264 u n\ni : \u03b9\n\u22a2 (fun i => f i x) i \u2264 u n"}, {"tactic": "exact hn i", "annotated_tactic": ["exact hn i", []], "state_before": "case h\u2082.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9\u271d : Sort y\ns t u\u271d : Set \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace \u03b2\ninst\u271d\u2078 : BorelSpace \u03b2\ninst\u271d\u2077 : TopologicalSpace \u03b3\ninst\u271d\u2076 : MeasurableSpace \u03b3\ninst\u271d\u2075 : BorelSpace \u03b3\ninst\u271d\u2074 : MeasurableSpace \u03b4\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Measurable (f i)\nh\u03b1 : Nonempty \u03b1\nA : \u2200 (i : \u03b9) (c : \u03b1), MeasurableSet {x | f i x \u2264 c}\nB : \u2200 (c : \u03b1), MeasurableSet {x | \u2200 (i : \u03b9), f i x \u2264 c}\nu : \u2115 \u2192 \u03b1\nhu : Tendsto u atTop atTop\nx : \u03b4\nn : \u2115\nhn : \u2200 (i : \u03b9), f i x \u2264 u n\ni : \u03b9\n\u22a2 (fun i => f i x) i \u2264 u n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "List.mem_of_nextOr_ne", "start": [76, 1], "end": [84, 28], "traced_tactics": [{"tactic": "induction' xs with y ys IH", "annotated_tactic": ["induction' xs with y ys IH", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs : List \u03b1\nx d : \u03b1\nh : nextOr xs x d \u2260 d\n\u22a2 x \u2208 xs", "state_after": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d : \u03b1\nh : nextOr [] x d \u2260 d\n\u22a2 x \u2208 []\n\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y : \u03b1\nys : List \u03b1\nIH : nextOr ys x d \u2260 d \u2192 x \u2208 ys\nh : nextOr (y :: ys) x d \u2260 d\n\u22a2 x \u2208 y :: ys"}, {"tactic": "cases' ys with z zs", "annotated_tactic": ["cases' ys with z zs", []], "state_before": "case cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y : \u03b1\nys : List \u03b1\nIH : nextOr ys x d \u2260 d \u2192 x \u2208 ys\nh : nextOr (y :: ys) x d \u2260 d\n\u22a2 x \u2208 y :: ys", "state_after": "case cons.nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y : \u03b1\nIH : nextOr [] x d \u2260 d \u2192 x \u2208 []\nh : nextOr [y] x d \u2260 d\n\u22a2 x \u2208 [y]\n\ncase cons.cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y z : \u03b1\nzs : List \u03b1\nIH : nextOr (z :: zs) x d \u2260 d \u2192 x \u2208 z :: zs\nh : nextOr (y :: z :: zs) x d \u2260 d\n\u22a2 x \u2208 y :: z :: zs"}, {"tactic": "simp at h", "annotated_tactic": ["simp at h", []], "state_before": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d : \u03b1\nh : nextOr [] x d \u2260 d\n\u22a2 x \u2208 []", "state_after": "no goals"}, {"tactic": "simp at h", "annotated_tactic": ["simp at h", []], "state_before": "case cons.nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y : \u03b1\nIH : nextOr [] x d \u2260 d \u2192 x \u2208 []\nh : nextOr [y] x d \u2260 d\n\u22a2 x \u2208 [y]", "state_after": "no goals"}, {"tactic": "by_cases hx : x = y", "annotated_tactic": ["by_cases hx : x = y", []], "state_before": "case cons.cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y z : \u03b1\nzs : List \u03b1\nIH : nextOr (z :: zs) x d \u2260 d \u2192 x \u2208 z :: zs\nh : nextOr (y :: z :: zs) x d \u2260 d\n\u22a2 x \u2208 y :: z :: zs", "state_after": "case pos\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y z : \u03b1\nzs : List \u03b1\nIH : nextOr (z :: zs) x d \u2260 d \u2192 x \u2208 z :: zs\nh : nextOr (y :: z :: zs) x d \u2260 d\nhx : x = y\n\u22a2 x \u2208 y :: z :: zs\n\ncase neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y z : \u03b1\nzs : List \u03b1\nIH : nextOr (z :: zs) x d \u2260 d \u2192 x \u2208 z :: zs\nh : nextOr (y :: z :: zs) x d \u2260 d\nhx : \u00acx = y\n\u22a2 x \u2208 y :: z :: zs"}, {"tactic": "simp [hx]", "annotated_tactic": ["simp [hx]", []], "state_before": "case pos\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y z : \u03b1\nzs : List \u03b1\nIH : nextOr (z :: zs) x d \u2260 d \u2192 x \u2208 z :: zs\nh : nextOr (y :: z :: zs) x d \u2260 d\nhx : x = y\n\u22a2 x \u2208 y :: z :: zs", "state_after": "no goals"}, {"tactic": "rw [nextOr_cons_of_ne _ _ _ _ hx] at h", "annotated_tactic": ["rw [<a>nextOr_cons_of_ne</a> _ _ _ _ hx] at h", [{"full_name": "List.nextOr_cons_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [54, 9], "def_end_pos": [54, 26]}]], "state_before": "case neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y z : \u03b1\nzs : List \u03b1\nIH : nextOr (z :: zs) x d \u2260 d \u2192 x \u2208 z :: zs\nh : nextOr (y :: z :: zs) x d \u2260 d\nhx : \u00acx = y\n\u22a2 x \u2208 y :: z :: zs", "state_after": "case neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y z : \u03b1\nzs : List \u03b1\nIH : nextOr (z :: zs) x d \u2260 d \u2192 x \u2208 z :: zs\nh : nextOr (z :: zs) x d \u2260 d\nhx : \u00acx = y\n\u22a2 x \u2208 y :: z :: zs"}, {"tactic": "simpa [hx] using IH h", "annotated_tactic": ["simpa [hx] using IH h", []], "state_before": "case neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx d y z : \u03b1\nzs : List \u03b1\nIH : nextOr (z :: zs) x d \u2260 d \u2192 x \u2208 z :: zs\nh : nextOr (z :: zs) x d \u2260 d\nhx : \u00acx = y\n\u22a2 x \u2208 y :: z :: zs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/Basic.lean", "full_name": "balanced_zero_union_interior", "start": [263, 1], "end": [264, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "getElem_fin", "start": [16, 9], "end": [17, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.Measure.map_map", "start": [1282, 1], "end": [1284, 75], "traced_tactics": [{"tactic": "simp [hf, hg, hs, hg hs, hg.comp hf, \u2190 preimage_comp]", "annotated_tactic": ["simp [hf, hg, hs, hg hs, hg.comp hf, \u2190 <a>preimage_comp</a>]", [{"full_name": "Set.preimage_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [151, 9], "def_end_pos": [151, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Type u_5\nR : Type u_6\nR' : Type u_7\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t : Set \u03b1\nf\u271d : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nf : \u03b1 \u2192 \u03b2\nhg : Measurable g\nhf : Measurable f\ns : Set \u03b3\nhs : MeasurableSet s\n\u22a2 \u2191\u2191(map g (map f \u03bc)) s = \u2191\u2191(map (g \u2218 f) \u03bc) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.coe_pair", "start": [1181, 1], "end": [1183, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t u v : Finset \u03b1\na\u271d b\u271d a b : \u03b1\n\u22a2 \u2191{a, b} = {a, b}", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t u v : Finset \u03b1\na\u271d b\u271d a b x\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191{a, b} \u2194 x\u271d \u2208 {a, b}"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t u v : Finset \u03b1\na\u271d b\u271d a b x\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191{a, b} \u2194 x\u271d \u2208 {a, b}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/Lemmas.lean", "full_name": "Std.RBSet.size_eq", "start": [682, 1], "end": [682, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Digits.lean", "full_name": "Nat.ofDigits_div_eq_ofDigits_tail", "start": [514, 1], "end": [522, 8], "traced_tactics": [{"tactic": "induction' digits with hd tl", "annotated_tactic": ["induction' digits with hd tl", []], "state_before": "n p : \u2115\nhpos : 0 < p\ndigits : List \u2115\nw\u2081 : \u2200 l \u2208 digits, l < p\n\u22a2 ofDigits p digits / p = ofDigits p (List.tail digits)", "state_after": "case nil\nn p : \u2115\nhpos : 0 < p\nw\u2081 : \u2200 l \u2208 [], l < p\n\u22a2 ofDigits p [] / p = ofDigits p (List.tail [])\n\ncase cons\nn p : \u2115\nhpos : 0 < p\nhd : \u2115\ntl : List \u2115\ntail_ih\u271d : (\u2200 l \u2208 tl, l < p) \u2192 ofDigits p tl / p = ofDigits p (List.tail tl)\nw\u2081 : \u2200 l \u2208 hd :: tl, l < p\n\u22a2 ofDigits p (hd :: tl) / p = ofDigits p (List.tail (hd :: tl))"}, {"tactic": "simp [ofDigits]", "annotated_tactic": ["simp [<a>ofDigits</a>]", [{"full_name": "Nat.ofDigits", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [165, 5], "def_end_pos": [165, 13]}]], "state_before": "case nil\nn p : \u2115\nhpos : 0 < p\nw\u2081 : \u2200 l \u2208 [], l < p\n\u22a2 ofDigits p [] / p = ofDigits p (List.tail [])", "state_after": "no goals"}, {"tactic": "refine' Eq.trans (add_mul_div_left hd _ hpos) _", "annotated_tactic": ["refine' <a>Eq.trans</a> (<a>add_mul_div_left</a> hd _ hpos) _", [{"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}, {"full_name": "Nat.add_mul_div_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [221, 9], "def_end_pos": [221, 25]}]], "state_before": "case cons\nn p : \u2115\nhpos : 0 < p\nhd : \u2115\ntl : List \u2115\ntail_ih\u271d : (\u2200 l \u2208 tl, l < p) \u2192 ofDigits p tl / p = ofDigits p (List.tail tl)\nw\u2081 : \u2200 l \u2208 hd :: tl, l < p\n\u22a2 ofDigits p (hd :: tl) / p = ofDigits p (List.tail (hd :: tl))", "state_after": "case cons\nn p : \u2115\nhpos : 0 < p\nhd : \u2115\ntl : List \u2115\ntail_ih\u271d : (\u2200 l \u2208 tl, l < p) \u2192 ofDigits p tl / p = ofDigits p (List.tail tl)\nw\u2081 : \u2200 l \u2208 hd :: tl, l < p\n\u22a2 hd / p + ofDigits p tl = ofDigits p (List.tail (hd :: tl))"}, {"tactic": "rw [Nat.div_eq_of_lt <| w\u2081 _ <| List.mem_cons_self _ _, zero_add]", "annotated_tactic": ["rw [<a>Nat.div_eq_of_lt</a> <| w\u2081 _ <| <a>List.mem_cons_self</a> _ _, <a>zero_add</a>]", [{"full_name": "Nat.div_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [305, 9], "def_end_pos": [305, 21]}, {"full_name": "List.mem_cons_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [67, 9], "def_end_pos": [67, 22]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "case cons\nn p : \u2115\nhpos : 0 < p\nhd : \u2115\ntl : List \u2115\ntail_ih\u271d : (\u2200 l \u2208 tl, l < p) \u2192 ofDigits p tl / p = ofDigits p (List.tail tl)\nw\u2081 : \u2200 l \u2208 hd :: tl, l < p\n\u22a2 hd / p + ofDigits p tl = ofDigits p (List.tail (hd :: tl))", "state_after": "case cons\nn p : \u2115\nhpos : 0 < p\nhd : \u2115\ntl : List \u2115\ntail_ih\u271d : (\u2200 l \u2208 tl, l < p) \u2192 ofDigits p tl / p = ofDigits p (List.tail tl)\nw\u2081 : \u2200 l \u2208 hd :: tl, l < p\n\u22a2 ofDigits p tl = ofDigits p (List.tail (hd :: tl))"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case cons\nn p : \u2115\nhpos : 0 < p\nhd : \u2115\ntl : List \u2115\ntail_ih\u271d : (\u2200 l \u2208 tl, l < p) \u2192 ofDigits p tl / p = ofDigits p (List.tail tl)\nw\u2081 : \u2200 l \u2208 hd :: tl, l < p\n\u22a2 ofDigits p tl = ofDigits p (List.tail (hd :: tl))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iInf\u2082_mono", "start": [803, 1], "end": [805, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GCDMonoid/Finset.lean", "full_name": "Finset.dvd_gcd", "start": [160, 1], "end": [161, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.sinh_eq", "start": [1026, 8], "end": [1027, 45], "traced_tactics": [{"tactic": "simp [Complex.sinh]", "annotated_tactic": ["simp [<a>Complex.sinh</a>]", [{"full_name": "Complex.sinh", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [78, 5], "def_end_pos": [78, 9]}]], "state_before": "x\u271d y x : \u211d\n\u22a2 \u2191(sinh x) = \u2191((rexp x - rexp (-x)) / 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "pow_lt_pow_iff_left", "start": [323, 1], "end": [324, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.image2_iInter\u2082_subset_right", "start": [1943, 1], "end": [1946, 59], "traced_tactics": [{"tactic": "simp_rw [image2_subset_iff, mem_iInter]", "annotated_tactic": ["simp_rw [<a>image2_subset_iff</a>, <a>mem_iInter</a>]", [{"full_name": "Set.image2_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [64, 9], "def_end_pos": [64, 26]}, {"full_name": "Set.mem_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [278, 9], "def_end_pos": [278, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 image2 f s (\u22c2 i, \u22c2 j, t i j) \u2286 \u22c2 i, \u22c2 j, image2 f s (t i j)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 \u2200 x \u2208 s, \u2200 (y : \u03b2), (\u2200 (i : \u03b9) (i_1 : \u03ba i), y \u2208 t i i_1) \u2192 \u2200 (i : \u03b9) (i_1 : \u03ba i), f x y \u2208 image2 f s (t i i_1)"}, {"tactic": "exact fun x hx y hy i j => mem_image2_of_mem hx (hy _ _)", "annotated_tactic": ["exact fun x hx y hy i j => <a>mem_image2_of_mem</a> hx (hy _ _)", [{"full_name": "Set.mem_image2_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [331, 9], "def_end_pos": [331, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 \u2200 x \u2208 s, \u2200 (y : \u03b2), (\u2200 (i : \u03b9) (i_1 : \u03ba i), y \u2208 t i i_1) \u2192 \u2200 (i : \u03b9) (i_1 : \u03ba i), f x y \u2208 image2 f s (t i i_1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/HasLimits.lean", "full_name": "CategoryTheory.Limits.hasColimitsOfSizeOfUnivLE", "start": [1214, 1], "end": [1217, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.toLin'_reindex", "start": [415, 1], "end": [420, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.vecMul_sub", "start": [1943, 1], "end": [1944, 87], "traced_tactics": [{"tactic": "simp [sub_eq_add_neg, vecMul_add, vecMul_neg]", "annotated_tactic": ["simp [<a>sub_eq_add_neg</a>, <a>vecMul_add</a>, <a>vecMul_neg</a>]", [{"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}, {"full_name": "Matrix.vecMul_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1778, 9], "def_end_pos": [1778, 19]}, {"full_name": "Matrix.vecMul_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1919, 9], "def_end_pos": [1919, 19]}]], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocRing \u03b1\ninst\u271d : Fintype m\nA B : Matrix m n \u03b1\nx : m \u2192 \u03b1\n\u22a2 x \u1d65* (A - B) = x \u1d65* A - x \u1d65* B", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/Finite.lean", "full_name": "LinearIndependent.fintype_card_le_finrank", "start": [173, 1], "end": [176, 39], "traced_tactics": [{"tactic": "simpa using h.cardinal_mk_le_finrank", "annotated_tactic": ["simpa using h.cardinal_mk_le_finrank", []], "state_before": "R : Type u\nM M\u2081 : Type v\nM' : Type v'\n\u03b9\u271d : Type w\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup M'\ninst\u271d\u2076 : AddCommGroup M\u2081\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R M'\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : StrongRankCondition R\ninst\u271d\u00b9 : Module.Finite R M\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nb : \u03b9 \u2192 M\nh : LinearIndependent R b\n\u22a2 Fintype.card \u03b9 \u2264 finrank R M", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean", "full_name": "Fin.find_eq_none_iff", "start": [1025, 1], "end": [1026, 96], "traced_tactics": [{"tactic": "rw [\u2190 not_exists, \u2190 isSome_find_iff]", "annotated_tactic": ["rw [\u2190 <a>not_exists</a>, \u2190 <a>isSome_find_iff</a>]", [{"full_name": "not_exists", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [187, 17], "def_end_pos": [187, 27]}, {"full_name": "Fin.isSome_find_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Tuple/Basic.lean", "def_pos": [1005, 9], "def_end_pos": [1005, 24]}]], "state_before": "m n\u271d n : \u2115\np : Fin n \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 find p = none \u2194 \u2200 (i : Fin n), \u00acp i", "state_after": "m n\u271d n : \u2115\np : Fin n \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 find p = none \u2194 \u00acOption.isSome (find fun x => p x) = true"}, {"tactic": "cases find p <;> simp", "annotated_tactic": ["cases <a>find</a> p <;> simp", [{"full_name": "Fin.find", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Tuple/Basic.lean", "def_pos": [976, 5], "def_end_pos": [976, 9]}]], "state_before": "m n\u271d n : \u2115\np : Fin n \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 find p = none \u2194 \u00acOption.isSome (find fun x => p x) = true", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/NormalClosure.lean", "full_name": "IntermediateField.normalClosure_of_normal", "start": [229, 1], "end": [230, 74], "traced_tactics": [{"tactic": "simp only [normalClosure_def, AlgHom.fieldRange_of_normal, iSup_const]", "annotated_tactic": ["simp only [<a>normalClosure_def</a>, <a>AlgHom.fieldRange_of_normal</a>, <a>iSup_const</a>]", [{"full_name": "normalClosure_def", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/NormalClosure.lean", "def_pos": [47, 7], "def_end_pos": [47, 24]}, {"full_name": "AlgHom.fieldRange_of_normal", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Normal.lean", "def_pos": [271, 9], "def_end_pos": [271, 36]}, {"full_name": "iSup_const", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [994, 9], "def_end_pos": [994, 19]}]], "state_before": "F : Type u_1\nK\u271d : Type u_2\nL : Type u_3\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Field K\u271d\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra F K\u271d\ninst\u271d\u00b9 : Algebra F L\nK K' : IntermediateField F L\ninst\u271d : Normal F \u21a5K\n\u22a2 normalClosure F (\u21a5K) L = K", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Rat/Lemmas.lean", "full_name": "Rat.maybeNormalize_eq_normalize", "start": [76, 1], "end": [82, 39], "traced_tactics": [{"tactic": "simp only [maybeNormalize_eq, mk_eq_normalize, Int.div_eq_ediv_of_dvd hn]", "annotated_tactic": ["simp only [<a>maybeNormalize_eq</a>, <a>mk_eq_normalize</a>, <a>Int.div_eq_ediv_of_dvd</a> hn]", [{"full_name": "Rat.maybeNormalize_eq", "def_path": ".lake/packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [24, 17], "def_end_pos": [24, 34]}, {"full_name": "Rat.mk_eq_normalize", "def_path": ".lake/packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [47, 9], "def_end_pos": [47, 24]}, {"full_name": "Int.div_eq_ediv_of_dvd", "def_path": ".lake/packages/std/Std/Data/Int/DivMod.lean", "def_pos": [542, 9], "def_end_pos": [542, 27]}]], "state_before": "num : Int\nden g : Nat\nden_nz : den / g \u2260 0\nreduced : Nat.Coprime (Int.natAbs (Int.div num \u2191g)) (den / g)\nhn : \u2191g \u2223 num\nhd : g \u2223 den\n\u22a2 maybeNormalize num den g den_nz reduced = normalize num den \u22ef", "state_after": "num : Int\nden g : Nat\nden_nz : den / g \u2260 0\nreduced : Nat.Coprime (Int.natAbs (Int.div num \u2191g)) (den / g)\nhn : \u2191g \u2223 num\nhd : g \u2223 den\n\u22a2 normalize (num / \u2191g) (den / g) den_nz = normalize num den \u22ef"}, {"tactic": "rw [\u2190 normalize_mul_right _ this, Int.ediv_mul_cancel hn]", "annotated_tactic": ["rw [\u2190 <a>normalize_mul_right</a> _ this, <a>Int.ediv_mul_cancel</a> hn]", [{"full_name": "Rat.normalize_mul_right", "def_path": ".lake/packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [58, 9], "def_end_pos": [58, 28]}, {"full_name": "Int.ediv_mul_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean", "def_pos": [304, 19], "def_end_pos": [304, 34]}]], "state_before": "num : Int\nden g : Nat\nden_nz : den / g \u2260 0\nreduced : Nat.Coprime (Int.natAbs (Int.div num \u2191g)) (den / g)\nhn : \u2191g \u2223 num\nhd : g \u2223 den\nthis : g \u2260 0\n\u22a2 normalize (num / \u2191g) (den / g) den_nz = normalize num den \u22ef", "state_after": "num : Int\nden g : Nat\nden_nz : den / g \u2260 0\nreduced : Nat.Coprime (Int.natAbs (Int.div num \u2191g)) (den / g)\nhn : \u2191g \u2223 num\nhd : g \u2223 den\nthis : g \u2260 0\n\u22a2 normalize num (den / g * g) \u22ef = normalize num den \u22ef"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "num : Int\nden g : Nat\nden_nz : den / g \u2260 0\nreduced : Nat.Coprime (Int.natAbs (Int.div num \u2191g)) (den / g)\nhn : \u2191g \u2223 num\nhd : g \u2223 den\nthis : g \u2260 0\n\u22a2 normalize num (den / g * g) \u22ef = normalize num den \u22ef", "state_after": "case e_den\nnum : Int\nden g : Nat\nden_nz : den / g \u2260 0\nreduced : Nat.Coprime (Int.natAbs (Int.div num \u2191g)) (den / g)\nhn : \u2191g \u2223 num\nhd : g \u2223 den\nthis : g \u2260 0\n\u22a2 den / g * g = den"}, {"tactic": "exact Nat.div_mul_cancel hd", "annotated_tactic": ["exact <a>Nat.div_mul_cancel</a> hd", [{"full_name": "Nat.div_mul_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean", "def_pos": [97, 19], "def_end_pos": [97, 33]}]], "state_before": "case e_den\nnum : Int\nden g : Nat\nden_nz : den / g \u2260 0\nreduced : Nat.Coprime (Int.natAbs (Int.div num \u2191g)) (den / g)\nhn : \u2191g \u2223 num\nhd : g \u2223 den\nthis : g \u2260 0\n\u22a2 den / g * g = den", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Monotone.isBoundedUnder_le_comp", "start": [127, 1], "end": [130, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Basic.lean", "full_name": "convex_empty", "start": [88, 1], "end": [88, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean", "full_name": "Submonoid.LocalizationMap.mk'_eq_iff_eq_mul", "start": [779, 1], "end": [780, 43], "traced_tactics": [{"tactic": "rw [eq_comm, eq_mk'_iff_mul_eq, eq_comm]", "annotated_tactic": ["rw [<a>eq_comm</a>, <a>eq_mk'_iff_mul_eq</a>, <a>eq_comm</a>]", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "Submonoid.LocalizationMap.eq_mk'_iff_mul_eq", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/MonoidLocalization.lean", "def_pos": [773, 9], "def_end_pos": [773, 26]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "M : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\nx : M\ny : \u21a5S\nz : N\n\u22a2 mk' f x y = z \u2194 (toMap f) x = z * (toMap f) \u2191y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LocalizedModule.lean", "full_name": "IsLocalizedModule.mk'_smul", "start": [965, 1], "end": [967, 54], "traced_tactics": [{"tactic": "delta mk'", "annotated_tactic": ["delta <a>mk'</a>", [{"full_name": "IsLocalizedModule.mk'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LocalizedModule.lean", "def_pos": [961, 19], "def_end_pos": [961, 22]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\ninst\u271d\u2079 : AddCommMonoid M''\nA : Type u_5\ninst\u271d\u2078 : CommSemiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Module A M'\ninst\u271d\u2075 : IsLocalization S A\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R M'\ninst\u271d\u00b2 : Module R M''\ninst\u271d\u00b9 : IsScalarTower R A M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\ninst\u271d : IsLocalizedModule S f\nr : R\nm : M\ns : \u21a5S\n\u22a2 mk' f (r \u2022 m) s = r \u2022 mk' f m s", "state_after": "R : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\ninst\u271d\u2079 : AddCommMonoid M''\nA : Type u_5\ninst\u271d\u2078 : CommSemiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Module A M'\ninst\u271d\u2075 : IsLocalization S A\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R M'\ninst\u271d\u00b2 : Module R M''\ninst\u271d\u00b9 : IsScalarTower R A M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\ninst\u271d : IsLocalizedModule S f\nr : R\nm : M\ns : \u21a5S\n\u22a2 (fromLocalizedModule S f) (LocalizedModule.mk (r \u2022 m) s) = r \u2022 (fromLocalizedModule S f) (LocalizedModule.mk m s)"}, {"tactic": "rw [\u2190 LocalizedModule.smul'_mk, LinearMap.map_smul]", "annotated_tactic": ["rw [\u2190 <a>LocalizedModule.smul'_mk</a>, <a>LinearMap.map_smul</a>]", [{"full_name": "LocalizedModule.smul'_mk", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LocalizedModule.lean", "def_pos": [426, 9], "def_end_pos": [426, 17]}, {"full_name": "LinearMap.map_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [355, 19], "def_end_pos": [355, 27]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\ninst\u271d\u2079 : AddCommMonoid M''\nA : Type u_5\ninst\u271d\u2078 : CommSemiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Module A M'\ninst\u271d\u2075 : IsLocalization S A\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R M'\ninst\u271d\u00b2 : Module R M''\ninst\u271d\u00b9 : IsScalarTower R A M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\ninst\u271d : IsLocalizedModule S f\nr : R\nm : M\ns : \u21a5S\n\u22a2 (fromLocalizedModule S f) (LocalizedModule.mk (r \u2022 m) s) = r \u2022 (fromLocalizedModule S f) (LocalizedModule.mk m s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "Submodule.map_inl", "start": [551, 1], "end": [554, 14], "traced_tactics": [{"tactic": "ext \u27e8x, y\u27e9", "annotated_tactic": ["ext \u27e8x, y\u27e9", []], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 map (inl R M M\u2082) p = prod p \u22a5", "state_after": "case h.mk\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\ny : M\u2082\n\u22a2 (x, y) \u2208 map (inl R M M\u2082) p \u2194 (x, y) \u2208 prod p \u22a5"}, {"tactic": "simp only [and_left_comm, eq_comm, mem_map, Prod.mk.inj_iff, inl_apply, mem_bot, exists_eq_left',\n  mem_prod]", "annotated_tactic": ["simp only [<a>and_left_comm</a>, <a>eq_comm</a>, <a>mem_map</a>, <a>Prod.mk.inj_iff</a>, <a>inl_apply</a>, <a>mem_bot</a>, <a>exists_eq_left'</a>,\n    <a>mem_prod</a>]", [{"full_name": "and_left_comm", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [41, 9], "def_end_pos": [41, 22]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "Submodule.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [89, 9], "def_end_pos": [89, 16]}, {"full_name": "Prod.mk.inj_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [102, 9], "def_end_pos": [102, 19]}, {"full_name": "LinearMap.inl_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [191, 9], "def_end_pos": [191, 18]}, {"full_name": "Submodule.mem_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [72, 9], "def_end_pos": [72, 16]}, {"full_name": "exists_eq_left'", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [226, 17], "def_end_pos": [226, 32]}, {"full_name": "Submodule.mem_prod", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [821, 9], "def_end_pos": [821, 17]}]], "state_before": "case h.mk\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\ny : M\u2082\n\u22a2 (x, y) \u2208 map (inl R M M\u2082) p \u2194 (x, y) \u2208 prod p \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/IntegralDomain.lean", "full_name": "Finite.isField_of_domain", "start": [109, 1], "end": [111, 80], "traced_tactics": [{"tactic": "cases nonempty_fintype R", "annotated_tactic": ["cases <a>nonempty_fintype</a> R", [{"full_name": "nonempty_fintype", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [442, 9], "def_end_pos": [442, 25]}]], "state_before": "R\u271d : Type u_1\nG : Type u_2\ninst\u271d\u2075 : Ring R\u271d\ninst\u271d\u2074 : IsDomain R\u271d\ninst\u271d\u00b3 : Fintype R\u271d\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : Finite R\n\u22a2 IsField R", "state_after": "case intro\nR\u271d : Type u_1\nG : Type u_2\ninst\u271d\u2075 : Ring R\u271d\ninst\u271d\u2074 : IsDomain R\u271d\ninst\u271d\u00b3 : Fintype R\u271d\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : Finite R\nval\u271d : Fintype R\n\u22a2 IsField R"}, {"tactic": "exact @Field.toIsField R (@Fintype.fieldOfDomain R _ _ (Classical.decEq R) _)", "annotated_tactic": ["exact @<a>Field.toIsField</a> R (@<a>Fintype.fieldOfDomain</a> R _ _ (<a>Classical.decEq</a> R) _)", [{"full_name": "Field.toIsField", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Field/IsField.lean", "def_pos": [47, 9], "def_end_pos": [47, 24]}, {"full_name": "Fintype.fieldOfDomain", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/IntegralDomain.lean", "def_pos": [105, 5], "def_end_pos": [105, 26]}, {"full_name": "Classical.decEq", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [979, 19], "def_end_pos": [979, 24]}]], "state_before": "case intro\nR\u271d : Type u_1\nG : Type u_2\ninst\u271d\u2075 : Ring R\u271d\ninst\u271d\u2074 : IsDomain R\u271d\ninst\u271d\u00b3 : Fintype R\u271d\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : Finite R\nval\u271d : Fintype R\n\u22a2 IsField R", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "full_name": "LinearIsometryEquiv.hasStrictFDerivAt", "start": [264, 11], "end": [265, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.map_apply", "start": [148, 1], "end": [149, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Tendsto.eventually_ne_atTop", "start": [220, 11], "end": [222, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Finite/Basic.lean", "full_name": "ZMod.frobenius_zmod", "start": [517, 1], "end": [519, 54], "traced_tactics": [{"tactic": "ext a", "annotated_tactic": ["ext a", []], "state_before": "K : Type u_1\nR : Type u_2\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 frobenius (ZMod p) p = RingHom.id (ZMod p)", "state_after": "case a\nK : Type u_1\nR : Type u_2\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\n\u22a2 (frobenius (ZMod p) p) a = (RingHom.id (ZMod p)) a"}, {"tactic": "rw [frobenius_def, ZMod.pow_card, RingHom.id_apply]", "annotated_tactic": ["rw [<a>frobenius_def</a>, <a>ZMod.pow_card</a>, <a>RingHom.id_apply</a>]", [{"full_name": "frobenius_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharP/ExpChar.lean", "def_pos": [293, 9], "def_end_pos": [293, 22]}, {"full_name": "ZMod.pow_card", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finite/Basic.lean", "def_pos": [505, 9], "def_end_pos": [505, 17]}, {"full_name": "RingHom.id_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [637, 9], "def_end_pos": [637, 17]}]], "state_before": "case a\nK : Type u_1\nR : Type u_2\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\n\u22a2 (frobenius (ZMod p) p) a = (RingHom.id (ZMod p)) a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Bicategory/Basic.lean", "full_name": "CategoryTheory.Bicategory.associator_inv_naturality_middle", "start": [361, 1], "end": [362, 74], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "B : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf : a \u27f6 b\ng g' : b \u27f6 c\n\u03b7 : g \u27f6 g'\nh : c \u27f6 d\n\u22a2 f \u25c1 \u03b7 \u25b7 h \u226b (\u03b1_ f g' h).inv = (\u03b1_ f g h).inv \u226b (f \u25c1 \u03b7) \u25b7 h", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Injective.comp_left", "start": [148, 1], "end": [150, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.piecewise_mem_Icc", "start": [2702, 1], "end": [2704, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean", "full_name": "Nat.ord_proj_dvd", "start": [340, 1], "end": [346, 37], "traced_tactics": [{"tactic": "if hp : p.Prime then ?_ else simp [hp]", "annotated_tactic": ["if hp : p.Prime then ?_ else simp [hp]", []], "state_before": "a b m n\u271d p\u271d n p : \u2115\n\u22a2 p ^ (factorization n) p \u2223 n", "state_after": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\n\u22a2 p ^ (factorization n) p \u2223 n"}, {"tactic": "rw [\u2190 factors_count_eq]", "annotated_tactic": ["rw [\u2190 <a>factors_count_eq</a>]", [{"full_name": "Nat.factors_count_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 25]}]], "state_before": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\n\u22a2 p ^ (factorization n) p \u2223 n", "state_after": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\n\u22a2 p ^ count p (factors n) \u2223 n"}, {"tactic": "apply dvd_of_factors_subperm (pow_ne_zero _ hp.ne_zero)", "annotated_tactic": ["apply <a>dvd_of_factors_subperm</a> (<a>pow_ne_zero</a> _ hp.ne_zero)", [{"full_name": "Nat.dvd_of_factors_subperm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factors.lean", "def_pos": [241, 9], "def_end_pos": [241, 31]}, {"full_name": "pow_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [199, 7], "def_end_pos": [199, 18]}]], "state_before": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\n\u22a2 p ^ count p (factors n) \u2223 n", "state_after": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\n\u22a2 factors (p ^ count p (factors n)) <+~ factors n"}, {"tactic": "rw [hp.factors_pow, List.subperm_ext_iff]", "annotated_tactic": ["rw [hp.factors_pow, <a>List.subperm_ext_iff</a>]", [{"full_name": "List.subperm_ext_iff", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [578, 9], "def_end_pos": [578, 24]}]], "state_before": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\n\u22a2 factors (p ^ count p (factors n)) <+~ factors n", "state_after": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\n\u22a2 \u2200 x \u2208 replicate (count p (factors n)) p, count x (replicate (count p (factors n)) p) \u2264 count x (factors n)"}, {"tactic": "intro q hq", "annotated_tactic": ["intro q hq", []], "state_before": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\n\u22a2 \u2200 x \u2208 replicate (count p (factors n)) p, count x (replicate (count p (factors n)) p) \u2264 count x (factors n)", "state_after": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\nq : \u2115\nhq : q \u2208 replicate (count p (factors n)) p\n\u22a2 count q (replicate (count p (factors n)) p) \u2264 count q (factors n)"}, {"tactic": "simp [List.eq_of_mem_replicate hq]", "annotated_tactic": ["simp [<a>List.eq_of_mem_replicate</a> hq]", [{"full_name": "List.eq_of_mem_replicate", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [463, 9], "def_end_pos": [463, 28]}]], "state_before": "a b m n\u271d p\u271d n p : \u2115\nhp : Prime p\nq : \u2115\nhq : q \u2208 replicate (count p (factors n)) p\n\u22a2 count q (replicate (count p (factors n)) p) \u2264 count q (factors n)", "state_after": "no goals"}, {"tactic": "simp [hp]", "annotated_tactic": ["simp [hp]", []], "state_before": "a b m n\u271d p\u271d n p : \u2115\nhp : \u00acPrime p\n\u22a2 p ^ (factorization n) p \u2223 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "full_name": "Real.logb_lt_iff_lt_rpow_of_base_lt_one", "start": [317, 1], "end": [318, 101], "traced_tactics": [{"tactic": "rw [\u2190 rpow_lt_rpow_left_iff_of_base_lt_one b_pos b_lt_one, rpow_logb b_pos (b_ne_one b_lt_one) hx]", "annotated_tactic": ["rw [\u2190 <a>rpow_lt_rpow_left_iff_of_base_lt_one</a> b_pos b_lt_one, <a>rpow_logb</a> b_pos (<a>b_ne_one</a> b_lt_one) hx]", [{"full_name": "Real.rpow_lt_rpow_left_iff_of_base_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [671, 9], "def_end_pos": [671, 45]}, {"full_name": "Real.rpow_logb", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "def_pos": [141, 9], "def_end_pos": [141, 18]}, {"full_name": "_private.\u00ab.lake\u00bb.packages.mathlib.Mathlib.Analysis.SpecialFunctions.Log.Base.0.Real.b_ne_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "def_pos": [294, 17], "def_end_pos": [294, 25]}]], "state_before": "b x y : \u211d\nb_pos : 0 < b\nb_lt_one : b < 1\nhx : 0 < x\n\u22a2 logb b x < y \u2194 b ^ y < x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.image_compl_eq", "start": [427, 1], "end": [428, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.card_le_six", "start": [135, 1], "end": [136, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "IsGLB.isGLB_of_tendsto", "start": [1306, 1], "end": [1309, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioc_subset_Ioo_union_Icc", "start": [1568, 1], "end": [1569, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "full_name": "NonUnitalSubalgebra.inclusion_injective", "start": [809, 1], "end": [810, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounded.lean", "full_name": "Set.unbounded_le_of_forall_exists_lt", "start": [38, 1], "end": [41, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "full_name": "smul_eq_mul", "start": [93, 1], "end": [94, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.append_eq_cons", "start": [154, 1], "end": [157, 89], "traced_tactics": [{"tactic": "cases a with simp | cons a as => ?_", "annotated_tactic": ["cases a with simp | <a>cons</a> a as => ?_", [{"full_name": "List.cons", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2271, 5], "def_end_pos": [2271, 9]}]], "state_before": "\u03b1\u271d : Type u_1\na b : List \u03b1\u271d\nx : \u03b1\u271d\nc : List \u03b1\u271d\n\u22a2 a ++ b = x :: c \u2194 a = [] \u2227 b = x :: c \u2228 \u2203 a', a = x :: a' \u2227 c = a' ++ b", "state_after": "case cons\n\u03b1\u271d : Type u_1\nb : List \u03b1\u271d\nx : \u03b1\u271d\nc : List \u03b1\u271d\na : \u03b1\u271d\nas : List \u03b1\u271d\n\u22a2 a = x \u2227 as ++ b = c \u2194 \u2203 a', (a = x \u2227 as = a') \u2227 c = a' ++ b"}, {"tactic": "exact \u27e8fun h => \u27e8as, by simp [h]\u27e9, fun \u27e8a', \u27e8aeq, aseq\u27e9, h\u27e9 => \u27e8aeq, by rw [aseq, h]\u27e9\u27e9", "annotated_tactic": ["exact \u27e8fun h => \u27e8as, by simp [h]\u27e9, fun \u27e8a', \u27e8aeq, aseq\u27e9, h\u27e9 => \u27e8aeq, by rw [aseq, h]\u27e9\u27e9", []], "state_before": "case cons\n\u03b1\u271d : Type u_1\nb : List \u03b1\u271d\nx : \u03b1\u271d\nc : List \u03b1\u271d\na : \u03b1\u271d\nas : List \u03b1\u271d\n\u22a2 a = x \u2227 as ++ b = c \u2194 \u2203 a', (a = x \u2227 as = a') \u2227 c = a' ++ b", "state_after": "no goals"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "\u03b1\u271d : Type u_1\nb : List \u03b1\u271d\nx : \u03b1\u271d\nc : List \u03b1\u271d\na : \u03b1\u271d\nas : List \u03b1\u271d\nh : a = x \u2227 as ++ b = c\n\u22a2 (a = x \u2227 as = as) \u2227 c = as ++ b", "state_after": "no goals"}, {"tactic": "rw [aseq, h]", "annotated_tactic": ["rw [aseq, h]", []], "state_before": "\u03b1\u271d : Type u_1\nb : List \u03b1\u271d\nx : \u03b1\u271d\nc : List \u03b1\u271d\na : \u03b1\u271d\nas : List \u03b1\u271d\nx\u271d : \u2203 a', (a = x \u2227 as = a') \u2227 c = a' ++ b\na' : List \u03b1\u271d\naeq : a = x\naseq : as = a'\nh : c = a' ++ b\n\u22a2 as ++ b = c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Commute/Basic.lean", "full_name": "Commute.inv_inv", "start": [26, 11], "end": [27, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.eventually_iff_seq_eventually", "start": [1942, 1], "end": [1945, 67], "traced_tactics": [{"tactic": "simpa using tendsto_iff_seq_tendsto (f := id) (l := \ud835\udcdf {x | p x})", "annotated_tactic": ["simpa using <a>tendsto_iff_seq_tendsto</a> (f := <a>id</a>) (l := \ud835\udcdf {x | p x})", [{"full_name": "Filter.tendsto_iff_seq_tendsto", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [1925, 9], "def_end_pos": [1925, 32]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nl : Filter \u03b9\np : \u03b9 \u2192 Prop\ninst\u271d : IsCountablyGenerated l\n\u22a2 (\u2200\u1da0 (n : \u03b9) in l, p n) \u2194 \u2200 (x : \u2115 \u2192 \u03b9), Tendsto x atTop l \u2192 \u2200\u1da0 (n : \u2115) in atTop, p (x n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/OfFn.lean", "full_name": "List.ofFn_add", "start": [147, 1], "end": [154, 8], "traced_tactics": [{"tactic": "induction' n with n IH", "annotated_tactic": ["induction' n with n IH", []], "state_before": "\u03b1 : Type u\nm n : \u2115\nf : Fin (m + n) \u2192 \u03b1\n\u22a2 ofFn f = (ofFn fun i => f (Fin.castAdd n i)) ++ ofFn fun j => f (Fin.natAdd m j)", "state_after": "case zero\n\u03b1 : Type u\nm : \u2115\nf : Fin (m + zero) \u2192 \u03b1\n\u22a2 ofFn f = (ofFn fun i => f (Fin.castAdd zero i)) ++ ofFn fun j => f (Fin.natAdd m j)\n\ncase succ\n\u03b1 : Type u\nm n : \u2115\nIH : \u2200 (f : Fin (m + n) \u2192 \u03b1), ofFn f = (ofFn fun i => f (Fin.castAdd n i)) ++ ofFn fun j => f (Fin.natAdd m j)\nf : Fin (m + succ n) \u2192 \u03b1\n\u22a2 ofFn f = (ofFn fun i => f (Fin.castAdd (succ n) i)) ++ ofFn fun j => f (Fin.natAdd m j)"}, {"tactic": "rw [ofFn_zero, append_nil, Fin.castAdd_zero, Fin.cast_refl]", "annotated_tactic": ["rw [<a>ofFn_zero</a>, <a>append_nil</a>, <a>Fin.castAdd_zero</a>, <a>Fin.cast_refl</a>]", [{"full_name": "List.ofFn_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/OfFn.lean", "def_pos": [109, 9], "def_end_pos": [109, 18]}, {"full_name": "List.append_nil", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [133, 17], "def_end_pos": [133, 27]}, {"full_name": "Fin.castAdd_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [323, 17], "def_end_pos": [323, 29]}, {"full_name": "Fin.cast_refl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [805, 17], "def_end_pos": [805, 26]}]], "state_before": "case zero\n\u03b1 : Type u\nm : \u2115\nf : Fin (m + zero) \u2192 \u03b1\n\u22a2 ofFn f = (ofFn fun i => f (Fin.castAdd zero i)) ++ ofFn fun j => f (Fin.natAdd m j)", "state_after": "case zero\n\u03b1 : Type u\nm : \u2115\nf : Fin (m + zero) \u2192 \u03b1\n\u22a2 ofFn f = ofFn fun i => f (id i)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case zero\n\u03b1 : Type u\nm : \u2115\nf : Fin (m + zero) \u2192 \u03b1\n\u22a2 ofFn f = ofFn fun i => f (id i)", "state_after": "no goals"}, {"tactic": "rw [ofFn_succ', ofFn_succ', IH, append_concat]", "annotated_tactic": ["rw [<a>ofFn_succ'</a>, <a>ofFn_succ'</a>, IH, <a>append_concat</a>]", [{"full_name": "List.ofFn_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/OfFn.lean", "def_pos": [121, 9], "def_end_pos": [121, 19]}, {"full_name": "List.ofFn_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/OfFn.lean", "def_pos": [121, 9], "def_end_pos": [121, 19]}, {"full_name": "List.append_concat", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [205, 9], "def_end_pos": [205, 22]}]], "state_before": "case succ\n\u03b1 : Type u\nm n : \u2115\nIH : \u2200 (f : Fin (m + n) \u2192 \u03b1), ofFn f = (ofFn fun i => f (Fin.castAdd n i)) ++ ofFn fun j => f (Fin.natAdd m j)\nf : Fin (m + succ n) \u2192 \u03b1\n\u22a2 ofFn f = (ofFn fun i => f (Fin.castAdd (succ n) i)) ++ ofFn fun j => f (Fin.natAdd m j)", "state_after": "case succ\n\u03b1 : Type u\nm n : \u2115\nIH : \u2200 (f : Fin (m + n) \u2192 \u03b1), ofFn f = (ofFn fun i => f (Fin.castAdd n i)) ++ ofFn fun j => f (Fin.natAdd m j)\nf : Fin (m + succ n) \u2192 \u03b1\n\u22a2 concat ((ofFn fun i => f (Fin.castSucc (Fin.castAdd n i))) ++ ofFn fun j => f (Fin.castSucc (Fin.natAdd m j)))\n      (f (Fin.last (Nat.add m n))) =\n    concat ((ofFn fun i => f (Fin.castAdd (succ n) i)) ++ ofFn fun i => f (Fin.natAdd m (Fin.castSucc i)))\n      (f (Fin.natAdd m (Fin.last n)))"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case succ\n\u03b1 : Type u\nm n : \u2115\nIH : \u2200 (f : Fin (m + n) \u2192 \u03b1), ofFn f = (ofFn fun i => f (Fin.castAdd n i)) ++ ofFn fun j => f (Fin.natAdd m j)\nf : Fin (m + succ n) \u2192 \u03b1\n\u22a2 concat ((ofFn fun i => f (Fin.castSucc (Fin.castAdd n i))) ++ ofFn fun j => f (Fin.castSucc (Fin.natAdd m j)))\n      (f (Fin.last (Nat.add m n))) =\n    concat ((ofFn fun i => f (Fin.castAdd (succ n) i)) ++ ofFn fun i => f (Fin.natAdd m (Fin.castSucc i)))\n      (f (Fin.natAdd m (Fin.last n)))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "IsBezout.gcd_dvd_right", "start": [188, 1], "end": [189, 83], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b9 : CommRing R\nx y z : R\ninst\u271d : IsPrincipal (Ideal.span {x, y})\n\u22a2 y \u2208 {x, y}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Prod.lean", "full_name": "Filter.mem_prod_iff_left", "start": [257, 1], "end": [261, 55], "traced_tactics": [{"tactic": "simp only [mem_prod_iff, prod_subset_iff]", "annotated_tactic": ["simp only [<a>mem_prod_iff</a>, <a>prod_subset_iff</a>]", [{"full_name": "Filter.mem_prod_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}, {"full_name": "Set.prod_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [68, 9], "def_end_pos": [68, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns\u271d : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 s \u2208 f \u00d7\u02e2 g \u2194 \u2203 t \u2208 f, \u2200\u1da0 (y : \u03b2) in g, \u2200 x \u2208 t, (x, y) \u2208 s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns\u271d : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 (\u2203 t\u2081 \u2208 f, \u2203 t\u2082 \u2208 g, \u2200 x \u2208 t\u2081, \u2200 y \u2208 t\u2082, (x, y) \u2208 s) \u2194 \u2203 t \u2208 f, \u2200\u1da0 (y : \u03b2) in g, \u2200 x \u2208 t, (x, y) \u2208 s"}, {"tactic": "refine exists_congr fun _ => Iff.rfl.and <| Iff.trans ?_ exists_mem_subset_iff", "annotated_tactic": ["refine <a>exists_congr</a> fun _ => Iff.rfl.and <| <a>Iff.trans</a> ?_ <a>exists_mem_subset_iff</a>", [{"full_name": "exists_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [143, 9], "def_end_pos": [143, 21]}, {"full_name": "Iff.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [798, 9], "def_end_pos": [798, 18]}, {"full_name": "Filter.exists_mem_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [224, 9], "def_end_pos": [224, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns\u271d : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\n\u22a2 (\u2203 t\u2081 \u2208 f, \u2203 t\u2082 \u2208 g, \u2200 x \u2208 t\u2081, \u2200 y \u2208 t\u2082, (x, y) \u2208 s) \u2194 \u2203 t \u2208 f, \u2200\u1da0 (y : \u03b2) in g, \u2200 x \u2208 t, (x, y) \u2208 s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns\u271d : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\nx\u271d : Set \u03b1\n\u22a2 (\u2203 t\u2082 \u2208 g, \u2200 x \u2208 x\u271d, \u2200 y \u2208 t\u2082, (x, y) \u2208 s) \u2194 \u2203 t \u2208 g, t \u2286 {x | (fun y => \u2200 x \u2208 x\u271d, (x, y) \u2208 s) x}"}, {"tactic": "exact exists_congr fun _ => Iff.rfl.and forall\u2082_swap", "annotated_tactic": ["exact <a>exists_congr</a> fun _ => Iff.rfl.and <a>forall\u2082_swap</a>", [{"full_name": "exists_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [143, 9], "def_end_pos": [143, 21]}, {"full_name": "forall\u2082_swap", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [657, 9], "def_end_pos": [657, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns\u271d : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\nx\u271d : Set \u03b1\n\u22a2 (\u2203 t\u2082 \u2208 g, \u2200 x \u2208 x\u271d, \u2200 y \u2208 t\u2082, (x, y) \u2208 s) \u2194 \u2203 t \u2208 g, t \u2286 {x | (fun y => \u2200 x \u2208 x\u271d, (x, y) \u2208 s) x}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean", "full_name": "ArithmeticFunction.inv_zetaUnit", "start": [1194, 1], "end": [1195, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.IsBigO.prod_left_snd", "start": [1050, 1], "end": [1051, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "full_name": "Equiv.Perm.card_cycleType_eq_zero", "start": [87, 1], "end": [88, 39], "traced_tactics": [{"tactic": "rw [card_eq_zero, cycleType_eq_zero]", "annotated_tactic": ["rw [<a>card_eq_zero</a>, <a>cycleType_eq_zero</a>]", [{"full_name": "Multiset.card_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [823, 9], "def_end_pos": [823, 21]}, {"full_name": "Equiv.Perm.cycleType_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Type.lean", "def_pos": [79, 9], "def_end_pos": [79, 26]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Perm \u03b1\n\u22a2 card (cycleType \u03c3) = 0 \u2194 \u03c3 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ico_inter_Iio", "start": [1856, 1], "end": [1857, 62], "traced_tactics": [{"tactic": "simp (config := { contextual := true }) [iff_def]", "annotated_tactic": ["simp (config := { contextual := <a>true</a> }) [<a>iff_def</a>]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}, {"full_name": "iff_def", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1376, 9], "def_end_pos": [1376, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\n\u22a2 \u2200 (x : \u03b1), x \u2208 Ico a b \u2229 Iio c \u2194 x \u2208 Ico a (min b c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Lemmas.lean", "full_name": "dite_ite_distrib_right", "start": [55, 1], "end": [57, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "full_name": "Matrix.SpecialLinearGroup.coe_transpose", "start": [177, 1], "end": [179, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.revPerm_symm", "start": [377, 1], "end": [378, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image2_congr'", "start": [197, 1], "end": [198, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "OrderIso.tendsto_atBot", "start": [488, 1], "end": [489, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/TensorProduct/Basic.lean", "full_name": "TensorProduct.tmul_ite", "start": [455, 1], "end": [456, 88], "traced_tactics": [{"tactic": "split_ifs <;> simp", "annotated_tactic": ["split_ifs <;> simp", []], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2079 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u2078 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u2077 : Semiring R''\nM : Type u_4\nN : Type u_5\nP\u271d : Type u_6\nQ : Type u_7\nS : Type u_8\nT : Type u_9\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid N\ninst\u271d\u00b9\u2074 : AddCommMonoid P\u271d\ninst\u271d\u00b9\u00b3 : AddCommMonoid Q\ninst\u271d\u00b9\u00b2 : AddCommMonoid S\ninst\u271d\u00b9\u00b9 : AddCommMonoid T\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Module R N\ninst\u271d\u2078 : Module R P\u271d\ninst\u271d\u2077 : Module R Q\ninst\u271d\u2076 : Module R S\ninst\u271d\u2075 : Module R T\ninst\u271d\u2074 : DistribMulAction R' M\ninst\u271d\u00b3 : Module R'' M\ninst\u271d\u00b2 : SMulCommClass R R' M\ninst\u271d\u00b9 : SMulCommClass R R'' M\nx\u2081 : M\nx\u2082 : N\nP : Prop\ninst\u271d : Decidable P\n\u22a2 (x\u2081 \u2297\u209c[R] if P then x\u2082 else 0) = if P then x\u2081 \u2297\u209c[R] x\u2082 else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rat/Defs.lean", "full_name": "Rat.zero_iff_num_zero", "start": [429, 1], "end": [430, 43], "traced_tactics": [{"tactic": "simp [*]", "annotated_tactic": ["simp [*]", []], "state_before": "a b c q : \u211a\nx\u271d : q = 0\n\u22a2 q.num = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bornology/Constructions.lean", "full_name": "Bornology.isBounded_image_fst_and_snd", "start": [58, 1], "end": [60, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/Order.lean", "full_name": "Int.sub_lt_sub_of_le_of_lt", "start": [321, 11], "end": [323, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Determinant.lean", "full_name": "LinearMap.finiteDimensional_of_det_ne_one", "start": [332, 1], "end": [337, 48], "traced_tactics": [{"tactic": "by_cases H : \u2203 s : Finset M, Nonempty (Basis s \ud835\udd5c M)", "annotated_tactic": ["by_cases H : \u2203 s : <a>Finset</a> M, <a>Nonempty</a> (<a>Basis</a> s \ud835\udd5c M)", [{"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}, {"full_name": "Nonempty", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [704, 17], "def_end_pos": [704, 25]}, {"full_name": "Basis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [90, 11], "def_end_pos": [90, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u00b9 : CommRing R\nM : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\nM' : Type u_3\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b2 : Fintype \u03ba\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9 : Field \ud835\udd5c\ninst\u271d : Module \ud835\udd5c M\nf : M \u2192\u2097[\ud835\udd5c] M\nhf : LinearMap.det f \u2260 1\n\u22a2 FiniteDimensional \ud835\udd5c M", "state_after": "case pos\nR : Type u_1\ninst\u271d\u00b9\u00b9 : CommRing R\nM : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\nM' : Type u_3\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b2 : Fintype \u03ba\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9 : Field \ud835\udd5c\ninst\u271d : Module \ud835\udd5c M\nf : M \u2192\u2097[\ud835\udd5c] M\nhf : LinearMap.det f \u2260 1\nH : \u2203 s, Nonempty (Basis { x // x \u2208 s } \ud835\udd5c M)\n\u22a2 FiniteDimensional \ud835\udd5c M\n\ncase neg\nR : Type u_1\ninst\u271d\u00b9\u00b9 : CommRing R\nM : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\nM' : Type u_3\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b2 : Fintype \u03ba\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9 : Field \ud835\udd5c\ninst\u271d : Module \ud835\udd5c M\nf : M \u2192\u2097[\ud835\udd5c] M\nhf : LinearMap.det f \u2260 1\nH : \u00ac\u2203 s, Nonempty (Basis { x // x \u2208 s } \ud835\udd5c M)\n\u22a2 FiniteDimensional \ud835\udd5c M"}, {"tactic": "rcases H with \u27e8s, \u27e8hs\u27e9\u27e9", "annotated_tactic": ["rcases H with \u27e8s, \u27e8hs\u27e9\u27e9", []], "state_before": "case pos\nR : Type u_1\ninst\u271d\u00b9\u00b9 : CommRing R\nM : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\nM' : Type u_3\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b2 : Fintype \u03ba\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9 : Field \ud835\udd5c\ninst\u271d : Module \ud835\udd5c M\nf : M \u2192\u2097[\ud835\udd5c] M\nhf : LinearMap.det f \u2260 1\nH : \u2203 s, Nonempty (Basis { x // x \u2208 s } \ud835\udd5c M)\n\u22a2 FiniteDimensional \ud835\udd5c M", "state_after": "case pos.intro.intro\nR : Type u_1\ninst\u271d\u00b9\u00b9 : CommRing R\nM : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\nM' : Type u_3\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b2 : Fintype \u03ba\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9 : Field \ud835\udd5c\ninst\u271d : Module \ud835\udd5c M\nf : M \u2192\u2097[\ud835\udd5c] M\nhf : LinearMap.det f \u2260 1\ns : Finset M\nhs : Basis { x // x \u2208 s } \ud835\udd5c M\n\u22a2 FiniteDimensional \ud835\udd5c M"}, {"tactic": "exact FiniteDimensional.of_fintype_basis hs", "annotated_tactic": ["exact <a>FiniteDimensional.of_fintype_basis</a> hs", [{"full_name": "FiniteDimensional.of_fintype_basis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FiniteDimensional.lean", "def_pos": [132, 9], "def_end_pos": [132, 25]}]], "state_before": "case pos.intro.intro\nR : Type u_1\ninst\u271d\u00b9\u00b9 : CommRing R\nM : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\nM' : Type u_3\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b2 : Fintype \u03ba\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9 : Field \ud835\udd5c\ninst\u271d : Module \ud835\udd5c M\nf : M \u2192\u2097[\ud835\udd5c] M\nhf : LinearMap.det f \u2260 1\ns : Finset M\nhs : Basis { x // x \u2208 s } \ud835\udd5c M\n\u22a2 FiniteDimensional \ud835\udd5c M", "state_after": "no goals"}, {"tactic": "classical simp [LinearMap.coe_det, H] at hf", "annotated_tactic": ["classical simp [<a>LinearMap.coe_det</a>, H] at hf", [{"full_name": "LinearMap.coe_det", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [178, 9], "def_end_pos": [178, 16]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u00b9\u00b9 : CommRing R\nM : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\nM' : Type u_3\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b2 : Fintype \u03ba\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9 : Field \ud835\udd5c\ninst\u271d : Module \ud835\udd5c M\nf : M \u2192\u2097[\ud835\udd5c] M\nhf : LinearMap.det f \u2260 1\nH : \u00ac\u2203 s, Nonempty (Basis { x // x \u2208 s } \ud835\udd5c M)\n\u22a2 FiniteDimensional \ud835\udd5c M", "state_after": "no goals"}, {"tactic": "simp [LinearMap.coe_det, H] at hf", "annotated_tactic": ["simp [<a>LinearMap.coe_det</a>, H] at hf", [{"full_name": "LinearMap.coe_det", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [178, 9], "def_end_pos": [178, 16]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u00b9\u00b9 : CommRing R\nM : Type u_2\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : Module R M\nM' : Type u_3\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\ne : Basis \u03b9 R M\nA : Type u_5\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : Module A M\n\u03ba : Type u_6\ninst\u271d\u00b2 : Fintype \u03ba\n\ud835\udd5c : Type u_7\ninst\u271d\u00b9 : Field \ud835\udd5c\ninst\u271d : Module \ud835\udd5c M\nf : M \u2192\u2097[\ud835\udd5c] M\nhf : LinearMap.det f \u2260 1\nH : \u00ac\u2203 s, Nonempty (Basis { x // x \u2208 s } \ud835\udd5c M)\n\u22a2 FiniteDimensional \ud835\udd5c M", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Basic.lean", "full_name": "LinearMap.cancel_right", "start": [567, 1], "end": [568, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "orderOf_le_card_univ", "start": [832, 1], "end": [833, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidHom.cancel_left", "start": [1013, 1], "end": [1016, 22], "traced_tactics": [{"tactic": "rw [\u2190 MonoidHom.comp_apply, h, MonoidHom.comp_apply]", "annotated_tactic": ["rw [\u2190 <a>MonoidHom.comp_apply</a>, h, <a>MonoidHom.comp_apply</a>]", [{"full_name": "MonoidHom.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [948, 9], "def_end_pos": [948, 29]}, {"full_name": "MonoidHom.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [948, 9], "def_end_pos": [948, 29]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\nG : Type u_7\nH : Type u_8\nF : Type u_9\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : MulOneClass N\ninst\u271d : MulOneClass P\ng : N \u2192* P\nf\u2081 f\u2082 : M \u2192* N\nhg : Function.Injective \u21d1g\nh : comp g f\u2081 = comp g f\u2082\nx : M\n\u22a2 g (f\u2081 x) = g (f\u2082 x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENat/Lattice.lean", "full_name": "ENat.iSup_coe_eq_top", "start": [30, 1], "end": [30, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Rat/Lemmas.lean", "full_name": "Rat.normalize_num_den'", "start": [88, 1], "end": [92, 47], "traced_tactics": [{"tactic": "refine \u27e8num.natAbs.gcd den, Nat.gcd_ne_zero_right nz, ?_\u27e9", "annotated_tactic": ["refine \u27e8num.natAbs.gcd den, <a>Nat.gcd_ne_zero_right</a> nz, ?_\u27e9", [{"full_name": "Nat.gcd_ne_zero_right", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [80, 9], "def_end_pos": [80, 26]}]], "state_before": "num : Int\nden : Nat\nnz : den \u2260 0\n\u22a2 \u2203 d, d \u2260 0 \u2227 num = (normalize num den nz).num * \u2191d \u2227 den = (normalize num den nz).den * d", "state_after": "num : Int\nden : Nat\nnz : den \u2260 0\n\u22a2 num = (normalize num den nz).num * \u2191(Nat.gcd (Int.natAbs num) den) \u2227\n    den = (normalize num den nz).den * Nat.gcd (Int.natAbs num) den"}, {"tactic": "simp [normalize_eq, Int.ediv_mul_cancel (Int.ofNat_dvd_left.2 <| Nat.gcd_dvd_left ..),\n  Nat.div_mul_cancel (Nat.gcd_dvd_right ..)]", "annotated_tactic": ["simp [<a>normalize_eq</a>, <a>Int.ediv_mul_cancel</a> (<a>Int.ofNat_dvd_left</a>.2 <| <a>Nat.gcd_dvd_left</a> ..),\n    <a>Nat.div_mul_cancel</a> (<a>Nat.gcd_dvd_right</a> ..)]", [{"full_name": "Rat.normalize_eq", "def_path": ".lake/packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [36, 9], "def_end_pos": [36, 21]}, {"full_name": "Int.ediv_mul_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean", "def_pos": [304, 19], "def_end_pos": [304, 34]}, {"full_name": "Int.ofNat_dvd_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean", "def_pos": [280, 9], "def_end_pos": [280, 23]}, {"full_name": "Nat.gcd_dvd_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [59, 9], "def_end_pos": [59, 21]}, {"full_name": "Nat.div_mul_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean", "def_pos": [97, 19], "def_end_pos": [97, 33]}, {"full_name": "Nat.gcd_dvd_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [61, 9], "def_end_pos": [61, 22]}]], "state_before": "num : Int\nden : Nat\nnz : den \u2260 0\n\u22a2 num = (normalize num den nz).num * \u2191(Nat.gcd (Int.natAbs num) den) \u2227\n    den = (normalize num den nz).den * Nat.gcd (Int.natAbs num) den", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Irrational.lean", "full_name": "Irrational.of_nat_mul", "start": [371, 1], "end": [372, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Operations.lean", "full_name": "ENNReal.toNNReal_add", "start": [193, 1], "end": [197, 6], "traced_tactics": [{"tactic": "lift r\u2081 to \u211d\u22650 using h\u2081", "annotated_tactic": ["lift r\u2081 to \u211d\u22650 using h\u2081", []], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u03b1 : Type u_1\nr\u2081 r\u2082 : \u211d\u22650\u221e\nh\u2081 : r\u2081 \u2260 \u22a4\nh\u2082 : r\u2082 \u2260 \u22a4\n\u22a2 (r\u2081 + r\u2082).toNNReal = r\u2081.toNNReal + r\u2082.toNNReal", "state_after": "case intro\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u03b1 : Type u_1\nr\u2082 : \u211d\u22650\u221e\nh\u2082 : r\u2082 \u2260 \u22a4\nr\u2081 : \u211d\u22650\n\u22a2 (\u2191r\u2081 + r\u2082).toNNReal = (\u2191r\u2081).toNNReal + r\u2082.toNNReal"}, {"tactic": "lift r\u2082 to \u211d\u22650 using h\u2082", "annotated_tactic": ["lift r\u2082 to \u211d\u22650 using h\u2082", []], "state_before": "case intro\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u03b1 : Type u_1\nr\u2082 : \u211d\u22650\u221e\nh\u2082 : r\u2082 \u2260 \u22a4\nr\u2081 : \u211d\u22650\n\u22a2 (\u2191r\u2081 + r\u2082).toNNReal = (\u2191r\u2081).toNNReal + r\u2082.toNNReal", "state_after": "case intro.intro\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u03b1 : Type u_1\nr\u2081 r\u2082 : \u211d\u22650\n\u22a2 (\u2191r\u2081 + \u2191r\u2082).toNNReal = (\u2191r\u2081).toNNReal + (\u2191r\u2082).toNNReal"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case intro.intro\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u03b1 : Type u_1\nr\u2081 r\u2082 : \u211d\u22650\n\u22a2 (\u2191r\u2081 + \u2191r\u2082).toNNReal = (\u2191r\u2081).toNNReal + (\u2191r\u2082).toNNReal", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Extr.lean", "full_name": "IsExtrFilter.neg", "start": [486, 1], "end": [487, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.coe_eq_zero_iff", "start": [415, 1], "end": [416, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/T5.lean", "full_name": "Set.ordConnectedComponent_mem_nhds", "start": [27, 1], "end": [30, 65], "traced_tactics": [{"tactic": "refine' \u27e8fun h => mem_of_superset h ordConnectedComponent_subset, fun h => _\u27e9", "annotated_tactic": ["refine' \u27e8fun h => <a>mem_of_superset</a> h <a>ordConnectedComponent_subset</a>, fun h => _\u27e9", [{"full_name": "Filter.mem_of_superset", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [152, 9], "def_end_pos": [152, 24]}, {"full_name": "Set.ordConnectedComponent_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/OrdConnectedComponent.lean", "def_pos": [44, 9], "def_end_pos": [44, 37]}]], "state_before": "X : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na b c : X\ns t : Set X\n\u22a2 ordConnectedComponent s a \u2208 \ud835\udcdd a \u2194 s \u2208 \ud835\udcdd a", "state_after": "X : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na b c : X\ns t : Set X\nh : s \u2208 \ud835\udcdd a\n\u22a2 ordConnectedComponent s a \u2208 \ud835\udcdd a"}, {"tactic": "rcases exists_Icc_mem_subset_of_mem_nhds h with \u27e8b, c, ha, ha', hs\u27e9", "annotated_tactic": ["rcases <a>exists_Icc_mem_subset_of_mem_nhds</a> h with \u27e8b, c, ha, ha', hs\u27e9", [{"full_name": "exists_Icc_mem_subset_of_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [443, 9], "def_end_pos": [443, 42]}]], "state_before": "X : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na b c : X\ns t : Set X\nh : s \u2208 \ud835\udcdd a\n\u22a2 ordConnectedComponent s a \u2208 \ud835\udcdd a", "state_after": "case intro.intro.intro.intro\nX : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na b\u271d c\u271d : X\ns t : Set X\nh : s \u2208 \ud835\udcdd a\nb c : X\nha : a \u2208 Icc b c\nha' : Icc b c \u2208 \ud835\udcdd a\nhs : Icc b c \u2286 s\n\u22a2 ordConnectedComponent s a \u2208 \ud835\udcdd a"}, {"tactic": "exact mem_of_superset ha' (subset_ordConnectedComponent ha hs)", "annotated_tactic": ["exact <a>mem_of_superset</a> ha' (<a>subset_ordConnectedComponent</a> ha hs)", [{"full_name": "Filter.mem_of_superset", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [152, 9], "def_end_pos": [152, 24]}, {"full_name": "Set.subset_ordConnectedComponent", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/OrdConnectedComponent.lean", "def_pos": [48, 9], "def_end_pos": [48, 37]}]], "state_before": "case intro.intro.intro.intro\nX : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na b\u271d c\u271d : X\ns t : Set X\nh : s \u2208 \ud835\udcdd a\nb c : X\nha : a \u2208 Icc b c\nha' : Icc b c \u2208 \ud835\udcdd a\nhs : Icc b c \u2286 s\n\u22a2 ordConnectedComponent s a \u2208 \ud835\udcdd a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/IntegrallyClosed.lean", "full_name": "integralClosure.isIntegrallyClosedOfFiniteExtension", "start": [144, 1], "end": [147, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsCoprime.mul_add_left_right", "start": [353, 1], "end": [355, 31], "traced_tactics": [{"tactic": "rw [add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime x (x * z + y)", "state_after": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime x (y + x * z)"}, {"tactic": "exact h.add_mul_left_right z", "annotated_tactic": ["exact h.add_mul_left_right z", []], "state_before": "R : Type u\ninst\u271d : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n\u22a2 IsCoprime x (y + x * z)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finsupp.lean", "full_name": "Finsupp.single_sum", "start": [305, 1], "end": [307, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.algebraMap_eq_diagonalRingHom", "start": [1341, 1], "end": [1342, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "WithTop.succ_coe_of_ne_top", "start": [1067, 1], "end": [1068, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean", "full_name": "HahnSeries.mul_single_coeff_add", "start": [254, 1], "end": [278, 9], "traced_tactics": [{"tactic": "by_cases hr : r = 0", "annotated_tactic": ["by_cases hr : r = 0", []], "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\n\u22a2 (x * (single b) r).coeff (a + b) = x.coeff a * r", "state_after": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : r = 0\n\u22a2 (x * (single b) r).coeff (a + b) = x.coeff a * r\n\ncase neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\n\u22a2 (x * (single b) r).coeff (a + b) = x.coeff a * r"}, {"tactic": "simp only [hr, smul_coeff, mul_coeff, support_single_of_ne, Ne.def, not_false_iff, smul_eq_mul]", "annotated_tactic": ["simp only [hr, <a>smul_coeff</a>, <a>mul_coeff</a>, <a>support_single_of_ne</a>, <a>Ne.def</a>, <a>not_false_iff</a>, <a>smul_eq_mul</a>]", [{"full_name": "HahnSeries.smul_coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Addition.lean", "def_pos": [199, 9], "def_end_pos": [199, 19]}, {"full_name": "HahnSeries.mul_coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "def_pos": [179, 9], "def_end_pos": [179, 18]}, {"full_name": "HahnSeries.support_single_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Basic.lean", "def_pos": [185, 9], "def_end_pos": [185, 29]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "not_false_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1359, 9], "def_end_pos": [1359, 22]}, {"full_name": "smul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}]], "state_before": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\n\u22a2 (x * (single b) r).coeff (a + b) = x.coeff a * r", "state_after": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 = x.coeff a * r"}, {"tactic": "by_cases hx : x.coeff a = 0", "annotated_tactic": ["by_cases hx : x.coeff a = 0", []], "state_before": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 = x.coeff a * r", "state_after": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 = x.coeff a * r\n\ncase neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 = x.coeff a * r"}, {"tactic": "trans \u2211 ij : \u0393 \u00d7 \u0393 in {(a, b)}, x.coeff ij.fst * (single b r).coeff ij.snd", "annotated_tactic": ["trans \u2211 ij : \u0393 \u00d7 \u0393 in {(a, b)}, x.coeff ij.fst * (<a>single</a> b r).<a>coeff</a> ij.snd", [{"full_name": "HahnSeries.single", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Basic.lean", "def_pos": [161, 5], "def_end_pos": [161, 11]}, {"full_name": "HahnSeries.coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Basic.lean", "def_pos": [43, 3], "def_end_pos": [43, 8]}]], "state_before": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 = x.coeff a * r", "state_after": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 =\n    \u2211 ij in {(a, b)}, x.coeff ij.1 * ((single b) r).coeff ij.2\n\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\n\u22a2 \u2211 ij in {(a, b)}, x.coeff ij.1 * ((single b) r).coeff ij.2 = x.coeff a * r"}, {"tactic": "simp [hr, mul_coeff]", "annotated_tactic": ["simp [hr, <a>mul_coeff</a>]", [{"full_name": "HahnSeries.mul_coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Multiplication.lean", "def_pos": [179, 9], "def_end_pos": [179, 18]}]], "state_before": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : r = 0\n\u22a2 (x * (single b) r).coeff (a + b) = x.coeff a * r", "state_after": "no goals"}, {"tactic": "simp only [hx, zero_mul]", "annotated_tactic": ["simp only [hx, <a>zero_mul</a>]", [{"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}]], "state_before": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 = x.coeff a * r", "state_after": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 = 0"}, {"tactic": "rw [sum_congr _ fun _ _ => rfl, sum_empty]", "annotated_tactic": ["rw [<a>sum_congr</a> _ fun _ _ => <a>rfl</a>, <a>sum_empty</a>]", [{"full_name": "Finset.sum_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [381, 3], "def_end_pos": [381, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Finset.sum_empty", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [293, 3], "def_end_pos": [293, 14]}]], "state_before": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 = 0", "state_after": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\n\u22a2 addAntidiagonal \u22ef \u22ef (a + b) = \u2205"}, {"tactic": "ext \u27e8a1, a2\u27e9", "annotated_tactic": ["ext \u27e8a1, a2\u27e9", []], "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\n\u22a2 addAntidiagonal \u22ef \u22ef (a + b) = \u2205", "state_after": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\na1 a2 : \u0393\n\u22a2 (a1, a2) \u2208 addAntidiagonal \u22ef \u22ef (a + b) \u2194 (a1, a2) \u2208 \u2205"}, {"tactic": "simp only [not_mem_empty, not_and, Set.mem_singleton_iff, Classical.not_not,\n  mem_addAntidiagonal, Set.mem_setOf_eq, iff_false_iff]", "annotated_tactic": ["simp only [<a>not_mem_empty</a>, <a>not_and</a>, <a>Set.mem_singleton_iff</a>, <a>Classical.not_not</a>,\n      <a>mem_addAntidiagonal</a>, <a>Set.mem_setOf_eq</a>, <a>iff_false_iff</a>]", [{"full_name": "Finset.not_mem_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [554, 9], "def_end_pos": [554, 22]}, {"full_name": "not_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [109, 17], "def_end_pos": [109, 24]}, {"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}, {"full_name": "Classical.not_not", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [128, 24], "def_end_pos": [128, 31]}, {"full_name": "Finset.mem_addAntidiagonal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/MulAntidiagonal.lean", "def_pos": [71, 3], "def_end_pos": [71, 14]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}, {"full_name": "iff_false_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [192, 9], "def_end_pos": [192, 22]}]], "state_before": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\na1 a2 : \u0393\n\u22a2 (a1, a2) \u2208 addAntidiagonal \u22ef \u22ef (a + b) \u2194 (a1, a2) \u2208 \u2205", "state_after": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\na1 a2 : \u0393\n\u22a2 a1 \u2208 support x \u2192 a2 = b \u2192 \u00aca1 + a2 = a + b"}, {"tactic": "rintro h2 rfl h1", "annotated_tactic": ["rintro h2 rfl h1", []], "state_before": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\na1 a2 : \u0393\n\u22a2 a1 \u2208 support x \u2192 a2 = b \u2192 \u00aca1 + a2 = a + b", "state_after": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\na1 a2 : \u0393\nh2 : a1 \u2208 support x\nh1 : a1 + a2 = a + a2\n\u22a2 False"}, {"tactic": "rw [\u2190 add_right_cancel h1] at hx", "annotated_tactic": ["rw [\u2190 <a>add_right_cancel</a> h1] at hx", [{"full_name": "add_right_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [245, 3], "def_end_pos": [245, 14]}]], "state_before": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na : \u0393\nhr : \u00acr = 0\nhx : x.coeff a = 0\na1 a2 : \u0393\nh2 : a1 \u2208 support x\nh1 : a1 + a2 = a + a2\n\u22a2 False", "state_after": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na : \u0393\nhr : \u00acr = 0\na1 : \u0393\nhx : x.coeff a1 = 0\na2 : \u0393\nh2 : a1 \u2208 support x\nh1 : a1 + a2 = a + a2\n\u22a2 False"}, {"tactic": "exact h2 hx", "annotated_tactic": ["exact h2 hx", []], "state_before": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na : \u0393\nhr : \u00acr = 0\na1 : \u0393\nhx : x.coeff a1 = 0\na2 : \u0393\nh2 : a1 \u2208 support x\nh1 : a1 + a2 = a + a2\n\u22a2 False", "state_after": "no goals"}, {"tactic": "apply sum_congr _ fun _ _ => rfl", "annotated_tactic": ["apply <a>sum_congr</a> _ fun _ _ => <a>rfl</a>", [{"full_name": "Finset.sum_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [381, 3], "def_end_pos": [381, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\n\u22a2 \u2211 x_1 in addAntidiagonal \u22ef \u22ef (a + b), x.coeff x_1.1 * ((single b) r).coeff x_1.2 =\n    \u2211 ij in {(a, b)}, x.coeff ij.1 * ((single b) r).coeff ij.2", "state_after": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\n\u22a2 addAntidiagonal \u22ef \u22ef (a + b) = {(a, b)}"}, {"tactic": "ext \u27e8a1, a2\u27e9", "annotated_tactic": ["ext \u27e8a1, a2\u27e9", []], "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\n\u22a2 addAntidiagonal \u22ef \u22ef (a + b) = {(a, b)}", "state_after": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\n\u22a2 (a1, a2) \u2208 addAntidiagonal \u22ef \u22ef (a + b) \u2194 (a1, a2) \u2208 {(a, b)}"}, {"tactic": "simp only [Set.mem_singleton_iff, Prod.mk.inj_iff, mem_addAntidiagonal, mem_singleton,\n  Set.mem_setOf_eq]", "annotated_tactic": ["simp only [<a>Set.mem_singleton_iff</a>, <a>Prod.mk.inj_iff</a>, <a>mem_addAntidiagonal</a>, <a>mem_singleton</a>,\n      <a>Set.mem_setOf_eq</a>]", [{"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}, {"full_name": "Prod.mk.inj_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [102, 9], "def_end_pos": [102, 19]}, {"full_name": "Finset.mem_addAntidiagonal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/MulAntidiagonal.lean", "def_pos": [71, 3], "def_end_pos": [71, 14]}, {"full_name": "Finset.mem_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [684, 9], "def_end_pos": [684, 22]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}]], "state_before": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\n\u22a2 (a1, a2) \u2208 addAntidiagonal \u22ef \u22ef (a + b) \u2194 (a1, a2) \u2208 {(a, b)}", "state_after": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\n\u22a2 a1 \u2208 support x \u2227 a2 = b \u2227 a1 + a2 = a + b \u2194 a1 = a \u2227 a2 = b"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case a.mk\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\n\u22a2 a1 \u2208 support x \u2227 a2 = b \u2227 a1 + a2 = a + b \u2194 a1 = a \u2227 a2 = b", "state_after": "case a.mk.mp\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\n\u22a2 a1 \u2208 support x \u2227 a2 = b \u2227 a1 + a2 = a + b \u2192 a1 = a \u2227 a2 = b\n\ncase a.mk.mpr\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\n\u22a2 a1 = a \u2227 a2 = b \u2192 a1 \u2208 support x \u2227 a2 = b \u2227 a1 + a2 = a + b"}, {"tactic": "rintro \u27e8_, rfl, h1\u27e9", "annotated_tactic": ["rintro \u27e8_, rfl, h1\u27e9", []], "state_before": "case a.mk.mp\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\n\u22a2 a1 \u2208 support x \u2227 a2 = b \u2227 a1 + a2 = a + b \u2192 a1 = a \u2227 a2 = b", "state_after": "case a.mk.mp.intro.intro\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\nleft\u271d : a1 \u2208 support x\nh1 : a1 + a2 = a + a2\n\u22a2 a1 = a \u2227 a2 = a2"}, {"tactic": "exact \u27e8add_right_cancel h1, rfl\u27e9", "annotated_tactic": ["exact \u27e8<a>add_right_cancel</a> h1, <a>rfl</a>\u27e9", [{"full_name": "add_right_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [245, 3], "def_end_pos": [245, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case a.mk.mp.intro.intro\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\nleft\u271d : a1 \u2208 support x\nh1 : a1 + a2 = a + a2\n\u22a2 a1 = a \u2227 a2 = a2", "state_after": "no goals"}, {"tactic": "rintro \u27e8rfl, rfl\u27e9", "annotated_tactic": ["rintro \u27e8rfl, rfl\u27e9", []], "state_before": "case a.mk.mpr\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\na1 a2 : \u0393\n\u22a2 a1 = a \u2227 a2 = b \u2192 a1 \u2208 support x \u2227 a2 = b \u2227 a1 + a2 = a + b", "state_after": "case a.mk.mpr.intro\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\nhr : \u00acr = 0\na1 a2 : \u0393\nhx : \u00acx.coeff a1 = 0\n\u22a2 a1 \u2208 support x \u2227 a2 = a2 \u2227 a1 + a2 = a1 + a2"}, {"tactic": "simp [hx]", "annotated_tactic": ["simp [hx]", []], "state_before": "case a.mk.mpr.intro\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\nhr : \u00acr = 0\na1 a2 : \u0393\nhx : \u00acx.coeff a1 = 0\n\u22a2 a1 \u2208 support x \u2227 a2 = a2 \u2227 a1 + a2 = a1 + a2", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : OrderedCancelAddCommMonoid \u0393\ninst\u271d : NonUnitalNonAssocSemiring R\nr : R\nx : HahnSeries \u0393 R\na b : \u0393\nhr : \u00acr = 0\nhx : \u00acx.coeff a = 0\n\u22a2 \u2211 ij in {(a, b)}, x.coeff ij.1 * ((single b) r).coeff ij.2 = x.coeff a * r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/EraseLead.lean", "full_name": "Polynomial.card_support_eq'", "start": [364, 1], "end": [376, 59], "traced_tactics": [{"tactic": "suffices (\u2211 i, C (x i) * X ^ k i).support = image k univ by\n  rw [this, univ.card_image_of_injective hk, card_fin]", "annotated_tactic": ["suffices (\u2211 i, <a>C</a> (x i) * <a>X</a> ^ k i).<a>support</a> = <a>image</a> k <a>univ</a> by\n    rw [this, univ.card_image_of_injective hk, <a>card_fin</a>]", [{"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.support", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [405, 5], "def_end_pos": [405, 12]}, {"full_name": "Finset.image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [344, 5], "def_end_pos": [344, 10]}, {"full_name": "Finset.univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [68, 5], "def_end_pos": [68, 9]}, {"full_name": "Finset.card_fin", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [322, 9], "def_end_pos": [322, 24]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\n\u22a2 (support (\u2211 i : Fin n, C (x i) * X ^ k i)).card = n", "state_after": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\n\u22a2 support (\u2211 i : Fin n, C (x i) * X ^ k i) = image k univ"}, {"tactic": "simp_rw [Finset.ext_iff, mem_support_iff, finset_sum_coeff, coeff_C_mul_X_pow, mem_image,\n  mem_univ, true_and]", "annotated_tactic": ["simp_rw [<a>Finset.ext_iff</a>, <a>mem_support_iff</a>, <a>finset_sum_coeff</a>, <a>coeff_C_mul_X_pow</a>, <a>mem_image</a>,\n    <a>mem_univ</a>, <a>true_and</a>]", [{"full_name": "Finset.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 16]}, {"full_name": "Polynomial.mem_support_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [733, 9], "def_end_pos": [733, 24]}, {"full_name": "Polynomial.finset_sum_coeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [108, 9], "def_end_pos": [108, 25]}, {"full_name": "Polynomial.coeff_C_mul_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [156, 9], "def_end_pos": [156, 26]}, {"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}, {"full_name": "Finset.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [73, 9], "def_end_pos": [73, 17]}, {"full_name": "true_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [102, 17], "def_end_pos": [102, 25]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\n\u22a2 support (\u2211 i : Fin n, C (x i) * X ^ k i) = image k univ", "state_after": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\n\u22a2 \u2200 (a : \u2115), (\u2211 x_1 : Fin n, if a = k x_1 then x x_1 else 0) \u2260 0 \u2194 \u2203 a_1, k a_1 = a"}, {"tactic": "refine' fun i => \u27e8fun h => _, _\u27e9", "annotated_tactic": ["refine' fun i => \u27e8fun h => _, _\u27e9", []], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\n\u22a2 \u2200 (a : \u2115), (\u2211 x_1 : Fin n, if a = k x_1 then x x_1 else 0) \u2260 0 \u2194 \u2203 a_1, k a_1 = a", "state_after": "case refine'_1\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\ni : \u2115\nh : (\u2211 x_1 : Fin n, if i = k x_1 then x x_1 else 0) \u2260 0\n\u22a2 \u2203 a, k a = i\n\ncase refine'_2\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\ni : \u2115\n\u22a2 (\u2203 a, k a = i) \u2192 (\u2211 x_1 : Fin n, if i = k x_1 then x x_1 else 0) \u2260 0"}, {"tactic": "rw [this, univ.card_image_of_injective hk, card_fin]", "annotated_tactic": ["rw [this, univ.card_image_of_injective hk, <a>card_fin</a>]", [{"full_name": "Finset.card_fin", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [322, 9], "def_end_pos": [322, 24]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\nthis : support (\u2211 i : Fin n, C (x i) * X ^ k i) = image k univ\n\u22a2 (support (\u2211 i : Fin n, C (x i) * X ^ k i)).card = n", "state_after": "no goals"}, {"tactic": "obtain \u27e8j, _, h\u27e9 := exists_ne_zero_of_sum_ne_zero h", "annotated_tactic": ["obtain \u27e8j, _, h\u27e9 := <a>exists_ne_zero_of_sum_ne_zero</a> h", [{"full_name": "Finset.exists_ne_zero_of_sum_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1430, 3], "def_end_pos": [1430, 14]}]], "state_before": "case refine'_1\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\ni : \u2115\nh : (\u2211 x_1 : Fin n, if i = k x_1 then x x_1 else 0) \u2260 0\n\u22a2 \u2203 a, k a = i", "state_after": "case refine'_1.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\ni : \u2115\nh\u271d : (\u2211 x_1 : Fin n, if i = k x_1 then x x_1 else 0) \u2260 0\nj : Fin n\nleft\u271d : j \u2208 univ\nh : (if i = k j then x j else 0) \u2260 0\n\u22a2 \u2203 a, k a = i"}, {"tactic": "exact \u27e8j, (ite_ne_right_iff.mp h).1.symm\u27e9", "annotated_tactic": ["exact \u27e8j, (ite_ne_right_iff.mp h).1.<a>symm</a>\u27e9", [{"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case refine'_1.intro.intro\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\ni : \u2115\nh\u271d : (\u2211 x_1 : Fin n, if i = k x_1 then x x_1 else 0) \u2260 0\nj : Fin n\nleft\u271d : j \u2208 univ\nh : (if i = k j then x j else 0) \u2260 0\n\u22a2 \u2203 a, k a = i", "state_after": "no goals"}, {"tactic": "rintro \u27e8j, _, rfl\u27e9", "annotated_tactic": ["rintro \u27e8j, _, rfl\u27e9", []], "state_before": "case refine'_2\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\ni : \u2115\n\u22a2 (\u2203 a, k a = i) \u2192 (\u2211 x_1 : Fin n, if i = k x_1 then x x_1 else 0) \u2260 0", "state_after": "case refine'_2.intro.refl\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\nj : Fin n\n\u22a2 (\u2211 x_1 : Fin n, if k j = k x_1 then x x_1 else 0) \u2260 0"}, {"tactic": "rw [sum_eq_single_of_mem j (mem_univ j), if_pos rfl]", "annotated_tactic": ["rw [<a>sum_eq_single_of_mem</a> j (<a>mem_univ</a> j), <a>if_pos</a> <a>rfl</a>]", [{"full_name": "Finset.sum_eq_single_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [932, 3], "def_end_pos": [932, 14]}, {"full_name": "Finset.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [73, 9], "def_end_pos": [73, 17]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case refine'_2.intro.refl\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\nj : Fin n\n\u22a2 (\u2211 x_1 : Fin n, if k j = k x_1 then x x_1 else 0) \u2260 0", "state_after": "case refine'_2.intro.refl\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\nj : Fin n\n\u22a2 x j \u2260 0\n\ncase refine'_2.intro.refl\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\nj : Fin n\n\u22a2 \u2200 b \u2208 univ, b \u2260 j \u2192 (if k j = k b then x b else 0) = 0"}, {"tactic": "exact hx j", "annotated_tactic": ["exact hx j", []], "state_before": "case refine'_2.intro.refl\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\nj : Fin n\n\u22a2 x j \u2260 0", "state_after": "no goals"}, {"tactic": "exact fun m _ hmj => if_neg fun h => hmj.symm (hk h)", "annotated_tactic": ["exact fun m _ hmj => <a>if_neg</a> fun h => hmj.symm (hk h)", [{"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}]], "state_before": "case refine'_2.intro.refl\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nn : \u2115\nk : Fin n \u2192 \u2115\nx : Fin n \u2192 R\nhk : Function.Injective k\nhx : \u2200 (i : Fin n), x i \u2260 0\nj : Fin n\n\u22a2 \u2200 b \u2208 univ, b \u2260 j \u2192 (if k j = k b then x b else 0) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean", "full_name": "Equicontinuous.equicontinuousOn", "start": [179, 1], "end": [181, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "NNReal.summable_sigma", "start": [1192, 1], "end": [1199, 40], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\nf : (x : \u03b1) \u00d7 \u03b2 x \u2192 \u211d\u22650\n\u22a2 Summable f \u2194\n    (\u2200 (x : \u03b1), Summable fun y => f { fst := x, snd := y }) \u2227 Summable fun x => \u2211' (y : \u03b2 x), f { fst := x, snd := y }", "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\nf : (x : \u03b1) \u00d7 \u03b2 x \u2192 \u211d\u22650\n\u22a2 Summable f \u2192\n    (\u2200 (x : \u03b1), Summable fun y => f { fst := x, snd := y }) \u2227 Summable fun x => \u2211' (y : \u03b2 x), f { fst := x, snd := y }\n\ncase mpr\n\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\nf : (x : \u03b1) \u00d7 \u03b2 x \u2192 \u211d\u22650\n\u22a2 ((\u2200 (x : \u03b1), Summable fun y => f { fst := x, snd := y }) \u2227 Summable fun x => \u2211' (y : \u03b2 x), f { fst := x, snd := y }) \u2192\n    Summable f"}, {"tactic": "simp only [\u2190 NNReal.summable_coe, NNReal.coe_tsum]", "annotated_tactic": ["simp only [\u2190 <a>NNReal.summable_coe</a>, <a>NNReal.coe_tsum</a>]", [{"full_name": "NNReal.summable_coe", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/NNReal.lean", "def_pos": [177, 9], "def_end_pos": [177, 21]}, {"full_name": "NNReal.coe_tsum", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/NNReal.lean", "def_pos": [191, 9], "def_end_pos": [191, 17]}]], "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\nf : (x : \u03b1) \u00d7 \u03b2 x \u2192 \u211d\u22650\n\u22a2 Summable f \u2192\n    (\u2200 (x : \u03b1), Summable fun y => f { fst := x, snd := y }) \u2227 Summable fun x => \u2211' (y : \u03b2 x), f { fst := x, snd := y }", "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\nf : (x : \u03b1) \u00d7 \u03b2 x \u2192 \u211d\u22650\n\u22a2 (Summable fun a => \u2191(f a)) \u2192\n    (\u2200 (x : \u03b1), Summable fun a => \u2191(f { fst := x, snd := a })) \u2227\n      Summable fun a => \u2211' (a_1 : \u03b2 a), \u2191(f { fst := a, snd := a_1 })"}, {"tactic": "exact fun h => \u27e8h.sigma_factor, h.sigma\u27e9", "annotated_tactic": ["exact fun h => \u27e8h.sigma_factor, h.sigma\u27e9", []], "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\nf : (x : \u03b1) \u00d7 \u03b2 x \u2192 \u211d\u22650\n\u22a2 (Summable fun a => \u2191(f a)) \u2192\n    (\u2200 (x : \u03b1), Summable fun a => \u2191(f { fst := x, snd := a })) \u2227\n      Summable fun a => \u2211' (a_1 : \u03b2 a), \u2191(f { fst := a, snd := a_1 })", "state_after": "no goals"}, {"tactic": "rintro \u27e8h\u2081, h\u2082\u27e9", "annotated_tactic": ["rintro \u27e8h\u2081, h\u2082\u27e9", []], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\nf : (x : \u03b1) \u00d7 \u03b2 x \u2192 \u211d\u22650\n\u22a2 ((\u2200 (x : \u03b1), Summable fun y => f { fst := x, snd := y }) \u2227 Summable fun x => \u2211' (y : \u03b2 x), f { fst := x, snd := y }) \u2192\n    Summable f", "state_after": "case mpr.intro\n\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\nf : (x : \u03b1) \u00d7 \u03b2 x \u2192 \u211d\u22650\nh\u2081 : \u2200 (x : \u03b1), Summable fun y => f { fst := x, snd := y }\nh\u2082 : Summable fun x => \u2211' (y : \u03b2 x), f { fst := x, snd := y }\n\u22a2 Summable f"}, {"tactic": "simpa only [\u2190 ENNReal.tsum_coe_ne_top_iff_summable, ENNReal.tsum_sigma',\n  ENNReal.coe_tsum (h\u2081 _)] using h\u2082", "annotated_tactic": ["simpa only [\u2190 <a>ENNReal.tsum_coe_ne_top_iff_summable</a>, <a>ENNReal.tsum_sigma'</a>,\n      <a>ENNReal.coe_tsum</a> (h\u2081 _)] using h\u2082", [{"full_name": "ENNReal.tsum_coe_ne_top_iff_summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [805, 9], "def_end_pos": [805, 37]}, {"full_name": "ENNReal.tsum_sigma'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [830, 19], "def_end_pos": [830, 30]}, {"full_name": "ENNReal.coe_tsum", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [792, 19], "def_end_pos": [792, 27]}]], "state_before": "case mpr.intro\n\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b2 : \u03b1 \u2192 Type u_4\nf : (x : \u03b1) \u00d7 \u03b2 x \u2192 \u211d\u22650\nh\u2081 : \u2200 (x : \u03b1), Summable fun y => f { fst := x, snd := y }\nh\u2082 : Summable fun x => \u2211' (y : \u03b2 x), f { fst := x, snd := y }\n\u22a2 Summable f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "full_name": "Submodule.mem_sInf", "start": [256, 1], "end": [257, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeGroup/Basic.lean", "full_name": "FreeGroup.prod.of", "start": [911, 1], "end": [912, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.coe_inv", "start": [322, 1], "end": [322, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Arg.lean", "full_name": "Complex.sameRay_iff_arg_div_eq_zero", "start": [41, 1], "end": [45, 48], "traced_tactics": [{"tactic": "rw [\u2190 Real.Angle.toReal_zero, \u2190 arg_coe_angle_eq_iff_eq_toReal, sameRay_iff]", "annotated_tactic": ["rw [\u2190 <a>Real.Angle.toReal_zero</a>, \u2190 <a>arg_coe_angle_eq_iff_eq_toReal</a>, <a>sameRay_iff</a>]", [{"full_name": "Real.Angle.toReal_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "def_pos": [583, 9], "def_end_pos": [583, 20]}, {"full_name": "Complex.arg_coe_angle_eq_iff_eq_toReal", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "def_pos": [562, 9], "def_end_pos": [562, 39]}, {"full_name": "Complex.sameRay_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Arg.lean", "def_pos": [31, 9], "def_end_pos": [31, 20]}]], "state_before": "x y : \u2102\n\u22a2 SameRay \u211d x y \u2194 arg (x / y) = 0", "state_after": "x y : \u2102\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0"}, {"tactic": "by_cases hx : x = 0", "annotated_tactic": ["by_cases hx : x = 0", []], "state_before": "x y : \u2102\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0", "state_after": "case pos\nx y : \u2102\nhx : x = 0\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0\n\ncase neg\nx y : \u2102\nhx : \u00acx = 0\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0"}, {"tactic": "by_cases hy : y = 0", "annotated_tactic": ["by_cases hy : y = 0", []], "state_before": "case neg\nx y : \u2102\nhx : \u00acx = 0\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0", "state_after": "case pos\nx y : \u2102\nhx : \u00acx = 0\nhy : y = 0\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0\n\ncase neg\nx y : \u2102\nhx : \u00acx = 0\nhy : \u00acy = 0\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0"}, {"tactic": "simp [hx, hy, arg_div_coe_angle, sub_eq_zero]", "annotated_tactic": ["simp [hx, hy, <a>arg_div_coe_angle</a>, <a>sub_eq_zero</a>]", [{"full_name": "Complex.arg_div_coe_angle", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "def_pos": [551, 9], "def_end_pos": [551, 26]}, {"full_name": "sub_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [880, 3], "def_end_pos": [880, 14]}]], "state_before": "case neg\nx y : \u2102\nhx : \u00acx = 0\nhy : \u00acy = 0\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0", "state_after": "no goals"}, {"tactic": "simp [hx]", "annotated_tactic": ["simp [hx]", []], "state_before": "case pos\nx y : \u2102\nhx : x = 0\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0", "state_after": "no goals"}, {"tactic": "simp [hy]", "annotated_tactic": ["simp [hy]", []], "state_before": "case pos\nx y : \u2102\nhx : \u00acx = 0\nhy : y = 0\n\u22a2 x = 0 \u2228 y = 0 \u2228 arg x = arg y \u2194 \u2191(arg (x / y)) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Set.lean", "full_name": "Equiv.preimage_subset", "start": [121, 1], "end": [122, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.erase_inter_comm", "start": [2366, 1], "end": [2367, 32], "traced_tactics": [{"tactic": "rw [erase_inter, inter_erase]", "annotated_tactic": ["rw [<a>erase_inter</a>, <a>inter_erase</a>]", [{"full_name": "Finset.erase_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2354, 9], "def_end_pos": [2354, 20]}, {"full_name": "Finset.inter_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2349, 9], "def_end_pos": [2349, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t\u271d u v : Finset \u03b1\na\u271d b : \u03b1\ns t : Finset \u03b1\na : \u03b1\n\u22a2 erase s a \u2229 t = s \u2229 erase t a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/UInt.lean", "full_name": "UInt32.toUSize_toNat", "start": [100, 9], "end": [101, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image2_assoc", "start": [238, 1], "end": [241, 95], "traced_tactics": [{"tactic": "simp only [image2_subset_iff, forall_image2_iff, h_assoc]", "annotated_tactic": ["simp only [<a>image2_subset_iff</a>, <a>forall_image2_iff</a>, h_assoc]", [{"full_name": "Set.image2_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [64, 9], "def_end_pos": [64, 26]}, {"full_name": "Set.forall_image2_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [58, 9], "def_end_pos": [58, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f'\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g'\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nf' : \u03b1 \u2192 \u03b5' \u2192 \u03b5\ng' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'\nh_assoc : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), f (g a b) c = f' a (g' b c)\nx\u271d : Set \u03b5\n\u22a2 image2 f (image2 g s t) u \u2286 x\u271d \u2194 image2 f' s (image2 g' t u) \u2286 x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "full_name": "Equiv.Perm.cycle_is_cycleOf", "start": [600, 1], "end": [615, 78], "traced_tactics": [{"tactic": "suffices f.cycleOf a = c.cycleOf a by\n  rw [this]\n  apply symm\n  exact\n    Equiv.Perm.IsCycle.cycleOf_eq (Equiv.Perm.mem_cycleFactorsFinset_iff.mp hc).left\n      (Equiv.Perm.mem_support.mp ha)", "annotated_tactic": ["suffices f.cycleOf a = c.cycleOf a by\n    rw [this]\n    apply <a>symm</a>\n    exact\n      <a>Equiv.Perm.IsCycle.cycleOf_eq</a> (Equiv.Perm.mem_cycleFactorsFinset_iff.mp hc).<a>left</a>\n        (Equiv.Perm.mem_support.mp ha)", [{"full_name": "symm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [303, 9], "def_end_pos": [303, 13]}, {"full_name": "Equiv.Perm.IsCycle.cycleOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "def_pos": [124, 9], "def_end_pos": [124, 27]}, {"full_name": "And.left", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [517, 3], "def_end_pos": [517, 7]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\n\u22a2 c = cycleOf f a", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\n\u22a2 cycleOf f a = cycleOf c a"}, {"tactic": "let hfc := (Equiv.Perm.disjoint_mul_inv_of_mem_cycleFactorsFinset hc).symm", "annotated_tactic": ["let hfc := (<a>Equiv.Perm.disjoint_mul_inv_of_mem_cycleFactorsFinset</a> hc).<a>symm</a>", [{"full_name": "Equiv.Perm.disjoint_mul_inv_of_mem_cycleFactorsFinset", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "def_pos": [588, 9], "def_end_pos": [588, 51]}, {"full_name": "Equiv.Perm.Disjoint.symm", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [50, 9], "def_end_pos": [50, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\n\u22a2 cycleOf f a = cycleOf c a", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\n\u22a2 cycleOf f a = cycleOf c a"}, {"tactic": "let hfc2 := Perm.Disjoint.commute hfc", "annotated_tactic": ["let hfc2 := <a>Perm.Disjoint.commute</a> hfc", [{"full_name": "Equiv.Perm.Disjoint.commute", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [63, 9], "def_end_pos": [63, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\n\u22a2 cycleOf f a = cycleOf c a", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\nhfc2 : Commute c (f * c\u207b\u00b9) := Disjoint.commute hfc\n\u22a2 cycleOf f a = cycleOf c a"}, {"tactic": "rw [\u2190 Equiv.Perm.cycleOf_mul_of_apply_right_eq_self hfc2]", "annotated_tactic": ["rw [\u2190 <a>Equiv.Perm.cycleOf_mul_of_apply_right_eq_self</a> hfc2]", [{"full_name": "Equiv.Perm.cycleOf_mul_of_apply_right_eq_self", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "def_pos": [198, 9], "def_end_pos": [198, 43]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\nhfc2 : Commute c (f * c\u207b\u00b9) := Disjoint.commute hfc\n\u22a2 cycleOf f a = cycleOf c a", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\nhfc2 : Commute c (f * c\u207b\u00b9) := Disjoint.commute hfc\n\u22a2 cycleOf f a = cycleOf (c * (f * c\u207b\u00b9)) a\n\ncase hx\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\nhfc2 : Commute c (f * c\u207b\u00b9) := Disjoint.commute hfc\n\u22a2 (f * c\u207b\u00b9) a = a"}, {"tactic": "simp only [hfc2.eq, inv_mul_cancel_right]", "annotated_tactic": ["simp only [hfc2.eq, <a>inv_mul_cancel_right</a>]", [{"full_name": "inv_mul_cancel_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1185, 9], "def_end_pos": [1185, 29]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\nhfc2 : Commute c (f * c\u207b\u00b9) := Disjoint.commute hfc\n\u22a2 cycleOf f a = cycleOf (c * (f * c\u207b\u00b9)) a\n\ncase hx\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\nhfc2 : Commute c (f * c\u207b\u00b9) := Disjoint.commute hfc\n\u22a2 (f * c\u207b\u00b9) a = a", "state_after": "case hx\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\nhfc2 : Commute c (f * c\u207b\u00b9) := Disjoint.commute hfc\n\u22a2 (f * c\u207b\u00b9) a = a"}, {"tactic": "exact\n  Equiv.Perm.not_mem_support.mp\n    (Finset.disjoint_left.mp (Equiv.Perm.Disjoint.disjoint_support hfc) ha)", "annotated_tactic": ["exact\n    Equiv.Perm.not_mem_support.mp\n      (Finset.disjoint_left.mp (<a>Equiv.Perm.Disjoint.disjoint_support</a> hfc) ha)", [{"full_name": "Equiv.Perm.Disjoint.disjoint_support", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [403, 9], "def_end_pos": [403, 34]}]], "state_before": "case hx\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nhfc : Disjoint c (f * c\u207b\u00b9) := Disjoint.symm (disjoint_mul_inv_of_mem_cycleFactorsFinset hc)\nhfc2 : Commute c (f * c\u207b\u00b9) := Disjoint.commute hfc\n\u22a2 (f * c\u207b\u00b9) a = a", "state_after": "no goals"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nthis : cycleOf f a = cycleOf c a\n\u22a2 c = cycleOf f a", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nthis : cycleOf f a = cycleOf c a\n\u22a2 c = cycleOf c a"}, {"tactic": "apply symm", "annotated_tactic": ["apply <a>symm</a>", [{"full_name": "symm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [303, 9], "def_end_pos": [303, 13]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nthis : cycleOf f a = cycleOf c a\n\u22a2 c = cycleOf c a", "state_after": "case a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nthis : cycleOf f a = cycleOf c a\n\u22a2 cycleOf c a = c"}, {"tactic": "exact\n  Equiv.Perm.IsCycle.cycleOf_eq (Equiv.Perm.mem_cycleFactorsFinset_iff.mp hc).left\n    (Equiv.Perm.mem_support.mp ha)", "annotated_tactic": ["exact\n      <a>Equiv.Perm.IsCycle.cycleOf_eq</a> (Equiv.Perm.mem_cycleFactorsFinset_iff.mp hc).<a>left</a>\n        (Equiv.Perm.mem_support.mp ha)", [{"full_name": "Equiv.Perm.IsCycle.cycleOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "def_pos": [124, 9], "def_end_pos": [124, 27]}, {"full_name": "And.left", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [517, 3], "def_end_pos": [517, 7]}]], "state_before": "case a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f c : Perm \u03b1\na : \u03b1\nha : a \u2208 support c\nhc : c \u2208 cycleFactorsFinset f\nthis : cycleOf f a = cycleOf c a\n\u22a2 cycleOf c a = c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.cast_int_comp", "start": [1338, 1], "end": [1338, 77], "traced_tactics": [{"tactic": "cases i <;> simp", "annotated_tactic": ["cases i <;> simp", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d : Ring R\np q r : R[X]\ni : \u2124\n\u22a2 comp (\u2191i) p = \u2191i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Subtype.lean", "full_name": "Subtype.coe_mk", "start": [99, 1], "end": [100, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.Perm.bagInter_right", "start": [425, 1], "end": [436, 34], "traced_tactics": [{"tactic": "induction' h with x _ _ _ _ x y _ _ _ _ _ _ ih_1 ih_2 generalizing t", "annotated_tactic": ["induction' h with x _ _ _ _ x y _ _ _ _ _ _ ih_1 ih_2 generalizing t", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 t : List \u03b1\nh : l\u2081 ~ l\u2082\n\u22a2 List.bagInter l\u2081 t ~ List.bagInter l\u2082 t", "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 t : List \u03b1\n\u22a2 List.bagInter [] t ~ List.bagInter [] t\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d\u00b9 l\u2082\u271d\u00b9 : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\na\u271d : l\u2081\u271d ~ l\u2082\u271d\na_ih\u271d : \u2200 (t : List \u03b1), List.bagInter l\u2081\u271d t ~ List.bagInter l\u2082\u271d t\nt : List \u03b1\n\u22a2 List.bagInter (x :: l\u2081\u271d) t ~ List.bagInter (x :: l\u2082\u271d) t\n\ncase swap\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t\n\ncase trans\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d\u00b9 l\u2082\u271d\u00b9 : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 l\u2081\u271d l\u2082\u271d l\u2083\u271d : List \u03b1\na\u271d\u00b9 : l\u2081\u271d ~ l\u2082\u271d\na\u271d : l\u2082\u271d ~ l\u2083\u271d\nih_1 : \u2200 (t : List \u03b1), List.bagInter l\u2081\u271d t ~ List.bagInter l\u2082\u271d t\nih_2 : \u2200 (t : List \u03b1), List.bagInter l\u2082\u271d t ~ List.bagInter l\u2083\u271d t\nt : List \u03b1\n\u22a2 List.bagInter l\u2081\u271d t ~ List.bagInter l\u2083\u271d t"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 t : List \u03b1\n\u22a2 List.bagInter [] t ~ List.bagInter [] t", "state_after": "no goals"}, {"tactic": "by_cases x \u2208 t <;> simp [*, Perm.cons]", "annotated_tactic": ["by_cases x \u2208 t <;> simp [*, <a>Perm.cons</a>]", [{"full_name": "List.Perm.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1562, 5], "def_end_pos": [1562, 9]}]], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d\u00b9 l\u2082\u271d\u00b9 : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\na\u271d : l\u2081\u271d ~ l\u2082\u271d\na_ih\u271d : \u2200 (t : List \u03b1), List.bagInter l\u2081\u271d t ~ List.bagInter l\u2082\u271d t\nt : List \u03b1\n\u22a2 List.bagInter (x :: l\u2081\u271d) t ~ List.bagInter (x :: l\u2082\u271d) t", "state_after": "no goals"}, {"tactic": "by_cases h : x = y", "annotated_tactic": ["by_cases h : x = y", []], "state_before": "case swap\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : x = y\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t"}, {"tactic": "by_cases xt : x \u2208 t <;> by_cases yt : y \u2208 t", "annotated_tactic": ["by_cases xt : x \u2208 t <;> by_cases yt : y \u2208 t", []], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\nxt : x \u2208 t\nyt : y \u2208 t\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\nxt : x \u2208 t\nyt : y \u2209 t\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t\n\ncase pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\nxt : x \u2209 t\nyt : y \u2208 t\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\nxt : x \u2209 t\nyt : y \u2209 t\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : x = y\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t", "state_after": "no goals"}, {"tactic": "simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (Ne.symm h), erase_comm, swap]", "annotated_tactic": ["simp [xt, yt, <a>mem_erase_of_ne</a> h, <a>mem_erase_of_ne</a> (<a>Ne.symm</a> h), <a>erase_comm</a>, <a>swap</a>]", [{"full_name": "List.mem_erase_of_ne", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1274, 17], "def_end_pos": [1274, 32]}, {"full_name": "List.mem_erase_of_ne", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1274, 17], "def_end_pos": [1274, 32]}, {"full_name": "Ne.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [702, 9], "def_end_pos": [702, 16]}, {"full_name": "List.erase_comm", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1277, 9], "def_end_pos": [1277, 19]}, {"full_name": "List.Perm.swap", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1564, 5], "def_end_pos": [1564, 9]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\nxt : x \u2208 t\nyt : y \u2208 t\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t", "state_after": "no goals"}, {"tactic": "simp [xt, yt, mt mem_of_mem_erase, Perm.cons]", "annotated_tactic": ["simp [xt, yt, <a>mt</a> <a>mem_of_mem_erase</a>, <a>Perm.cons</a>]", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "List.mem_of_mem_erase", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1272, 9], "def_end_pos": [1272, 25]}, {"full_name": "List.Perm.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1562, 5], "def_end_pos": [1562, 9]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\nxt : x \u2208 t\nyt : y \u2209 t\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t", "state_after": "no goals"}, {"tactic": "simp [xt, yt, mt mem_of_mem_erase, Perm.cons]", "annotated_tactic": ["simp [xt, yt, <a>mt</a> <a>mem_of_mem_erase</a>, <a>Perm.cons</a>]", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "List.mem_of_mem_erase", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1272, 9], "def_end_pos": [1272, 25]}, {"full_name": "List.Perm.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1562, 5], "def_end_pos": [1562, 9]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\nxt : x \u2209 t\nyt : y \u2208 t\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t", "state_after": "no goals"}, {"tactic": "simp [xt, yt]", "annotated_tactic": ["simp [xt, yt]", []], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d l\u2082\u271d : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nl\u271d t : List \u03b1\nh : \u00acx = y\nxt : x \u2209 t\nyt : y \u2209 t\n\u22a2 List.bagInter (y :: x :: l\u271d) t ~ List.bagInter (x :: y :: l\u271d) t", "state_after": "no goals"}, {"tactic": "exact (ih_1 _).trans (ih_2 _)", "annotated_tactic": ["exact (ih_1 _).<a>trans</a> (ih_2 _)", [{"full_name": "List.Perm.trans", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1566, 5], "def_end_pos": [1566, 10]}]], "state_before": "case trans\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081\u271d\u00b9 l\u2082\u271d\u00b9 : List \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 l\u2081\u271d l\u2082\u271d l\u2083\u271d : List \u03b1\na\u271d\u00b9 : l\u2081\u271d ~ l\u2082\u271d\na\u271d : l\u2082\u271d ~ l\u2083\u271d\nih_1 : \u2200 (t : List \u03b1), List.bagInter l\u2081\u271d t ~ List.bagInter l\u2082\u271d t\nih_2 : \u2200 (t : List \u03b1), List.bagInter l\u2082\u271d t ~ List.bagInter l\u2083\u271d t\nt : List \u03b1\n\u22a2 List.bagInter l\u2081\u271d t ~ List.bagInter l\u2083\u271d t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Log.lean", "full_name": "Int.log_zpow", "start": [138, 1], "end": [145, 25], "traced_tactics": [{"tactic": "obtain \u27e8n, rfl | rfl\u27e9 := Int.eq_nat_or_neg z", "annotated_tactic": ["obtain \u27e8n, rfl | rfl\u27e9 := <a>Int.eq_nat_or_neg</a> z", [{"full_name": "Int.eq_nat_or_neg", "def_path": ".lake/packages/std/Std/Data/Int/Order.lean", "def_pos": [481, 9], "def_end_pos": [481, 22]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemifield R\ninst\u271d : FloorSemiring R\nb : \u2115\nhb : 1 < b\nz : \u2124\n\u22a2 log b (\u2191b ^ z) = z", "state_after": "case intro.inl\nR : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemifield R\ninst\u271d : FloorSemiring R\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 log b (\u2191b ^ \u2191n) = \u2191n\n\ncase intro.inr\nR : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemifield R\ninst\u271d : FloorSemiring R\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 log b (\u2191b ^ (-\u2191n)) = -\u2191n"}, {"tactic": "rw [log_of_one_le_right _ (one_le_zpow_of_nonneg _ <| Int.coe_nat_nonneg _), zpow_coe_nat, \u2190\n  Nat.cast_pow, Nat.floor_coe, Nat.log_pow hb]", "annotated_tactic": ["rw [<a>log_of_one_le_right</a> _ (<a>one_le_zpow_of_nonneg</a> _ <| <a>Int.coe_nat_nonneg</a> _), <a>zpow_coe_nat</a>, \u2190\n      <a>Nat.cast_pow</a>, <a>Nat.floor_coe</a>, <a>Nat.log_pow</a> hb]", [{"full_name": "Int.log_of_one_le_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Log.lean", "def_pos": [62, 9], "def_end_pos": [62, 28]}, {"full_name": "one_le_zpow_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Power.lean", "def_pos": [45, 9], "def_end_pos": [45, 30]}, {"full_name": "Int.coe_nat_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Defs.lean", "def_pos": [49, 7], "def_end_pos": [49, 21]}, {"full_name": "zpow_coe_nat", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [962, 9], "def_end_pos": [962, 21]}, {"full_name": "Nat.cast_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [83, 7], "def_end_pos": [83, 15]}, {"full_name": "Nat.floor_coe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [167, 9], "def_end_pos": [167, 18]}, {"full_name": "Nat.log_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [156, 9], "def_end_pos": [156, 16]}]], "state_before": "case intro.inl\nR : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemifield R\ninst\u271d : FloorSemiring R\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 log b (\u2191b ^ \u2191n) = \u2191n", "state_after": "R : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemifield R\ninst\u271d : FloorSemiring R\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 1 \u2264 \u2191b"}, {"tactic": "exact mod_cast hb.le", "annotated_tactic": ["exact mod_cast hb.le", []], "state_before": "R : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemifield R\ninst\u271d : FloorSemiring R\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 1 \u2264 \u2191b", "state_after": "no goals"}, {"tactic": "rw [log_of_right_le_one _ (zpow_le_one_of_nonpos _ <| neg_nonpos.mpr (Int.coe_nat_nonneg _)),\n  zpow_neg, inv_inv, zpow_coe_nat, \u2190 Nat.cast_pow, Nat.ceil_natCast, Nat.clog_pow _ _ hb]", "annotated_tactic": ["rw [<a>log_of_right_le_one</a> _ (<a>zpow_le_one_of_nonpos</a> _ <| neg_nonpos.mpr (<a>Int.coe_nat_nonneg</a> _)),\n      <a>zpow_neg</a>, <a>inv_inv</a>, <a>zpow_coe_nat</a>, \u2190 <a>Nat.cast_pow</a>, <a>Nat.ceil_natCast</a>, <a>Nat.clog_pow</a> _ _ hb]", [{"full_name": "Int.log_of_right_le_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Log.lean", "def_pos": [66, 9], "def_end_pos": [66, 28]}, {"full_name": "zpow_le_one_of_nonpos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Power.lean", "def_pos": [41, 9], "def_end_pos": [41, 30]}, {"full_name": "Int.coe_nat_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Defs.lean", "def_pos": [49, 7], "def_end_pos": [49, 21]}, {"full_name": "zpow_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [293, 9], "def_end_pos": [293, 17]}, {"full_name": "inv_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 16]}, {"full_name": "zpow_coe_nat", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [962, 9], "def_end_pos": [962, 21]}, {"full_name": "Nat.cast_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [83, 7], "def_end_pos": [83, 15]}, {"full_name": "Nat.ceil_natCast", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [317, 9], "def_end_pos": [317, 21]}, {"full_name": "Nat.clog_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [313, 9], "def_end_pos": [313, 17]}]], "state_before": "case intro.inr\nR : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemifield R\ninst\u271d : FloorSemiring R\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 log b (\u2191b ^ (-\u2191n)) = -\u2191n", "state_after": "R : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemifield R\ninst\u271d : FloorSemiring R\nb : \u2115\nhb : 1 < b\nn : \u2115\n\u22a2 1 \u2264 \u2191b"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/GDelta.lean", "full_name": "IsG\u03b4.sUnion", "start": [153, 1], "end": [158, 29], "traced_tactics": [{"tactic": "induction S, hS using Set.Finite.dinduction_on with\n| H0 => simp\n| H1 _ _ ih =>\n  simp only [ball_insert_iff, sUnion_insert] at *\n  exact h.1.union (ih h.2)", "annotated_tactic": ["induction S, hS using <a>Set.Finite.dinduction_on</a> with\n  | H0 => simp\n  | H1 _ _ ih =>\n    simp only [<a>ball_insert_iff</a>, <a>sUnion_insert</a>] at *\n    exact h.1.<a>union</a> (ih h.2)", [{"full_name": "Set.Finite.dinduction_on", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1192, 9], "def_end_pos": [1192, 29]}, {"full_name": "Set.ball_insert_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1225, 9], "def_end_pos": [1225, 24]}, {"full_name": "Set.sUnion_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1143, 9], "def_end_pos": [1143, 22]}, {"full_name": "IsG\u03b4.union", "def_path": ".lake/packages/mathlib/Mathlib/Topology/GDelta.lean", "def_pos": [143, 9], "def_end_pos": [143, 19]}]], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhS : Set.Finite S\nh : \u2200 s \u2208 S, IsG\u03b4 s\n\u22a2 IsG\u03b4 (\u22c3\u2080 S)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case H0\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nh : \u2200 s \u2208 \u2205, IsG\u03b4 s\n\u22a2 IsG\u03b4 (\u22c3\u2080 \u2205)", "state_after": "no goals"}, {"tactic": "simp only [ball_insert_iff, sUnion_insert] at *", "annotated_tactic": ["simp only [<a>ball_insert_iff</a>, <a>sUnion_insert</a>] at *", [{"full_name": "Set.ball_insert_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1225, 9], "def_end_pos": [1225, 24]}, {"full_name": "Set.sUnion_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1143, 9], "def_end_pos": [1143, 22]}]], "state_before": "case H1\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\na\u271d\u00b9 : Set X\ns\u271d : Set (Set X)\na\u271d : a\u271d\u00b9 \u2209 s\u271d\nh\u271d : Set.Finite s\u271d\nih : (\u2200 s \u2208 s\u271d, IsG\u03b4 s) \u2192 IsG\u03b4 (\u22c3\u2080 s\u271d)\nh : \u2200 s \u2208 insert a\u271d\u00b9 s\u271d, IsG\u03b4 s\n\u22a2 IsG\u03b4 (\u22c3\u2080 insert a\u271d\u00b9 s\u271d)", "state_after": "case H1\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\na\u271d\u00b9 : Set X\ns\u271d : Set (Set X)\na\u271d : a\u271d\u00b9 \u2209 s\u271d\nh\u271d : Set.Finite s\u271d\nih : (\u2200 s \u2208 s\u271d, IsG\u03b4 s) \u2192 IsG\u03b4 (\u22c3\u2080 s\u271d)\nh : IsG\u03b4 a\u271d\u00b9 \u2227 \u2200 x \u2208 s\u271d, IsG\u03b4 x\n\u22a2 IsG\u03b4 (a\u271d\u00b9 \u222a \u22c3\u2080 s\u271d)"}, {"tactic": "exact h.1.union (ih h.2)", "annotated_tactic": ["exact h.1.<a>union</a> (ih h.2)", [{"full_name": "IsG\u03b4.union", "def_path": ".lake/packages/mathlib/Mathlib/Topology/GDelta.lean", "def_pos": [143, 9], "def_end_pos": [143, 19]}]], "state_before": "case H1\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\na\u271d\u00b9 : Set X\ns\u271d : Set (Set X)\na\u271d : a\u271d\u00b9 \u2209 s\u271d\nh\u271d : Set.Finite s\u271d\nih : (\u2200 s \u2208 s\u271d, IsG\u03b4 s) \u2192 IsG\u03b4 (\u22c3\u2080 s\u271d)\nh : IsG\u03b4 a\u271d\u00b9 \u2227 \u2200 x \u2208 s\u271d, IsG\u03b4 x\n\u22a2 IsG\u03b4 (a\u271d\u00b9 \u222a \u22c3\u2080 s\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Data/Bool/Lemmas.lean", "full_name": "Bool.cond_false", "start": [42, 1], "end": [42, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.union_inter_cancel_right", "start": [1675, 1], "end": [1676, 69], "traced_tactics": [{"tactic": "rw [\u2190 coe_inj, coe_inter, coe_union, Set.union_inter_cancel_right]", "annotated_tactic": ["rw [\u2190 <a>coe_inj</a>, <a>coe_inter</a>, <a>coe_union</a>, <a>Set.union_inter_cancel_right</a>]", [{"full_name": "Finset.coe_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [249, 9], "def_end_pos": [249, 16]}, {"full_name": "Finset.coe_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1665, 9], "def_end_pos": [1665, 18]}, {"full_name": "Finset.coe_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1434, 9], "def_end_pos": [1434, 18]}, {"full_name": "Set.union_inter_cancel_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1010, 9], "def_end_pos": [1010, 33]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u v : Finset \u03b1\na b : \u03b1\ns t : Finset \u03b1\n\u22a2 (s \u222a t) \u2229 t = t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/RatFunc.lean", "full_name": "RatFunc.denom_mul_dvd", "start": [1322, 1], "end": [1325, 90], "traced_tactics": [{"tactic": "rw [denom_dvd (mul_ne_zero (denom_ne_zero x) (denom_ne_zero y))]", "annotated_tactic": ["rw [<a>denom_dvd</a> (<a>mul_ne_zero</a> (<a>denom_ne_zero</a> x) (<a>denom_ne_zero</a> y))]", [{"full_name": "RatFunc.denom_dvd", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1300, 9], "def_end_pos": [1300, 18]}, {"full_name": "mul_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [88, 9], "def_end_pos": [88, 20]}, {"full_name": "RatFunc.denom_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1196, 9], "def_end_pos": [1196, 22]}, {"full_name": "RatFunc.denom_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1196, 9], "def_end_pos": [1196, 22]}]], "state_before": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\n\u22a2 denom (x * y) \u2223 denom x * denom y", "state_after": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\n\u22a2 \u2203 p, x * y = (algebraMap K[X] (RatFunc K)) p / (algebraMap K[X] (RatFunc K)) (denom x * denom y)"}, {"tactic": "refine' \u27e8x.num * y.num, _\u27e9", "annotated_tactic": ["refine' \u27e8x.num * y.num, _\u27e9", []], "state_before": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\n\u22a2 \u2203 p, x * y = (algebraMap K[X] (RatFunc K)) p / (algebraMap K[X] (RatFunc K)) (denom x * denom y)", "state_after": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\n\u22a2 x * y = (algebraMap K[X] (RatFunc K)) (num x * num y) / (algebraMap K[X] (RatFunc K)) (denom x * denom y)"}, {"tactic": "rw [RingHom.map_mul, RingHom.map_mul, \u2190 div_mul_div_comm, num_div_denom, num_div_denom]", "annotated_tactic": ["rw [<a>RingHom.map_mul</a>, <a>RingHom.map_mul</a>, \u2190 <a>div_mul_div_comm</a>, <a>num_div_denom</a>, <a>num_div_denom</a>]", [{"full_name": "RingHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "RingHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "div_mul_div_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [657, 9], "def_end_pos": [657, 25]}, {"full_name": "RatFunc.num_div_denom", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1225, 9], "def_end_pos": [1225, 22]}, {"full_name": "RatFunc.num_div_denom", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1225, 9], "def_end_pos": [1225, 22]}]], "state_before": "K : Type u\ninst\u271d : Field K\nx y : RatFunc K\n\u22a2 x * y = (algebraMap K[X] (RatFunc K)) (num x * num y) / (algebraMap K[X] (RatFunc K)) (denom x * denom y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "Filter.Tendsto.add_atBot", "start": [1132, 1], "end": [1134, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Matrix.lean", "full_name": "Continuous.matrix_adjugate", "start": [224, 1], "end": [227, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "coinduced_compose", "start": [484, 1], "end": [486, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.eval_nat_cast_map", "start": [1003, 1], "end": [1009, 81], "traced_tactics": [{"tactic": "induction p using Polynomial.induction_on' with\n| h_add p q hp hq =>\n  simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]\n| h_monomial n r =>\n  simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]", "annotated_tactic": ["induction p using <a>Polynomial.induction_on'</a> with\n  | h_add p q hp hq =>\n    simp only [hp, hq, <a>Polynomial.map_add</a>, <a>RingHom.map_add</a>, <a>eval_add</a>]\n  | h_monomial n r =>\n    simp only [<a>map_natCast</a> f, <a>eval_monomial</a>, <a>map_monomial</a>, f.map_pow, f.map_mul]", [{"full_name": "Polynomial.induction_on'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Induction.lean", "def_pos": [63, 19], "def_end_pos": [63, 32]}, {"full_name": "Polynomial.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [736, 19], "def_end_pos": [736, 26]}, {"full_name": "RingHom.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [559, 19], "def_end_pos": [559, 26]}, {"full_name": "Polynomial.eval_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [391, 9], "def_end_pos": [391, 17]}, {"full_name": "map_natCast", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [174, 9], "def_end_pos": [174, 20]}, {"full_name": "Polynomial.eval_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [381, 9], "def_end_pos": [381, 22]}, {"full_name": "Polynomial.map_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [725, 9], "def_end_pos": [725, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : Semiring S\nf\u271d f : R \u2192+* S\np : R[X]\nn : \u2115\n\u22a2 eval (\u2191n) (map f p) = f (eval (\u2191n) p)", "state_after": "no goals"}, {"tactic": "simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]", "annotated_tactic": ["simp only [hp, hq, <a>Polynomial.map_add</a>, <a>RingHom.map_add</a>, <a>eval_add</a>]", [{"full_name": "Polynomial.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [736, 19], "def_end_pos": [736, 26]}, {"full_name": "RingHom.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [559, 19], "def_end_pos": [559, 26]}, {"full_name": "Polynomial.eval_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [391, 9], "def_end_pos": [391, 17]}]], "state_before": "case h_add\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q\u271d r : R[X]\ninst\u271d : Semiring S\nf\u271d f : R \u2192+* S\nn : \u2115\np q : R[X]\nhp : eval (\u2191n) (map f p) = f (eval (\u2191n) p)\nhq : eval (\u2191n) (map f q) = f (eval (\u2191n) q)\n\u22a2 eval (\u2191n) (map f (p + q)) = f (eval (\u2191n) (p + q))", "state_after": "no goals"}, {"tactic": "simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]", "annotated_tactic": ["simp only [<a>map_natCast</a> f, <a>eval_monomial</a>, <a>map_monomial</a>, f.map_pow, f.map_mul]", [{"full_name": "map_natCast", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [174, 9], "def_end_pos": [174, 20]}, {"full_name": "Polynomial.eval_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [381, 9], "def_end_pos": [381, 22]}, {"full_name": "Polynomial.map_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [725, 9], "def_end_pos": [725, 21]}]], "state_before": "case h_monomial\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n\u271d\u00b9 : \u2115\ninst\u271d\u00b9 : Semiring R\np q r\u271d : R[X]\ninst\u271d : Semiring S\nf\u271d f : R \u2192+* S\nn\u271d n : \u2115\nr : R\n\u22a2 eval (\u2191n\u271d) (map f ((monomial n) r)) = f (eval (\u2191n\u271d) ((monomial n) r))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/WithTop.lean", "full_name": "WithTop.prod_lt_top", "start": [44, 1], "end": [48, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometry.ediam_image", "start": [329, 1], "end": [330, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Perm.lean", "full_name": "length_permsOfList", "start": [38, 1], "end": [44, 9], "traced_tactics": [{"tactic": "rw [length_cons, Nat.factorial_succ]", "annotated_tactic": ["rw [<a>length_cons</a>, <a>Nat.factorial_succ</a>]", [{"full_name": "List.length_cons", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2332, 17], "def_end_pos": [2332, 33]}, {"full_name": "Nat.factorial_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [46, 9], "def_end_pos": [46, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\na : \u03b1\nl : List \u03b1\n\u22a2 length (permsOfList (a :: l)) = (length (a :: l))!", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\na : \u03b1\nl : List \u03b1\n\u22a2 length (permsOfList (a :: l)) = (length l + 1) * (length l)!"}, {"tactic": "simp only [permsOfList, length_append, length_permsOfList, length_bind, comp,\n length_map, map_const', sum_replicate, smul_eq_mul, succ_mul]", "annotated_tactic": ["simp only [<a>permsOfList</a>, <a>length_append</a>, length_permsOfList, <a>length_bind</a>, <a>comp</a>,\n     <a>length_map</a>, <a>map_const'</a>, <a>sum_replicate</a>, <a>smul_eq_mul</a>, <a>succ_mul</a>]", [{"full_name": "permsOfList", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Perm.lean", "def_pos": [33, 5], "def_end_pos": [33, 16]}, {"full_name": "List.length_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [857, 17], "def_end_pos": [857, 30]}, {"full_name": "List.length_bind", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Join.lean", "def_pos": [73, 9], "def_end_pos": [73, 20]}, {"full_name": "Function.comp", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}, {"full_name": "List.length_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [862, 17], "def_end_pos": [862, 27]}, {"full_name": "List.map_const'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1887, 17], "def_end_pos": [1887, 27]}, {"full_name": "List.sum_replicate", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [87, 3], "def_end_pos": [87, 14]}, {"full_name": "smul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}, {"full_name": "Nat.succ_mul", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [176, 9], "def_end_pos": [176, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\na : \u03b1\nl : List \u03b1\n\u22a2 length (permsOfList (a :: l)) = (length l + 1) * (length l)!", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\na : \u03b1\nl : List \u03b1\n\u22a2 (length l)! + length l * (length l)! = length l * (length l)! + (length l)!"}, {"tactic": "ring", "annotated_tactic": ["ring", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\na : \u03b1\nl : List \u03b1\n\u22a2 (length l)! + length l * (length l)! = length l * (length l)! + (length l)!", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean", "full_name": "MeasureTheory.coe_measureUnivNNReal", "start": [88, 1], "end": [90, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.vsub_card_le", "start": [1583, 1], "end": [1584, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Algebra/Classes.lean", "full_name": "asymm_of", "start": [354, 1], "end": [355, 8], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeGroup/Basic.lean", "full_name": "FreeGroup.map.mk", "start": [800, 1], "end": [801, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.total_comp", "start": [863, 1], "end": [866, 21], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nf : \u03b1' \u2192 \u03b1\n\u22a2 Finsupp.total \u03b1' M R (v \u2218 f) = Finsupp.total \u03b1 M R v \u2218\u2097 lmapDomain R R f", "state_after": "case h.h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nf : \u03b1' \u2192 \u03b1\na\u271d : \u03b1'\n\u22a2 (Finsupp.total \u03b1' M R (v \u2218 f) \u2218\u2097 lsingle a\u271d) 1 = ((Finsupp.total \u03b1 M R v \u2218\u2097 lmapDomain R R f) \u2218\u2097 lsingle a\u271d) 1"}, {"tactic": "simp [total_apply]", "annotated_tactic": ["simp [<a>total_apply</a>]", [{"full_name": "Finsupp.total_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [666, 9], "def_end_pos": [666, 20]}]], "state_before": "case h.h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nf : \u03b1' \u2192 \u03b1\na\u271d : \u03b1'\n\u22a2 (Finsupp.total \u03b1' M R (v \u2218 f) \u2218\u2097 lsingle a\u271d) 1 = ((Finsupp.total \u03b1 M R v \u2218\u2097 lmapDomain R R f) \u2218\u2097 lsingle a\u271d) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/SimpleModule.lean", "full_name": "RingHom.isSemisimpleRing_of_surjective", "start": [320, 1], "end": [326, 17], "traced_tactics": [{"tactic": "letI : Module R S := Module.compHom _ f", "annotated_tactic": ["letI : <a>Module</a> R S := <a>Module.compHom</a> _ f", [{"full_name": "Module", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [56, 7], "def_end_pos": [56, 13]}, {"full_name": "Module.compHom", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [158, 5], "def_end_pos": [158, 19]}]], "state_before": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : Ring S\nM : Type u_4\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nm : Submodule R M\nN : Type u_5\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\ninst\u271d : IsSemisimpleRing R\n\u22a2 IsSemisimpleRing S", "state_after": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : Ring S\nM : Type u_4\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nm : Submodule R M\nN : Type u_5\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\ninst\u271d : IsSemisimpleRing R\nthis : Module R S := Module.compHom S f\n\u22a2 IsSemisimpleRing S"}, {"tactic": "haveI : RingHomSurjective f := \u27e8hf\u27e9", "annotated_tactic": ["haveI : <a>RingHomSurjective</a> f := \u27e8hf\u27e9", [{"full_name": "RingHomSurjective", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/CompTypeclasses.lean", "def_pos": [170, 7], "def_end_pos": [170, 24]}]], "state_before": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : Ring S\nM : Type u_4\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nm : Submodule R M\nN : Type u_5\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\ninst\u271d : IsSemisimpleRing R\nthis : Module R S := Module.compHom S f\n\u22a2 IsSemisimpleRing S", "state_after": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : Ring S\nM : Type u_4\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nm : Submodule R M\nN : Type u_5\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\ninst\u271d : IsSemisimpleRing R\nthis\u271d : Module R S := Module.compHom S f\nthis : RingHomSurjective f\n\u22a2 IsSemisimpleRing S"}, {"tactic": "let e : S \u2192\u209b\u2097[f] S := { AddMonoidHom.id S with map_smul' := fun _ _ \u21a6 rfl }", "annotated_tactic": ["let e : S \u2192\u209b\u2097[f] S := { <a>AddMonoidHom.id</a> S with map_smul' := fun _ _ \u21a6 <a>rfl</a> }", [{"full_name": "AddMonoidHom.id", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [881, 3], "def_end_pos": [881, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : Ring S\nM : Type u_4\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nm : Submodule R M\nN : Type u_5\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\ninst\u271d : IsSemisimpleRing R\nthis\u271d : Module R S := Module.compHom S f\nthis : RingHomSurjective f\n\u22a2 IsSemisimpleRing S", "state_after": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : Ring S\nM : Type u_4\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nm : Submodule R M\nN : Type u_5\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\ninst\u271d : IsSemisimpleRing R\nthis\u271d : Module R S := Module.compHom S f\nthis : RingHomSurjective f\ne : S \u2192\u209b\u2097[f] S :=\n  let __src := AddMonoidHom.id S;\n  { toAddHom := { toFun := __src.toFun, map_add' := \u22ef }, map_smul' := \u22ef }\n\u22a2 IsSemisimpleRing S"}, {"tactic": "rw [IsSemisimpleRing, \u2190 e.isSemisimpleModule_iff_of_bijective Function.bijective_id]", "annotated_tactic": ["rw [<a>IsSemisimpleRing</a>, \u2190 e.isSemisimpleModule_iff_of_bijective <a>Function.bijective_id</a>]", [{"full_name": "IsSemisimpleRing", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/SimpleModule.lean", "def_pos": [62, 8], "def_end_pos": [62, 24]}, {"full_name": "Function.bijective_id", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [207, 9], "def_end_pos": [207, 21]}]], "state_before": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : Ring S\nM : Type u_4\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nm : Submodule R M\nN : Type u_5\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\ninst\u271d : IsSemisimpleRing R\nthis\u271d : Module R S := Module.compHom S f\nthis : RingHomSurjective f\ne : S \u2192\u209b\u2097[f] S :=\n  let __src := AddMonoidHom.id S;\n  { toAddHom := { toFun := __src.toFun, map_add' := \u22ef }, map_smul' := \u22ef }\n\u22a2 IsSemisimpleRing S", "state_after": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : Ring S\nM : Type u_4\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nm : Submodule R M\nN : Type u_5\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\ninst\u271d : IsSemisimpleRing R\nthis\u271d : Module R S := Module.compHom S f\nthis : RingHomSurjective f\ne : S \u2192\u209b\u2097[f] S :=\n  let __src := AddMonoidHom.id S;\n  { toAddHom := { toFun := __src.toFun, map_add' := \u22ef }, map_smul' := \u22ef }\n\u22a2 IsSemisimpleModule R S"}, {"tactic": "infer_instance", "annotated_tactic": ["infer_instance", []], "state_before": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : Ring S\nM : Type u_4\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\nm : Submodule R M\nN : Type u_5\ninst\u271d\u00b2 : AddCommGroup N\ninst\u271d\u00b9 : Module R N\nf : R \u2192+* S\nhf : Function.Surjective \u21d1f\ninst\u271d : IsSemisimpleRing R\nthis\u271d : Module R S := Module.compHom S f\nthis : RingHomSurjective f\ne : S \u2192\u209b\u2097[f] S :=\n  let __src := AddMonoidHom.id S;\n  { toAddHom := { toFun := __src.toFun, map_add' := \u22ef }, map_smul' := \u22ef }\n\u22a2 IsSemisimpleModule R S", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "Submodule.toLinearPMap_domain", "start": [1026, 1], "end": [1027, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Subsemiring.closure_induction\u2082", "start": [882, 1], "end": [892, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Circle.lean", "full_name": "expMapCircle_sub", "start": [151, 1], "end": [152, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Antisymmetrization.lean", "full_name": "toAntisymmetrization_ofAntisymmetrization", "start": [124, 1], "end": [126, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/ComputeDegree.lean", "full_name": "Mathlib.Tactic.ComputeDegree.natDegree_nat_cast_le", "start": [94, 1], "end": [94, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.ofFinsupp_zero", "start": [155, 1], "end": [156, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/IsLimit.lean", "full_name": "CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_inv_comp", "start": [160, 1], "end": [162, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "full_name": "SeminormFamily.withSeminorms_iff_uniformSpace_eq_iInf", "start": [460, 1], "end": [467, 78], "traced_tactics": [{"tactic": "rw [p.withSeminorms_iff_nhds_eq_iInf,\n  UniformAddGroup.ext_iff inferInstance (uniformAddGroup_iInf fun i => inferInstance),\n  UniformSpace.toTopologicalSpace_iInf, nhds_iInf]", "annotated_tactic": ["rw [p.withSeminorms_iff_nhds_eq_iInf,\n    <a>UniformAddGroup.ext_iff</a> <a>inferInstance</a> (<a>uniformAddGroup_iInf</a> fun i => <a>inferInstance</a>),\n    <a>UniformSpace.toTopologicalSpace_iInf</a>, <a>nhds_iInf</a>]", [{"full_name": "UniformAddGroup.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/UniformGroup.lean", "def_pos": [303, 3], "def_end_pos": [303, 14]}, {"full_name": "inferInstance", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [99, 8], "def_end_pos": [99, 21]}, {"full_name": "uniformAddGroup_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/UniformGroup.lean", "def_pos": [221, 3], "def_end_pos": [221, 14]}, {"full_name": "inferInstance", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [99, 8], "def_end_pos": [99, 21]}, {"full_name": "UniformSpace.toTopologicalSpace_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [1322, 9], "def_end_pos": [1322, 32]}, {"full_name": "nhds_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [644, 9], "def_end_pos": [644, 18]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Nonempty \u03b9\nu : UniformSpace E\ninst\u271d : UniformAddGroup E\np : SeminormFamily \ud835\udd5c E \u03b9\n\u22a2 WithSeminorms p \u2194 u = \u2a05 i, PseudoMetricSpace.toUniformSpace", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Nonempty \u03b9\nu : UniformSpace E\ninst\u271d : UniformAddGroup E\np : SeminormFamily \ud835\udd5c E \u03b9\n\u22a2 \ud835\udcdd 0 = \u2a05 i, comap (\u21d1(p i)) (\ud835\udcdd 0) \u2194 \ud835\udcdd 0 = \u2a05 i, \ud835\udcdd 0"}, {"tactic": "congrm _ = \u2a05 i, ?_", "annotated_tactic": ["congrm _ = \u2a05 i, ?_", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Nonempty \u03b9\nu : UniformSpace E\ninst\u271d : UniformAddGroup E\np : SeminormFamily \ud835\udd5c E \u03b9\n\u22a2 \ud835\udcdd 0 = \u2a05 i, comap (\u21d1(p i)) (\ud835\udcdd 0) \u2194 \ud835\udcdd 0 = \u2a05 i, \ud835\udcdd 0", "state_after": "case a\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Nonempty \u03b9\nu : UniformSpace E\ninst\u271d : UniformAddGroup E\np : SeminormFamily \ud835\udd5c E \u03b9\ni : \u03b9\n\u22a2 comap (\u21d1(p i)) (\ud835\udcdd 0) = \ud835\udcdd 0"}, {"tactic": "exact @comap_norm_nhds_zero _ (p i).toAddGroupSeminorm.toSeminormedAddGroup", "annotated_tactic": ["exact @<a>comap_norm_nhds_zero</a> _ (p i).toAddGroupSeminorm.toSeminormedAddGroup", [{"full_name": "comap_norm_nhds_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [1168, 3], "def_end_pos": [1168, 14]}]], "state_before": "case a\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Nonempty \u03b9\nu : UniformSpace E\ninst\u271d : UniformAddGroup E\np : SeminormFamily \ud835\udd5c E \u03b9\ni : \u03b9\n\u22a2 comap (\u21d1(p i)) (\ud835\udcdd 0) = \ud835\udcdd 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/FinitePresentation.lean", "full_name": "Algebra.FinitePresentation.quotient", "start": [130, 11], "end": [136, 13], "traced_tactics": [{"tactic": "obtain \u27e8n, f, hf\u27e9 := hfp", "annotated_tactic": ["obtain \u27e8n, f, hf\u27e9 := hfp", []], "state_before": "R : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra R B\nI : Ideal A\nh : Ideal.FG I\nhfp : FinitePresentation R A\n\u22a2 FinitePresentation R (A \u29f8 I)", "state_after": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra R B\nI : Ideal A\nh : Ideal.FG I\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f \u2227 Ideal.FG (RingHom.ker f.toRingHom)\n\u22a2 FinitePresentation R (A \u29f8 I)"}, {"tactic": "refine' \u27e8n, (Ideal.Quotient.mk\u2090 R I).comp f, _, _\u27e9", "annotated_tactic": ["refine' \u27e8n, (<a>Ideal.Quotient.mk\u2090</a> R I).<a>comp</a> f, _, _\u27e9", [{"full_name": "Ideal.Quotient.mk\u2090", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [319, 5], "def_end_pos": [319, 17]}, {"full_name": "AlgHom.comp", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [323, 5], "def_end_pos": [323, 9]}]], "state_before": "case intro.intro\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra R B\nI : Ideal A\nh : Ideal.FG I\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f \u2227 Ideal.FG (RingHom.ker f.toRingHom)\n\u22a2 FinitePresentation R (A \u29f8 I)", "state_after": "case intro.intro.refine'_1\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra R B\nI : Ideal A\nh : Ideal.FG I\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f \u2227 Ideal.FG (RingHom.ker f.toRingHom)\n\u22a2 Surjective \u21d1(AlgHom.comp (Ideal.Quotient.mk\u2090 R I) f)\n\ncase intro.intro.refine'_2\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra R B\nI : Ideal A\nh : Ideal.FG I\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f \u2227 Ideal.FG (RingHom.ker f.toRingHom)\n\u22a2 Ideal.FG (RingHom.ker (AlgHom.comp (Ideal.Quotient.mk\u2090 R I) f).toRingHom)"}, {"tactic": "exact (Ideal.Quotient.mk\u2090_surjective R I).comp hf.1", "annotated_tactic": ["exact (<a>Ideal.Quotient.mk\u2090_surjective</a> R I).<a>comp</a> hf.1", [{"full_name": "Ideal.Quotient.mk\u2090_surjective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [361, 9], "def_end_pos": [361, 32]}, {"full_name": "Function.Surjective.comp", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [130, 9], "def_end_pos": [130, 24]}]], "state_before": "case intro.intro.refine'_1\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra R B\nI : Ideal A\nh : Ideal.FG I\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f \u2227 Ideal.FG (RingHom.ker f.toRingHom)\n\u22a2 Surjective \u21d1(AlgHom.comp (Ideal.Quotient.mk\u2090 R I) f)", "state_after": "no goals"}, {"tactic": "refine' Ideal.fg_ker_comp _ _ hf.2 _ hf.1", "annotated_tactic": ["refine' <a>Ideal.fg_ker_comp</a> _ _ hf.2 _ hf.1", [{"full_name": "Ideal.fg_ker_comp", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Finiteness.lean", "def_pos": [500, 9], "def_end_pos": [500, 20]}]], "state_before": "case intro.intro.refine'_2\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra R B\nI : Ideal A\nh : Ideal.FG I\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f \u2227 Ideal.FG (RingHom.ker f.toRingHom)\n\u22a2 Ideal.FG (RingHom.ker (AlgHom.comp (Ideal.Quotient.mk\u2090 R I) f).toRingHom)", "state_after": "case intro.intro.refine'_2\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra R B\nI : Ideal A\nh : Ideal.FG I\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f \u2227 Ideal.FG (RingHom.ker f.toRingHom)\n\u22a2 Ideal.FG (RingHom.ker (Ideal.Quotient.mk\u2090 R I).toRingHom)"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case intro.intro.refine'_2\nR : Type w\u2081\nA : Type w\u2082\nB : Type w\u2083\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra R B\nI : Ideal A\nh : Ideal.FG I\nn : \u2115\nf : MvPolynomial (Fin n) R \u2192\u2090[R] A\nhf : Surjective \u21d1f \u2227 Ideal.FG (RingHom.ker f.toRingHom)\n\u22a2 Ideal.FG (RingHom.ker (Ideal.Quotient.mk\u2090 R I).toRingHom)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.Tendsto.iterate", "start": [3073, 11], "end": [3076, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.get?_inj", "start": [756, 1], "end": [771, 39], "traced_tactics": [{"tactic": "induction xs generalizing i j with\n| nil => cases h\u2080\n| cons x xs ih =>\n  match i, j with\n  | 0, 0 => rfl\n  | i+1, j+1 => simp; cases h\u2081 with\n    | cons ha h\u2081 => exact ih (Nat.lt_of_succ_lt_succ h\u2080) h\u2081 h\u2082\n  | i+1, 0 => ?_ | 0, j+1 => ?_\n  all_goals\n    simp at h\u2082\n    cases h\u2081; rename_i h' h\n    have := h x ?_ rfl; cases this\n    rw [mem_iff_get?]\n  exact \u27e8_, h\u2082\u27e9; exact \u27e8_ , h\u2082.symm\u27e9", "annotated_tactic": ["induction xs generalizing i j with\n  | <a>nil</a> => cases h\u2080\n  | <a>cons</a> x xs ih =>\n    match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h\u2081 with\n      | <a>cons</a> ha h\u2081 => exact ih (<a>Nat.lt_of_succ_lt_succ</a> h\u2080) h\u2081 h\u2082\n    | i+1, 0 => ?_ | 0, j+1 => ?_\n    all_goals\n      simp at h\u2082\n      cases h\u2081; rename_i h' h\n      have := h x ?_ <a>rfl</a>; cases this\n      rw [<a>mem_iff_get?</a>]\n    exact \u27e8_, h\u2082\u27e9; exact \u27e8_ , h\u2082.symm\u27e9", [{"full_name": "List.nil", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2268, 5], "def_end_pos": [2268, 8]}, {"full_name": "List.cons", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2271, 5], "def_end_pos": [2271, 9]}, {"full_name": "List.Pairwise.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1035, 5], "def_end_pos": [1035, 9]}, {"full_name": "Nat.lt_of_succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [289, 9], "def_end_pos": [289, 27]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "List.mem_iff_get?", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [744, 9], "def_end_pos": [744, 21]}]], "state_before": "i : Nat\n\u03b1\u271d : Type u_1\nxs : List \u03b1\u271d\nj : Nat\nh\u2080 : i < length xs\nh\u2081 : Nodup xs\nh\u2082 : get? xs i = get? xs j\n\u22a2 i = j", "state_after": "no goals"}, {"tactic": "cases h\u2080", "annotated_tactic": ["cases h\u2080", []], "state_before": "case nil\n\u03b1\u271d : Type u_1\ni j : Nat\nh\u2080 : i < length []\nh\u2081 : Nodup []\nh\u2082 : get? [] i = get? [] j\n\u22a2 i = j", "state_after": "no goals"}, {"tactic": "match i, j with\n| 0, 0 => rfl\n| i+1, j+1 => simp; cases h\u2081 with\n  | cons ha h\u2081 => exact ih (Nat.lt_of_succ_lt_succ h\u2080) h\u2081 h\u2082\n| i+1, 0 => ?_ | 0, j+1 => ?_", "annotated_tactic": ["match i, j with\n    | 0, 0 => rfl\n    | i+1, j+1 => simp; cases h\u2081 with\n      | <a>cons</a> ha h\u2081 => exact ih (<a>Nat.lt_of_succ_lt_succ</a> h\u2080) h\u2081 h\u2082\n    | i+1, 0 => ?_ | 0, j+1 => ?_", [{"full_name": "List.Pairwise.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1035, 5], "def_end_pos": [1035, 9]}, {"full_name": "Nat.lt_of_succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [289, 9], "def_end_pos": [289, 27]}]], "state_before": "case cons\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j : Nat\nh\u2080 : i < length (x :: xs)\nh\u2081 : Nodup (x :: xs)\nh\u2082 : get? (x :: xs) i = get? (x :: xs) j\n\u22a2 i = j", "state_after": "case cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni\u271d j : Nat\nh\u2081 : Nodup (x :: xs)\ni : Nat\nh\u2080 : i + 1 < length (x :: xs)\nh\u2082 : get? (x :: xs) (i + 1) = get? (x :: xs) 0\n\u22a2 i + 1 = 0\n\ncase cons.refine_2\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d : Nat\nh\u2081 : Nodup (x :: xs)\nj : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : get? (x :: xs) 0 = get? (x :: xs) (j + 1)\n\u22a2 0 = j + 1"}, {"tactic": "all_goals\n  simp at h\u2082\n  cases h\u2081; rename_i h' h\n  have := h x ?_ rfl; cases this\n  rw [mem_iff_get?]", "annotated_tactic": ["all_goals\n      simp at h\u2082\n      cases h\u2081; rename_i h' h\n      have := h x ?_ <a>rfl</a>; cases this\n      rw [<a>mem_iff_get?</a>]", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "List.mem_iff_get?", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [744, 9], "def_end_pos": [744, 21]}]], "state_before": "case cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni\u271d j : Nat\nh\u2081 : Nodup (x :: xs)\ni : Nat\nh\u2080 : i + 1 < length (x :: xs)\nh\u2082 : get? (x :: xs) (i + 1) = get? (x :: xs) 0\n\u22a2 i + 1 = 0\n\ncase cons.refine_2\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d : Nat\nh\u2081 : Nodup (x :: xs)\nj : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : get? (x :: xs) 0 = get? (x :: xs) (j + 1)\n\u22a2 0 = j + 1", "state_after": "case cons.refine_1.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni\u271d j i : Nat\nh\u2080 : i + 1 < length (x :: xs)\nh\u2082 : get? xs i = some x\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 \u2203 n, get? xs n = some x\n\ncase cons.refine_2.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 \u2203 n, get? xs n = some x"}, {"tactic": "exact \u27e8_, h\u2082\u27e9", "annotated_tactic": ["exact \u27e8_, h\u2082\u27e9", []], "state_before": "case cons.refine_1.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni\u271d j i : Nat\nh\u2080 : i + 1 < length (x :: xs)\nh\u2082 : get? xs i = some x\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 \u2203 n, get? xs n = some x\n\ncase cons.refine_2.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 \u2203 n, get? xs n = some x", "state_after": "case cons.refine_2.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 \u2203 n, get? xs n = some x"}, {"tactic": "exact \u27e8_ , h\u2082.symm\u27e9", "annotated_tactic": ["exact \u27e8_ , h\u2082.symm\u27e9", []], "state_before": "case cons.refine_2.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 \u2203 n, get? xs n = some x", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j : Nat\nh\u2081 : Nodup (x :: xs)\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : get? (x :: xs) 0 = get? (x :: xs) 0\n\u22a2 0 = 0", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni\u271d j\u271d : Nat\nh\u2081 : Nodup (x :: xs)\ni j : Nat\nh\u2080 : i + 1 < length (x :: xs)\nh\u2082 : get? (x :: xs) (i + 1) = get? (x :: xs) (j + 1)\n\u22a2 i + 1 = j + 1", "state_after": "\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni\u271d j\u271d : Nat\nh\u2081 : Nodup (x :: xs)\ni j : Nat\nh\u2080 : i + 1 < length (x :: xs)\nh\u2082 : get? (x :: xs) (i + 1) = get? (x :: xs) (j + 1)\n\u22a2 i = j"}, {"tactic": "cases h\u2081 with\n| cons ha h\u2081 => exact ih (Nat.lt_of_succ_lt_succ h\u2080) h\u2081 h\u2082", "annotated_tactic": ["cases h\u2081 with\n      | <a>cons</a> ha h\u2081 => exact ih (<a>Nat.lt_of_succ_lt_succ</a> h\u2080) h\u2081 h\u2082", [{"full_name": "List.Pairwise.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1035, 5], "def_end_pos": [1035, 9]}, {"full_name": "Nat.lt_of_succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [289, 9], "def_end_pos": [289, 27]}]], "state_before": "\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni\u271d j\u271d : Nat\nh\u2081 : Nodup (x :: xs)\ni j : Nat\nh\u2080 : i + 1 < length (x :: xs)\nh\u2082 : get? (x :: xs) (i + 1) = get? (x :: xs) (j + 1)\n\u22a2 i = j", "state_after": "no goals"}, {"tactic": "exact ih (Nat.lt_of_succ_lt_succ h\u2080) h\u2081 h\u2082", "annotated_tactic": ["exact ih (<a>Nat.lt_of_succ_lt_succ</a> h\u2080) h\u2081 h\u2082", [{"full_name": "Nat.lt_of_succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [289, 9], "def_end_pos": [289, 27]}]], "state_before": "case cons\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni\u271d j\u271d i j : Nat\nh\u2080 : i + 1 < length (x :: xs)\nh\u2082 : get? (x :: xs) (i + 1) = get? (x :: xs) (j + 1)\nh\u2081 : Pairwise (fun x x_1 => x \u2260 x_1) xs\nha : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 i = j", "state_after": "no goals"}, {"tactic": "simp at h\u2082", "annotated_tactic": ["simp at h\u2082", []], "state_before": "case cons.refine_2\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d : Nat\nh\u2081 : Nodup (x :: xs)\nj : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : get? (x :: xs) 0 = get? (x :: xs) (j + 1)\n\u22a2 0 = j + 1", "state_after": "case cons.refine_2\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d : Nat\nh\u2081 : Nodup (x :: xs)\nj : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\n\u22a2 0 = j + 1"}, {"tactic": "cases h\u2081", "annotated_tactic": ["cases h\u2081", []], "state_before": "case cons.refine_2\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d : Nat\nh\u2081 : Nodup (x :: xs)\nj : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\n\u22a2 0 = j + 1", "state_after": "case cons.refine_2.cons\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\na\u271d\u00b9 : Pairwise (fun x x_1 => x \u2260 x_1) xs\na\u271d : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 0 = j + 1"}, {"tactic": "rename_i h' h", "annotated_tactic": ["rename_i h' h", []], "state_before": "case cons.refine_2.cons\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\na\u271d\u00b9 : Pairwise (fun x x_1 => x \u2260 x_1) xs\na\u271d : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 0 = j + 1", "state_after": "case cons.refine_2.cons\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 0 = j + 1"}, {"tactic": "have := h x ?_ rfl", "annotated_tactic": ["have := h x ?_ <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case cons.refine_2.cons\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 0 = j + 1", "state_after": "case cons.refine_2.cons.refine_2\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\nthis : False\n\u22a2 0 = j + 1\n\ncase cons.refine_2.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 x \u2208 xs"}, {"tactic": "cases this", "annotated_tactic": ["cases this", []], "state_before": "case cons.refine_2.cons.refine_2\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\nthis : False\n\u22a2 0 = j + 1\n\ncase cons.refine_2.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 x \u2208 xs", "state_after": "case cons.refine_2.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 x \u2208 xs"}, {"tactic": "rw [mem_iff_get?]", "annotated_tactic": ["rw [<a>mem_iff_get?</a>]", [{"full_name": "List.mem_iff_get?", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [744, 9], "def_end_pos": [744, 21]}]], "state_before": "case cons.refine_2.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 x \u2208 xs", "state_after": "case cons.refine_2.cons.refine_1\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\nxs : List \u03b1\u271d\nih : \u2200 {i j : Nat}, i < length xs \u2192 Nodup xs \u2192 get? xs i = get? xs j \u2192 i = j\ni j\u271d j : Nat\nh\u2080 : 0 < length (x :: xs)\nh\u2082 : some x = get? xs j\nh' : Pairwise (fun x x_1 => x \u2260 x_1) xs\nh : \u2200 (a' : \u03b1\u271d), a' \u2208 xs \u2192 x \u2260 a'\n\u22a2 \u2203 n, get? xs n = some x"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "LinearMap.tunnelAux_injective", "start": [924, 1], "end": [926, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/LocalExtr.lean", "full_name": "isLocalMaxOn_const", "start": [192, 1], "end": [193, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Finite.lean", "full_name": "Nat.card_le_card_of_surjective", "start": [89, 1], "end": [92, 66], "traced_tactics": [{"tactic": "have : lift.{u} #\u03b2 \u2264 lift.{v} #\u03b1 := mk_le_of_surjective (ULift.map_surjective.2 hf)", "annotated_tactic": ["have : <a>lift</a>.{u} #\u03b2 \u2264 <a>lift</a>.{v} #\u03b1 := <a>mk_le_of_surjective</a> (<a>ULift.map_surjective</a>.2 hf)", [{"full_name": "Cardinal.lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [189, 5], "def_end_pos": [189, 9]}, {"full_name": "Cardinal.lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [189, 5], "def_end_pos": [189, 9]}, {"full_name": "Cardinal.mk_le_of_surjective", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [278, 9], "def_end_pos": [278, 28]}, {"full_name": "ULift.map_surjective", "def_path": ".lake/packages/mathlib/Mathlib/Data/ULift.lean", "def_pos": [145, 15], "def_end_pos": [145, 29]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Finite \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\n\u22a2 Nat.card \u03b2 \u2264 Nat.card \u03b1", "state_after": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Finite \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nthis : lift.{u, v} #\u03b2 \u2264 lift.{v, u} #\u03b1\n\u22a2 Nat.card \u03b2 \u2264 Nat.card \u03b1"}, {"tactic": "simpa using toNat_le_toNat this (by simp [lt_aleph0_of_finite])", "annotated_tactic": ["simpa using <a>toNat_le_toNat</a> this (by simp [<a>lt_aleph0_of_finite</a>])", [{"full_name": "Cardinal.toNat_le_toNat", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/ToNat.lean", "def_pos": [91, 9], "def_end_pos": [91, 23]}, {"full_name": "Cardinal.lt_aleph0_of_finite", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1602, 9], "def_end_pos": [1602, 28]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Finite \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nthis : lift.{u, v} #\u03b2 \u2264 lift.{v, u} #\u03b1\n\u22a2 Nat.card \u03b2 \u2264 Nat.card \u03b1", "state_after": "no goals"}, {"tactic": "simp [lt_aleph0_of_finite]", "annotated_tactic": ["simp [<a>lt_aleph0_of_finite</a>]", [{"full_name": "Cardinal.lt_aleph0_of_finite", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1602, 9], "def_end_pos": [1602, 28]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Finite \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nthis : lift.{u, v} #\u03b2 \u2264 lift.{v, u} #\u03b1\n\u22a2 lift.{v, u} #\u03b1 < \u2135\u2080", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rel.lean", "full_name": "Rel.comp_right_bot", "start": [121, 1], "end": [123, 23], "traced_tactics": [{"tactic": "ext x y", "annotated_tactic": ["ext x y", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\n\u22a2 r \u2022 \u22a5 = \u22a5", "state_after": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\nx : \u03b1\ny : \u03b3\n\u22a2 (r \u2022 \u22a5) x y \u2194 \u22a5 x y"}, {"tactic": "simp [comp, Bot.bot]", "annotated_tactic": ["simp [<a>comp</a>, <a>Bot.bot</a>]", [{"full_name": "Rel.comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rel.lean", "def_pos": [92, 5], "def_end_pos": [92, 9]}, {"full_name": "Bot.bot", "def_path": ".lake/packages/mathlib/Mathlib/Order/Notation.lean", "def_pos": [107, 3], "def_end_pos": [107, 6]}]], "state_before": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\nx : \u03b1\ny : \u03b3\n\u22a2 (r \u2022 \u22a5) x y \u2194 \u22a5 x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "Ideal.quotientEquiv_symm_mk", "start": [518, 1], "end": [521, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounded.lean", "full_name": "Set.unbounded_ge_inter_gt", "start": [408, 1], "end": [410, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.inf_of_mem", "start": [980, 1], "end": [982, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.val_neg_of_ne_zero", "start": [994, 1], "end": [995, 61], "traced_tactics": [{"tactic": "simp_all [neg_val a, na.out]", "annotated_tactic": ["simp_all [<a>neg_val</a> a, na.out]", [{"full_name": "ZMod.neg_val", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [984, 9], "def_end_pos": [984, 16]}]], "state_before": "n : \u2115\nnz : NeZero n\na : ZMod n\nna : NeZero a\n\u22a2 val (-a) = n - val a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometryEquiv.continuous", "start": [687, 11], "end": [688, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.re_eq_self_of_le", "start": [781, 1], "end": [782, 60], "traced_tactics": [{"tactic": "rw [\u2190 conj_eq_iff_re, conj_eq_iff_im, im_eq_zero_of_le h]", "annotated_tactic": ["rw [\u2190 <a>conj_eq_iff_re</a>, <a>conj_eq_iff_im</a>, <a>im_eq_zero_of_le</a> h]", [{"full_name": "IsROrC.conj_eq_iff_re", "def_path": ".lake/packages/mathlib/Mathlib/Data/IsROrC/Basic.lean", "def_pos": [439, 9], "def_end_pos": [439, 23]}, {"full_name": "IsROrC.conj_eq_iff_im", "def_path": ".lake/packages/mathlib/Mathlib/Data/IsROrC/Basic.lean", "def_pos": [443, 9], "def_end_pos": [443, 23]}, {"full_name": "IsROrC.im_eq_zero_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/IsROrC/Basic.lean", "def_pos": [776, 9], "def_end_pos": [776, 25]}]], "state_before": "K : Type u_1\nE : Type u_2\ninst\u271d : IsROrC K\nz a : K\nh : \u2016a\u2016 \u2264 re a\n\u22a2 \u2191(re a) = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.prod_filter_index", "start": [936, 1], "end": [941, 35], "traced_tactics": [{"tactic": "classical\n  refine' Finset.prod_congr rfl fun x hx => _\n  rw [support_filter, Finset.mem_filter] at hx\n  rw [filter_apply_pos _ _ hx.2]", "annotated_tactic": ["classical\n    refine' <a>Finset.prod_congr</a> <a>rfl</a> fun x hx => _\n    rw [<a>support_filter</a>, <a>Finset.mem_filter</a>] at hx\n    rw [<a>filter_apply_pos</a> _ _ hx.2]", [{"full_name": "Finset.prod_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 9], "def_end_pos": [382, 19]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Finsupp.support_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [917, 9], "def_end_pos": [917, 23]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "Finsupp.filter_apply_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [909, 9], "def_end_pos": [909, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : Zero M\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nf : \u03b1 \u2192\u2080 M\ninst\u271d : CommMonoid N\ng : \u03b1 \u2192 M \u2192 N\n\u22a2 prod (filter p f) g = \u220f x in (filter p f).support, g x (f x)", "state_after": "no goals"}, {"tactic": "refine' Finset.prod_congr rfl fun x hx => _", "annotated_tactic": ["refine' <a>Finset.prod_congr</a> <a>rfl</a> fun x hx => _", [{"full_name": "Finset.prod_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 9], "def_end_pos": [382, 19]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : Zero M\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nf : \u03b1 \u2192\u2080 M\ninst\u271d : CommMonoid N\ng : \u03b1 \u2192 M \u2192 N\n\u22a2 prod (filter p f) g = \u220f x in (filter p f).support, g x (f x)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : Zero M\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nf : \u03b1 \u2192\u2080 M\ninst\u271d : CommMonoid N\ng : \u03b1 \u2192 M \u2192 N\nx : \u03b1\nhx : x \u2208 (filter p f).support\n\u22a2 g x ((filter p f) x) = g x (f x)"}, {"tactic": "rw [support_filter, Finset.mem_filter] at hx", "annotated_tactic": ["rw [<a>support_filter</a>, <a>Finset.mem_filter</a>] at hx", [{"full_name": "Finsupp.support_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [917, 9], "def_end_pos": [917, 23]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : Zero M\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nf : \u03b1 \u2192\u2080 M\ninst\u271d : CommMonoid N\ng : \u03b1 \u2192 M \u2192 N\nx : \u03b1\nhx : x \u2208 (filter p f).support\n\u22a2 g x ((filter p f) x) = g x (f x)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : Zero M\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nf : \u03b1 \u2192\u2080 M\ninst\u271d : CommMonoid N\ng : \u03b1 \u2192 M \u2192 N\nx : \u03b1\nhx : x \u2208 f.support \u2227 p x\n\u22a2 g x ((filter p f) x) = g x (f x)"}, {"tactic": "rw [filter_apply_pos _ _ hx.2]", "annotated_tactic": ["rw [<a>filter_apply_pos</a> _ _ hx.2]", [{"full_name": "Finsupp.filter_apply_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [909, 9], "def_end_pos": [909, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : Zero M\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nf : \u03b1 \u2192\u2080 M\ninst\u271d : CommMonoid N\ng : \u03b1 \u2192 M \u2192 N\nx : \u03b1\nhx : x \u2208 f.support \u2227 p x\n\u22a2 g x ((filter p f) x) = g x (f x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "normal_exists_closure_subset", "start": [2076, 1], "end": [2083, 49], "traced_tactics": [{"tactic": "have : Disjoint s t\u1d9c := Set.disjoint_left.mpr fun x hxs hxt => hxt (hst hxs)", "annotated_tactic": ["have : <a>Disjoint</a> s t\u1d9c := Set.disjoint_left.mpr fun x hxs hxt => hxt (hst hxs)", [{"full_name": "Disjoint", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [42, 5], "def_end_pos": [42, 13]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsOpen t\nhst : s \u2286 t\n\u22a2 \u2203 u, IsOpen u \u2227 s \u2286 u \u2227 closure u \u2286 t", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsOpen t\nhst : s \u2286 t\nthis : Disjoint s t\u1d9c\n\u22a2 \u2203 u, IsOpen u \u2227 s \u2286 u \u2227 closure u \u2286 t"}, {"tactic": "rcases normal_separation hs (isClosed_compl_iff.2 ht) this with\n  \u27e8s', t', hs', ht', hss', htt', hs't'\u27e9", "annotated_tactic": ["rcases <a>normal_separation</a> hs (<a>isClosed_compl_iff</a>.2 ht) this with\n    \u27e8s', t', hs', ht', hss', htt', hs't'\u27e9", [{"full_name": "normal_separation", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [2067, 9], "def_end_pos": [2067, 26]}, {"full_name": "isClosed_compl_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [199, 9], "def_end_pos": [199, 27]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsOpen t\nhst : s \u2286 t\nthis : Disjoint s t\u1d9c\n\u22a2 \u2203 u, IsOpen u \u2227 s \u2286 u \u2227 closure u \u2286 t", "state_after": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsOpen t\nhst : s \u2286 t\nthis : Disjoint s t\u1d9c\ns' t' : Set X\nhs' : IsOpen s'\nht' : IsOpen t'\nhss' : s \u2286 s'\nhtt' : t\u1d9c \u2286 t'\nhs't' : Disjoint s' t'\n\u22a2 \u2203 u, IsOpen u \u2227 s \u2286 u \u2227 closure u \u2286 t"}, {"tactic": "refine \u27e8s', hs', hss', Subset.trans (closure_minimal ?_ (isClosed_compl_iff.2 ht'))\n  (compl_subset_comm.1 htt')\u27e9", "annotated_tactic": ["refine \u27e8s', hs', hss', <a>Subset.trans</a> (<a>closure_minimal</a> ?_ (<a>isClosed_compl_iff</a>.2 ht'))\n    (<a>compl_subset_comm</a>.1 htt')\u27e9", [{"full_name": "Set.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [343, 9], "def_end_pos": [343, 21]}, {"full_name": "closure_minimal", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [404, 9], "def_end_pos": [404, 24]}, {"full_name": "isClosed_compl_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [199, 9], "def_end_pos": [199, 27]}, {"full_name": "Set.compl_subset_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1728, 9], "def_end_pos": [1728, 26]}]], "state_before": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsOpen t\nhst : s \u2286 t\nthis : Disjoint s t\u1d9c\ns' t' : Set X\nhs' : IsOpen s'\nht' : IsOpen t'\nhss' : s \u2286 s'\nhtt' : t\u1d9c \u2286 t'\nhs't' : Disjoint s' t'\n\u22a2 \u2203 u, IsOpen u \u2227 s \u2286 u \u2227 closure u \u2286 t", "state_after": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsOpen t\nhst : s \u2286 t\nthis : Disjoint s t\u1d9c\ns' t' : Set X\nhs' : IsOpen s'\nht' : IsOpen t'\nhss' : s \u2286 s'\nhtt' : t\u1d9c \u2286 t'\nhs't' : Disjoint s' t'\n\u22a2 s' \u2286 t'\u1d9c"}, {"tactic": "exact fun x hxs hxt => hs't'.le_bot \u27e8hxs, hxt\u27e9", "annotated_tactic": ["exact fun x hxs hxt => hs't'.le_bot \u27e8hxs, hxt\u27e9", []], "state_before": "case intro.intro.intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsOpen t\nhst : s \u2286 t\nthis : Disjoint s t\u1d9c\ns' t' : Set X\nhs' : IsOpen s'\nht' : IsOpen t'\nhss' : s \u2286 s'\nhtt' : t\u1d9c \u2286 t'\nhs't' : Disjoint s' t'\n\u22a2 s' \u2286 t'\u1d9c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Basic.lean", "full_name": "Complex.star_def", "start": [597, 1], "end": [598, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "full_name": "AffineEquiv.coe_linear", "start": [131, 1], "end": [132, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Cauchy.lean", "full_name": "Filter.Tendsto.cauchy_map", "start": [96, 1], "end": [98, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Dirac.lean", "full_name": "MeasureTheory.Measure.map_eq_sum", "start": [87, 1], "end": [92, 91], "traced_tactics": [{"tactic": "ext s", "annotated_tactic": ["ext s", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns : Set \u03b1\na : \u03b1\ninst\u271d\u00b9 : Countable \u03b2\ninst\u271d : MeasurableSingletonClass \u03b2\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\n\u22a2 map f \u03bc = sum fun b => \u2191\u2191\u03bc (f \u207b\u00b9' {b}) \u2022 dirac b", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ninst\u271d\u00b9 : Countable \u03b2\ninst\u271d : MeasurableSingletonClass \u03b2\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\ns : Set \u03b2\na\u271d : MeasurableSet s\n\u22a2 \u2191\u2191(map f \u03bc) s = \u2191\u2191(sum fun b => \u2191\u2191\u03bc (f \u207b\u00b9' {b}) \u2022 dirac b) s"}, {"tactic": "have : \u2200 y \u2208 s, MeasurableSet (f \u207b\u00b9' {y}) := fun y _ => hf (measurableSet_singleton _)", "annotated_tactic": ["have : \u2200 y \u2208 s, <a>MeasurableSet</a> (f \u207b\u00b9' {y}) := fun y _ => hf (<a>measurableSet_singleton</a> _)", [{"full_name": "MeasurableSet", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [63, 5], "def_end_pos": [63, 18]}, {"full_name": "MeasurableSingletonClass.measurableSet_singleton", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [278, 3], "def_end_pos": [278, 26]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ninst\u271d\u00b9 : Countable \u03b2\ninst\u271d : MeasurableSingletonClass \u03b2\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\ns : Set \u03b2\na\u271d : MeasurableSet s\n\u22a2 \u2191\u2191(map f \u03bc) s = \u2191\u2191(sum fun b => \u2191\u2191\u03bc (f \u207b\u00b9' {b}) \u2022 dirac b) s", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ninst\u271d\u00b9 : Countable \u03b2\ninst\u271d : MeasurableSingletonClass \u03b2\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\ns : Set \u03b2\na\u271d : MeasurableSet s\nthis : \u2200 y \u2208 s, MeasurableSet (f \u207b\u00b9' {y})\n\u22a2 \u2191\u2191(map f \u03bc) s = \u2191\u2191(sum fun b => \u2191\u2191\u03bc (f \u207b\u00b9' {b}) \u2022 dirac b) s"}, {"tactic": "simp [\u2190 tsum_measure_preimage_singleton (to_countable s) this, *,\n  tsum_subtype s fun b => \u03bc (f \u207b\u00b9' {b}), \u2190 indicator_mul_right s fun b => \u03bc (f \u207b\u00b9' {b})]", "annotated_tactic": ["simp [\u2190 <a>tsum_measure_preimage_singleton</a> (<a>to_countable</a> s) this, *,\n    <a>tsum_subtype</a> s fun b => \u03bc (f \u207b\u00b9' {b}), \u2190 <a>indicator_mul_right</a> s fun b => \u03bc (f \u207b\u00b9' {b})]", [{"full_name": "MeasureTheory.tsum_measure_preimage_singleton", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "def_pos": [212, 9], "def_end_pos": [212, 40]}, {"full_name": "Set.to_countable", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [53, 9], "def_end_pos": [53, 21]}, {"full_name": "tsum_subtype", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "def_pos": [424, 9], "def_end_pos": [424, 21]}, {"full_name": "Set.indicator_mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [567, 9], "def_end_pos": [567, 28]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ninst\u271d\u00b9 : Countable \u03b2\ninst\u271d : MeasurableSingletonClass \u03b2\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\ns : Set \u03b2\na\u271d : MeasurableSet s\nthis : \u2200 y \u2208 s, MeasurableSet (f \u207b\u00b9' {y})\n\u22a2 \u2191\u2191(map f \u03bc) s = \u2191\u2191(sum fun b => \u2191\u2191\u03bc (f \u207b\u00b9' {b}) \u2022 dirac b) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Basic.lean", "full_name": "HahnSeries.support_nonempty_iff", "start": [115, 8], "end": [116, 68], "traced_tactics": [{"tactic": "rw [support, support_nonempty_iff, Ne.def, coeff_fun_eq_zero_iff]", "annotated_tactic": ["rw [<a>support</a>, <a>support_nonempty_iff</a>, <a>Ne.def</a>, <a>coeff_fun_eq_zero_iff</a>]", [{"full_name": "HahnSeries.support", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Basic.lean", "def_pos": [66, 12], "def_end_pos": [66, 19]}, {"full_name": "Function.support_nonempty_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Support.lean", "def_pos": [123, 3], "def_end_pos": [123, 14]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "HahnSeries.coeff_fun_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Basic.lean", "def_pos": [101, 9], "def_end_pos": [101, 30]}]], "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : Zero R\nx : HahnSeries \u0393 R\n\u22a2 Set.Nonempty (support x) \u2194 x \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/StructuredArrow.lean", "full_name": "CategoryTheory.CostructuredArrow.epi_of_epi_left", "start": [531, 1], "end": [532, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "Substring.ValidFor.front", "start": [895, 1], "end": [896, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Trace.lean", "full_name": "Algebra.traceMatrix_reindex", "start": [467, 1], "end": [468, 86], "traced_tactics": [{"tactic": "ext (x y)", "annotated_tactic": ["ext (x y)", []], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : CommRing S\ninst\u271d\u00b9\u2076 : CommRing T\ninst\u271d\u00b9\u2075 : Algebra R S\ninst\u271d\u00b9\u2074 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u00b9\u2070 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2079 : Field F\ninst\u271d\u2078 : Algebra R L\ninst\u271d\u2077 : Algebra L F\ninst\u271d\u2076 : Algebra R F\ninst\u271d\u2075 : IsScalarTower R L F\nA : Type u\nB : Type v\nC : Type z\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : CommRing C\ninst\u271d : Algebra A C\n\u03ba' : Type u_7\nb : Basis \u03ba A B\nf : \u03ba \u2243 \u03ba'\n\u22a2 traceMatrix A \u21d1(Basis.reindex b f) = (reindex f f) (traceMatrix A \u21d1b)", "state_after": "case a.h\nR : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : CommRing S\ninst\u271d\u00b9\u2076 : CommRing T\ninst\u271d\u00b9\u2075 : Algebra R S\ninst\u271d\u00b9\u2074 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u00b9\u2070 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2079 : Field F\ninst\u271d\u2078 : Algebra R L\ninst\u271d\u2077 : Algebra L F\ninst\u271d\u2076 : Algebra R F\ninst\u271d\u2075 : IsScalarTower R L F\nA : Type u\nB : Type v\nC : Type z\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : CommRing C\ninst\u271d : Algebra A C\n\u03ba' : Type u_7\nb : Basis \u03ba A B\nf : \u03ba \u2243 \u03ba'\nx y : \u03ba'\n\u22a2 traceMatrix A (\u21d1(Basis.reindex b f)) x y = (reindex f f) (traceMatrix A \u21d1b) x y"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a.h\nR : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : CommRing S\ninst\u271d\u00b9\u2076 : CommRing T\ninst\u271d\u00b9\u2075 : Algebra R S\ninst\u271d\u00b9\u2074 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u00b9\u2070 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u2079 : Field F\ninst\u271d\u2078 : Algebra R L\ninst\u271d\u2077 : Algebra L F\ninst\u271d\u2076 : Algebra R F\ninst\u271d\u2075 : IsScalarTower R L F\nA : Type u\nB : Type v\nC : Type z\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : CommRing C\ninst\u271d : Algebra A C\n\u03ba' : Type u_7\nb : Basis \u03ba A B\nf : \u03ba \u2243 \u03ba'\nx y : \u03ba'\n\u22a2 traceMatrix A (\u21d1(Basis.reindex b f)) x y = (reindex f f) (traceMatrix A \u21d1b) x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsCoprime.of_isCoprime_of_dvd_right", "start": [174, 1], "end": [175, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Nilpotent.lean", "full_name": "nilpotencyClass_zero", "start": [192, 1], "end": [194, 61], "traced_tactics": [{"tactic": "constructor <;> simp", "annotated_tactic": ["constructor <;> simp", []], "state_before": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d\u00b9 : MonoidWithZero R\ninst\u271d : Nontrivial R\n\u22a2 0 ^ (0 + 1) = 0 \u2227 0 ^ 0 \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.mem_graph", "start": [781, 1], "end": [781, 88], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nx : \u21a5f.domain\n\u22a2 (\u2191x, \u2191f x) \u2208 graph f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Regular/Basic.lean", "full_name": "mul_isLeftRegular_iff", "start": [138, 1], "end": [140, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Ultrafilter.lean", "full_name": "Ultrafilter.nonempty_of_mem", "start": [157, 1], "end": [158, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "Measurable.imp", "start": [1185, 1], "end": [1186, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearEquiv.funCongrLeft_apply", "start": [1206, 1], "end": [1207, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/Inv.lean", "full_name": "Mathlib.Meta.NormNum.isNat_ratCast", "start": [73, 1], "end": [75, 29], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\ninst\u271d : DivisionRing R\nn\u271d : \u2115\n\u22a2 \u2191\u2191n\u271d = \u2191n\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.liftAddHom_comp_single", "start": [2072, 1], "end": [2073, 79], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d : AddCommMonoid \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\ni : \u03b9\n\u22a2 AddMonoidHom.comp (liftAddHom f) (singleAddHom \u03b2 i) = f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "StrictAnti.antitone", "start": [504, 11], "end": [505, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Closure.lean", "full_name": "ClosureOperator.closure_min", "start": [196, 1], "end": [196, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "isGLB_pair", "start": [1019, 1], "end": [1020, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Torsion.lean", "full_name": "IsTorsion.subgroup", "start": [89, 1], "end": [90, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Integral.lean", "full_name": "is_integral_localization_at_leadingCoeff", "start": [206, 1], "end": [215, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeGroup/Basic.lean", "full_name": "FreeGroup.toWord_injective", "start": [1289, 1], "end": [1290, 39], "traced_tactics": [{"tactic": "rintro \u27e8L\u2081\u27e9 \u27e8L\u2082\u27e9", "annotated_tactic": ["rintro \u27e8L\u2081\u27e9 \u27e8L\u2082\u27e9", []], "state_before": "\u03b1 : Type u\nL L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)\ninst\u271d : DecidableEq \u03b1\n\u22a2 Function.Injective toWord", "state_after": "case mk.mk\n\u03b1 : Type u\nL L\u2081\u271d L\u2082\u271d L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)\ninst\u271d : DecidableEq \u03b1\na\u2081\u271d : FreeGroup \u03b1\nL\u2081 : List (\u03b1 \u00d7 Bool)\na\u2082\u271d : FreeGroup \u03b1\nL\u2082 : List (\u03b1 \u00d7 Bool)\n\u22a2 toWord (Quot.mk Red.Step L\u2081) = toWord (Quot.mk Red.Step L\u2082) \u2192 Quot.mk Red.Step L\u2081 = Quot.mk Red.Step L\u2082"}, {"tactic": "exact reduce.exact", "annotated_tactic": ["exact <a>reduce.exact</a>", [{"full_name": "FreeGroup.reduce.exact", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/FreeGroup/Basic.lean", "def_pos": [1253, 9], "def_end_pos": [1253, 21]}]], "state_before": "case mk.mk\n\u03b1 : Type u\nL L\u2081\u271d L\u2082\u271d L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)\ninst\u271d : DecidableEq \u03b1\na\u2081\u271d : FreeGroup \u03b1\nL\u2081 : List (\u03b1 \u00d7 Bool)\na\u2082\u271d : FreeGroup \u03b1\nL\u2082 : List (\u03b1 \u00d7 Bool)\n\u22a2 toWord (Quot.mk Red.Step L\u2081) = toWord (Quot.mk Red.Step L\u2082) \u2192 Quot.mk Red.Step L\u2081 = Quot.mk Red.Step L\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.pure_sets", "start": [2136, 1], "end": [2137, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "full_name": "HasFDerivWithinAt.isBigO_sub", "start": [753, 8], "end": [755, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.cos_sq_le_one", "start": [936, 1], "end": [937, 72], "traced_tactics": [{"tactic": "rw [\u2190 sin_sq_add_cos_sq x]", "annotated_tactic": ["rw [\u2190 <a>sin_sq_add_cos_sq</a> x]", [{"full_name": "Real.sin_sq_add_cos_sq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [924, 16], "def_end_pos": [924, 33]}]], "state_before": "x y : \u211d\n\u22a2 cos x ^ 2 \u2264 1", "state_after": "x y : \u211d\n\u22a2 cos x ^ 2 \u2264 sin x ^ 2 + cos x ^ 2"}, {"tactic": "exact le_add_of_nonneg_left (sq_nonneg _)", "annotated_tactic": ["exact <a>le_add_of_nonneg_left</a> (<a>sq_nonneg</a> _)", [{"full_name": "le_add_of_nonneg_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [409, 15], "def_end_pos": [409, 36]}, {"full_name": "sq_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [1206, 7], "def_end_pos": [1206, 16]}]], "state_before": "x y : \u211d\n\u22a2 cos x ^ 2 \u2264 sin x ^ 2 + cos x ^ 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/EpiMono.lean", "full_name": "CategoryTheory.isSplitMono_of_mono", "start": [238, 1], "end": [239, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "full_name": "Ordinal.relIso_enum'", "start": [549, 1], "end": [553, 62], "traced_tactics": [{"tactic": "refine' inductionOn o _", "annotated_tactic": ["refine' <a>inductionOn</a> o _", [{"full_name": "Ordinal.inductionOn", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [312, 9], "def_end_pos": [312, 20]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3 : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u2243r s\no : Ordinal.{u}\n\u22a2 \u2200 (hr : o < type r) (hs : o < type s), f (enum r o hr) = enum s o hs", "state_after": "\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3 : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u2243r s\no : Ordinal.{u}\n\u22a2 \u2200 (\u03b1_1 : Type u) (r_1 : \u03b1_1 \u2192 \u03b1_1 \u2192 Prop) [inst : IsWellOrder \u03b1_1 r_1] (hr : type r_1 < type r)\n    (hs : type r_1 < type s), f (enum r (type r_1) hr) = enum s (type r_1) hs"}, {"tactic": "rintro \u03b3 t wo \u27e8g\u27e9 \u27e8h\u27e9", "annotated_tactic": ["rintro \u03b3 t wo \u27e8g\u27e9 \u27e8h\u27e9", []], "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3 : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u2243r s\no : Ordinal.{u}\n\u22a2 \u2200 (\u03b1_1 : Type u) (r_1 : \u03b1_1 \u2192 \u03b1_1 \u2192 Prop) [inst : IsWellOrder \u03b1_1 r_1] (hr : type r_1 < type r)\n    (hs : type r_1 < type s), f (enum r (type r_1) hr) = enum s (type r_1) hs", "state_after": "case intro.intro\n\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3\u271d : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt\u271d : \u03b3\u271d \u2192 \u03b3\u271d \u2192 Prop\n\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u2243r s\no : Ordinal.{u}\n\u03b3 : Type u\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nwo : IsWellOrder \u03b3 t\ng : t \u227ai r\nh : t \u227ai s\n\u22a2 f (enum r (type t) \u22ef) = enum s (type t) \u22ef"}, {"tactic": "rw [enum_type g, enum_type (PrincipalSeg.ltEquiv g f)]", "annotated_tactic": ["rw [<a>enum_type</a> g, <a>enum_type</a> (<a>PrincipalSeg.ltEquiv</a> g f)]", [{"full_name": "Ordinal.enum_type", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [533, 9], "def_end_pos": [533, 18]}, {"full_name": "Ordinal.enum_type", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [533, 9], "def_end_pos": [533, 18]}, {"full_name": "PrincipalSeg.ltEquiv", "def_path": ".lake/packages/mathlib/Mathlib/Order/InitialSeg.lean", "def_pos": [341, 5], "def_end_pos": [341, 12]}]], "state_before": "case intro.intro\n\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3\u271d : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt\u271d : \u03b3\u271d \u2192 \u03b3\u271d \u2192 Prop\n\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u2243r s\no : Ordinal.{u}\n\u03b3 : Type u\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nwo : IsWellOrder \u03b3 t\ng : t \u227ai r\nh : t \u227ai s\n\u22a2 f (enum r (type t) \u22ef) = enum s (type t) \u22ef", "state_after": "case intro.intro\n\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3\u271d : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt\u271d : \u03b3\u271d \u2192 \u03b3\u271d \u2192 Prop\n\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u2243r s\no : Ordinal.{u}\n\u03b3 : Type u\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nwo : IsWellOrder \u03b3 t\ng : t \u227ai r\nh : t \u227ai s\n\u22a2 f g.top = (PrincipalSeg.ltEquiv g f).top"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case intro.intro\n\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3\u271d : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt\u271d : \u03b3\u271d \u2192 \u03b3\u271d \u2192 Prop\n\u03b1 \u03b2 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u2243r s\no : Ordinal.{u}\n\u03b3 : Type u\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nwo : IsWellOrder \u03b3 t\ng : t \u227ai r\nh : t \u227ai s\n\u22a2 f g.top = (PrincipalSeg.ltEquiv g f).top", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.coe_sSup_eq'", "start": [578, 11], "end": [580, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.toList_singleton", "start": [3597, 1], "end": [3598, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.ssubset_cons", "start": [935, 1], "end": [936, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/EraseLead.lean", "full_name": "Polynomial.eraseLead_natDegree_lt", "start": [211, 1], "end": [214, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "List.prev_reverse_eq_next", "start": [400, 1], "end": [415, 12], "traced_tactics": [{"tactic": "obtain \u27e8k, hk, rfl\u27e9 := nthLe_of_mem hx", "annotated_tactic": ["obtain \u27e8k, hk, rfl\u27e9 := <a>nthLe_of_mem</a> hx", [{"full_name": "List.nthLe_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1196, 9], "def_end_pos": [1196, 21]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d : \u03b1\nl : List \u03b1\nh : Nodup l\nx : \u03b1\nhx : x \u2208 l\n\u22a2 prev (reverse l) x \u22ef = next l x hx", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\n\u22a2 prev (reverse l) (nthLe l k hk) \u22ef = next l (nthLe l k hk) hx"}, {"tactic": "have lpos : 0 < l.length := k.zero_le.trans_lt hk", "annotated_tactic": ["have lpos : 0 < l.length := k.zero_le.trans_lt hk", []], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\n\u22a2 prev (reverse l) (nthLe l k hk) \u22ef = next l (nthLe l k hk) hx", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\n\u22a2 prev (reverse l) (nthLe l k hk) \u22ef = next l (nthLe l k hk) hx"}, {"tactic": "have key : l.length - 1 - k < l.length :=\n  (Nat.sub_le _ _).trans_lt (tsub_lt_self lpos Nat.succ_pos')", "annotated_tactic": ["have key : l.length - 1 - k < l.length :=\n    (<a>Nat.sub_le</a> _ _).<a>trans_lt</a> (<a>tsub_lt_self</a> lpos <a>Nat.succ_pos'</a>)", [{"full_name": "Nat.sub_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 15]}, {"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}, {"full_name": "tsub_lt_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [482, 9], "def_end_pos": [482, 21]}, {"full_name": "Nat.succ_pos'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [48, 7], "def_end_pos": [48, 16]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\n\u22a2 prev (reverse l) (nthLe l k hk) \u22ef = next l (nthLe l k hk) hx", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 prev (reverse l) (nthLe l k hk) \u22ef = next l (nthLe l k hk) hx"}, {"tactic": "rw [\u2190 nthLe_pmap l.next (fun _ h => h) (by simpa using hk)]", "annotated_tactic": ["rw [\u2190 <a>nthLe_pmap</a> l.next (fun _ h => h) (by simpa using hk)]", [{"full_name": "List.nthLe_pmap", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [3173, 9], "def_end_pos": [3173, 19]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 prev (reverse l) (nthLe l k hk) \u22ef = next l (nthLe l k hk) hx", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 prev (reverse l) (nthLe l k hk) \u22ef = nthLe (pmap (next l) l \u22ef) k \u22ef"}, {"tactic": "simp_rw [\u2190 nthLe_reverse l k (key.trans_le (by simp)), pmap_next_eq_rotate_one _ h]", "annotated_tactic": ["simp_rw [\u2190 <a>nthLe_reverse</a> l k (key.trans_le (by simp)), <a>pmap_next_eq_rotate_one</a> _ h]", [{"full_name": "List.nthLe_reverse", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1419, 9], "def_end_pos": [1419, 22]}, {"full_name": "List.pmap_next_eq_rotate_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [357, 9], "def_end_pos": [357, 32]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 prev (reverse l) (nthLe l k hk) \u22ef = nthLe (pmap (next l) l \u22ef) k \u22ef", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 prev (reverse l) (nthLe (reverse l) (length l - 1 - k) \u22ef) \u22ef = nthLe (rotate l 1) k \u22ef"}, {"tactic": "rw [\u2190 nthLe_pmap l.reverse.prev fun _ h => h]", "annotated_tactic": ["rw [\u2190 <a>nthLe_pmap</a> l.reverse.prev fun _ h => h]", [{"full_name": "List.nthLe_pmap", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [3173, 9], "def_end_pos": [3173, 19]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 prev (reverse l) (nthLe (reverse l) (length l - 1 - k) \u22ef) \u22ef = nthLe (rotate l 1) k \u22ef", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 nthLe (pmap (prev (reverse l)) (reverse l) \u22ef) (length l - 1 - k) ?intro.intro = nthLe (rotate l 1) k \u22ef\n\ncase intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 length l - 1 - k < length (pmap (prev (reverse l)) (reverse l) \u22ef)"}, {"tactic": "simpa using hk", "annotated_tactic": ["simpa using hk", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 k < length (pmap (next l) l \u22ef)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 length l \u2264 length (reverse l)", "state_after": "no goals"}, {"tactic": "simp_rw [pmap_prev_eq_rotate_length_sub_one _ (nodup_reverse.mpr h), rotate_reverse,\n  length_reverse, Nat.mod_eq_of_lt (tsub_lt_self lpos Nat.succ_pos'),\n  tsub_tsub_cancel_of_le (Nat.succ_le_of_lt lpos)]", "annotated_tactic": ["simp_rw [<a>pmap_prev_eq_rotate_length_sub_one</a> _ (nodup_reverse.mpr h), <a>rotate_reverse</a>,\n      <a>length_reverse</a>, <a>Nat.mod_eq_of_lt</a> (<a>tsub_lt_self</a> lpos <a>Nat.succ_pos'</a>),\n      <a>tsub_tsub_cancel_of_le</a> (<a>Nat.succ_le_of_lt</a> lpos)]", [{"full_name": "List.pmap_prev_eq_rotate_length_sub_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [365, 9], "def_end_pos": [365, 43]}, {"full_name": "List.rotate_reverse", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [368, 9], "def_end_pos": [368, 23]}, {"full_name": "List.length_reverse", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [867, 17], "def_end_pos": [867, 31]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}, {"full_name": "tsub_lt_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [482, 9], "def_end_pos": [482, 21]}, {"full_name": "Nat.succ_pos'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [48, 7], "def_end_pos": [48, 16]}, {"full_name": "tsub_tsub_cancel_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [295, 9], "def_end_pos": [295, 31]}, {"full_name": "Nat.succ_le_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [292, 9], "def_end_pos": [292, 22]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 nthLe (pmap (prev (reverse l)) (reverse l) \u22ef) (length l - 1 - k) ?intro.intro = nthLe (rotate l 1) k \u22ef", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 nthLe (reverse (rotate l (Nat.succ 0))) (length l - 1 - k) \u22ef = nthLe (rotate l 1) k \u22ef"}, {"tactic": "rw [\u2190 nthLe_reverse]", "annotated_tactic": ["rw [\u2190 <a>nthLe_reverse</a>]", [{"full_name": "List.nthLe_reverse", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1419, 9], "def_end_pos": [1419, 22]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 nthLe (reverse (rotate l (Nat.succ 0))) (length l - 1 - k) \u22ef = nthLe (rotate l 1) k \u22ef", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 nthLe (reverse (reverse (rotate l (Nat.succ 0)))) (length (reverse (rotate l (Nat.succ 0))) - 1 - (length l - 1 - k))\n      ?intro.intro.h1 =\n    nthLe (rotate l 1) k \u22ef\n\ncase intro.intro.h1\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 length (reverse (rotate l (Nat.succ 0))) - 1 - (length l - 1 - k) < length (reverse (reverse (rotate l (Nat.succ 0))))\n\ncase intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 length l - 1 - k < length (pmap (prev (reverse l)) (reverse l) \u22ef)"}, {"tactic": "simp [tsub_tsub_cancel_of_le (Nat.le_sub_one_of_lt hk)]", "annotated_tactic": ["simp [<a>tsub_tsub_cancel_of_le</a> (<a>Nat.le_sub_one_of_lt</a> hk)]", [{"full_name": "tsub_tsub_cancel_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [295, 9], "def_end_pos": [295, 31]}, {"full_name": "Nat.le_sub_one_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [312, 9], "def_end_pos": [312, 25]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 nthLe (reverse (reverse (rotate l (Nat.succ 0)))) (length (reverse (rotate l (Nat.succ 0))) - 1 - (length l - 1 - k))\n      ?intro.intro.h1 =\n    nthLe (rotate l 1) k \u22ef", "state_after": "no goals"}, {"tactic": "simpa using (Nat.sub_le _ _).trans_lt (tsub_lt_self lpos Nat.succ_pos')", "annotated_tactic": ["simpa using (<a>Nat.sub_le</a> _ _).<a>trans_lt</a> (<a>tsub_lt_self</a> lpos <a>Nat.succ_pos'</a>)", [{"full_name": "Nat.sub_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 15]}, {"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}, {"full_name": "tsub_lt_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [482, 9], "def_end_pos": [482, 21]}, {"full_name": "Nat.succ_pos'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [48, 7], "def_end_pos": [48, 16]}]], "state_before": "case intro.intro.h1\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 length (reverse (rotate l (Nat.succ 0))) - 1 - (length l - 1 - k) < length (reverse (reverse (rotate l (Nat.succ 0))))", "state_after": "no goals"}, {"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx : \u03b1\nl : List \u03b1\nh : Nodup l\nk : \u2115\nhk : k < length l\nhx : nthLe l k hk \u2208 l\nlpos : 0 < length l\nkey : length l - 1 - k < length l\n\u22a2 length l - 1 - k < length (pmap (prev (reverse l)) (reverse l) \u22ef)", "state_after": "no goals"}]}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "mathd_algebra_151", "start": [451, 1], "end": [452, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "\u22a2 \u2308Real.sqrt 27\u2309 - \u230aReal.sqrt 26\u230b = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/UniformConvergence.lean", "full_name": "UniformOnFun.toFun_mul", "start": [80, 1], "end": [83, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Units.lean", "full_name": "Int.eq_one_or_neg_one_of_mul_eq_neg_one'", "start": [80, 1], "end": [84, 55], "traced_tactics": [{"tactic": "rcases isUnit_eq_one_or (IsUnit.mul_iff.mp (Int.isUnit_iff.mpr (Or.inr h))).1 with (rfl | rfl)", "annotated_tactic": ["rcases <a>isUnit_eq_one_or</a> (IsUnit.mul_iff.mp (Int.isUnit_iff.mpr (<a>Or.inr</a> h))).1 with (rfl | rfl)", [{"full_name": "Int.isUnit_eq_one_or", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Units.lean", "def_pos": [42, 9], "def_end_pos": [42, 25]}, {"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}]], "state_before": "z w : \u2124\nh : z * w = -1\n\u22a2 z = 1 \u2227 w = -1 \u2228 z = -1 \u2227 w = 1", "state_after": "case inl\nw : \u2124\nh : 1 * w = -1\n\u22a2 1 = 1 \u2227 w = -1 \u2228 1 = -1 \u2227 w = 1\n\ncase inr\nw : \u2124\nh : -1 * w = -1\n\u22a2 -1 = 1 \u2227 w = -1 \u2228 -1 = -1 \u2227 w = 1"}, {"tactic": "exact Or.inl \u27e8rfl, one_mul w \u25b8 h\u27e9", "annotated_tactic": ["exact <a>Or.inl</a> \u27e8<a>rfl</a>, <a>one_mul</a> w \u25b8 h\u27e9", [{"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "case inl\nw : \u2124\nh : 1 * w = -1\n\u22a2 1 = 1 \u2227 w = -1 \u2228 1 = -1 \u2227 w = 1", "state_after": "no goals"}, {"tactic": "exact Or.inr \u27e8rfl, neg_inj.mp (neg_one_mul w \u25b8 h)\u27e9", "annotated_tactic": ["exact <a>Or.inr</a> \u27e8<a>rfl</a>, neg_inj.mp (<a>neg_one_mul</a> w \u25b8 h)\u27e9", [{"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "neg_one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [345, 9], "def_end_pos": [345, 20]}]], "state_before": "case inr\nw : \u2124\nh : -1 * w = -1\n\u22a2 -1 = 1 \u2227 w = -1 \u2228 -1 = -1 \u2227 w = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/ByteArray.lean", "full_name": "ByteArray.push_data", "start": [33, 9], "end": [33, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "AddValuation.top_iff", "start": [728, 1], "end": [729, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "full_name": "Ordinal.card_typein", "start": [611, 1], "end": [613, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/CovariantClass.lean", "full_name": "Right.pow_lt_one_iff", "start": [336, 1], "end": [342, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "isOpen_compl_singleton", "start": [396, 1], "end": [397, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.inclusion_eq_id", "start": [2780, 1], "end": [2781, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.prod_apply", "start": [764, 1], "end": [768, 96], "traced_tactics": [{"tactic": "ext <;> cases i <;>\n  simp only [prod_apply_inl_fst, Sum.elim_inl, LinearMap.inl_apply, prod_apply_inr_fst,\n    Sum.elim_inr, LinearMap.inr_apply, prod_apply_inl_snd, prod_apply_inr_snd, Function.comp]", "annotated_tactic": ["ext <;> cases i <;>\n    simp only [<a>prod_apply_inl_fst</a>, <a>Sum.elim_inl</a>, <a>LinearMap.inl_apply</a>, <a>prod_apply_inr_fst</a>,\n      <a>Sum.elim_inr</a>, <a>LinearMap.inr_apply</a>, <a>prod_apply_inl_snd</a>, <a>prod_apply_inr_snd</a>, <a>Function.comp</a>]", [{"full_name": "Basis.prod_apply_inl_fst", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [725, 9], "def_end_pos": [725, 27]}, {"full_name": "Sum.elim_inl", "def_path": ".lake/packages/std/Std/Data/Sum/Basic.lean", "def_pos": [85, 17], "def_end_pos": [85, 25]}, {"full_name": "LinearMap.inl_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [191, 9], "def_end_pos": [191, 18]}, {"full_name": "Basis.prod_apply_inr_fst", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [734, 9], "def_end_pos": [734, 27]}, {"full_name": "Sum.elim_inr", "def_path": ".lake/packages/std/Std/Data/Sum/Basic.lean", "def_pos": [88, 17], "def_end_pos": [88, 25]}, {"full_name": "LinearMap.inr_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [200, 9], "def_end_pos": [200, 18]}, {"full_name": "Basis.prod_apply_inl_snd", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [744, 9], "def_end_pos": [744, 27]}, {"full_name": "Basis.prod_apply_inr_snd", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [754, 9], "def_end_pos": [754, 27]}, {"full_name": "Function.comp", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ni : \u03b9 \u2295 \u03b9'\n\u22a2 (Basis.prod b b') i = Sum.elim (\u21d1(LinearMap.inl R M M') \u2218 \u21d1b) (\u21d1(LinearMap.inr R M M') \u2218 \u21d1b') i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Ker.lean", "full_name": "LinearMap.injective_restrict_iff_disjoint", "start": [227, 9], "end": [230, 90], "traced_tactics": [{"tactic": "rw [\u2190 ker_eq_bot, ker_restrict hf, ker_eq_bot, injective_domRestrict_iff, disjoint_iff]", "annotated_tactic": ["rw [\u2190 <a>ker_eq_bot</a>, <a>ker_restrict</a> hf, <a>ker_eq_bot</a>, <a>injective_domRestrict_iff</a>, <a>disjoint_iff</a>]", [{"full_name": "LinearMap.ker_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [210, 9], "def_end_pos": [210, 19]}, {"full_name": "LinearMap.ker_restrict", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [129, 9], "def_end_pos": [129, 21]}, {"full_name": "LinearMap.ker_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [210, 9], "def_end_pos": [210, 19]}, {"full_name": "LinearMap.injective_domRestrict_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [214, 15], "def_end_pos": [214, 40]}, {"full_name": "disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nK : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\nV : Type u_10\nV\u2082 : Type u_11\ninst\u271d\u00b9\u00b9 : Ring R\ninst\u271d\u00b9\u2070 : Ring R\u2082\ninst\u271d\u2079 : Ring R\u2083\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup M\u2082\ninst\u271d\u2076 : AddCommGroup M\u2083\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R\u2082 M\u2082\ninst\u271d\u00b3 : Module R\u2083 M\u2083\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c4\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083\nF : Type u_12\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082\nf\u271d : F\np : Submodule R M\nf : M \u2192\u2097[R] M\nhf : \u2200 x \u2208 p, f x \u2208 p\n\u22a2 Injective \u21d1(restrict f hf) \u2194 Disjoint p (ker f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Real.sin_nat_mul_two_pi_sub", "start": [314, 1], "end": [315, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/MinMax.lean", "full_name": "le_max_iff", "start": [38, 1], "end": [39, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "mem_sphere_iff_norm'", "start": [777, 1], "end": [777, 90], "traced_tactics": [{"tactic": "simp [dist_eq_norm_div]", "annotated_tactic": ["simp [<a>dist_eq_norm_div</a>]", [{"full_name": "dist_eq_norm_div", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [401, 9], "def_end_pos": [401, 25]}]], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b2 : SeminormedGroup E\ninst\u271d\u00b9 : SeminormedGroup F\ninst\u271d : SeminormedGroup G\ns : Set E\na a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\n\u22a2 b \u2208 sphere a r \u2194 \u2016b / a\u2016 = r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.mapDomain_add", "start": [502, 1], "end": [503, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "LowerSet.mem_Iio_iff", "start": [1308, 1], "end": [1309, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Subsemiring.rangeS_subtype", "start": [1193, 1], "end": [1194, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Nontrivial/Defs.lean", "full_name": "exists_pair_ne", "start": [40, 1], "end": [41, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.exists_simpleFunc_forall_lintegral_sub_lt_of_pos", "start": [223, 1], "end": [239, 6], "traced_tactics": [{"tactic": "rw [lintegral_eq_nnreal] at h", "annotated_tactic": ["rw [<a>lintegral_eq_nnreal</a>] at h", [{"full_name": "MeasureTheory.lintegral_eq_nnreal", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [199, 9], "def_end_pos": [199, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u222b\u207b (x : \u03b1), f x \u2202\u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5"}, {"tactic": "have := ENNReal.lt_add_right h h\u03b5", "annotated_tactic": ["have := <a>ENNReal.lt_add_right</a> h h\u03b5", [{"full_name": "ENNReal.lt_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Operations.lean", "def_pos": [177, 9], "def_end_pos": [177, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nthis :\n  \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc <\n    (\u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc) + \u03b5\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5"}, {"tactic": "erw [ENNReal.biSup_add] at this <;> [skip; exact \u27e80, fun x => zero_le _\u27e9]", "annotated_tactic": ["erw [<a>ENNReal.biSup_add</a>] at this <;> [skip; exact \u27e80, fun x => <a>zero_le</a> _\u27e9]", [{"full_name": "ENNReal.biSup_add", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [586, 9], "def_end_pos": [586, 18]}, {"full_name": "zero_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [204, 30], "def_end_pos": [204, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nthis :\n  \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc <\n    (\u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc) + \u03b5\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nthis :\n  \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc <\n    \u2a06 i \u2208 fun \u03c6 => \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x, SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc + \u03b5\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5"}, {"tactic": "simp_rw [lt_iSup_iff, iSup_lt_iff, iSup_le_iff] at this", "annotated_tactic": ["simp_rw [<a>lt_iSup_iff</a>, <a>iSup_lt_iff</a>, <a>iSup_le_iff</a>] at this", [{"full_name": "lt_iSup_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [548, 9], "def_end_pos": [548, 20]}, {"full_name": "iSup_lt_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [870, 9], "def_end_pos": [870, 20]}, {"full_name": "iSup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [853, 9], "def_end_pos": [853, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nthis :\n  \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc <\n    \u2a06 i \u2208 fun \u03c6 => \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x, SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc + \u03b5\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nthis :\n  \u2203 i,\n    \u2203 (_ : i \u2208 fun \u03c6 => \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x),\n      \u2203 b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc + \u03b5,\n        \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5"}, {"tactic": "rcases this with \u27e8\u03c6, hle : \u2200 x, \u2191(\u03c6 x) \u2264 f x, b, hb\u03c6, hb\u27e9", "annotated_tactic": ["rcases this with \u27e8\u03c6, hle : \u2200 x, \u2191(\u03c6 x) \u2264 f x, b, hb\u03c6, hb\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nthis :\n  \u2203 i,\n    \u2203 (_ : i \u2208 fun \u03c6 => \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x),\n      \u2203 b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc + \u03b5,\n        \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5"}, {"tactic": "refine' \u27e8\u03c6, hle, fun \u03c8 h\u03c8 => _\u27e9", "annotated_tactic": ["refine' \u27e8\u03c6, hle, fun \u03c8 h\u03c8 => _\u27e9", []], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u22a2 \u2203 \u03c6,\n    (\u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x) \u2227\n      \u2200 (\u03c8 : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\n\u22a2 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5"}, {"tactic": "have : (map (\u2191) \u03c6).lintegral \u03bc \u2260 \u221e := ne_top_of_le_ne_top h (by exact le_iSup\u2082 (\u03b1 := \u211d\u22650\u221e) \u03c6 hle)", "annotated_tactic": ["have : (<a>map</a> (\u2191) \u03c6).<a>lintegral</a> \u03bc \u2260 \u221e := <a>ne_top_of_le_ne_top</a> h (by exact <a>le_iSup\u2082</a> (\u03b1 := \u211d\u22650\u221e) \u03c6 hle)", [{"full_name": "MeasureTheory.SimpleFunc.map", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [300, 5], "def_end_pos": [300, 8]}, {"full_name": "MeasureTheory.SimpleFunc.lintegral", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [965, 5], "def_end_pos": [965, 14]}, {"full_name": "ne_top_of_le_ne_top", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [162, 9], "def_end_pos": [162, 28]}, {"full_name": "le_iSup\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [746, 9], "def_end_pos": [746, 17]}]], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\n\u22a2 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u22a2 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5"}, {"tactic": "rw [\u2190 ENNReal.add_lt_add_iff_left this, \u2190 add_lintegral, \u2190 SimpleFunc.map_add @ENNReal.coe_add]", "annotated_tactic": ["rw [\u2190 <a>ENNReal.add_lt_add_iff_left</a> this, \u2190 <a>add_lintegral</a>, \u2190 <a>SimpleFunc.map_add</a> @<a>ENNReal.coe_add</a>]", [{"full_name": "ENNReal.add_lt_add_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Operations.lean", "def_pos": [157, 19], "def_end_pos": [157, 38]}, {"full_name": "MeasureTheory.SimpleFunc.add_lintegral", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [1005, 9], "def_end_pos": [1005, 22]}, {"full_name": "MeasureTheory.SimpleFunc.map_add", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [575, 3], "def_end_pos": [575, 14]}, {"full_name": "ENNReal.coe_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [415, 26], "def_end_pos": [415, 33]}]], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u22a2 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c8 - \u03c6)) \u03bc < \u03b5", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u22a2 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c6 + (\u03c8 - \u03c6))) \u03bc <\n    SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5"}, {"tactic": "refine' (hb _ fun x => le_trans _ (max_le (hle x) (h\u03c8 x))).trans_lt hb\u03c6", "annotated_tactic": ["refine' (hb _ fun x => <a>le_trans</a> _ (<a>max_le</a> (hle x) (h\u03c8 x))).<a>trans_lt</a> hb\u03c6", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "max_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [68, 9], "def_end_pos": [68, 15]}, {"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}]], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u22a2 SimpleFunc.lintegral (SimpleFunc.map ofNNReal (\u03c6 + (\u03c8 - \u03c6))) \u03bc <\n    SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\nx : \u03b1\n\u22a2 \u2191(\u2191(\u03c6 + (\u03c8 - \u03c6)) x) \u2264 max \u2191(\u2191\u03c6 x) \u2191(\u2191\u03c8 x)"}, {"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\nx : \u03b1\n\u22a2 \u2191(\u2191(\u03c6 + (\u03c8 - \u03c6)) x) \u2264 max \u2191(\u2191\u03c6 x) \u2191(\u2191\u03c8 x)", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\nx : \u03b1\n\u22a2 \u2191(\u03c6 + (\u03c8 - \u03c6)) x \u2264 max (\u2191\u03c6 x) (\u2191\u03c8 x)"}, {"tactic": "simp only [add_apply, sub_apply, add_tsub_eq_max]", "annotated_tactic": ["simp only [<a>add_apply</a>, <a>sub_apply</a>, <a>add_tsub_eq_max</a>]", [{"full_name": "MeasureTheory.SimpleFunc.add_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [512, 3], "def_end_pos": [512, 14]}, {"full_name": "MeasureTheory.SimpleFunc.sub_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [518, 3], "def_end_pos": [518, 14]}, {"full_name": "add_tsub_eq_max", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [506, 9], "def_end_pos": [506, 24]}]], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\nx : \u03b1\n\u22a2 \u2191(\u03c6 + (\u03c8 - \u03c6)) x \u2264 max (\u2191\u03c6 x) (\u2191\u03c8 x)", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\nx : \u03b1\n\u22a2 max (\u2191\u03c6 x) (\u2191\u03c8 x) \u2264 max (\u2191\u03c6 x) (\u2191\u03c8 x)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\nthis : SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\nx : \u03b1\n\u22a2 max (\u2191\u03c6 x) (\u2191\u03c8 x) \u2264 max (\u2191\u03c6 x) (\u2191\u03c8 x)", "state_after": "no goals"}, {"tactic": "exact le_iSup\u2082 (\u03b1 := \u211d\u22650\u221e) \u03c6 hle", "annotated_tactic": ["exact <a>le_iSup\u2082</a> (\u03b1 := \u211d\u22650\u221e) \u03c6 hle", [{"full_name": "le_iSup\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [746, 9], "def_end_pos": [746, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nh : \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u03c6 : \u03b1 \u2192\u209b \u211d\u22650\nhle : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x\nb : \u211d\u22650\u221e\nhb\u03c6 : b < SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc + \u03b5\nhb : \u2200 (i : \u03b1 \u2192\u209b \u211d\u22650), (\u2200 (x : \u03b1), \u2191(\u2191i x) \u2264 f x) \u2192 SimpleFunc.lintegral (SimpleFunc.map ofNNReal i) \u03bc \u2264 b\n\u03c8 : \u03b1 \u2192\u209b \u211d\u22650\nh\u03c8 : \u2200 (x : \u03b1), \u2191(\u2191\u03c8 x) \u2264 f x\n\u22a2 SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc \u2264\n    \u2a06 \u03c6, \u2a06 (_ : \u2200 (x : \u03b1), \u2191(\u2191\u03c6 x) \u2264 f x), SimpleFunc.lintegral (SimpleFunc.map ofNNReal \u03c6) \u03bc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeGroup/Basic.lean", "full_name": "FreeGroup.toWord_eq_nil_iff", "start": [1320, 1], "end": [1321, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Basic.lean", "full_name": "AddMonoidHom.coe_mulRight", "start": [86, 1], "end": [88, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/NatCast.lean", "full_name": "zero_lt_three'", "start": [92, 1], "end": [93, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.smul_finset_subset_iff\u2080", "start": [2273, 1], "end": [2274, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.iUnion_pNat_ptsOfPeriod", "start": [253, 1], "end": [254, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Antichain.lean", "full_name": "IsAntichain.isWeakAntichain", "start": [396, 11], "end": [397, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.HasBasis.restrict", "start": [444, 1], "end": [449, 39], "traced_tactics": [{"tactic": "refine' \u27e8fun t => \u27e8fun ht => _, fun \u27e8i, hpi, hti\u27e9 => h.mem_iff.2 \u27e8i, hpi.1, hti\u27e9\u27e9\u27e9", "annotated_tactic": ["refine' \u27e8fun t => \u27e8fun ht => _, fun \u27e8i, hpi, hti\u27e9 => h.mem_iff.2 \u27e8i, hpi.1, hti\u27e9\u27e9\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nh : HasBasis l p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\n\u22a2 HasBasis l (fun i => p i \u2227 q i) s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nh : HasBasis l p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\nt : Set \u03b1\nht : t \u2208 l\n\u22a2 \u2203 i, (p i \u2227 q i) \u2227 s i \u2286 t"}, {"tactic": "rcases h.mem_iff.1 ht with \u27e8i, hpi, hti\u27e9", "annotated_tactic": ["rcases h.mem_iff.1 ht with \u27e8i, hpi, hti\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nh : HasBasis l p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\nt : Set \u03b1\nht : t \u2208 l\n\u22a2 \u2203 i, (p i \u2227 q i) \u2227 s i \u2286 t", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni\u271d : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nh : HasBasis l p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\nt : Set \u03b1\nht : t \u2208 l\ni : \u03b9\nhpi : p i\nhti : s i \u2286 t\n\u22a2 \u2203 i, (p i \u2227 q i) \u2227 s i \u2286 t"}, {"tactic": "rcases hq i hpi with \u27e8j, hpj, hqj, hji\u27e9", "annotated_tactic": ["rcases hq i hpi with \u27e8j, hpj, hqj, hji\u27e9", []], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni\u271d : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nh : HasBasis l p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\nt : Set \u03b1\nht : t \u2208 l\ni : \u03b9\nhpi : p i\nhti : s i \u2286 t\n\u22a2 \u2203 i, (p i \u2227 q i) \u2227 s i \u2286 t", "state_after": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni\u271d : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nh : HasBasis l p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\nt : Set \u03b1\nht : t \u2208 l\ni : \u03b9\nhpi : p i\nhti : s i \u2286 t\nj : \u03b9\nhpj : p j\nhqj : q j\nhji : s j \u2286 s i\n\u22a2 \u2203 i, (p i \u2227 q i) \u2227 s i \u2286 t"}, {"tactic": "exact \u27e8j, \u27e8hpj, hqj\u27e9, hji.trans hti\u27e9", "annotated_tactic": ["exact \u27e8j, \u27e8hpj, hqj\u27e9, hji.trans hti\u27e9", []], "state_before": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni\u271d : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nh : HasBasis l p s\nq : \u03b9 \u2192 Prop\nhq : \u2200 (i : \u03b9), p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i\nt : Set \u03b1\nht : t \u2208 l\ni : \u03b9\nhpi : p i\nhti : s i \u2286 t\nj : \u03b9\nhpj : p j\nhqj : q j\nhji : s j \u2286 s i\n\u22a2 \u2203 i, (p i \u2227 q i) \u2227 s i \u2286 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Combination.lean", "full_name": "convexHull_prod", "start": [453, 1], "end": [458, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Forall2.lean", "full_name": "List.forall\u2082_take", "start": [210, 1], "end": [213, 81], "traced_tactics": [{"tactic": "simp only [Forall\u2082.nil, take]", "annotated_tactic": ["simp only [<a>Forall\u2082.nil</a>, <a>take</a>]", [{"full_name": "List.Forall\u2082.nil", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [819, 5], "def_end_pos": [819, 8]}, {"full_name": "List.take", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [534, 5], "def_end_pos": [534, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR S : \u03b1 \u2192 \u03b2 \u2192 Prop\nP : \u03b3 \u2192 \u03b4 \u2192 Prop\nR\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d\u00b2 : List \u03b1\nx\u271d\u00b9 : List \u03b2\nx\u271d : Forall\u2082 R x\u271d\u00b2 x\u271d\u00b9\n\u22a2 Forall\u2082 R (take 0 x\u271d\u00b2) (take 0 x\u271d\u00b9)", "state_after": "no goals"}, {"tactic": "simp only [Forall\u2082.nil, take]", "annotated_tactic": ["simp only [<a>Forall\u2082.nil</a>, <a>take</a>]", [{"full_name": "List.Forall\u2082.nil", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [819, 5], "def_end_pos": [819, 8]}, {"full_name": "List.take", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [534, 5], "def_end_pos": [534, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR S : \u03b1 \u2192 \u03b2 \u2192 Prop\nP : \u03b3 \u2192 \u03b4 \u2192 Prop\nR\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop\nn\u271d : \u2115\n\u22a2 Forall\u2082 R (take (n\u271d + 1) []) (take (n\u271d + 1) [])", "state_after": "no goals"}, {"tactic": "simp [And.intro h\u2081 h\u2082, forall\u2082_take n]", "annotated_tactic": ["simp [<a>And.intro</a> h\u2081 h\u2082, forall\u2082_take n]", [{"full_name": "And.intro", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [514, 3], "def_end_pos": [514, 8]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR S : \u03b1 \u2192 \u03b2 \u2192 Prop\nP : \u03b3 \u2192 \u03b4 \u2192 Prop\nR\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop\nn : \u2115\na\u271d : \u03b1\nb\u271d : \u03b2\nl\u2081\u271d : List \u03b1\nl\u2082\u271d : List \u03b2\nh\u2081 : R a\u271d b\u271d\nh\u2082 : Forall\u2082 R l\u2081\u271d l\u2082\u271d\n\u22a2 Forall\u2082 R (take (n + 1) (a\u271d :: l\u2081\u271d)) (take (n + 1) (b\u271d :: l\u2082\u271d))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "Disjoint.disjoint_sdiff_left", "start": [463, 1], "end": [464, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "le_iSup_inf_iSup", "start": [1931, 1], "end": [1932, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.HasBasis.biInf_mem", "start": [827, 11], "end": [832, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.continuous_const_mul", "start": [418, 11], "end": [419, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bases.lean", "full_name": "TopologicalSpace.IsTopologicalBasis.isOpenMap_iff", "start": [232, 1], "end": [236, 42], "traced_tactics": [{"tactic": "refine' \u27e8fun H o ho => H _ (hB.isOpen ho), fun hf o ho => _\u27e9", "annotated_tactic": ["refine' \u27e8fun H o ho => H _ (hB.isOpen ho), fun hf o ho => _\u27e9", []], "state_before": "\u03b1 : Type u\n\u03b2\u271d : Type u_1\nt : TopologicalSpace \u03b1\nB\u271d : Set (Set \u03b1)\ns : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nB : Set (Set \u03b1)\nhB : IsTopologicalBasis B\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsOpenMap f \u2194 \u2200 s \u2208 B, IsOpen (f '' s)", "state_after": "\u03b1 : Type u\n\u03b2\u271d : Type u_1\nt : TopologicalSpace \u03b1\nB\u271d : Set (Set \u03b1)\ns : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nB : Set (Set \u03b1)\nhB : IsTopologicalBasis B\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 s \u2208 B, IsOpen (f '' s)\no : Set \u03b1\nho : IsOpen o\n\u22a2 IsOpen (f '' o)"}, {"tactic": "rw [hB.open_eq_sUnion' ho, sUnion_eq_iUnion, image_iUnion]", "annotated_tactic": ["rw [hB.open_eq_sUnion' ho, <a>sUnion_eq_iUnion</a>, <a>image_iUnion</a>]", [{"full_name": "Set.sUnion_eq_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1324, 9], "def_end_pos": [1324, 25]}, {"full_name": "Set.image_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1664, 9], "def_end_pos": [1664, 21]}]], "state_before": "\u03b1 : Type u\n\u03b2\u271d : Type u_1\nt : TopologicalSpace \u03b1\nB\u271d : Set (Set \u03b1)\ns : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nB : Set (Set \u03b1)\nhB : IsTopologicalBasis B\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 s \u2208 B, IsOpen (f '' s)\no : Set \u03b1\nho : IsOpen o\n\u22a2 IsOpen (f '' o)", "state_after": "\u03b1 : Type u\n\u03b2\u271d : Type u_1\nt : TopologicalSpace \u03b1\nB\u271d : Set (Set \u03b1)\ns : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nB : Set (Set \u03b1)\nhB : IsTopologicalBasis B\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 s \u2208 B, IsOpen (f '' s)\no : Set \u03b1\nho : IsOpen o\n\u22a2 IsOpen (\u22c3 i, f '' \u2191i)"}, {"tactic": "exact isOpen_iUnion fun s => hf s s.2.1", "annotated_tactic": ["exact <a>isOpen_iUnion</a> fun s => hf s s.2.1", [{"full_name": "isOpen_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2\u271d : Type u_1\nt : TopologicalSpace \u03b1\nB\u271d : Set (Set \u03b1)\ns : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nB : Set (Set \u03b1)\nhB : IsTopologicalBasis B\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 s \u2208 B, IsOpen (f '' s)\no : Set \u03b1\nho : IsOpen o\n\u22a2 IsOpen (\u22c3 i, f '' \u2191i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "full_name": "AffineIsometry.coe_comp", "start": [238, 1], "end": [239, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Sqrt.lean", "full_name": "Real.sqrt_eq_iff_sq_eq", "start": [235, 1], "end": [236, 41], "traced_tactics": [{"tactic": "rw [sq, sqrt_eq_iff_mul_self_eq hx hy]", "annotated_tactic": ["rw [<a>sq</a>, <a>sqrt_eq_iff_mul_self_eq</a> hx hy]", [{"full_name": "sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [91, 41], "def_end_pos": [91, 43]}, {"full_name": "Real.sqrt_eq_iff_mul_self_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Sqrt.lean", "def_pos": [212, 9], "def_end_pos": [212, 32]}]], "state_before": "x y : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\n\u22a2 sqrt x = y \u2194 y ^ 2 = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "full_name": "TensorProduct.directSumRight_symm_lof_tmul", "start": [187, 1], "end": [190, 58], "traced_tactics": [{"tactic": "rw [LinearEquiv.symm_apply_eq, directSumRight_tmul_lof]", "annotated_tactic": ["rw [<a>LinearEquiv.symm_apply_eq</a>, <a>directSumRight_tmul_lof</a>]", [{"full_name": "LinearEquiv.symm_apply_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [393, 9], "def_end_pos": [393, 22]}, {"full_name": "TensorProduct.directSumRight_tmul_lof", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "def_pos": [178, 9], "def_end_pos": [178, 32]}]], "state_before": "R : Type u\ninst\u271d\u00b9\u2070 : CommSemiring R\n\u03b9\u2081 : Type v\u2081\n\u03b9\u2082 : Type v\u2082\ninst\u271d\u2079 : DecidableEq \u03b9\u2081\ninst\u271d\u2078 : DecidableEq \u03b9\u2082\nM\u2081 : \u03b9\u2081 \u2192 Type w\u2081\nM\u2081' : Type w\u2081'\nM\u2082 : \u03b9\u2082 \u2192 Type w\u2082\nM\u2082' : Type w\u2082'\ninst\u271d\u2077 : (i\u2081 : \u03b9\u2081) \u2192 AddCommMonoid (M\u2081 i\u2081)\ninst\u271d\u2076 : AddCommMonoid M\u2081'\ninst\u271d\u2075 : (i\u2082 : \u03b9\u2082) \u2192 AddCommMonoid (M\u2082 i\u2082)\ninst\u271d\u2074 : AddCommMonoid M\u2082'\ninst\u271d\u00b3 : (i\u2081 : \u03b9\u2081) \u2192 Module R (M\u2081 i\u2081)\ninst\u271d\u00b2 : Module R M\u2081'\ninst\u271d\u00b9 : (i\u2082 : \u03b9\u2082) \u2192 Module R (M\u2082 i\u2082)\ninst\u271d : Module R M\u2082'\nx : M\u2081'\ni : \u03b9\u2082\ny : M\u2082 i\n\u22a2 (LinearEquiv.symm (directSumRight R M\u2081' M\u2082)) ((lof R \u03b9\u2082 (fun i => M\u2081' \u2297[R] M\u2082 i) i) (x \u2297\u209c[R] y)) =\n    x \u2297\u209c[R] (lof R \u03b9\u2082 M\u2082 i) y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Data/Bool/Lemmas.lean", "full_name": "Bool.cond_self", "start": [46, 1], "end": [46, 93], "traced_tactics": [{"tactic": "cases b <;> rfl", "annotated_tactic": ["cases b <;> rfl", []], "state_before": "\u03b1 : Type u\nb : Bool\na : \u03b1\n\u22a2 (bif b then a else a) = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "full_name": "Submodule.mem_iInf", "start": [261, 1], "end": [262, 56], "traced_tactics": [{"tactic": "rw [\u2190 SetLike.mem_coe, iInf_coe, Set.mem_iInter]", "annotated_tactic": ["rw [\u2190 <a>SetLike.mem_coe</a>, <a>iInf_coe</a>, <a>Set.mem_iInter</a>]", [{"full_name": "SetLike.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [180, 9], "def_end_pos": [180, 16]}, {"full_name": "Submodule.iInf_coe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [251, 9], "def_end_pos": [251, 17]}, {"full_name": "Set.mem_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [278, 9], "def_end_pos": [278, 19]}]], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : SMul S R\ninst\u271d : IsScalarTower S R M\np\u271d q : Submodule R M\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Submodule R M\nx : M\n\u22a2 x \u2208 \u2a05 i, p i \u2194 \u2200 (i : \u03b9), x \u2208 p i", "state_after": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : SMul S R\ninst\u271d : IsScalarTower S R M\np\u271d q : Submodule R M\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Submodule R M\nx : M\n\u22a2 (\u2200 (i : \u03b9), x \u2208 \u2191(p i)) \u2194 \u2200 (i : \u03b9), x \u2208 p i"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : SMul S R\ninst\u271d : IsScalarTower S R M\np\u271d q : Submodule R M\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Submodule R M\nx : M\n\u22a2 (\u2200 (i : \u03b9), x \u2208 \u2191(p i)) \u2194 \u2200 (i : \u03b9), x \u2208 p i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Star.lean", "full_name": "StarConvex.add_right", "start": [241, 1], "end": [246, 71], "traced_tactics": [{"tactic": "intro y hy a b ha hb hab", "annotated_tactic": ["intro y hy a b ha hb hab", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y z\u271d : E\ns : Set E\nhs : StarConvex \ud835\udd5c x s\nz : E\n\u22a2 StarConvex \ud835\udd5c (x + z) ((fun x => x + z) '' s)", "state_after": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y\u271d z\u271d : E\ns : Set E\nhs : StarConvex \ud835\udd5c x s\nz y : E\nhy : y \u2208 (fun x => x + z) '' s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 (x + z) + b \u2022 y \u2208 (fun x => x + z) '' s"}, {"tactic": "obtain \u27e8y', hy', rfl\u27e9 := hy", "annotated_tactic": ["obtain \u27e8y', hy', rfl\u27e9 := hy", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y\u271d z\u271d : E\ns : Set E\nhs : StarConvex \ud835\udd5c x s\nz y : E\nhy : y \u2208 (fun x => x + z) '' s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 (x + z) + b \u2022 y \u2208 (fun x => x + z) '' s", "state_after": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y z\u271d : E\ns : Set E\nhs : StarConvex \ud835\udd5c x s\nz : E\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\ny' : E\nhy' : y' \u2208 s\n\u22a2 a \u2022 (x + z) + b \u2022 (fun x => x + z) y' \u2208 (fun x => x + z) '' s"}, {"tactic": "refine' \u27e8a \u2022 x + b \u2022 y', hs hy' ha hb hab, _\u27e9", "annotated_tactic": ["refine' \u27e8a \u2022 x + b \u2022 y', hs hy' ha hb hab, _\u27e9", []], "state_before": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y z\u271d : E\ns : Set E\nhs : StarConvex \ud835\udd5c x s\nz : E\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\ny' : E\nhy' : y' \u2208 s\n\u22a2 a \u2022 (x + z) + b \u2022 (fun x => x + z) y' \u2208 (fun x => x + z) '' s", "state_after": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y z\u271d : E\ns : Set E\nhs : StarConvex \ud835\udd5c x s\nz : E\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\ny' : E\nhy' : y' \u2208 s\n\u22a2 (fun x => x + z) (a \u2022 x + b \u2022 y') = a \u2022 (x + z) + b \u2022 (fun x => x + z) y'"}, {"tactic": "rw [smul_add, smul_add, add_add_add_comm, \u2190 add_smul, hab, one_smul]", "annotated_tactic": ["rw [<a>smul_add</a>, <a>smul_add</a>, <a>add_add_add_comm</a>, \u2190 <a>add_smul</a>, hab, <a>one_smul</a>]", [{"full_name": "smul_add", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [843, 9], "def_end_pos": [843, 17]}, {"full_name": "smul_add", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [843, 9], "def_end_pos": [843, 17]}, {"full_name": "add_add_add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [167, 3], "def_end_pos": [167, 14]}, {"full_name": "add_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [92, 9], "def_end_pos": [92, 17]}, {"full_name": "one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [481, 9], "def_end_pos": [481, 17]}]], "state_before": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y z\u271d : E\ns : Set E\nhs : StarConvex \ud835\udd5c x s\nz : E\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\ny' : E\nhy' : y' \u2208 s\n\u22a2 (fun x => x + z) (a \u2022 x + b \u2022 y') = a \u2022 (x + z) + b \u2022 (fun x => x + z) y'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/LocalRing.lean", "full_name": "RingEquiv.localRing", "start": [537, 11], "end": [540, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "full_name": "CategoryTheory.Limits.hasInitial_of_hasTerminal_op", "start": [450, 1], "end": [451, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Cyclotomic/Basic.lean", "full_name": "IsCyclotomicExtension.finite_of_singleton", "start": [307, 1], "end": [318, 79], "traced_tactics": [{"tactic": "rw [Module.finite_def, \u2190 top_toSubmodule, \u2190 ((iff_adjoin_eq_top _ _ _).1 h).2]", "annotated_tactic": ["rw [<a>Module.finite_def</a>, \u2190 <a>top_toSubmodule</a>, \u2190 ((<a>iff_adjoin_eq_top</a> _ _ _).1 h).2]", [{"full_name": "Module.finite_def", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Finiteness.lean", "def_pos": [550, 9], "def_end_pos": [550, 19]}, {"full_name": "Algebra.top_toSubmodule", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "def_pos": [758, 9], "def_end_pos": [758, 24]}, {"full_name": "IsCyclotomicExtension.iff_adjoin_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Cyclotomic/Basic.lean", "def_pos": [93, 9], "def_end_pos": [93, 26]}]], "state_before": "n : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\n\u22a2 Module.Finite A B", "state_after": "n : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\n\u22a2 Submodule.FG (Subalgebra.toSubmodule (adjoin A {b | \u2203 n_1 \u2208 {n}, b ^ \u2191n_1 = 1}))"}, {"tactic": "refine' fg_adjoin_of_finite _ fun b hb => _", "annotated_tactic": ["refine' <a>fg_adjoin_of_finite</a> _ fun b hb => _", [{"full_name": "fg_adjoin_of_finite", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/IntegralClosure.lean", "def_pos": [197, 9], "def_end_pos": [197, 28]}]], "state_before": "n : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\n\u22a2 Submodule.FG (Subalgebra.toSubmodule (adjoin A {b | \u2203 n_1 \u2208 {n}, b ^ \u2191n_1 = 1}))", "state_after": "case refine'_1\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\n\u22a2 Set.Finite {b | \u2203 n_1 \u2208 {n}, b ^ \u2191n_1 = 1}\n\ncase refine'_2\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\nb : B\nhb : b \u2208 {b | \u2203 n_1 \u2208 {n}, b ^ \u2191n_1 = 1}\n\u22a2 IsIntegral A b"}, {"tactic": "simp only [mem_singleton_iff, exists_eq_left]", "annotated_tactic": ["simp only [<a>mem_singleton_iff</a>, <a>exists_eq_left</a>]", [{"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}, {"full_name": "exists_eq_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [215, 17], "def_end_pos": [215, 31]}]], "state_before": "case refine'_1\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\n\u22a2 Set.Finite {b | \u2203 n_1 \u2208 {n}, b ^ \u2191n_1 = 1}", "state_after": "case refine'_1\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\n\u22a2 Set.Finite {b | b ^ \u2191n = 1}"}, {"tactic": "have : {b : B | b ^ (n : \u2115) = 1} = (nthRoots n (1 : B)).toFinset :=\n  Set.ext fun x => \u27e8fun h => by simpa using h, fun h => by simpa using h\u27e9", "annotated_tactic": ["have : {b : B | b ^ (n : \u2115) = 1} = (<a>nthRoots</a> n (1 : B)).<a>toFinset</a> :=\n      <a>Set.ext</a> fun x => \u27e8fun h => by simpa using h, fun h => by simpa using h\u27e9", [{"full_name": "Polynomial.nthRoots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [929, 5], "def_end_pos": [929, 13]}, {"full_name": "Multiset.toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3273, 5], "def_end_pos": [3273, 13]}, {"full_name": "Set.ext", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [64, 9], "def_end_pos": [64, 12]}]], "state_before": "case refine'_1\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\n\u22a2 Set.Finite {b | b ^ \u2191n = 1}", "state_after": "case refine'_1\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\nthis : {b | b ^ \u2191n = 1} = \u2191(Multiset.toFinset (nthRoots (\u2191n) 1))\n\u22a2 Set.Finite {b | b ^ \u2191n = 1}"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "case refine'_1\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\nthis : {b | b ^ \u2191n = 1} = \u2191(Multiset.toFinset (nthRoots (\u2191n) 1))\n\u22a2 Set.Finite {b | b ^ \u2191n = 1}", "state_after": "case refine'_1\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\nthis : {b | b ^ \u2191n = 1} = \u2191(Multiset.toFinset (nthRoots (\u2191n) 1))\n\u22a2 Set.Finite \u2191(Multiset.toFinset (nthRoots (\u2191n) 1))"}, {"tactic": "exact (nthRoots (\u2191n) 1).toFinset.finite_toSet", "annotated_tactic": ["exact (<a>nthRoots</a> (\u2191n) 1).toFinset.finite_toSet", [{"full_name": "Polynomial.nthRoots", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [929, 5], "def_end_pos": [929, 13]}]], "state_before": "case refine'_1\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\nthis : {b | b ^ \u2191n = 1} = \u2191(Multiset.toFinset (nthRoots (\u2191n) 1))\n\u22a2 Set.Finite \u2191(Multiset.toFinset (nthRoots (\u2191n) 1))", "state_after": "no goals"}, {"tactic": "simpa using h", "annotated_tactic": ["simpa using h", []], "state_before": "n : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh\u271d : IsCyclotomicExtension {n} A B\nx : B\nh : x \u2208 {b | b ^ \u2191n = 1}\n\u22a2 x \u2208 \u2191(Multiset.toFinset (nthRoots (\u2191n) 1))", "state_after": "no goals"}, {"tactic": "simpa using h", "annotated_tactic": ["simpa using h", []], "state_before": "n : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh\u271d : IsCyclotomicExtension {n} A B\nx : B\nh : x \u2208 \u2191(Multiset.toFinset (nthRoots (\u2191n) 1))\n\u22a2 x \u2208 {b | b ^ \u2191n = 1}", "state_after": "no goals"}, {"tactic": "simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hb", "annotated_tactic": ["simp only [<a>mem_singleton_iff</a>, <a>exists_eq_left</a>, <a>mem_setOf_eq</a>] at hb", [{"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}, {"full_name": "exists_eq_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [215, 17], "def_end_pos": [215, 31]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}]], "state_before": "case refine'_2\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\nb : B\nhb : b \u2208 {b | \u2203 n_1 \u2208 {n}, b ^ \u2191n_1 = 1}\n\u22a2 IsIntegral A b", "state_after": "case refine'_2\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\nb : B\nhb : b ^ \u2191n = 1\n\u22a2 IsIntegral A b"}, {"tactic": "exact \u27e8X ^ (n : \u2115) - 1, \u27e8monic_X_pow_sub_C _ n.pos.ne.symm, by simp [hb]\u27e9\u27e9", "annotated_tactic": ["exact \u27e8<a>X</a> ^ (n : \u2115) - 1, \u27e8<a>monic_X_pow_sub_C</a> _ n.pos.ne.symm, by simp [hb]\u27e9\u27e9", [{"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.monic_X_pow_sub_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [399, 9], "def_end_pos": [399, 26]}]], "state_before": "case refine'_2\nn : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\nb : B\nhb : b ^ \u2191n = 1\n\u22a2 IsIntegral A b", "state_after": "no goals"}, {"tactic": "simp [hb]", "annotated_tactic": ["simp [hb]", []], "state_before": "n : \u2115+\nS T : Set \u2115+\nA : Type u\nB : Type v\nK : Type w\nL : Type z\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsDomain B\nh : IsCyclotomicExtension {n} A B\nb : B\nhb : b ^ \u2191n = 1\n\u22a2 eval\u2082 (algebraMap A B) b (X ^ \u2191n - 1) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean", "full_name": "equicontinuous_iff_continuous", "start": [528, 1], "end": [530, 91], "traced_tactics": [{"tactic": "simp_rw [Equicontinuous, continuous_iff_continuousAt, equicontinuousAt_iff_continuousAt]", "annotated_tactic": ["simp_rw [<a>Equicontinuous</a>, <a>continuous_iff_continuousAt</a>, <a>equicontinuousAt_iff_continuousAt</a>]", [{"full_name": "Equicontinuous", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "def_pos": [117, 5], "def_end_pos": [117, 19]}, {"full_name": "continuous_iff_continuousAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1635, 9], "def_end_pos": [1635, 36]}, {"full_name": "equicontinuousAt_iff_continuousAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Equicontinuity.lean", "def_pos": [508, 9], "def_end_pos": [508, 42]}]], "state_before": "\u03b9 : Type u_1\n\u03ba : Type u_2\nX : Type u_3\nX' : Type u_4\nY : Type u_5\nZ : Type u_6\n\u03b1 : Type u_7\n\u03b1' : Type u_8\n\u03b2 : Type u_9\n\u03b2' : Type u_10\n\u03b3 : Type u_11\n\ud835\udcd5 : Type u_12\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ntZ : TopologicalSpace Z\nu\u03b1 : UniformSpace \u03b1\nu\u03b2 : UniformSpace \u03b2\nu\u03b3 : UniformSpace \u03b3\nF : \u03b9 \u2192 X \u2192 \u03b1\n\u22a2 Equicontinuous F \u2194 Continuous (\u21d1UniformFun.ofFun \u2218 swap F)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Noetherian.lean", "full_name": "isNoetherianRing_iff", "start": [507, 1], "end": [508, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_mem_inter_mulSupport", "start": [550, 1], "end": [552, 71], "traced_tactics": [{"tactic": "rw [finprod_mem_def, finprod_mem_def, mulIndicator_inter_mulSupport]", "annotated_tactic": ["rw [<a>finprod_mem_def</a>, <a>finprod_mem_def</a>, <a>mulIndicator_inter_mulSupport</a>]", [{"full_name": "finprod_mem_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [377, 9], "def_end_pos": [377, 24]}, {"full_name": "finprod_mem_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [377, 9], "def_end_pos": [377, 24]}, {"full_name": "Set.mulIndicator_inter_mulSupport", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [230, 9], "def_end_pos": [230, 38]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : \u03b1 \u2192 M\ns : Set \u03b1\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s \u2229 mulSupport f), f i = \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.eq_top_iff'", "start": [1065, 1], "end": [1066, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "inf_eq_left", "start": [403, 1], "end": [404, 44], "traced_tactics": [{"tactic": "simp [le_rfl]", "annotated_tactic": ["simp [<a>le_rfl</a>]", [{"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : SemilatticeInf \u03b1\na b c d : \u03b1\n\u22a2 a \u2293 b \u2264 a \u2227 a \u2264 a \u2293 b \u2194 a \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Subsemiring.coe_toSubmonoid", "start": [401, 1], "end": [402, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/EuclideanDomain.lean", "full_name": "isCoprime_div_gcd_div_gcd", "start": [58, 1], "end": [64, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Operations.lean", "full_name": "Submonoid.toAddSubmonoid_closure", "start": [100, 1], "end": [106, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean", "full_name": "equicontinuousOn_iff_range", "start": [481, 1], "end": [483, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.Subset.rfl", "start": [348, 11], "end": [349, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "full_name": "Complex.two_pi_I_ne_zero", "start": [152, 1], "end": [152, 91], "traced_tactics": [{"tactic": "norm_num [Real.pi_ne_zero, I_ne_zero]", "annotated_tactic": ["norm_num [<a>Real.pi_ne_zero</a>, <a>I_ne_zero</a>]", [{"full_name": "Real.pi_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "def_pos": [171, 9], "def_end_pos": [171, 19]}, {"full_name": "Complex.I_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [327, 15], "def_end_pos": [327, 24]}]], "state_before": "\u22a2 2 * \u2191\u03c0 * I \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.image_add_const_Iic", "start": [363, 1], "end": [363, 81], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedAddCommGroup \u03b1\na b c : \u03b1\n\u22a2 (fun x => x + a) '' Iic b = Iic (b + a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Basic.lean", "full_name": "uniformContinuous_toAdd", "start": [1435, 1], "end": [1436, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/GeneralLinearGroup.lean", "full_name": "Matrix.GeneralLinearGroup.coe_mul", "start": [112, 1], "end": [113, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "full_name": "Equiv.Perm.VectorsProdEqOne.card", "start": [446, 1], "end": [447, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Hom/Basic.lean", "full_name": "MonoidHom.coe_of_map_div", "start": [157, 1], "end": [158, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Commute/Defs.lean", "full_name": "Commute.mul_inv", "start": [227, 11], "end": [227, 101], "traced_tactics": [{"tactic": "rw [hab.eq, mul_inv_rev]", "annotated_tactic": ["rw [hab.eq, <a>mul_inv_rev</a>]", [{"full_name": "mul_inv_rev", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1070, 9], "def_end_pos": [1070, 20]}]], "state_before": "G : Type u_1\ninst\u271d : DivisionMonoid G\na b c d : G\nhab : Commute a b\n\u22a2 (a * b)\u207b\u00b9 = a\u207b\u00b9 * b\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.infinite_of_exists_right", "start": [2378, 1], "end": [2381, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/Lemmas.lean", "full_name": "Std.RBNode.toStream_toList'", "start": [423, 1], "end": [424, 52], "traced_tactics": [{"tactic": "induction t generalizing s <;> simp [*, toStream]", "annotated_tactic": ["induction t generalizing s <;> simp [*, <a>toStream</a>]", [{"full_name": "Std.RBNode.toStream", "def_path": ".lake/packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [125, 5], "def_end_pos": [125, 13]}]], "state_before": "\u03b1 : Type u_1\nt : RBNode \u03b1\ns : RBNode.Stream \u03b1\n\u22a2 Stream.toList (toStream t s) = toList t ++ Stream.toList s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeGroup/Basic.lean", "full_name": "FreeGroup.Red.length", "start": [426, 1], "end": [431, 58], "traced_tactics": [{"tactic": "induction' h with L\u2082 L\u2083 _h\u2081\u2082 h\u2082\u2083 ih", "annotated_tactic": ["induction' h with L\u2082 L\u2083 _h\u2081\u2082 h\u2082\u2083 ih", []], "state_before": "\u03b1 : Type u\nL L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)\nh : Red L\u2081 L\u2082\n\u22a2 \u2203 n, List.length L\u2081 = List.length L\u2082 + 2 * n", "state_after": "case refl\n\u03b1 : Type u\nL L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)\n\u22a2 \u2203 n, List.length L\u2081 = List.length L\u2081 + 2 * n\n\ncase tail\n\u03b1 : Type u\nL L\u2081 L\u2082\u271d L\u2083\u271d L\u2084 L\u2082 L\u2083 : List (\u03b1 \u00d7 Bool)\n_h\u2081\u2082 : ReflTransGen Step L\u2081 L\u2082\nh\u2082\u2083 : Step L\u2082 L\u2083\nih : \u2203 n, List.length L\u2081 = List.length L\u2082 + 2 * n\n\u22a2 \u2203 n, List.length L\u2081 = List.length L\u2083 + 2 * n"}, {"tactic": "exact \u27e80, rfl\u27e9", "annotated_tactic": ["exact \u27e80, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case refl\n\u03b1 : Type u\nL L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)\n\u22a2 \u2203 n, List.length L\u2081 = List.length L\u2081 + 2 * n", "state_after": "no goals"}, {"tactic": "rcases ih with \u27e8n, eq\u27e9", "annotated_tactic": ["rcases ih with \u27e8n, eq\u27e9", []], "state_before": "case tail\n\u03b1 : Type u\nL L\u2081 L\u2082\u271d L\u2083\u271d L\u2084 L\u2082 L\u2083 : List (\u03b1 \u00d7 Bool)\n_h\u2081\u2082 : ReflTransGen Step L\u2081 L\u2082\nh\u2082\u2083 : Step L\u2082 L\u2083\nih : \u2203 n, List.length L\u2081 = List.length L\u2082 + 2 * n\n\u22a2 \u2203 n, List.length L\u2081 = List.length L\u2083 + 2 * n", "state_after": "case tail.intro\n\u03b1 : Type u\nL L\u2081 L\u2082\u271d L\u2083\u271d L\u2084 L\u2082 L\u2083 : List (\u03b1 \u00d7 Bool)\n_h\u2081\u2082 : ReflTransGen Step L\u2081 L\u2082\nh\u2082\u2083 : Step L\u2082 L\u2083\nn : \u2115\neq : List.length L\u2081 = List.length L\u2082 + 2 * n\n\u22a2 \u2203 n, List.length L\u2081 = List.length L\u2083 + 2 * n"}, {"tactic": "exists 1 + n", "annotated_tactic": ["exists 1 + n", []], "state_before": "case tail.intro\n\u03b1 : Type u\nL L\u2081 L\u2082\u271d L\u2083\u271d L\u2084 L\u2082 L\u2083 : List (\u03b1 \u00d7 Bool)\n_h\u2081\u2082 : ReflTransGen Step L\u2081 L\u2082\nh\u2082\u2083 : Step L\u2082 L\u2083\nn : \u2115\neq : List.length L\u2081 = List.length L\u2082 + 2 * n\n\u22a2 \u2203 n, List.length L\u2081 = List.length L\u2083 + 2 * n", "state_after": "case tail.intro\n\u03b1 : Type u\nL L\u2081 L\u2082\u271d L\u2083\u271d L\u2084 L\u2082 L\u2083 : List (\u03b1 \u00d7 Bool)\n_h\u2081\u2082 : ReflTransGen Step L\u2081 L\u2082\nh\u2082\u2083 : Step L\u2082 L\u2083\nn : \u2115\neq : List.length L\u2081 = List.length L\u2082 + 2 * n\n\u22a2 List.length L\u2081 = List.length L\u2083 + 2 * (1 + n)"}, {"tactic": "simp [mul_add, eq, (Step.length h\u2082\u2083).symm, add_assoc]", "annotated_tactic": ["simp [<a>mul_add</a>, eq, (<a>Step.length</a> h\u2082\u2083).<a>symm</a>, <a>add_assoc</a>]", [{"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "FreeGroup.Red.Step.length", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/FreeGroup/Basic.lean", "def_pos": [109, 9], "def_end_pos": [109, 20]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}]], "state_before": "case tail.intro\n\u03b1 : Type u\nL L\u2081 L\u2082\u271d L\u2083\u271d L\u2084 L\u2082 L\u2083 : List (\u03b1 \u00d7 Bool)\n_h\u2081\u2082 : ReflTransGen Step L\u2081 L\u2082\nh\u2082\u2083 : Step L\u2082 L\u2083\nn : \u2115\neq : List.length L\u2081 = List.length L\u2082 + 2 * n\n\u22a2 List.length L\u2081 = List.length L\u2083 + 2 * (1 + n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.cosh_three_mul", "start": [1137, 8], "end": [1138, 43], "traced_tactics": [{"tactic": "rw [\u2190 ofReal_inj]", "annotated_tactic": ["rw [\u2190 <a>ofReal_inj</a>]", [{"full_name": "Complex.ofReal_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [109, 9], "def_end_pos": [109, 19]}]], "state_before": "x y : \u211d\n\u22a2 cosh (3 * x) = 4 * cosh x ^ 3 - 3 * cosh x", "state_after": "x y : \u211d\n\u22a2 \u2191(cosh (3 * x)) = \u2191(4 * cosh x ^ 3 - 3 * cosh x)"}, {"tactic": "simp [cosh_three_mul]", "annotated_tactic": ["simp [<a>cosh_three_mul</a>]", [{"full_name": "Complex.cosh_three_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [458, 9], "def_end_pos": [458, 23]}]], "state_before": "x y : \u211d\n\u22a2 \u2191(cosh (3 * x)) = \u2191(4 * cosh x ^ 3 - 3 * cosh x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Set.toFinset_ofFinset", "start": [659, 1], "end": [661, 58], "traced_tactics": [{"tactic": "rw [@mem_toFinset _ _ (id _), H]", "annotated_tactic": ["rw [@<a>mem_toFinset</a> _ _ (<a>id</a> _), H]", [{"full_name": "Set.mem_toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [653, 9], "def_end_pos": [653, 21]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns\u271d t p : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\nx : \u03b1\n\u22a2 x \u2208 toFinset p \u2194 x \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "full_name": "Basis.opNorm_le", "start": [319, 1], "end": [322, 63], "traced_tactics": [{"tactic": "simpa using NNReal.coe_le_coe.mpr (v.opNNNorm_le \u27e8M, hM\u27e9 hu)", "annotated_tactic": ["simpa using NNReal.coe_le_coe.mpr (v.opNNNorm_le \u27e8M, hM\u27e9 hu)", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \ud835\udd5c E\nF : Type w\ninst\u271d\u2078 : NormedAddCommGroup F\ninst\u271d\u2077 : NormedSpace \ud835\udd5c F\nF' : Type x\ninst\u271d\u2076 : AddCommGroup F'\ninst\u271d\u2075 : Module \ud835\udd5c F'\ninst\u271d\u2074 : TopologicalSpace F'\ninst\u271d\u00b3 : TopologicalAddGroup F'\ninst\u271d\u00b2 : ContinuousSMul \ud835\udd5c F'\ninst\u271d\u00b9 : CompleteSpace \ud835\udd5c\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nv : Basis \u03b9 \ud835\udd5c E\nu : E \u2192L[\ud835\udd5c] F\nM : \u211d\nhM : 0 \u2264 M\nhu : \u2200 (i : \u03b9), \u2016u (v i)\u2016 \u2264 M\n\u22a2 \u2016u\u2016 \u2264 Fintype.card \u03b9 \u2022 \u2016\u2191(equivFunL v)\u2016 * M", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Index.lean", "full_name": "Subgroup.relindex_inf_le", "start": [434, 1], "end": [439, 82], "traced_tactics": [{"tactic": "by_cases h : H.relindex L = 0", "annotated_tactic": ["by_cases h : H.relindex L = 0", []], "state_before": "G : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\n\u22a2 relindex (H \u2293 K) L \u2264 relindex H L * relindex K L", "state_after": "case pos\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nh : relindex H L = 0\n\u22a2 relindex (H \u2293 K) L \u2264 relindex H L * relindex K L\n\ncase neg\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nh : \u00acrelindex H L = 0\n\u22a2 relindex (H \u2293 K) L \u2264 relindex H L * relindex K L"}, {"tactic": "rw [\u2190 inf_relindex_right, inf_assoc, \u2190 relindex_mul_relindex _ _ L inf_le_right inf_le_right,\n  inf_relindex_right, inf_relindex_right]", "annotated_tactic": ["rw [\u2190 <a>inf_relindex_right</a>, <a>inf_assoc</a>, \u2190 <a>relindex_mul_relindex</a> _ _ L <a>inf_le_right</a> <a>inf_le_right</a>,\n    <a>inf_relindex_right</a>, <a>inf_relindex_right</a>]", [{"full_name": "Subgroup.inf_relindex_right", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Index.lean", "def_pos": [133, 9], "def_end_pos": [133, 27]}, {"full_name": "inf_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [470, 9], "def_end_pos": [470, 18]}, {"full_name": "Subgroup.relindex_mul_relindex", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Index.lean", "def_pos": [125, 9], "def_end_pos": [125, 30]}, {"full_name": "inf_le_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [369, 9], "def_end_pos": [369, 21]}, {"full_name": "inf_le_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [369, 9], "def_end_pos": [369, 21]}, {"full_name": "Subgroup.inf_relindex_right", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Index.lean", "def_pos": [133, 9], "def_end_pos": [133, 27]}, {"full_name": "Subgroup.inf_relindex_right", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Index.lean", "def_pos": [133, 9], "def_end_pos": [133, 27]}]], "state_before": "case neg\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nh : \u00acrelindex H L = 0\n\u22a2 relindex (H \u2293 K) L \u2264 relindex H L * relindex K L", "state_after": "case neg\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nh : \u00acrelindex H L = 0\n\u22a2 relindex H (K \u2293 L) * relindex K L \u2264 relindex H L * relindex K L"}, {"tactic": "exact mul_le_mul_right' (relindex_le_of_le_right inf_le_right h) (K.relindex L)", "annotated_tactic": ["exact <a>mul_le_mul_right'</a> (<a>relindex_le_of_le_right</a> <a>inf_le_right</a> h) (K.relindex L)", [{"full_name": "mul_le_mul_right'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [67, 9], "def_end_pos": [67, 26]}, {"full_name": "Subgroup.relindex_le_of_le_right", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Index.lean", "def_pos": [402, 9], "def_end_pos": [402, 32]}, {"full_name": "inf_le_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [369, 9], "def_end_pos": [369, 21]}]], "state_before": "case neg\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nh : \u00acrelindex H L = 0\n\u22a2 relindex H (K \u2293 L) * relindex K L \u2264 relindex H L * relindex K L", "state_after": "no goals"}, {"tactic": "exact (le_of_eq (relindex_eq_zero_of_le_left inf_le_left h)).trans (zero_le _)", "annotated_tactic": ["exact (<a>le_of_eq</a> (<a>relindex_eq_zero_of_le_left</a> <a>inf_le_left</a> h)).<a>trans</a> (<a>zero_le</a> _)", [{"full_name": "le_of_eq", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [66, 9], "def_end_pos": [66, 17]}, {"full_name": "Subgroup.relindex_eq_zero_of_le_left", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Index.lean", "def_pos": [377, 9], "def_end_pos": [377, 36]}, {"full_name": "inf_le_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [360, 9], "def_end_pos": [360, 20]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "zero_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [204, 30], "def_end_pos": [204, 37]}]], "state_before": "case pos\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nh : relindex H L = 0\n\u22a2 relindex (H \u2293 K) L \u2264 relindex H L * relindex K L", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Countable.lean", "full_name": "Set.Countable.union", "start": [256, 1], "end": [257, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Interval.lean", "full_name": "Int.card_Ioc_of_le", "start": [142, 1], "end": [143, 35], "traced_tactics": [{"tactic": "rw [card_Ioc, toNat_sub_of_le h]", "annotated_tactic": ["rw [<a>card_Ioc</a>, <a>toNat_sub_of_le</a> h]", [{"full_name": "Int.card_Ioc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Interval.lean", "def_pos": [116, 9], "def_end_pos": [116, 17]}, {"full_name": "Int.toNat_sub_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Order/Basic.lean", "def_pos": [529, 9], "def_end_pos": [529, 24]}]], "state_before": "a b : \u2124\nh : a \u2264 b\n\u22a2 \u2191(Ioc a b).card = b - a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Submodule.annihilator_bot", "start": [107, 1], "end": [108, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean", "full_name": "PowerSeries.coeff_prod", "start": [639, 1], "end": [650, 57], "traced_tactics": [{"tactic": "simp only [coeff]", "annotated_tactic": ["simp only [<a>coeff</a>]", [{"full_name": "PowerSeries.coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PowerSeries/Basic.lean", "def_pos": [140, 5], "def_end_pos": [140, 10]}]], "state_before": "R\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 (coeff R d) (\u220f j in s, f j) = \u2211 l in piAntidiagonal s d, \u220f i in s, (coeff R (l i)) (f i)", "state_after": "R\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 (MvPowerSeries.coeff R (single () d)) (\u220f j in s, f j) =\n    \u2211 x in piAntidiagonal s d, \u220f x_1 in s, (MvPowerSeries.coeff R (single () (x x_1))) (f x_1)"}, {"tactic": "convert MvPowerSeries.coeff_prod _ _ _", "annotated_tactic": ["convert <a>MvPowerSeries.coeff_prod</a> _ _ _", [{"full_name": "MvPowerSeries.coeff_prod", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/MvPowerSeries/Basic.lean", "def_pos": [690, 9], "def_end_pos": [690, 19]}]], "state_before": "R\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 (MvPowerSeries.coeff R (single () d)) (\u220f j in s, f j) =\n    \u2211 x in piAntidiagonal s d, \u220f x_1 in s, (MvPowerSeries.coeff R (single () (x x_1))) (f x_1)", "state_after": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 \u2211 x in piAntidiagonal s d, \u220f x_1 in s, (MvPowerSeries.coeff R (single () (x x_1))) (f x_1) =\n    \u2211 l in piAntidiagonal s (single () d), \u220f i in s, (MvPowerSeries.coeff R (l i)) (f i)\n\ncase convert_5\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 DecidableEq \u03b9\n\ncase convert_6\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 DecidableEq Unit"}, {"tactic": "rw [\u2190 AddEquiv.finsuppUnique_symm d, \u2190 mapRange_piAntidiagonal_eq, sum_map, sum_congr rfl]", "annotated_tactic": ["rw [\u2190 <a>AddEquiv.finsuppUnique_symm</a> d, \u2190 <a>mapRange_piAntidiagonal_eq</a>, <a>sum_map</a>, <a>sum_congr</a> <a>rfl</a>]", [{"full_name": "AddEquiv.finsuppUnique_symm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [1070, 9], "def_end_pos": [1070, 43]}, {"full_name": "Finset.mapRange_piAntidiagonal_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/PiAntidiagonal.lean", "def_pos": [245, 7], "def_end_pos": [245, 33]}, {"full_name": "Finset.sum_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [368, 3], "def_end_pos": [368, 14]}, {"full_name": "Finset.sum_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [381, 3], "def_end_pos": [381, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 \u2211 x in piAntidiagonal s d, \u220f x_1 in s, (MvPowerSeries.coeff R (single () (x x_1))) (f x_1) =\n    \u2211 l in piAntidiagonal s (single () d), \u220f i in s, (MvPowerSeries.coeff R (l i)) (f i)\n\ncase convert_5\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 DecidableEq \u03b9\n\ncase convert_6\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 DecidableEq Unit", "state_after": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 \u2200 x \u2208 piAntidiagonal s d,\n    \u220f x_1 in s, (MvPowerSeries.coeff R (single () (x x_1))) (f x_1) =\n      \u220f i in s,\n        (MvPowerSeries.coeff R\n            (((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) i))\n          (f i)"}, {"tactic": "intro x _", "annotated_tactic": ["intro x _", []], "state_before": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\n\u22a2 \u2200 x \u2208 piAntidiagonal s d,\n    \u220f x_1 in s, (MvPowerSeries.coeff R (single () (x x_1))) (f x_1) =\n      \u220f i in s,\n        (MvPowerSeries.coeff R\n            (((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) i))\n          (f i)", "state_after": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\nx : \u03b9 \u2192\u2080 \u2115\na\u271d : x \u2208 piAntidiagonal s d\n\u22a2 \u220f x_1 in s, (MvPowerSeries.coeff R (single () (x x_1))) (f x_1) =\n    \u220f i in s,\n      (MvPowerSeries.coeff R\n          (((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) i))\n        (f i)"}, {"tactic": "apply prod_congr rfl", "annotated_tactic": ["apply <a>prod_congr</a> <a>rfl</a>", [{"full_name": "Finset.prod_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 9], "def_end_pos": [382, 19]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\nx : \u03b9 \u2192\u2080 \u2115\na\u271d : x \u2208 piAntidiagonal s d\n\u22a2 \u220f x_1 in s, (MvPowerSeries.coeff R (single () (x x_1))) (f x_1) =\n    \u220f i in s,\n      (MvPowerSeries.coeff R\n          (((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) i))\n        (f i)", "state_after": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\nx : \u03b9 \u2192\u2080 \u2115\na\u271d : x \u2208 piAntidiagonal s d\n\u22a2 \u2200 x_1 \u2208 s,\n    (MvPowerSeries.coeff R (single () (x x_1))) (f x_1) =\n      (MvPowerSeries.coeff R\n          (((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) x_1))\n        (f x_1)"}, {"tactic": "intro i _", "annotated_tactic": ["intro i _", []], "state_before": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\nx : \u03b9 \u2192\u2080 \u2115\na\u271d : x \u2208 piAntidiagonal s d\n\u22a2 \u2200 x_1 \u2208 s,\n    (MvPowerSeries.coeff R (single () (x x_1))) (f x_1) =\n      (MvPowerSeries.coeff R\n          (((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) x_1))\n        (f x_1)", "state_after": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\nx : \u03b9 \u2192\u2080 \u2115\na\u271d\u00b9 : x \u2208 piAntidiagonal s d\ni : \u03b9\na\u271d : i \u2208 s\n\u22a2 (MvPowerSeries.coeff R (single () (x i))) (f i) =\n    (MvPowerSeries.coeff R\n        (((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) i))\n      (f i)"}, {"tactic": "congr 2", "annotated_tactic": ["congr 2", []], "state_before": "case h.e'_3\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\nx : \u03b9 \u2192\u2080 \u2115\na\u271d\u00b9 : x \u2208 piAntidiagonal s d\ni : \u03b9\na\u271d : i \u2208 s\n\u22a2 (MvPowerSeries.coeff R (single () (x i))) (f i) =\n    (MvPowerSeries.coeff R\n        (((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) i))\n      (f i)", "state_after": "case h.e'_3.e_a.e_n\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\nx : \u03b9 \u2192\u2080 \u2115\na\u271d\u00b9 : x \u2208 piAntidiagonal s d\ni : \u03b9\na\u271d : i \u2208 s\n\u22a2 single () (x i) = ((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) i"}, {"tactic": "simp only [AddEquiv.toEquiv_eq_coe, Finsupp.mapRange.addEquiv_toEquiv, AddEquiv.toEquiv_symm,\n  Equiv.coe_toEmbedding, Finsupp.mapRange.equiv_apply, AddEquiv.coe_toEquiv_symm,\n  Finsupp.mapRange_apply, AddEquiv.finsuppUnique_symm]", "annotated_tactic": ["simp only [<a>AddEquiv.toEquiv_eq_coe</a>, <a>Finsupp.mapRange.addEquiv_toEquiv</a>, <a>AddEquiv.toEquiv_symm</a>,\n    <a>Equiv.coe_toEmbedding</a>, <a>Finsupp.mapRange.equiv_apply</a>, <a>AddEquiv.coe_toEquiv_symm</a>,\n    <a>Finsupp.mapRange_apply</a>, <a>AddEquiv.finsuppUnique_symm</a>]", [{"full_name": "AddEquiv.toEquiv_eq_coe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Equiv/Basic.lean", "def_pos": [214, 3], "def_end_pos": [214, 14]}, {"full_name": "Finsupp.mapRange.addEquiv_toEquiv", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [287, 9], "def_end_pos": [287, 34]}, {"full_name": "AddEquiv.toEquiv_symm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Equiv/Basic.lean", "def_pos": [323, 3], "def_end_pos": [323, 14]}, {"full_name": "Equiv.coe_toEmbedding", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [79, 9], "def_end_pos": [79, 30]}, {"full_name": "Finsupp.mapRange.equiv_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [140, 9], "def_end_pos": [140, 14]}, {"full_name": "AddEquiv.coe_toEquiv_symm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Equiv/Basic.lean", "def_pos": [303, 3], "def_end_pos": [303, 14]}, {"full_name": "Finsupp.mapRange_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 23]}, {"full_name": "AddEquiv.finsuppUnique_symm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [1070, 9], "def_end_pos": [1070, 43]}]], "state_before": "case h.e'_3.e_a.e_n\nR\u271d : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b9\nf : \u03b9 \u2192 R\u27e6X\u27e7\nd : \u2115\ns : Finset \u03b9\nx : \u03b9 \u2192\u2080 \u2115\na\u271d\u00b9 : x \u2208 piAntidiagonal s d\ni : \u03b9\na\u271d : i \u2208 s\n\u22a2 single () (x i) = ((Equiv.toEmbedding (Finsupp.mapRange.addEquiv (AddEquiv.symm AddEquiv.finsuppUnique)).toEquiv) x) i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Hom/Basic.lean", "full_name": "RingHom.map_dvd", "start": [52, 11], "end": [53, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.map_toDual_max", "start": [1620, 1], "end": [1622, 34], "traced_tactics": [{"tactic": "rw [min_eq_inf_withTop, inf_image]", "annotated_tactic": ["rw [<a>min_eq_inf_withTop</a>, <a>inf_image</a>]", [{"full_name": "Finset.min_eq_inf_withTop", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1437, 9], "def_end_pos": [1437, 27]}, {"full_name": "Finset.inf_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [345, 9], "def_end_pos": [345, 18]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b1\nH : s\u271d.Nonempty\nx : \u03b1\ns : Finset \u03b1\n\u22a2 WithBot.map (\u21d1toDual) (Finset.max s) = Finset.min (image (\u21d1toDual) s)", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b1\nH : s\u271d.Nonempty\nx : \u03b1\ns : Finset \u03b1\n\u22a2 WithBot.map (\u21d1toDual) (Finset.max s) = inf s (WithTop.some \u2218 \u21d1toDual)"}, {"tactic": "exact congr_fun Option.map_id _", "annotated_tactic": ["exact <a>congr_fun</a> <a>Option.map_id</a> _", [{"full_name": "congr_fun", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [74, 7], "def_end_pos": [74, 16]}, {"full_name": "Option.map_id", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [46, 9], "def_end_pos": [46, 15]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b1\nH : s\u271d.Nonempty\nx : \u03b1\ns : Finset \u03b1\n\u22a2 WithBot.map (\u21d1toDual) (Finset.max s) = inf s (WithTop.some \u2218 \u21d1toDual)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean", "full_name": "Fin.snoc_last", "start": [509, 1], "end": [509, 60], "traced_tactics": [{"tactic": "simp [snoc]", "annotated_tactic": ["simp [<a>snoc</a>]", [{"full_name": "Fin.snoc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Tuple/Basic.lean", "def_pos": [484, 5], "def_end_pos": [484, 9]}]], "state_before": "m n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\n\u22a2 snoc p x (last n) = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "mul_le_mul_three", "start": [214, 1], "end": [218, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Cast/Basic.lean", "full_name": "Nat.coe_castRingHom", "start": [62, 1], "end": [62, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.bind_congr", "start": [1769, 1], "end": [1771, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "isOpenMap_div_right", "start": [1209, 1], "end": [1210, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.extract_empty_of_size_le_start", "start": [691, 1], "end": [694, 23], "traced_tactics": [{"tactic": "simp [extract]", "annotated_tactic": ["simp [<a>extract</a>]", [{"full_name": "Array.extract", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2721, 5], "def_end_pos": [2721, 18]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nstart stop : Nat\nh : size as \u2264 start\n\u22a2 extract as start stop = #[]", "state_after": "\u03b1 : Type u_1\nas : Array \u03b1\nstart stop : Nat\nh : size as \u2264 start\n\u22a2 extract.loop as (min stop (size as) - start) start #[] = #[]"}, {"tactic": "rw [\u2190Nat.sub_min_sub_right, Nat.sub_eq_zero_of_le h, Nat.min_zero,\nextract_loop_zero]", "annotated_tactic": ["rw [\u2190<a>Nat.sub_min_sub_right</a>, <a>Nat.sub_eq_zero_of_le</a> h, <a>Nat.min_zero</a>,\n    <a>extract_loop_zero</a>]", [{"full_name": "Nat.sub_min_sub_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [465, 19], "def_end_pos": [465, 36]}, {"full_name": "Nat.sub_eq_zero_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [679, 19], "def_end_pos": [679, 36]}, {"full_name": "Nat.min_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [342, 27], "def_end_pos": [342, 35]}, {"full_name": "Array.extract_loop_zero", "def_path": ".lake/packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [569, 9], "def_end_pos": [569, 26]}]], "state_before": "\u03b1 : Type u_1\nas : Array \u03b1\nstart stop : Nat\nh : size as \u2264 start\n\u22a2 extract.loop as (min stop (size as) - start) start #[] = #[]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Real.rpow_inv_natCast_pow", "start": [496, 1], "end": [498, 68], "traced_tactics": [{"tactic": "have hn0 : (n : \u211d) \u2260 0 := Nat.cast_ne_zero.2 hn", "annotated_tactic": ["have hn0 : (n : \u211d) \u2260 0 := <a>Nat.cast_ne_zero</a>.2 hn", [{"full_name": "Nat.cast_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharZero/Defs.lean", "def_pos": [83, 9], "def_end_pos": [83, 21]}]], "state_before": "x y z : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\n\u22a2 (x ^ (\u2191n)\u207b\u00b9) ^ n = x", "state_after": "x y z : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 (x ^ (\u2191n)\u207b\u00b9) ^ n = x"}, {"tactic": "rw [\u2190 rpow_nat_cast, \u2190 rpow_mul hx, inv_mul_cancel hn0, rpow_one]", "annotated_tactic": ["rw [\u2190 <a>rpow_nat_cast</a>, \u2190 <a>rpow_mul</a> hx, <a>inv_mul_cancel</a> hn0, <a>rpow_one</a>]", [{"full_name": "Real.rpow_nat_cast", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [70, 9], "def_end_pos": [70, 22]}, {"full_name": "Real.rpow_mul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [393, 9], "def_end_pos": [393, 17]}, {"full_name": "inv_mul_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NeZero.lean", "def_pos": [53, 9], "def_end_pos": [53, 23]}, {"full_name": "Real.rpow_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [144, 9], "def_end_pos": [144, 17]}]], "state_before": "x y z : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 (x ^ (\u2191n)\u207b\u00b9) ^ n = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "ClosedEmbedding.t4Space", "start": [2168, 11], "end": [2171, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/Field.lean", "full_name": "Filter.Tendsto.mul_atBot", "start": [110, 1], "end": [112, 49], "traced_tactics": [{"tactic": "simpa only [mul_comm] using hg.atBot_mul hC hf", "annotated_tactic": ["simpa only [<a>mul_comm</a>] using hg.atBot_mul hC hf", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "\ud835\udd5c : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\nl : Filter \u03b1\nf g : \u03b1 \u2192 \ud835\udd5c\nC : \ud835\udd5c\nhC : 0 < C\nhf : Tendsto f l (\ud835\udcdd C)\nhg : Tendsto g l atBot\n\u22a2 Tendsto (fun x => f x * g x) l atBot", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sum/Order.lean", "full_name": "OrderIso.sumAssoc_symm_apply_inr_inr", "start": [595, 1], "end": [596, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/NatAntidiagonal.lean", "full_name": "List.Nat.map_swap_antidiagonal", "start": [95, 1], "end": [100, 78], "traced_tactics": [{"tactic": "rw [antidiagonal, map_map, \u2190 List.map_reverse, range_eq_range', reverse_range', \u2190\n  range_eq_range', map_map]", "annotated_tactic": ["rw [<a>antidiagonal</a>, <a>map_map</a>, \u2190 <a>List.map_reverse</a>, <a>range_eq_range'</a>, <a>reverse_range'</a>, \u2190\n    <a>range_eq_range'</a>, <a>map_map</a>]", [{"full_name": "List.Nat.antidiagonal", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/NatAntidiagonal.lean", "def_pos": [32, 5], "def_end_pos": [32, 17]}, {"full_name": "List.map_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [133, 17], "def_end_pos": [133, 24]}, {"full_name": "List.map_reverse", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [595, 9], "def_end_pos": [595, 20]}, {"full_name": "List.range_eq_range'", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2192, 9], "def_end_pos": [2192, 24]}, {"full_name": "List.reverse_range'", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2243, 9], "def_end_pos": [2243, 23]}, {"full_name": "List.range_eq_range'", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2192, 9], "def_end_pos": [2192, 24]}, {"full_name": "List.map_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [133, 17], "def_end_pos": [133, 24]}]], "state_before": "n : \u2115\n\u22a2 map Prod.swap (antidiagonal n) = reverse (antidiagonal n)", "state_after": "n : \u2115\n\u22a2 map (Prod.swap \u2218 fun i => (i, n - i)) (range (n + 1)) =\n    map ((fun i => (i, n - i)) \u2218 fun x => 0 + (n + 1) - 1 - x) (range (n + 1))"}, {"tactic": "apply map_congr", "annotated_tactic": ["apply <a>map_congr</a>", [{"full_name": "List.map_congr", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1728, 9], "def_end_pos": [1728, 18]}]], "state_before": "n : \u2115\n\u22a2 map (Prod.swap \u2218 fun i => (i, n - i)) (range (n + 1)) =\n    map ((fun i => (i, n - i)) \u2218 fun x => 0 + (n + 1) - 1 - x) (range (n + 1))", "state_after": "case a\nn : \u2115\n\u22a2 \u2200 x \u2208 range (n + 1), (Prod.swap \u2218 fun i => (i, n - i)) x = ((fun i => (i, n - i)) \u2218 fun x => 0 + (n + 1) - 1 - x) x"}, {"tactic": "simp (config := { contextual := true }) [Nat.sub_sub_self, Nat.lt_succ_iff]", "annotated_tactic": ["simp (config := { contextual := <a>true</a> }) [<a>Nat.sub_sub_self</a>, <a>Nat.lt_succ_iff</a>]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}, {"full_name": "Nat.sub_sub_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [252, 19], "def_end_pos": [252, 31]}, {"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}]], "state_before": "case a\nn : \u2115\n\u22a2 \u2200 x \u2208 range (n + 1), (Prod.swap \u2218 fun i => (i, n - i)) x = ((fun i => (i, n - i)) \u2218 fun x => 0 + (n + 1) - 1 - x) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Integral.lean", "full_name": "integralClosure.isFractionRing_of_finite_extension", "start": [362, 1], "end": [364, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/StdBasis.lean", "full_name": "LinearMap.iInf_ker_proj_le_iSup_range_stdBasis", "start": [108, 1], "end": [122, 76], "traced_tactics": [{"tactic": "intro b hb", "annotated_tactic": ["intro b hb", []], "state_before": "R : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\n\u22a2 \u2200 \u2983x : (i : \u03b9) \u2192 \u03c6 i\u2984, x \u2208 \u2a05 i \u2208 J, ker (proj i) \u2192 x \u2208 \u2a06 i \u2208 I, range (stdBasis R \u03c6 i)", "state_after": "R : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : b \u2208 \u2a05 i \u2208 J, ker (proj i)\n\u22a2 b \u2208 \u2a06 i \u2208 I, range (stdBasis R \u03c6 i)"}, {"tactic": "simp only [mem_iInf, mem_ker, proj_apply] at hb", "annotated_tactic": ["simp only [<a>mem_iInf</a>, <a>mem_ker</a>, <a>proj_apply</a>] at hb", [{"full_name": "Submodule.mem_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [261, 9], "def_end_pos": [261, 17]}, {"full_name": "LinearMap.mem_ker", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [65, 9], "def_end_pos": [65, 16]}, {"full_name": "LinearMap.proj_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Pi.lean", "def_pos": [93, 9], "def_end_pos": [93, 19]}]], "state_before": "R : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : b \u2208 \u2a05 i \u2208 J, ker (proj i)\n\u22a2 b \u2208 \u2a06 i \u2208 I, range (stdBasis R \u03c6 i)", "state_after": "R : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\n\u22a2 b \u2208 \u2a06 i \u2208 I, range (stdBasis R \u03c6 i)"}, {"tactic": "rw [\u2190\n  show (\u2211 i in I, stdBasis R \u03c6 i (b i)) = b by\n    ext i\n    rw [Finset.sum_apply, \u2190 stdBasis_same R \u03c6 i (b i)]\n    refine Finset.sum_eq_single i (fun j _ ne => stdBasis_ne _ _ _ _ ne.symm _) ?_\n    intro hiI\n    rw [stdBasis_same]\n    exact hb _ ((hu trivial).resolve_left hiI)]", "annotated_tactic": ["rw [\u2190\n        show (\u2211 i in I, <a>stdBasis</a> R \u03c6 i (b i)) = b by\n          ext i\n          rw [<a>Finset.sum_apply</a>, \u2190 <a>stdBasis_same</a> R \u03c6 i (b i)]\n          refine <a>Finset.sum_eq_single</a> i (fun j _ ne => <a>stdBasis_ne</a> _ _ _ _ ne.symm _) ?_\n          intro hiI\n          rw [<a>stdBasis_same</a>]\n          exact hb _ ((hu <a>trivial</a>).<a>resolve_left</a> hiI)]", [{"full_name": "LinearMap.stdBasis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [48, 5], "def_end_pos": [48, 13]}, {"full_name": "Finset.sum_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Pi.lean", "def_pos": [41, 3], "def_end_pos": [41, 14]}, {"full_name": "LinearMap.stdBasis_same", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [67, 9], "def_end_pos": [67, 22]}, {"full_name": "Finset.sum_eq_single", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [946, 3], "def_end_pos": [946, 14]}, {"full_name": "LinearMap.stdBasis_ne", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [71, 9], "def_end_pos": [71, 20]}, {"full_name": "LinearMap.stdBasis_same", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [67, 9], "def_end_pos": [67, 22]}, {"full_name": "trivial", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [643, 31], "def_end_pos": [643, 38]}, {"full_name": "Or.resolve_left", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [551, 9], "def_end_pos": [551, 24]}]], "state_before": "R : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\n\u22a2 b \u2208 \u2a06 i \u2208 I, range (stdBasis R \u03c6 i)", "state_after": "R : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\n\u22a2 \u2211 i in I, (stdBasis R \u03c6 i) (b i) \u2208 \u2a06 i \u2208 I, range (stdBasis R \u03c6 i)"}, {"tactic": "exact sum_mem_biSup fun i _ => mem_range_self (stdBasis R \u03c6 i) (b i)", "annotated_tactic": ["exact <a>sum_mem_biSup</a> fun i _ => <a>mem_range_self</a> (<a>stdBasis</a> R \u03c6 i) (b i)", [{"full_name": "Submodule.sum_mem_biSup", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [305, 9], "def_end_pos": [305, 22]}, {"full_name": "LinearMap.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [155, 9], "def_end_pos": [155, 23]}, {"full_name": "LinearMap.stdBasis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [48, 5], "def_end_pos": [48, 13]}]], "state_before": "R : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\n\u22a2 \u2211 i in I, (stdBasis R \u03c6 i) (b i) \u2208 \u2a06 i \u2208 I, range (stdBasis R \u03c6 i)", "state_after": "no goals"}, {"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "R : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\n\u22a2 \u2211 i in I, (stdBasis R \u03c6 i) (b i) = b", "state_after": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\n\u22a2 Finset.sum I (fun i => (stdBasis R \u03c6 i) (b i)) i = b i"}, {"tactic": "rw [Finset.sum_apply, \u2190 stdBasis_same R \u03c6 i (b i)]", "annotated_tactic": ["rw [<a>Finset.sum_apply</a>, \u2190 <a>stdBasis_same</a> R \u03c6 i (b i)]", [{"full_name": "Finset.sum_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Pi.lean", "def_pos": [41, 3], "def_end_pos": [41, 14]}, {"full_name": "LinearMap.stdBasis_same", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [67, 9], "def_end_pos": [67, 22]}]], "state_before": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\n\u22a2 Finset.sum I (fun i => (stdBasis R \u03c6 i) (b i)) i = b i", "state_after": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\n\u22a2 \u2211 c in I, (stdBasis R \u03c6 c) (b c) i = (stdBasis R \u03c6 i) (b i) i"}, {"tactic": "refine Finset.sum_eq_single i (fun j _ ne => stdBasis_ne _ _ _ _ ne.symm _) ?_", "annotated_tactic": ["refine <a>Finset.sum_eq_single</a> i (fun j _ ne => <a>stdBasis_ne</a> _ _ _ _ ne.symm _) ?_", [{"full_name": "Finset.sum_eq_single", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [946, 3], "def_end_pos": [946, 14]}, {"full_name": "LinearMap.stdBasis_ne", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [71, 9], "def_end_pos": [71, 20]}]], "state_before": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\n\u22a2 \u2211 c in I, (stdBasis R \u03c6 c) (b c) i = (stdBasis R \u03c6 i) (b i) i", "state_after": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\n\u22a2 i \u2209 I \u2192 (stdBasis R \u03c6 i) (b i) i = 0"}, {"tactic": "intro hiI", "annotated_tactic": ["intro hiI", []], "state_before": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\n\u22a2 i \u2209 I \u2192 (stdBasis R \u03c6 i) (b i) i = 0", "state_after": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\nhiI : i \u2209 I\n\u22a2 (stdBasis R \u03c6 i) (b i) i = 0"}, {"tactic": "rw [stdBasis_same]", "annotated_tactic": ["rw [<a>stdBasis_same</a>]", [{"full_name": "LinearMap.stdBasis_same", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [67, 9], "def_end_pos": [67, 22]}]], "state_before": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\nhiI : i \u2209 I\n\u22a2 (stdBasis R \u03c6 i) (b i) i = 0", "state_after": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\nhiI : i \u2209 I\n\u22a2 b i = 0"}, {"tactic": "exact hb _ ((hu trivial).resolve_left hiI)", "annotated_tactic": ["exact hb _ ((hu <a>trivial</a>).<a>resolve_left</a> hiI)", [{"full_name": "trivial", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [643, 31], "def_end_pos": [643, 38]}, {"full_name": "Or.resolve_left", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [551, 9], "def_end_pos": [551, 24]}]], "state_before": "case h\nR : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03c6 i)\ninst\u271d : DecidableEq \u03b9\nI : Finset \u03b9\nJ : Set \u03b9\nhu : univ \u2286 \u2191I \u222a J\nb : (i : \u03b9) \u2192 \u03c6 i\nhb : \u2200 i \u2208 J, b i = 0\ni : \u03b9\nhiI : i \u2209 I\n\u22a2 b i = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/LocalExtr.lean", "full_name": "IsLocalMax.max", "start": [527, 8], "end": [529, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.support_prod_of_pairwise_disjoint", "start": [415, 1], "end": [421, 40], "traced_tactics": [{"tactic": "induction' l with hd tl hl", "annotated_tactic": ["induction' l with hd tl hl", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nl : List (Perm \u03b1)\nh : List.Pairwise Disjoint l\n\u22a2 support (List.prod l) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support l)", "state_after": "case nil\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : List.Pairwise Disjoint []\n\u22a2 support (List.prod []) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support [])\n\ncase cons\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g hd : Perm \u03b1\ntl : List (Perm \u03b1)\nhl : List.Pairwise Disjoint tl \u2192 support (List.prod tl) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support tl)\nh : List.Pairwise Disjoint (hd :: tl)\n\u22a2 support (List.prod (hd :: tl)) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support (hd :: tl))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : List.Pairwise Disjoint []\n\u22a2 support (List.prod []) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support [])", "state_after": "no goals"}, {"tactic": "rw [List.pairwise_cons] at h", "annotated_tactic": ["rw [<a>List.pairwise_cons</a>] at h", [{"full_name": "List.pairwise_cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1041, 17], "def_end_pos": [1041, 30]}]], "state_before": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g hd : Perm \u03b1\ntl : List (Perm \u03b1)\nhl : List.Pairwise Disjoint tl \u2192 support (List.prod tl) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support tl)\nh : List.Pairwise Disjoint (hd :: tl)\n\u22a2 support (List.prod (hd :: tl)) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support (hd :: tl))", "state_after": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g hd : Perm \u03b1\ntl : List (Perm \u03b1)\nhl : List.Pairwise Disjoint tl \u2192 support (List.prod tl) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support tl)\nh : (\u2200 a' \u2208 tl, Disjoint hd a') \u2227 List.Pairwise Disjoint tl\n\u22a2 support (List.prod (hd :: tl)) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support (hd :: tl))"}, {"tactic": "have : Disjoint hd tl.prod := disjoint_prod_right _ h.left", "annotated_tactic": ["have : <a>Disjoint</a> hd tl.prod := <a>disjoint_prod_right</a> _ h.left", [{"full_name": "Equiv.Perm.Disjoint", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [43, 5], "def_end_pos": [43, 13]}, {"full_name": "Equiv.Perm.disjoint_prod_right", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [130, 9], "def_end_pos": [130, 28]}]], "state_before": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g hd : Perm \u03b1\ntl : List (Perm \u03b1)\nhl : List.Pairwise Disjoint tl \u2192 support (List.prod tl) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support tl)\nh : (\u2200 a' \u2208 tl, Disjoint hd a') \u2227 List.Pairwise Disjoint tl\n\u22a2 support (List.prod (hd :: tl)) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support (hd :: tl))", "state_after": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g hd : Perm \u03b1\ntl : List (Perm \u03b1)\nhl : List.Pairwise Disjoint tl \u2192 support (List.prod tl) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support tl)\nh : (\u2200 a' \u2208 tl, Disjoint hd a') \u2227 List.Pairwise Disjoint tl\nthis : Disjoint hd (List.prod tl)\n\u22a2 support (List.prod (hd :: tl)) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support (hd :: tl))"}, {"tactic": "simp [this.support_mul, hl h.right]", "annotated_tactic": ["simp [this.support_mul, hl h.right]", []], "state_before": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g hd : Perm \u03b1\ntl : List (Perm \u03b1)\nhl : List.Pairwise Disjoint tl \u2192 support (List.prod tl) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support tl)\nh : (\u2200 a' \u2208 tl, Disjoint hd a') \u2227 List.Pairwise Disjoint tl\nthis : Disjoint hd (List.prod tl)\n\u22a2 support (List.prod (hd :: tl)) = List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 (List.map support (hd :: tl))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "full_name": "Complex.cpow_mul_int", "start": [122, 1], "end": [122, 99], "traced_tactics": [{"tactic": "rw [mul_comm, cpow_int_mul]", "annotated_tactic": ["rw [<a>mul_comm</a>, <a>cpow_int_mul</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Complex.cpow_int_mul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "def_pos": [115, 7], "def_end_pos": [115, 19]}]], "state_before": "x y : \u2102\nn : \u2124\n\u22a2 x ^ (y * \u2191n) = (x ^ y) ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Index.lean", "full_name": "Subgroup.dvd_index_map", "start": [340, 1], "end": [343, 22], "traced_tactics": [{"tactic": "rw [index_map, sup_of_le_left hf]", "annotated_tactic": ["rw [<a>index_map</a>, <a>sup_of_le_left</a> hf]", [{"full_name": "Subgroup.index_map", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Index.lean", "def_pos": [325, 9], "def_end_pos": [325, 18]}, {"full_name": "sup_of_le_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [175, 11], "def_end_pos": [175, 25]}]], "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH K L : Subgroup G\nG' : Type u_2\ninst\u271d : Group G'\nf : G \u2192* G'\nhf : MonoidHom.ker f \u2264 H\n\u22a2 index H \u2223 index (map f H)", "state_after": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH K L : Subgroup G\nG' : Type u_2\ninst\u271d : Group G'\nf : G \u2192* G'\nhf : MonoidHom.ker f \u2264 H\n\u22a2 index H \u2223 index H * index (MonoidHom.range f)"}, {"tactic": "apply dvd_mul_right", "annotated_tactic": ["apply <a>dvd_mul_right</a>", [{"full_name": "dvd_mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 22]}]], "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH K L : Subgroup G\nG' : Type u_2\ninst\u271d : Group G'\nf : G \u2192* G'\nhf : MonoidHom.ker f \u2264 H\n\u22a2 index H \u2223 index H * index (MonoidHom.range f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Norm.lean", "full_name": "Algebra.norm_eq_zero_iff'", "start": [177, 1], "end": [178, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Basic.lean", "full_name": "Complex.ofReal_def", "start": [104, 1], "end": [105, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.eq_sInf_of_mem_iff_exists_mem", "start": [810, 1], "end": [813, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Cast/Commute.lean", "full_name": "Commute.self_cast_nat_mul", "start": [87, 1], "end": [87, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Fintype.rightInverse_bijInv", "start": [1204, 1], "end": [1205, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "full_name": "Polynomial.cyclotomic.dvd_X_pow_sub_one", "start": [374, 1], "end": [382, 62], "traced_tactics": [{"tactic": "suffices cyclotomic n \u2124 \u2223 X ^ n - 1 by\n  simpa only [map_cyclotomic_int, Polynomial.map_sub, Polynomial.map_one, Polynomial.map_pow,\n    Polynomial.map_X] using map_dvd (Int.castRingHom R) this", "annotated_tactic": ["suffices <a>cyclotomic</a> n \u2124 \u2223 <a>X</a> ^ n - 1 by\n    simpa only [<a>map_cyclotomic_int</a>, <a>Polynomial.map_sub</a>, <a>Polynomial.map_one</a>, <a>Polynomial.map_pow</a>,\n      <a>Polynomial.map_X</a>] using <a>map_dvd</a> (<a>Int.castRingHom</a> R) this", [{"full_name": "Polynomial.cyclotomic", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [253, 5], "def_end_pos": [253, 15]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.map_cyclotomic_int", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [266, 9], "def_end_pos": [266, 27]}, {"full_name": "Polynomial.map_sub", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [1283, 19], "def_end_pos": [1283, 26]}, {"full_name": "Polynomial.map_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [741, 19], "def_end_pos": [741, 26]}, {"full_name": "Polynomial.map_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [942, 19], "def_end_pos": [942, 26]}, {"full_name": "Polynomial.map_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [720, 9], "def_end_pos": [720, 14]}, {"full_name": "Polynomial.map_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [802, 9], "def_end_pos": [802, 16]}, {"full_name": "Int.castRingHom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [81, 5], "def_end_pos": [81, 16]}]], "state_before": "n : \u2115\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 cyclotomic n R \u2223 X ^ n - 1", "state_after": "n : \u2115\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 cyclotomic n \u2124 \u2223 X ^ n - 1"}, {"tactic": "rcases n.eq_zero_or_pos with (rfl | hn)", "annotated_tactic": ["rcases n.eq_zero_or_pos with (rfl | hn)", []], "state_before": "n : \u2115\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 cyclotomic n \u2124 \u2223 X ^ n - 1", "state_after": "case inl\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 cyclotomic 0 \u2124 \u2223 X ^ 0 - 1\n\ncase inr\nn : \u2115\nR : Type u_1\ninst\u271d : Ring R\nhn : n > 0\n\u22a2 cyclotomic n \u2124 \u2223 X ^ n - 1"}, {"tactic": "rw [\u2190 prod_cyclotomic_eq_X_pow_sub_one hn]", "annotated_tactic": ["rw [\u2190 <a>prod_cyclotomic_eq_X_pow_sub_one</a> hn]", [{"full_name": "Polynomial.prod_cyclotomic_eq_X_pow_sub_one", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [362, 9], "def_end_pos": [362, 41]}]], "state_before": "case inr\nn : \u2115\nR : Type u_1\ninst\u271d : Ring R\nhn : n > 0\n\u22a2 cyclotomic n \u2124 \u2223 X ^ n - 1", "state_after": "case inr\nn : \u2115\nR : Type u_1\ninst\u271d : Ring R\nhn : n > 0\n\u22a2 cyclotomic n \u2124 \u2223 \u220f i in Nat.divisors n, cyclotomic i \u2124"}, {"tactic": "exact Finset.dvd_prod_of_mem _ (n.mem_divisors_self hn.ne')", "annotated_tactic": ["exact <a>Finset.dvd_prod_of_mem</a> _ (n.mem_divisors_self hn.ne')", [{"full_name": "Finset.dvd_prod_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1814, 9], "def_end_pos": [1814, 24]}]], "state_before": "case inr\nn : \u2115\nR : Type u_1\ninst\u271d : Ring R\nhn : n > 0\n\u22a2 cyclotomic n \u2124 \u2223 \u220f i in Nat.divisors n, cyclotomic i \u2124", "state_after": "no goals"}, {"tactic": "simpa only [map_cyclotomic_int, Polynomial.map_sub, Polynomial.map_one, Polynomial.map_pow,\n  Polynomial.map_X] using map_dvd (Int.castRingHom R) this", "annotated_tactic": ["simpa only [<a>map_cyclotomic_int</a>, <a>Polynomial.map_sub</a>, <a>Polynomial.map_one</a>, <a>Polynomial.map_pow</a>,\n      <a>Polynomial.map_X</a>] using <a>map_dvd</a> (<a>Int.castRingHom</a> R) this", [{"full_name": "Polynomial.map_cyclotomic_int", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean", "def_pos": [266, 9], "def_end_pos": [266, 27]}, {"full_name": "Polynomial.map_sub", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [1283, 19], "def_end_pos": [1283, 26]}, {"full_name": "Polynomial.map_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [741, 19], "def_end_pos": [741, 26]}, {"full_name": "Polynomial.map_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [942, 19], "def_end_pos": [942, 26]}, {"full_name": "Polynomial.map_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [720, 9], "def_end_pos": [720, 14]}, {"full_name": "Polynomial.map_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [802, 9], "def_end_pos": [802, 16]}, {"full_name": "Int.castRingHom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [81, 5], "def_end_pos": [81, 16]}]], "state_before": "n : \u2115\nR : Type u_1\ninst\u271d : Ring R\nthis : cyclotomic n \u2124 \u2223 X ^ n - 1\n\u22a2 cyclotomic n R \u2223 X ^ n - 1", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inl\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 cyclotomic 0 \u2124 \u2223 X ^ 0 - 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/End.lean", "full_name": "Module.End.natCast_apply", "start": [91, 1], "end": [91, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Congruence.lean", "full_name": "Con.lift_funext", "start": [950, 1], "end": [953, 29], "traced_tactics": [{"tactic": "rw [\u2190 lift_apply_mk' f, \u2190 lift_apply_mk' g]", "annotated_tactic": ["rw [\u2190 <a>lift_apply_mk'</a> f, \u2190 <a>lift_apply_mk'</a> g]", [{"full_name": "Con.lift_apply_mk'", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Congruence.lean", "def_pos": [940, 9], "def_end_pos": [940, 23]}, {"full_name": "Con.lift_apply_mk'", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Congruence.lean", "def_pos": [940, 9], "def_end_pos": [940, 23]}]], "state_before": "M : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : MulOneClass N\ninst\u271d : MulOneClass P\nc : Con M\nx y : M\nf\u271d : M \u2192* P\nf g : Con.Quotient c \u2192* P\nh : \u2200 (a : M), f \u2191a = g \u2191a\n\u22a2 f = g", "state_after": "M : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : MulOneClass N\ninst\u271d : MulOneClass P\nc : Con M\nx y : M\nf\u271d : M \u2192* P\nf g : Con.Quotient c \u2192* P\nh : \u2200 (a : M), f \u2191a = g \u2191a\n\u22a2 lift c (MonoidHom.comp f (mk' c)) \u22ef = lift c (MonoidHom.comp g (mk' c)) \u22ef"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "M : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : MulOneClass N\ninst\u271d : MulOneClass P\nc : Con M\nx y : M\nf\u271d : M \u2192* P\nf g : Con.Quotient c \u2192* P\nh : \u2200 (a : M), f \u2191a = g \u2191a\n\u22a2 lift c (MonoidHom.comp f (mk' c)) \u22ef = lift c (MonoidHom.comp g (mk' c)) \u22ef", "state_after": "case e_f\nM : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : MulOneClass N\ninst\u271d : MulOneClass P\nc : Con M\nx y : M\nf\u271d : M \u2192* P\nf g : Con.Quotient c \u2192* P\nh : \u2200 (a : M), f \u2191a = g \u2191a\n\u22a2 MonoidHom.comp f (mk' c) = MonoidHom.comp g (mk' c)"}, {"tactic": "exact DFunLike.ext_iff.2 h", "annotated_tactic": ["exact <a>DFunLike.ext_iff</a>.2 h", [{"full_name": "DFunLike.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/FunLike/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 16]}]], "state_before": "case e_f\nM : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : MulOneClass N\ninst\u271d : MulOneClass P\nc : Con M\nx y : M\nf\u271d : M \u2192* P\nf g : Con.Quotient c \u2192* P\nh : \u2200 (a : M), f \u2191a = g \u2191a\n\u22a2 MonoidHom.comp f (mk' c) = MonoidHom.comp g (mk' c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Hom.lean", "full_name": "NormedAddGroupHom.ext_iff", "start": [116, 1], "end": [117, 30], "traced_tactics": [{"tactic": "rintro rfl x", "annotated_tactic": ["rintro rfl x", []], "state_before": "V : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf g : NormedAddGroupHom V\u2081 V\u2082\n\u22a2 f = g \u2192 \u2200 (x : V\u2081), f x = g x", "state_after": "V : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf : NormedAddGroupHom V\u2081 V\u2082\nx : V\u2081\n\u22a2 f x = f x"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "V : Type u_1\nV\u2081 : Type u_2\nV\u2082 : Type u_3\nV\u2083 : Type u_4\ninst\u271d\u00b3 : SeminormedAddCommGroup V\ninst\u271d\u00b2 : SeminormedAddCommGroup V\u2081\ninst\u271d\u00b9 : SeminormedAddCommGroup V\u2082\ninst\u271d : SeminormedAddCommGroup V\u2083\nf : NormedAddGroupHom V\u2081 V\u2082\nx : V\u2081\n\u22a2 f x = f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "List.prev_singleton", "start": [150, 1], "end": [151, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.card_support_eq_zero", "start": [583, 1], "end": [584, 49], "traced_tactics": [{"tactic": "rw [Finset.card_eq_zero, support_eq_empty_iff]", "annotated_tactic": ["rw [<a>Finset.card_eq_zero</a>, <a>support_eq_empty_iff</a>]", [{"full_name": "Finset.card_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [70, 9], "def_end_pos": [70, 21]}, {"full_name": "Equiv.Perm.support_eq_empty_iff", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [310, 9], "def_end_pos": [310, 29]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\n\u22a2 (support f).card = 0 \u2194 f = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.neg_ball", "start": [959, 1], "end": [961, 83], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup E\u2082\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 E\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np\u271d p : Seminorm \ud835\udd5c E\nr : \u211d\nx : E\n\u22a2 -ball p x r = ball p (-x) r", "state_after": "case h\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup E\u2082\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 E\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np\u271d p : Seminorm \ud835\udd5c E\nr : \u211d\nx x\u271d : E\n\u22a2 x\u271d \u2208 -ball p x r \u2194 x\u271d \u2208 ball p (-x) r"}, {"tactic": "rw [Set.mem_neg, mem_ball, mem_ball, \u2190 neg_add', sub_neg_eq_add, map_neg_eq_map]", "annotated_tactic": ["rw [<a>Set.mem_neg</a>, <a>mem_ball</a>, <a>mem_ball</a>, \u2190 <a>neg_add'</a>, <a>sub_neg_eq_add</a>, <a>map_neg_eq_map</a>]", [{"full_name": "Set.mem_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [180, 3], "def_end_pos": [180, 14]}, {"full_name": "Seminorm.mem_ball", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [675, 9], "def_end_pos": [675, 17]}, {"full_name": "Seminorm.mem_ball", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [675, 9], "def_end_pos": [675, 17]}, {"full_name": "neg_add'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [576, 3], "def_end_pos": [576, 14]}, {"full_name": "sub_neg_eq_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [528, 3], "def_end_pos": [528, 14]}, {"full_name": "AddGroupSeminormClass.map_neg_eq_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Hom/Basic.lean", "def_pos": [180, 3], "def_end_pos": [180, 17]}]], "state_before": "case h\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup E\u2082\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 E\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np\u271d p : Seminorm \ud835\udd5c E\nr : \u211d\nx x\u271d : E\n\u22a2 x\u271d \u2208 -ball p x r \u2194 x\u271d \u2208 ball p (-x) r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.pow_induction_on_right'", "start": [492, 11], "end": [509, 54], "traced_tactics": [{"tactic": "induction' n with n n_ih generalizing x", "annotated_tactic": ["induction' n with n n_ih generalizing x", []], "state_before": "\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nn : \u2115\nx : A\nhx : x \u2208 M ^ n\n\u22a2 C n x hx", "state_after": "case zero\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nx : A\nhx : x \u2208 M ^ Nat.zero\n\u22a2 C Nat.zero x hx\n\ncase succ\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nn : \u2115\nn_ih : \u2200 {x : A} (hx : x \u2208 M ^ n), C n x hx\nx : A\nhx : x \u2208 M ^ Nat.succ n\n\u22a2 C (Nat.succ n) x hx"}, {"tactic": "revert hx", "annotated_tactic": ["revert hx", []], "state_before": "case succ\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nn : \u2115\nn_ih : \u2200 {x : A} (hx : x \u2208 M ^ n), C n x hx\nx : A\nhx : x \u2208 M ^ Nat.succ n\n\u22a2 C (Nat.succ n) x hx", "state_after": "case succ\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nn : \u2115\nn_ih : \u2200 {x : A} (hx : x \u2208 M ^ n), C n x hx\nx : A\n\u22a2 \u2200 (hx : x \u2208 M ^ Nat.succ n), C (Nat.succ n) x hx"}, {"tactic": "simp_rw [pow_succ']", "annotated_tactic": ["simp_rw [<a>pow_succ'</a>]", [{"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}]], "state_before": "case succ\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nn : \u2115\nn_ih : \u2200 {x : A} (hx : x \u2208 M ^ n), C n x hx\nx : A\n\u22a2 \u2200 (hx : x \u2208 M ^ Nat.succ n), C (Nat.succ n) x hx", "state_after": "case succ\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nn : \u2115\nn_ih : \u2200 {x : A} (hx : x \u2208 M ^ n), C n x hx\nx : A\n\u22a2 \u2200 (hx : x \u2208 M ^ n * M), C (Nat.succ n) x \u22ef"}, {"tactic": "intro hx", "annotated_tactic": ["intro hx", []], "state_before": "case succ\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nn : \u2115\nn_ih : \u2200 {x : A} (hx : x \u2208 M ^ n), C n x hx\nx : A\n\u22a2 \u2200 (hx : x \u2208 M ^ n * M), C (Nat.succ n) x \u22ef", "state_after": "case succ\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nn : \u2115\nn_ih : \u2200 {x : A} (hx : x \u2208 M ^ n), C n x hx\nx : A\nhx : x \u2208 M ^ n * M\n\u22a2 C (Nat.succ n) x \u22ef"}, {"tactic": "exact\n  Submodule.mul_induction_on' (fun m hm x ih => mul_mem _ _ hm (n_ih _) _ ih)\n    (fun x hx y hy Cx Cy => add _ _ _ _ _ Cx Cy) hx", "annotated_tactic": ["exact\n    <a>Submodule.mul_induction_on'</a> (fun m hm x ih => mul_mem _ _ hm (n_ih _) _ ih)\n      (fun x hx y hy Cx Cy => add _ _ _ _ _ Cx Cy) hx", [{"full_name": "Submodule.mul_induction_on'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Operations.lean", "def_pos": [187, 19], "def_end_pos": [187, 36]}]], "state_before": "case succ\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nn : \u2115\nn_ih : \u2200 {x : A} (hx : x \u2208 M ^ n), C n x hx\nx : A\nhx : x \u2208 M ^ n * M\n\u22a2 C (Nat.succ n) x \u22ef", "state_after": "no goals"}, {"tactic": "rw [pow_zero] at hx", "annotated_tactic": ["rw [<a>pow_zero</a>] at hx", [{"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}]], "state_before": "case zero\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nx : A\nhx : x \u2208 M ^ Nat.zero\n\u22a2 C Nat.zero x hx", "state_after": "case zero\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nx : A\nhx\u271d : x \u2208 M ^ Nat.zero\nhx : x \u2208 1\n\u22a2 C Nat.zero x hx\u271d"}, {"tactic": "obtain \u27e8r, rfl\u27e9 := hx", "annotated_tactic": ["obtain \u27e8r, rfl\u27e9 := hx", []], "state_before": "case zero\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nx : A\nhx\u271d : x \u2208 M ^ Nat.zero\nhx : x \u2208 1\n\u22a2 C Nat.zero x hx\u271d", "state_after": "case zero.intro\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nr : R\nhx : (Algebra.linearMap R A) r \u2208 M ^ Nat.zero\n\u22a2 C Nat.zero ((Algebra.linearMap R A) r) hx"}, {"tactic": "exact algebraMap r", "annotated_tactic": ["exact algebraMap r", []], "state_before": "case zero.intro\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nC : (n : \u2115) \u2192 (x : A) \u2192 x \u2208 M ^ n \u2192 Prop\nalgebraMap : \u2200 (r : R), C 0 ((_root_.algebraMap R A) r) \u22ef\nadd : \u2200 (x y : A) (i : \u2115) (hx : x \u2208 M ^ i) (hy : y \u2208 M ^ i), C i x hx \u2192 C i y hy \u2192 C i (x + y) \u22ef\nmul_mem : \u2200 (i : \u2115) (x : A) (hx : x \u2208 M ^ i), C i x hx \u2192 \u2200 (m : A) (hm : m \u2208 M), C (Nat.succ i) (x * m) \u22ef\nr : R\nhx : (Algebra.linearMap R A) r \u2208 M ^ Nat.zero\n\u22a2 C Nat.zero ((Algebra.linearMap R A) r) hx", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "Monotone.ne_of_lt_of_lt_int", "start": [1152, 1], "end": [1155, 77], "traced_tactics": [{"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Preorder \u03b1\nf : \u2124 \u2192 \u03b1\nhf : Monotone f\nn : \u2124\nx : \u03b1\nh1 : f n < x\nh2 : x < f (n + 1)\na : \u2124\n\u22a2 f a \u2260 x", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Preorder \u03b1\nf : \u2124 \u2192 \u03b1\nhf : Monotone f\nn a : \u2124\nh1 : f n < f a\nh2 : f a < f (n + 1)\n\u22a2 False"}, {"tactic": "exact (hf.reflect_lt h1).not_le (Int.le_of_lt_add_one <| hf.reflect_lt h2)", "annotated_tactic": ["exact (hf.reflect_lt h1).<a>not_le</a> (<a>Int.le_of_lt_add_one</a> <| hf.reflect_lt h2)", [{"full_name": "LT.lt.not_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [348, 7], "def_end_pos": [348, 19]}, {"full_name": "Int.le_of_lt_add_one", "def_path": ".lake/packages/std/Std/Data/Int/Order.lean", "def_pos": [341, 9], "def_end_pos": [341, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : Preorder \u03b1\nf : \u2124 \u2192 \u03b1\nhf : Monotone f\nn a : \u2124\nh1 : f n < f a\nh2 : f a < f (n + 1)\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/EditDistance/Defs.lean", "full_name": "suffixLevenshtein_nil_nil", "start": [203, 1], "end": [204, 6], "traced_tactics": [{"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b9 : AddZeroClass \u03b4\ninst\u271d : Min \u03b4\nC : Cost \u03b1 \u03b2 \u03b4\n\u22a2 \u2191(suffixLevenshtein C [] []) = [0]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "BoundedLatticeHom.coe_copy", "start": [1254, 1], "end": [1255, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/BigOperators.lean", "full_name": "Mathlib.Meta.NormNum.Finset.prod_empty", "start": [326, 1], "end": [328, 12], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b2 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CommSemiring \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Finset.prod \u2205 f = \u21911", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "full_name": "tendstoLocallyUniformlyOn_TFAE", "start": [735, 1], "end": [752, 14], "traced_tactics": [{"tactic": "tfae_have 1 \u2192 2", "annotated_tactic": ["tfae_have 1 \u2192 2", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\n\u22a2 List.TFAE\n    [TendstoLocallyUniformlyOn G g p s, \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K,\n      \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v]", "state_after": "case tfae_1_to_2\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\n\u22a2 TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\n\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\n\u22a2 List.TFAE\n    [TendstoLocallyUniformlyOn G g p s, \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K,\n      \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v]"}, {"tactic": "tfae_have 2 \u2192 3", "annotated_tactic": ["tfae_have 2 \u2192 3", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\n\u22a2 List.TFAE\n    [TendstoLocallyUniformlyOn G g p s, \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K,\n      \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v]", "state_after": "case tfae_2_to_3\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\n\u22a2 (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\n\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\n\u22a2 List.TFAE\n    [TendstoLocallyUniformlyOn G g p s, \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K,\n      \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v]"}, {"tactic": "tfae_have 3 \u2192 1", "annotated_tactic": ["tfae_have 3 \u2192 1", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\n\u22a2 List.TFAE\n    [TendstoLocallyUniformlyOn G g p s, \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K,\n      \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v]", "state_after": "case tfae_3_to_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\n\u22a2 (\u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v) \u2192 TendstoLocallyUniformlyOn G g p s\n\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\ntfae_3_to_1 : (\u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v) \u2192 TendstoLocallyUniformlyOn G g p s\n\u22a2 List.TFAE\n    [TendstoLocallyUniformlyOn G g p s, \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K,\n      \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v]"}, {"tactic": "tfae_finish", "annotated_tactic": ["tfae_finish", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\ntfae_3_to_1 : (\u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v) \u2192 TendstoLocallyUniformlyOn G g p s\n\u22a2 List.TFAE\n    [TendstoLocallyUniformlyOn G g p s, \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K,\n      \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v]", "state_after": "no goals"}, {"tactic": "rintro h K hK1 hK2", "annotated_tactic": ["rintro h K hK1 hK2", []], "state_before": "case tfae_1_to_2\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\n\u22a2 TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K", "state_after": "case tfae_1_to_2\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\nh : TendstoLocallyUniformlyOn G g p s\nK : Set \u03b1\nhK1 : K \u2286 s\nhK2 : IsCompact K\n\u22a2 TendstoUniformlyOn G g p K"}, {"tactic": "exact (tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK2).mp (h.mono hK1)", "annotated_tactic": ["exact (<a>tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact</a> hK2).<a>mp</a> (h.mono hK1)", [{"full_name": "tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/UniformConvergence.lean", "def_pos": [709, 9], "def_end_pos": [709, 68]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "case tfae_1_to_2\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\nh : TendstoLocallyUniformlyOn G g p s\nK : Set \u03b1\nhK1 : K \u2286 s\nhK2 : IsCompact K\n\u22a2 TendstoUniformlyOn G g p K", "state_after": "no goals"}, {"tactic": "rintro h x hx", "annotated_tactic": ["rintro h x hx", []], "state_before": "case tfae_2_to_3\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\n\u22a2 (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v", "state_after": "case tfae_2_to_3\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\nh : \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\nx : \u03b1\nhx : x \u2208 s\n\u22a2 \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v"}, {"tactic": "obtain \u27e8K, \u27e8hK1, hK2\u27e9, hK3\u27e9 := (compact_basis_nhds x).mem_iff.mp (hs.mem_nhds hx)", "annotated_tactic": ["obtain \u27e8K, \u27e8hK1, hK2\u27e9, hK3\u27e9 := (<a>compact_basis_nhds</a> x).mem_iff.mp (hs.mem_nhds hx)", [{"full_name": "compact_basis_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/LocallyCompact.lean", "def_pos": [55, 9], "def_end_pos": [55, 27]}]], "state_before": "case tfae_2_to_3\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\nh : \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\nx : \u03b1\nhx : x \u2208 s\n\u22a2 \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v", "state_after": "case tfae_2_to_3.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\nh : \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\nx : \u03b1\nhx : x \u2208 s\nK : Set \u03b1\nhK3 : K \u2286 s\nhK1 : K \u2208 \ud835\udcdd x\nhK2 : IsCompact K\n\u22a2 \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v"}, {"tactic": "exact \u27e8K, nhdsWithin_le_nhds hK1, h K hK3 hK2\u27e9", "annotated_tactic": ["exact \u27e8K, <a>nhdsWithin_le_nhds</a> hK1, h K hK3 hK2\u27e9", [{"full_name": "nhdsWithin_le_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [201, 9], "def_end_pos": [201, 27]}]], "state_before": "case tfae_2_to_3.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\nh : \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\nx : \u03b1\nhx : x \u2208 s\nK : Set \u03b1\nhK3 : K \u2286 s\nhK1 : K \u2208 \ud835\udcdd x\nhK2 : IsCompact K\n\u22a2 \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v", "state_after": "no goals"}, {"tactic": "rintro h u hu x hx", "annotated_tactic": ["rintro h u hu x hx", []], "state_before": "case tfae_3_to_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\n\u22a2 (\u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v) \u2192 TendstoLocallyUniformlyOn G g p s", "state_after": "case tfae_3_to_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\nh : \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\n\u22a2 \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (g y, G n y) \u2208 u"}, {"tactic": "obtain \u27e8v, hv1, hv2\u27e9 := h x hx", "annotated_tactic": ["obtain \u27e8v, hv1, hv2\u27e9 := h x hx", []], "state_before": "case tfae_3_to_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\nh : \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\n\u22a2 \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (g y, G n y) \u2208 u", "state_after": "case tfae_3_to_1.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\nh : \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\nv : Set \u03b1\nhv1 : v \u2208 \ud835\udcdd[s] x\nhv2 : TendstoUniformlyOn G g p v\n\u22a2 \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (g y, G n y) \u2208 u"}, {"tactic": "exact \u27e8v, hv1, hv2 u hu\u27e9", "annotated_tactic": ["exact \u27e8v, hv1, hv2 u hu\u27e9", []], "state_before": "case tfae_3_to_1.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : UniformSpace \u03b2\nF : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns s' : Set \u03b1\nx\u271d : \u03b1\np\u271d : Filter \u03b9\np' : Filter \u03b1\ng\u271d : \u03b9 \u2192 \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyCompactSpace \u03b1\nG : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\np : Filter \u03b9\nhs : IsOpen s\ntfae_1_to_2 : TendstoLocallyUniformlyOn G g p s \u2192 \u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K\ntfae_2_to_3 : (\u2200 K \u2286 s, IsCompact K \u2192 TendstoUniformlyOn G g p K) \u2192 \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\nh : \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v\nu : Set (\u03b2 \u00d7 \u03b2)\nhu : u \u2208 \ud835\udce4 \u03b2\nx : \u03b1\nhx : x \u2208 s\nv : Set \u03b1\nhv1 : v \u2208 \ud835\udcdd[s] x\nhv2 : TendstoUniformlyOn G g p v\n\u22a2 \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (g y, G n y) \u2208 u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.cons_eq_zero_iff", "start": [572, 1], "end": [576, 38], "traced_tactics": [{"tactic": "convert congr_arg vecTail h", "annotated_tactic": ["convert <a>congr_arg</a> <a>vecTail</a> h", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "Matrix.vecTail", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [98, 5], "def_end_pos": [98, 12]}]], "state_before": "\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Zero \u03b1\nv : Fin n \u2192 \u03b1\nx : \u03b1\nh : vecCons x v = 0\n\u22a2 v = 0", "state_after": "no goals"}, {"tactic": "simp [hx, hv]", "annotated_tactic": ["simp [hx, hv]", []], "state_before": "\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Zero \u03b1\nv : Fin n \u2192 \u03b1\nx : \u03b1\nx\u271d : x = 0 \u2227 v = 0\nhx : x = 0\nhv : v = 0\n\u22a2 vecCons x v = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isBigO_iff_eventually_isBigOWith", "start": [255, 1], "end": [257, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Ring.lean", "full_name": "neg_one_sq", "start": [145, 1], "end": [145, 67], "traced_tactics": [{"tactic": "simp [neg_sq, one_pow]", "annotated_tactic": ["simp [<a>neg_sq</a>, <a>one_pow</a>]", [{"full_name": "neg_sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [141, 9], "def_end_pos": [141, 15]}, {"full_name": "one_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [75, 9], "def_end_pos": [75, 16]}]], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : Monoid R\ninst\u271d : HasDistribNeg R\n\u22a2 (-1) ^ 2 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Determinant.lean", "full_name": "LinearMap.detAux_id", "start": [153, 1], "end": [154, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Divisors.lean", "full_name": "Nat.pos_of_mem_divisors", "start": [200, 1], "end": [204, 21], "traced_tactics": [{"tactic": "cases m", "annotated_tactic": ["cases m", []], "state_before": "n m : \u2115\nh : m \u2208 divisors n\n\u22a2 0 < m", "state_after": "case zero\nn : \u2115\nh : zero \u2208 divisors n\n\u22a2 0 < zero\n\ncase succ\nn n\u271d : \u2115\nh : succ n\u271d \u2208 divisors n\n\u22a2 0 < succ n\u271d"}, {"tactic": "apply Nat.succ_pos", "annotated_tactic": ["apply <a>Nat.succ_pos</a>", [{"full_name": "Nat.succ_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1674, 9], "def_end_pos": [1674, 21]}]], "state_before": "case succ\nn n\u271d : \u2115\nh : succ n\u271d \u2208 divisors n\n\u22a2 0 < succ n\u271d", "state_after": "no goals"}, {"tactic": "rw [mem_divisors, zero_eq, zero_dvd_iff (a := n)] at h", "annotated_tactic": ["rw [<a>mem_divisors</a>, <a>zero_eq</a>, <a>zero_dvd_iff</a> (a := n)] at h", [{"full_name": "Nat.mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [96, 9], "def_end_pos": [96, 21]}, {"full_name": "Nat.zero_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [83, 17], "def_end_pos": [83, 24]}, {"full_name": "zero_dvd_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean", "def_pos": [33, 9], "def_end_pos": [33, 21]}]], "state_before": "case zero\nn : \u2115\nh : zero \u2208 divisors n\n\u22a2 0 < zero", "state_after": "case zero\nn : \u2115\nh : n = 0 \u2227 n \u2260 0\n\u22a2 0 < zero"}, {"tactic": "cases h.2 h.1", "annotated_tactic": ["cases h.2 h.1", []], "state_before": "case zero\nn : \u2115\nh : n = 0 \u2227 n \u2260 0\n\u22a2 0 < zero", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Ker.lean", "full_name": "LinearMap.ker_toAddSubgroup", "start": [183, 1], "end": [184, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupClosed.lean", "full_name": "supClosed_empty", "start": [44, 1], "end": [44, 77], "traced_tactics": [{"tactic": "simp [SupClosed]", "annotated_tactic": ["simp [<a>SupClosed</a>]", [{"full_name": "SupClosed", "def_path": ".lake/packages/mathlib/Mathlib/Order/SupClosed.lean", "def_pos": [42, 5], "def_end_pos": [42, 14]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeSup \u03b2\n\u03b9 : Sort u_4\nS : Set (Set \u03b1)\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b1\na : \u03b1\n\u22a2 SupClosed \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "Prod.tendsto_iff", "start": [579, 1], "end": [582, 46], "traced_tactics": [{"tactic": "rw [nhds_prod_eq, Filter.tendsto_prod_iff']", "annotated_tactic": ["rw [<a>nhds_prod_eq</a>, <a>Filter.tendsto_prod_iff'</a>]", [{"full_name": "nhds_prod_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [534, 9], "def_end_pos": [534, 21]}, {"full_name": "Filter.tendsto_prod_iff'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [459, 9], "def_end_pos": [459, 26]}]], "state_before": "X\u271d : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nX : Type u_5\nseq : X \u2192 Y \u00d7 Z\nf : Filter X\np : Y \u00d7 Z\n\u22a2 Tendsto seq f (\ud835\udcdd p) \u2194 Tendsto (fun n => (seq n).1) f (\ud835\udcdd p.1) \u2227 Tendsto (fun n => (seq n).2) f (\ud835\udcdd p.2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Control/ForInStep/Lemmas.lean", "full_name": "ForInStep.bind_yield", "start": [12, 9], "end": [13, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Lift.lean", "full_name": "Filter.mem_lift'", "start": [248, 1], "end": [249, 101], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "dist_triangle_right", "start": [195, 1], "end": [196, 40], "traced_tactics": [{"tactic": "rw [dist_comm y]", "annotated_tactic": ["rw [<a>dist_comm</a> y]", [{"full_name": "dist_comm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [179, 9], "def_end_pos": [179, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\n\u22a2 dist x y \u2264 dist x z + dist y z", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\n\u22a2 dist x y \u2264 dist x z + dist z y"}, {"tactic": "apply dist_triangle", "annotated_tactic": ["apply <a>dist_triangle</a>", [{"full_name": "dist_triangle", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [187, 9], "def_end_pos": [187, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\n\u22a2 dist x y \u2264 dist x z + dist z y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Control/Lawful.lean", "full_name": "ExceptT.run_monadLift", "start": [124, 1], "end": [126, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "IsClosed.sInf_mem", "start": [1968, 1], "end": [1970, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.fst_injective", "start": [150, 1], "end": [151, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Real.lean", "full_name": "ENNReal.toReal_le_add'", "start": [114, 1], "end": [117, 56], "traced_tactics": [{"tactic": "refine le_trans (toReal_mono' hle ?_) toReal_add_le", "annotated_tactic": ["refine <a>le_trans</a> (<a>toReal_mono'</a> hle ?_) <a>toReal_add_le</a>", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "ENNReal.toReal_mono'", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [88, 9], "def_end_pos": [88, 21]}, {"full_name": "ENNReal.toReal_add_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [58, 9], "def_end_pos": [58, 22]}]], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhle : a \u2264 b + c\nhb : b = \u22a4 \u2192 a = \u22a4\nhc : c = \u22a4 \u2192 a = \u22a4\n\u22a2 a.toReal \u2264 b.toReal + c.toReal", "state_after": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhle : a \u2264 b + c\nhb : b = \u22a4 \u2192 a = \u22a4\nhc : c = \u22a4 \u2192 a = \u22a4\n\u22a2 b + c = \u22a4 \u2192 a = \u22a4"}, {"tactic": "simpa only [add_eq_top, or_imp] using And.intro hb hc", "annotated_tactic": ["simpa only [<a>add_eq_top</a>, <a>or_imp</a>] using <a>And.intro</a> hb hc", [{"full_name": "ENNReal.add_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Operations.lean", "def_pos": [187, 17], "def_end_pos": [187, 27]}, {"full_name": "or_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 15]}, {"full_name": "And.intro", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [514, 3], "def_end_pos": [514, 8]}]], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhle : a \u2264 b + c\nhb : b = \u22a4 \u2192 a = \u22a4\nhc : c = \u22a4 \u2192 a = \u22a4\n\u22a2 b + c = \u22a4 \u2192 a = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean", "full_name": "ArithmeticFunction.sum_eq_iff_sum_smul_moebius_eq_on", "start": [1281, 1], "end": [1304, 19], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\n\u22a2 (\u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n) \u2194 \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n", "state_after": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\n\u22a2 (\u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n) \u2192 \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\n\ncase mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\n\u22a2 (\u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n) \u2192 \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\n\u22a2 (\u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n) \u2192 \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n", "state_after": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\n\u22a2 \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n"}, {"tactic": "let G := fun (n:\u2115) => (\u2211 i in n.divisors, f i)", "annotated_tactic": ["let G := fun (n:\u2115) => (\u2211 i in n.divisors, f i)", []], "state_before": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\n\u22a2 \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n", "state_after": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\n\u22a2 \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n"}, {"tactic": "intro n hn hnP", "annotated_tactic": ["intro n hn hnP", []], "state_before": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\n\u22a2 \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n", "state_after": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n"}, {"tactic": "suffices \u2211 d in n.divisors, \u03bc (n/d) \u2022 G d = f n from by\n  rw [Nat.sum_divisorsAntidiagonal' (f := fun x y => \u03bc x \u2022 g y), \u2190 this, sum_congr rfl]\n  intro d hd\n  rw [\u2190 h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]", "annotated_tactic": ["suffices \u2211 d in n.divisors, \u03bc (n/d) \u2022 G d = f n from by\n      rw [<a>Nat.sum_divisorsAntidiagonal'</a> (f := fun x y => \u03bc x \u2022 g y), \u2190 this, <a>sum_congr</a> <a>rfl</a>]\n      intro d hd\n      rw [\u2190 h d (<a>Nat.pos_of_mem_divisors</a> hd) <| hs d n (<a>Nat.dvd_of_mem_divisors</a> hd) hnP]", [{"full_name": "Nat.sum_divisorsAntidiagonal'", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [521, 3], "def_end_pos": [521, 14]}, {"full_name": "Finset.sum_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [381, 3], "def_end_pos": [381, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Nat.pos_of_mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [200, 9], "def_end_pos": [200, 28]}, {"full_name": "Nat.dvd_of_mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [110, 9], "def_end_pos": [110, 28]}]], "state_before": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n", "state_after": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 d in divisors n, \u03bc (n / d) \u2022 G d = f n"}, {"tactic": "rw [\u2190 Nat.sum_divisorsAntidiagonal' (f := fun x y => \u03bc x \u2022 G y)]", "annotated_tactic": ["rw [\u2190 <a>Nat.sum_divisorsAntidiagonal'</a> (f := fun x y => \u03bc x \u2022 G y)]", [{"full_name": "Nat.sum_divisorsAntidiagonal'", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [521, 3], "def_end_pos": [521, 14]}]], "state_before": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 d in divisors n, \u03bc (n / d) \u2022 G d = f n", "state_after": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 i in divisorsAntidiagonal n, \u03bc i.1 \u2022 G i.2 = f n"}, {"tactic": "apply sum_eq_iff_sum_smul_moebius_eq.mp _ n hn", "annotated_tactic": ["apply sum_eq_iff_sum_smul_moebius_eq.mp _ n hn", []], "state_before": "case mp\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 i in divisorsAntidiagonal n, \u03bc i.1 \u2022 G i.2 = f n", "state_after": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2200 n > 0, \u2211 i in divisors n, f i = G n"}, {"tactic": "intro _ _", "annotated_tactic": ["intro _ _", []], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2200 n > 0, \u2211 i in divisors n, f i = G n", "state_after": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nn\u271d : \u2115\na\u271d : n\u271d > 0\n\u22a2 \u2211 i in divisors n\u271d, f i = G n\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nn\u271d : \u2115\na\u271d : n\u271d > 0\n\u22a2 \u2211 i in divisors n\u271d, f i = G n\u271d", "state_after": "no goals"}, {"tactic": "rw [Nat.sum_divisorsAntidiagonal' (f := fun x y => \u03bc x \u2022 g y), \u2190 this, sum_congr rfl]", "annotated_tactic": ["rw [<a>Nat.sum_divisorsAntidiagonal'</a> (f := fun x y => \u03bc x \u2022 g y), \u2190 this, <a>sum_congr</a> <a>rfl</a>]", [{"full_name": "Nat.sum_divisorsAntidiagonal'", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [521, 3], "def_end_pos": [521, 14]}, {"full_name": "Finset.sum_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [381, 3], "def_end_pos": [381, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, \u03bc (n / d) \u2022 G d = f n\n\u22a2 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n", "state_after": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, \u03bc (n / d) \u2022 G d = f n\n\u22a2 \u2200 x \u2208 divisors n, \u03bc (n / x) \u2022 g x = \u03bc (n / x) \u2022 G x"}, {"tactic": "intro d hd", "annotated_tactic": ["intro d hd", []], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, \u03bc (n / d) \u2022 G d = f n\n\u22a2 \u2200 x \u2208 divisors n, \u03bc (n / x) \u2022 g x = \u03bc (n / x) \u2022 G x", "state_after": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, \u03bc (n / d) \u2022 G d = f n\nd : \u2115\nhd : d \u2208 divisors n\n\u22a2 \u03bc (n / d) \u2022 g d = \u03bc (n / d) \u2022 G d"}, {"tactic": "rw [\u2190 h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]", "annotated_tactic": ["rw [\u2190 h d (<a>Nat.pos_of_mem_divisors</a> hd) <| hs d n (<a>Nat.dvd_of_mem_divisors</a> hd) hnP]", [{"full_name": "Nat.pos_of_mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [200, 9], "def_end_pos": [200, 28]}, {"full_name": "Nat.dvd_of_mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [110, 9], "def_end_pos": [110, 28]}]], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n\nG : \u2115 \u2192 R := fun n => \u2211 i in divisors n, f i\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, \u03bc (n / d) \u2022 G d = f n\nd : \u2115\nhd : d \u2208 divisors n\n\u22a2 \u03bc (n / d) \u2022 g d = \u03bc (n / d) \u2022 G d", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\n\u22a2 (\u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n) \u2192 \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n", "state_after": "case mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\n\u22a2 \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n"}, {"tactic": "let F := fun (n:\u2115) => \u2211 x : \u2115 \u00d7 \u2115 in n.divisorsAntidiagonal, \u03bc x.fst \u2022 g x.snd", "annotated_tactic": ["let F := fun (n:\u2115) => \u2211 x : \u2115 \u00d7 \u2115 in n.divisorsAntidiagonal, \u03bc x.fst \u2022 g x.snd", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\n\u22a2 \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n", "state_after": "case mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\n\u22a2 \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n"}, {"tactic": "intro n hn hnP", "annotated_tactic": ["intro n hn hnP", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\n\u22a2 \u2200 n > 0, n \u2208 s \u2192 \u2211 i in divisors n, f i = g n", "state_after": "case mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 i in divisors n, f i = g n"}, {"tactic": "suffices \u2211 d in n.divisors, F d = g n from by\n  rw [\u2190 this, sum_congr rfl]\n  intro d hd\n  rw [\u2190 h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]", "annotated_tactic": ["suffices \u2211 d in n.divisors, F d = g n from by\n      rw [\u2190 this, <a>sum_congr</a> <a>rfl</a>]\n      intro d hd\n      rw [\u2190 h d (<a>Nat.pos_of_mem_divisors</a> hd) <| hs d n (<a>Nat.dvd_of_mem_divisors</a> hd) hnP]", [{"full_name": "Finset.sum_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [381, 3], "def_end_pos": [381, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Nat.pos_of_mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [200, 9], "def_end_pos": [200, 28]}, {"full_name": "Nat.dvd_of_mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [110, 9], "def_end_pos": [110, 28]}]], "state_before": "case mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 i in divisors n, f i = g n", "state_after": "case mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 d in divisors n, F d = g n"}, {"tactic": "apply sum_eq_iff_sum_smul_moebius_eq.mpr _ n hn", "annotated_tactic": ["apply sum_eq_iff_sum_smul_moebius_eq.mpr _ n hn", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2211 d in divisors n, F d = g n", "state_after": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2200 n > 0, \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = F n"}, {"tactic": "intro _ _", "annotated_tactic": ["intro _ _", []], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\n\u22a2 \u2200 n > 0, \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = F n", "state_after": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nn\u271d : \u2115\na\u271d : n\u271d > 0\n\u22a2 \u2211 x in divisorsAntidiagonal n\u271d, \u03bc x.1 \u2022 g x.2 = F n\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nn\u271d : \u2115\na\u271d : n\u271d > 0\n\u22a2 \u2211 x in divisorsAntidiagonal n\u271d, \u03bc x.1 \u2022 g x.2 = F n\u271d", "state_after": "no goals"}, {"tactic": "rw [\u2190 this, sum_congr rfl]", "annotated_tactic": ["rw [\u2190 this, <a>sum_congr</a> <a>rfl</a>]", [{"full_name": "Finset.sum_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [381, 3], "def_end_pos": [381, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, F d = g n\n\u22a2 \u2211 i in divisors n, f i = g n", "state_after": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, F d = g n\n\u22a2 \u2200 x \u2208 divisors n, f x = F x"}, {"tactic": "intro d hd", "annotated_tactic": ["intro d hd", []], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, F d = g n\n\u22a2 \u2200 x \u2208 divisors n, f x = F x", "state_after": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, F d = g n\nd : \u2115\nhd : d \u2208 divisors n\n\u22a2 f d = F d"}, {"tactic": "rw [\u2190 h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]", "annotated_tactic": ["rw [\u2190 h d (<a>Nat.pos_of_mem_divisors</a> hd) <| hs d n (<a>Nat.dvd_of_mem_divisors</a> hd) hnP]", [{"full_name": "Nat.pos_of_mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [200, 9], "def_end_pos": [200, 28]}, {"full_name": "Nat.dvd_of_mem_divisors", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [110, 9], "def_end_pos": [110, 28]}]], "state_before": "R : Type u_1\ninst\u271d : AddCommGroup R\nf g : \u2115 \u2192 R\ns : Set \u2115\nhs : \u2200 (m n : \u2115), m \u2223 n \u2192 n \u2208 s \u2192 m \u2208 s\nh : \u2200 n > 0, n \u2208 s \u2192 \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2 = f n\nF : \u2115 \u2192 R := fun n => \u2211 x in divisorsAntidiagonal n, \u03bc x.1 \u2022 g x.2\nn : \u2115\nhn : n > 0\nhnP : n \u2208 s\nthis : \u2211 d in divisors n, F d = g n\nd : \u2115\nhd : d \u2208 divisors n\n\u22a2 f d = F d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/CommRing.lean", "full_name": "MvPolynomial.totalDegree_neg", "start": [203, 1], "end": [204, 39], "traced_tactics": [{"tactic": "simp only [totalDegree, support_neg]", "annotated_tactic": ["simp only [<a>totalDegree</a>, <a>support_neg</a>]", [{"full_name": "MvPolynomial.totalDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [356, 5], "def_end_pos": [356, 16]}, {"full_name": "MvPolynomial.support_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/CommRing.lean", "def_pos": [83, 9], "def_end_pos": [83, 20]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommRing R\np q a : MvPolynomial \u03c3 R\n\u22a2 totalDegree (-a) = totalDegree a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "full_name": "NonUnitalSubring.coe_set_mk", "start": [169, 1], "end": [171, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Lifts.lean", "full_name": "Polynomial.X_mem_lifts", "start": [96, 1], "end": [99, 21], "traced_tactics": [{"tactic": "simp only [coe_mapRingHom, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true, map_X,\n  and_self_iff]", "annotated_tactic": ["simp only [<a>coe_mapRingHom</a>, <a>Set.mem_univ</a>, <a>Subsemiring.coe_top</a>, <a>eq_self_iff_true</a>, <a>map_X</a>,\n      <a>and_self_iff</a>]", [{"full_name": "Polynomial.coe_mapRingHom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [772, 9], "def_end_pos": [772, 23]}, {"full_name": "Set.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [82, 29], "def_end_pos": [82, 37]}, {"full_name": "Subsemiring.coe_top", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Subsemiring/Basic.lean", "def_pos": [430, 9], "def_end_pos": [430, 16]}, {"full_name": "eq_self_iff_true", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1368, 9], "def_end_pos": [1368, 25]}, {"full_name": "Polynomial.map_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [720, 9], "def_end_pos": [720, 14]}, {"full_name": "and_self_iff", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [20, 9], "def_end_pos": [20, 21]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf\u271d f : R \u2192+* S\n\u22a2 (mapRingHom f) X = X", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.lintegral_iInf", "start": [1050, 1], "end": [1052, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Subsingleton.atBot_eq", "start": [330, 1], "end": [331, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Basic.lean", "full_name": "ENNReal.toNNReal_eq_toNNReal_iff'", "start": [448, 1], "end": [450, 91], "traced_tactics": [{"tactic": "simp only [ENNReal.toNNReal_eq_toNNReal_iff x y, hx, hy, and_false, false_and, or_false]", "annotated_tactic": ["simp only [<a>ENNReal.toNNReal_eq_toNNReal_iff</a> x y, hx, hy, <a>and_false</a>, <a>false_and</a>, <a>or_false</a>]", [{"full_name": "ENNReal.toNNReal_eq_toNNReal_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [438, 9], "def_end_pos": [438, 33]}, {"full_name": "and_false", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [103, 17], "def_end_pos": [103, 26]}, {"full_name": "false_and", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [104, 17], "def_end_pos": [104, 26]}, {"full_name": "or_false", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [113, 17], "def_end_pos": [113, 25]}]], "state_before": "\u03b1 : Type u_1\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y : \u211d\u22650\u221e\nhx : x \u2260 \u22a4\nhy : y \u2260 \u22a4\n\u22a2 x.toNNReal = y.toNNReal \u2194 x = y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/NonUnitalHom.lean", "full_name": "NonUnitalAlgHom.map_add", "start": [243, 11], "end": [244, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Intervals.lean", "full_name": "Finset.prod_range_add_one_eq_factorial", "start": [247, 1], "end": [249, 87], "traced_tactics": [{"tactic": "simp [factorial, Finset.range_succ, prod_range_add_one_eq_factorial n]", "annotated_tactic": ["simp [<a>factorial</a>, <a>Finset.range_succ</a>, prod_range_add_one_eq_factorial n]", [{"full_name": "Nat.factorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [30, 5], "def_end_pos": [30, 14]}, {"full_name": "Finset.range_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3146, 9], "def_end_pos": [3146, 19]}]], "state_before": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : CommMonoid M\ns\u2082 s\u2081 s : Finset \u03b1\na : \u03b1\ng f : \u03b1 \u2192 M\nn : \u2115\n\u22a2 \u220f x in range (n + 1), (x + 1) = (n + 1)!", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "IsCompact.mem_closure_iff_exists_inseparable", "start": [978, 1], "end": [986, 47], "traced_tactics": [{"tactic": "refine \u27e8fun hy \u21a6 ?_, fun \u27e8x, hxK, hxy\u27e9 \u21a6\n  (hxy.mem_closed_iff isClosed_closure).1 <| subset_closure hxK\u27e9", "annotated_tactic": ["refine \u27e8fun hy \u21a6 ?_, fun \u27e8x, hxK, hxy\u27e9 \u21a6\n    (hxy.mem_closed_iff <a>isClosed_closure</a>).1 <| <a>subset_closure</a> hxK\u27e9", [{"full_name": "isClosed_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [392, 9], "def_end_pos": [392, 25]}, {"full_name": "subset_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [396, 9], "def_end_pos": [396, 23]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R1Space X\nx y : X\nK : Set X\nhK : IsCompact K\n\u22a2 y \u2208 closure K \u2194 \u2203 x \u2208 K, Inseparable x y", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R1Space X\nx y : X\nK : Set X\nhK : IsCompact K\nhy : y \u2208 closure K\n\u22a2 \u2203 x \u2208 K, Inseparable x y"}, {"tactic": "contrapose! hy", "annotated_tactic": ["contrapose! hy", []], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R1Space X\nx y : X\nK : Set X\nhK : IsCompact K\nhy : y \u2208 closure K\n\u22a2 \u2203 x \u2208 K, Inseparable x y", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R1Space X\nx y : X\nK : Set X\nhK : IsCompact K\nhy : \u2200 x \u2208 K, \u00acInseparable x y\n\u22a2 y \u2209 closure K"}, {"tactic": "have : Disjoint (\ud835\udcdd y) (\ud835\udcdd\u02e2 K) := hK.disjoint_nhdsSet_right.2 fun x hx \u21a6\n  (disjoint_nhds_nhds_iff_not_inseparable.2 (hy x hx)).symm", "annotated_tactic": ["have : <a>Disjoint</a> (\ud835\udcdd y) (\ud835\udcdd\u02e2 K) := hK.disjoint_nhdsSet_right.2 fun x hx \u21a6\n    (<a>disjoint_nhds_nhds_iff_not_inseparable</a>.2 (hy x hx)).<a>symm</a>", [{"full_name": "Disjoint", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [42, 5], "def_end_pos": [42, 13]}, {"full_name": "disjoint_nhds_nhds_iff_not_inseparable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [959, 9], "def_end_pos": [959, 47]}, {"full_name": "Disjoint.symm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [55, 9], "def_end_pos": [55, 22]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R1Space X\nx y : X\nK : Set X\nhK : IsCompact K\nhy : \u2200 x \u2208 K, \u00acInseparable x y\n\u22a2 y \u2209 closure K", "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R1Space X\nx y : X\nK : Set X\nhK : IsCompact K\nhy : \u2200 x \u2208 K, \u00acInseparable x y\nthis : Disjoint (\ud835\udcdd y) (\ud835\udcdd\u02e2 K)\n\u22a2 y \u2209 closure K"}, {"tactic": "simpa only [disjoint_iff, not_mem_closure_iff_nhdsWithin_eq_bot]\n  using this.mono_right principal_le_nhdsSet", "annotated_tactic": ["simpa only [<a>disjoint_iff</a>, <a>not_mem_closure_iff_nhdsWithin_eq_bot</a>]\n    using this.mono_right <a>principal_le_nhdsSet</a>", [{"full_name": "disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "not_mem_closure_iff_nhdsWithin_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1251, 7], "def_end_pos": [1251, 44]}, {"full_name": "principal_le_nhdsSet", "def_path": ".lake/packages/mathlib/Mathlib/Topology/NhdsSet.lean", "def_pos": [97, 9], "def_end_pos": [97, 29]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : R1Space X\nx y : X\nK : Set X\nhK : IsCompact K\nhy : \u2200 x \u2208 K, \u00acInseparable x y\nthis : Disjoint (\ud835\udcdd y) (\ud835\udcdd\u02e2 K)\n\u22a2 y \u2209 closure K", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Compact.lean", "full_name": "IsCompact.uniformContinuousOn_of_continuous", "start": [177, 1], "end": [182, 56], "traced_tactics": [{"tactic": "rw [uniformContinuousOn_iff_restrict]", "annotated_tactic": ["rw [<a>uniformContinuousOn_iff_restrict</a>]", [{"full_name": "uniformContinuousOn_iff_restrict", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [1477, 9], "def_end_pos": [1477, 41]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : IsCompact s\nhf : ContinuousOn f s\n\u22a2 UniformContinuousOn f s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : IsCompact s\nhf : ContinuousOn f s\n\u22a2 UniformContinuous (restrict s f)"}, {"tactic": "rw [isCompact_iff_compactSpace] at hs", "annotated_tactic": ["rw [<a>isCompact_iff_compactSpace</a>] at hs", [{"full_name": "isCompact_iff_compactSpace", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/Compact.lean", "def_pos": [957, 9], "def_end_pos": [957, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : IsCompact s\nhf : ContinuousOn f s\n\u22a2 UniformContinuous (restrict s f)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : CompactSpace \u2191s\nhf : ContinuousOn f s\n\u22a2 UniformContinuous (restrict s f)"}, {"tactic": "rw [continuousOn_iff_continuous_restrict] at hf", "annotated_tactic": ["rw [<a>continuousOn_iff_continuous_restrict</a>] at hf", [{"full_name": "continuousOn_iff_continuous_restrict", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [653, 9], "def_end_pos": [653, 45]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : CompactSpace \u2191s\nhf : ContinuousOn f s\n\u22a2 UniformContinuous (restrict s f)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : CompactSpace \u2191s\nhf : Continuous (restrict s f)\n\u22a2 UniformContinuous (restrict s f)"}, {"tactic": "exact CompactSpace.uniformContinuous_of_continuous hf", "annotated_tactic": ["exact <a>CompactSpace.uniformContinuous_of_continuous</a> hf", [{"full_name": "CompactSpace.uniformContinuous_of_continuous", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Compact.lean", "def_pos": [167, 9], "def_end_pos": [167, 53]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : CompactSpace \u2191s\nhf : Continuous (restrict s f)\n\u22a2 UniformContinuous (restrict s f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/OrderClosed.lean", "full_name": "Ico_mem_nhds", "start": [775, 1], "end": [776, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "Continuous.subtype_map", "start": [1114, 1], "end": [1116, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/GroupWithZero.lean", "full_name": "Homeomorph.coe_mulRight\u2080", "start": [295, 1], "end": [296, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "divp_assoc'", "start": [502, 1], "end": [503, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "full_name": "DifferentiableAt.prod_map", "start": [371, 11], "end": [373, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousOn.lean", "full_name": "continuousWithinAt_inter", "start": [763, 1], "end": [765, 54], "traced_tactics": [{"tactic": "simp [ContinuousWithinAt, nhdsWithin_restrict' s h]", "annotated_tactic": ["simp [<a>ContinuousWithinAt</a>, <a>nhdsWithin_restrict'</a> s h]", [{"full_name": "ContinuousWithinAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [163, 5], "def_end_pos": [163, 23]}, {"full_name": "nhdsWithin_restrict'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [188, 9], "def_end_pos": [188, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\nx : \u03b1\nh : t \u2208 \ud835\udcdd x\n\u22a2 ContinuousWithinAt f (s \u2229 t) x \u2194 ContinuousWithinAt f s x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Adjoin.lean", "full_name": "IntermediateField.exists_lt_finrank_of_infinite_dimensional", "start": [1189, 1], "end": [1204, 59], "traced_tactics": [{"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "F : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 n < finrank F \u21a5L", "state_after": "case zero\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.zero < finrank F \u21a5L\n\ncase succ\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nih : \u2203 L, FiniteDimensional F \u21a5L \u2227 n < finrank F \u21a5L\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L"}, {"tactic": "obtain \u27e8L, fin, hn\u27e9 := ih", "annotated_tactic": ["obtain \u27e8L, fin, hn\u27e9 := ih", []], "state_before": "case succ\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nih : \u2203 L, FiniteDimensional F \u21a5L \u2227 n < finrank F \u21a5L\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L", "state_after": "case succ.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L"}, {"tactic": "obtain \u27e8x, hx\u27e9 : \u2203 x : E, x \u2209 L := by\n  contrapose! hnfd\n  rw [show L = \u22a4 from eq_top_iff.2 fun x _ \u21a6 hnfd x] at fin\n  exact topEquiv.toLinearEquiv.finiteDimensional", "annotated_tactic": ["obtain \u27e8x, hx\u27e9 : \u2203 x : E, x \u2209 L := by\n    contrapose! hnfd\n    rw [show L = \u22a4 from <a>eq_top_iff</a>.2 fun x _ \u21a6 hnfd x] at fin\n    exact topEquiv.toLinearEquiv.finiteDimensional", [{"full_name": "eq_top_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [133, 9], "def_end_pos": [133, 19]}]], "state_before": "case succ.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L", "state_after": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L"}, {"tactic": "let L' := L \u2294 F\u27eex\u27ef", "annotated_tactic": ["let L' := L \u2294 F\u27eex\u27ef", []], "state_before": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L", "state_after": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L"}, {"tactic": "haveI := adjoin.finiteDimensional (halg x).isIntegral", "annotated_tactic": ["haveI := <a>adjoin.finiteDimensional</a> (halg x).<a>isIntegral</a>", [{"full_name": "IntermediateField.adjoin.finiteDimensional", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [1137, 9], "def_end_pos": [1137, 33]}, {"full_name": "IsAlgebraic.isIntegral", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Algebraic.lean", "def_pos": [232, 8], "def_end_pos": [232, 30]}]], "state_before": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L", "state_after": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\nthis : FiniteDimensional F \u21a5F\u27eex\u27ef\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L"}, {"tactic": "refine \u27e8L', inferInstance, by_contra fun h \u21a6 ?_\u27e9", "annotated_tactic": ["refine \u27e8L', <a>inferInstance</a>, <a>by_contra</a> fun h \u21a6 ?_\u27e9", [{"full_name": "inferInstance", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [99, 8], "def_end_pos": [99, 21]}, {"full_name": "by_contra", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [222, 7], "def_end_pos": [222, 16]}]], "state_before": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\nthis : FiniteDimensional F \u21a5F\u27eex\u27ef\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.succ n < finrank F \u21a5L", "state_after": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\nthis : FiniteDimensional F \u21a5F\u27eex\u27ef\nh : \u00acNat.succ n < finrank F \u21a5L'\n\u22a2 False"}, {"tactic": "have h1 : L = L' := eq_of_le_of_finrank_le le_sup_left ((not_lt.1 h).trans hn)", "annotated_tactic": ["have h1 : L = L' := <a>eq_of_le_of_finrank_le</a> <a>le_sup_left</a> ((<a>not_lt</a>.1 h).<a>trans</a> hn)", [{"full_name": "IntermediateField.eq_of_le_of_finrank_le", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/IntermediateField.lean", "def_pos": [775, 9], "def_end_pos": [775, 31]}, {"full_name": "le_sup_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [112, 9], "def_end_pos": [112, 20]}, {"full_name": "not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 15]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}]], "state_before": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\nthis : FiniteDimensional F \u21a5F\u27eex\u27ef\nh : \u00acNat.succ n < finrank F \u21a5L'\n\u22a2 False", "state_after": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\nthis : FiniteDimensional F \u21a5F\u27eex\u27ef\nh : \u00acNat.succ n < finrank F \u21a5L'\nh1 : L = L'\n\u22a2 False"}, {"tactic": "have h2 : F\u27eex\u27ef \u2264 L' := le_sup_right", "annotated_tactic": ["have h2 : F\u27eex\u27ef \u2264 L' := <a>le_sup_right</a>", [{"full_name": "le_sup_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [121, 9], "def_end_pos": [121, 21]}]], "state_before": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\nthis : FiniteDimensional F \u21a5F\u27eex\u27ef\nh : \u00acNat.succ n < finrank F \u21a5L'\nh1 : L = L'\n\u22a2 False", "state_after": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\nthis : FiniteDimensional F \u21a5F\u27eex\u27ef\nh : \u00acNat.succ n < finrank F \u21a5L'\nh1 : L = L'\nh2 : F\u27eex\u27ef \u2264 L'\n\u22a2 False"}, {"tactic": "exact hx <| (h1.symm \u25b8 h2) <| mem_adjoin_simple_self F x", "annotated_tactic": ["exact hx <| (h1.symm \u25b8 h2) <| <a>mem_adjoin_simple_self</a> F x", [{"full_name": "IntermediateField.mem_adjoin_simple_self", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [595, 9], "def_end_pos": [595, 31]}]], "state_before": "case succ.intro.intro.intro\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nx : E\nhx : x \u2209 L\nL' : IntermediateField F E := L \u2294 F\u27eex\u27ef\nthis : FiniteDimensional F \u21a5F\u27eex\u27ef\nh : \u00acNat.succ n < finrank F \u21a5L'\nh1 : L = L'\nh2 : F\u27eex\u27ef \u2264 L'\n\u22a2 False", "state_after": "no goals"}, {"tactic": "exact \u27e8\u22a5, Subalgebra.finiteDimensional_bot, finrank_pos\u27e9", "annotated_tactic": ["exact \u27e8\u22a5, <a>Subalgebra.finiteDimensional_bot</a>, <a>finrank_pos</a>\u27e9", [{"full_name": "Subalgebra.finiteDimensional_bot", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FiniteDimensional.lean", "def_pos": [1146, 10], "def_end_pos": [1146, 42]}, {"full_name": "FiniteDimensional.finrank_pos", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finite.lean", "def_pos": [378, 9], "def_end_pos": [378, 38]}]], "state_before": "case zero\nF : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\n\u22a2 \u2203 L, FiniteDimensional F \u21a5L \u2227 Nat.zero < finrank F \u21a5L", "state_after": "no goals"}, {"tactic": "contrapose! hnfd", "annotated_tactic": ["contrapose! hnfd", []], "state_before": "F : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nhnfd : \u00acFiniteDimensional F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\n\u22a2 \u2203 x, x \u2209 L", "state_after": "F : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nhnfd : \u2200 (x : E), x \u2208 L\n\u22a2 FiniteDimensional F E"}, {"tactic": "rw [show L = \u22a4 from eq_top_iff.2 fun x _ \u21a6 hnfd x] at fin", "annotated_tactic": ["rw [show L = \u22a4 from <a>eq_top_iff</a>.2 fun x _ \u21a6 hnfd x] at fin", [{"full_name": "eq_top_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [133, 9], "def_end_pos": [133, 19]}]], "state_before": "F : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5L\nhn : n < finrank F \u21a5L\nhnfd : \u2200 (x : E), x \u2208 L\n\u22a2 FiniteDimensional F E", "state_after": "F : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5\u22a4\nhn : n < finrank F \u21a5L\nhnfd : \u2200 (x : E), x \u2208 L\n\u22a2 FiniteDimensional F E"}, {"tactic": "exact topEquiv.toLinearEquiv.finiteDimensional", "annotated_tactic": ["exact topEquiv.toLinearEquiv.finiteDimensional", []], "state_before": "F : Type u_1\ninst\u271d\u2076 : Field F\nE : Type u_2\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL\u271d : Type u_3\ninst\u271d\u00b9 : Field L\u271d\ninst\u271d : Algebra K L\u271d\nhalg : Algebra.IsAlgebraic F E\nn : \u2115\nL : IntermediateField F E\nfin : FiniteDimensional F \u21a5\u22a4\nhn : n < finrank F \u21a5L\nhnfd : \u2200 (x : E), x \u2208 L\n\u22a2 FiniteDimensional F E", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Hull.lean", "full_name": "convexHull_univ", "start": [84, 1], "end": [85, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "SupHom.withTop_id", "start": [1612, 1], "end": [1612, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "full_name": "MulMemClass.coe_subtype", "start": [575, 1], "end": [576, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/StarAlgHom.lean", "full_name": "StarAlgEquiv.coe_trans", "start": [952, 1], "end": [953, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "full_name": "Cardinal.principal_add_ord", "start": [913, 1], "end": [916, 30], "traced_tactics": [{"tactic": "rw [lt_ord, Ordinal.card_add] at *", "annotated_tactic": ["rw [<a>lt_ord</a>, <a>Ordinal.card_add</a>] at *", [{"full_name": "Cardinal.lt_ord", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1357, 9], "def_end_pos": [1357, 15]}, {"full_name": "Ordinal.card_add", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [896, 9], "def_end_pos": [896, 17]}]], "state_before": "c : Cardinal.{u_1}\nhc : \u2135\u2080 \u2264 c\na b : Ordinal.{u_1}\nha : a < ord c\nhb : b < ord c\n\u22a2 (fun x x_1 => x + x_1) a b < ord c", "state_after": "c : Cardinal.{u_1}\nhc : \u2135\u2080 \u2264 c\na b : Ordinal.{u_1}\nha : card a < c\nhb : card b < c\n\u22a2 card a + card b < c"}, {"tactic": "exact add_lt_of_lt hc ha hb", "annotated_tactic": ["exact <a>add_lt_of_lt</a> hc ha hb", [{"full_name": "Cardinal.add_lt_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [760, 9], "def_end_pos": [760, 21]}]], "state_before": "c : Cardinal.{u_1}\nhc : \u2135\u2080 \u2264 c\na b : Ordinal.{u_1}\nha : card a < c\nhb : card b < c\n\u22a2 card a + card b < c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Order.lean", "full_name": "Finset.le_sum_card", "start": [350, 1], "end": [354, 52], "traced_tactics": [{"tactic": "simp_rw [univ_inter]", "annotated_tactic": ["simp_rw [<a>univ_inter</a>]", [{"full_name": "Finset.univ_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [280, 15], "def_end_pos": [280, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nM : Type u_4\nN : Type u_5\nG : Type u_6\nk : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq \u03b1\ns : Finset \u03b1\nB : Finset (Finset \u03b1)\nn : \u2115\ninst\u271d : Fintype \u03b1\nh : \u2200 (a : \u03b1), n \u2264 (filter (fun x => a \u2208 x) B).card\n\u22a2 \u2211 s in B, (univ \u2229 s).card = \u2211 s in B, s.card", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/AbsoluteValue.lean", "full_name": "IsAbsoluteValue.abv_one", "start": [383, 1], "end": [384, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "Submodule.ker_subtypeL", "start": [1102, 1], "end": [1103, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.factors_mono", "start": [1553, 1], "end": [1554, 82], "traced_tactics": [{"tactic": "rw [eq, factors_mul]", "annotated_tactic": ["rw [eq, <a>factors_mul</a>]", [{"full_name": "Associates.factors_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1546, 9], "def_end_pos": [1546, 20]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\ns t : Associates \u03b1\nd : Associates \u03b1\neq : t = s * d\n\u22a2 factors s \u2264 factors t", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\ns t : Associates \u03b1\nd : Associates \u03b1\neq : t = s * d\n\u22a2 factors s \u2264 factors s + factors d"}, {"tactic": "exact le_add_of_nonneg_right bot_le", "annotated_tactic": ["exact <a>le_add_of_nonneg_right</a> <a>bot_le</a>", [{"full_name": "le_add_of_nonneg_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [391, 15], "def_end_pos": [391, 37]}, {"full_name": "bot_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [224, 9], "def_end_pos": [224, 15]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\ns t : Associates \u03b1\nd : Associates \u03b1\neq : t = s * d\n\u22a2 factors s \u2264 factors s + factors d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounded.lean", "full_name": "Set.bounded_self", "start": [169, 1], "end": [170, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "full_name": "Real.Angle.sign_pi_add", "start": [878, 1], "end": [878, 100], "traced_tactics": [{"tactic": "rw [add_comm, sign_add_pi]", "annotated_tactic": ["rw [<a>add_comm</a>, <a>sign_add_pi</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "Real.Angle.sign_add_pi", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "def_pos": [873, 9], "def_end_pos": [873, 20]}]], "state_before": "\u03b8 : Angle\n\u22a2 sign (\u2191\u03c0 + \u03b8) = -sign \u03b8", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Basic.lean", "full_name": "derivWithin_congr", "start": [644, 1], "end": [647, 32], "traced_tactics": [{"tactic": "unfold derivWithin", "annotated_tactic": ["unfold <a>derivWithin</a>", [{"full_name": "derivWithin", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "def_pos": [140, 5], "def_end_pos": [140, 16]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 derivWithin f\u2081 s x = derivWithin f s x", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 (fderivWithin \ud835\udd5c f\u2081 s x) 1 = (fderivWithin \ud835\udd5c f s x) 1"}, {"tactic": "rw [fderivWithin_congr hs hx]", "annotated_tactic": ["rw [<a>fderivWithin_congr</a> hs hx]", [{"full_name": "fderivWithin_congr", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [1052, 9], "def_end_pos": [1052, 27]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nhs : EqOn f\u2081 f s\nhx : f\u2081 x = f x\n\u22a2 (fderivWithin \ud835\udd5c f\u2081 s x) 1 = (fderivWithin \ud835\udd5c f s x) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.Iic_sInf", "start": [2148, 1], "end": [2148, 96], "traced_tactics": [{"tactic": "rw [sInf_eq_iInf, Iic_iInf\u2082]", "annotated_tactic": ["rw [<a>sInf_eq_iInf</a>, <a>Iic_iInf\u2082</a>]", [{"full_name": "sInf_eq_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [882, 9], "def_end_pos": [882, 21]}, {"full_name": "Set.Iic_iInf\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [2141, 9], "def_end_pos": [2141, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 Iic (sInf s) = \u22c2 a \u2208 s, Iic a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "mul_self_le_mul_self_of_le_of_neg_le", "start": [1303, 1], "end": [1306, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.erase_neg", "start": [941, 1], "end": [943, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Subfield.lean", "full_name": "Subfield.coe_zero", "start": [384, 1], "end": [385, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Fin.image_castSucc", "start": [868, 1], "end": [870, 54], "traced_tactics": [{"tactic": "rw [\u2190 Fin.succAbove_last, Fin.image_succAbove_univ]", "annotated_tactic": ["rw [\u2190 <a>Fin.succAbove_last</a>, <a>Fin.image_succAbove_univ</a>]", [{"full_name": "Fin.succAbove_last", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/OrderHom.lean", "def_pos": [178, 9], "def_end_pos": [178, 23]}, {"full_name": "Fin.image_succAbove_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [857, 9], "def_end_pos": [857, 33]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\n\u22a2 image castSucc univ = {last n}\u1d9c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Nat.even_sub'", "start": [150, 1], "end": [151, 67], "traced_tactics": [{"tactic": "rw [even_sub h, even_iff_not_odd, even_iff_not_odd, not_iff_not]", "annotated_tactic": ["rw [<a>even_sub</a> h, <a>even_iff_not_odd</a>, <a>even_iff_not_odd</a>, <a>not_iff_not</a>]", [{"full_name": "Nat.even_sub", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Parity.lean", "def_pos": [145, 9], "def_end_pos": [145, 17]}, {"full_name": "Nat.even_iff_not_odd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Parity.lean", "def_pos": [58, 9], "def_end_pos": [58, 25]}, {"full_name": "Nat.even_iff_not_odd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Parity.lean", "def_pos": [58, 9], "def_end_pos": [58, 25]}, {"full_name": "not_iff_not", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [449, 9], "def_end_pos": [449, 20]}]], "state_before": "m n : \u2115\nh : n \u2264 m\n\u22a2 Even (m - n) \u2194 (Odd m \u2194 Odd n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GeomSum.lean", "full_name": "geom_sum_succ", "start": [46, 1], "end": [48, 61], "traced_tactics": [{"tactic": "simp only [mul_sum, \u2190 pow_succ, sum_range_succ', pow_zero]", "annotated_tactic": ["simp only [<a>mul_sum</a>, \u2190 <a>pow_succ</a>, <a>sum_range_succ'</a>, <a>pow_zero</a>]", [{"full_name": "Finset.mul_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean", "def_pos": [32, 7], "def_end_pos": [32, 14]}, {"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}, {"full_name": "Finset.sum_range_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1453, 3], "def_end_pos": [1453, 14]}, {"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}]], "state_before": "\u03b1 : Type u\ninst\u271d : Semiring \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 \u2211 i in range (n + 1), x ^ i = x * \u2211 i in range n, x ^ i + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Coset.lean", "full_name": "QuotientGroup.induction_on'", "start": [470, 1], "end": [471, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.cons_inj_left", "start": [147, 1], "end": [151, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "HasFDerivWithinAt.smul", "start": [261, 1], "end": [263, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.replicate_left_injective", "start": [984, 1], "end": [986, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Pointwise.lean", "full_name": "mul_ball_one", "start": [221, 1], "end": [226, 40], "traced_tactics": [{"tactic": "rw [thickening_eq_biUnion_ball]", "annotated_tactic": ["rw [<a>thickening_eq_biUnion_ball</a>]", [{"full_name": "Metric.thickening_eq_biUnion_ball", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [153, 9], "def_end_pos": [153, 35]}]], "state_before": "E : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y : E\n\u22a2 s * ball 1 \u03b4 = thickening \u03b4 s", "state_after": "E : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y : E\n\u22a2 s * ball 1 \u03b4 = \u22c3 x \u2208 s, ball x \u03b4"}, {"tactic": "convert iUnion\u2082_mul (fun x (_ : x \u2208 s) => {x}) (ball (1 : E) \u03b4)", "annotated_tactic": ["convert <a>iUnion\u2082_mul</a> (fun x (_ : x \u2208 s) => {x}) (<a>ball</a> (1 : E) \u03b4)", [{"full_name": "Set.iUnion\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [506, 9], "def_end_pos": [506, 20]}, {"full_name": "Metric.ball", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [401, 5], "def_end_pos": [401, 9]}]], "state_before": "E : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y : E\n\u22a2 s * ball 1 \u03b4 = \u22c3 x \u2208 s, ball x \u03b4", "state_after": "case h.e'_2.h.e'_5\nE : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y : E\n\u22a2 s = \u22c3 i \u2208 s, {i}\n\ncase h.e'_3.h.e'_3.h.f\nE : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y x\u271d\u00b9 : E\nx\u271d : x\u271d\u00b9 \u2208 s\n\u22a2 ball x\u271d\u00b9 \u03b4 = {x\u271d\u00b9} * ball 1 \u03b4"}, {"tactic": "exact s.biUnion_of_singleton.symm", "annotated_tactic": ["exact s.biUnion_of_singleton.symm", []], "state_before": "case h.e'_2.h.e'_5\nE : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y : E\n\u22a2 s = \u22c3 i \u2208 s, {i}\n\ncase h.e'_3.h.e'_3.h.f\nE : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y x\u271d\u00b9 : E\nx\u271d : x\u271d\u00b9 \u2208 s\n\u22a2 ball x\u271d\u00b9 \u03b4 = {x\u271d\u00b9} * ball 1 \u03b4", "state_after": "case h.e'_3.h.e'_3.h.f\nE : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y x\u271d\u00b9 : E\nx\u271d : x\u271d\u00b9 \u2208 s\n\u22a2 ball x\u271d\u00b9 \u03b4 = {x\u271d\u00b9} * ball 1 \u03b4"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "case h.e'_3.h.e'_3.h.f\nE : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y x\u271d\u00b9 : E\nx\u271d : x\u271d\u00b9 \u2208 s\n\u22a2 ball x\u271d\u00b9 \u03b4 = {x\u271d\u00b9} * ball 1 \u03b4", "state_after": "case h.e'_3.h.e'_3.h.f.h\nE : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx\u271d\u00b2 y x\u271d\u00b9 : E\nx\u271d : x\u271d\u00b9 \u2208 s\nx : E\n\u22a2 x \u2208 ball x\u271d\u00b9 \u03b4 \u2194 x \u2208 {x\u271d\u00b9} * ball 1 \u03b4"}, {"tactic": "simp_rw [singleton_mul_ball, mul_one]", "annotated_tactic": ["simp_rw [<a>singleton_mul_ball</a>, <a>mul_one</a>]", [{"full_name": "singleton_mul_ball", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Pointwise.lean", "def_pos": [119, 9], "def_end_pos": [119, 27]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "case h.e'_3.h.e'_3.h.f.h\nE : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx\u271d\u00b2 y x\u271d\u00b9 : E\nx\u271d : x\u271d\u00b9 \u2208 s\nx : E\n\u22a2 x \u2208 ball x\u271d\u00b9 \u03b4 \u2194 x \u2208 {x\u271d\u00b9} * ball 1 \u03b4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/FiniteDimensional.lean", "full_name": "LinearMap.ker_comp_eq_of_commute_of_disjoint_ker", "start": [694, 1], "end": [699, 73], "traced_tactics": [{"tactic": "suffices \u2200 x, f x = 0 \u2192 f (g x) = 0 by rw [ker_comp, comap_eq_sup_ker_of_disjoint _ h']; simpa", "annotated_tactic": ["suffices \u2200 x, f x = 0 \u2192 f (g x) = 0 by rw [<a>ker_comp</a>, <a>comap_eq_sup_ker_of_disjoint</a> _ h']; simpa", [{"full_name": "LinearMap.ker_comp", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [87, 9], "def_end_pos": [87, 17]}, {"full_name": "LinearMap.comap_eq_sup_ker_of_disjoint", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FiniteDimensional.lean", "def_pos": [685, 9], "def_end_pos": [685, 37]}]], "state_before": "K : Type u\nV : Type v\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\nV\u2082 : Type v'\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\nf g : V \u2192\u2097[K] V\nh : Commute f g\nh' : Disjoint (ker f) (ker g)\n\u22a2 ker (f \u2218\u2097 g) = ker f \u2294 ker g", "state_after": "K : Type u\nV : Type v\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\nV\u2082 : Type v'\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\nf g : V \u2192\u2097[K] V\nh : Commute f g\nh' : Disjoint (ker f) (ker g)\n\u22a2 \u2200 (x : V), f x = 0 \u2192 f (g x) = 0"}, {"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "K : Type u\nV : Type v\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\nV\u2082 : Type v'\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\nf g : V \u2192\u2097[K] V\nh : Commute f g\nh' : Disjoint (ker f) (ker g)\n\u22a2 \u2200 (x : V), f x = 0 \u2192 f (g x) = 0", "state_after": "K : Type u\nV : Type v\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\nV\u2082 : Type v'\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\nf g : V \u2192\u2097[K] V\nh : Commute f g\nh' : Disjoint (ker f) (ker g)\nx : V\nhx : f x = 0\n\u22a2 f (g x) = 0"}, {"tactic": "rw [\u2190 comp_apply, \u2190 mul_eq_comp, h.eq, mul_apply, hx, _root_.map_zero]", "annotated_tactic": ["rw [\u2190 <a>comp_apply</a>, \u2190 <a>mul_eq_comp</a>, h.eq, <a>mul_apply</a>, hx, <a>_root_.map_zero</a>]", [{"full_name": "LinearMap.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 19]}, {"full_name": "LinearMap.mul_eq_comp", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/End.lean", "def_pos": [53, 9], "def_end_pos": [53, 20]}, {"full_name": "LinearMap.mul_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/End.lean", "def_pos": [61, 9], "def_end_pos": [61, 18]}, {"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}]], "state_before": "K : Type u\nV : Type v\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\nV\u2082 : Type v'\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\nf g : V \u2192\u2097[K] V\nh : Commute f g\nh' : Disjoint (ker f) (ker g)\nx : V\nhx : f x = 0\n\u22a2 f (g x) = 0", "state_after": "no goals"}, {"tactic": "rw [ker_comp, comap_eq_sup_ker_of_disjoint _ h']", "annotated_tactic": ["rw [<a>ker_comp</a>, <a>comap_eq_sup_ker_of_disjoint</a> _ h']", [{"full_name": "LinearMap.ker_comp", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Ker.lean", "def_pos": [87, 9], "def_end_pos": [87, 17]}, {"full_name": "LinearMap.comap_eq_sup_ker_of_disjoint", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FiniteDimensional.lean", "def_pos": [685, 9], "def_end_pos": [685, 37]}]], "state_before": "K : Type u\nV : Type v\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\nV\u2082 : Type v'\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\nf g : V \u2192\u2097[K] V\nh : Commute f g\nh' : Disjoint (ker f) (ker g)\nthis : \u2200 (x : V), f x = 0 \u2192 f (g x) = 0\n\u22a2 ker (f \u2218\u2097 g) = ker f \u2294 ker g", "state_after": "K : Type u\nV : Type v\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\nV\u2082 : Type v'\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\nf g : V \u2192\u2097[K] V\nh : Commute f g\nh' : Disjoint (ker f) (ker g)\nthis : \u2200 (x : V), f x = 0 \u2192 f (g x) = 0\n\u22a2 \u2200 x \u2208 ker f, g x \u2208 ker f"}, {"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "K : Type u\nV : Type v\ninst\u271d\u2075 : DivisionRing K\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module K V\nV\u2082 : Type v'\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\ninst\u271d : FiniteDimensional K V\nf g : V \u2192\u2097[K] V\nh : Commute f g\nh' : Disjoint (ker f) (ker g)\nthis : \u2200 (x : V), f x = 0 \u2192 f (g x) = 0\n\u22a2 \u2200 x \u2208 ker f, g x \u2208 ker f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.liftAddHom_apply_single", "start": [2067, 1], "end": [2068, 78], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d : AddCommMonoid \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\ni : \u03b9\nx : \u03b2 i\n\u22a2 (liftAddHom f) (single i x) = (f i) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Prod.lean", "full_name": "Filter.prod_inf_prod", "start": [384, 1], "end": [386, 86], "traced_tactics": [{"tactic": "simp only [SProd.sprod, Filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]", "annotated_tactic": ["simp only [<a>SProd.sprod</a>, <a>Filter.prod</a>, <a>comap_inf</a>, <a>inf_comm</a>, <a>inf_assoc</a>, <a>inf_left_comm</a>]", [{"full_name": "SProd.sprod", "def_path": ".lake/packages/mathlib/Mathlib/Data/SProd.lean", "def_pos": [29, 3], "def_end_pos": [29, 8]}, {"full_name": "Filter.prod", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [53, 15], "def_end_pos": [53, 19]}, {"full_name": "Filter.comap_inf", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2365, 17], "def_end_pos": [2365, 26]}, {"full_name": "inf_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [465, 9], "def_end_pos": [465, 17]}, {"full_name": "inf_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [470, 9], "def_end_pos": [470, 18]}, {"full_name": "inf_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [485, 9], "def_end_pos": [485, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\nf\u2081 f\u2082 : Filter \u03b1\ng\u2081 g\u2082 : Filter \u03b2\n\u22a2 f\u2081 \u00d7\u02e2 g\u2081 \u2293 f\u2082 \u00d7\u02e2 g\u2082 = (f\u2081 \u2293 f\u2082) \u00d7\u02e2 (g\u2081 \u2293 g\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Contraction.lean", "full_name": "contractLeft_apply", "start": [69, 1], "end": [70, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "toIocMod_zsmul_add'", "start": [443, 1], "end": [445, 47], "traced_tactics": [{"tactic": "rw [add_comm, toIocMod_add_zsmul', add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>, <a>toIocMod_add_zsmul'</a>, <a>add_comm</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "toIocMod_add_zsmul'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [421, 9], "def_end_pos": [421, 28]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b\u271d c : \u03b1\nn : \u2124\na b : \u03b1\nm : \u2124\n\u22a2 toIocMod hp (m \u2022 p + a) b = m \u2022 p + toIocMod hp a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.exists_next_right", "start": [1773, 1], "end": [1777, 92], "traced_tactics": [{"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b1\nH : s\u271d.Nonempty\nx\u271d x : \u03b1\ns : Finset \u03b1\nh : \u2203 y \u2208 s, x < y\ny : \u03b1\nhy : y \u2208 s \u2227 x < y\n\u22a2 y \u2208 s \u2227 x < y", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b1\nH : s\u271d.Nonempty\nx\u271d x : \u03b1\ns : Finset \u03b1\nh : \u2203 y \u2208 s, x < y\nHne : (filter (fun x_1 => x < x_1) s).Nonempty\naux : min' (filter (fun x_1 => x < x_1) s) Hne \u2208 s \u2227 x < min' (filter (fun x_1 => x < x_1) s) Hne\n\u22a2 x < min' (filter (fun x_1 => x < x_1) s) Hne", "state_after": "no goals"}, {"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : LinearOrder \u03b1\ns\u271d : Finset \u03b1\nH : s\u271d.Nonempty\nx\u271d x : \u03b1\ns : Finset \u03b1\nh : \u2203 y \u2208 s, x < y\nHne : (filter (fun x_1 => x < x_1) s).Nonempty\naux : min' (filter (fun x_1 => x < x_1) s) Hne \u2208 s \u2227 x < min' (filter (fun x_1 => x < x_1) s) Hne\nz : \u03b1\nhzs : z \u2208 s\nhz : x < z\n\u22a2 x < z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "Substring.Valid.dropWhile", "start": [1091, 1], "end": [1092, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Data/Bool/Lemmas.lean", "full_name": "Bool.or_eq_false_eq_eq_false_and_eq_false", "start": [95, 1], "end": [97, 31], "traced_tactics": [{"tactic": "cases a <;> cases b <;> simp", "annotated_tactic": ["cases a <;> cases b <;> simp", []], "state_before": "a b : Bool\n\u22a2 ((a || b) = false) = (a = false \u2227 b = false)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Equiv.lean", "full_name": "UniformEquiv.coe_prodComm", "start": [311, 1], "end": [312, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.apply_extend", "start": [763, 1], "end": [765, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean", "full_name": "padicValNat_mul_div_factorial", "start": [673, 9], "end": [676, 76], "traced_tactics": [{"tactic": "nth_rw 2 [\u2190 div_add_mod n p]", "annotated_tactic": ["nth_rw 2 [\u2190 <a>div_add_mod</a> n p]", [{"full_name": "Nat.div_add_mod", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [167, 9], "def_end_pos": [167, 20]}]], "state_before": "p n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 padicValNat p (p * (n / p))! = padicValNat p n !", "state_after": "p n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 padicValNat p (p * (n / p))! = padicValNat p (p * (n / p) + n % p)!"}, {"tactic": "exact (padicValNat_factorial_mul_add (n / p) <| mod_lt n hp.out.pos).symm", "annotated_tactic": ["exact (<a>padicValNat_factorial_mul_add</a> (n / p) <| <a>mod_lt</a> n hp.out.pos).<a>symm</a>", [{"full_name": "padicValNat_factorial_mul_add", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [660, 9], "def_end_pos": [660, 38]}, {"full_name": "Nat.mod_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [123, 9], "def_end_pos": [123, 15]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "p n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 padicValNat p (p * (n / p))! = padicValNat p (p * (n / p) + n % p)!", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "self_sub_toIocMod", "start": [148, 1], "end": [149, 32], "traced_tactics": [{"tactic": "rw [toIocMod, sub_sub_cancel]", "annotated_tactic": ["rw [<a>toIocMod</a>, <a>sub_sub_cancel</a>]", [{"full_name": "toIocMod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [79, 5], "def_end_pos": [79, 13]}, {"full_name": "sub_sub_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1005, 3], "def_end_pos": [1005, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b\u271d c : \u03b1\nn : \u2124\na b : \u03b1\n\u22a2 b - toIocMod hp a b = toIocDiv hp a b \u2022 p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.compl_range_inl", "start": [933, 1], "end": [934, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sign.lean", "full_name": "SignType.neg_one_lt_iff", "start": [169, 1], "end": [169, 80], "traced_tactics": [{"tactic": "cases a <;> decide", "annotated_tactic": ["cases a <;> decide", []], "state_before": "a : SignType\n\u22a2 -1 < a \u2194 0 \u2264 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean", "full_name": "LinearEquiv.coe_isometryOfInner", "start": [1295, 1], "end": [1296, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.coe_toSubsemiring", "start": [70, 1], "end": [71, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant.lean", "full_name": "Matrix.det_fin_two", "start": [791, 1], "end": [795, 7], "traced_tactics": [{"tactic": "simp only [det_succ_row_zero, det_unique, Fin.default_eq_zero, submatrix_apply,\n  Fin.succ_zero_eq_one, Fin.sum_univ_succ, Fin.val_zero, Fin.zero_succAbove, univ_unique,\n  Fin.val_succ, Fin.coe_fin_one, Fin.succ_succAbove_zero, sum_singleton]", "annotated_tactic": ["simp only [<a>det_succ_row_zero</a>, <a>det_unique</a>, <a>Fin.default_eq_zero</a>, <a>submatrix_apply</a>,\n    <a>Fin.succ_zero_eq_one</a>, <a>Fin.sum_univ_succ</a>, <a>Fin.val_zero</a>, <a>Fin.zero_succAbove</a>, <a>univ_unique</a>,\n    <a>Fin.val_succ</a>, <a>Fin.coe_fin_one</a>, <a>Fin.succ_succAbove_zero</a>, <a>sum_singleton</a>]", [{"full_name": "Matrix.det_succ_row_zero", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [738, 9], "def_end_pos": [738, 26]}, {"full_name": "Matrix.det_unique", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [118, 9], "def_end_pos": [118, 19]}, {"full_name": "Fin.default_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [568, 9], "def_end_pos": [568, 24]}, {"full_name": "Matrix.submatrix_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [2459, 9], "def_end_pos": [2459, 24]}, {"full_name": "Fin.succ_zero_eq_one", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 33]}, {"full_name": "Fin.sum_univ_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [80, 3], "def_end_pos": [80, 14]}, {"full_name": "Fin.val_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [113, 17], "def_end_pos": [113, 25]}, {"full_name": "Fin.zero_succAbove", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/OrderHom.lean", "def_pos": [275, 9], "def_end_pos": [275, 23]}, {"full_name": "Finset.univ_unique", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [121, 9], "def_end_pos": [121, 20]}, {"full_name": "Fin.val_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [224, 17], "def_end_pos": [224, 25]}, {"full_name": "Fin.coe_fin_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [1560, 9], "def_end_pos": [1560, 20]}, {"full_name": "Fin.succ_succAbove_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/OrderHom.lean", "def_pos": [280, 9], "def_end_pos": [280, 28]}, {"full_name": "Finset.sum_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [342, 3], "def_end_pos": [342, 14]}]], "state_before": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix (Fin 2) (Fin 2) R\n\u22a2 det A = A 0 0 * A 1 1 - A 0 1 * A 1 0", "state_after": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix (Fin 2) (Fin 2) R\n\u22a2 (-1) ^ 0 * A 0 0 * A 1 1 + (-1) ^ (0 + 1) * A 0 1 * A 1 0 = A 0 0 * A 1 1 - A 0 1 * A 1 0"}, {"tactic": "ring", "annotated_tactic": ["ring", []], "state_before": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix (Fin 2) (Fin 2) R\n\u22a2 (-1) ^ 0 * A 0 0 * A 1 1 + (-1) ^ (0 + 1) * A 0 1 * A 1 0 = A 0 0 * A 1 1 - A 0 1 * A 1 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Interval.lean", "full_name": "Nat.decreasing_induction_of_not_bddAbove", "start": [363, 1], "end": [365, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.iterate_comp_eval\u2082", "start": [1066, 1], "end": [1070, 84], "traced_tactics": [{"tactic": "induction' k with k IH", "annotated_tactic": ["induction' k with k IH", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q : R[X]\nx : R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nk : \u2115\nt : S\n\u22a2 eval\u2082 f t ((comp p)^[k] q) = (fun x => eval\u2082 f x p)^[k] (eval\u2082 f t q)", "state_after": "case zero\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q : R[X]\nx : R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nt : S\n\u22a2 eval\u2082 f t ((comp p)^[Nat.zero] q) = (fun x => eval\u2082 f x p)^[Nat.zero] (eval\u2082 f t q)\n\ncase succ\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q : R[X]\nx : R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nt : S\nk : \u2115\nIH : eval\u2082 f t ((comp p)^[k] q) = (fun x => eval\u2082 f x p)^[k] (eval\u2082 f t q)\n\u22a2 eval\u2082 f t ((comp p)^[Nat.succ k] q) = (fun x => eval\u2082 f x p)^[Nat.succ k] (eval\u2082 f t q)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q : R[X]\nx : R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nt : S\n\u22a2 eval\u2082 f t ((comp p)^[Nat.zero] q) = (fun x => eval\u2082 f x p)^[Nat.zero] (eval\u2082 f t q)", "state_after": "no goals"}, {"tactic": "rw [Function.iterate_succ_apply', Function.iterate_succ_apply', eval\u2082_comp, IH]", "annotated_tactic": ["rw [<a>Function.iterate_succ_apply'</a>, <a>Function.iterate_succ_apply'</a>, <a>eval\u2082_comp</a>, IH]", [{"full_name": "Function.iterate_succ_apply'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [190, 9], "def_end_pos": [190, 28]}, {"full_name": "Function.iterate_succ_apply'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [190, 9], "def_end_pos": [190, 28]}, {"full_name": "Polynomial.eval\u2082_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [1061, 9], "def_end_pos": [1061, 19]}]], "state_before": "case succ\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q : R[X]\nx : R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nt : S\nk : \u2115\nIH : eval\u2082 f t ((comp p)^[k] q) = (fun x => eval\u2082 f x p)^[k] (eval\u2082 f t q)\n\u22a2 eval\u2082 f t ((comp p)^[Nat.succ k] q) = (fun x => eval\u2082 f x p)^[Nat.succ k] (eval\u2082 f t q)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "Filter.Tendsto.add_atTop", "start": [1122, 1], "end": [1127, 65], "traced_tactics": [{"tactic": "nontriviality \u03b1", "annotated_tactic": ["nontriviality \u03b1", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : OrderTopology \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\nC : \u03b1\nhf : Tendsto f l (\ud835\udcdd C)\nhg : Tendsto g l atTop\n\u22a2 Tendsto (fun x => f x + g x) l atTop", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : OrderTopology \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\nC : \u03b1\nhf : Tendsto f l (\ud835\udcdd C)\nhg : Tendsto g l atTop\na\u271d : Nontrivial \u03b1\n\u22a2 Tendsto (fun x => f x + g x) l atTop"}, {"tactic": "obtain \u27e8C', hC'\u27e9 : \u2203 C', C' < C := exists_lt C", "annotated_tactic": ["obtain \u27e8C', hC'\u27e9 : \u2203 C', C' < C := <a>exists_lt</a> C", [{"full_name": "NoMinOrder.exists_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Max.lean", "def_pos": [55, 3], "def_end_pos": [55, 12]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : OrderTopology \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\nC : \u03b1\nhf : Tendsto f l (\ud835\udcdd C)\nhg : Tendsto g l atTop\na\u271d : Nontrivial \u03b1\n\u22a2 Tendsto (fun x => f x + g x) l atTop", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : OrderTopology \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\nC : \u03b1\nhf : Tendsto f l (\ud835\udcdd C)\nhg : Tendsto g l atTop\na\u271d : Nontrivial \u03b1\nC' : \u03b1\nhC' : C' < C\n\u22a2 Tendsto (fun x => f x + g x) l atTop"}, {"tactic": "refine' tendsto_atTop_add_left_of_le' _ C' _ hg", "annotated_tactic": ["refine' <a>tendsto_atTop_add_left_of_le'</a> _ C' _ hg", [{"full_name": "Filter.tendsto_atTop_add_left_of_le'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [830, 9], "def_end_pos": [830, 38]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : OrderTopology \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\nC : \u03b1\nhf : Tendsto f l (\ud835\udcdd C)\nhg : Tendsto g l atTop\na\u271d : Nontrivial \u03b1\nC' : \u03b1\nhC' : C' < C\n\u22a2 Tendsto (fun x => f x + g x) l atTop", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : OrderTopology \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\nC : \u03b1\nhf : Tendsto f l (\ud835\udcdd C)\nhg : Tendsto g l atTop\na\u271d : Nontrivial \u03b1\nC' : \u03b1\nhC' : C' < C\n\u22a2 \u2200\u1da0 (x : \u03b2) in l, C' \u2264 f x"}, {"tactic": "exact (hf.eventually (lt_mem_nhds hC')).mono fun x => le_of_lt", "annotated_tactic": ["exact (hf.eventually (<a>lt_mem_nhds</a> hC')).<a>mono</a> fun x => <a>le_of_lt</a>", [{"full_name": "lt_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [105, 9], "def_end_pos": [105, 20]}, {"full_name": "Filter.Eventually.mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1157, 9], "def_end_pos": [1157, 24]}, {"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : OrderTopology \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\nC : \u03b1\nhf : Tendsto f l (\ud835\udcdd C)\nhg : Tendsto g l atTop\na\u271d : Nontrivial \u03b1\nC' : \u03b1\nhC' : C' < C\n\u22a2 \u2200\u1da0 (x : \u03b2) in l, C' \u2264 f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isBigOWith_zero'", "start": [1237, 1], "end": [1238, 52], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | (fun x => \u20160\u2016 \u2264 0 * \u2016g x\u2016) x}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "InfTopHom.cancel_left", "start": [986, 1], "end": [988, 91], "traced_tactics": [{"tactic": "rw [\u2190 comp_apply, h, comp_apply]", "annotated_tactic": ["rw [\u2190 <a>comp_apply</a>, h, <a>comp_apply</a>]", [{"full_name": "InfTopHom.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Order/Hom/Lattice.lean", "def_pos": [963, 9], "def_end_pos": [963, 19]}, {"full_name": "InfTopHom.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Order/Hom/Lattice.lean", "def_pos": [963, 9], "def_end_pos": [963, 19]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2078 : FunLike F \u03b1 \u03b2\ninst\u271d\u2077 : Inf \u03b1\ninst\u271d\u2076 : Top \u03b1\ninst\u271d\u2075 : Inf \u03b2\ninst\u271d\u2074 : Top \u03b2\ninst\u271d\u00b3 : Inf \u03b3\ninst\u271d\u00b2 : Top \u03b3\ninst\u271d\u00b9 : Inf \u03b4\ninst\u271d : Top \u03b4\ng : InfTopHom \u03b2 \u03b3\nf\u2081 f\u2082 : InfTopHom \u03b1 \u03b2\nhg : Injective \u21d1g\nh : comp g f\u2081 = comp g f\u2082\na : \u03b1\n\u22a2 g (f\u2081 a) = g (f\u2082 a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean", "full_name": "HahnSeries.C_mul_eq_smul", "start": [497, 1], "end": [498, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Prod.lean", "full_name": "Prod.smul_fst", "start": [48, 1], "end": [49, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Trace.lean", "full_name": "Matrix.trace_sub", "start": [139, 1], "end": [140, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.union_diff_cancel_right", "start": [1828, 1], "end": [1829, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "full_name": "CategoryTheory.Limits.coprod.symmetry'", "start": [1137, 1], "end": [1139, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.ofFinset", "start": [77, 11], "end": [78, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Divisors.lean", "full_name": "Nat.pos_of_mem_properDivisors", "start": [207, 1], "end": [208, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Countable.lean", "full_name": "Set.countable_coe_iff", "start": [49, 1], "end": [49, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Multiplicity.lean", "full_name": "multiplicity.mul'", "start": [550, 11], "end": [575, 85], "traced_tactics": [{"tactic": "have hdiva : p ^ get (multiplicity p a) ((finite_mul_iff hp).1 h).1 \u2223 a := pow_multiplicity_dvd _", "annotated_tactic": ["have hdiva : p ^ <a>get</a> (<a>multiplicity</a> p a) ((<a>finite_mul_iff</a> hp).1 h).1 \u2223 a := <a>pow_multiplicity_dvd</a> _", [{"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "multiplicity.pow_multiplicity_dvd", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [111, 9], "def_end_pos": [111, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef"}, {"tactic": "have hdivb : p ^ get (multiplicity p b) ((finite_mul_iff hp).1 h).2 \u2223 b := pow_multiplicity_dvd _", "annotated_tactic": ["have hdivb : p ^ <a>get</a> (<a>multiplicity</a> p b) ((<a>finite_mul_iff</a> hp).1 h).2 \u2223 b := <a>pow_multiplicity_dvd</a> _", [{"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "multiplicity.pow_multiplicity_dvd", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [111, 9], "def_end_pos": [111, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef"}, {"tactic": "have hpoweq :\n  p ^ (get (multiplicity p a) ((finite_mul_iff hp).1 h).1 +\n        get (multiplicity p b) ((finite_mul_iff hp).1 h).2) =\n    p ^ get (multiplicity p a) ((finite_mul_iff hp).1 h).1 *\n      p ^ get (multiplicity p b) ((finite_mul_iff hp).1 h).2 :=\n  by simp [pow_add]", "annotated_tactic": ["have hpoweq :\n    p ^ (<a>get</a> (<a>multiplicity</a> p a) ((<a>finite_mul_iff</a> hp).1 h).1 +\n          <a>get</a> (<a>multiplicity</a> p b) ((<a>finite_mul_iff</a> hp).1 h).2) =\n      p ^ <a>get</a> (<a>multiplicity</a> p a) ((<a>finite_mul_iff</a> hp).1 h).1 *\n        p ^ <a>get</a> (<a>multiplicity</a> p b) ((<a>finite_mul_iff</a> hp).1 h).2 :=\n    by simp [<a>pow_add</a>]", [{"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "pow_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [103, 9], "def_end_pos": [103, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef"}, {"tactic": "have hdiv :\n  p ^ (get (multiplicity p a) ((finite_mul_iff hp).1 h).1 +\n        get (multiplicity p b) ((finite_mul_iff hp).1 h).2) \u2223\n    a * b :=\n  by rw [hpoweq]; apply mul_dvd_mul <;> assumption", "annotated_tactic": ["have hdiv :\n    p ^ (<a>get</a> (<a>multiplicity</a> p a) ((<a>finite_mul_iff</a> hp).1 h).1 +\n          <a>get</a> (<a>multiplicity</a> p b) ((<a>finite_mul_iff</a> hp).1 h).2) \u2223\n      a * b :=\n    by rw [hpoweq]; apply <a>mul_dvd_mul</a> <;> assumption", [{"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "mul_dvd_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [210, 9], "def_end_pos": [210, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\nhdiv : p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) \u2223 a * b\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef"}, {"tactic": "have hsucc :\n  \u00acp ^ (get (multiplicity p a) ((finite_mul_iff hp).1 h).1 +\n            get (multiplicity p b) ((finite_mul_iff hp).1 h).2 +\n          1) \u2223\n      a * b :=\n  fun h =>\n  not_or_of_not (is_greatest' _ (lt_succ_self _)) (is_greatest' _ (lt_succ_self _))\n    (_root_.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul hp hdiva hdivb h)", "annotated_tactic": ["have hsucc :\n    \u00acp ^ (<a>get</a> (<a>multiplicity</a> p a) ((<a>finite_mul_iff</a> hp).1 h).1 +\n              <a>get</a> (<a>multiplicity</a> p b) ((<a>finite_mul_iff</a> hp).1 h).2 +\n            1) \u2223\n        a * b :=\n    fun h =>\n    <a>not_or_of_not</a> (<a>is_greatest'</a> _ (<a>lt_succ_self</a> _)) (<a>is_greatest'</a> _ (<a>lt_succ_self</a> _))\n      (<a>_root_.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul</a> hp hdiva hdivb h)", [{"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "Part.get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [56, 3], "def_end_pos": [56, 6]}, {"full_name": "multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [38, 5], "def_end_pos": [38, 17]}, {"full_name": "multiplicity.finite_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [520, 9], "def_end_pos": [520, 23]}, {"full_name": "not_or_of_not", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [184, 9], "def_end_pos": [184, 22]}, {"full_name": "multiplicity.is_greatest'", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [119, 9], "def_end_pos": [119, 21]}, {"full_name": "Nat.lt_succ_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 21]}, {"full_name": "multiplicity.is_greatest'", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [119, 9], "def_end_pos": [119, 21]}, {"full_name": "Nat.lt_succ_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 21]}, {"full_name": "succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [351, 9], "def_end_pos": [351, 49]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\nhdiv : p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) \u2223 a * b\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\nhdiv : p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) \u2223 a * b\nhsucc : \u00acp ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef + 1) \u2223 a * b\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef"}, {"tactic": "rw [\u2190 PartENat.natCast_inj, PartENat.natCast_get, eq_coe_iff]", "annotated_tactic": ["rw [\u2190 <a>PartENat.natCast_inj</a>, <a>PartENat.natCast_get</a>, <a>eq_coe_iff</a>]", [{"full_name": "PartENat.natCast_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [116, 9], "def_end_pos": [116, 20]}, {"full_name": "PartENat.natCast_get", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [179, 9], "def_end_pos": [179, 20]}, {"full_name": "multiplicity.eq_coe_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [157, 9], "def_end_pos": [157, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\nhdiv : p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) \u2223 a * b\nhsucc : \u00acp ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef + 1) \u2223 a * b\n\u22a2 (multiplicity p (a * b)).get h = (multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\nhdiv : p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) \u2223 a * b\nhsucc : \u00acp ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef + 1) \u2223 a * b\n\u22a2 p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) \u2223 a * b \u2227\n    \u00acp ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef + 1) \u2223 a * b"}, {"tactic": "exact \u27e8hdiv, hsucc\u27e9", "annotated_tactic": ["exact \u27e8hdiv, hsucc\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\nhdiv : p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) \u2223 a * b\nhsucc : \u00acp ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef + 1) \u2223 a * b\n\u22a2 p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) \u2223 a * b \u2227\n    \u00acp ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef + 1) \u2223 a * b", "state_after": "no goals"}, {"tactic": "simp [pow_add]", "annotated_tactic": ["simp [<a>pow_add</a>]", [{"full_name": "pow_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [103, 9], "def_end_pos": [103, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\n\u22a2 p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef", "state_after": "no goals"}, {"tactic": "rw [hpoweq]", "annotated_tactic": ["rw [hpoweq]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\n\u22a2 p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) \u2223 a * b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\n\u22a2 p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef \u2223 a * b"}, {"tactic": "apply mul_dvd_mul <;> assumption", "annotated_tactic": ["apply <a>mul_dvd_mul</a> <;> assumption", [{"full_name": "mul_dvd_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [210, 9], "def_end_pos": [210, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\np a b : \u03b1\nhp : Prime p\nh : (multiplicity p (a * b)).Dom\nhdiva : p ^ (multiplicity p a).get \u22ef \u2223 a\nhdivb : p ^ (multiplicity p b).get \u22ef \u2223 b\nhpoweq :\n  p ^ ((multiplicity p a).get \u22ef + (multiplicity p b).get \u22ef) =\n    p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef\n\u22a2 p ^ (multiplicity p a).get \u22ef * p ^ (multiplicity p b).get \u22ef \u2223 a * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean", "full_name": "Ideal.isPrime_map_C_of_isPrime", "start": [799, 1], "end": [801, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/CharP/Basic.lean", "full_name": "CharP.exists_unique", "start": [219, 1], "end": [221, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "IsGLB.csInf_eq", "start": [570, 1], "end": [571, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.indexOf_append_of_not_mem", "start": [1180, 1], "end": [1185, 50], "traced_tactics": [{"tactic": "induction' l\u2081 with d\u2081 t\u2081 ih", "annotated_tactic": ["induction' l\u2081 with d\u2081 t\u2081 ih", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nh : \u00aca \u2208 l\u2081\n\u22a2 indexOf a (l\u2081 ++ l\u2082) = length l\u2081 + indexOf a l\u2082", "state_after": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nh : \u00aca \u2208 []\n\u22a2 indexOf a ([] ++ l\u2082) = length [] + indexOf a l\u2082\n\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na d\u2081 : \u03b1\nt\u2081 : List \u03b1\nih : \u00aca \u2208 t\u2081 \u2192 indexOf a (t\u2081 ++ l\u2082) = length t\u2081 + indexOf a l\u2082\nh : \u00aca \u2208 d\u2081 :: t\u2081\n\u22a2 indexOf a (d\u2081 :: t\u2081 ++ l\u2082) = length (d\u2081 :: t\u2081) + indexOf a l\u2082"}, {"tactic": "rw [List.cons_append, indexOf_cons_ne _ (ne_of_not_mem_cons h).symm, List.length,\n  ih (not_mem_of_not_mem_cons h), Nat.succ_add]", "annotated_tactic": ["rw [<a>List.cons_append</a>, <a>indexOf_cons_ne</a> _ (<a>ne_of_not_mem_cons</a> h).<a>symm</a>, <a>List.length</a>,\n    ih (<a>not_mem_of_not_mem_cons</a> h), <a>Nat.succ_add</a>]", [{"full_name": "List.cons_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [139, 17], "def_end_pos": [139, 28]}, {"full_name": "List.indexOf_cons_ne", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1134, 9], "def_end_pos": [1134, 24]}, {"full_name": "List.ne_of_not_mem_cons", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [103, 9], "def_end_pos": [103, 27]}, {"full_name": "Ne.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [702, 9], "def_end_pos": [702, 16]}, {"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}, {"full_name": "List.not_mem_of_not_mem_cons", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 32]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na d\u2081 : \u03b1\nt\u2081 : List \u03b1\nih : \u00aca \u2208 t\u2081 \u2192 indexOf a (t\u2081 ++ l\u2082) = length t\u2081 + indexOf a l\u2082\nh : \u00aca \u2208 d\u2081 :: t\u2081\n\u22a2 indexOf a (d\u2081 :: t\u2081 ++ l\u2082) = length (d\u2081 :: t\u2081) + indexOf a l\u2082", "state_after": "no goals"}, {"tactic": "rw [List.nil_append, List.length, zero_add]", "annotated_tactic": ["rw [<a>List.nil_append</a>, <a>List.length</a>, <a>zero_add</a>]", [{"full_name": "List.nil_append", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [132, 17], "def_end_pos": [132, 27]}, {"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nh : \u00aca \u2208 []\n\u22a2 indexOf a ([] ++ l\u2082) = length [] + indexOf a l\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "IsOpen.mul_closure_one_eq", "start": [1536, 1], "end": [1539, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/IsLimit.lean", "full_name": "CategoryTheory.Limits.IsLimit.ofIsoLimit_lift", "start": [184, 1], "end": [186, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_preimage_of_injective_lift", "start": [2141, 1], "end": [2146, 68], "traced_tactics": [{"tactic": "rw [lift_mk_le.{0}]", "annotated_tactic": ["rw [<a>lift_mk_le</a>.{0}]", [{"full_name": "Cardinal.lift_mk_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [310, 9], "def_end_pos": [310, 19]}]], "state_before": "\u03b1\u271d \u03b2\u271d : Type u\nc : Cardinal.{?u.244292}\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Injective f\n\u22a2 lift.{v, u} #\u2191(f \u207b\u00b9' s) \u2264 lift.{u, v} #\u2191s", "state_after": "\u03b1\u271d \u03b2\u271d : Type u\nc : Cardinal.{?u.244292}\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Injective f\n\u22a2 Nonempty (\u2191(f \u207b\u00b9' s) \u21aa \u2191s)"}, {"tactic": "use Subtype.coind (fun x => f x.1) fun x => mem_preimage.mp x.2", "annotated_tactic": ["use <a>Subtype.coind</a> (fun x => f x.1) fun x => mem_preimage.mp x.2", [{"full_name": "Subtype.coind", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [179, 5], "def_end_pos": [179, 10]}]], "state_before": "\u03b1\u271d \u03b2\u271d : Type u\nc : Cardinal.{?u.244292}\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Injective f\n\u22a2 Nonempty (\u2191(f \u207b\u00b9' s) \u21aa \u2191s)", "state_after": "case inj'\n\u03b1\u271d \u03b2\u271d : Type u\nc : Cardinal.{?u.244292}\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Injective f\n\u22a2 Injective (Subtype.coind (fun x => f \u2191x) \u22ef)"}, {"tactic": "apply Subtype.coind_injective", "annotated_tactic": ["apply <a>Subtype.coind_injective</a>", [{"full_name": "Subtype.coind_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [183, 9], "def_end_pos": [183, 24]}]], "state_before": "case inj'\n\u03b1\u271d \u03b2\u271d : Type u\nc : Cardinal.{?u.244292}\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Injective f\n\u22a2 Injective (Subtype.coind (fun x => f \u2191x) \u22ef)", "state_after": "case inj'.hf\n\u03b1\u271d \u03b2\u271d : Type u\nc : Cardinal.{?u.244292}\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Injective f\n\u22a2 Injective fun x => f \u2191x"}, {"tactic": "exact h.comp Subtype.val_injective", "annotated_tactic": ["exact h.comp <a>Subtype.val_injective</a>", [{"full_name": "Subtype.val_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [122, 9], "def_end_pos": [122, 22]}]], "state_before": "case inj'.hf\n\u03b1\u271d \u03b2\u271d : Type u\nc : Cardinal.{?u.244292}\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Injective f\n\u22a2 Injective fun x => f \u2191x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Powerset.lean", "full_name": "Multiset.powersetAux_perm_powersetAux'", "start": [48, 1], "end": [49, 71], "traced_tactics": [{"tactic": "rw [powersetAux_eq_map_coe]", "annotated_tactic": ["rw [<a>powersetAux_eq_map_coe</a>]", [{"full_name": "Multiset.powersetAux_eq_map_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Powerset.lean", "def_pos": [33, 9], "def_end_pos": [33, 31]}]], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 powersetAux l ~ powersetAux' l", "state_after": "\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 List.map ofList (sublists l) ~ powersetAux' l"}, {"tactic": "exact (sublists_perm_sublists' _).map _", "annotated_tactic": ["exact (<a>sublists_perm_sublists'</a> _).<a>map</a> _", [{"full_name": "List.sublists_perm_sublists'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sublists.lean", "def_pos": [418, 9], "def_end_pos": [418, 32]}, {"full_name": "List.Perm.map", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}]], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 List.map ofList (sublists l) ~ powersetAux' l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/CompleteLattice.lean", "full_name": "sInfHom.comp_assoc", "start": [479, 1], "end": [481, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "isOpen_range_sigmaMk", "start": [1593, 1], "end": [1594, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.left_not_mem_Ioo", "start": [158, 1], "end": [158, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "full_name": "MeasureTheory.SimpleFunc.lintegral_map'", "start": [1143, 1], "end": [1148, 60], "traced_tactics": [{"tactic": "simp only [preimage, eq]", "annotated_tactic": ["simp only [<a>preimage</a>, eq]", [{"full_name": "Set.preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [113, 5], "def_end_pos": [113, 13]}]], "state_before": "\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\n\u03b2 : Type u_5\ninst\u271d : MeasurableSpace \u03b2\n\u03bc' : Measure \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\ng : \u03b2 \u2192\u209b \u211d\u22650\u221e\nm' : \u03b1 \u2192 \u03b2\neq : \u2200 (a : \u03b1), \u2191f a = \u2191g (m' a)\nh : \u2200 (s : Set \u03b2), MeasurableSet s \u2192 \u2191\u2191\u03bc' s = \u2191\u2191\u03bc (m' \u207b\u00b9' s)\ny : \u211d\u22650\u221e\n\u22a2 \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {y}) = \u2191\u2191\u03bc' (\u2191g \u207b\u00b9' {y})", "state_after": "\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\n\u03b2 : Type u_5\ninst\u271d : MeasurableSpace \u03b2\n\u03bc' : Measure \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\ng : \u03b2 \u2192\u209b \u211d\u22650\u221e\nm' : \u03b1 \u2192 \u03b2\neq : \u2200 (a : \u03b1), \u2191f a = \u2191g (m' a)\nh : \u2200 (s : Set \u03b2), MeasurableSet s \u2192 \u2191\u2191\u03bc' s = \u2191\u2191\u03bc (m' \u207b\u00b9' s)\ny : \u211d\u22650\u221e\n\u22a2 \u2191\u2191\u03bc {x | \u2191g (m' x) \u2208 {y}} = \u2191\u2191\u03bc' {x | \u2191g x \u2208 {y}}"}, {"tactic": "exact (h (g \u207b\u00b9' {y}) (g.measurableSet_preimage _)).symm", "annotated_tactic": ["exact (h (g \u207b\u00b9' {y}) (g.measurableSet_preimage _)).<a>symm</a>", [{"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\n\u03b2 : Type u_5\ninst\u271d : MeasurableSpace \u03b2\n\u03bc' : Measure \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\ng : \u03b2 \u2192\u209b \u211d\u22650\u221e\nm' : \u03b1 \u2192 \u03b2\neq : \u2200 (a : \u03b1), \u2191f a = \u2191g (m' a)\nh : \u2200 (s : Set \u03b2), MeasurableSet s \u2192 \u2191\u2191\u03bc' s = \u2191\u2191\u03bc (m' \u207b\u00b9' s)\ny : \u211d\u22650\u221e\n\u22a2 \u2191\u2191\u03bc {x | \u2191g (m' x) \u2208 {y}} = \u2191\u2191\u03bc' {x | \u2191g x \u2208 {y}}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Icc_subset_Icc", "start": [171, 1], "end": [172, 54], "traced_tactics": [{"tactic": "simpa [\u2190 coe_subset] using Set.Icc_subset_Icc ha hb", "annotated_tactic": ["simpa [\u2190 <a>coe_subset</a>] using <a>Set.Icc_subset_Icc</a> ha hb", [{"full_name": "Finset.coe_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [381, 9], "def_end_pos": [381, 19]}, {"full_name": "Set.Icc_subset_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [455, 9], "def_end_pos": [455, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nha : a\u2082 \u2264 a\u2081\nhb : b\u2081 \u2264 b\u2082\n\u22a2 Icc a\u2081 b\u2081 \u2286 Icc a\u2082 b\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "smul_closedBall''", "start": [1726, 1], "end": [1729, 38], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\n\u22a2 a \u2022 closedBall b r = closedBall (a \u2022 b) r", "state_after": "case h\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nx\u271d : E\n\u22a2 x\u271d \u2208 a \u2022 closedBall b r \u2194 x\u271d \u2208 closedBall (a \u2022 b) r"}, {"tactic": "simp [mem_closedBall, Set.mem_smul_set, dist_eq_norm_div, _root_.div_eq_inv_mul, \u2190\n  eq_inv_mul_iff_mul_eq, mul_assoc]", "annotated_tactic": ["simp [<a>mem_closedBall</a>, <a>Set.mem_smul_set</a>, <a>dist_eq_norm_div</a>, <a>_root_.div_eq_inv_mul</a>, \u2190\n    <a>eq_inv_mul_iff_mul_eq</a>, <a>mul_assoc</a>]", [{"full_name": "Metric.mem_closedBall", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [470, 17], "def_end_pos": [470, 31]}, {"full_name": "Set.mem_smul_set", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [315, 9], "def_end_pos": [315, 21]}, {"full_name": "dist_eq_norm_div", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [401, 9], "def_end_pos": [401, 25]}, {"full_name": "div_eq_inv_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [567, 9], "def_end_pos": [567, 23]}, {"full_name": "eq_inv_mul_iff_mul_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [760, 9], "def_end_pos": [760, 30]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "case h\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nx\u271d : E\n\u22a2 x\u271d \u2208 a \u2022 closedBall b r \u2194 x\u271d \u2208 closedBall (a \u2022 b) r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Cardinal.IsRegular.ord_pos", "start": [960, 1], "end": [962, 14], "traced_tactics": [{"tactic": "rw [Cardinal.lt_ord, card_zero]", "annotated_tactic": ["rw [<a>Cardinal.lt_ord</a>, <a>card_zero</a>]", [{"full_name": "Cardinal.lt_ord", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1357, 9], "def_end_pos": [1357, 15]}, {"full_name": "Ordinal.card_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [621, 9], "def_end_pos": [621, 18]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Cardinal.{u_2}\nH : IsRegular c\n\u22a2 0 < ord c", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Cardinal.{u_2}\nH : IsRegular c\n\u22a2 0 < c"}, {"tactic": "exact H.pos", "annotated_tactic": ["exact H.pos", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc : Cardinal.{u_2}\nH : IsRegular c\n\u22a2 0 < c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean", "full_name": "SimpleGraph.edge_mem_incidenceSet_iff", "start": [730, 1], "end": [731, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "full_name": "Subgroup.smul_mem_pointwise_smul", "start": [329, 1], "end": [330, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.diagonal_dotProduct", "start": [851, 1], "end": [854, 72], "traced_tactics": [{"tactic": "have : \u2200 j \u2260 i, diagonal v i j * w j = 0 := fun j hij => by\n  simp [diagonal_apply_ne' _ hij]", "annotated_tactic": ["have : \u2200 j \u2260 i, <a>diagonal</a> v i j * w j = 0 := fun j hij => by\n    simp [<a>diagonal_apply_ne'</a> _ hij]", [{"full_name": "Matrix.diagonal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [403, 5], "def_end_pos": [403, 13]}, {"full_name": "Matrix.diagonal_apply_ne'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [422, 9], "def_end_pos": [422, 27]}]], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v w : m \u2192 \u03b1\ni : m\n\u22a2 diagonal v i \u2b1d\u1d65 w = v i * w i", "state_after": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v w : m \u2192 \u03b1\ni : m\nthis : \u2200 (j : m), j \u2260 i \u2192 diagonal v i j * w j = 0\n\u22a2 diagonal v i \u2b1d\u1d65 w = v i * w i"}, {"tactic": "convert Finset.sum_eq_single i (fun j _ => this j) _ using 1 <;> simp", "annotated_tactic": ["convert <a>Finset.sum_eq_single</a> i (fun j _ => this j) _ using 1 <;> simp", [{"full_name": "Finset.sum_eq_single", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [946, 3], "def_end_pos": [946, 14]}]], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v w : m \u2192 \u03b1\ni : m\nthis : \u2200 (j : m), j \u2260 i \u2192 diagonal v i j * w j = 0\n\u22a2 diagonal v i \u2b1d\u1d65 w = v i * w i", "state_after": "no goals"}, {"tactic": "simp [diagonal_apply_ne' _ hij]", "annotated_tactic": ["simp [<a>diagonal_apply_ne'</a> _ hij]", [{"full_name": "Matrix.diagonal_apply_ne'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [422, 9], "def_end_pos": [422, 27]}]], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nu v w : m \u2192 \u03b1\ni j : m\nhij : j \u2260 i\n\u22a2 diagonal v i j * w j = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.insert_erase_invOn", "start": [2012, 1], "end": [2014, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sym/Basic.lean", "full_name": "Sym.cons_inj_right", "start": [120, 1], "end": [121, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/Finrank.lean", "full_name": "LinearEquiv.finrank_map_eq", "start": [119, 1], "end": [121, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/JordanHolder.lean", "full_name": "CompositionSeries.bot_le", "start": [355, 1], "end": [356, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Bicategory/Basic.lean", "full_name": "CategoryTheory.Bicategory.leftUnitor_whiskerRight", "start": [424, 1], "end": [428, 69], "traced_tactics": [{"tactic": "rw [\u2190 whiskerLeft_iff, whiskerLeft_comp, \u2190 cancel_epi (\u03b1_ _ _ _).hom, \u2190\n    cancel_epi ((\u03b1_ _ _ _).hom \u25b7 _), pentagon_assoc, triangle, \u2190 associator_naturality_middle, \u2190\n    comp_whiskerRight_assoc, triangle, associator_naturality_left]", "annotated_tactic": ["rw [\u2190 <a>whiskerLeft_iff</a>, <a>whiskerLeft_comp</a>, \u2190 <a>cancel_epi</a> (\u03b1_ _ _ _).<a>hom</a>, \u2190\n      <a>cancel_epi</a> ((\u03b1_ _ _ _).<a>hom</a> \u25b7 _), <a>pentagon_assoc</a>, <a>triangle</a>, \u2190 <a>associator_naturality_middle</a>, \u2190\n      <a>comp_whiskerRight_assoc</a>, <a>triangle</a>, <a>associator_naturality_left</a>]", [{"full_name": "CategoryTheory.Bicategory.whiskerLeft_iff", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Bicategory/Basic.lean", "def_pos": [414, 9], "def_end_pos": [414, 24]}, {"full_name": "CategoryTheory.Bicategory.whiskerLeft_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Bicategory/Basic.lean", "def_pos": [75, 3], "def_end_pos": [75, 19]}, {"full_name": "CategoryTheory.cancel_epi", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [297, 9], "def_end_pos": [297, 19]}, {"full_name": "CategoryTheory.Iso.hom", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [53, 3], "def_end_pos": [53, 6]}, {"full_name": "CategoryTheory.cancel_epi", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [297, 9], "def_end_pos": [297, 19]}, {"full_name": "CategoryTheory.Iso.hom", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [53, 3], "def_end_pos": [53, 6]}, {"full_name": "CategoryTheory.Bicategory.pentagon_assoc", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Bicategory/Basic.lean", "def_pos": [181, 12], "def_end_pos": [181, 34]}, {"full_name": "CategoryTheory.Bicategory.triangle", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Bicategory/Basic.lean", "def_pos": [123, 3], "def_end_pos": [123, 11]}, {"full_name": "CategoryTheory.Bicategory.associator_naturality_middle", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Bicategory/Basic.lean", "def_pos": [356, 9], "def_end_pos": [356, 37]}, {"full_name": "CategoryTheory.Bicategory.comp_whiskerRight_assoc", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Bicategory/Basic.lean", "def_pos": [177, 12], "def_end_pos": [177, 19]}, {"full_name": "CategoryTheory.Bicategory.triangle", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Bicategory/Basic.lean", "def_pos": [123, 3], "def_end_pos": [123, 11]}, {"full_name": "CategoryTheory.Bicategory.associator_naturality_left", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Bicategory/Basic.lean", "def_pos": [341, 9], "def_end_pos": [341, 35]}]], "state_before": "B : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf : a \u27f6 b\ng : b \u27f6 c\n\u22a2 (\u03bb_ f).hom \u25b7 g = (\u03b1_ (\ud835\udfd9 a) f g).hom \u226b (\u03bb_ (f \u226b g)).hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "MeasureTheory.Measure.ext_of_Ico'", "start": [815, 1], "end": [836, 16], "traced_tactics": [{"tactic": "rcases exists_countable_dense_bot_top \u03b1 with \u27e8s, hsc, hsd, hsb, _\u27e9", "annotated_tactic": ["rcases <a>exists_countable_dense_bot_top</a> \u03b1 with \u27e8s, hsc, hsd, hsb, _\u27e9", [{"full_name": "exists_countable_dense_bot_top", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bases.lean", "def_pos": [653, 9], "def_end_pos": [653, 39]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\n\u22a2 \u03bc = \u03bd", "state_after": "case intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\n\u22a2 \u03bc = \u03bd"}, {"tactic": "have : (\u22c3 (l \u2208 s) (u \u2208 s) (_ : l < u), {Ico l u} : Set (Set \u03b1)).Countable :=\n  hsc.biUnion fun l _ => hsc.biUnion fun u _ => countable_iUnion fun _ => countable_singleton _", "annotated_tactic": ["have : (\u22c3 (l \u2208 s) (u \u2208 s) (_ : l < u), {<a>Ico</a> l u} : <a>Set</a> (<a>Set</a> \u03b1)).<a>Countable</a> :=\n    hsc.biUnion fun l _ => hsc.biUnion fun u _ => <a>countable_iUnion</a> fun _ => <a>countable_singleton</a> _", [{"full_name": "Set.Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [49, 5], "def_end_pos": [49, 8]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "Set.Countable", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [45, 15], "def_end_pos": [45, 24]}, {"full_name": "Set.countable_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [222, 9], "def_end_pos": [222, 25]}, {"full_name": "Set.countable_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [167, 17], "def_end_pos": [167, 36]}]], "state_before": "case intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\n\u22a2 \u03bc = \u03bd", "state_after": "case intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable (\u22c3 l \u2208 s, \u22c3 u \u2208 s, \u22c3 (_ : l < u), {Ico l u})\n\u22a2 \u03bc = \u03bd"}, {"tactic": "simp only [\u2190 setOf_eq_eq_singleton, \u2190 setOf_exists] at this", "annotated_tactic": ["simp only [\u2190 <a>setOf_eq_eq_singleton</a>, \u2190 <a>setOf_exists</a>] at this", [{"full_name": "Set.setOf_eq_eq_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1248, 9], "def_end_pos": [1248, 30]}, {"full_name": "Set.setOf_exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [232, 9], "def_end_pos": [232, 21]}]], "state_before": "case intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable (\u22c3 l \u2208 s, \u22c3 u \u2208 s, \u22c3 (_ : l < u), {Ico l u})\n\u22a2 \u03bc = \u03bd", "state_after": "case intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 \u03bc = \u03bd"}, {"tactic": "refine'\n  Measure.ext_of_generateFrom_of_cover_subset\n    (BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ico \u03b1)) (isPiSystem_Ico id id) _ this\n    _ _ _", "annotated_tactic": ["refine'\n    <a>Measure.ext_of_generateFrom_of_cover_subset</a>\n      (BorelSpace.measurable_eq.trans (<a>borel_eq_generateFrom_Ico</a> \u03b1)) (<a>isPiSystem_Ico</a> <a>id</a> <a>id</a>) _ this\n      _ _ _", [{"full_name": "MeasureTheory.Measure.ext_of_generateFrom_of_cover_subset", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [489, 9], "def_end_pos": [489, 44]}, {"full_name": "borel_eq_generateFrom_Ico", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "def_pos": [746, 9], "def_end_pos": [746, 34]}, {"full_name": "isPiSystem_Ico", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/PiSystem.lean", "def_pos": [209, 9], "def_end_pos": [209, 23]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "case intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 \u03bc = \u03bd", "state_after": "case intro.intro.intro.intro.refine'_1\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2} \u2286 {S | \u2203 l u, l < u \u2227 Ico l u = S}\n\ncase intro.intro.intro.intro.refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 \u22c3\u2080 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2} = univ\n\ncase intro.intro.intro.intro.refine'_3\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 \u2200 s_1 \u2208 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}, \u2191\u2191\u03bc s_1 \u2260 \u22a4\n\ncase intro.intro.intro.intro.refine'_4\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 \u2200 s \u2208 {S | \u2203 l u, l < u \u2227 Ico l u = S}, \u2191\u2191\u03bc s = \u2191\u2191\u03bd s"}, {"tactic": "rintro _ \u27e8l, -, u, -, h, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8l, -, u, -, h, rfl\u27e9", []], "state_before": "case intro.intro.intro.intro.refine'_1\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2} \u2286 {S | \u2203 l u, l < u \u2227 Ico l u = S}", "state_after": "case intro.intro.intro.intro.refine'_1.intro.intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u\u271d : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh\u271d : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nl u : \u03b1\nh : l < u\n\u22a2 Ico l u \u2208 {S | \u2203 l u, l < u \u2227 Ico l u = S}"}, {"tactic": "exact \u27e8l, u, h, rfl\u27e9", "annotated_tactic": ["exact \u27e8l, u, h, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro.intro.intro.intro.refine'_1.intro.intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u\u271d : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh\u271d : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nl u : \u03b1\nh : l < u\n\u22a2 Ico l u \u2208 {S | \u2203 l u, l < u \u2227 Ico l u = S}", "state_after": "no goals"}, {"tactic": "refine' sUnion_eq_univ_iff.2 fun x => _", "annotated_tactic": ["refine' <a>sUnion_eq_univ_iff</a>.2 fun x => _", [{"full_name": "Set.sUnion_eq_univ_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1200, 9], "def_end_pos": [1200, 27]}]], "state_before": "case intro.intro.intro.intro.refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 \u22c3\u2080 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2} = univ", "state_after": "case intro.intro.intro.intro.refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x\u271d : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nx : \u03b1\n\u22a2 \u2203 b \u2208 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}, x \u2208 b"}, {"tactic": "rcases hsd.exists_le' hsb x with \u27e8l, hls, hlx\u27e9", "annotated_tactic": ["rcases hsd.exists_le' hsb x with \u27e8l, hls, hlx\u27e9", []], "state_before": "case intro.intro.intro.intro.refine'_2\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x\u271d : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nx : \u03b1\n\u22a2 \u2203 b \u2208 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}, x \u2208 b", "state_after": "case intro.intro.intro.intro.refine'_2.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x\u271d : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nx l : \u03b1\nhls : l \u2208 s\nhlx : l \u2264 x\n\u22a2 \u2203 b \u2208 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}, x \u2208 b"}, {"tactic": "rcases hsd.exists_gt x with \u27e8u, hus, hxu\u27e9", "annotated_tactic": ["rcases hsd.exists_gt x with \u27e8u, hus, hxu\u27e9", []], "state_before": "case intro.intro.intro.intro.refine'_2.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x\u271d : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nx l : \u03b1\nhls : l \u2208 s\nhlx : l \u2264 x\n\u22a2 \u2203 b \u2208 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}, x \u2208 b", "state_after": "case intro.intro.intro.intro.refine'_2.intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u\u271d : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x\u271d : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nx l : \u03b1\nhls : l \u2208 s\nhlx : l \u2264 x\nu : \u03b1\nhus : u \u2208 s\nhxu : x < u\n\u22a2 \u2203 b \u2208 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}, x \u2208 b"}, {"tactic": "exact \u27e8_, \u27e8l, hls, u, hus, hlx.trans_lt hxu, rfl\u27e9, hlx, hxu\u27e9", "annotated_tactic": ["exact \u27e8_, \u27e8l, hls, u, hus, hlx.trans_lt hxu, <a>rfl</a>\u27e9, hlx, hxu\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro.intro.intro.intro.refine'_2.intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u\u271d : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x\u271d : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nx l : \u03b1\nhls : l \u2208 s\nhlx : l \u2264 x\nu : \u03b1\nhus : u \u2208 s\nhxu : x < u\n\u22a2 \u2203 b \u2208 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}, x \u2208 b", "state_after": "no goals"}, {"tactic": "rintro _ \u27e8l, -, u, -, hlt, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8l, -, u, -, hlt, rfl\u27e9", []], "state_before": "case intro.intro.intro.intro.refine'_3\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 \u2200 s_1 \u2208 {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}, \u2191\u2191\u03bc s_1 \u2260 \u22a4", "state_after": "case intro.intro.intro.intro.refine'_3.intro.intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u\u271d : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nl u : \u03b1\nhlt : l < u\n\u22a2 \u2191\u2191\u03bc (Ico l u) \u2260 \u22a4"}, {"tactic": "exact h\u03bc hlt", "annotated_tactic": ["exact h\u03bc hlt", []], "state_before": "case intro.intro.intro.intro.refine'_3.intro.intro.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u\u271d : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nl u : \u03b1\nhlt : l < u\n\u22a2 \u2191\u2191\u03bc (Ico l u) \u2260 \u22a4", "state_after": "no goals"}, {"tactic": "rintro _ \u27e8l, u, hlt, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8l, u, hlt, rfl\u27e9", []], "state_before": "case intro.intro.intro.intro.refine'_4\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\n\u22a2 \u2200 s \u2208 {S | \u2203 l u, l < u \u2227 Ico l u = S}, \u2191\u2191\u03bc s = \u2191\u2191\u03bd s", "state_after": "case intro.intro.intro.intro.refine'_4.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u\u271d : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nl u : \u03b1\nhlt : l < u\n\u22a2 \u2191\u2191\u03bc (Ico l u) = \u2191\u2191\u03bd (Ico l u)"}, {"tactic": "exact h hlt", "annotated_tactic": ["exact h hlt", []], "state_before": "case intro.intro.intro.intro.refine'_4.intro.intro.intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3\u2082 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort y\ns\u271d t u\u271d : Set \u03b1\u271d\ninst\u271d\u00b2\u00b2 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b2\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2\u2070 : OpensMeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : OpensMeasurableSpace \u03b2\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b3\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b3\ninst\u271d\u00b9\u2074 : BorelSpace \u03b3\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b3\u2082\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b3\u2082\ninst\u271d\u00b9\u00b9 : BorelSpace \u03b3\u2082\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b4\n\u03b1' : Type u_6\ninst\u271d\u2079 : TopologicalSpace \u03b1'\ninst\u271d\u2078 : MeasurableSpace \u03b1'\ninst\u271d\u2077 : LinearOrder \u03b1\u271d\ninst\u271d\u2076 : OrderClosedTopology \u03b1\u271d\na b x : \u03b1\u271d\n\u03b1 : Type u_7\ninst\u271d\u2075 : TopologicalSpace \u03b1\nm : MeasurableSpace \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : NoMaxOrder \u03b1\n\u03bc \u03bd : Measure \u03b1\nh\u03bc : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) \u2260 \u22a4\nh : \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u2191\u2191\u03bc (Ico a b) = \u2191\u2191\u03bd (Ico a b)\ns : Set \u03b1\nhsc : Set.Countable s\nhsd : Dense s\nhsb : \u2200 (x : \u03b1), IsBot x \u2192 x \u2208 s\nright\u271d : \u2200 (x : \u03b1), IsTop x \u2192 x \u2208 s\nthis : Set.Countable {x | \u2203 i, \u2203 (_ : i \u2208 s), \u2203 i_2, \u2203 (_ : i_2 \u2208 s) (_ : i < i_2), x = Ico i i_2}\nl u : \u03b1\nhlt : l < u\n\u22a2 \u2191\u2191\u03bc (Ico l u) = \u2191\u2191\u03bd (Ico l u)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Determinant.lean", "full_name": "LinearMap.associated_det_of_eq_comp", "start": [480, 1], "end": [487, 76], "traced_tactics": [{"tactic": "suffices Associated (LinearMap.det (f' \u2218\u2097 \u2191e)) (LinearMap.det f') by\n  convert this using 2\n  ext x\n  exact h x", "annotated_tactic": ["suffices <a>Associated</a> (<a>LinearMap.det</a> (f' \u2218\u2097 \u2191e)) (<a>LinearMap.det</a> f') by\n    convert this using 2\n    ext x\n    exact h x", [{"full_name": "Associated", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [378, 5], "def_end_pos": [378, 15]}, {"full_name": "LinearMap.det", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [172, 27], "def_end_pos": [172, 30]}, {"full_name": "LinearMap.det", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [172, 27], "def_end_pos": [172, 30]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\n\u22a2 Associated (LinearMap.det f) (LinearMap.det f')", "state_after": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\n\u22a2 Associated (LinearMap.det (f' \u2218\u2097 \u2191e)) (LinearMap.det f')"}, {"tactic": "rw [\u2190 mul_one (LinearMap.det f'), LinearMap.det_comp]", "annotated_tactic": ["rw [\u2190 <a>mul_one</a> (<a>LinearMap.det</a> f'), <a>LinearMap.det_comp</a>]", [{"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "LinearMap.det", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [172, 27], "def_end_pos": [172, 30]}, {"full_name": "LinearMap.det_comp", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [241, 9], "def_end_pos": [241, 17]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\n\u22a2 Associated (LinearMap.det (f' \u2218\u2097 \u2191e)) (LinearMap.det f')", "state_after": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\n\u22a2 Associated (LinearMap.det f' * LinearMap.det \u2191e) (LinearMap.det f' * 1)"}, {"tactic": "exact Associated.mul_left _ (associated_one_iff_isUnit.mpr e.isUnit_det')", "annotated_tactic": ["exact <a>Associated.mul_left</a> _ (associated_one_iff_isUnit.mpr e.isUnit_det')", [{"full_name": "Associated.mul_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [527, 9], "def_end_pos": [527, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\n\u22a2 Associated (LinearMap.det f' * LinearMap.det \u2191e) (LinearMap.det f' * 1)", "state_after": "no goals"}, {"tactic": "convert this using 2", "annotated_tactic": ["convert this using 2", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\nthis : Associated (LinearMap.det (f' \u2218\u2097 \u2191e)) (LinearMap.det f')\n\u22a2 Associated (LinearMap.det f) (LinearMap.det f')", "state_after": "case h.e'_3.h.e'_6\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\nthis : Associated (LinearMap.det (f' \u2218\u2097 \u2191e)) (LinearMap.det f')\n\u22a2 f = f' \u2218\u2097 \u2191e"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "case h.e'_3.h.e'_6\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\nthis : Associated (LinearMap.det (f' \u2218\u2097 \u2191e)) (LinearMap.det f')\n\u22a2 f = f' \u2218\u2097 \u2191e", "state_after": "case h.e'_3.h.e'_6.h\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\nthis : Associated (LinearMap.det (f' \u2218\u2097 \u2191e)) (LinearMap.det f')\nx : M\n\u22a2 f x = (f' \u2218\u2097 \u2191e) x"}, {"tactic": "exact h x", "annotated_tactic": ["exact h x", []], "state_before": "case h.e'_3.h.e'_6.h\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne\u271d : Basis \u03b9 R M\ne : M \u2243\u2097[R] M\nf f' : M \u2192\u2097[R] M\nh : \u2200 (x : M), f x = f' (e x)\nthis : Associated (LinearMap.det (f' \u2218\u2097 \u2191e)) (LinearMap.det f')\nx : M\n\u22a2 f x = (f' \u2218\u2097 \u2191e) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Defs.lean", "full_name": "AddLECancellable.tsub_eq_of_eq_add", "start": [286, 11], "end": [289, 25], "traced_tactics": [{"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nhb : AddLECancellable b\nh : a = c + b\n\u22a2 c \u2264 a - b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nhb : AddLECancellable b\nh : a = c + b\n\u22a2 c \u2264 c + b - b"}, {"tactic": "exact hb.le_add_tsub", "annotated_tactic": ["exact hb.le_add_tsub", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nhb : AddLECancellable b\nh : a = c + b\n\u22a2 c \u2264 c + b - b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.sum_mem", "start": [366, 11], "end": [368, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.PullbackCone.IsLimit.lift_fst", "start": [658, 1], "end": [660, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "contDiffWithinAt_succ_iff_hasFDerivWithinAt'", "start": [604, 1], "end": [621, 85], "traced_tactics": [{"tactic": "refine' \u27e8fun hf => _, _\u27e9", "annotated_tactic": ["refine' \u27e8fun hf => _, _\u27e9", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x \u2194\n    \u2203 u \u2208 \ud835\udcdd[insert x s] x,\n      u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x", "state_after": "case refine'_1\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x,\n    u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\n\ncase refine'_2\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\n\u22a2 (\u2203 u \u2208 \ud835\udcdd[insert x s] x,\n      u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x) \u2192\n    ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x"}, {"tactic": "obtain \u27e8u, hu, f', huf', hf'\u27e9 := contDiffWithinAt_succ_iff_hasFDerivWithinAt.mp hf", "annotated_tactic": ["obtain \u27e8u, hu, f', huf', hf'\u27e9 := contDiffWithinAt_succ_iff_hasFDerivWithinAt.mp hf", []], "state_before": "case refine'_1\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x,\n    u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x", "state_after": "case refine'_1.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x,\n    u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x"}, {"tactic": "obtain \u27e8w, hw, hxw, hwu\u27e9 := mem_nhdsWithin.mp hu", "annotated_tactic": ["obtain \u27e8w, hw, hxw, hwu\u27e9 := mem_nhdsWithin.mp hu", []], "state_before": "case refine'_1.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x,\n    u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x", "state_after": "case refine'_1.intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : w \u2229 insert x s \u2286 u\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x,\n    u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x"}, {"tactic": "rw [inter_comm] at hwu", "annotated_tactic": ["rw [<a>inter_comm</a>] at hwu", [{"full_name": "Set.inter_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [908, 9], "def_end_pos": [908, 19]}]], "state_before": "case refine'_1.intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : w \u2229 insert x s \u2286 u\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x,\n    u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x", "state_after": "case refine'_1.intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x,\n    u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x"}, {"tactic": "refine' \u27e8insert x s \u2229 w, inter_mem_nhdsWithin _ (hw.mem_nhds hxw), inter_subset_left _ _, f',\n  fun y hy => _, _\u27e9", "annotated_tactic": ["refine' \u27e8<a>insert</a> x s \u2229 w, <a>inter_mem_nhdsWithin</a> _ (hw.mem_nhds hxw), <a>inter_subset_left</a> _ _, f',\n      fun y hy => _, _\u27e9", [{"full_name": "Insert.insert", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [456, 3], "def_end_pos": [456, 9]}, {"full_name": "inter_mem_nhdsWithin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [156, 9], "def_end_pos": [156, 29]}, {"full_name": "Set.inter_subset_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [933, 9], "def_end_pos": [933, 26]}]], "state_before": "case refine'_1.intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x,\n    u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x", "state_after": "case refine'_1.intro.intro.intro.intro.intro.intro.intro.refine'_1\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\ny : E\nhy : y \u2208 insert x s \u2229 w\n\u22a2 HasFDerivWithinAt f (f' y) s y\n\ncase refine'_1.intro.intro.intro.intro.intro.intro.intro.refine'_2\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x"}, {"tactic": "refine' ((huf' y <| hwu hy).mono hwu).mono_of_mem _", "annotated_tactic": ["refine' ((huf' y <| hwu hy).<a>mono</a> hwu).<a>mono_of_mem</a> _", [{"full_name": "HasFDerivWithinAt.mono", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [376, 16], "def_end_pos": [376, 38]}, {"full_name": "HasFDerivWithinAt.mono_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [370, 9], "def_end_pos": [370, 38]}]], "state_before": "case refine'_1.intro.intro.intro.intro.intro.intro.intro.refine'_1\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\ny : E\nhy : y \u2208 insert x s \u2229 w\n\u22a2 HasFDerivWithinAt f (f' y) s y", "state_after": "case refine'_1.intro.intro.intro.intro.intro.intro.intro.refine'_1\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\ny : E\nhy : y \u2208 insert x s \u2229 w\n\u22a2 insert x s \u2229 w \u2208 \ud835\udcdd[s] y"}, {"tactic": "refine' mem_of_superset _ (inter_subset_inter_left _ (subset_insert _ _))", "annotated_tactic": ["refine' <a>mem_of_superset</a> _ (<a>inter_subset_inter_left</a> _ (<a>subset_insert</a> _ _))", [{"full_name": "Filter.mem_of_superset", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [152, 9], "def_end_pos": [152, 24]}, {"full_name": "Set.inter_subset_inter_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [997, 9], "def_end_pos": [997, 32]}, {"full_name": "Set.subset_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1093, 9], "def_end_pos": [1093, 22]}]], "state_before": "case refine'_1.intro.intro.intro.intro.intro.intro.intro.refine'_1\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\ny : E\nhy : y \u2208 insert x s \u2229 w\n\u22a2 insert x s \u2229 w \u2208 \ud835\udcdd[s] y", "state_after": "case refine'_1.intro.intro.intro.intro.intro.intro.intro.refine'_1\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\ny : E\nhy : y \u2208 insert x s \u2229 w\n\u22a2 s \u2229 w \u2208 \ud835\udcdd[s] y"}, {"tactic": "exact inter_mem_nhdsWithin _ (hw.mem_nhds hy.2)", "annotated_tactic": ["exact <a>inter_mem_nhdsWithin</a> _ (hw.mem_nhds hy.2)", [{"full_name": "inter_mem_nhdsWithin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [156, 9], "def_end_pos": [156, 29]}]], "state_before": "case refine'_1.intro.intro.intro.intro.intro.intro.intro.refine'_1\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\ny : E\nhy : y \u2208 insert x s \u2229 w\n\u22a2 s \u2229 w \u2208 \ud835\udcdd[s] y", "state_after": "no goals"}, {"tactic": "exact hf'.mono_of_mem (nhdsWithin_mono _ (subset_insert _ _) hu)", "annotated_tactic": ["exact hf'.mono_of_mem (<a>nhdsWithin_mono</a> _ (<a>subset_insert</a> _ _) hu)", [{"full_name": "nhdsWithin_mono", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [160, 9], "def_end_pos": [160, 24]}, {"full_name": "Set.subset_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1093, 9], "def_end_pos": [1093, 22]}]], "state_before": "case refine'_1.intro.intro.intro.intro.intro.intro.intro.refine'_2\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nhf : ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x\nw : Set E\nhw : IsOpen w\nhxw : x \u2208 w\nhwu : insert x s \u2229 w \u2286 u\n\u22a2 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x", "state_after": "no goals"}, {"tactic": "rw [\u2190 contDiffWithinAt_insert, contDiffWithinAt_succ_iff_hasFDerivWithinAt,\n  insert_eq_of_mem (mem_insert _ _)]", "annotated_tactic": ["rw [\u2190 <a>contDiffWithinAt_insert</a>, <a>contDiffWithinAt_succ_iff_hasFDerivWithinAt</a>,\n      <a>insert_eq_of_mem</a> (<a>mem_insert</a> _ _)]", [{"full_name": "contDiffWithinAt_insert", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [520, 9], "def_end_pos": [520, 32]}, {"full_name": "contDiffWithinAt_succ_iff_hasFDerivWithinAt", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [553, 9], "def_end_pos": [553, 52]}, {"full_name": "Set.insert_eq_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1122, 9], "def_end_pos": [1122, 25]}, {"full_name": "Set.mem_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1096, 9], "def_end_pos": [1096, 19]}]], "state_before": "case refine'_2\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\n\u22a2 (\u2203 u \u2208 \ud835\udcdd[insert x s] x,\n      u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x) \u2192\n    ContDiffWithinAt \ud835\udd5c (\u2191(n + 1)) f s x", "state_after": "case refine'_2\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\n\u22a2 (\u2203 u \u2208 \ud835\udcdd[insert x s] x,\n      u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x) \u2192\n    \u2203 u \u2208 \ud835\udcdd[insert x s] x, \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x"}, {"tactic": "rintro \u27e8u, hu, hus, f', huf', hf'\u27e9", "annotated_tactic": ["rintro \u27e8u, hu, hus, f', huf', hf'\u27e9", []], "state_before": "case refine'_2\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\n\u22a2 (\u2203 u \u2208 \ud835\udcdd[insert x s] x,\n      u \u2286 insert x s \u2227 \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x) \u2192\n    \u2203 u \u2208 \ud835\udcdd[insert x s] x, \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x", "state_after": "case refine'_2.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nhus : u \u2286 insert x s\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x, \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x"}, {"tactic": "exact \u27e8u, hu, f', fun y hy => (huf' y hy).insert'.mono hus, hf'.insert.mono hus\u27e9", "annotated_tactic": ["exact \u27e8u, hu, f', fun y hy => (huf' y hy).insert'.mono hus, hf'.insert.mono hus\u27e9", []], "state_before": "case refine'_2.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert x s] x\nhus : u \u2286 insert x s\nf' : E \u2192 E \u2192L[\ud835\udd5c] F\nhuf' : \u2200 x \u2208 u, HasFDerivWithinAt f (f' x) s x\nhf' : ContDiffWithinAt \ud835\udd5c (\u2191n) f' s x\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x, \u2203 f', (\u2200 x \u2208 u, HasFDerivWithinAt f (f' x) u x) \u2227 ContDiffWithinAt \ud835\udd5c (\u2191n) f' u x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.map_pmap", "start": [1577, 1], "end": [1579, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "full_name": "Equiv.refl_toPartialEquiv", "start": [1086, 1], "end": [1087, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean", "full_name": "SimpleGraph.mk'_mem_incidenceSet_left_iff", "start": [722, 1], "end": [723, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.subset_image\u2082", "start": [531, 1], "end": [539, 85], "traced_tactics": [{"tactic": "rw [\u2190 Set.image_prod, subset_image_iff] at hu", "annotated_tactic": ["rw [\u2190 <a>Set.image_prod</a>, <a>subset_image_iff</a>] at hu", [{"full_name": "Set.image_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [79, 7], "def_end_pos": [79, 17]}, {"full_name": "Finset.subset_image_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [836, 9], "def_end_pos": [836, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nhu : \u2191u \u2286 image2 f s t\n\u22a2 \u2203 s' t', \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 image\u2082 f s' t'", "state_after": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nhu : \u2203 s', \u2191s' \u2286 s \u00d7\u02e2 t \u2227 image (fun x => f x.1 x.2) s' = u\n\u22a2 \u2203 s' t', \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 image\u2082 f s' t'"}, {"tactic": "rcases hu with \u27e8u, hu, rfl\u27e9", "annotated_tactic": ["rcases hu with \u27e8u, hu, rfl\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nhu : \u2203 s', \u2191s' \u2286 s \u00d7\u02e2 t \u2227 image (fun x => f x.1 x.2) s' = u\n\u22a2 \u2203 s' t', \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 image\u2082 f s' t'", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nu : Finset (\u03b1 \u00d7 \u03b2)\nhu : \u2191u \u2286 s \u00d7\u02e2 t\n\u22a2 \u2203 s' t', \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 image (fun x => f x.1 x.2) u \u2286 image\u2082 f s' t'"}, {"tactic": "classical\nuse u.image Prod.fst, u.image Prod.snd\nsimp only [coe_image, Set.image_subset_iff, image\u2082_image_left, image\u2082_image_right,\n  image_subset_iff]\nexact \u27e8fun _ h \u21a6 (hu h).1, fun _ h \u21a6 (hu h).2, fun x hx \u21a6 mem_image\u2082_of_mem hx hx\u27e9", "annotated_tactic": ["classical\n  use u.image <a>Prod.fst</a>, u.image <a>Prod.snd</a>\n  simp only [<a>coe_image</a>, <a>Set.image_subset_iff</a>, <a>image\u2082_image_left</a>, <a>image\u2082_image_right</a>,\n    <a>image_subset_iff</a>]\n  exact \u27e8fun _ h \u21a6 (hu h).1, fun _ h \u21a6 (hu h).2, fun x hx \u21a6 <a>mem_image\u2082_of_mem</a> hx hx\u27e9", [{"full_name": "Prod.fst", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [481, 3], "def_end_pos": [481, 6]}, {"full_name": "Prod.snd", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [483, 3], "def_end_pos": [483, 6]}, {"full_name": "Finset.coe_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [423, 9], "def_end_pos": [423, 18]}, {"full_name": "Set.image_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [480, 9], "def_end_pos": [480, 25]}, {"full_name": "Finset.image\u2082_image_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [299, 9], "def_end_pos": [299, 26]}, {"full_name": "Finset.image\u2082_image_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [306, 9], "def_end_pos": [306, 27]}, {"full_name": "Finset.image_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [484, 9], "def_end_pos": [484, 25]}, {"full_name": "Finset.mem_image\u2082_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [70, 9], "def_end_pos": [70, 26]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nu : Finset (\u03b1 \u00d7 \u03b2)\nhu : \u2191u \u2286 s \u00d7\u02e2 t\n\u22a2 \u2203 s' t', \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 image (fun x => f x.1 x.2) u \u2286 image\u2082 f s' t'", "state_after": "no goals"}, {"tactic": "use u.image Prod.fst, u.image Prod.snd", "annotated_tactic": ["use u.image <a>Prod.fst</a>, u.image <a>Prod.snd</a>", [{"full_name": "Prod.fst", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [481, 3], "def_end_pos": [481, 6]}, {"full_name": "Prod.snd", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [483, 3], "def_end_pos": [483, 6]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nu : Finset (\u03b1 \u00d7 \u03b2)\nhu : \u2191u \u2286 s \u00d7\u02e2 t\n\u22a2 \u2203 s' t', \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 image (fun x => f x.1 x.2) u \u2286 image\u2082 f s' t'", "state_after": "case h\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nu : Finset (\u03b1 \u00d7 \u03b2)\nhu : \u2191u \u2286 s \u00d7\u02e2 t\n\u22a2 \u2191(image Prod.fst u) \u2286 s \u2227\n    \u2191(image Prod.snd u) \u2286 t \u2227 image (fun x => f x.1 x.2) u \u2286 image\u2082 f (image Prod.fst u) (image Prod.snd u)"}, {"tactic": "simp only [coe_image, Set.image_subset_iff, image\u2082_image_left, image\u2082_image_right,\n  image_subset_iff]", "annotated_tactic": ["simp only [<a>coe_image</a>, <a>Set.image_subset_iff</a>, <a>image\u2082_image_left</a>, <a>image\u2082_image_right</a>,\n    <a>image_subset_iff</a>]", [{"full_name": "Finset.coe_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [423, 9], "def_end_pos": [423, 18]}, {"full_name": "Set.image_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [480, 9], "def_end_pos": [480, 25]}, {"full_name": "Finset.image\u2082_image_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [299, 9], "def_end_pos": [299, 26]}, {"full_name": "Finset.image\u2082_image_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [306, 9], "def_end_pos": [306, 27]}, {"full_name": "Finset.image_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [484, 9], "def_end_pos": [484, 25]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nu : Finset (\u03b1 \u00d7 \u03b2)\nhu : \u2191u \u2286 s \u00d7\u02e2 t\n\u22a2 \u2191(image Prod.fst u) \u2286 s \u2227\n    \u2191(image Prod.snd u) \u2286 t \u2227 image (fun x => f x.1 x.2) u \u2286 image\u2082 f (image Prod.fst u) (image Prod.snd u)", "state_after": "case h\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nu : Finset (\u03b1 \u00d7 \u03b2)\nhu : \u2191u \u2286 s \u00d7\u02e2 t\n\u22a2 \u2191u \u2286 Prod.fst \u207b\u00b9' s \u2227 \u2191u \u2286 Prod.snd \u207b\u00b9' t \u2227 \u2200 x \u2208 u, f x.1 x.2 \u2208 image\u2082 (fun a b => f a.1 b.2) u u"}, {"tactic": "exact \u27e8fun _ h \u21a6 (hu h).1, fun _ h \u21a6 (hu h).2, fun x hx \u21a6 mem_image\u2082_of_mem hx hx\u27e9", "annotated_tactic": ["exact \u27e8fun _ h \u21a6 (hu h).1, fun _ h \u21a6 (hu h).2, fun x hx \u21a6 <a>mem_image\u2082_of_mem</a> hx hx\u27e9", [{"full_name": "Finset.mem_image\u2082_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [70, 9], "def_end_pos": [70, 26]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\nu' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ns : Set \u03b1\nt : Set \u03b2\nu : Finset (\u03b1 \u00d7 \u03b2)\nhu : \u2191u \u2286 s \u00d7\u02e2 t\n\u22a2 \u2191u \u2286 Prod.fst \u207b\u00b9' s \u2227 \u2191u \u2286 Prod.snd \u207b\u00b9' t \u2227 \u2200 x \u2208 u, f x.1 x.2 \u2208 image\u2082 (fun a b => f a.1 b.2) u u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Pointwise.lean", "full_name": "Submodule.coe_span_smul", "start": [561, 1], "end": [576, 47], "traced_tactics": [{"tactic": "rintro r n hr hn", "annotated_tactic": ["rintro r n hr hn", []], "state_before": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\n\u22a2 \u2200 \u2983r : R'\u2984 \u2983n : M'\u2984, r \u2208 \u2191(Ideal.span s) \u2192 n \u2208 N \u2192 r \u2022 n \u2208 s \u2022 N", "state_after": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhr : r \u2208 \u2191(Ideal.span s)\nhn : n \u2208 N\n\u22a2 r \u2022 n \u2208 s \u2022 N"}, {"tactic": "induction' hr using Submodule.span_induction' with r h _ _ _ _ ihr ihs r r' hr hr'", "annotated_tactic": ["induction' hr using <a>Submodule.span_induction'</a> with r h _ _ _ _ ihr ihs r r' hr hr'", [{"full_name": "Submodule.span_induction'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [188, 9], "def_end_pos": [188, 24]}]], "state_before": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhr : r \u2208 \u2191(Ideal.span s)\nhn : n \u2208 N\n\u22a2 r \u2022 n \u2208 s \u2022 N", "state_after": "case mem\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nh : r \u2208 s\n\u22a2 r \u2022 n \u2208 s \u2022 N\n\ncase zero\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhn : n \u2208 N\n\u22a2 0 \u2022 n \u2208 s \u2022 N\n\ncase add\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhn : n \u2208 N\nx\u271d : R'\nhx\u271d : x\u271d \u2208 span R' s\ny\u271d : R'\nhy\u271d : y\u271d \u2208 span R' s\nihr : x\u271d \u2022 n \u2208 s \u2022 N\nihs : y\u271d \u2022 n \u2208 s \u2022 N\n\u22a2 (x\u271d + y\u271d) \u2022 n \u2208 s \u2022 N\n\ncase smul\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr r' : R'\nhr : r' \u2208 span R' s\nhr' : r' \u2022 n \u2208 s \u2022 N\n\u22a2 (r \u2022 r') \u2022 n \u2208 s \u2022 N"}, {"tactic": "exact mem_set_smul_of_mem_mem h hn", "annotated_tactic": ["exact <a>mem_set_smul_of_mem_mem</a> h hn", [{"full_name": "Submodule.mem_set_smul_of_mem_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Pointwise.lean", "def_pos": [353, 7], "def_end_pos": [353, 30]}]], "state_before": "case mem\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nh : r \u2208 s\n\u22a2 r \u2022 n \u2208 s \u2022 N", "state_after": "no goals"}, {"tactic": "rw [zero_smul]", "annotated_tactic": ["rw [<a>zero_smul</a>]", [{"full_name": "zero_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}]], "state_before": "case zero\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhn : n \u2208 N\n\u22a2 0 \u2022 n \u2208 s \u2022 N", "state_after": "case zero\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhn : n \u2208 N\n\u22a2 0 \u2208 s \u2022 N"}, {"tactic": "exact Submodule.zero_mem _", "annotated_tactic": ["exact <a>Submodule.zero_mem</a> _", [{"full_name": "Submodule.zero_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [218, 19], "def_end_pos": [218, 27]}]], "state_before": "case zero\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhn : n \u2208 N\n\u22a2 0 \u2208 s \u2022 N", "state_after": "no goals"}, {"tactic": "rw [add_smul]", "annotated_tactic": ["rw [<a>add_smul</a>]", [{"full_name": "add_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [92, 9], "def_end_pos": [92, 17]}]], "state_before": "case add\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhn : n \u2208 N\nx\u271d : R'\nhx\u271d : x\u271d \u2208 span R' s\ny\u271d : R'\nhy\u271d : y\u271d \u2208 span R' s\nihr : x\u271d \u2022 n \u2208 s \u2022 N\nihs : y\u271d \u2022 n \u2208 s \u2022 N\n\u22a2 (x\u271d + y\u271d) \u2022 n \u2208 s \u2022 N", "state_after": "case add\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhn : n \u2208 N\nx\u271d : R'\nhx\u271d : x\u271d \u2208 span R' s\ny\u271d : R'\nhy\u271d : y\u271d \u2208 span R' s\nihr : x\u271d \u2022 n \u2208 s \u2022 N\nihs : y\u271d \u2022 n \u2208 s \u2022 N\n\u22a2 x\u271d \u2022 n + y\u271d \u2022 n \u2208 s \u2022 N"}, {"tactic": "exact Submodule.add_mem _ ihr ihs", "annotated_tactic": ["exact <a>Submodule.add_mem</a> _ ihr ihs", [{"full_name": "Submodule.add_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [222, 19], "def_end_pos": [222, 26]}]], "state_before": "case add\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr : R'\nn : M'\nhn : n \u2208 N\nx\u271d : R'\nhx\u271d : x\u271d \u2208 span R' s\ny\u271d : R'\nhy\u271d : y\u271d \u2208 span R' s\nihr : x\u271d \u2022 n \u2208 s \u2022 N\nihs : y\u271d \u2022 n \u2208 s \u2022 N\n\u22a2 x\u271d \u2022 n + y\u271d \u2022 n \u2208 s \u2022 N", "state_after": "no goals"}, {"tactic": "rw [mem_span_set] at hr", "annotated_tactic": ["rw [<a>mem_span_set</a>] at hr", [{"full_name": "mem_span_set", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [1322, 9], "def_end_pos": [1322, 21]}]], "state_before": "case smul\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr r' : R'\nhr : r' \u2208 span R' s\nhr' : r' \u2022 n \u2208 s \u2022 N\n\u22a2 (r \u2022 r') \u2022 n \u2208 s \u2022 N", "state_after": "case smul\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr r' : R'\nhr : \u2203 c, \u2191c.support \u2286 s \u2227 (Finsupp.sum c fun mi r => r \u2022 mi) = r'\nhr' : r' \u2022 n \u2208 s \u2022 N\n\u22a2 (r \u2022 r') \u2022 n \u2208 s \u2022 N"}, {"tactic": "obtain \u27e8c, hc, rfl\u27e9 := hr", "annotated_tactic": ["obtain \u27e8c, hc, rfl\u27e9 := hr", []], "state_before": "case smul\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr r' : R'\nhr : \u2203 c, \u2191c.support \u2286 s \u2227 (Finsupp.sum c fun mi r => r \u2022 mi) = r'\nhr' : r' \u2022 n \u2208 s \u2022 N\n\u22a2 (r \u2022 r') \u2022 n \u2208 s \u2022 N", "state_after": "case smul.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nc : R' \u2192\u2080 R'\nhc : \u2191c.support \u2286 s\nhr' : (Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N\n\u22a2 (r \u2022 Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N"}, {"tactic": "rw [Finsupp.sum, Finset.smul_sum, Finset.sum_smul]", "annotated_tactic": ["rw [<a>Finsupp.sum</a>, <a>Finset.smul_sum</a>, <a>Finset.sum_smul</a>]", [{"full_name": "Finsupp.sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [47, 3], "def_end_pos": [47, 14]}, {"full_name": "Finset.smul_sum", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/BigOperators.lean", "def_pos": [52, 9], "def_end_pos": [52, 24]}, {"full_name": "Finset.sum_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/BigOperators.lean", "def_pos": [38, 9], "def_end_pos": [38, 24]}]], "state_before": "case smul.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nc : R' \u2192\u2080 R'\nhc : \u2191c.support \u2286 s\nhr' : (Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N\n\u22a2 (r \u2022 Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N", "state_after": "case smul.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nc : R' \u2192\u2080 R'\nhc : \u2191c.support \u2286 s\nhr' : (Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N\n\u22a2 (Finset.sum c.support fun i => (r \u2022 c i \u2022 i) \u2022 n) \u2208 s \u2022 N"}, {"tactic": "refine Submodule.sum_mem _ fun i hi => ?_", "annotated_tactic": ["refine <a>Submodule.sum_mem</a> _ fun i hi => ?_", [{"full_name": "Submodule.sum_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [235, 19], "def_end_pos": [235, 26]}]], "state_before": "case smul.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nc : R' \u2192\u2080 R'\nhc : \u2191c.support \u2286 s\nhr' : (Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N\n\u22a2 (Finset.sum c.support fun i => (r \u2022 c i \u2022 i) \u2022 n) \u2208 s \u2022 N", "state_after": "case smul.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nc : R' \u2192\u2080 R'\nhc : \u2191c.support \u2286 s\nhr' : (Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N\ni : R'\nhi : i \u2208 c.support\n\u22a2 (r \u2022 c i \u2022 i) \u2022 n \u2208 s \u2022 N"}, {"tactic": "rw [\u2190 mul_smul, smul_eq_mul, mul_comm, mul_smul]", "annotated_tactic": ["rw [\u2190 <a>mul_smul</a>, <a>smul_eq_mul</a>, <a>mul_comm</a>, <a>mul_smul</a>]", [{"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}, {"full_name": "smul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}]], "state_before": "case smul.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nc : R' \u2192\u2080 R'\nhc : \u2191c.support \u2286 s\nhr' : (Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N\ni : R'\nhi : i \u2208 c.support\n\u22a2 (r \u2022 c i \u2022 i) \u2022 n \u2208 s \u2022 N", "state_after": "case smul.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nc : R' \u2192\u2080 R'\nhc : \u2191c.support \u2286 s\nhr' : (Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N\ni : R'\nhi : i \u2208 c.support\n\u22a2 i \u2022 (r * c i) \u2022 n \u2208 s \u2022 N"}, {"tactic": "exact mem_set_smul_of_mem_mem (hc hi) <| Submodule.smul_mem _ _ hn", "annotated_tactic": ["exact <a>mem_set_smul_of_mem_mem</a> (hc hi) <| <a>Submodule.smul_mem</a> _ _ hn", [{"full_name": "Submodule.mem_set_smul_of_mem_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Pointwise.lean", "def_pos": [353, 7], "def_end_pos": [353, 30]}, {"full_name": "Submodule.smul_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}]], "state_before": "case smul.intro.intro\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Module R M\nS : Type u_4\ninst\u271d\u2076 : Monoid S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : DistribMulAction S M\nsR : Set R\ns\u271d : Set S\nN\u271d : Submodule R M\nR' : Type u_5\nM' : Type u_6\ninst\u271d\u00b2 : CommSemiring R'\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R' M'\ns : Set R'\nN : Submodule R' M'\nr\u271d : R'\nn : M'\nhn : n \u2208 N\nr : R'\nc : R' \u2192\u2080 R'\nhc : \u2191c.support \u2286 s\nhr' : (Finsupp.sum c fun mi r => r \u2022 mi) \u2022 n \u2208 s \u2022 N\ni : R'\nhi : i \u2208 c.support\n\u22a2 i \u2022 (r * c i) \u2022 n \u2208 s \u2022 N", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.floor_zero", "start": [738, 1], "end": [738, 73], "traced_tactics": [{"tactic": "rw [\u2190 cast_zero, floor_intCast]", "annotated_tactic": ["rw [\u2190 <a>cast_zero</a>, <a>floor_intCast</a>]", [{"full_name": "Int.cast_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 18]}, {"full_name": "Int.floor_intCast", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [728, 9], "def_end_pos": [728, 22]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\n\u22a2 \u230a0\u230b = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Sigma.lean", "full_name": "Set.Nonempty.sigma", "start": [228, 11], "end": [231, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.isCobounded_bot", "start": [269, 1], "end": [269, 85], "traced_tactics": [{"tactic": "simp [IsCobounded]", "annotated_tactic": ["simp [<a>IsCobounded</a>]", [{"full_name": "Filter.IsCobounded", "def_path": ".lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean", "def_pos": [197, 5], "def_end_pos": [197, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : Filter \u03b1\n\u22a2 IsCobounded r \u22a5 \u2194 \u2203 b, \u2200 (x : \u03b1), r b x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Function.lean", "full_name": "concaveOn_iff_convex_hypograph", "start": [266, 1], "end": [268, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.Nonempty.inr", "start": [1518, 1], "end": [1519, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.dotProduct_pUnit", "start": [771, 1], "end": [772, 20], "traced_tactics": [{"tactic": "simp [dotProduct]", "annotated_tactic": ["simp [<a>dotProduct</a>]", [{"full_name": "Matrix.dotProduct", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [752, 5], "def_end_pos": [752, 15]}]], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : Mul \u03b1\nv w : PUnit.{u_10 + 1} \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 w = v PUnit.unit * w PUnit.unit", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Operations.lean", "full_name": "Submonoid.map_comap_map", "start": [317, 1], "end": [318, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Monic.lean", "full_name": "Polynomial.Monic.natDegree_map", "start": [318, 1], "end": [322, 20], "traced_tactics": [{"tactic": "refine' le_antisymm (natDegree_map_le _ _) (le_natDegree_of_ne_zero _)", "annotated_tactic": ["refine' <a>le_antisymm</a> (<a>natDegree_map_le</a> _ _) (<a>le_natDegree_of_ne_zero</a> _)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Polynomial.natDegree_map_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [874, 9], "def_end_pos": [874, 25]}, {"full_name": "Polynomial.le_natDegree_of_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [182, 9], "def_end_pos": [182, 32]}]], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nP : R[X]\nhmo : Monic P\nf : R \u2192+* S\n\u22a2 natDegree (Polynomial.map f P) = natDegree P", "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nP : R[X]\nhmo : Monic P\nf : R \u2192+* S\n\u22a2 coeff (Polynomial.map f P) (natDegree P) \u2260 0"}, {"tactic": "rw [coeff_map, Monic.coeff_natDegree hmo, RingHom.map_one]", "annotated_tactic": ["rw [<a>coeff_map</a>, <a>Monic.coeff_natDegree</a> hmo, <a>RingHom.map_one</a>]", [{"full_name": "Polynomial.coeff_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [807, 9], "def_end_pos": [807, 18]}, {"full_name": "Polynomial.Monic.coeff_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [100, 9], "def_end_pos": [100, 30]}, {"full_name": "RingHom.map_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [554, 19], "def_end_pos": [554, 26]}]], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nP : R[X]\nhmo : Monic P\nf : R \u2192+* S\n\u22a2 coeff (Polynomial.map f P) (natDegree P) \u2260 0", "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nP : R[X]\nhmo : Monic P\nf : R \u2192+* S\n\u22a2 1 \u2260 0"}, {"tactic": "exact one_ne_zero", "annotated_tactic": ["exact <a>one_ne_zero</a>", [{"full_name": "one_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}]], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nP : R[X]\nhmo : Monic P\nf : R \u2192+* S\n\u22a2 1 \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "sdiff_eq_right", "start": [330, 1], "end": [331, 46], "traced_tactics": [{"tactic": "rw [disjoint_sdiff_self_left.eq_iff]", "annotated_tactic": ["rw [disjoint_sdiff_self_left.eq_iff]", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\nw x y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 x \\ y = y \u2194 x = \u22a5 \u2227 y = \u22a5", "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\nw x y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 x \\ y = \u22a5 \u2227 y = \u22a5 \u2194 x = \u22a5 \u2227 y = \u22a5"}, {"tactic": "aesop", "annotated_tactic": ["aesop", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\nw x y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 x \\ y = \u22a5 \u2227 y = \u22a5 \u2194 x = \u22a5 \u2227 y = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.castSucc_lt_succ_iff", "start": [990, 1], "end": [991, 49], "traced_tactics": [{"tactic": "rw [castSucc_lt_iff_succ_le, succ_le_succ_iff]", "annotated_tactic": ["rw [<a>castSucc_lt_iff_succ_le</a>, <a>succ_le_succ_iff</a>]", [{"full_name": "Fin.castSucc_lt_iff_succ_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [370, 9], "def_end_pos": [370, 32]}, {"full_name": "Fin.succ_le_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [229, 17], "def_end_pos": [229, 33]}]], "state_before": "n m n\u271d : \u2115\na b : Fin n\u271d\n\u22a2 castSucc a < succ b \u2194 a \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/BigOperators/Lemmas.lean", "full_name": "List.prod_eq_one_iff", "start": [54, 1], "end": [57, 85], "traced_tactics": [{"tactic": "rw [List.eq_replicate.2 \u27e8_, h\u27e9, prod_replicate, one_pow]", "annotated_tactic": ["rw [<a>List.eq_replicate</a>.2 \u27e8_, h\u27e9, <a>prod_replicate</a>, <a>one_pow</a>]", [{"full_name": "List.eq_replicate", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [472, 9], "def_end_pos": [472, 21]}, {"full_name": "List.prod_replicate", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [88, 9], "def_end_pos": [88, 23]}, {"full_name": "one_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [75, 9], "def_end_pos": [75, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d : CanonicallyOrderedCommMonoid M\nl : List M\nh : \u2200 (x : M), x \u2208 l \u2192 x = 1\n\u22a2 prod l = 1", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d : CanonicallyOrderedCommMonoid M\nl : List M\nh : \u2200 (x : M), x \u2208 l \u2192 x = 1\n\u22a2 \u2115\n\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d : CanonicallyOrderedCommMonoid M\nl : List M\nh : \u2200 (x : M), x \u2208 l \u2192 x = 1\n\u22a2 length l = ?m.5579"}, {"tactic": "exact (length l)", "annotated_tactic": ["exact (<a>length</a> l)", [{"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d : CanonicallyOrderedCommMonoid M\nl : List M\nh : \u2200 (x : M), x \u2208 l \u2192 x = 1\n\u22a2 \u2115\n\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d : CanonicallyOrderedCommMonoid M\nl : List M\nh : \u2200 (x : M), x \u2208 l \u2192 x = 1\n\u22a2 length l = ?m.5579", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d : CanonicallyOrderedCommMonoid M\nl : List M\nh : \u2200 (x : M), x \u2208 l \u2192 x = 1\n\u22a2 length l = length l"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d : CanonicallyOrderedCommMonoid M\nl : List M\nh : \u2200 (x : M), x \u2208 l \u2192 x = 1\n\u22a2 length l = length l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Conjugate.lean", "full_name": "Function.Semiconj\u2082.isIdempotent_left", "start": [209, 1], "end": [211, 74], "traced_tactics": [{"tactic": "rw [h.eq, Std.IdempotentOp.idempotent (op := gb)]", "annotated_tactic": ["rw [h.eq, <a>Std.IdempotentOp.idempotent</a> (op := gb)]", [{"full_name": "Std.IdempotentOp.idempotent", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1972, 3], "def_end_pos": [1972, 13]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nga : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ngb : \u03b2 \u2192 \u03b2 \u2192 \u03b2\ninst\u271d : Std.IdempotentOp gb\nh : Semiconj\u2082 f ga gb\nh_inj : Injective f\nx : \u03b1\n\u22a2 f (ga x x) = f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Prod.lean", "full_name": "Finset.offDiag_card", "start": [336, 1], "end": [343, 85], "traced_tactics": [{"tactic": "conv_rhs => { rw [\u2190 s.diag_card] }", "annotated_tactic": ["conv_rhs => { rw [\u2190 s.diag_card] }", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\nthis : (diag s).card + (offDiag s).card = s.card * s.card\n\u22a2 (offDiag s).card = s.card * s.card - s.card", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\nthis : (diag s).card + (offDiag s).card = s.card * s.card\n\u22a2 (offDiag s).card = (diag s).card * (diag s).card - (diag s).card"}, {"tactic": "simp only [diag_card] at *", "annotated_tactic": ["simp only [<a>diag_card</a>] at *", [{"full_name": "Finset.diag_card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Prod.lean", "def_pos": [319, 9], "def_end_pos": [319, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\nthis : (diag s).card + (offDiag s).card = s.card * s.card\n\u22a2 (offDiag s).card = (diag s).card * (diag s).card - (diag s).card", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\nthis : s.card + (offDiag s).card = s.card * s.card\n\u22a2 (offDiag s).card = s.card * s.card - s.card"}, {"tactic": "rw [tsub_eq_of_eq_add_rev]", "annotated_tactic": ["rw [<a>tsub_eq_of_eq_add_rev</a>]", [{"full_name": "tsub_eq_of_eq_add_rev", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [352, 9], "def_end_pos": [352, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\nthis : s.card + (offDiag s).card = s.card * s.card\n\u22a2 (offDiag s).card = s.card * s.card - s.card", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\nthis : s.card + (offDiag s).card = s.card * s.card\n\u22a2 s.card * s.card = s.card + (offDiag s).card"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\nthis : s.card + (offDiag s).card = s.card * s.card\n\u22a2 s.card * s.card = s.card + (offDiag s).card", "state_after": "no goals"}, {"tactic": "rw [\u2190 card_product, diag, offDiag]", "annotated_tactic": ["rw [\u2190 <a>card_product</a>, <a>diag</a>, <a>offDiag</a>]", [{"full_name": "Finset.card_product", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Prod.lean", "def_pos": [139, 9], "def_end_pos": [139, 21]}, {"full_name": "Finset.diag", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Prod.lean", "def_pos": [289, 5], "def_end_pos": [289, 9]}, {"full_name": "Finset.offDiag", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Prod.lean", "def_pos": [295, 5], "def_end_pos": [295, 12]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 (diag s).card + (offDiag s).card = s.card * s.card", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 (filter (fun a => a.1 = a.2) (s \u00d7\u02e2 s)).card + (filter (fun a => a.1 \u2260 a.2) (s \u00d7\u02e2 s)).card = (s \u00d7\u02e2 s).card"}, {"tactic": "conv_rhs => rw [\u2190 filter_card_add_filter_neg_card_eq_card (fun a => a.1 = a.2)]", "annotated_tactic": ["conv_rhs => rw [\u2190 <a>filter_card_add_filter_neg_card_eq_card</a> (fun a => a.1 = a.2)]", [{"full_name": "Finset.filter_card_add_filter_neg_card_eq_card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [535, 9], "def_end_pos": [535, 48]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 (filter (fun a => a.1 = a.2) (s \u00d7\u02e2 s)).card + (filter (fun a => a.1 \u2260 a.2) (s \u00d7\u02e2 s)).card = (s \u00d7\u02e2 s).card", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Defs.lean", "full_name": "Set.mapsTo_preimage", "start": [273, 1], "end": [273, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Basic.lean", "full_name": "eq_of_forall_gt_iff", "start": [558, 1], "end": [559, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "fderiv_mul_const", "start": [562, 1], "end": [564, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "full_name": "FreeMonoid.smul_def", "start": [288, 1], "end": [290, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/PartialHomeomorph.lean", "full_name": "PartialHomeomorph.trans_target'", "start": [892, 1], "end": [893, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "ne_of_irrefl", "start": [133, 1], "end": [134, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.ofEquiv_card", "start": [145, 1], "end": [146, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "full_name": "Finset.sum_smul_vsub_eq_weightedVSubOfPoint_sub", "start": [179, 1], "end": [182, 97], "traced_tactics": [{"tactic": "simp_rw [weightedVSubOfPoint_apply, \u2190 sum_sub_distrib, \u2190 smul_sub, vsub_sub_vsub_cancel_right]", "annotated_tactic": ["simp_rw [<a>weightedVSubOfPoint_apply</a>, \u2190 <a>sum_sub_distrib</a>, \u2190 <a>smul_sub</a>, <a>vsub_sub_vsub_cancel_right</a>]", [{"full_name": "Finset.weightedVSubOfPoint_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [72, 9], "def_end_pos": [72, 34]}, {"full_name": "Finset.sum_sub_distrib", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [2055, 3], "def_end_pos": [2055, 14]}, {"full_name": "smul_sub", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [1024, 9], "def_end_pos": [1024, 17]}, {"full_name": "vsub_sub_vsub_cancel_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [171, 9], "def_end_pos": [171, 35]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\n\u03b9 : Type u_4\ns : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\nw : \u03b9 \u2192 k\np\u2081 p\u2082 : \u03b9 \u2192 P\nb : P\n\u22a2 \u2211 i in s, w i \u2022 (p\u2081 i -\u1d65 p\u2082 i) = (weightedVSubOfPoint s p\u2081 b) w - (weightedVSubOfPoint s p\u2082 b) w", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/SesquilinearForm.lean", "full_name": "LinearMap.IsOrtho\u1d62.nondegenerate_of_not_isOrtho_basis_self", "start": [845, 1], "end": [849, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.OuterMeasure.map_ofFunction_le", "start": [779, 1], "end": [784, 24], "traced_tactics": [{"tactic": "rw [map_apply]", "annotated_tactic": ["rw [<a>map_apply</a>]", [{"full_name": "MeasureTheory.OuterMeasure.map_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [445, 9], "def_end_pos": [445, 18]}]], "state_before": "\u03b1 : Type u_1\nm : Set \u03b1 \u2192 \u211d\u22650\u221e\nm_empty : m \u2205 = 0\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 \u2191((map f) (OuterMeasure.ofFunction m m_empty)) s \u2264 m (f \u207b\u00b9' s)", "state_after": "\u03b1 : Type u_1\nm : Set \u03b1 \u2192 \u211d\u22650\u221e\nm_empty : m \u2205 = 0\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 \u2191(OuterMeasure.ofFunction m m_empty) (f \u207b\u00b9' s) \u2264 m (f \u207b\u00b9' s)"}, {"tactic": "apply ofFunction_le", "annotated_tactic": ["apply <a>ofFunction_le</a>", [{"full_name": "MeasureTheory.OuterMeasure.ofFunction_le", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [693, 9], "def_end_pos": [693, 22]}]], "state_before": "\u03b1 : Type u_1\nm : Set \u03b1 \u2192 \u211d\u22650\u221e\nm_empty : m \u2205 = 0\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 \u2191(OuterMeasure.ofFunction m m_empty) (f \u207b\u00b9' s) \u2264 m (f \u207b\u00b9' s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "full_name": "MeasureTheory.MeasurePreserving.restrict_image_emb", "start": [88, 1], "end": [90, 95], "traced_tactics": [{"tactic": "simpa only [Set.preimage_image_eq _ h\u2082.injective] using hf.restrict_preimage_emb h\u2082 (f '' s)", "annotated_tactic": ["simpa only [<a>Set.preimage_image_eq</a> _ h\u2082.injective] using hf.restrict_preimage_emb h\u2082 (f '' s)", [{"full_name": "Set.preimage_image_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [493, 9], "def_end_pos": [493, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\n\u03bca : Measure \u03b1\n\u03bcb : Measure \u03b2\n\u03bcc : Measure \u03b3\n\u03bcd : Measure \u03b4\nf : \u03b1 \u2192 \u03b2\nhf : MeasurePreserving f \u03bca \u03bcb\nh\u2082 : MeasurableEmbedding f\ns : Set \u03b1\n\u22a2 MeasurePreserving f (Measure.restrict \u03bca s) (Measure.restrict \u03bcb (f '' s))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Algebra.lean", "full_name": "algebraMap_le_algebraMap", "start": [44, 1], "end": [45, 40], "traced_tactics": [{"tactic": "simp [Algebra.algebraMap_eq_smul_one]", "annotated_tactic": ["simp [<a>Algebra.algebraMap_eq_smul_one</a>]", [{"full_name": "Algebra.algebraMap_eq_smul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [344, 9], "def_end_pos": [344, 31]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : OrderedCommSemiring \u03b1\ninst\u271d\u00b3 : StrictOrderedSemiring \u03b2\ninst\u271d\u00b2 : Algebra \u03b1 \u03b2\ninst\u271d\u00b9 : SMulPosMono \u03b1 \u03b2\ninst\u271d : SMulPosReflectLE \u03b1 \u03b2\na\u2081 a\u2082 : \u03b1\n\u22a2 (algebraMap \u03b1 \u03b2) a\u2081 \u2264 (algebraMap \u03b1 \u03b2) a\u2082 \u2194 a\u2081 \u2264 a\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.ceil_congr", "start": [1624, 1], "end": [1625, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Logic.lean", "full_name": "congrArg\u2082", "start": [41, 1], "end": [42, 73], "traced_tactics": [{"tactic": "subst hx hy", "annotated_tactic": ["subst hx hy", []], "state_before": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nx x' : \u03b1\ny y' : \u03b2\nhx : x = x'\nhy : y = y'\n\u22a2 f x y = f x' y'", "state_after": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nx : \u03b1\ny : \u03b2\n\u22a2 f x y = f x y"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nx : \u03b1\ny : \u03b2\n\u22a2 f x y = f x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/UniqueProds.lean", "full_name": "UniqueMul.mulHom_preimage", "start": [145, 1], "end": [151, 69], "traced_tactics": [{"tactic": "intro a b ha hb ab", "annotated_tactic": ["intro a b ha hb ab", []], "state_before": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Mul G\ninst\u271d : Mul H\nA\u271d B\u271d : Finset G\na0\u271d b0\u271d : G\nf : G \u2192\u2099* H\nhf : Function.Injective \u21d1f\na0 b0 : G\nA B : Finset H\nu : UniqueMul A B (f a0) (f b0)\n\u22a2 UniqueMul (Finset.preimage A \u21d1f \u22ef) (Finset.preimage B \u21d1f \u22ef) a0 b0", "state_after": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Mul G\ninst\u271d : Mul H\nA\u271d B\u271d : Finset G\na0\u271d b0\u271d : G\nf : G \u2192\u2099* H\nhf : Function.Injective \u21d1f\na0 b0 : G\nA B : Finset H\nu : UniqueMul A B (f a0) (f b0)\na b : G\nha : a \u2208 Finset.preimage A \u21d1f \u22ef\nhb : b \u2208 Finset.preimage B \u21d1f \u22ef\nab : a * b = a0 * b0\n\u22a2 a = a0 \u2227 b = b0"}, {"tactic": "simp only [\u2190 hf.eq_iff, map_mul] at ab \u22a2", "annotated_tactic": ["simp only [\u2190 hf.eq_iff, <a>map_mul</a>] at ab \u22a2", [{"full_name": "map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [308, 9], "def_end_pos": [308, 16]}]], "state_before": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Mul G\ninst\u271d : Mul H\nA\u271d B\u271d : Finset G\na0\u271d b0\u271d : G\nf : G \u2192\u2099* H\nhf : Function.Injective \u21d1f\na0 b0 : G\nA B : Finset H\nu : UniqueMul A B (f a0) (f b0)\na b : G\nha : a \u2208 Finset.preimage A \u21d1f \u22ef\nhb : b \u2208 Finset.preimage B \u21d1f \u22ef\nab : a * b = a0 * b0\n\u22a2 a = a0 \u2227 b = b0", "state_after": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Mul G\ninst\u271d : Mul H\nA\u271d B\u271d : Finset G\na0\u271d b0\u271d : G\nf : G \u2192\u2099* H\nhf : Function.Injective \u21d1f\na0 b0 : G\nA B : Finset H\nu : UniqueMul A B (f a0) (f b0)\na b : G\nha : a \u2208 Finset.preimage A \u21d1f \u22ef\nhb : b \u2208 Finset.preimage B \u21d1f \u22ef\nab : f a * f b = f a0 * f b0\n\u22a2 f a = f a0 \u2227 f b = f b0"}, {"tactic": "exact u (Finset.mem_preimage.mp ha) (Finset.mem_preimage.mp hb) ab", "annotated_tactic": ["exact u (Finset.mem_preimage.mp ha) (Finset.mem_preimage.mp hb) ab", []], "state_before": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Mul G\ninst\u271d : Mul H\nA\u271d B\u271d : Finset G\na0\u271d b0\u271d : G\nf : G \u2192\u2099* H\nhf : Function.Injective \u21d1f\na0 b0 : G\nA B : Finset H\nu : UniqueMul A B (f a0) (f b0)\na b : G\nha : a \u2208 Finset.preimage A \u21d1f \u22ef\nhb : b \u2208 Finset.preimage B \u21d1f \u22ef\nab : f a * f b = f a0 * f b0\n\u22a2 f a = f a0 \u2227 f b = f b0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_monomial_le", "start": [301, 1], "end": [304, 38], "traced_tactics": [{"tactic": "rw [h, (monomial n).map_zero, degree_zero]", "annotated_tactic": ["rw [h, (<a>monomial</a> n).<a>map_zero</a>, <a>degree_zero</a>]", [{"full_name": "Polynomial.monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [430, 5], "def_end_pos": [430, 13]}, {"full_name": "LinearMap.map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [342, 19], "def_end_pos": [342, 27]}, {"full_name": "Polynomial.degree_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [105, 9], "def_end_pos": [105, 20]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\na : R\nthis : DecidableEq R := Classical.decEq R\nh : a = 0\n\u22a2 degree ((monomial n) a) \u2264 \u2191n", "state_after": "R : Type u\nS : Type v\na\u271d b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\na : R\nthis : DecidableEq R := Classical.decEq R\nh : a = 0\n\u22a2 \u22a5 \u2264 \u2191n"}, {"tactic": "exact bot_le", "annotated_tactic": ["exact <a>bot_le</a>", [{"full_name": "bot_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [224, 9], "def_end_pos": [224, 15]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\na : R\nthis : DecidableEq R := Classical.decEq R\nh : a = 0\n\u22a2 \u22a5 \u2264 \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Noetherian.lean", "full_name": "eventuallyConst_of_isNoetherian", "start": [360, 1], "end": [363, 65], "traced_tactics": [{"tactic": "simp_rw [eventuallyConst_atTop, eq_comm]", "annotated_tactic": ["simp_rw [<a>eventuallyConst_atTop</a>, <a>eq_comm</a>]", [{"full_name": "Filter.eventuallyConst_atTop", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/EventuallyConst.lean", "def_pos": [152, 7], "def_end_pos": [152, 28]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "R : Type u_1\nM : Type u_2\nP : Type u_3\nN : Type w\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192o Submodule R M\n\u22a2 EventuallyConst (\u21d1f) atTop", "state_after": "R : Type u_1\nM : Type u_2\nP : Type u_3\nN : Type w\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192o Submodule R M\n\u22a2 \u2203 i, \u2200 (j : \u2115), i \u2264 j \u2192 f i = f j"}, {"tactic": "exact (monotone_stabilizes_iff_noetherian.mpr inferInstance) f", "annotated_tactic": ["exact (monotone_stabilizes_iff_noetherian.mpr <a>inferInstance</a>) f", [{"full_name": "inferInstance", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [99, 8], "def_end_pos": [99, 21]}]], "state_before": "R : Type u_1\nM : Type u_2\nP : Type u_3\nN : Type w\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192o Submodule R M\n\u22a2 \u2203 i, \u2200 (j : \u2115), i \u2264 j \u2192 f i = f j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/FreeModule/PID.lean", "full_name": "eq_bot_of_generator_maximal_submoduleImage_eq_zero", "start": [74, 1], "end": [83, 66], "traced_tactics": [{"tactic": "rw [Submodule.eq_bot_iff]", "annotated_tactic": ["rw [<a>Submodule.eq_bot_iff</a>]", [{"full_name": "Submodule.eq_bot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [84, 19], "def_end_pos": [84, 29]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00acLinearMap.submoduleImage \u03d5 N < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\n\u22a2 N = \u22a5", "state_after": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00acLinearMap.submoduleImage \u03d5 N < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\n\u22a2 \u2200 x \u2208 N, x = 0"}, {"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00acLinearMap.submoduleImage \u03d5 N < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\n\u22a2 \u2200 x \u2208 N, x = 0", "state_after": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00acLinearMap.submoduleImage \u03d5 N < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\n\u22a2 x = 0"}, {"tactic": "refine (mk_eq_zero _ _).mp (show (\u27e8x, hNO hx\u27e9 : O) = 0 from b.ext_elem fun i \u21a6 ?_)", "annotated_tactic": ["refine (<a>mk_eq_zero</a> _ _).<a>mp</a> (show (\u27e8x, hNO hx\u27e9 : O) = 0 from b.ext_elem fun i \u21a6 ?_)", [{"full_name": "Submodule.mk_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [284, 9], "def_end_pos": [284, 19]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00acLinearMap.submoduleImage \u03d5 N < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\n\u22a2 x = 0", "state_after": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00acLinearMap.submoduleImage \u03d5 N < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\ni : \u03b9\n\u22a2 (b.repr { val := x, property := \u22ef }) i = (b.repr 0) i"}, {"tactic": "rw [(eq_bot_iff_generator_eq_zero _).mpr hgen] at h\u03d5", "annotated_tactic": ["rw [(<a>eq_bot_iff_generator_eq_zero</a> _).<a>mpr</a> hgen] at h\u03d5", [{"full_name": "Submodule.IsPrincipal.eq_bot_iff_generator_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean", "def_pos": [113, 9], "def_end_pos": [113, 37]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00acLinearMap.submoduleImage \u03d5 N < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\ni : \u03b9\n\u22a2 (b.repr { val := x, property := \u22ef }) i = (b.repr 0) i", "state_after": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00ac\u22a5 < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\ni : \u03b9\n\u22a2 (b.repr { val := x, property := \u22ef }) i = (b.repr 0) i"}, {"tactic": "rw [LinearEquiv.map_zero, Finsupp.zero_apply]", "annotated_tactic": ["rw [<a>LinearEquiv.map_zero</a>, <a>Finsupp.zero_apply</a>]", [{"full_name": "LinearEquiv.map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [484, 19], "def_end_pos": [484, 27]}, {"full_name": "Finsupp.zero_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [171, 9], "def_end_pos": [171, 19]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00ac\u22a5 < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\ni : \u03b9\n\u22a2 (b.repr { val := x, property := \u22ef }) i = (b.repr 0) i", "state_after": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00ac\u22a5 < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\ni : \u03b9\n\u22a2 (b.repr { val := x, property := \u22ef }) i = 0"}, {"tactic": "refine (Submodule.eq_bot_iff _).mp (not_bot_lt_iff.1 <| h\u03d5 (Finsupp.lapply i \u2218\u2097 \u2191b.repr)) _ ?_", "annotated_tactic": ["refine (<a>Submodule.eq_bot_iff</a> _).<a>mp</a> (<a>not_bot_lt_iff</a>.1 <| h\u03d5 (<a>Finsupp.lapply</a> i \u2218\u2097 \u2191b.repr)) _ ?_", [{"full_name": "Submodule.eq_bot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [84, 19], "def_end_pos": [84, 29]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}, {"full_name": "not_bot_lt_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [344, 9], "def_end_pos": [344, 23]}, {"full_name": "Finsupp.lapply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [170, 5], "def_end_pos": [170, 11]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00ac\u22a5 < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\ni : \u03b9\n\u22a2 (b.repr { val := x, property := \u22ef }) i = 0", "state_after": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00ac\u22a5 < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\ni : \u03b9\n\u22a2 (b.repr { val := x, property := \u22ef }) i \u2208 LinearMap.submoduleImage (Finsupp.lapply i \u2218\u2097 \u2191b.repr) N"}, {"tactic": "exact (LinearMap.mem_submoduleImage_of_le hNO).mpr \u27e8x, hx, rfl\u27e9", "annotated_tactic": ["exact (<a>LinearMap.mem_submoduleImage_of_le</a> hNO).<a>mpr</a> \u27e8x, hx, <a>rfl</a>\u27e9", [{"full_name": "LinearMap.mem_submoduleImage_of_le", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [543, 9], "def_end_pos": [543, 33]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\n\u03b9 : Type u_1\nb\u271d : Basis \u03b9 R M\nN O : Submodule R M\nb : Basis \u03b9 R \u21a5O\nhNO : N \u2264 O\n\u03d5 : \u21a5O \u2192\u2097[R] R\nh\u03d5 : \u2200 (\u03c8 : \u21a5O \u2192\u2097[R] R), \u00ac\u22a5 < LinearMap.submoduleImage \u03c8 N\ninst\u271d : IsPrincipal (LinearMap.submoduleImage \u03d5 N)\nhgen : generator (LinearMap.submoduleImage \u03d5 N) = 0\nx : M\nhx : x \u2208 N\ni : \u03b9\n\u22a2 (b.repr { val := x, property := \u22ef }) i \u2208 LinearMap.submoduleImage (Finsupp.lapply i \u2218\u2097 \u2191b.repr) N", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/IsometricSMul.lean", "full_name": "dist_inv_inv", "start": [399, 1], "end": [401, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/Lemmas.lean", "full_name": "Std.RBSet.mem_toList", "start": [626, 1], "end": [626, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "order_separated", "start": [385, 1], "end": [388, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/AbstractCompletion.lean", "full_name": "AbstractCompletion.compare_coe", "start": [254, 1], "end": [255, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "countable_of_isolated_left'", "start": [617, 1], "end": [619, 67], "traced_tactics": [{"tactic": "simpa only [\u2190 covBy_iff_Ioo_eq] using countable_setOf_covBy_left", "annotated_tactic": ["simpa only [\u2190 <a>covBy_iff_Ioo_eq</a>] using <a>countable_setOf_covBy_left</a>", [{"full_name": "covBy_iff_Ioo_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/Cover.lean", "def_pos": [350, 9], "def_end_pos": [350, 25]}, {"full_name": "countable_setOf_covBy_left", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [610, 9], "def_end_pos": [610, 35]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u22a2 Set.Countable {x | \u2203 y < x, Ioo y x = \u2205}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Synonym.lean", "full_name": "toLex_inj", "start": [195, 1], "end": [196, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "AffineSubspace.subtype_apply", "start": [417, 1], "end": [418, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_of_infinite_mulSupport", "start": [425, 1], "end": [426, 63], "traced_tactics": [{"tactic": "classical rw [finprod_def, dif_neg hf]", "annotated_tactic": ["classical rw [<a>finprod_def</a>, <a>dif_neg</a> hf]", [{"full_name": "finprod_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [414, 9], "def_end_pos": [414, 20]}, {"full_name": "dif_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [949, 9], "def_end_pos": [949, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : \u03b1 \u2192 M\nhf : Set.Infinite (mulSupport f)\n\u22a2 \u220f\u1da0 (i : \u03b1), f i = 1", "state_after": "no goals"}, {"tactic": "rw [finprod_def, dif_neg hf]", "annotated_tactic": ["rw [<a>finprod_def</a>, <a>dif_neg</a> hf]", [{"full_name": "finprod_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [414, 9], "def_end_pos": [414, 20]}, {"full_name": "dif_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [949, 9], "def_end_pos": [949, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : \u03b1 \u2192 M\nhf : Set.Infinite (mulSupport f)\n\u22a2 \u220f\u1da0 (i : \u03b1), f i = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.range_cons_empty", "start": [183, 1], "end": [184, 48], "traced_tactics": [{"tactic": "rw [range_cons, range_empty, Set.union_empty]", "annotated_tactic": ["rw [<a>range_cons</a>, <a>range_empty</a>, <a>Set.union_empty</a>]", [{"full_name": "Matrix.range_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [173, 9], "def_end_pos": [173, 19]}, {"full_name": "Matrix.range_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [178, 9], "def_end_pos": [178, 20]}, {"full_name": "Set.union_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [747, 9], "def_end_pos": [747, 20]}]], "state_before": "\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\nx : \u03b1\nu : Fin 0 \u2192 \u03b1\n\u22a2 Set.range (vecCons x u) = {x}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Identities.lean", "full_name": "pow_four_add_four_mul_pow_four'", "start": [46, 1], "end": [48, 7], "traced_tactics": [{"tactic": "ring", "annotated_tactic": ["ring", []], "state_before": "R : Type u_1\ninst\u271d : CommRing R\na b x\u2081 x\u2082 x\u2083 x\u2084 x\u2085 x\u2086 x\u2087 x\u2088 y\u2081 y\u2082 y\u2083 y\u2084 y\u2085 y\u2086 y\u2087 y\u2088 n : R\n\u22a2 a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Antilipschitz.lean", "full_name": "LipschitzWith.to_rightInverse", "start": [269, 1], "end": [271, 82], "traced_tactics": [{"tactic": "simpa only [hg _] using hf (g x) (g y)", "annotated_tactic": ["simpa only [hg _] using hf (g x) (g y)", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b2\nhf : LipschitzWith K f\ng : \u03b2 \u2192 \u03b1\nhg : Function.RightInverse g f\nx y : \u03b2\n\u22a2 edist x y \u2264 \u2191K * edist (g x) (g y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENat/Basic.lean", "full_name": "ENat.one_le_iff_pos", "start": [240, 1], "end": [241, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Cover.lean", "full_name": "reflTransGen_wcovBy_eq_reflTransGen_covBy", "start": [534, 1], "end": [536, 53], "traced_tactics": [{"tactic": "rw [wcovBy_eq_reflGen_covBy, reflTransGen_reflGen]", "annotated_tactic": ["rw [<a>wcovBy_eq_reflGen_covBy</a>, <a>reflTransGen_reflGen</a>]", [{"full_name": "wcovBy_eq_reflGen_covBy", "def_path": ".lake/packages/mathlib/Mathlib/Order/Cover.lean", "def_pos": [527, 7], "def_end_pos": [527, 30]}, {"full_name": "Relation.reflTransGen_reflGen", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Relation.lean", "def_pos": [644, 15], "def_end_pos": [644, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\n\u22a2 (ReflTransGen fun x x_1 => x \u2a7f x_1) = ReflTransGen fun x x_1 => x \u22d6 x_1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Defs.lean", "full_name": "PosSMulReflectLT.toPosSMulMono", "start": [386, 1], "end": [387, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.lintegral_mul_const", "start": [725, 1], "end": [726, 93], "traced_tactics": [{"tactic": "simp_rw [mul_comm, lintegral_const_mul r hf]", "annotated_tactic": ["simp_rw [<a>mul_comm</a>, <a>lintegral_const_mul</a> r hf]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "MeasureTheory.lintegral_const_mul", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [670, 9], "def_end_pos": [670, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nr : \u211d\u22650\u221e\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\n\u22a2 \u222b\u207b (a : \u03b1), f a * r \u2202\u03bc = (\u222b\u207b (a : \u03b1), f a \u2202\u03bc) * r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearEquiv.neg_apply", "start": [928, 1], "end": [928, 52], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : M\n\u22a2 (neg R) x = -x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.image\u2082_insert_right", "start": [188, 1], "end": [192, 30], "traced_tactics": [{"tactic": "push_cast", "annotated_tactic": ["push_cast", []], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2078 : DecidableEq \u03b1'\ninst\u271d\u2077 : DecidableEq \u03b2'\ninst\u271d\u2076 : DecidableEq \u03b3\ninst\u271d\u2075 : DecidableEq \u03b3'\ninst\u271d\u2074 : DecidableEq \u03b4\ninst\u271d\u00b3 : DecidableEq \u03b4'\ninst\u271d\u00b2 : DecidableEq \u03b5\ninst\u271d\u00b9 : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ninst\u271d : DecidableEq \u03b2\n\u22a2 \u2191(image\u2082 f s (insert b t)) = \u2191(image (fun a => f a b) s \u222a image\u2082 f s t)", "state_after": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2078 : DecidableEq \u03b1'\ninst\u271d\u2077 : DecidableEq \u03b2'\ninst\u271d\u2076 : DecidableEq \u03b3\ninst\u271d\u2075 : DecidableEq \u03b3'\ninst\u271d\u2074 : DecidableEq \u03b4\ninst\u271d\u00b3 : DecidableEq \u03b4'\ninst\u271d\u00b2 : DecidableEq \u03b5\ninst\u271d\u00b9 : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ninst\u271d : DecidableEq \u03b2\n\u22a2 image2 f (\u2191s) (insert b \u2191t) = (fun a => f a b) '' \u2191s \u222a image2 f \u2191s \u2191t"}, {"tactic": "exact image2_insert_right", "annotated_tactic": ["exact <a>image2_insert_right</a>", [{"full_name": "Set.image2_insert_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [186, 9], "def_end_pos": [186, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2078 : DecidableEq \u03b1'\ninst\u271d\u2077 : DecidableEq \u03b2'\ninst\u271d\u2076 : DecidableEq \u03b3\ninst\u271d\u2075 : DecidableEq \u03b3'\ninst\u271d\u2074 : DecidableEq \u03b4\ninst\u271d\u00b3 : DecidableEq \u03b4'\ninst\u271d\u00b2 : DecidableEq \u03b5\ninst\u271d\u00b9 : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ninst\u271d : DecidableEq \u03b2\n\u22a2 image2 f (\u2191s) (insert b \u2191t) = (fun a => f a b) '' \u2191s \u222a image2 f \u2191s \u2191t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/HasLimits.lean", "full_name": "CategoryTheory.Limits.hasLimitOfEquivalenceComp", "start": [499, 1], "end": [501, 42], "traced_tactics": [{"tactic": "haveI : HasLimit (e.inverse \u22d9 e.functor \u22d9 F) := Limits.hasLimitEquivalenceComp e.symm", "annotated_tactic": ["haveI : <a>HasLimit</a> (e.inverse \u22d9 e.functor \u22d9 F) := <a>Limits.hasLimitEquivalenceComp</a> e.symm", [{"full_name": "CategoryTheory.Limits.HasLimit", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/HasLimits.lean", "def_pos": [86, 7], "def_end_pos": [86, 15]}, {"full_name": "CategoryTheory.Limits.hasLimitEquivalenceComp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/HasLimits.lean", "def_pos": [487, 10], "def_end_pos": [487, 33]}]], "state_before": "J : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nF : J \u2964 C\ne : K \u224c J\ninst\u271d : HasLimit (e.functor \u22d9 F)\n\u22a2 HasLimit F", "state_after": "J : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nF : J \u2964 C\ne : K \u224c J\ninst\u271d : HasLimit (e.functor \u22d9 F)\nthis : HasLimit (e.inverse \u22d9 e.functor \u22d9 F)\n\u22a2 HasLimit F"}, {"tactic": "apply hasLimitOfIso (e.invFunIdAssoc F)", "annotated_tactic": ["apply <a>hasLimitOfIso</a> (e.invFunIdAssoc F)", [{"full_name": "CategoryTheory.Limits.hasLimitOfIso", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/HasLimits.lean", "def_pos": [315, 9], "def_end_pos": [315, 22]}]], "state_before": "J : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nF : J \u2964 C\ne : K \u224c J\ninst\u271d : HasLimit (e.functor \u22d9 F)\nthis : HasLimit (e.inverse \u22d9 e.functor \u22d9 F)\n\u22a2 HasLimit F", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.utf8Len_cons", "start": [62, 9], "end": [62, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bases.lean", "full_name": "Dense.exists_countable_dense_subset", "start": [619, 1], "end": [623, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.image_congr", "start": [251, 1], "end": [253, 69], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b1 \u2192 \u03b2\ns\u271d t : Set \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : \u2200 a \u2208 s, f a = g a\n\u22a2 f '' s = g '' s", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b1 \u2192 \u03b2\ns\u271d t : Set \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : \u2200 a \u2208 s, f a = g a\nx : \u03b2\n\u22a2 x \u2208 f '' s \u2194 x \u2208 g '' s"}, {"tactic": "exact exists_congr fun a \u21a6 and_congr_right fun ha \u21a6 by rw [h a ha]", "annotated_tactic": ["exact <a>exists_congr</a> fun a \u21a6 <a>and_congr_right</a> fun ha \u21a6 by rw [h a ha]", [{"full_name": "exists_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [143, 9], "def_end_pos": [143, 21]}, {"full_name": "and_congr_right", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [130, 9], "def_end_pos": [130, 24]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b1 \u2192 \u03b2\ns\u271d t : Set \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : \u2200 a \u2208 s, f a = g a\nx : \u03b2\n\u22a2 x \u2208 f '' s \u2194 x \u2208 g '' s", "state_after": "no goals"}, {"tactic": "rw [h a ha]", "annotated_tactic": ["rw [h a ha]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b1 \u2192 \u03b2\ns\u271d t : Set \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : \u2200 a \u2208 s, f a = g a\nx : \u03b2\na : \u03b1\nha : a \u2208 s\n\u22a2 f a = x \u2194 g a = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "Submodule.comap_snd", "start": [567, 1], "end": [567, 75], "traced_tactics": [{"tactic": "ext \u27e8x, y\u27e9", "annotated_tactic": ["ext \u27e8x, y\u27e9", []], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 comap (snd R M M\u2082) q = prod \u22a4 q", "state_after": "case h.mk\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\ny : M\u2082\n\u22a2 (x, y) \u2208 comap (snd R M M\u2082) q \u2194 (x, y) \u2208 prod \u22a4 q"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.mk\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\ny : M\u2082\n\u22a2 (x, y) \u2208 comap (snd R M M\u2082) q \u2194 (x, y) \u2208 prod \u22a4 q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.preimage_mul_const_Ioc_of_neg", "start": [668, 1], "end": [670, 57], "traced_tactics": [{"tactic": "simp [\u2190 Ioi_inter_Iic, \u2190 Ici_inter_Iio, h, inter_comm]", "annotated_tactic": ["simp [\u2190 <a>Ioi_inter_Iic</a>, \u2190 <a>Ici_inter_Iio</a>, h, <a>inter_comm</a>]", [{"full_name": "Set.Ioi_inter_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [626, 9], "def_end_pos": [626, 22]}, {"full_name": "Set.Ici_inter_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [622, 9], "def_end_pos": [622, 22]}, {"full_name": "Set.inter_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [908, 9], "def_end_pos": [908, 19]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\na\u271d a b c : \u03b1\nh : c < 0\n\u22a2 (fun x => x * c) \u207b\u00b9' Ioc a b = Ico (b / c) (a / c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "full_name": "Real.Angle.coe_add", "start": [84, 1], "end": [85, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/IntegralClosure.lean", "full_name": "IsIntegralClosure.mk'_zero", "start": [761, 1], "end": [762, 73], "traced_tactics": [{"tactic": "rw [algebraMap_mk', RingHom.map_zero]", "annotated_tactic": ["rw [<a>algebraMap_mk'</a>, <a>RingHom.map_zero</a>]", [{"full_name": "IsIntegralClosure.algebraMap_mk'", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/IntegralClosure.lean", "def_pos": [751, 9], "def_end_pos": [751, 23]}, {"full_name": "RingHom.map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [549, 19], "def_end_pos": [549, 27]}]], "state_before": "R : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : Algebra A B\ninst\u271d : IsIntegralClosure A R B\nh : optParam (IsIntegral R 0) \u22ef\n\u22a2 (algebraMap A B) (mk' A 0 h) = (algebraMap A B) 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.floor_add_ofNat", "start": [462, 1], "end": [464, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "full_name": "Equiv.uniformEmbedding", "start": [185, 1], "end": [187, 96], "traced_tactics": [{"tactic": "rwa [\u2190 Equiv.prodCongr_apply, \u2190 map_equiv_symm]", "annotated_tactic": ["rwa [\u2190 <a>Equiv.prodCongr_apply</a>, \u2190 <a>map_equiv_symm</a>]", [{"full_name": "Equiv.prodCongr_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [110, 27], "def_end_pos": [110, 32]}, {"full_name": "Filter.map_equiv_symm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2712, 9], "def_end_pos": [2712, 23]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : UniformSpace \u03b1\u271d\ninst\u271d\u00b3 : UniformSpace \u03b2\u271d\ninst\u271d\u00b2 : UniformSpace \u03b3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b1 \u2243 \u03b2\nh\u2081 : UniformContinuous \u21d1f\nh\u2082 : UniformContinuous \u21d1f.symm\n\u22a2 comap (Prod.map \u21d1f \u21d1f) (\ud835\udce4 \u03b2) \u2264 \ud835\udce4 \u03b1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/CauSeq/BigOperators.lean", "full_name": "IsCauSeq.series_ratio_test", "start": [209, 1], "end": [229, 33], "traced_tactics": [{"tactic": "have har1 : |r| < 1 := by rwa [abs_of_nonneg hr0]", "annotated_tactic": ["have har1 : |r| < 1 := by rwa [<a>abs_of_nonneg</a> hr0]", [{"full_name": "abs_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [94, 3], "def_end_pos": [94, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\n\u22a2 IsCauSeq abv fun m => \u2211 n in range m, f n", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\n\u22a2 IsCauSeq abv fun m => \u2211 n in range m, f n"}, {"tactic": "refine (geo_series_const (abv (f n.succ) * r\u207b\u00b9 ^ n.succ) har1).of_abv_le n.succ fun m hmn \u21a6 ?_", "annotated_tactic": ["refine (<a>geo_series_const</a> (abv (f n.succ) * r\u207b\u00b9 ^ n.succ) har1).<a>of_abv_le</a> n.succ fun m hmn \u21a6 ?_", [{"full_name": "IsCauSeq.geo_series_const", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/BigOperators.lean", "def_pos": [204, 7], "def_end_pos": [204, 23]}, {"full_name": "IsCauSeq.of_abv_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/BigOperators.lean", "def_pos": [25, 7], "def_end_pos": [25, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\n\u22a2 IsCauSeq abv fun m => \u2211 n in range m, f n", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\nm : \u2115\nhmn : Nat.succ n \u2264 m\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m"}, {"tactic": "obtain rfl | hr := hr0.eq_or_lt", "annotated_tactic": ["obtain rfl | hr := hr0.eq_or_lt", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\nm : \u2115\nhmn : Nat.succ n \u2264 m\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn m : \u2115\nhmn : Nat.succ n \u2264 m\nhr0 : 0 \u2264 0\nhr1 : 0 < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 0 * abv (f m)\nhar1 : |0| < 1\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * 0\u207b\u00b9 ^ Nat.succ n * 0 ^ m\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhr : 0 < r\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m"}, {"tactic": "generalize hk : m - n.succ = k", "annotated_tactic": ["generalize hk : m - n.succ = k", []], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhr : 0 < r\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m", "state_after": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhr : 0 < r\nk : \u2115\nhk : m - Nat.succ n = k\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m"}, {"tactic": "replace hk : m = k + n.succ := (tsub_eq_iff_eq_add_of_le hmn).1 hk", "annotated_tactic": ["replace hk : m = k + n.succ := (<a>tsub_eq_iff_eq_add_of_le</a> hmn).1 hk", [{"full_name": "tsub_eq_iff_eq_add_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [209, 9], "def_end_pos": [209, 33]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhr : 0 < r\nk : \u2115\nhk : m - Nat.succ n = k\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m", "state_after": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhr : 0 < r\nk : \u2115\nhk : m = k + Nat.succ n\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m"}, {"tactic": "induction' k with k ih generalizing m n", "annotated_tactic": ["induction' k with k ih generalizing m n", []], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nhar1 : |r| < 1\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhr : 0 < r\nk : \u2115\nhk : m = k + Nat.succ n\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m", "state_after": "case inr.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.zero + Nat.succ n\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\n\ncase inr.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m"}, {"tactic": "rwa [abs_of_nonneg hr0]", "annotated_tactic": ["rwa [<a>abs_of_nonneg</a> hr0]", [{"full_name": "abs_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [94, 3], "def_end_pos": [94, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn : \u2115\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\n\u22a2 |r| < 1", "state_after": "no goals"}, {"tactic": "have m_pos := lt_of_lt_of_le (Nat.succ_pos n) hmn", "annotated_tactic": ["have m_pos := <a>lt_of_lt_of_le</a> (<a>Nat.succ_pos</a> n) hmn", [{"full_name": "lt_of_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [109, 9], "def_end_pos": [109, 23]}, {"full_name": "Nat.succ_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1674, 9], "def_end_pos": [1674, 21]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn m : \u2115\nhmn : Nat.succ n \u2264 m\nhr0 : 0 \u2264 0\nhr1 : 0 < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 0 * abv (f m)\nhar1 : |0| < 1\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * 0\u207b\u00b9 ^ Nat.succ n * 0 ^ m", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn m : \u2115\nhmn : Nat.succ n \u2264 m\nhr0 : 0 \u2264 0\nhr1 : 0 < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 0 * abv (f m)\nhar1 : |0| < 1\nm_pos : 0 < m\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * 0\u207b\u00b9 ^ Nat.succ n * 0 ^ m"}, {"tactic": "have := h m.pred (Nat.le_of_succ_le_succ (by rwa [Nat.succ_pred_eq_of_pos m_pos]))", "annotated_tactic": ["have := h m.pred (<a>Nat.le_of_succ_le_succ</a> (by rwa [<a>Nat.succ_pred_eq_of_pos</a> m_pos]))", [{"full_name": "Nat.le_of_succ_le_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1694, 9], "def_end_pos": [1694, 31]}, {"full_name": "Nat.succ_pred_eq_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [573, 9], "def_end_pos": [573, 28]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn m : \u2115\nhmn : Nat.succ n \u2264 m\nhr0 : 0 \u2264 0\nhr1 : 0 < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 0 * abv (f m)\nhar1 : |0| < 1\nm_pos : 0 < m\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * 0\u207b\u00b9 ^ Nat.succ n * 0 ^ m", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn m : \u2115\nhmn : Nat.succ n \u2264 m\nhr0 : 0 \u2264 0\nhr1 : 0 < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 0 * abv (f m)\nhar1 : |0| < 1\nm_pos : 0 < m\nthis : abv (f (Nat.succ (Nat.pred m))) \u2264 0 * abv (f (Nat.pred m))\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * 0\u207b\u00b9 ^ Nat.succ n * 0 ^ m"}, {"tactic": "simpa [Nat.succ_pred_eq_of_pos m_pos, pow_succ] using this", "annotated_tactic": ["simpa [<a>Nat.succ_pred_eq_of_pos</a> m_pos, <a>pow_succ</a>] using this", [{"full_name": "Nat.succ_pred_eq_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [573, 9], "def_end_pos": [573, 28]}, {"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn m : \u2115\nhmn : Nat.succ n \u2264 m\nhr0 : 0 \u2264 0\nhr1 : 0 < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 0 * abv (f m)\nhar1 : |0| < 1\nm_pos : 0 < m\nthis : abv (f (Nat.succ (Nat.pred m))) \u2264 0 * abv (f (Nat.pred m))\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * 0\u207b\u00b9 ^ Nat.succ n * 0 ^ m", "state_after": "no goals"}, {"tactic": "rwa [Nat.succ_pred_eq_of_pos m_pos]", "annotated_tactic": ["rwa [<a>Nat.succ_pred_eq_of_pos</a> m_pos]", [{"full_name": "Nat.succ_pred_eq_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [573, 9], "def_end_pos": [573, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nn m : \u2115\nhmn : Nat.succ n \u2264 m\nhr0 : 0 \u2264 0\nhr1 : 0 < 1\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 0 * abv (f m)\nhar1 : |0| < 1\nm_pos : 0 < m\n\u22a2 Nat.succ n \u2264 Nat.succ (Nat.pred m)", "state_after": "no goals"}, {"tactic": "rw [hk, Nat.zero_add, mul_right_comm, inv_pow _ _, \u2190 div_eq_mul_inv, mul_div_cancel]", "annotated_tactic": ["rw [hk, <a>Nat.zero_add</a>, <a>mul_right_comm</a>, <a>inv_pow</a> _ _, \u2190 <a>div_eq_mul_inv</a>, <a>mul_div_cancel</a>]", [{"full_name": "Nat.zero_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [114, 27], "def_end_pos": [114, 35]}, {"full_name": "mul_right_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [162, 9], "def_end_pos": [162, 23]}, {"full_name": "inv_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [278, 9], "def_end_pos": [278, 16]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "mul_div_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [343, 15], "def_end_pos": [343, 29]}]], "state_before": "case inr.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.zero + Nat.succ n\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m", "state_after": "case inr.zero.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.zero + Nat.succ n\n\u22a2 r ^ Nat.succ n \u2260 0"}, {"tactic": "positivity", "annotated_tactic": ["positivity", []], "state_before": "case inr.zero.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.zero + Nat.succ n\n\u22a2 r ^ Nat.succ n \u2260 0", "state_after": "no goals"}, {"tactic": "have kn : k + n.succ \u2265 n.succ := by\n  rw [\u2190 zero_add n.succ]; exact add_le_add (Nat.zero_le _) (by simp)", "annotated_tactic": ["have kn : k + n.succ \u2265 n.succ := by\n      rw [\u2190 <a>zero_add</a> n.succ]; exact <a>add_le_add</a> (<a>Nat.zero_le</a> _) (by simp)", [{"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}, {"full_name": "add_le_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [205, 32], "def_end_pos": [205, 42]}, {"full_name": "Nat.zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1644, 9], "def_end_pos": [1644, 20]}]], "state_before": "case inr.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m", "state_after": "case inr.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\nkn : k + Nat.succ n \u2265 Nat.succ n\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m"}, {"tactic": "erw [hk, Nat.succ_add, pow_succ' r, \u2190 mul_assoc]", "annotated_tactic": ["erw [hk, <a>Nat.succ_add</a>, <a>pow_succ'</a> r, \u2190 <a>mul_assoc</a>]", [{"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "pow_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [262, 7], "def_end_pos": [262, 16]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "case inr.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\nkn : k + Nat.succ n \u2265 Nat.succ n\n\u22a2 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m", "state_after": "case inr.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\nkn : k + Nat.succ n \u2265 Nat.succ n\n\u22a2 abv (f (Nat.succ (k + Nat.succ n))) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ (k + Nat.succ n) * r"}, {"tactic": "refine\n  le_trans (by rw [mul_comm] <;> exact h _ (Nat.le_of_succ_le kn))\n    (mul_le_mul_of_nonneg_right ?_ hr0)", "annotated_tactic": ["refine\n      <a>le_trans</a> (by rw [<a>mul_comm</a>] <;> exact h _ (<a>Nat.le_of_succ_le</a> kn))\n        (<a>mul_le_mul_of_nonneg_right</a> ?_ hr0)", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Nat.le_of_succ_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [285, 9], "def_end_pos": [285, 22]}, {"full_name": "mul_le_mul_of_nonneg_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [210, 9], "def_end_pos": [210, 35]}]], "state_before": "case inr.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\nkn : k + Nat.succ n \u2265 Nat.succ n\n\u22a2 abv (f (Nat.succ (k + Nat.succ n))) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ (k + Nat.succ n) * r", "state_after": "case inr.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\nkn : k + Nat.succ n \u2265 Nat.succ n\n\u22a2 abv (f (k + Nat.succ n)) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ (k + Nat.succ n)"}, {"tactic": "exact ih _ h _ (by simp) rfl", "annotated_tactic": ["exact ih _ h _ (by simp) <a>rfl</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case inr.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\nkn : k + Nat.succ n \u2265 Nat.succ n\n\u22a2 abv (f (k + Nat.succ n)) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ (k + Nat.succ n)", "state_after": "no goals"}, {"tactic": "rw [\u2190 zero_add n.succ]", "annotated_tactic": ["rw [\u2190 <a>zero_add</a> n.succ]", [{"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\n\u22a2 k + Nat.succ n \u2265 Nat.succ n", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\n\u22a2 k + (0 + Nat.succ n) \u2265 0 + Nat.succ n"}, {"tactic": "exact add_le_add (Nat.zero_le _) (by simp)", "annotated_tactic": ["exact <a>add_le_add</a> (<a>Nat.zero_le</a> _) (by simp)", [{"full_name": "add_le_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [205, 32], "def_end_pos": [205, 42]}, {"full_name": "Nat.zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1644, 9], "def_end_pos": [1644, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\n\u22a2 k + (0 + Nat.succ n) \u2265 0 + Nat.succ n", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\n\u22a2 Nat.succ n \u2264 0 + Nat.succ n", "state_after": "no goals"}, {"tactic": "rw [mul_comm] <;> exact h _ (Nat.le_of_succ_le kn)", "annotated_tactic": ["rw [<a>mul_comm</a>] <;> exact h _ (<a>Nat.le_of_succ_le</a> kn)", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Nat.le_of_succ_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [285, 9], "def_end_pos": [285, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\nkn : k + Nat.succ n \u2265 Nat.succ n\n\u22a2 abv (f (Nat.succ (k + Nat.succ n))) \u2264 ?m.153694 * r", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\nf\u271d g : \u2115 \u2192 \u03b2\na : \u2115 \u2192 \u03b1\ninst\u271d : Archimedean \u03b1\nf : \u2115 \u2192 \u03b2\nr : \u03b1\nhr0 : 0 \u2264 r\nhr1 : r < 1\nhar1 : |r| < 1\nhr : 0 < r\nk : \u2115\nih :\n  \u2200 (n : \u2115),\n    (\u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)) \u2192\n      \u2200 (m : \u2115), Nat.succ n \u2264 m \u2192 m = k + Nat.succ n \u2192 abv (f m) \u2264 abv (f (Nat.succ n)) * r\u207b\u00b9 ^ Nat.succ n * r ^ m\nn : \u2115\nh : \u2200 (m : \u2115), n \u2264 m \u2192 abv (f (Nat.succ m)) \u2264 r * abv (f m)\nm : \u2115\nhmn : Nat.succ n \u2264 m\nhk : m = Nat.succ k + Nat.succ n\nkn : k + Nat.succ n \u2265 Nat.succ n\n\u22a2 Nat.succ n \u2264 k + Nat.succ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.le_erase", "start": [1750, 1], "end": [1750, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.factors_decreasing", "start": [560, 1], "end": [565, 98], "traced_tactics": [{"tactic": "rwa [mul_one, \u2190 Ideal.span_singleton_le_span_singleton]", "annotated_tactic": ["rwa [<a>mul_one</a>, \u2190 <a>Ideal.span_singleton_le_span_singleton</a>]", [{"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "Ideal.span_singleton_le_span_singleton", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [510, 9], "def_end_pos": [510, 41]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\nI : Ideal \u03b1\ninst\u271d : IsDomain \u03b1\nb\u2081 b\u2082 : \u03b1\nh\u2081 : b\u2081 \u2260 0\nh\u2082 : \u00acIsUnit b\u2082\nh : span {b\u2081} \u2264 span {b\u2081 * b\u2082}\n\u22a2 b\u2081 * b\u2082 \u2223 b\u2081 * 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "pi_Ici_mem_nhds", "start": [743, 1], "end": [744, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "isClosed_iSup_iff", "start": [986, 1], "end": [987, 92], "traced_tactics": [{"tactic": "simp [\u2190 @isOpen_compl_iff _ _ (\u2a06 i, t i), \u2190 @isOpen_compl_iff _ _ (t _), isOpen_iSup_iff]", "annotated_tactic": ["simp [\u2190 @<a>isOpen_compl_iff</a> _ _ (\u2a06 i, t i), \u2190 @<a>isOpen_compl_iff</a> _ _ (t _), <a>isOpen_iSup_iff</a>]", [{"full_name": "isOpen_compl_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [161, 17], "def_end_pos": [161, 33]}, {"full_name": "isOpen_compl_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [161, 17], "def_end_pos": [161, 33]}, {"full_name": "isOpen_iSup_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [980, 9], "def_end_pos": [980, 24]}]], "state_before": "\u03b1 : Type u\n\u03b9 : Sort v\nt : \u03b9 \u2192 TopologicalSpace \u03b1\ns : Set \u03b1\n\u22a2 IsClosed s \u2194 \u2200 (i : \u03b9), IsClosed s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "AffineSubspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top", "start": [992, 1], "end": [999, 23], "traced_tactics": [{"tactic": "by_contra h", "annotated_tactic": ["by_contra h", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns1 s2 : AffineSubspace k P\nh1 : Set.Nonempty \u2191s1\nh2 : Set.Nonempty \u2191s2\nhd : direction s1 \u2294 direction s2 = \u22a4\n\u22a2 Set.Nonempty (\u2191s1 \u2229 \u2191s2)", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns1 s2 : AffineSubspace k P\nh1 : Set.Nonempty \u2191s1\nh2 : Set.Nonempty \u2191s2\nhd : direction s1 \u2294 direction s2 = \u22a4\nh : \u00acSet.Nonempty (\u2191s1 \u2229 \u2191s2)\n\u22a2 False"}, {"tactic": "rw [Set.not_nonempty_iff_eq_empty] at h", "annotated_tactic": ["rw [<a>Set.not_nonempty_iff_eq_empty</a>] at h", [{"full_name": "Set.not_nonempty_iff_eq_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [579, 9], "def_end_pos": [579, 34]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns1 s2 : AffineSubspace k P\nh1 : Set.Nonempty \u2191s1\nh2 : Set.Nonempty \u2191s2\nhd : direction s1 \u2294 direction s2 = \u22a4\nh : \u00acSet.Nonempty (\u2191s1 \u2229 \u2191s2)\n\u22a2 False", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns1 s2 : AffineSubspace k P\nh1 : Set.Nonempty \u2191s1\nh2 : Set.Nonempty \u2191s2\nhd : direction s1 \u2294 direction s2 = \u22a4\nh : \u2191s1 \u2229 \u2191s2 = \u2205\n\u22a2 False"}, {"tactic": "have hlt := sup_direction_lt_of_nonempty_of_inter_empty h1 h2 h", "annotated_tactic": ["have hlt := <a>sup_direction_lt_of_nonempty_of_inter_empty</a> h1 h2 h", [{"full_name": "AffineSubspace.sup_direction_lt_of_nonempty_of_inter_empty", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [970, 9], "def_end_pos": [970, 52]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns1 s2 : AffineSubspace k P\nh1 : Set.Nonempty \u2191s1\nh2 : Set.Nonempty \u2191s2\nhd : direction s1 \u2294 direction s2 = \u22a4\nh : \u2191s1 \u2229 \u2191s2 = \u2205\n\u22a2 False", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns1 s2 : AffineSubspace k P\nh1 : Set.Nonempty \u2191s1\nh2 : Set.Nonempty \u2191s2\nhd : direction s1 \u2294 direction s2 = \u22a4\nh : \u2191s1 \u2229 \u2191s2 = \u2205\nhlt : direction s1 \u2294 direction s2 < direction (s1 \u2294 s2)\n\u22a2 False"}, {"tactic": "rw [hd] at hlt", "annotated_tactic": ["rw [hd] at hlt", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns1 s2 : AffineSubspace k P\nh1 : Set.Nonempty \u2191s1\nh2 : Set.Nonempty \u2191s2\nhd : direction s1 \u2294 direction s2 = \u22a4\nh : \u2191s1 \u2229 \u2191s2 = \u2205\nhlt : direction s1 \u2294 direction s2 < direction (s1 \u2294 s2)\n\u22a2 False", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns1 s2 : AffineSubspace k P\nh1 : Set.Nonempty \u2191s1\nh2 : Set.Nonempty \u2191s2\nhd : direction s1 \u2294 direction s2 = \u22a4\nh : \u2191s1 \u2229 \u2191s2 = \u2205\nhlt : \u22a4 < direction (s1 \u2294 s2)\n\u22a2 False"}, {"tactic": "exact not_top_lt hlt", "annotated_tactic": ["exact <a>not_top_lt</a> hlt", [{"full_name": "not_top_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [86, 9], "def_end_pos": [86, 19]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns1 s2 : AffineSubspace k P\nh1 : Set.Nonempty \u2191s1\nh2 : Set.Nonempty \u2191s2\nhd : direction s1 \u2294 direction s2 = \u22a4\nh : \u2191s1 \u2229 \u2191s2 = \u2205\nhlt : \u22a4 < direction (s1 \u2294 s2)\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Sum/Basic.lean", "full_name": "Sum.lex_inl_inl", "start": [150, 9], "end": [151, 45], "traced_tactics": [{"tactic": "cases h", "annotated_tactic": ["cases h", []], "state_before": "\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\na\u2081 a\u2082 : \u03b1\u271d\nh : Lex r s (inl a\u2081) (inl a\u2082)\n\u22a2 r a\u2081 a\u2082", "state_after": "case inl\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\na\u2081 a\u2082 : \u03b1\u271d\nh\u271d : r a\u2081 a\u2082\n\u22a2 r a\u2081 a\u2082"}, {"tactic": "assumption", "annotated_tactic": ["assumption", []], "state_before": "case inl\n\u03b1\u271d : Type u_1\nr : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\n\u03b2\u271d : Type u_2\ns : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\na\u2081 a\u2082 : \u03b1\u271d\nh\u271d : r a\u2081 a\u2082\n\u22a2 r a\u2081 a\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Sort.lean", "full_name": "List.sorted_insertionSort", "start": [356, 1], "end": [358, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.whiskerRight_id_symm", "start": [508, 1], "end": [510, 7], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b2 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nU V W X\u271d Y\u271d Z X Y : C\nf : X \u27f6 Y\n\u22a2 f = (\u03c1_ X).inv \u226b f \u25b7 \ud835\udfd9_ C \u226b (\u03c1_ Y).hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.rel_zero_right", "start": [2810, 1], "end": [2810, 85], "traced_tactics": [{"tactic": "rw [rel_iff]", "annotated_tactic": ["rw [<a>rel_iff</a>]", [{"full_name": "Multiset.rel_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2749, 3], "def_end_pos": [2749, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : Multiset \u03b1\n\u22a2 Rel r a 0 \u2194 a = 0", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : Multiset \u03b1\n\u22a2 (a = 0 \u2227 0 = 0 \u2228 \u2203 a_1 b as bs, r a_1 b \u2227 Rel r as bs \u2227 a = a_1 ::\u2098 as \u2227 0 = b ::\u2098 bs) \u2194 a = 0"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : Multiset \u03b1\n\u22a2 (a = 0 \u2227 0 = 0 \u2228 \u2203 a_1 b as bs, r a_1 b \u2227 Rel r as bs \u2227 a = a_1 ::\u2098 as \u2227 0 = b ::\u2098 bs) \u2194 a = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Determinant.lean", "full_name": "LinearEquiv.isUnit_det'", "start": [428, 1], "end": [430, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/UniformGroup.lean", "full_name": "UniformGroup.uniformity_countably_generated", "start": [314, 1], "end": [317, 46], "traced_tactics": [{"tactic": "rw [uniformity_eq_comap_nhds_one]", "annotated_tactic": ["rw [<a>uniformity_eq_comap_nhds_one</a>]", [{"full_name": "uniformity_eq_comap_nhds_one", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/UniformGroup.lean", "def_pos": [270, 9], "def_end_pos": [270, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : UniformGroup \u03b1\ninst\u271d : IsCountablyGenerated (\ud835\udcdd 1)\n\u22a2 IsCountablyGenerated (\ud835\udce4 \u03b1)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : UniformGroup \u03b1\ninst\u271d : IsCountablyGenerated (\ud835\udcdd 1)\n\u22a2 IsCountablyGenerated (comap (fun x => x.2 / x.1) (\ud835\udcdd 1))"}, {"tactic": "exact Filter.comap.isCountablyGenerated _ _", "annotated_tactic": ["exact <a>Filter.comap.isCountablyGenerated</a> _ _", [{"full_name": "Filter.comap.isCountablyGenerated", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [1149, 10], "def_end_pos": [1149, 36]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : UniformGroup \u03b1\ninst\u271d : IsCountablyGenerated (\ud835\udcdd 1)\n\u22a2 IsCountablyGenerated (comap (fun x => x.2 / x.1) (\ud835\udcdd 1))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isLittleO_irrefl", "start": [625, 1], "end": [626, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "algebraMap_mem", "start": [106, 1], "end": [109, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Antilipschitz.lean", "full_name": "AntilipschitzWith.le_mul_ediam_image", "start": [121, 1], "end": [122, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.map_id'", "start": [587, 1], "end": [588, 49], "traced_tactics": [{"tactic": "rw [show f = id from funext H]", "annotated_tactic": ["rw [show f = <a>id</a> from <a>funext</a> H]", [{"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "funext", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1805, 9], "def_end_pos": [1805, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b1\nH : \u2200 (x : \u03b1), f x = x\no : Part \u03b1\n\u22a2 map f o = o", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b1\nH : \u2200 (x : \u03b1), f x = x\no : Part \u03b1\n\u22a2 map id o = o"}, {"tactic": "exact id_map o", "annotated_tactic": ["exact <a>id_map</a> o", [{"full_name": "LawfulFunctor.id_map", "def_path": ".lake/packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [18, 3], "def_end_pos": [18, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b1\nH : \u2200 (x : \u03b1), f x = x\no : Part \u03b1\n\u22a2 map id o = o", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/RelIso/Basic.lean", "full_name": "injective_of_increasing", "start": [168, 1], "end": [180, 33], "traced_tactics": [{"tactic": "intro x y hxy", "annotated_tactic": ["intro x y hxy", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\n\u22a2 Injective f", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\n\u22a2 x = y"}, {"tactic": "rcases trichotomous_of r x y with (h | h | h)", "annotated_tactic": ["rcases <a>trichotomous_of</a> r x y with (h | h | h)", [{"full_name": "trichotomous_of", "def_path": ".lake/packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [364, 9], "def_end_pos": [364, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\n\u22a2 x = y", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r x y\n\u22a2 x = y\n\ncase inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : x = y\n\u22a2 x = y\n\ncase inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r y x\n\u22a2 x = y"}, {"tactic": "have := hf h", "annotated_tactic": ["have := hf h", []], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r x y\n\u22a2 x = y", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r x y\nthis : s (f x) (f y)\n\u22a2 x = y"}, {"tactic": "rw [hxy] at this", "annotated_tactic": ["rw [hxy] at this", []], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r x y\nthis : s (f x) (f y)\n\u22a2 x = y", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r x y\nthis : s (f y) (f y)\n\u22a2 x = y"}, {"tactic": "exfalso", "annotated_tactic": ["exfalso", []], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r x y\nthis : s (f y) (f y)\n\u22a2 x = y", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r x y\nthis : s (f y) (f y)\n\u22a2 False"}, {"tactic": "exact irrefl_of s (f y) this", "annotated_tactic": ["exact <a>irrefl_of</a> s (f y) this", [{"full_name": "irrefl_of", "def_path": ".lake/packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [334, 9], "def_end_pos": [334, 18]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r x y\nthis : s (f y) (f y)\n\u22a2 False", "state_after": "no goals"}, {"tactic": "exact h", "annotated_tactic": ["exact h", []], "state_before": "case inr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : x = y\n\u22a2 x = y", "state_after": "no goals"}, {"tactic": "have := hf h", "annotated_tactic": ["have := hf h", []], "state_before": "case inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r y x\n\u22a2 x = y", "state_after": "case inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r y x\nthis : s (f y) (f x)\n\u22a2 x = y"}, {"tactic": "rw [hxy] at this", "annotated_tactic": ["rw [hxy] at this", []], "state_before": "case inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r y x\nthis : s (f y) (f x)\n\u22a2 x = y", "state_after": "case inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r y x\nthis : s (f y) (f y)\n\u22a2 x = y"}, {"tactic": "exfalso", "annotated_tactic": ["exfalso", []], "state_before": "case inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r y x\nthis : s (f y) (f y)\n\u22a2 x = y", "state_after": "case inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r y x\nthis : s (f y) (f y)\n\u22a2 False"}, {"tactic": "exact irrefl_of s (f y) this", "annotated_tactic": ["exact <a>irrefl_of</a> s (f y) this", [{"full_name": "irrefl_of", "def_path": ".lake/packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [334, 9], "def_end_pos": [334, 18]}]], "state_before": "case inr.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\nu : \u03b4 \u2192 \u03b4 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsTrichotomous \u03b1 r\ninst\u271d : IsIrrefl \u03b2 s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 {x y : \u03b1}, r x y \u2192 s (f x) (f y)\nx y : \u03b1\nhxy : f x = f y\nh : r y x\nthis : s (f y) (f y)\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Ray.lean", "full_name": "SameRay.eq_of_norm_eq", "start": [110, 1], "end": [111, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.one_lt_card", "start": [618, 1], "end": [619, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/CharP/Reduced.lean", "full_name": "isSquare_of_charTwo'", "start": [37, 1], "end": [42, 97], "traced_tactics": [{"tactic": "cases nonempty_fintype R", "annotated_tactic": ["cases <a>nonempty_fintype</a> R", [{"full_name": "nonempty_fintype", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [442, 9], "def_end_pos": [442, 25]}]], "state_before": "R : Type u_1\ninst\u271d\u00b3 : Finite R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsReduced R\ninst\u271d : CharP R 2\na : R\n\u22a2 IsSquare a", "state_after": "case intro\nR : Type u_1\ninst\u271d\u00b3 : Finite R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsReduced R\ninst\u271d : CharP R 2\na : R\nval\u271d : Fintype R\n\u22a2 IsSquare a"}, {"tactic": "exact\n  Exists.imp (fun b h => pow_two b \u25b8 Eq.symm h)\n    (((Fintype.bijective_iff_injective_and_card _).mpr \u27e8frobenius_inj R 2, rfl\u27e9).surjective a)", "annotated_tactic": ["exact\n    <a>Exists.imp</a> (fun b h => <a>pow_two</a> b \u25b8 <a>Eq.symm</a> h)\n      (((<a>Fintype.bijective_iff_injective_and_card</a> _).<a>mpr</a> \u27e8<a>frobenius_inj</a> R 2, <a>rfl</a>\u27e9).<a>surjective</a> a)", [{"full_name": "Exists.imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [126, 9], "def_end_pos": [126, 19]}, {"full_name": "pow_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [86, 32], "def_end_pos": [86, 39]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}, {"full_name": "Fintype.bijective_iff_injective_and_card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [693, 9], "def_end_pos": [693, 41]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}, {"full_name": "frobenius_inj", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharP/Reduced.lean", "def_pos": [29, 9], "def_end_pos": [29, 22]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Function.Bijective.surjective", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [88, 19], "def_end_pos": [88, 39]}]], "state_before": "case intro\nR : Type u_1\ninst\u271d\u00b3 : Finite R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsReduced R\ninst\u271d : CharP R 2\na : R\nval\u271d : Fintype R\n\u22a2 IsSquare a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "AddValuation.map_le_add", "start": [682, 1], "end": [683, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Iterate.lean", "full_name": "Monotone.seq_lt_seq_of_lt_of_le", "start": [68, 1], "end": [71, 78], "traced_tactics": [{"tactic": "cases n", "annotated_tactic": ["cases n", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 \u03b1\nx y : \u2115 \u2192 \u03b1\nhf : Monotone f\nn : \u2115\nh\u2080 : x 0 < y 0\nhx : \u2200 (k : \u2115), k < n \u2192 x (k + 1) < f (x k)\nhy : \u2200 (k : \u2115), k < n \u2192 f (y k) \u2264 y (k + 1)\n\u22a2 x n < y n", "state_after": "case zero\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 \u03b1\nx y : \u2115 \u2192 \u03b1\nhf : Monotone f\nh\u2080 : x 0 < y 0\nhx : \u2200 (k : \u2115), k < Nat.zero \u2192 x (k + 1) < f (x k)\nhy : \u2200 (k : \u2115), k < Nat.zero \u2192 f (y k) \u2264 y (k + 1)\n\u22a2 x Nat.zero < y Nat.zero\n\ncase succ\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 \u03b1\nx y : \u2115 \u2192 \u03b1\nhf : Monotone f\nh\u2080 : x 0 < y 0\nn\u271d : \u2115\nhx : \u2200 (k : \u2115), k < Nat.succ n\u271d \u2192 x (k + 1) < f (x k)\nhy : \u2200 (k : \u2115), k < Nat.succ n\u271d \u2192 f (y k) \u2264 y (k + 1)\n\u22a2 x (Nat.succ n\u271d) < y (Nat.succ n\u271d)"}, {"tactic": "exacts [h\u2080, hf.seq_pos_lt_seq_of_lt_of_le (Nat.zero_lt_succ _) h\u2080.le hx hy]", "annotated_tactic": ["exacts [h\u2080, hf.seq_pos_lt_seq_of_lt_of_le (<a>Nat.zero_lt_succ</a> _) h\u2080.le hx hy]", [{"full_name": "Nat.zero_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1652, 9], "def_end_pos": [1652, 25]}]], "state_before": "case zero\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 \u03b1\nx y : \u2115 \u2192 \u03b1\nhf : Monotone f\nh\u2080 : x 0 < y 0\nhx : \u2200 (k : \u2115), k < Nat.zero \u2192 x (k + 1) < f (x k)\nhy : \u2200 (k : \u2115), k < Nat.zero \u2192 f (y k) \u2264 y (k + 1)\n\u22a2 x Nat.zero < y Nat.zero\n\ncase succ\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nf : \u03b1 \u2192 \u03b1\nx y : \u2115 \u2192 \u03b1\nhf : Monotone f\nh\u2080 : x 0 < y 0\nn\u271d : \u2115\nhx : \u2200 (k : \u2115), k < Nat.succ n\u271d \u2192 x (k + 1) < f (x k)\nhy : \u2200 (k : \u2115), k < Nat.succ n\u271d \u2192 f (y k) \u2264 y (k + 1)\n\u22a2 x (Nat.succ n\u271d) < y (Nat.succ n\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Basic.lean", "full_name": "HasDerivAt.le_of_lip'", "start": [771, 1], "end": [774, 61], "traced_tactics": [{"tactic": "simpa using HasFDerivAt.le_of_lip' hf.hasFDerivAt hC\u2080 hlip", "annotated_tactic": ["simpa using <a>HasFDerivAt.le_of_lip'</a> hf.hasFDerivAt hC\u2080 hlip", [{"full_name": "HasFDerivAt.le_of_lip'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [336, 9], "def_end_pos": [336, 31]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf\u271d f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf'\u271d f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nf : \ud835\udd5c \u2192 F\nf' : F\nx\u2080 : \ud835\udd5c\nhf : HasDerivAt f f' x\u2080\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : \ud835\udd5c) in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u22a2 \u2016f'\u2016 \u2264 C", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.succ_pred_prime", "start": [200, 1], "end": [201, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "normalizerCondition_iff_only_full_group_self_normalizing", "start": [2277, 1], "end": [2281, 8], "traced_tactics": [{"tactic": "apply forall_congr'", "annotated_tactic": ["apply <a>forall_congr'</a>", [{"full_name": "forall_congr'", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\nN : Type u_5\ninst\u271d : Group N\n\u22a2 NormalizerCondition G \u2194 \u2200 (H : Subgroup G), normalizer H = H \u2192 H = \u22a4", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\nN : Type u_5\ninst\u271d : Group N\n\u22a2 \u2200 (a : Subgroup G), a < \u22a4 \u2192 a < normalizer a \u2194 normalizer a = a \u2192 a = \u22a4"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\nN : Type u_5\ninst\u271d : Group N\n\u22a2 \u2200 (a : Subgroup G), a < \u22a4 \u2192 a < normalizer a \u2194 normalizer a = a \u2192 a = \u22a4", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH\u271d K : Subgroup G\nN : Type u_5\ninst\u271d : Group N\nH : Subgroup G\n\u22a2 H < \u22a4 \u2192 H < normalizer H \u2194 normalizer H = H \u2192 H = \u22a4"}, {"tactic": "simp only [lt_iff_le_and_ne, le_normalizer, true_and_iff, le_top, Ne.def]", "annotated_tactic": ["simp only [<a>lt_iff_le_and_ne</a>, <a>le_normalizer</a>, <a>true_and_iff</a>, <a>le_top</a>, <a>Ne.def</a>]", [{"full_name": "lt_iff_le_and_ne", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [368, 9], "def_end_pos": [368, 25]}, {"full_name": "Subgroup.le_normalizer", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [2202, 9], "def_end_pos": [2202, 22]}, {"full_name": "true_and_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [140, 9], "def_end_pos": [140, 21]}, {"full_name": "le_top", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [66, 9], "def_end_pos": [66, 15]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}]], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH\u271d K : Subgroup G\nN : Type u_5\ninst\u271d : Group N\nH : Subgroup G\n\u22a2 H < \u22a4 \u2192 H < normalizer H \u2194 normalizer H = H \u2192 H = \u22a4", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH\u271d K : Subgroup G\nN : Type u_5\ninst\u271d : Group N\nH : Subgroup G\n\u22a2 \u00acH = \u22a4 \u2192 \u00acH = normalizer H \u2194 normalizer H = H \u2192 H = \u22a4"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH\u271d K : Subgroup G\nN : Type u_5\ninst\u271d : Group N\nH : Subgroup G\n\u22a2 \u00acH = \u22a4 \u2192 \u00acH = normalizer H \u2194 normalizer H = H \u2192 H = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeGroup/Basic.lean", "full_name": "FreeGroup.invRev_involutive", "start": [576, 1], "end": [576, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Interval.lean", "full_name": "Int.uIcc_eq_finset_map", "start": [102, 1], "end": [104, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Bits.lean", "full_name": "Nat.boddDiv2_eq", "start": [40, 1], "end": [41, 42], "traced_tactics": [{"tactic": "unfold bodd div2", "annotated_tactic": ["unfold <a>bodd</a> <a>div2</a>", [{"full_name": "Nat.bodd", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [50, 5], "def_end_pos": [50, 9]}, {"full_name": "Nat.div2", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [45, 5], "def_end_pos": [45, 9]}]], "state_before": "n\u271d n : \u2115\n\u22a2 boddDiv2 n = (bodd n, div2 n)", "state_after": "n\u271d n : \u2115\n\u22a2 boddDiv2 n = ((boddDiv2 n).1, (boddDiv2 n).2)"}, {"tactic": "cases boddDiv2 n", "annotated_tactic": ["cases <a>boddDiv2</a> n", [{"full_name": "Nat.boddDiv2", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [36, 5], "def_end_pos": [36, 13]}]], "state_before": "n\u271d n : \u2115\n\u22a2 boddDiv2 n = ((boddDiv2 n).1, (boddDiv2 n).2)", "state_after": "case mk\nn\u271d n : \u2115\nfst\u271d : Bool\nsnd\u271d : \u2115\n\u22a2 (fst\u271d, snd\u271d) = ((fst\u271d, snd\u271d).1, (fst\u271d, snd\u271d).2)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk\nn\u271d n : \u2115\nfst\u271d : Bool\nsnd\u271d : \u2115\n\u22a2 (fst\u271d, snd\u271d) = ((fst\u271d, snd\u271d).1, (fst\u271d, snd\u271d).2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Homeomorph.lean", "full_name": "Homeomorph.coe_prodCongr", "start": [576, 1], "end": [577, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.sup_apply", "start": [1186, 11], "end": [1189, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.tail_nil", "start": [288, 9], "end": [288, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finite/Basic.lean", "full_name": "Finite.prod_right", "start": [77, 1], "end": [78, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Summable.lean", "full_name": "HahnSeries.SummableFamily.hsum_ofFinsupp", "start": [400, 1], "end": [408, 11], "traced_tactics": [{"tactic": "ext g", "annotated_tactic": ["ext g", []], "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\n\u22a2 hsum (ofFinsupp f) = Finsupp.sum f fun x => id", "state_after": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\n\u22a2 (hsum (ofFinsupp f)).coeff g = (Finsupp.sum f fun x => id).coeff g"}, {"tactic": "simp only [hsum_coeff, coe_ofFinsupp, Finsupp.sum, Ne.def]", "annotated_tactic": ["simp only [<a>hsum_coeff</a>, <a>coe_ofFinsupp</a>, <a>Finsupp.sum</a>, <a>Ne.def</a>]", [{"full_name": "HahnSeries.SummableFamily.hsum_coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Summable.lean", "def_pos": [222, 9], "def_end_pos": [222, 19]}, {"full_name": "HahnSeries.SummableFamily.coe_ofFinsupp", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Summable.lean", "def_pos": [395, 9], "def_end_pos": [395, 22]}, {"full_name": "Finsupp.sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [47, 3], "def_end_pos": [47, 14]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}]], "state_before": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\n\u22a2 (hsum (ofFinsupp f)).coeff g = (Finsupp.sum f fun x => id).coeff g", "state_after": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\n\u22a2 \u2211\u1da0 (i : \u03b1), (f i).coeff g = (\u2211 x in f.support, id (f x)).coeff g"}, {"tactic": "simp_rw [\u2190 coeff.addMonoidHom_apply, id.def]", "annotated_tactic": ["simp_rw [\u2190 <a>coeff.addMonoidHom_apply</a>, <a>id.def</a>]", [{"full_name": "HahnSeries.coeff.addMonoidHom_apply", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Addition.lean", "def_pos": [101, 3], "def_end_pos": [101, 8]}, {"full_name": "id.def", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [22, 9], "def_end_pos": [22, 15]}]], "state_before": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\n\u22a2 \u2211\u1da0 (i : \u03b1), (f i).coeff g = (\u2211 x in f.support, id (f x)).coeff g", "state_after": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\n\u22a2 \u2211\u1da0 (i : \u03b1), (coeff.addMonoidHom g) (f i) = (coeff.addMonoidHom g) (\u2211 x in f.support, f x)"}, {"tactic": "rw [map_sum, finsum_eq_sum_of_support_subset]", "annotated_tactic": ["rw [<a>map_sum</a>, <a>finsum_eq_sum_of_support_subset</a>]", [{"full_name": "map_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [208, 3], "def_end_pos": [208, 14]}, {"full_name": "finsum_eq_sum_of_support_subset", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}]], "state_before": "case coeff.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\n\u22a2 \u2211\u1da0 (i : \u03b1), (coeff.addMonoidHom g) (f i) = (coeff.addMonoidHom g) (\u2211 x in f.support, f x)", "state_after": "case coeff.h.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\n\u22a2 (Function.support fun i => (coeff.addMonoidHom g) (f i)) \u2286 \u2191f.support"}, {"tactic": "intro x h", "annotated_tactic": ["intro x h", []], "state_before": "case coeff.h.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\n\u22a2 (Function.support fun i => (coeff.addMonoidHom g) (f i)) \u2286 \u2191f.support", "state_after": "case coeff.h.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\nx : \u03b1\nh : x \u2208 Function.support fun i => (coeff.addMonoidHom g) (f i)\n\u22a2 x \u2208 \u2191f.support"}, {"tactic": "simp only [coeff.addMonoidHom_apply, mem_coe, Finsupp.mem_support_iff, Ne.def]", "annotated_tactic": ["simp only [<a>coeff.addMonoidHom_apply</a>, <a>mem_coe</a>, <a>Finsupp.mem_support_iff</a>, <a>Ne.def</a>]", [{"full_name": "HahnSeries.coeff.addMonoidHom_apply", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/HahnSeries/Addition.lean", "def_pos": [101, 3], "def_end_pos": [101, 8]}, {"full_name": "Finset.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}, {"full_name": "Finsupp.mem_support_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [185, 9], "def_end_pos": [185, 24]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}]], "state_before": "case coeff.h.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\nx : \u03b1\nh : x \u2208 Function.support fun i => (coeff.addMonoidHom g) (f i)\n\u22a2 x \u2208 \u2191f.support", "state_after": "case coeff.h.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\nx : \u03b1\nh : x \u2208 Function.support fun i => (coeff.addMonoidHom g) (f i)\n\u22a2 \u00acf x = 0"}, {"tactic": "contrapose! h", "annotated_tactic": ["contrapose! h", []], "state_before": "case coeff.h.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\nx : \u03b1\nh : x \u2208 Function.support fun i => (coeff.addMonoidHom g) (f i)\n\u22a2 \u00acf x = 0", "state_after": "case coeff.h.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\nx : \u03b1\nh : f x = 0\n\u22a2 x \u2209 Function.support fun i => (coeff.addMonoidHom g) (f i)"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case coeff.h.h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddCommMonoid R\n\u03b1 : Type u_3\nf : \u03b1 \u2192\u2080 HahnSeries \u0393 R\ng : \u0393\nx : \u03b1\nh : f x = 0\n\u22a2 x \u2209 Function.support fun i => (coeff.addMonoidHom g) (f i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "Metric.sphere_eq_empty_of_subsingleton", "start": [499, 1], "end": [500, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Continuum.lean", "full_name": "Cardinal.lift_le_continuum", "start": [53, 1], "end": [55, 39], "traced_tactics": [{"tactic": "rw [\u2190 lift_continuum.{u,v}, lift_le]", "annotated_tactic": ["rw [\u2190 <a>lift_continuum</a>.{u,v}, <a>lift_le</a>]", [{"full_name": "Cardinal.lift_continuum", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Continuum.lean", "def_pos": [42, 9], "def_end_pos": [42, 23]}, {"full_name": "Cardinal.lift_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 16]}]], "state_before": "c : Cardinal.{u}\n\u22a2 lift.{v, u} c \u2264 \ud835\udd20 \u2194 c \u2264 \ud835\udd20", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Intervals.lean", "full_name": "Finset.sum_Ico_Ico_comm", "start": [167, 1], "end": [176, 8], "traced_tactics": [{"tactic": "rw [Finset.sum_sigma', Finset.sum_sigma']", "annotated_tactic": ["rw [<a>Finset.sum_sigma'</a>, <a>Finset.sum_sigma'</a>]", [{"full_name": "Finset.sum_sigma'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [594, 3], "def_end_pos": [594, 14]}, {"full_name": "Finset.sum_sigma'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [594, 3], "def_end_pos": [594, 14]}]], "state_before": "\u03b1 : Type u_1\nM\u271d : Type u_2\ninst\u271d\u00b9 : CommMonoid M\u271d\ns\u2082 s\u2081 s : Finset \u03b1\na\u271d : \u03b1\ng f\u271d : \u03b1 \u2192 M\u271d\nM : Type u_3\ninst\u271d : AddCommMonoid M\na b : \u2115\nf : \u2115 \u2192 \u2115 \u2192 M\n\u22a2 \u2211 i in Ico a b, \u2211 j in Ico i b, f i j = \u2211 j in Ico a b, \u2211 i in Ico a (j + 1), f i j", "state_after": "\u03b1 : Type u_1\nM\u271d : Type u_2\ninst\u271d\u00b9 : CommMonoid M\u271d\ns\u2082 s\u2081 s : Finset \u03b1\na\u271d : \u03b1\ng f\u271d : \u03b1 \u2192 M\u271d\nM : Type u_3\ninst\u271d : AddCommMonoid M\na b : \u2115\nf : \u2115 \u2192 \u2115 \u2192 M\n\u22a2 \u2211 x in Finset.sigma (Ico a b) fun i => Ico i b, f x.fst x.snd =\n    \u2211 x in Finset.sigma (Ico a b) fun j => Ico a (j + 1), f x.snd x.fst"}, {"tactic": "refine' sum_nbij' (fun x \u21a6 \u27e8x.2, x.1\u27e9) (fun x \u21a6 \u27e8x.2, x.1\u27e9) _ _ (fun _ _ \u21a6 rfl) (fun _ _ \u21a6 rfl)\n  (fun _ _ \u21a6 rfl) <;>\nsimp only [Finset.mem_Ico, Sigma.forall, Finset.mem_sigma] <;>\nrintro a b \u27e8\u27e8h\u2081, h\u2082\u27e9, \u27e8h\u2083, h\u2084\u27e9\u27e9 <;>\nrefine' \u27e8\u27e8_, _\u27e9, \u27e8_, _\u27e9\u27e9 <;>\nomega", "annotated_tactic": ["refine' <a>sum_nbij'</a> (fun x \u21a6 \u27e8x.2, x.1\u27e9) (fun x \u21a6 \u27e8x.2, x.1\u27e9) _ _ (fun _ _ \u21a6 <a>rfl</a>) (fun _ _ \u21a6 <a>rfl</a>)\n    (fun _ _ \u21a6 <a>rfl</a>) <;>\n  simp only [<a>Finset.mem_Ico</a>, <a>Sigma.forall</a>, <a>Finset.mem_sigma</a>] <;>\n  rintro a b \u27e8\u27e8h\u2081, h\u2082\u27e9, \u27e8h\u2083, h\u2084\u27e9\u27e9 <;>\n  refine' \u27e8\u27e8_, _\u27e9, \u27e8_, _\u27e9\u27e9 <;>\n  omega", [{"full_name": "Finset.sum_nbij'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [680, 3], "def_end_pos": [680, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Finset.mem_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [332, 9], "def_end_pos": [332, 16]}, {"full_name": "Sigma.forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sigma/Basic.lean", "def_pos": [95, 9], "def_end_pos": [95, 17]}, {"full_name": "Finset.mem_sigma", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Sigma.lean", "def_pos": [49, 9], "def_end_pos": [49, 18]}]], "state_before": "\u03b1 : Type u_1\nM\u271d : Type u_2\ninst\u271d\u00b9 : CommMonoid M\u271d\ns\u2082 s\u2081 s : Finset \u03b1\na\u271d : \u03b1\ng f\u271d : \u03b1 \u2192 M\u271d\nM : Type u_3\ninst\u271d : AddCommMonoid M\na b : \u2115\nf : \u2115 \u2192 \u2115 \u2192 M\n\u22a2 \u2211 x in Finset.sigma (Ico a b) fun i => Ico i b, f x.fst x.snd =\n    \u2211 x in Finset.sigma (Ico a b) fun j => Ico a (j + 1), f x.snd x.fst", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Ring/Basic.lean", "full_name": "Mathlib.Tactic.Ring.zero_mul", "start": [432, 1], "end": [432, 48], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\nb : R\n\u22a2 0 * b = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "full_name": "Matrix.SpecialLinearGroup.isCoprime_row", "start": [414, 1], "end": [419, 9], "traced_tactics": [{"tactic": "simp_rw [det_coe A \u25b8 det_fin_two A.1]", "annotated_tactic": ["simp_rw [<a>det_coe</a> A \u25b8 <a>det_fin_two</a> A.1]", [{"full_name": "Matrix.SpecialLinearGroup.det_coe", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "def_pos": [168, 9], "def_end_pos": [168, 16]}, {"full_name": "Matrix.det_fin_two", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [791, 9], "def_end_pos": [791, 20]}]], "state_before": "case refine_2\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\ni : Fin 2\n\u22a2 -\u2191A 0 1 * \u2191A 1 0 + \u2191A 0 0 * \u2191A 1 1 = 1", "state_after": "case refine_2\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\ni : Fin 2\n\u22a2 -\u2191A 0 1 * \u2191A 1 0 + \u2191A 0 0 * \u2191A 1 1 = \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0"}, {"tactic": "ring", "annotated_tactic": ["ring", []], "state_before": "case refine_2\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\nR : Type v\ninst\u271d\u00b9 : CommRing R\nS : Type u_1\ninst\u271d : CommRing S\nA : SL(2, R)\ni : Fin 2\n\u22a2 -\u2191A 0 1 * \u2191A 1 0 + \u2191A 0 0 * \u2191A 1 1 = \u2191A 0 0 * \u2191A 1 1 - \u2191A 0 1 * \u2191A 1 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/StructuredArrow.lean", "full_name": "CategoryTheory.StructuredArrow.IsUniversal.hom_ext", "start": [365, 1], "end": [367, 38], "traced_tactics": [{"tactic": "rw [h.hom_desc \u03b7, h.hom_desc \u03b7', w]", "annotated_tactic": ["rw [h.hom_desc \u03b7, h.hom_desc \u03b7', w]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} D\nS S' S'' : D\nY Y' Y'' : C\nT T' : C \u2964 D\nA : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} A\nB : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} B\nf g : StructuredArrow S T\nh : IsUniversal f\nc : C\n\u03b7 \u03b7' : f.right \u27f6 c\nw : f.hom \u226b T.map \u03b7 = f.hom \u226b T.map \u03b7'\n\u22a2 \u03b7 = \u03b7'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Add.lean", "full_name": "DifferentiableAt.const_sub", "start": [679, 1], "end": [681, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Subtype.lean", "full_name": "Subtype.heq_iff_coe_heq", "start": [79, 1], "end": [83, 39], "traced_tactics": [{"tactic": "subst h", "annotated_tactic": ["subst h", []], "state_before": "\u03b1\u271d : Sort u_1\n\u03b2\u271d : Sort u_2\n\u03b3 : Sort u_3\np\u271d q\u271d : \u03b1\u271d \u2192 Prop\n\u03b1 \u03b2 : Sort u_4\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\na : { x // p x }\nb : { y // q y }\nh : \u03b1 = \u03b2\nh' : HEq p q\n\u22a2 HEq a b \u2194 HEq \u2191a \u2191b", "state_after": "\u03b1\u271d : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np\u271d q\u271d : \u03b1\u271d \u2192 Prop\n\u03b1 : Sort u_4\np : \u03b1 \u2192 Prop\na : { x // p x }\nq : \u03b1 \u2192 Prop\nb : { y // q y }\nh' : HEq p q\n\u22a2 HEq a b \u2194 HEq \u2191a \u2191b"}, {"tactic": "subst h'", "annotated_tactic": ["subst h'", []], "state_before": "\u03b1\u271d : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np\u271d q\u271d : \u03b1\u271d \u2192 Prop\n\u03b1 : Sort u_4\np : \u03b1 \u2192 Prop\na : { x // p x }\nq : \u03b1 \u2192 Prop\nb : { y // q y }\nh' : HEq p q\n\u22a2 HEq a b \u2194 HEq \u2191a \u2191b", "state_after": "\u03b1\u271d : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np\u271d q : \u03b1\u271d \u2192 Prop\n\u03b1 : Sort u_4\np : \u03b1 \u2192 Prop\na b : { y // p y }\n\u22a2 HEq a b \u2194 HEq \u2191a \u2191b"}, {"tactic": "rw [heq_iff_eq, heq_iff_eq, ext_iff]", "annotated_tactic": ["rw [<a>heq_iff_eq</a>, <a>heq_iff_eq</a>, <a>ext_iff</a>]", [{"full_name": "heq_iff_eq", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [33, 9], "def_end_pos": [33, 19]}, {"full_name": "heq_iff_eq", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [33, 9], "def_end_pos": [33, 19]}, {"full_name": "Subtype.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [69, 9], "def_end_pos": [69, 16]}]], "state_before": "\u03b1\u271d : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np\u271d q : \u03b1\u271d \u2192 Prop\n\u03b1 : Sort u_4\np : \u03b1 \u2192 Prop\na b : { y // p y }\n\u22a2 HEq a b \u2194 HEq \u2191a \u2191b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Pointwise.lean", "full_name": "thickening_cthickening", "start": [313, 1], "end": [317, 82], "traced_tactics": [{"tactic": "obtain rfl | h\u03b4 := h\u03b4.eq_or_lt", "annotated_tactic": ["obtain rfl | h\u03b4 := h\u03b4.eq_or_lt", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx y z : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 \u2264 \u03b4\ns : Set E\n\u22a2 thickening \u03b5 (cthickening \u03b4 s) = thickening (\u03b5 + \u03b4) s", "state_after": "case inl\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx y z : E\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\ns : Set E\nh\u03b4 : 0 \u2264 0\n\u22a2 thickening \u03b5 (cthickening 0 s) = thickening (\u03b5 + 0) s\n\ncase inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx y z : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4\u271d : 0 \u2264 \u03b4\ns : Set E\nh\u03b4 : 0 < \u03b4\n\u22a2 thickening \u03b5 (cthickening \u03b4 s) = thickening (\u03b5 + \u03b4) s"}, {"tactic": "rw [cthickening_zero, thickening_closure, add_zero]", "annotated_tactic": ["rw [<a>cthickening_zero</a>, <a>thickening_closure</a>, <a>add_zero</a>]", [{"full_name": "Metric.cthickening_zero", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [232, 9], "def_end_pos": [232, 25]}, {"full_name": "Metric.thickening_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [405, 9], "def_end_pos": [405, 27]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "case inl\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx y z : E\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\ns : Set E\nh\u03b4 : 0 \u2264 0\n\u22a2 thickening \u03b5 (cthickening 0 s) = thickening (\u03b5 + 0) s", "state_after": "no goals"}, {"tactic": "rw [\u2190 closure_thickening h\u03b4, thickening_closure, thickening_thickening h\u03b5 h\u03b4]", "annotated_tactic": ["rw [\u2190 <a>closure_thickening</a> h\u03b4, <a>thickening_closure</a>, <a>thickening_thickening</a> h\u03b5 h\u03b4]", [{"full_name": "closure_thickening", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Pointwise.lean", "def_pos": [299, 9], "def_end_pos": [299, 27]}, {"full_name": "Metric.thickening_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [405, 9], "def_end_pos": [405, 27]}, {"full_name": "thickening_thickening", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Pointwise.lean", "def_pos": [279, 9], "def_end_pos": [279, 30]}]], "state_before": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx y z : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4\u271d : 0 \u2264 \u03b4\ns : Set E\nh\u03b4 : 0 < \u03b4\n\u22a2 thickening \u03b5 (cthickening \u03b4 s) = thickening (\u03b5 + \u03b4) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Basic.lean", "full_name": "Complex.I_mul_re", "start": [349, 1], "end": [349, 57], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "z : \u2102\n\u22a2 (I * z).re = -z.im", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean", "full_name": "Nat.prod_factorization_eq_prod_primeFactors", "start": [207, 1], "end": [209, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "full_name": "Real.div_logb", "start": [111, 1], "end": [113, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Inseparable.lean", "full_name": "SeparationQuotient.lift_comp_mk", "start": [501, 1], "end": [502, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.rightInverse_iff_comp", "start": [345, 1], "end": [346, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Adjoin/Basic.lean", "full_name": "Algebra.adjoin_union_coe_submodule", "start": [352, 1], "end": [356, 81], "traced_tactics": [{"tactic": "rw [adjoin_eq_span, adjoin_eq_span, adjoin_eq_span, span_mul_span]", "annotated_tactic": ["rw [<a>adjoin_eq_span</a>, <a>adjoin_eq_span</a>, <a>adjoin_eq_span</a>, <a>span_mul_span</a>]", [{"full_name": "Algebra.adjoin_eq_span", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Adjoin/Basic.lean", "def_pos": [163, 9], "def_end_pos": [163, 23]}, {"full_name": "Algebra.adjoin_eq_span", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Adjoin/Basic.lean", "def_pos": [163, 9], "def_end_pos": [163, 23]}, {"full_name": "Algebra.adjoin_eq_span", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Adjoin/Basic.lean", "def_pos": [163, 9], "def_end_pos": [163, 23]}, {"full_name": "Submodule.span_mul_span", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Operations.lean", "def_pos": [200, 9], "def_end_pos": [200, 22]}]], "state_before": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\ns t : Set A\n\u22a2 Subalgebra.toSubmodule (adjoin R (s \u222a t)) = Subalgebra.toSubmodule (adjoin R s) * Subalgebra.toSubmodule (adjoin R t)", "state_after": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\ns t : Set A\n\u22a2 span R \u2191(Submonoid.closure (s \u222a t)) = span R (\u2191(Submonoid.closure s) * \u2191(Submonoid.closure t))"}, {"tactic": "congr 1 with z", "annotated_tactic": ["congr 1 with z", []], "state_before": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\ns t : Set A\n\u22a2 span R \u2191(Submonoid.closure (s \u222a t)) = span R (\u2191(Submonoid.closure s) * \u2191(Submonoid.closure t))", "state_after": "case e_s.h\nR : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\ns t : Set A\nz : A\n\u22a2 z \u2208 \u2191(Submonoid.closure (s \u222a t)) \u2194 z \u2208 \u2191(Submonoid.closure s) * \u2191(Submonoid.closure t)"}, {"tactic": "simp [Submonoid.closure_union, Submonoid.mem_sup, Set.mem_mul]", "annotated_tactic": ["simp [<a>Submonoid.closure_union</a>, <a>Submonoid.mem_sup</a>, <a>Set.mem_mul</a>]", [{"full_name": "Submonoid.closure_union", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [525, 9], "def_end_pos": [525, 22]}, {"full_name": "Submonoid.mem_sup", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [647, 9], "def_end_pos": [647, 16]}, {"full_name": "Set.mem_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [341, 9], "def_end_pos": [341, 16]}]], "state_before": "case e_s.h\nR : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\ns t : Set A\nz : A\n\u22a2 z \u2208 \u2191(Submonoid.closure (s \u222a t)) \u2194 z \u2208 \u2191(Submonoid.closure s) * \u2191(Submonoid.closure t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Matrix.lean", "full_name": "Matrix.transpose_tsum", "start": [308, 1], "end": [312, 91], "traced_tactics": [{"tactic": "by_cases hf : Summable f", "annotated_tactic": ["by_cases hf : <a>Summable</a> f", [{"full_name": "Summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [64, 5], "def_end_pos": [64, 13]}]], "state_before": "X : Type u_1\n\u03b1 : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nS : Type u_7\nR : Type u_8\nm' : l \u2192 Type u_9\nn' : l \u2192 Type u_10\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : Module \u03b1 R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\n\u22a2 (\u2211' (x : X), f x)\u1d40 = \u2211' (x : X), (f x)\u1d40", "state_after": "case pos\nX : Type u_1\n\u03b1 : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nS : Type u_7\nR : Type u_8\nm' : l \u2192 Type u_9\nn' : l \u2192 Type u_10\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : Module \u03b1 R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : Summable f\n\u22a2 (\u2211' (x : X), f x)\u1d40 = \u2211' (x : X), (f x)\u1d40\n\ncase neg\nX : Type u_1\n\u03b1 : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nS : Type u_7\nR : Type u_8\nm' : l \u2192 Type u_9\nn' : l \u2192 Type u_10\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : Module \u03b1 R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : \u00acSummable f\n\u22a2 (\u2211' (x : X), f x)\u1d40 = \u2211' (x : X), (f x)\u1d40"}, {"tactic": "exact hf.hasSum.matrix_transpose.tsum_eq.symm", "annotated_tactic": ["exact hf.hasSum.matrix_transpose.tsum_eq.symm", []], "state_before": "case pos\nX : Type u_1\n\u03b1 : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nS : Type u_7\nR : Type u_8\nm' : l \u2192 Type u_9\nn' : l \u2192 Type u_10\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : Module \u03b1 R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : Summable f\n\u22a2 (\u2211' (x : X), f x)\u1d40 = \u2211' (x : X), (f x)\u1d40", "state_after": "no goals"}, {"tactic": "have hft := summable_matrix_transpose.not.mpr hf", "annotated_tactic": ["have hft := summable_matrix_transpose.not.mpr hf", []], "state_before": "case neg\nX : Type u_1\n\u03b1 : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nS : Type u_7\nR : Type u_8\nm' : l \u2192 Type u_9\nn' : l \u2192 Type u_10\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : Module \u03b1 R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : \u00acSummable f\n\u22a2 (\u2211' (x : X), f x)\u1d40 = \u2211' (x : X), (f x)\u1d40", "state_after": "case neg\nX : Type u_1\n\u03b1 : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nS : Type u_7\nR : Type u_8\nm' : l \u2192 Type u_9\nn' : l \u2192 Type u_10\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : Module \u03b1 R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : \u00acSummable f\nhft : \u00acSummable fun x => (f x)\u1d40\n\u22a2 (\u2211' (x : X), f x)\u1d40 = \u2211' (x : X), (f x)\u1d40"}, {"tactic": "rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable hft, transpose_zero]", "annotated_tactic": ["rw [<a>tsum_eq_zero_of_not_summable</a> hf, <a>tsum_eq_zero_of_not_summable</a> hft, <a>transpose_zero</a>]", [{"full_name": "tsum_eq_zero_of_not_summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [90, 9], "def_end_pos": [90, 37]}, {"full_name": "tsum_eq_zero_of_not_summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [90, 9], "def_end_pos": [90, 37]}, {"full_name": "Matrix.transpose_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [2006, 9], "def_end_pos": [2006, 23]}]], "state_before": "case neg\nX : Type u_1\n\u03b1 : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\np : Type u_6\nS : Type u_7\nR : Type u_8\nm' : l \u2192 Type u_9\nn' : l \u2192 Type u_10\ninst\u271d\u2074 : Semiring \u03b1\ninst\u271d\u00b3 : AddCommMonoid R\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : Module \u03b1 R\ninst\u271d : T2Space R\nf : X \u2192 Matrix m n R\nhf : \u00acSummable f\nhft : \u00acSummable fun x => (f x)\u1d40\n\u22a2 (\u2211' (x : X), f x)\u1d40 = \u2211' (x : X), (f x)\u1d40", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Disjointed.lean", "full_name": "disjointed_eq_inf_compl", "start": [149, 1], "end": [157, 23], "traced_tactics": [{"tactic": "cases n", "annotated_tactic": ["cases n", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\nn : \u2115\n\u22a2 disjointed f n = f n \u2293 \u2a05 i, \u2a05 (_ : i < n), (f i)\u1d9c", "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\n\u22a2 disjointed f Nat.zero = f Nat.zero \u2293 \u2a05 i, \u2a05 (_ : i < Nat.zero), (f i)\u1d9c\n\ncase succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\nn\u271d : \u2115\n\u22a2 disjointed f (Nat.succ n\u271d) = f (Nat.succ n\u271d) \u2293 \u2a05 i, \u2a05 (_ : i < Nat.succ n\u271d), (f i)\u1d9c"}, {"tactic": "simp_rw [disjointed_succ, partialSups_eq_biSup, sdiff_eq, compl_iSup]", "annotated_tactic": ["simp_rw [<a>disjointed_succ</a>, <a>partialSups_eq_biSup</a>, <a>sdiff_eq</a>, <a>compl_iSup</a>]", [{"full_name": "disjointed_succ", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjointed.lean", "def_pos": [59, 9], "def_end_pos": [59, 24]}, {"full_name": "partialSups_eq_biSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/PartialSups.lean", "def_pos": [179, 9], "def_end_pos": [179, 29]}, {"full_name": "sdiff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [594, 9], "def_end_pos": [594, 17]}, {"full_name": "compl_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteBooleanAlgebra.lean", "def_pos": [455, 9], "def_end_pos": [455, 19]}]], "state_before": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\nn\u271d : \u2115\n\u22a2 disjointed f (Nat.succ n\u271d) = f (Nat.succ n\u271d) \u2293 \u2a05 i, \u2a05 (_ : i < Nat.succ n\u271d), (f i)\u1d9c", "state_after": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\nn\u271d : \u2115\n\u22a2 f (n\u271d + 1) \u2293 \u2a05 i, \u2a05 (_ : i \u2264 n\u271d), (f i)\u1d9c = f (Nat.succ n\u271d) \u2293 \u2a05 i, \u2a05 (_ : i < Nat.succ n\u271d), (f i)\u1d9c"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\nn\u271d : \u2115\n\u22a2 f (n\u271d + 1) \u2293 \u2a05 i, \u2a05 (_ : i \u2264 n\u271d), (f i)\u1d9c = f (Nat.succ n\u271d) \u2293 \u2a05 i, \u2a05 (_ : i < Nat.succ n\u271d), (f i)\u1d9c", "state_after": "case succ.e_a.e_s\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\nn\u271d : \u2115\n\u22a2 (fun i => \u2a05 (_ : i \u2264 n\u271d), (f i)\u1d9c) = fun i => \u2a05 (_ : i < Nat.succ n\u271d), (f i)\u1d9c"}, {"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "case succ.e_a.e_s\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\nn\u271d : \u2115\n\u22a2 (fun i => \u2a05 (_ : i \u2264 n\u271d), (f i)\u1d9c) = fun i => \u2a05 (_ : i < Nat.succ n\u271d), (f i)\u1d9c", "state_after": "case succ.e_a.e_s.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\nn\u271d i : \u2115\n\u22a2 \u2a05 (_ : i \u2264 n\u271d), (f i)\u1d9c = \u2a05 (_ : i < Nat.succ n\u271d), (f i)\u1d9c"}, {"tactic": "rw [Nat.lt_succ_iff]", "annotated_tactic": ["rw [<a>Nat.lt_succ_iff</a>]", [{"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}]], "state_before": "case succ.e_a.e_s.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\nn\u271d i : \u2115\n\u22a2 \u2a05 (_ : i \u2264 n\u271d), (f i)\u1d9c = \u2a05 (_ : i < Nat.succ n\u271d), (f i)\u1d9c", "state_after": "no goals"}, {"tactic": "rw [disjointed_zero, eq_comm, inf_eq_left]", "annotated_tactic": ["rw [<a>disjointed_zero</a>, <a>eq_comm</a>, <a>inf_eq_left</a>]", [{"full_name": "disjointed_zero", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjointed.lean", "def_pos": [55, 9], "def_end_pos": [55, 24]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "inf_eq_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [403, 9], "def_end_pos": [403, 20]}]], "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\n\u22a2 disjointed f Nat.zero = f Nat.zero \u2293 \u2a05 i, \u2a05 (_ : i < Nat.zero), (f i)\u1d9c", "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\n\u22a2 f Nat.zero \u2264 \u2a05 i, \u2a05 (_ : i < Nat.zero), (f i)\u1d9c"}, {"tactic": "simp_rw [le_iInf_iff]", "annotated_tactic": ["simp_rw [<a>le_iInf_iff</a>]", [{"full_name": "le_iInf_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [858, 9], "def_end_pos": [858, 20]}]], "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\n\u22a2 f Nat.zero \u2264 \u2a05 i, \u2a05 (_ : i < Nat.zero), (f i)\u1d9c", "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2200 i < Nat.zero, f Nat.zero \u2264 (f i)\u1d9c"}, {"tactic": "exact fun i hi => (i.not_lt_zero hi).elim", "annotated_tactic": ["exact fun i hi => (i.not_lt_zero hi).<a>elim</a>", [{"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}]], "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteBooleanAlgebra \u03b1\nf : \u2115 \u2192 \u03b1\n\u22a2 \u2200 i < Nat.zero, f Nat.zero \u2264 (f i)\u1d9c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean", "full_name": "MeasureTheory.Measure.countable_meas_level_set_pos", "start": [818, 1], "end": [821, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.preimage_congr", "start": [55, 1], "end": [57, 11], "traced_tactics": [{"tactic": "congr with x", "annotated_tactic": ["congr with x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b1 \u2192 \u03b2\ng\u271d : \u03b2 \u2192 \u03b3\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : \u2200 (x : \u03b1), f x = g x\n\u22a2 f \u207b\u00b9' s = g \u207b\u00b9' s", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b1 \u2192 \u03b2\ng\u271d : \u03b2 \u2192 \u03b3\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : \u2200 (x : \u03b1), f x = g x\nx : \u03b1\n\u22a2 x \u2208 f \u207b\u00b9' s \u2194 x \u2208 g \u207b\u00b9' s"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b1 \u2192 \u03b2\ng\u271d : \u03b2 \u2192 \u03b3\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : \u2200 (x : \u03b1), f x = g x\nx : \u03b1\n\u22a2 x \u2208 f \u207b\u00b9' s \u2194 x \u2208 g \u207b\u00b9' s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Algebra/Classes.lean", "full_name": "antisymm", "start": [307, 1], "end": [308, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometryEquiv.congr_arg", "start": [598, 11], "end": [599, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/ToNat.lean", "full_name": "Cardinal.toNat_lt_toNat", "start": [100, 1], "end": [101, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/PathConnected.lean", "full_name": "joinedIn_univ", "start": [857, 1], "end": [858, 52], "traced_tactics": [{"tactic": "simp [JoinedIn, Joined, exists_true_iff_nonempty]", "annotated_tactic": ["simp [<a>JoinedIn</a>, <a>Joined</a>, <a>exists_true_iff_nonempty</a>]", [{"full_name": "JoinedIn", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/PathConnected.lean", "def_pos": [804, 5], "def_end_pos": [804, 13]}, {"full_name": "Joined", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/PathConnected.lean", "def_pos": [757, 5], "def_end_pos": [757, 11]}, {"full_name": "exists_true_iff_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nonempty.lean", "def_pos": [44, 9], "def_end_pos": [44, 33]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\nF : Set X\n\u22a2 JoinedIn univ x y \u2194 Joined x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "full_name": "AffineEquiv.continuous_of_finiteDimensional", "start": [136, 1], "end": [137, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "Valuation.map_add_eq_of_lt_left", "start": [324, 1], "end": [325, 50], "traced_tactics": [{"tactic": "rw [add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "K : Type u_1\nF : Type u_2\nR : Type u_3\ninst\u271d\u00b3 : DivisionRing K\n\u0393\u2080 : Type u_4\n\u0393'\u2080 : Type u_5\n\u0393''\u2080 : Type u_6\ninst\u271d\u00b2 : LinearOrderedCommMonoidWithZero \u0393''\u2080\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y z : R\nh : v y < v x\n\u22a2 v (x + y) = v x", "state_after": "K : Type u_1\nF : Type u_2\nR : Type u_3\ninst\u271d\u00b3 : DivisionRing K\n\u0393\u2080 : Type u_4\n\u0393'\u2080 : Type u_5\n\u0393''\u2080 : Type u_6\ninst\u271d\u00b2 : LinearOrderedCommMonoidWithZero \u0393''\u2080\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y z : R\nh : v y < v x\n\u22a2 v (y + x) = v x"}, {"tactic": "exact map_add_eq_of_lt_right _ h", "annotated_tactic": ["exact <a>map_add_eq_of_lt_right</a> _ h", [{"full_name": "Valuation.map_add_eq_of_lt_right", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Valuation/Basic.lean", "def_pos": [320, 9], "def_end_pos": [320, 31]}]], "state_before": "K : Type u_1\nF : Type u_2\nR : Type u_3\ninst\u271d\u00b3 : DivisionRing K\n\u0393\u2080 : Type u_4\n\u0393'\u2080 : Type u_5\n\u0393''\u2080 : Type u_6\ninst\u271d\u00b2 : LinearOrderedCommMonoidWithZero \u0393''\u2080\ninst\u271d\u00b9 : Ring R\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\nx y z : R\nh : v y < v x\n\u22a2 v (y + x) = v x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/PGroup.lean", "full_name": "IsPGroup.nontrivial_iff_card", "start": [158, 1], "end": [167, 76], "traced_tactics": [{"tactic": "rw [hk0, pow_zero] at hk", "annotated_tactic": ["rw [hk0, <a>pow_zero</a>] at hk", [{"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}]], "state_before": "p : \u2115\nG : Type u_1\ninst\u271d\u00b9 : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\ninst\u271d : Fintype G\nhGnt : Nontrivial G\nk : \u2115\nhk : card G = p ^ k\nhk0 : k = 0\n\u22a2 False", "state_after": "p : \u2115\nG : Type u_1\ninst\u271d\u00b9 : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\ninst\u271d : Fintype G\nhGnt : Nontrivial G\nk : \u2115\nhk : card G = 1\nhk0 : k = 0\n\u22a2 False"}, {"tactic": "exact Fintype.one_lt_card.ne' hk", "annotated_tactic": ["exact Fintype.one_lt_card.ne' hk", []], "state_before": "p : \u2115\nG : Type u_1\ninst\u271d\u00b9 : Group G\nhG : IsPGroup p G\nhp : Fact (Nat.Prime p)\ninst\u271d : Fintype G\nhGnt : Nontrivial G\nk : \u2115\nhk : card G = 1\nhk0 : k = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.singleton_vsub_singleton", "start": [1629, 1], "end": [1630, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean", "full_name": "MeasureTheory.Measure.fst_zero", "start": [1038, 9], "end": [1038, 74], "traced_tactics": [{"tactic": "simp [fst]", "annotated_tactic": ["simp [<a>fst</a>]", [{"full_name": "MeasureTheory.Measure.fst", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Constructions/Prod/Basic.lean", "def_pos": [1027, 19], "def_end_pos": [1027, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\nE : Type u_6\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1'\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace \u03b2'\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bc \u03bc' : Measure \u03b1\n\u03bd \u03bd' : Measure \u03b2\n\u03c4 : Measure \u03b3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : SFinite \u03bd\n\u03c1 : Measure (\u03b1 \u00d7 \u03b2)\n\u22a2 fst 0 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.OuterMeasure.trim_eq_iInf", "start": [1635, 1], "end": [1639, 36], "traced_tactics": [{"tactic": "simp (config := { singlePass := true }) only [iInf_comm]", "annotated_tactic": ["simp (config := { singlePass := <a>true</a> }) only [<a>iInf_comm</a>]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}, {"full_name": "iInf_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1090, 9], "def_end_pos": [1090, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\ns : Set \u03b1\n\u22a2 \u2191(trim m) s = \u2a05 t, \u2a05 (_ : s \u2286 t), \u2a05 (_ : MeasurableSet t), \u2191m t", "state_after": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\ns : Set \u03b1\n\u22a2 \u2191(trim m) s = \u2a05 t, \u2a05 (_ : MeasurableSet t), \u2a05 (_ : s \u2286 t), \u2191m t"}, {"tactic": "exact\n  inducedOuterMeasure_eq_iInf MeasurableSet.iUnion (fun f _ => m.iUnion_nat f)\n    (fun _ _ _ _ h => m.mono h) s", "annotated_tactic": ["exact\n    <a>inducedOuterMeasure_eq_iInf</a> <a>MeasurableSet.iUnion</a> (fun f _ => m.iUnion_nat f)\n      (fun _ _ _ _ h => m.mono h) s", [{"full_name": "MeasureTheory.inducedOuterMeasure_eq_iInf", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1458, 9], "def_end_pos": [1458, 36]}, {"full_name": "MeasurableSet.iUnion", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [116, 19], "def_end_pos": [116, 39]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\ns : Set \u03b1\n\u22a2 \u2191(trim m) s = \u2a05 t, \u2a05 (_ : MeasurableSet t), \u2a05 (_ : s \u2286 t), \u2191m t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Tower.lean", "full_name": "Algebra.lsmul_injective", "start": [370, 1], "end": [372, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "full_name": "Matrix.det_one_add_smul", "start": [250, 1], "end": [254, 98], "traced_tactics": [{"tactic": "simpa [eval_det, \u2190 smul_eq_mul_diagonal] using congr_arg (eval r) (Matrix.det_one_add_X_smul M)", "annotated_tactic": ["simpa [<a>eval_det</a>, \u2190 <a>smul_eq_mul_diagonal</a>] using <a>congr_arg</a> (<a>eval</a> r) (<a>Matrix.det_one_add_X_smul</a> M)", [{"full_name": "Matrix.eval_det", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "def_pos": [177, 9], "def_end_pos": [177, 17]}, {"full_name": "Matrix.smul_eq_mul_diagonal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1304, 9], "def_end_pos": [1304, 29]}, {"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "Polynomial.eval", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [315, 5], "def_end_pos": [315, 9]}, {"full_name": "Matrix.det_one_add_X_smul", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "def_pos": [241, 7], "def_end_pos": [241, 25]}]], "state_before": "R : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d : Matrix n n R\nr : R\nM : Matrix n n R\n\u22a2 det (1 + r \u2022 M) = 1 + trace M * r + eval r (divX (divX (det (1 + X \u2022 map M \u21d1C)))) * r ^ 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Limit.lean", "full_name": "Order.IsPredLimit.lt_pred", "start": [356, 1], "end": [357, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.val_le", "start": [58, 1], "end": [59, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Module/Basic.lean", "full_name": "PolynomialModule.single_apply", "start": [261, 1], "end": [262, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.prod_single", "start": [1069, 1], "end": [1072, 76], "traced_tactics": [{"tactic": "rw [prod_cons has, ih, single_mul_single, prod_cons has, prod_cons has]", "annotated_tactic": ["rw [<a>prod_cons</a> has, ih, <a>single_mul_single</a>, <a>prod_cons</a> has, <a>prod_cons</a> has]", [{"full_name": "Finset.prod_cons", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [306, 9], "def_end_pos": [306, 18]}, {"full_name": "MonoidAlgebra.single_mul_single", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [450, 9], "def_end_pos": [450, 26]}, {"full_name": "Finset.prod_cons", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [306, 9], "def_end_pos": [306, 18]}, {"full_name": "Finset.prod_cons", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [306, 9], "def_end_pos": [306, 18]}]], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\n\u03b9 : Type ui\ninst\u271d\u00b9 : CommSemiring k\ninst\u271d : CommMonoid G\ns\u271d : Finset \u03b9\na\u271d : \u03b9 \u2192 G\nb : \u03b9 \u2192 k\na : \u03b9\ns : Finset \u03b9\nhas : a \u2209 s\nih : \u220f i in s, single (a\u271d i) (b i) = single (\u220f i in s, a\u271d i) (\u220f i in s, b i)\n\u22a2 \u220f i in Finset.cons a s has, single (a\u271d i) (b i) =\n    single (\u220f i in Finset.cons a s has, a\u271d i) (\u220f i in Finset.cons a s has, b i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "TopHom.coe_top", "start": [327, 1], "end": [328, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/Over.lean", "full_name": "CategoryTheory.Over.iteratedSliceBackward_forget_forget", "start": [288, 1], "end": [290, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Icc_eq_cons_Ioc", "start": [629, 1], "end": [630, 51], "traced_tactics": [{"tactic": "classical rw [cons_eq_insert, Ioc_insert_left h]", "annotated_tactic": ["classical rw [<a>cons_eq_insert</a>, <a>Ioc_insert_left</a> h]", [{"full_name": "Finset.cons_eq_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1140, 9], "def_end_pos": [1140, 23]}, {"full_name": "Finset.Ioc_insert_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/LocallyFinite/Basic.lean", "def_pos": [580, 9], "def_end_pos": [580, 24]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\nh : a \u2264 b\n\u22a2 Icc a b = cons a (Ioc a b) \u22ef", "state_after": "no goals"}, {"tactic": "rw [cons_eq_insert, Ioc_insert_left h]", "annotated_tactic": ["rw [<a>cons_eq_insert</a>, <a>Ioc_insert_left</a> h]", [{"full_name": "Finset.cons_eq_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1140, 9], "def_end_pos": [1140, 23]}, {"full_name": "Finset.Ioc_insert_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/LocallyFinite/Basic.lean", "def_pos": [580, 9], "def_end_pos": [580, 24]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\nh : a \u2264 b\n\u22a2 Icc a b = cons a (Ioc a b) \u22ef", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "Inducing.prod_map", "start": [851, 1], "end": [854, 43], "traced_tactics": [{"tactic": "simp_rw [Prod.map_def, nhds_prod_eq, hf.nhds_eq_comap,\nhg.nhds_eq_comap, prod_comap_comap_eq]", "annotated_tactic": ["simp_rw [<a>Prod.map_def</a>, <a>nhds_prod_eq</a>, hf.nhds_eq_comap,\n    hg.nhds_eq_comap, <a>prod_comap_comap_eq</a>]", [{"full_name": "Prod.map_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [129, 9], "def_end_pos": [129, 16]}, {"full_name": "nhds_prod_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [534, 9], "def_end_pos": [534, 21]}, {"full_name": "Filter.prod_comap_comap_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [242, 9], "def_end_pos": [242, 28]}]], "state_before": "X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace W\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : TopologicalSpace \u03b6\nf : X \u2192 Y\ng : Z \u2192 W\nhf : Inducing f\nhg : Inducing g\nx\u271d : X \u00d7 Z\nx : X\nz : Z\n\u22a2 \ud835\udcdd (x, z) = comap (Prod.map f g) (\ud835\udcdd (Prod.map f g (x, z)))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Cast/Lemmas.lean", "full_name": "ofDual_intCast", "start": [556, 1], "end": [557, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearMap.algebraMap_apply", "start": [1756, 9], "end": [1756, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "full_name": "Finset.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one", "start": [414, 1], "end": [417, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LocallyFinite.lean", "full_name": "Finset.map_subtype_embedding_Ici", "start": [1356, 1], "end": [1358, 71], "traced_tactics": [{"tactic": "rw [subtype_Ici_eq]", "annotated_tactic": ["rw [<a>subtype_Ici_eq</a>]", [{"full_name": "Finset.subtype_Ici_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [1346, 9], "def_end_pos": [1346, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : LocallyFiniteOrderTop \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, a \u2264 x \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Ici a) = Ici \u2191a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : LocallyFiniteOrderTop \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, a \u2264 x \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Finset.subtype p (Ici \u2191a)) = Ici \u2191a"}, {"tactic": "exact Finset.subtype_map_of_mem fun x hx => hp (mem_Ici.1 hx) a.prop", "annotated_tactic": ["exact <a>Finset.subtype_map_of_mem</a> fun x hx => hp (<a>mem_Ici</a>.1 hx) a.prop", [{"full_name": "Finset.subtype_map_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [778, 9], "def_end_pos": [778, 27]}, {"full_name": "Finset.mem_Ici", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [383, 9], "def_end_pos": [383, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : LocallyFiniteOrderTop \u03b1\na : Subtype p\nhp : \u2200 \u2983a x : \u03b1\u2984, a \u2264 x \u2192 p a \u2192 p x\n\u22a2 map (Embedding.subtype p) (Finset.subtype p (Ici \u2191a)) = Ici \u2191a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean", "full_name": "real_inner_comm", "start": [437, 1], "end": [438, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/CharP/Basic.lean", "full_name": "CharP.false_of_nontrivial_of_char_one", "start": [481, 1], "end": [482, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Hom.lean", "full_name": "DistribMulActionHom.ext_ring_iff", "start": [420, 1], "end": [421, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Bool/Basic.lean", "full_name": "Bool.decide_not", "start": [52, 1], "end": [53, 26], "traced_tactics": [{"tactic": "by_cases p <;> simp [*]", "annotated_tactic": ["by_cases p <;> simp [*]", []], "state_before": "p : Prop\ninst\u271d : Decidable p\n\u22a2 (decide \u00acp) = !decide p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Power.lean", "full_name": "Odd.zpow_neg_iff", "start": [193, 1], "end": [194, 72], "traced_tactics": [{"tactic": "cases' hn with k hk", "annotated_tactic": ["cases' hn with k hk", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nhn : Odd n\n\u22a2 a ^ n < 0 \u2194 a < 0", "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn k : \u2124\nhk : n = 2 * k + 1\n\u22a2 a ^ n < 0 \u2194 a < 0"}, {"tactic": "simpa only [hk, two_mul] using zpow_bit1_neg_iff", "annotated_tactic": ["simpa only [hk, <a>two_mul</a>] using <a>zpow_bit1_neg_iff</a>", [{"full_name": "two_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [179, 9], "def_end_pos": [179, 16]}, {"full_name": "zpow_bit1_neg_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Power.lean", "def_pos": [163, 9], "def_end_pos": [163, 26]}]], "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn k : \u2124\nhk : n = 2 * k + 1\n\u22a2 a ^ n < 0 \u2194 a < 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Minpoly/Basic.lean", "full_name": "minpoly.not_isUnit", "start": [110, 1], "end": [115, 26], "traced_tactics": [{"tactic": "haveI : Nontrivial A := (algebraMap A B).domain_nontrivial", "annotated_tactic": ["haveI : <a>Nontrivial</a> A := (<a>algebraMap</a> A B).<a>domain_nontrivial</a>", [{"full_name": "Nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [31, 7], "def_end_pos": [31, 17]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "RingHom.domain_nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [598, 9], "def_end_pos": [598, 26]}]], "state_before": "A : Type u_1\nB : Type u_2\nB' : Type u_3\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Ring B'\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra A B'\nx : B\ninst\u271d : Nontrivial B\n\u22a2 \u00acIsUnit (minpoly A x)", "state_after": "A : Type u_1\nB : Type u_2\nB' : Type u_3\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Ring B'\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra A B'\nx : B\ninst\u271d : Nontrivial B\nthis : Nontrivial A\n\u22a2 \u00acIsUnit (minpoly A x)"}, {"tactic": "by_cases hx : IsIntegral A x", "annotated_tactic": ["by_cases hx : <a>IsIntegral</a> A x", [{"full_name": "IsIntegral", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/IntegralClosure.lean", "def_pos": [61, 5], "def_end_pos": [61, 15]}]], "state_before": "A : Type u_1\nB : Type u_2\nB' : Type u_3\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Ring B'\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra A B'\nx : B\ninst\u271d : Nontrivial B\nthis : Nontrivial A\n\u22a2 \u00acIsUnit (minpoly A x)", "state_after": "case pos\nA : Type u_1\nB : Type u_2\nB' : Type u_3\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Ring B'\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra A B'\nx : B\ninst\u271d : Nontrivial B\nthis : Nontrivial A\nhx : IsIntegral A x\n\u22a2 \u00acIsUnit (minpoly A x)\n\ncase neg\nA : Type u_1\nB : Type u_2\nB' : Type u_3\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Ring B'\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra A B'\nx : B\ninst\u271d : Nontrivial B\nthis : Nontrivial A\nhx : \u00acIsIntegral A x\n\u22a2 \u00acIsUnit (minpoly A x)"}, {"tactic": "exact mt (monic hx).eq_one_of_isUnit (ne_one A x)", "annotated_tactic": ["exact <a>mt</a> (<a>monic</a> hx).<a>eq_one_of_isUnit</a> (<a>ne_one</a> A x)", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "minpoly.monic", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Basic.lean", "def_pos": [52, 9], "def_end_pos": [52, 14]}, {"full_name": "Polynomial.Monic.eq_one_of_isUnit", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [255, 9], "def_end_pos": [255, 31]}, {"full_name": "minpoly.ne_one", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Basic.lean", "def_pos": [95, 9], "def_end_pos": [95, 15]}]], "state_before": "case pos\nA : Type u_1\nB : Type u_2\nB' : Type u_3\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Ring B'\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra A B'\nx : B\ninst\u271d : Nontrivial B\nthis : Nontrivial A\nhx : IsIntegral A x\n\u22a2 \u00acIsUnit (minpoly A x)", "state_after": "no goals"}, {"tactic": "rw [eq_zero hx]", "annotated_tactic": ["rw [<a>eq_zero</a> hx]", [{"full_name": "minpoly.eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Basic.lean", "def_pos": [63, 9], "def_end_pos": [63, 16]}]], "state_before": "case neg\nA : Type u_1\nB : Type u_2\nB' : Type u_3\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Ring B'\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra A B'\nx : B\ninst\u271d : Nontrivial B\nthis : Nontrivial A\nhx : \u00acIsIntegral A x\n\u22a2 \u00acIsUnit (minpoly A x)", "state_after": "case neg\nA : Type u_1\nB : Type u_2\nB' : Type u_3\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Ring B'\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra A B'\nx : B\ninst\u271d : Nontrivial B\nthis : Nontrivial A\nhx : \u00acIsIntegral A x\n\u22a2 \u00acIsUnit 0"}, {"tactic": "exact not_isUnit_zero", "annotated_tactic": ["exact <a>not_isUnit_zero</a>", [{"full_name": "not_isUnit_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [74, 9], "def_end_pos": [74, 24]}]], "state_before": "case neg\nA : Type u_1\nB : Type u_2\nB' : Type u_3\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Ring B'\ninst\u271d\u00b2 : Algebra A B\ninst\u271d\u00b9 : Algebra A B'\nx : B\ninst\u271d : Nontrivial B\nthis : Nontrivial A\nhx : \u00acIsIntegral A x\n\u22a2 \u00acIsUnit 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.whiskerLeftIso_trans", "start": [354, 1], "end": [357, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Adjoin/Basic.lean", "full_name": "AlgHom.ext_of_adjoin_eq_top", "start": [447, 1], "end": [449, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Equiv.lean", "full_name": "RingEquiv.symm_trans_self", "start": [881, 1], "end": [882, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/FieldDivision.lean", "full_name": "Polynomial.coe_normUnit", "start": [197, 1], "end": [198, 18], "traced_tactics": [{"tactic": "simp [normUnit]", "annotated_tactic": ["simp [<a>normUnit</a>]", [{"full_name": "NormalizationMonoid.normUnit", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [75, 3], "def_end_pos": [75, 11]}]], "state_before": "R : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizationMonoid R\np : R[X]\n\u22a2 \u2191(normUnit p) = C \u2191(normUnit (leadingCoeff p))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/RatFunc.lean", "full_name": "RatFunc.ofFractionRing_neg", "start": [350, 1], "end": [351, 83], "traced_tactics": [{"tactic": "simp only [Neg.neg, RatFunc.neg]", "annotated_tactic": ["simp only [<a>Neg.neg</a>, <a>RatFunc.neg</a>]", [{"full_name": "Neg.neg", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1311, 3], "def_end_pos": [1311, 6]}, {"full_name": "RatFunc.neg", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [343, 27], "def_end_pos": [343, 30]}]], "state_before": "K : Type u\ninst\u271d : CommRing K\np : FractionRing K[X]\n\u22a2 { toFractionRing := -p } = -{ toFractionRing := p }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.coeff_C_mul", "start": [707, 1], "end": [711, 7], "traced_tactics": [{"tactic": "rw [mul_def, sum_C]", "annotated_tactic": ["rw [<a>mul_def</a>, <a>sum_C</a>]", [{"full_name": "MvPolynomial.mul_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [172, 9], "def_end_pos": [172, 16]}, {"full_name": "MvPolynomial.sum_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [370, 9], "def_end_pos": [370, 14]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nm : \u03c3 \u2192\u2080 \u2115\na : R\np : MvPolynomial \u03c3 R\n\u22a2 coeff m (C a * p) = a * coeff m p", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nm : \u03c3 \u2192\u2080 \u2115\na : R\np : MvPolynomial \u03c3 R\n\u22a2 coeff m (sum p fun n b => (monomial (0 + n)) (a * b)) = a * coeff m p\n\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nm : \u03c3 \u2192\u2080 \u2115\na : R\np : MvPolynomial \u03c3 R\n\u22a2 (sum p fun n b => (monomial (0 + n)) (0 * b)) = 0"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nm : \u03c3 \u2192\u2080 \u2115\na : R\np : MvPolynomial \u03c3 R\n\u22a2 (sum p fun n b => (monomial (0 + n)) (0 * b)) = 0", "state_after": "no goals"}, {"tactic": "simp (config := { contextual := true }) [sum_def, coeff_sum]", "annotated_tactic": ["simp (config := { contextual := <a>true</a> }) [<a>sum_def</a>, <a>coeff_sum</a>]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}, {"full_name": "MvPolynomial.sum_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [600, 9], "def_end_pos": [600, 16]}, {"full_name": "MvPolynomial.coeff_sum", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [648, 9], "def_end_pos": [648, 18]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nm : \u03c3 \u2192\u2080 \u2115\na : R\np : MvPolynomial \u03c3 R\n\u22a2 coeff m (sum p fun n b => (monomial (0 + n)) (a * b)) = a * coeff m p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Equiv.lean", "full_name": "MulEquiv.isDomain", "start": [897, 11], "end": [901, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units/Hom.lean", "full_name": "Units.liftRight_inv_mul", "start": [155, 1], "end": [157, 62], "traced_tactics": [{"tactic": "rw [Units.inv_mul_eq_iff_eq_mul, mul_one, coe_liftRight]", "annotated_tactic": ["rw [<a>Units.inv_mul_eq_iff_eq_mul</a>, <a>mul_one</a>, <a>coe_liftRight</a>]", [{"full_name": "Units.inv_mul_eq_iff_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [326, 9], "def_end_pos": [326, 30]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "Units.coe_liftRight", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units/Hom.lean", "def_pos": [142, 9], "def_end_pos": [142, 22]}]], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nP : Type w\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Monoid N\ninst\u271d : Monoid P\nf : M \u2192* N\ng : M \u2192 N\u02e3\nh : \u2200 (x : M), \u2191(g x) = f x\nx : M\n\u22a2 \u2191((liftRight f g h) x)\u207b\u00b9 * f x = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.rel_cons_left", "start": [2813, 1], "end": [2827, 63], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nas : Multiset \u03b1\nbs : Multiset \u03b2\n\u22a2 Rel r (a ::\u2098 as) bs \u2194 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'", "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nas : Multiset \u03b1\nbs : Multiset \u03b2\n\u22a2 Rel r (a ::\u2098 as) bs \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\n\ncase mpr\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nas : Multiset \u03b1\nbs : Multiset \u03b2\n\u22a2 (\u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs') \u2192 Rel r (a ::\u2098 as) bs"}, {"tactic": "generalize hm : a ::\u2098 as = m", "annotated_tactic": ["generalize hm : a ::\u2098 as = m", []], "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nas : Multiset \u03b1\nbs : Multiset \u03b2\n\u22a2 Rel r (a ::\u2098 as) bs \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'", "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nas : Multiset \u03b1\nbs : Multiset \u03b2\nm : Multiset \u03b1\nhm : a ::\u2098 as = m\n\u22a2 Rel r m bs \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nas : Multiset \u03b1\nbs : Multiset \u03b2\nm : Multiset \u03b1\nhm : a ::\u2098 as = m\n\u22a2 Rel r m bs \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'", "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nas : Multiset \u03b1\nbs : Multiset \u03b2\nm : Multiset \u03b1\nhm : a ::\u2098 as = m\nh : Rel r m bs\n\u22a2 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'"}, {"tactic": "simp at hm", "annotated_tactic": ["simp at hm", []], "state_before": "case mp.zero\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs : Multiset \u03b2\nm as : Multiset \u03b1\nhm : a ::\u2098 as = 0\n\u22a2 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 0 = b ::\u2098 bs'", "state_after": "no goals"}, {"tactic": "rcases cons_eq_cons.1 hm with (\u27e8eq\u2081, eq\u2082\u27e9 | \u27e8_h, cs, eq\u2081, eq\u2082\u27e9)", "annotated_tactic": ["rcases <a>cons_eq_cons</a>.1 hm with (\u27e8eq\u2081, eq\u2082\u27e9 | \u27e8_h, cs, eq\u2081, eq\u2082\u27e9)", [{"full_name": "Multiset.cons_eq_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [300, 9], "def_end_pos": [300, 21]}]], "state_before": "case mp.cons\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\na' : \u03b1\nb : \u03b2\nas' : Multiset \u03b1\nbs : Multiset \u03b2\nha'b : r a' b\nh : Rel r as' bs\nih : \u2200 {as : Multiset \u03b1}, a ::\u2098 as = as' \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\nas : Multiset \u03b1\nhm : a ::\u2098 as = a' ::\u2098 as'\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'", "state_after": "case mp.cons.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\na' : \u03b1\nb : \u03b2\nas' : Multiset \u03b1\nbs : Multiset \u03b2\nha'b : r a' b\nh : Rel r as' bs\nih : \u2200 {as : Multiset \u03b1}, a ::\u2098 as = as' \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\nas : Multiset \u03b1\nhm : a ::\u2098 as = a' ::\u2098 as'\neq\u2081 : a = a'\neq\u2082 : as = as'\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'\n\ncase mp.cons.inr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\na' : \u03b1\nb : \u03b2\nas' : Multiset \u03b1\nbs : Multiset \u03b2\nha'b : r a' b\nh : Rel r as' bs\nih : \u2200 {as : Multiset \u03b1}, a ::\u2098 as = as' \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\nas : Multiset \u03b1\nhm : a ::\u2098 as = a' ::\u2098 as'\n_h : a \u2260 a'\ncs : Multiset \u03b1\neq\u2081 : as = a' ::\u2098 cs\neq\u2082 : as' = a ::\u2098 cs\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'"}, {"tactic": "subst eq\u2081", "annotated_tactic": ["subst eq\u2081", []], "state_before": "case mp.cons.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\na' : \u03b1\nb : \u03b2\nas' : Multiset \u03b1\nbs : Multiset \u03b2\nha'b : r a' b\nh : Rel r as' bs\nih : \u2200 {as : Multiset \u03b1}, a ::\u2098 as = as' \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\nas : Multiset \u03b1\nhm : a ::\u2098 as = a' ::\u2098 as'\neq\u2081 : a = a'\neq\u2082 : as = as'\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'", "state_after": "case mp.cons.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\nb : \u03b2\nas' : Multiset \u03b1\nbs : Multiset \u03b2\nh : Rel r as' bs\nih : \u2200 {as : Multiset \u03b1}, a ::\u2098 as = as' \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\nas : Multiset \u03b1\neq\u2082 : as = as'\nha'b : r a b\nhm : a ::\u2098 as = a ::\u2098 as'\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'"}, {"tactic": "subst eq\u2082", "annotated_tactic": ["subst eq\u2082", []], "state_before": "case mp.cons.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\nb : \u03b2\nas' : Multiset \u03b1\nbs : Multiset \u03b2\nh : Rel r as' bs\nih : \u2200 {as : Multiset \u03b1}, a ::\u2098 as = as' \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\nas : Multiset \u03b1\neq\u2082 : as = as'\nha'b : r a b\nhm : a ::\u2098 as = a ::\u2098 as'\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'", "state_after": "case mp.cons.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\nb : \u03b2\nbs : Multiset \u03b2\nas : Multiset \u03b1\nha'b : r a b\nh : Rel r as bs\nih : \u2200 {as_1 : Multiset \u03b1}, a ::\u2098 as_1 = as \u2192 \u2203 b bs', r a b \u2227 Rel r as_1 bs' \u2227 bs = b ::\u2098 bs'\nhm : a ::\u2098 as = a ::\u2098 as\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'"}, {"tactic": "exact \u27e8b, bs, ha'b, h, rfl\u27e9", "annotated_tactic": ["exact \u27e8b, bs, ha'b, h, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case mp.cons.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\nb : \u03b2\nbs : Multiset \u03b2\nas : Multiset \u03b1\nha'b : r a b\nh : Rel r as bs\nih : \u2200 {as_1 : Multiset \u03b1}, a ::\u2098 as_1 = as \u2192 \u2203 b bs', r a b \u2227 Rel r as_1 bs' \u2227 bs = b ::\u2098 bs'\nhm : a ::\u2098 as = a ::\u2098 as\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'", "state_after": "no goals"}, {"tactic": "rcases ih eq\u2082.symm with \u27e8b', bs', h\u2081, h\u2082, eq\u27e9", "annotated_tactic": ["rcases ih eq\u2082.symm with \u27e8b', bs', h\u2081, h\u2082, eq\u27e9", []], "state_before": "case mp.cons.inr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\na' : \u03b1\nb : \u03b2\nas' : Multiset \u03b1\nbs : Multiset \u03b2\nha'b : r a' b\nh : Rel r as' bs\nih : \u2200 {as : Multiset \u03b1}, a ::\u2098 as = as' \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\nas : Multiset \u03b1\nhm : a ::\u2098 as = a' ::\u2098 as'\n_h : a \u2260 a'\ncs : Multiset \u03b1\neq\u2081 : as = a' ::\u2098 cs\neq\u2082 : as' = a ::\u2098 cs\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'", "state_after": "case mp.cons.inr.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\na' : \u03b1\nb : \u03b2\nas' : Multiset \u03b1\nbs : Multiset \u03b2\nha'b : r a' b\nh : Rel r as' bs\nih : \u2200 {as : Multiset \u03b1}, a ::\u2098 as = as' \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\nas : Multiset \u03b1\nhm : a ::\u2098 as = a' ::\u2098 as'\n_h : a \u2260 a'\ncs : Multiset \u03b1\neq\u2081 : as = a' ::\u2098 cs\neq\u2082 : as' = a ::\u2098 cs\nb' : \u03b2\nbs' : Multiset \u03b2\nh\u2081 : r a b'\nh\u2082 : Rel r cs bs'\neq : bs = b' ::\u2098 bs'\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'"}, {"tactic": "exact \u27e8b', b ::\u2098 bs', h\u2081, eq\u2081.symm \u25b8 Rel.cons ha'b h\u2082, eq.symm \u25b8 cons_swap _ _ _\u27e9", "annotated_tactic": ["exact \u27e8b', b ::\u2098 bs', h\u2081, eq\u2081.symm \u25b8 <a>Rel.cons</a> ha'b h\u2082, eq.symm \u25b8 <a>cons_swap</a> _ _ _\u27e9", [{"full_name": "Multiset.Rel.cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2752, 5], "def_end_pos": [2752, 9]}, {"full_name": "Multiset.cons_swap", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [171, 9], "def_end_pos": [171, 18]}]], "state_before": "case mp.cons.inr.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nbs\u271d : Multiset \u03b2\nm : Multiset \u03b1\na' : \u03b1\nb : \u03b2\nas' : Multiset \u03b1\nbs : Multiset \u03b2\nha'b : r a' b\nh : Rel r as' bs\nih : \u2200 {as : Multiset \u03b1}, a ::\u2098 as = as' \u2192 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'\nas : Multiset \u03b1\nhm : a ::\u2098 as = a' ::\u2098 as'\n_h : a \u2260 a'\ncs : Multiset \u03b1\neq\u2081 : as = a' ::\u2098 cs\neq\u2082 : as' = a ::\u2098 cs\nb' : \u03b2\nbs' : Multiset \u03b2\nh\u2081 : r a b'\nh\u2082 : Rel r cs bs'\neq : bs = b' ::\u2098 bs'\n\u22a2 \u2203 b_1 bs', r a b_1 \u2227 Rel r as bs' \u2227 b ::\u2098 bs = b_1 ::\u2098 bs'", "state_after": "no goals"}, {"tactic": "exact fun \u27e8b, bs', hab, h, Eq\u27e9 => Eq.symm \u25b8 Rel.cons hab h", "annotated_tactic": ["exact fun \u27e8b, bs', hab, h, Eq\u27e9 => Eq.symm \u25b8 <a>Rel.cons</a> hab h", [{"full_name": "Multiset.Rel.cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2752, 5], "def_end_pos": [2752, 9]}]], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\na : \u03b1\nas : Multiset \u03b1\nbs : Multiset \u03b2\n\u22a2 (\u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs') \u2192 Rel r (a ::\u2098 as) bs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/TensorProduct/Basic.lean", "full_name": "Algebra.TensorProduct.intCast_def'", "start": [537, 1], "end": [538, 54], "traced_tactics": [{"tactic": "rw [intCast_def, \u2190 zsmul_one, smul_tmul, zsmul_one]", "annotated_tactic": ["rw [<a>intCast_def</a>, \u2190 <a>zsmul_one</a>, <a>smul_tmul</a>, <a>zsmul_one</a>]", [{"full_name": "Algebra.TensorProduct.intCast_def", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/TensorProduct/Basic.lean", "def_pos": [465, 9], "def_end_pos": [465, 20]}, {"full_name": "zsmul_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [334, 15], "def_end_pos": [334, 24]}, {"full_name": "TensorProduct.smul_tmul", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/TensorProduct/Basic.lean", "def_pos": [249, 9], "def_end_pos": [249, 18]}, {"full_name": "zsmul_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [334, 15], "def_end_pos": [334, 24]}]], "state_before": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\nE : Type uE\nF : Type uF\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra R B\nz : \u2124\n\u22a2 \u2191z = 1 \u2297\u209c[R] \u2191z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "full_name": "NonUnitalSubring.coe_eq_zero_iff", "start": [328, 1], "end": [329, 7], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : NonUnitalNonAssocRing R\ninst\u271d\u00b9 : NonUnitalNonAssocRing S\ninst\u271d : NonUnitalNonAssocRing T\ns : NonUnitalSubring R\nx : \u21a5s\n\u22a2 \u2191x = 0 \u2194 x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.not_isUnit_of_degree_pos", "start": [242, 1], "end": [247, 43], "traced_tactics": [{"tactic": "cases subsingleton_or_nontrivial R", "annotated_tactic": ["cases <a>subsingleton_or_nontrivial</a> R", [{"full_name": "subsingleton_or_nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [99, 9], "def_end_pos": [99, 35]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q p : R[X]\nhpl : 0 < degree p\n\u22a2 \u00acIsUnit p", "state_after": "case inl\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q p : R[X]\nhpl : 0 < degree p\nh\u271d : Subsingleton R\n\u22a2 \u00acIsUnit p\n\ncase inr\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q p : R[X]\nhpl : 0 < degree p\nh\u271d : Nontrivial R\n\u22a2 \u00acIsUnit p"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case inr\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q p : R[X]\nhpl : 0 < degree p\nh\u271d : Nontrivial R\n\u22a2 \u00acIsUnit p", "state_after": "case inr\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q p : R[X]\nhpl : 0 < degree p\nh\u271d : Nontrivial R\nh : IsUnit p\n\u22a2 False"}, {"tactic": "simp [degree_eq_zero_of_isUnit h] at hpl", "annotated_tactic": ["simp [<a>degree_eq_zero_of_isUnit</a> h] at hpl", [{"full_name": "Polynomial.degree_eq_zero_of_isUnit", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [222, 9], "def_end_pos": [222, 33]}]], "state_before": "case inr\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q p : R[X]\nhpl : 0 < degree p\nh\u271d : Nontrivial R\nh : IsUnit p\n\u22a2 False", "state_after": "no goals"}, {"tactic": "simp [Subsingleton.elim p 0] at hpl", "annotated_tactic": ["simp [<a>Subsingleton.elim</a> p 0] at hpl", [{"full_name": "Subsingleton.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1010, 19], "def_end_pos": [1010, 36]}]], "state_before": "case inl\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q p : R[X]\nhpl : 0 < degree p\nh\u271d : Subsingleton R\n\u22a2 \u00acIsUnit p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.brange_bfamilyOfFamily", "start": [1209, 1], "end": [1210, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.eval\u2082_add", "start": [89, 1], "end": [91, 41], "traced_tactics": [{"tactic": "simp only [eval\u2082_eq_sum]", "annotated_tactic": ["simp only [<a>eval\u2082_eq_sum</a>]", [{"full_name": "Polynomial.eval\u2082_eq_sum", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [48, 9], "def_end_pos": [48, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q r : R[X]\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 eval\u2082 f x (p + q) = eval\u2082 f x p + eval\u2082 f x q", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q r : R[X]\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 (sum (p + q) fun e a => f a * x ^ e) = (sum p fun e a => f a * x ^ e) + sum q fun e a => f a * x ^ e"}, {"tactic": "apply sum_add_index <;> simp [add_mul]", "annotated_tactic": ["apply <a>sum_add_index</a> <;> simp [<a>add_mul</a>]", [{"full_name": "Polynomial.sum_add_index", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1021, 9], "def_end_pos": [1021, 22]}, {"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q r : R[X]\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 (sum (p + q) fun e a => f a * x ^ e) = (sum p fun e a => f a * x ^ e) + sum q fun e a => f a * x ^ e", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "card_finset_fin_le", "start": [339, 1], "end": [340, 53], "traced_tactics": [{"tactic": "simpa only [Fintype.card_fin] using s.card_le_univ", "annotated_tactic": ["simpa only [<a>Fintype.card_fin</a>] using s.card_le_univ", [{"full_name": "Fintype.card_fin", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [308, 9], "def_end_pos": [308, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\ns : Finset (Fin n)\n\u22a2 s.card \u2264 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Nat.cast_list_prod", "start": [2504, 1], "end": [2505, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean", "full_name": "padicValNat_dvd_iff_le", "start": [564, 1], "end": [566, 100], "traced_tactics": [{"tactic": "rw [pow_dvd_iff_le_multiplicity, \u2190 padicValNat_def' hp.out.ne_one ha.bot_lt, PartENat.coe_le_coe]", "annotated_tactic": ["rw [<a>pow_dvd_iff_le_multiplicity</a>, \u2190 <a>padicValNat_def'</a> hp.out.ne_one ha.bot_lt, <a>PartENat.coe_le_coe</a>]", [{"full_name": "multiplicity.pow_dvd_iff_le_multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [148, 9], "def_end_pos": [148, 36]}, {"full_name": "padicValNat_def'", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [284, 9], "def_end_pos": [284, 25]}, {"full_name": "PartENat.coe_le_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [310, 9], "def_end_pos": [310, 19]}]], "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\na n : \u2115\nha : a \u2260 0\n\u22a2 p ^ n \u2223 a \u2194 n \u2264 padicValNat p a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Basic.lean", "full_name": "isOpen_iff_ball_subset", "start": [738, 1], "end": [739, 75], "traced_tactics": [{"tactic": "simp_rw [isOpen_iff_mem_nhds, nhds_eq_comap_uniformity, mem_comap, ball]", "annotated_tactic": ["simp_rw [<a>isOpen_iff_mem_nhds</a>, <a>nhds_eq_comap_uniformity</a>, <a>mem_comap</a>, <a>ball</a>]", [{"full_name": "isOpen_iff_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1183, 9], "def_end_pos": [1183, 28]}, {"full_name": "nhds_eq_comap_uniformity", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [724, 9], "def_end_pos": [724, 33]}, {"full_name": "Filter.mem_comap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2219, 17], "def_end_pos": [2219, 26]}, {"full_name": "UniformSpace.ball", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [622, 5], "def_end_pos": [622, 22]}]], "state_before": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\n\u03b4 : Type ud\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\ns : Set \u03b1\n\u22a2 IsOpen s \u2194 \u2200 x \u2208 s, \u2203 V \u2208 \ud835\udce4 \u03b1, ball x V \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bornology/Basic.lean", "full_name": "Bornology.isBounded_sUnion", "start": [294, 1], "end": [295, 95], "traced_tactics": [{"tactic": "rw [sUnion_eq_biUnion, isBounded_biUnion hs]", "annotated_tactic": ["rw [<a>sUnion_eq_biUnion</a>, <a>isBounded_biUnion</a> hs]", [{"full_name": "Set.sUnion_eq_biUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1316, 9], "def_end_pos": [1316, 26]}, {"full_name": "Bornology.isBounded_biUnion", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bornology/Basic.lean", "def_pos": [284, 9], "def_end_pos": [284, 26]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ns : Set \u03b1\ninst\u271d : Bornology \u03b1\nS : Set (Set \u03b1)\nhs : Set.Finite S\n\u22a2 IsBounded (\u22c3\u2080 S) \u2194 \u2200 s \u2208 S, IsBounded s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Topology.lean", "full_name": "Convex.add_smul_mem_interior'", "start": [230, 1], "end": [232, 76], "traced_tactics": [{"tactic": "simpa only [add_sub_cancel'] using hs.add_smul_sub_mem_interior' hx hy ht", "annotated_tactic": ["simpa only [<a>add_sub_cancel'</a>] using hs.add_smul_sub_mem_interior' hx hy ht", [{"full_name": "add_sub_cancel'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1026, 30], "def_end_pos": [1026, 45]}]], "state_before": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u2075 : LinearOrderedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : TopologicalAddGroup E\ninst\u271d : ContinuousConstSMul \ud835\udd5c E\ns : Set E\nhs : Convex \ud835\udd5c s\nx y : E\nhx : x \u2208 closure s\nhy : x + y \u2208 interior s\nt : \ud835\udd5c\nht : t \u2208 Ioc 0 1\n\u22a2 x + t \u2022 y \u2208 interior s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.RightInverse.injective", "start": [371, 1], "end": [372, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Basic.lean", "full_name": "CauSeq.Completion.ofRat_rat", "start": [47, 1], "end": [49, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Sqrt.lean", "full_name": "Nat.le_three_of_sqrt_eq_one", "start": [127, 1], "end": [128, 57], "traced_tactics": [{"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "n : \u2115\nh : sqrt n = 1\n\u22a2 sqrt n < 2", "state_after": "n : \u2115\nh : sqrt n = 1\n\u22a2 1 < 2"}, {"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "n : \u2115\nh : sqrt n = 1\n\u22a2 1 < 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial", "start": [808, 1], "end": [812, 70], "traced_tactics": [{"tactic": "rcases s.eq_empty_or_nonempty with hs | hs", "annotated_tactic": ["rcases s.eq_empty_or_nonempty with hs | hs", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns : Set P\ninst\u271d : Nontrivial P\n\u22a2 affineSpan k s = \u22a4 \u2194 vectorSpan k s = \u22a4", "state_after": "case inl\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns : Set P\ninst\u271d : Nontrivial P\nhs : s = \u2205\n\u22a2 affineSpan k s = \u22a4 \u2194 vectorSpan k s = \u22a4\n\ncase inr\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns : Set P\ninst\u271d : Nontrivial P\nhs : Set.Nonempty s\n\u22a2 affineSpan k s = \u22a4 \u2194 vectorSpan k s = \u22a4"}, {"tactic": "simp [hs, subsingleton_iff_bot_eq_top, AddTorsor.subsingleton_iff V P, not_subsingleton]", "annotated_tactic": ["simp [hs, <a>subsingleton_iff_bot_eq_top</a>, <a>AddTorsor.subsingleton_iff</a> V P, <a>not_subsingleton</a>]", [{"full_name": "subsingleton_iff_bot_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [655, 9], "def_end_pos": [655, 36]}, {"full_name": "AddTorsor.subsingleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [487, 9], "def_end_pos": [487, 35]}, {"full_name": "not_subsingleton", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [91, 9], "def_end_pos": [91, 25]}]], "state_before": "case inl\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns : Set P\ninst\u271d : Nontrivial P\nhs : s = \u2205\n\u22a2 affineSpan k s = \u22a4 \u2194 vectorSpan k s = \u22a4", "state_after": "no goals"}, {"tactic": "rw [affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty k V P hs]", "annotated_tactic": ["rw [<a>affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty</a> k V P hs]", [{"full_name": "AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [796, 9], "def_end_pos": [796, 60]}]], "state_before": "case inr\nk : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\nS : AffineSpace V P\np\u2081 p\u2082 : P\ns : Set P\ninst\u271d : Nontrivial P\nhs : Set.Nonempty s\n\u22a2 affineSpan k s = \u22a4 \u2194 vectorSpan k s = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.comap_eq_top_iff", "start": [1545, 1], "end": [1547, 35], "traced_tactics": [{"tactic": "rw [h, comap_top]", "annotated_tactic": ["rw [h, <a>comap_top</a>]", [{"full_name": "Ideal.comap_top", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [1540, 9], "def_end_pos": [1540, 18]}]], "state_before": "R : Type u\nS : Type v\nF : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : FunLike F R S\nrc : RingHomClass F R S\nf : F\nI\u271d J : Ideal R\nK L : Ideal S\nG : Type u_2\ninst\u271d : FunLike G S R\nrcg : RingHomClass G S R\nI : Ideal S\nh : I = \u22a4\n\u22a2 comap f I = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousFunction/Basic.lean", "full_name": "ContinuousMap.coe_restrict", "start": [412, 1], "end": [413, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.setValue_eq", "start": [1765, 1], "end": [1766, 35], "traced_tactics": [{"tactic": "simp [setValue, swap_apply_left]", "annotated_tactic": ["simp [<a>setValue</a>, <a>swap_apply_left</a>]", [{"full_name": "Equiv.setValue", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [1760, 5], "def_end_pos": [1760, 13]}, {"full_name": "Equiv.swap_apply_left", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [1637, 9], "def_end_pos": [1637, 24]}]], "state_before": "\u03b1 : Sort u_2\ninst\u271d : DecidableEq \u03b1\n\u03b2 : Sort u_1\nf : \u03b1 \u2243 \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 (setValue f a b) a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.toSubmonoid_mono", "start": [460, 1], "end": [461, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/Subalgebra.lean", "full_name": "StarSubalgebra.mul_mem_sup", "start": [646, 1], "end": [648, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/AddCircle.lean", "full_name": "AddCircle.norm_half_period_eq", "start": [136, 1], "end": [139, 78], "traced_tactics": [{"tactic": "rcases eq_or_ne p 0 with (rfl | hp)", "annotated_tactic": ["rcases <a>eq_or_ne</a> p 0 with (rfl | hp)", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "p : \u211d\n\u22a2 \u2016\u2191(p / 2)\u2016 = |p| / 2", "state_after": "case inl\n\n\u22a2 \u2016\u2191(0 / 2)\u2016 = |0| / 2\n\ncase inr\np : \u211d\nhp : p \u2260 0\n\u22a2 \u2016\u2191(p / 2)\u2016 = |p| / 2"}, {"tactic": "rw [norm_eq, \u2190 mul_div_assoc, inv_mul_cancel hp, one_div, round_two_inv, Int.cast_one,\n  one_mul, (by linarith : p / 2 - p = -(p / 2)), abs_neg, abs_div, abs_two]", "annotated_tactic": ["rw [<a>norm_eq</a>, \u2190 <a>mul_div_assoc</a>, <a>inv_mul_cancel</a> hp, <a>one_div</a>, <a>round_two_inv</a>, <a>Int.cast_one</a>,\n    <a>one_mul</a>, (by linarith : p / 2 - p = -(p / 2)), <a>abs_neg</a>, <a>abs_div</a>, <a>abs_two</a>]", [{"full_name": "AddCircle.norm_eq", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/AddCircle.lean", "def_pos": [86, 9], "def_end_pos": [86, 16]}, {"full_name": "mul_div_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [374, 9], "def_end_pos": [374, 22]}, {"full_name": "inv_mul_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NeZero.lean", "def_pos": [53, 9], "def_end_pos": [53, 23]}, {"full_name": "one_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [386, 9], "def_end_pos": [386, 16]}, {"full_name": "round_two_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [1576, 9], "def_end_pos": [1576, 22]}, {"full_name": "Int.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [78, 9], "def_end_pos": [78, 17]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "abs_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [86, 3], "def_end_pos": [86, 14]}, {"full_name": "abs_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [1079, 9], "def_end_pos": [1079, 16]}, {"full_name": "abs_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Abs.lean", "def_pos": [40, 7], "def_end_pos": [40, 14]}]], "state_before": "case inr\np : \u211d\nhp : p \u2260 0\n\u22a2 \u2016\u2191(p / 2)\u2016 = |p| / 2", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inl\n\n\u22a2 \u2016\u2191(0 / 2)\u2016 = |0| / 2", "state_after": "no goals"}, {"tactic": "linarith", "annotated_tactic": ["linarith", []], "state_before": "p : \u211d\nhp : p \u2260 0\n\u22a2 p / 2 - p = -(p / 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "isBot_iff_eq_bot", "start": [304, 1], "end": [305, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Basic.lean", "full_name": "ENNReal.sup_eq_max", "start": [627, 9], "end": [627, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "full_name": "Collinear.coplanar_insert", "start": [792, 1], "end": [796, 93], "traced_tactics": [{"tactic": "have : FiniteDimensional k { x // x \u2208 vectorSpan k s } := h.finiteDimensional_vectorSpan", "annotated_tactic": ["have : <a>FiniteDimensional</a> k { x // x \u2208 <a>vectorSpan</a> k s } := h.finiteDimensional_vectorSpan", [{"full_name": "FiniteDimensional", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FiniteDimensional.lean", "def_pos": [79, 5], "def_end_pos": [79, 22]}, {"full_name": "vectorSpan", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [60, 5], "def_end_pos": [60, 15]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\nh : Collinear k s\np : P\n\u22a2 Coplanar k (insert p s)", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\nh : Collinear k s\np : P\nthis : FiniteDimensional k \u21a5(vectorSpan k s)\n\u22a2 Coplanar k (insert p s)"}, {"tactic": "rw [coplanar_iff_finrank_le_two]", "annotated_tactic": ["rw [<a>coplanar_iff_finrank_le_two</a>]", [{"full_name": "coplanar_iff_finrank_le_two", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "def_pos": [689, 9], "def_end_pos": [689, 36]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\nh : Collinear k s\np : P\nthis : FiniteDimensional k \u21a5(vectorSpan k s)\n\u22a2 Coplanar k (insert p s)", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\nh : Collinear k s\np : P\nthis : FiniteDimensional k \u21a5(vectorSpan k s)\n\u22a2 finrank k \u21a5(vectorSpan k (insert p s)) \u2264 2"}, {"tactic": "exact (finrank_vectorSpan_insert_le_set k s p).trans (add_le_add_right h.finrank_le_one _)", "annotated_tactic": ["exact (<a>finrank_vectorSpan_insert_le_set</a> k s p).<a>trans</a> (<a>add_le_add_right</a> h.finrank_le_one _)", [{"full_name": "finrank_vectorSpan_insert_le_set", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "def_pos": [782, 9], "def_end_pos": [782, 41]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "add_le_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [66, 32], "def_end_pos": [66, 48]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\ns : Set P\nh : Collinear k s\np : P\nthis : FiniteDimensional k \u21a5(vectorSpan k s)\n\u22a2 finrank k \u21a5(vectorSpan k (insert p s)) \u2264 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/ModEq.lean", "full_name": "Nat.ModEq.cancel_left_div_gcd", "start": [282, 1], "end": [296, 47], "traced_tactics": [{"tactic": "let d := gcd m c", "annotated_tactic": ["let d := <a>gcd</a> m c", [{"full_name": "Nat.gcd", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [12, 5], "def_end_pos": [12, 8]}]], "state_before": "m n a b c d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\n\u22a2 a \u2261 b [MOD m / gcd m c]", "state_after": "m n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\n\u22a2 a \u2261 b [MOD m / gcd m c]"}, {"tactic": "have hmd := gcd_dvd_left m c", "annotated_tactic": ["have hmd := <a>gcd_dvd_left</a> m c", [{"full_name": "Nat.gcd_dvd_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [59, 9], "def_end_pos": [59, 21]}]], "state_before": "m n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\n\u22a2 a \u2261 b [MOD m / gcd m c]", "state_after": "m n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\n\u22a2 a \u2261 b [MOD m / gcd m c]"}, {"tactic": "have hcd := gcd_dvd_right m c", "annotated_tactic": ["have hcd := <a>gcd_dvd_right</a> m c", [{"full_name": "Nat.gcd_dvd_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [61, 9], "def_end_pos": [61, 22]}]], "state_before": "m n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\n\u22a2 a \u2261 b [MOD m / gcd m c]", "state_after": "m n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 a \u2261 b [MOD m / gcd m c]"}, {"tactic": "rw [modEq_iff_dvd]", "annotated_tactic": ["rw [<a>modEq_iff_dvd</a>]", [{"full_name": "Nat.modEq_iff_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/ModEq.lean", "def_pos": [89, 9], "def_end_pos": [89, 22]}]], "state_before": "m n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 a \u2261 b [MOD m / gcd m c]", "state_after": "m n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191(m / gcd m c) \u2223 \u2191b - \u2191a"}, {"tactic": "refine' @Int.dvd_of_dvd_mul_right_of_gcd_one (m / d) (c / d) (b - a) _ _", "annotated_tactic": ["refine' @<a>Int.dvd_of_dvd_mul_right_of_gcd_one</a> (m / d) (c / d) (b - a) _ _", [{"full_name": "Int.dvd_of_dvd_mul_right_of_gcd_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/GCD.lean", "def_pos": [404, 9], "def_end_pos": [404, 40]}]], "state_before": "m n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191(m / gcd m c) \u2223 \u2191b - \u2191a", "state_after": "case refine'_1\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191m / \u2191d \u2223 \u2191c / \u2191d * (\u2191b - \u2191a)\n\ncase refine'_2\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 Int.gcd (\u2191m / \u2191d) (\u2191c / \u2191d) = 1"}, {"tactic": "rw [mul_comm, \u2190 Int.mul_ediv_assoc (b - a) (Int.coe_nat_dvd.mpr hcd), mul_comm]", "annotated_tactic": ["rw [<a>mul_comm</a>, \u2190 <a>Int.mul_ediv_assoc</a> (b - a) (Int.coe_nat_dvd.mpr hcd), <a>mul_comm</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Int.mul_ediv_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean", "def_pos": [310, 19], "def_end_pos": [310, 33]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "case refine'_1\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191m / \u2191d \u2223 \u2191c / \u2191d * (\u2191b - \u2191a)", "state_after": "case refine'_1\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191m / \u2191d \u2223 \u2191c * (\u2191b - \u2191a) / \u2191(gcd m c)"}, {"tactic": "apply Int.ediv_dvd_ediv (Int.coe_nat_dvd.mpr hmd)", "annotated_tactic": ["apply <a>Int.ediv_dvd_ediv</a> (Int.coe_nat_dvd.mpr hmd)", [{"full_name": "Int.ediv_dvd_ediv", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Order/Basic.lean", "def_pos": [381, 9], "def_end_pos": [381, 22]}]], "state_before": "case refine'_1\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191m / \u2191d \u2223 \u2191c * (\u2191b - \u2191a) / \u2191(gcd m c)", "state_after": "case refine'_1\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191m \u2223 \u2191c * (\u2191b - \u2191a)"}, {"tactic": "rw [mul_sub]", "annotated_tactic": ["rw [<a>mul_sub</a>]", [{"full_name": "mul_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [382, 7], "def_end_pos": [382, 14]}]], "state_before": "case refine'_1\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191m \u2223 \u2191c * (\u2191b - \u2191a)", "state_after": "case refine'_1\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191m \u2223 \u2191c * \u2191b - \u2191c * \u2191a"}, {"tactic": "exact modEq_iff_dvd.mp h", "annotated_tactic": ["exact modEq_iff_dvd.mp h", []], "state_before": "case refine'_1\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 \u2191m \u2223 \u2191c * \u2191b - \u2191c * \u2191a", "state_after": "no goals"}, {"tactic": "simp only [\u2190 Int.coe_nat_div, Int.coe_nat_gcd (m / d) (c / d), gcd_div hmd hcd,\n  Nat.div_self (gcd_pos_of_pos_left c hm)]", "annotated_tactic": ["simp only [\u2190 <a>Int.coe_nat_div</a>, <a>Int.coe_nat_gcd</a> (m / d) (c / d), <a>gcd_div</a> hmd hcd,\n      <a>Nat.div_self</a> (<a>gcd_pos_of_pos_left</a> c hm)]", [{"full_name": "Int.coe_nat_div", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Defs.lean", "def_pos": [170, 26], "def_end_pos": [170, 37]}, {"full_name": "Int.coe_nat_gcd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/GCD.lean", "def_pos": [186, 19], "def_end_pos": [186, 30]}, {"full_name": "Nat.gcd_div", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}, {"full_name": "Nat.div_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [639, 19], "def_end_pos": [639, 27]}, {"full_name": "Nat.gcd_pos_of_pos_left", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [57, 9], "def_end_pos": [57, 28]}]], "state_before": "case refine'_2\nm n a b c d\u271d : \u2115\nhm : 0 < m\nh : c * a \u2261 c * b [MOD m]\nd : \u2115 := gcd m c\nhmd : gcd m c \u2223 m\nhcd : gcd m c \u2223 c\n\u22a2 Int.gcd (\u2191m / \u2191d) (\u2191c / \u2191d) = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "full_name": "smul_mul_assoc", "start": [430, 1], "end": [432, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean", "full_name": "Nat.factorization_prime_le_iff_dvd", "start": [422, 1], "end": [427, 6], "traced_tactics": [{"tactic": "rw [\u2190 factorization_le_iff_dvd hd hn]", "annotated_tactic": ["rw [\u2190 <a>factorization_le_iff_dvd</a> hd hn]", [{"full_name": "Nat.factorization_le_iff_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean", "def_pos": [409, 9], "def_end_pos": [409, 33]}]], "state_before": "a b m n\u271d p d n : \u2115\nhd : d \u2260 0\nhn : n \u2260 0\n\u22a2 (\u2200 (p : \u2115), Prime p \u2192 (factorization d) p \u2264 (factorization n) p) \u2194 d \u2223 n", "state_after": "a b m n\u271d p d n : \u2115\nhd : d \u2260 0\nhn : n \u2260 0\n\u22a2 (\u2200 (p : \u2115), Prime p \u2192 (factorization d) p \u2264 (factorization n) p) \u2194 factorization d \u2264 factorization n"}, {"tactic": "refine' \u27e8fun h p => (em p.Prime).elim (h p) fun hp => _, fun h p _ => h p\u27e9", "annotated_tactic": ["refine' \u27e8fun h p => (<a>em</a> p.Prime).<a>elim</a> (h p) fun hp => _, fun h p _ => h p\u27e9", [{"full_name": "em", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [193, 7], "def_end_pos": [193, 9]}, {"full_name": "Or.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [546, 9], "def_end_pos": [546, 16]}]], "state_before": "a b m n\u271d p d n : \u2115\nhd : d \u2260 0\nhn : n \u2260 0\n\u22a2 (\u2200 (p : \u2115), Prime p \u2192 (factorization d) p \u2264 (factorization n) p) \u2194 factorization d \u2264 factorization n", "state_after": "a b m n\u271d p\u271d d n : \u2115\nhd : d \u2260 0\nhn : n \u2260 0\nh : \u2200 (p : \u2115), Prime p \u2192 (factorization d) p \u2264 (factorization n) p\np : \u2115\nhp : \u00acPrime p\n\u22a2 (factorization d) p \u2264 (factorization n) p"}, {"tactic": "simp_rw [factorization_eq_zero_of_non_prime _ hp]", "annotated_tactic": ["simp_rw [<a>factorization_eq_zero_of_non_prime</a> _ hp]", [{"full_name": "Nat.factorization_eq_zero_of_non_prime", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorization/Basic.lean", "def_pos": [139, 9], "def_end_pos": [139, 43]}]], "state_before": "a b m n\u271d p\u271d d n : \u2115\nhd : d \u2260 0\nhn : n \u2260 0\nh : \u2200 (p : \u2115), Prime p \u2192 (factorization d) p \u2264 (factorization n) p\np : \u2115\nhp : \u00acPrime p\n\u22a2 (factorization d) p \u2264 (factorization n) p", "state_after": "a b m n\u271d p\u271d d n : \u2115\nhd : d \u2260 0\nhn : n \u2260 0\nh : \u2200 (p : \u2115), Prime p \u2192 (factorization d) p \u2264 (factorization n) p\np : \u2115\nhp : \u00acPrime p\n\u22a2 0 \u2264 0"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "a b m n\u271d p\u271d d n : \u2115\nhd : d \u2260 0\nhn : n \u2260 0\nh : \u2200 (p : \u2115), Prime p \u2192 (factorization d) p \u2264 (factorization n) p\np : \u2115\nhp : \u00acPrime p\n\u22a2 0 \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/ENat.lean", "full_name": "Cardinal.toENatAux_zero", "start": [157, 1], "end": [157, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "not_and_not_right", "start": [469, 1], "end": [469, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Int.gcd_def", "start": [184, 1], "end": [184, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.continuous_mul_const", "start": [422, 11], "end": [423, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "Continuous.fst'", "start": [342, 1], "end": [343, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Induction.lean", "full_name": "Polynomial.induction_on'", "start": [63, 11], "end": [66, 58], "traced_tactics": [{"tactic": "rw [C_mul_X_pow_eq_monomial]", "annotated_tactic": ["rw [<a>C_mul_X_pow_eq_monomial</a>]", [{"full_name": "Polynomial.C_mul_X_pow_eq_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [774, 9], "def_end_pos": [774, 32]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type x\nk : Type y\nA : Type z\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np\u271d q r : R[X]\nM : R[X] \u2192 Prop\np : R[X]\nh_add : \u2200 (p q : R[X]), M p \u2192 M q \u2192 M (p + q)\nh_monomial : \u2200 (n : \u2115) (a : R), M ((monomial n) a)\nn : \u2115\na : R\n_h : M (C a * X ^ n)\n\u22a2 M (C a * X ^ (n + 1))", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type x\nk : Type y\nA : Type z\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np\u271d q r : R[X]\nM : R[X] \u2192 Prop\np : R[X]\nh_add : \u2200 (p q : R[X]), M p \u2192 M q \u2192 M (p + q)\nh_monomial : \u2200 (n : \u2115) (a : R), M ((monomial n) a)\nn : \u2115\na : R\n_h : M (C a * X ^ n)\n\u22a2 M ((monomial (n + 1)) a)"}, {"tactic": "exact h_monomial _ _", "annotated_tactic": ["exact h_monomial _ _", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type x\nk : Type y\nA : Type z\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np\u271d q r : R[X]\nM : R[X] \u2192 Prop\np : R[X]\nh_add : \u2200 (p q : R[X]), M p \u2192 M q \u2192 M (p + q)\nh_monomial : \u2200 (n : \u2115) (a : R), M ((monomial n) a)\nn : \u2115\na : R\n_h : M (C a * X ^ n)\n\u22a2 M ((monomial (n + 1)) a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/PathConnected.lean", "full_name": "JoinedIn.symm", "start": [870, 1], "end": [873, 15], "traced_tactics": [{"tactic": "cases' h.mem with hx hy", "annotated_tactic": ["cases' h.mem with hx hy", []], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\nF : Set X\nh : JoinedIn F x y\n\u22a2 JoinedIn F y x", "state_after": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\nF : Set X\nh : JoinedIn F x y\nhx : x \u2208 F\nhy : y \u2208 F\n\u22a2 JoinedIn F y x"}, {"tactic": "simp_all [joinedIn_iff_joined]", "annotated_tactic": ["simp_all [<a>joinedIn_iff_joined</a>]", [{"full_name": "joinedIn_iff_joined", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/PathConnected.lean", "def_pos": [851, 9], "def_end_pos": [851, 28]}]], "state_before": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\nF : Set X\nh : JoinedIn F x y\nhx : x \u2208 F\nhy : y \u2208 F\n\u22a2 JoinedIn F y x", "state_after": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\nF : Set X\nhx\u271d : x \u2208 F\nhy\u271d : y \u2208 F\nh : Joined { val := x, property := \u22ef } { val := y, property := \u22ef }\nhx : x \u2208 F\nhy : y \u2208 F\n\u22a2 Joined { val := y, property := \u22ef } { val := x, property := \u22ef }"}, {"tactic": "exact h.symm", "annotated_tactic": ["exact h.symm", []], "state_before": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\nF : Set X\nhx\u271d : x \u2208 F\nhy\u271d : y \u2208 F\nh : Joined { val := x, property := \u22ef } { val := y, property := \u22ef }\nhx : x \u2208 F\nhy : y \u2208 F\n\u22a2 Joined { val := y, property := \u22ef } { val := x, property := \u22ef }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.finite_option", "start": [1127, 1], "end": [1130, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.im_le_norm", "start": [772, 1], "end": [773, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "full_name": "star\u2097\u1d62_toContinuousLinearEquiv", "start": [303, 1], "end": [305, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Basic.lean", "full_name": "IsLocalization.map_eq_zero_iff", "start": [232, 1], "end": [239, 24], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\n\u22a2 (algebraMap R S) r = 0 \u2194 \u2203 m, \u2191m * r = 0", "state_after": "case mp\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\n\u22a2 (algebraMap R S) r = 0 \u2192 \u2203 m, \u2191m * r = 0\n\ncase mpr\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\n\u22a2 (\u2203 m, \u2191m * r = 0) \u2192 (algebraMap R S) r = 0"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mp\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\n\u22a2 (algebraMap R S) r = 0 \u2192 \u2203 m, \u2191m * r = 0\n\ncase mpr\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\n\u22a2 (\u2203 m, \u2191m * r = 0) \u2192 (algebraMap R S) r = 0", "state_after": "case mp\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\nh : (algebraMap R S) r = 0\n\u22a2 \u2203 m, \u2191m * r = 0\n\ncase mpr\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\n\u22a2 (\u2203 m, \u2191m * r = 0) \u2192 (algebraMap R S) r = 0"}, {"tactic": "obtain \u27e8m, hm\u27e9 := (IsLocalization.eq_iff_exists M S).mp ((algebraMap R S).map_zero.trans h.symm)", "annotated_tactic": ["obtain \u27e8m, hm\u27e9 := (<a>IsLocalization.eq_iff_exists</a> M S).<a>mp</a> ((<a>algebraMap</a> R S).map_zero.trans h.symm)", [{"full_name": "IsLocalization.eq_iff_exists", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [130, 9], "def_end_pos": [130, 22]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}]], "state_before": "case mp\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\nh : (algebraMap R S) r = 0\n\u22a2 \u2203 m, \u2191m * r = 0", "state_after": "case mp.intro\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\nh : (algebraMap R S) r = 0\nm : \u21a5M\nhm : \u2191m * 0 = \u2191m * r\n\u22a2 \u2203 m, \u2191m * r = 0"}, {"tactic": "exact \u27e8m, by simpa using hm.symm\u27e9", "annotated_tactic": ["exact \u27e8m, by simpa using hm.symm\u27e9", []], "state_before": "case mp.intro\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\nh : (algebraMap R S) r = 0\nm : \u21a5M\nhm : \u2191m * 0 = \u2191m * r\n\u22a2 \u2203 m, \u2191m * r = 0", "state_after": "no goals"}, {"tactic": "simpa using hm.symm", "annotated_tactic": ["simpa using hm.symm", []], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\nh : (algebraMap R S) r = 0\nm : \u21a5M\nhm : \u2191m * 0 = \u2191m * r\n\u22a2 \u2191m * r = 0", "state_after": "no goals"}, {"tactic": "rintro \u27e8m, hm\u27e9", "annotated_tactic": ["rintro \u27e8m, hm\u27e9", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\n\u22a2 (\u2203 m, \u2191m * r = 0) \u2192 (algebraMap R S) r = 0", "state_after": "case mpr.intro\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\nm : \u21a5M\nhm : \u2191m * r = 0\n\u22a2 (algebraMap R S) r = 0"}, {"tactic": "rw [\u2190 (IsLocalization.map_units S m).mul_right_inj, mul_zero, \u2190 RingHom.map_mul, hm,\n  RingHom.map_zero]", "annotated_tactic": ["rw [\u2190 (<a>IsLocalization.map_units</a> S m).<a>mul_right_inj</a>, <a>mul_zero</a>, \u2190 <a>RingHom.map_mul</a>, hm,\n      <a>RingHom.map_zero</a>]", [{"full_name": "IsLocalization.map_units", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}, {"full_name": "IsUnit.mul_right_inj", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [849, 9], "def_end_pos": [849, 22]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "RingHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "RingHom.map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [549, 19], "def_end_pos": [549, 27]}]], "state_before": "case mpr.intro\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nr : R\nm : \u21a5M\nhm : \u2191m * r = 0\n\u22a2 (algebraMap R S) r = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidHom.comp_assoc", "start": [968, 1], "end": [970, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.nat_lt_aleph0", "start": [1527, 1], "end": [1531, 41], "traced_tactics": [{"tactic": "rw [\u2190 nat_succ, \u2190 lift_mk_fin, aleph0, lift_mk_le.{u}]", "annotated_tactic": ["rw [\u2190 <a>nat_succ</a>, \u2190 <a>lift_mk_fin</a>, <a>aleph0</a>, <a>lift_mk_le</a>.{u}]", [{"full_name": "Cardinal.nat_succ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1485, 9], "def_end_pos": [1485, 17]}, {"full_name": "Cardinal.lift_mk_fin", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1425, 9], "def_end_pos": [1425, 20]}, {"full_name": "Cardinal.aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1266, 5], "def_end_pos": [1266, 11]}, {"full_name": "Cardinal.lift_mk_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [310, 9], "def_end_pos": [310, 19]}]], "state_before": "\u03b1 \u03b2 : Type u\nn : \u2115\n\u22a2 succ \u2191n \u2264 \u2135\u2080", "state_after": "\u03b1 \u03b2 : Type u\nn : \u2115\n\u22a2 Nonempty (Fin (Nat.succ n) \u21aa \u2115)"}, {"tactic": "exact \u27e8\u27e8(\u2191), fun a b => Fin.ext\u27e9\u27e9", "annotated_tactic": ["exact \u27e8\u27e8(\u2191), fun a b => <a>Fin.ext</a>\u27e9\u27e9", [{"full_name": "Fin.ext", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [37, 16], "def_end_pos": [37, 19]}]], "state_before": "\u03b1 \u03b2 : Type u\nn : \u2115\n\u22a2 Nonempty (Fin (Nat.succ n) \u21aa \u2115)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Basic.lean", "full_name": "LinearMap.comp_zero", "start": [886, 1], "end": [887, 69], "traced_tactics": [{"tactic": "rw [comp_apply, zero_apply, zero_apply, g.map_zero]", "annotated_tactic": ["rw [<a>comp_apply</a>, <a>zero_apply</a>, <a>zero_apply</a>, g.map_zero]", [{"full_name": "LinearMap.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 19]}, {"full_name": "LinearMap.zero_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [881, 9], "def_end_pos": [881, 19]}, {"full_name": "LinearMap.zero_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [881, 9], "def_end_pos": [881, 19]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u2075 : Semiring R\u2081\ninst\u271d\u00b9\u2074 : Semiring R\u2082\ninst\u271d\u00b9\u00b3 : Semiring R\u2083\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2083\ninst\u271d\u2079 : AddCommGroup N\u2081\ninst\u271d\u2078 : AddCommGroup N\u2082\ninst\u271d\u2077 : AddCommGroup N\u2083\ninst\u271d\u2076 : Module R\u2081 M\ninst\u271d\u2075 : Module R\u2082 M\u2082\ninst\u271d\u2074 : Module R\u2083 M\u2083\ninst\u271d\u00b3 : Module R\u2081 N\u2081\ninst\u271d\u00b2 : Module R\u2082 N\u2082\ninst\u271d\u00b9 : Module R\u2083 N\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\ninst\u271d : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\nc : M\n\u22a2 (comp g 0) c = 0 c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/GDelta.lean", "full_name": "IsG\u03b4.empty", "start": [69, 11], "end": [70, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Pi.lean", "full_name": "MonoidHom.functions_ext'", "start": [106, 1], "end": [108, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Circular.lean", "full_name": "sbtw_cyclic_left", "start": [214, 1], "end": [215, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "inf_symmDiff_distrib_left", "start": [402, 1], "end": [404, 31], "traced_tactics": [{"tactic": "rw [symmDiff_eq_sup_sdiff_inf, inf_sdiff_distrib_left, inf_sup_left, inf_inf_distrib_left,\n  symmDiff_eq_sup_sdiff_inf]", "annotated_tactic": ["rw [<a>symmDiff_eq_sup_sdiff_inf</a>, <a>inf_sdiff_distrib_left</a>, <a>inf_sup_left</a>, <a>inf_inf_distrib_left</a>,\n    <a>symmDiff_eq_sup_sdiff_inf</a>]", [{"full_name": "symmDiff_eq_sup_sdiff_inf", "def_path": ".lake/packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [158, 9], "def_end_pos": [158, 34]}, {"full_name": "inf_sdiff_distrib_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [465, 9], "def_end_pos": [465, 31]}, {"full_name": "inf_sup_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [730, 9], "def_end_pos": [730, 21]}, {"full_name": "inf_inf_distrib_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [497, 9], "def_end_pos": [497, 29]}, {"full_name": "symmDiff_eq_sup_sdiff_inf", "def_path": ".lake/packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [158, 9], "def_end_pos": [158, 34]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\n\u22a2 a \u2293 b \u2206 c = (a \u2293 b) \u2206 (a \u2293 c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/StarAlgHom.lean", "full_name": "NonUnitalStarAlgHom.inr_apply", "start": [616, 1], "end": [617, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "LinearEquiv.toSpanNonzeroSingleton_one", "start": [1157, 1], "end": [1159, 68], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nx : M\nh : x \u2260 0\n\u22a2 (toSpanNonzeroSingleton R M x h) 1 = { val := x, property := \u22ef }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "full_name": "HasSum.summable", "start": [86, 1], "end": [87, 9], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Sum/Basic.lean", "full_name": "Sum.swap_inr", "start": [104, 9], "end": [104, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.count_zero", "start": [1323, 1], "end": [1327, 6], "traced_tactics": [{"tactic": "dsimp only [count]", "annotated_tactic": ["dsimp only [<a>count</a>]", [{"full_name": "Associates.count", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1310, 5], "def_end_pos": [1310, 10]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : DecidableEq (Associates \u03b1)\np : Associates \u03b1\nhp : Irreducible p\n\u22a2 count p 0 = 0", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : DecidableEq (Associates \u03b1)\np : Associates \u03b1\nhp : Irreducible p\n\u22a2 (if hp : Irreducible p then bcount { val := p, property := hp } else 0) 0 = 0"}, {"tactic": "split_ifs", "annotated_tactic": ["split_ifs", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : DecidableEq (Associates \u03b1)\np : Associates \u03b1\nhp : Irreducible p\n\u22a2 (if hp : Irreducible p then bcount { val := p, property := hp } else 0) 0 = 0", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : DecidableEq (Associates \u03b1)\np : Associates \u03b1\nhp : Irreducible p\n\u22a2 bcount { val := p, property := hp } 0 = 0"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : DecidableEq (Associates \u03b1)\np : Associates \u03b1\nhp : Irreducible p\n\u22a2 bcount { val := p, property := hp } 0 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Laurent.lean", "full_name": "LaurentPolynomial.mul_T_assoc", "start": [204, 1], "end": [205, 28], "traced_tactics": [{"tactic": "simp [\u2190 T_add, mul_assoc]", "annotated_tactic": ["simp [\u2190 <a>T_add</a>, <a>mul_assoc</a>]", [{"full_name": "LaurentPolynomial.T_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Laurent.lean", "def_pos": [186, 9], "def_end_pos": [186, 14]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[T;T\u207b\u00b9]\nm n : \u2124\n\u22a2 f * T m * T n = f * T (m + n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Function.lean", "full_name": "ConcaveOn.inf", "start": [609, 1], "end": [610, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Ray.lean", "full_name": "SameRay.refl", "start": [76, 1], "end": [78, 65], "traced_tactics": [{"tactic": "nontriviality R", "annotated_tactic": ["nontriviality R", []], "state_before": "R : Type u_1\ninst\u271d\u2075 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\n\u03b9 : Type u_4\ninst\u271d : DecidableEq \u03b9\nx\u271d y z x : M\n\u22a2 SameRay R x x", "state_after": "R : Type u_1\ninst\u271d\u2076 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nN : Type u_3\ninst\u271d\u00b3 : AddCommMonoid N\ninst\u271d\u00b2 : Module R N\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\nx\u271d y z x : M\ninst\u271d : Nontrivial R\n\u22a2 SameRay R x x"}, {"tactic": "exact Or.inr (Or.inr <| \u27e81, 1, zero_lt_one, zero_lt_one, rfl\u27e9)", "annotated_tactic": ["exact <a>Or.inr</a> (<a>Or.inr</a> <| \u27e81, 1, <a>zero_lt_one</a>, <a>zero_lt_one</a>, <a>rfl</a>\u27e9)", [{"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "zero_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}, {"full_name": "zero_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nN : Type u_3\ninst\u271d\u00b3 : AddCommMonoid N\ninst\u271d\u00b2 : Module R N\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\nx\u271d y z x : M\ninst\u271d : Nontrivial R\n\u22a2 SameRay R x x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Congruence.lean", "full_name": "RingCon.coe_smul", "start": [235, 1], "end": [236, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Order.lean", "full_name": "Complex.lt_def", "start": [59, 1], "end": [60, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "Cycle.coe_toFinset", "start": [807, 1], "end": [808, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Invertible/Defs.lean", "full_name": "invOf_mul_self'", "start": [98, 1], "end": [99, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.Ici_mul_Ioi_subset'", "start": [110, 1], "end": [113, 39], "traced_tactics": [{"tactic": "haveI := covariantClass_le_of_lt", "annotated_tactic": ["haveI := <a>covariantClass_le_of_lt</a>", [{"full_name": "covariantClass_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CovariantAndContravariant.lean", "def_pos": [289, 9], "def_end_pos": [289, 32]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\ninst\u271d : CovariantClass \u03b1 \u03b1 (Function.swap HMul.hMul) LT.lt\na b : \u03b1\n\u22a2 Ici a * Ioi b \u2286 Ioi (a * b)", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\ninst\u271d : CovariantClass \u03b1 \u03b1 (Function.swap HMul.hMul) LT.lt\na b : \u03b1\nthis :\n  \u2200 (M : Type ?u.12179) (N : Type ?u.12180) (\u03bc : M \u2192 N \u2192 N) [inst : PartialOrder N]\n    [inst_1 : CovariantClass M N \u03bc fun x x_1 => x < x_1], CovariantClass M N \u03bc fun x x_1 => x \u2264 x_1\n\u22a2 Ici a * Ioi b \u2286 Ioi (a * b)"}, {"tactic": "rintro x \u27e8y, hya, z, hzb, rfl\u27e9", "annotated_tactic": ["rintro x \u27e8y, hya, z, hzb, rfl\u27e9", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\ninst\u271d : CovariantClass \u03b1 \u03b1 (Function.swap HMul.hMul) LT.lt\na b : \u03b1\nthis :\n  \u2200 (M : Type ?u.12179) (N : Type ?u.12180) (\u03bc : M \u2192 N \u2192 N) [inst : PartialOrder N]\n    [inst_1 : CovariantClass M N \u03bc fun x x_1 => x < x_1], CovariantClass M N \u03bc fun x x_1 => x \u2264 x_1\n\u22a2 Ici a * Ioi b \u2286 Ioi (a * b)", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\ninst\u271d : CovariantClass \u03b1 \u03b1 (Function.swap HMul.hMul) LT.lt\na b : \u03b1\nthis :\n  \u2200 (M : Type ?u.12179) (N : Type ?u.12180) (\u03bc : M \u2192 N \u2192 N) [inst : PartialOrder N]\n    [inst_1 : CovariantClass M N \u03bc fun x x_1 => x < x_1], CovariantClass M N \u03bc fun x x_1 => x \u2264 x_1\ny : \u03b1\nhya : y \u2208 Ici a\nz : \u03b1\nhzb : z \u2208 Ioi b\n\u22a2 (fun x x_1 => x * x_1) y z \u2208 Ioi (a * b)"}, {"tactic": "exact mul_lt_mul_of_le_of_lt hya hzb", "annotated_tactic": ["exact <a>mul_lt_mul_of_le_of_lt</a> hya hzb", [{"full_name": "mul_lt_mul_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [171, 9], "def_end_pos": [171, 31]}]], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\ninst\u271d : CovariantClass \u03b1 \u03b1 (Function.swap HMul.hMul) LT.lt\na b : \u03b1\nthis :\n  \u2200 (M : Type ?u.12179) (N : Type ?u.12180) (\u03bc : M \u2192 N \u2192 N) [inst : PartialOrder N]\n    [inst_1 : CovariantClass M N \u03bc fun x x_1 => x < x_1], CovariantClass M N \u03bc fun x x_1 => x \u2264 x_1\ny : \u03b1\nhya : y \u2208 Ici a\nz : \u03b1\nhzb : z \u2208 Ioi b\n\u22a2 (fun x x_1 => x * x_1) y z \u2208 Ioi (a * b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "full_name": "PartialEquiv.image_source_eq_target", "start": [341, 1], "end": [342, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "AffineEquiv.span_eq_top_iff", "start": [1678, 1], "end": [1684, 77], "traced_tactics": [{"tactic": "refine' \u27e8(e : P\u2081 \u2192\u1d43[k] P\u2082).span_eq_top_of_surjective e.surjective, _\u27e9", "annotated_tactic": ["refine' \u27e8(e : P\u2081 \u2192\u1d43[k] P\u2082).<a>span_eq_top_of_surjective</a> e.surjective, _\u27e9", [{"full_name": "AffineMap.span_eq_top_of_surjective", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [1642, 9], "def_end_pos": [1642, 34]}]], "state_before": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\n\u22a2 affineSpan k s = \u22a4 \u2194 affineSpan k (\u21d1e '' s) = \u22a4", "state_after": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\n\u22a2 affineSpan k (\u21d1e '' s) = \u22a4 \u2192 affineSpan k s = \u22a4"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\n\u22a2 affineSpan k (\u21d1e '' s) = \u22a4 \u2192 affineSpan k s = \u22a4", "state_after": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\n\u22a2 affineSpan k s = \u22a4"}, {"tactic": "have : s = e.symm '' (e '' s) := by rw [\u2190 image_comp]; simp", "annotated_tactic": ["have : s = e.symm '' (e '' s) := by rw [\u2190 <a>image_comp</a>]; simp", [{"full_name": "Set.image_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [265, 9], "def_end_pos": [265, 19]}]], "state_before": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\n\u22a2 affineSpan k s = \u22a4", "state_after": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\nthis : s = \u21d1(symm e) '' (\u21d1e '' s)\n\u22a2 affineSpan k s = \u22a4"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\nthis : s = \u21d1(symm e) '' (\u21d1e '' s)\n\u22a2 affineSpan k s = \u22a4", "state_after": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\nthis : s = \u21d1(symm e) '' (\u21d1e '' s)\n\u22a2 affineSpan k (\u21d1(symm e) '' (\u21d1e '' s)) = \u22a4"}, {"tactic": "exact (e.symm : P\u2082 \u2192\u1d43[k] P\u2081).span_eq_top_of_surjective e.symm.surjective h", "annotated_tactic": ["exact (e.symm : P\u2082 \u2192\u1d43[k] P\u2081).<a>span_eq_top_of_surjective</a> e.symm.surjective h", [{"full_name": "AffineMap.span_eq_top_of_surjective", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [1642, 9], "def_end_pos": [1642, 34]}]], "state_before": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\nthis : s = \u21d1(symm e) '' (\u21d1e '' s)\n\u22a2 affineSpan k (\u21d1(symm e) '' (\u21d1e '' s)) = \u22a4", "state_after": "no goals"}, {"tactic": "rw [\u2190 image_comp]", "annotated_tactic": ["rw [\u2190 <a>image_comp</a>]", [{"full_name": "Set.image_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [265, 9], "def_end_pos": [265, 19]}]], "state_before": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\n\u22a2 s = \u21d1(symm e) '' (\u21d1e '' s)", "state_after": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\n\u22a2 s = \u21d1(symm e) \u2218 \u21d1e '' s"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\nV\u2083 : Type u_6\nP\u2083 : Type u_7\ninst\u271d\u2079 : Ring k\ninst\u271d\u2078 : AddCommGroup V\u2081\ninst\u271d\u2077 : Module k V\u2081\ninst\u271d\u2076 : AffineSpace V\u2081 P\u2081\ninst\u271d\u2075 : AddCommGroup V\u2082\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AffineSpace V\u2082 P\u2082\ninst\u271d\u00b2 : AddCommGroup V\u2083\ninst\u271d\u00b9 : Module k V\u2083\ninst\u271d : AffineSpace V\u2083 P\u2083\nf : P\u2081 \u2192\u1d43[k] P\u2082\ns : Set P\u2081\ne : P\u2081 \u2243\u1d43[k] P\u2082\nh : affineSpan k (\u21d1e '' s) = \u22a4\n\u22a2 s = \u21d1(symm e) \u2218 \u21d1e '' s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean", "full_name": "IsBoundedLinearMap.zero", "start": [107, 1], "end": [108, 61], "traced_tactics": [{"tactic": "simp [le_refl]", "annotated_tactic": ["simp [<a>le_refl</a>]", [{"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\n\u22a2 \u2200 (x : E), \u20160 x\u2016 \u2264 0 * \u2016x\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Commute/Units.lean", "full_name": "isUnit_mul_self_iff", "start": [96, 1], "end": [97, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finite/Card.lean", "full_name": "Finite.card_le_one_iff_subsingleton", "start": [78, 1], "end": [80, 77], "traced_tactics": [{"tactic": "haveI := Fintype.ofFinite \u03b1", "annotated_tactic": ["haveI := <a>Fintype.ofFinite</a> \u03b1", [{"full_name": "Fintype.ofFinite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [448, 19], "def_end_pos": [448, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Finite \u03b1\n\u22a2 Nat.card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1"}, {"tactic": "simp only [Nat.card_eq_fintype_card, Fintype.card_le_one_iff_subsingleton]", "annotated_tactic": ["simp only [<a>Nat.card_eq_fintype_card</a>, <a>Fintype.card_le_one_iff_subsingleton</a>]", [{"full_name": "Nat.card_eq_fintype_card", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Finite.lean", "def_pos": [41, 9], "def_end_pos": [41, 29]}, {"full_name": "Fintype.card_le_one_iff_subsingleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [589, 9], "def_end_pos": [589, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Finite \u03b1\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.SurjOn.inter", "start": [856, 1], "end": [858, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.lookmap_nil", "start": [3254, 1], "end": [3255, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "toIcoDiv_add_right", "start": [297, 1], "end": [298, 59], "traced_tactics": [{"tactic": "simpa only [one_zsmul] using toIcoDiv_add_zsmul hp a b 1", "annotated_tactic": ["simpa only [<a>one_zsmul</a>] using <a>toIcoDiv_add_zsmul</a> hp a b 1", [{"full_name": "one_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [245, 30], "def_end_pos": [245, 39]}, {"full_name": "toIcoDiv_add_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [233, 9], "def_end_pos": [233, 27]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b\u271d c : \u03b1\nn : \u2124\na b : \u03b1\n\u22a2 toIcoDiv hp a (b + p) = toIcoDiv hp a b + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/IsometricSMul.lean", "full_name": "nndist_inv_inv", "start": [406, 1], "end": [408, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/GeneralLinearGroup.lean", "full_name": "Matrix.GeneralLinearGroup.coe_inv", "start": [121, 1], "end": [123, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.image_eq_preimage_of_inverse", "start": [406, 1], "end": [409, 100], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Cast/Order.lean", "full_name": "Nat.cast_lt_one", "start": [142, 1], "end": [143, 71], "traced_tactics": [{"tactic": "rw [\u2190 cast_one, cast_lt, Nat.lt_succ_iff, \u2190 bot_eq_zero, le_bot_iff]", "annotated_tactic": ["rw [\u2190 <a>cast_one</a>, <a>cast_lt</a>, <a>Nat.lt_succ_iff</a>, \u2190 <a>bot_eq_zero</a>, <a>le_bot_iff</a>]", [{"full_name": "Nat.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [150, 9], "def_end_pos": [150, 17]}, {"full_name": "Nat.cast_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Order.lean", "def_pos": [129, 9], "def_end_pos": [129, 16]}, {"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}, {"full_name": "bot_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [210, 3], "def_end_pos": [210, 14]}, {"full_name": "le_bot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [323, 9], "def_end_pos": [323, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : AddMonoidWithOne \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : CharZero \u03b1\nm n : \u2115\n\u22a2 \u2191n < 1 \u2194 n = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.nat_cast_comp", "start": [567, 1], "end": [567, 89], "traced_tactics": [{"tactic": "rw [\u2190 C_eq_nat_cast, C_comp]", "annotated_tactic": ["rw [\u2190 <a>C_eq_nat_cast</a>, <a>C_comp</a>]", [{"full_name": "Polynomial.C_eq_nat_cast", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [552, 9], "def_end_pos": [552, 22]}, {"full_name": "Polynomial.C_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [562, 9], "def_end_pos": [562, 15]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\n\u22a2 comp (\u2191n) p = \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "full_name": "Cardinal.aleph_limit", "start": [277, 1], "end": [287, 45], "traced_tactics": [{"tactic": "apply le_antisymm _ (ciSup_le' _)", "annotated_tactic": ["apply <a>le_antisymm</a> _ (<a>ciSup_le'</a> _)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "ciSup_le'", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [1252, 9], "def_end_pos": [1252, 18]}]], "state_before": "o : Ordinal.{u_1}\nho : Ordinal.IsLimit o\n\u22a2 aleph o = \u2a06 a, aleph \u2191a", "state_after": "o : Ordinal.{u_1}\nho : Ordinal.IsLimit o\n\u22a2 aleph o \u2264 \u2a06 i, aleph \u2191i\n\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\n\u22a2 \u2200 (i : \u2191(Iio o)), aleph \u2191i \u2264 aleph o"}, {"tactic": "rw [aleph, aleph'_limit (ho.add _)]", "annotated_tactic": ["rw [<a>aleph</a>, <a>aleph'_limit</a> (ho.add _)]", [{"full_name": "Cardinal.aleph", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [247, 5], "def_end_pos": [247, 10]}, {"full_name": "Cardinal.aleph'_limit", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [225, 9], "def_end_pos": [225, 21]}]], "state_before": "o : Ordinal.{u_1}\nho : Ordinal.IsLimit o\n\u22a2 aleph o \u2264 \u2a06 i, aleph \u2191i", "state_after": "o : Ordinal.{u_1}\nho : Ordinal.IsLimit o\n\u22a2 \u2a06 a, aleph' \u2191a \u2264 \u2a06 i, aleph \u2191i"}, {"tactic": "refine' ciSup_mono' (bddAbove_of_small _) _", "annotated_tactic": ["refine' <a>ciSup_mono'</a> (<a>bddAbove_of_small</a> _) _", [{"full_name": "ciSup_mono'", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [1261, 9], "def_end_pos": [1261, 20]}, {"full_name": "Cardinal.bddAbove_of_small", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [986, 9], "def_end_pos": [986, 26]}]], "state_before": "o : Ordinal.{u_1}\nho : Ordinal.IsLimit o\n\u22a2 \u2a06 a, aleph' \u2191a \u2264 \u2a06 i, aleph \u2191i", "state_after": "o : Ordinal.{u_1}\nho : Ordinal.IsLimit o\n\u22a2 \u2200 (i : \u2191(Iio (\u03c9 + o))), \u2203 i', aleph' \u2191i \u2264 aleph \u2191i'"}, {"tactic": "rintro \u27e8i, hi\u27e9", "annotated_tactic": ["rintro \u27e8i, hi\u27e9", []], "state_before": "o : Ordinal.{u_1}\nho : Ordinal.IsLimit o\n\u22a2 \u2200 (i : \u2191(Iio (\u03c9 + o))), \u2203 i', aleph' \u2191i \u2264 aleph \u2191i'", "state_after": "case mk\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\ni : Ordinal.{u_1}\nhi : i \u2208 Iio (\u03c9 + o)\n\u22a2 \u2203 i', aleph' \u2191{ val := i, property := hi } \u2264 aleph \u2191i'"}, {"tactic": "cases' lt_or_le i \u03c9 with h h", "annotated_tactic": ["cases' <a>lt_or_le</a> i \u03c9 with h h", [{"full_name": "lt_or_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [330, 9], "def_end_pos": [330, 17]}]], "state_before": "case mk\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\ni : Ordinal.{u_1}\nhi : i \u2208 Iio (\u03c9 + o)\n\u22a2 \u2203 i', aleph' \u2191{ val := i, property := hi } \u2264 aleph \u2191i'", "state_after": "case mk.inl\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\ni : Ordinal.{u_1}\nhi : i \u2208 Iio (\u03c9 + o)\nh : i < \u03c9\n\u22a2 \u2203 i', aleph' \u2191{ val := i, property := hi } \u2264 aleph \u2191i'\n\ncase mk.inr\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\ni : Ordinal.{u_1}\nhi : i \u2208 Iio (\u03c9 + o)\nh : \u03c9 \u2264 i\n\u22a2 \u2203 i', aleph' \u2191{ val := i, property := hi } \u2264 aleph \u2191i'"}, {"tactic": "rcases lt_omega.1 h with \u27e8n, rfl\u27e9", "annotated_tactic": ["rcases <a>lt_omega</a>.1 h with \u27e8n, rfl\u27e9", [{"full_name": "Ordinal.lt_omega", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [2427, 9], "def_end_pos": [2427, 17]}]], "state_before": "case mk.inl\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\ni : Ordinal.{u_1}\nhi : i \u2208 Iio (\u03c9 + o)\nh : i < \u03c9\n\u22a2 \u2203 i', aleph' \u2191{ val := i, property := hi } \u2264 aleph \u2191i'", "state_after": "case mk.inl.intro\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\nn : \u2115\nhi : \u2191n \u2208 Iio (\u03c9 + o)\nh : \u2191n < \u03c9\n\u22a2 \u2203 i', aleph' \u2191{ val := \u2191n, property := hi } \u2264 aleph \u2191i'"}, {"tactic": "use \u27e80, ho.pos\u27e9", "annotated_tactic": ["use \u27e80, ho.pos\u27e9", []], "state_before": "case mk.inl.intro\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\nn : \u2115\nhi : \u2191n \u2208 Iio (\u03c9 + o)\nh : \u2191n < \u03c9\n\u22a2 \u2203 i', aleph' \u2191{ val := \u2191n, property := hi } \u2264 aleph \u2191i'", "state_after": "case h\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\nn : \u2115\nhi : \u2191n \u2208 Iio (\u03c9 + o)\nh : \u2191n < \u03c9\n\u22a2 aleph' \u2191{ val := \u2191n, property := hi } \u2264 aleph \u2191{ val := 0, property := \u22ef }"}, {"tactic": "simpa using (nat_lt_aleph0 n).le", "annotated_tactic": ["simpa using (<a>nat_lt_aleph0</a> n).<a>le</a>", [{"full_name": "Cardinal.nat_lt_aleph0", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1527, 9], "def_end_pos": [1527, 22]}, {"full_name": "LT.lt.le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [139, 7], "def_end_pos": [139, 15]}]], "state_before": "case h\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\nn : \u2115\nhi : \u2191n \u2208 Iio (\u03c9 + o)\nh : \u2191n < \u03c9\n\u22a2 aleph' \u2191{ val := \u2191n, property := hi } \u2264 aleph \u2191{ val := 0, property := \u22ef }", "state_after": "no goals"}, {"tactic": "exact \u27e8\u27e8_, (sub_lt_of_le h).2 hi\u27e9, aleph'_le.2 (le_add_sub _ _)\u27e9", "annotated_tactic": ["exact \u27e8\u27e8_, (<a>sub_lt_of_le</a> h).2 hi\u27e9, <a>aleph'_le</a>.2 (<a>le_add_sub</a> _ _)\u27e9", [{"full_name": "Ordinal.sub_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [578, 9], "def_end_pos": [578, 21]}, {"full_name": "Cardinal.aleph'_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [183, 9], "def_end_pos": [183, 18]}, {"full_name": "Ordinal.le_add_sub", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [540, 9], "def_end_pos": [540, 19]}]], "state_before": "case mk.inr\no : Ordinal.{u_1}\nho : Ordinal.IsLimit o\ni : Ordinal.{u_1}\nhi : i \u2208 Iio (\u03c9 + o)\nh : \u03c9 \u2264 i\n\u22a2 \u2203 i', aleph' \u2191{ val := i, property := hi } \u2264 aleph \u2191i'", "state_after": "no goals"}, {"tactic": "exact fun i => aleph_le.2 (le_of_lt i.2)", "annotated_tactic": ["exact fun i => <a>aleph_le</a>.2 (<a>le_of_lt</a> i.2)", [{"full_name": "Cardinal.aleph_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [257, 9], "def_end_pos": [257, 17]}, {"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}]], "state_before": "o : Ordinal.{u_1}\nho : Ordinal.IsLimit o\n\u22a2 \u2200 (i : \u2191(Iio o)), aleph \u2191i \u2264 aleph o", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.image_sInter_subset", "start": [1498, 1], "end": [1500, 29], "traced_tactics": [{"tactic": "rw [sInter_eq_biInter]", "annotated_tactic": ["rw [<a>sInter_eq_biInter</a>]", [{"full_name": "Set.sInter_eq_biInter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1320, 9], "def_end_pos": [1320, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' \u22c2\u2080 S \u2286 \u22c2 s \u2208 S, f '' s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' \u22c2 i \u2208 S, i \u2286 \u22c2 s \u2208 S, f '' s"}, {"tactic": "apply image_iInter\u2082_subset", "annotated_tactic": ["apply <a>image_iInter\u2082_subset</a>", [{"full_name": "Set.image_iInter\u2082_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1493, 9], "def_end_pos": [1493, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' \u22c2 i \u2208 S, i \u2286 \u22c2 s \u2208 S, f '' s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "full_name": "BilinForm.mul_toMatrix", "start": [325, 1], "end": [327, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.IsBigO.prod_left", "start": [1040, 1], "end": [1043, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Order/Defs.lean", "full_name": "lt_of_le_of_lt", "start": [116, 1], "end": [119, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.tendsto_iSup", "start": [3189, 1], "end": [3190, 101], "traced_tactics": [{"tactic": "simp only [Tendsto, map_iSup, iSup_le_iff]", "annotated_tactic": ["simp only [<a>Tendsto</a>, <a>map_iSup</a>, <a>iSup_le_iff</a>]", [{"full_name": "Filter.Tendsto", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2962, 5], "def_end_pos": [2962, 12]}, {"full_name": "Filter.map_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2353, 9], "def_end_pos": [2353, 17]}, {"full_name": "iSup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [853, 9], "def_end_pos": [853, 20]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : \u03b1 \u2192 \u03b2\nx : \u03b9 \u2192 Filter \u03b1\ny : Filter \u03b2\n\u22a2 Tendsto f (\u2a06 i, x i) y \u2194 \u2200 (i : \u03b9), Tendsto f (x i) y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.prodMonoidal_rightUnitor_hom_fst", "start": [1048, 1], "end": [1051, 6], "traced_tactics": [{"tactic": "cases X", "annotated_tactic": ["cases X", []], "state_before": "C : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d\u2074 : MonoidalCategory C\nC\u2081 : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\u2081\ninst\u271d\u00b2 : MonoidalCategory C\u2081\nC\u2082 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} C\u2082\ninst\u271d : MonoidalCategory C\u2082\nX : C\u2081 \u00d7 C\u2082\n\u22a2 (\u03c1_ X).hom.1 = (\u03c1_ X.1).hom", "state_after": "case mk\nC : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d\u2074 : MonoidalCategory C\nC\u2081 : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\u2081\ninst\u271d\u00b2 : MonoidalCategory C\u2081\nC\u2082 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} C\u2082\ninst\u271d : MonoidalCategory C\u2082\nfst\u271d : C\u2081\nsnd\u271d : C\u2082\n\u22a2 (\u03c1_ (fst\u271d, snd\u271d)).hom.1 = (\u03c1_ (fst\u271d, snd\u271d).1).hom"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk\nC : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d\u2074 : MonoidalCategory C\nC\u2081 : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\u2081\ninst\u271d\u00b2 : MonoidalCategory C\u2081\nC\u2082 : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} C\u2082\ninst\u271d : MonoidalCategory C\u2082\nfst\u271d : C\u2081\nsnd\u271d : C\u2082\n\u22a2 (\u03c1_ (fst\u271d, snd\u271d)).hom.1 = (\u03c1_ (fst\u271d, snd\u271d).1).hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Hom/Ring.lean", "full_name": "OrderRingIso.coe_toOrderIso", "start": [401, 1], "end": [402, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Closure.lean", "full_name": "ClosureOperator.closure_inf_le", "start": [224, 1], "end": [226, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.conjTransposeAddEquiv_symm", "start": [2345, 1], "end": [2347, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_mul_distrib", "start": [825, 1], "end": [826, 50], "traced_tactics": [{"tactic": "rw [one_mul]", "annotated_tactic": ["rw [<a>one_mul</a>]", [{"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\n\u22a2 \u220f x in s, f x * g x = fold (fun x x_1 => x * x_1) (1 * 1) (fun x => f x * g x) s", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\n\u22a2 \u220f x in s, f x * g x = fold (fun x x_1 => x * x_1) 1 (fun x => f x * g x) s"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\n\u22a2 \u220f x in s, f x * g x = fold (fun x x_1 => x * x_1) 1 (fun x => f x * g x) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "orderOf_eq_one_iff", "start": [251, 1], "end": [252, 71], "traced_tactics": [{"tactic": "rw [orderOf, minimalPeriod_eq_one_iff_isFixedPt, IsFixedPt, mul_one]", "annotated_tactic": ["rw [<a>orderOf</a>, <a>minimalPeriod_eq_one_iff_isFixedPt</a>, <a>IsFixedPt</a>, <a>mul_one</a>]", [{"full_name": "orderOf", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [154, 19], "def_end_pos": [154, 26]}, {"full_name": "Function.minimalPeriod_eq_one_iff_isFixedPt", "def_path": ".lake/packages/mathlib/Mathlib/Dynamics/PeriodicPts.lean", "def_pos": [373, 9], "def_end_pos": [373, 43]}, {"full_name": "Function.IsFixedPt", "def_path": ".lake/packages/mathlib/Mathlib/Dynamics/FixedPoints/Basic.lean", "def_pos": [39, 5], "def_end_pos": [39, 14]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : Monoid G\na b x y : G\nn m : \u2115\n\u22a2 orderOf x = 1 \u2194 x = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Intervals.lean", "full_name": "List.Ico.eq_nil_of_le", "start": [72, 1], "end": [73, 40], "traced_tactics": [{"tactic": "simp [Ico, tsub_eq_zero_iff_le.mpr h]", "annotated_tactic": ["simp [<a>Ico</a>, tsub_eq_zero_iff_le.mpr h]", [{"full_name": "List.Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Intervals.lean", "def_pos": [36, 5], "def_end_pos": [36, 8]}]], "state_before": "n m : \u2115\nh : m \u2264 n\n\u22a2 Ico n m = []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Interval.lean", "full_name": "Nat.card_Ioo", "start": [113, 1], "end": [114, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearForm/Basic.lean", "full_name": "BilinForm.coeFn_congr", "start": [78, 1], "end": [79, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_of_subsingleton", "start": [125, 1], "end": [126, 42], "traced_tactics": [{"tactic": "rw [Subsingleton.elim p 0, degree_zero]", "annotated_tactic": ["rw [<a>Subsingleton.elim</a> p 0, <a>degree_zero</a>]", [{"full_name": "Subsingleton.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1010, 19], "def_end_pos": [1010, 36]}, {"full_name": "Polynomial.degree_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [105, 9], "def_end_pos": [105, 20]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d\u00b9 : Semiring R\np q r : R[X]\ninst\u271d : Subsingleton R\n\u22a2 degree p = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.IsLittleO.prod_left_snd", "start": [1069, 1], "end": [1070, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "Bornology.IsBounded.exists_pos_norm_lt'", "start": [771, 1], "end": [773, 71], "traced_tactics": [{"tactic": "positivity", "annotated_tactic": ["positivity", []], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b2 : SeminormedGroup E\ninst\u271d\u00b9 : SeminormedGroup F\ninst\u271d : SeminormedGroup G\ns : Set E\na a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nhs : IsBounded s\nR : \u211d\nhR\u2080 : R > 0\nhR : \u2200 x \u2208 s, \u2016x\u2016 \u2264 R\n\u22a2 R + 1 > 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.neg_comp", "start": [1328, 1], "end": [1329, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearForm/Properties.lean", "full_name": "BilinForm.mem_selfAdjointSubmodule", "start": [332, 1], "end": [334, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Sqrt.lean", "full_name": "NNReal.sqrt_inv", "start": [110, 1], "end": [111, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.erase_neg", "start": [1154, 1], "end": [1155, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.compl_mem_comk", "start": [3312, 1], "end": [3314, 7], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\np : Set \u03b1 \u2192 Prop\nhe : p \u2205\nhmono : \u2200 (t : Set \u03b1), p t \u2192 \u2200 s \u2286 t, p s\nhunion : \u2200 (s : Set \u03b1), p s \u2192 \u2200 (t : Set \u03b1), p t \u2192 p (s \u222a t)\ns : Set \u03b1\n\u22a2 s\u1d9c \u2208 comk p he hmono hunion \u2194 p s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Tendsto.atTop_mul_atBot", "start": [967, 1], "end": [970, 92], "traced_tactics": [{"tactic": "have := hf.atTop_mul_atTop <| tendsto_neg_atBot_atTop.comp hg", "annotated_tactic": ["have := hf.atTop_mul_atTop <| tendsto_neg_atBot_atTop.comp hg", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : OrderedRing \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : Tendsto f l atTop\nhg : Tendsto g l atBot\n\u22a2 Tendsto (fun x => f x * g x) l atBot", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : OrderedRing \u03b1\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : Tendsto f l atTop\nhg : Tendsto g l atBot\nthis : Tendsto (fun x => f x * (Neg.neg \u2218 g) x) l atTop\n\u22a2 Tendsto (fun x => f x * g x) l atBot"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "Metric.ball_subset", "start": [666, 1], "end": [668, 75], "traced_tactics": [{"tactic": "rw [\u2190 add_sub_cancel'_right \u03b5\u2081 \u03b5\u2082]", "annotated_tactic": ["rw [\u2190 <a>add_sub_cancel'_right</a> \u03b5\u2081 \u03b5\u2082]", [{"full_name": "add_sub_cancel'_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1031, 3], "def_end_pos": [1031, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z\u271d : \u03b1\n\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\ns : Set \u03b1\nh : dist x y \u2264 \u03b5\u2082 - \u03b5\u2081\nz : \u03b1\nzx : z \u2208 ball x \u03b5\u2081\n\u22a2 z \u2208 ball y \u03b5\u2082", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z\u271d : \u03b1\n\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\ns : Set \u03b1\nh : dist x y \u2264 \u03b5\u2082 - \u03b5\u2081\nz : \u03b1\nzx : z \u2208 ball x \u03b5\u2081\n\u22a2 z \u2208 ball y (\u03b5\u2081 + (\u03b5\u2082 - \u03b5\u2081))"}, {"tactic": "exact lt_of_le_of_lt (dist_triangle z x y) (add_lt_add_of_lt_of_le zx h)", "annotated_tactic": ["exact <a>lt_of_le_of_lt</a> (<a>dist_triangle</a> z x y) (<a>add_lt_add_of_lt_of_le</a> zx h)", [{"full_name": "lt_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}, {"full_name": "dist_triangle", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [187, 9], "def_end_pos": [187, 22]}, {"full_name": "add_lt_add_of_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [178, 3], "def_end_pos": [178, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z\u271d : \u03b1\n\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\ns : Set \u03b1\nh : dist x y \u2264 \u03b5\u2082 - \u03b5\u2081\nz : \u03b1\nzx : z \u2208 ball x \u03b5\u2081\n\u22a2 z \u2208 ball y (\u03b5\u2081 + (\u03b5\u2082 - \u03b5\u2081))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "top_eq_true", "start": [911, 1], "end": [912, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "full_name": "Subgroup.mem_pointwise_smul_iff_inv_smul_mem", "start": [382, 1], "end": [384, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Finite.lean", "full_name": "Nat.card_eq_fintype_card", "start": [41, 1], "end": [42, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Cast/Basic.lean", "full_name": "Int.cast_zero", "start": [59, 1], "end": [60, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Trace.lean", "full_name": "Algebra.trace_eq_zero_of_not_exists_basis", "start": [103, 1], "end": [104, 70], "traced_tactics": [{"tactic": "ext s", "annotated_tactic": ["ext s", []], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing T\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R S\nh : \u00ac\u2203 s, Nonempty (Basis { x // x \u2208 s } R S)\n\u22a2 trace R S = 0", "state_after": "case h\nR : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing T\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R S\nh : \u00ac\u2203 s, Nonempty (Basis { x // x \u2208 s } R S)\ns : S\n\u22a2 (trace R S) s = 0 s"}, {"tactic": "simp [trace_apply, LinearMap.trace, h]", "annotated_tactic": ["simp [<a>trace_apply</a>, <a>LinearMap.trace</a>, h]", [{"full_name": "Algebra.trace_apply", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Trace.lean", "def_pos": [99, 9], "def_end_pos": [99, 20]}, {"full_name": "LinearMap.trace", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Trace.lean", "def_pos": [78, 5], "def_end_pos": [78, 10]}]], "state_before": "case h\nR : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing T\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d : Fintype \u03b9\nb : Basis \u03b9 R S\nh : \u00ac\u2203 s, Nonempty (Basis { x // x \u2208 s } R S)\ns : S\n\u22a2 (trace R S) s = 0 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Real.sqrtTwoAddSeries_two", "start": [701, 1], "end": [701, 83], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "x : \u211d\n\u22a2 sqrtTwoAddSeries 0 2 = sqrt (2 + sqrt 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.prod_insert", "start": [182, 1], "end": [193, 28], "traced_tactics": [{"tactic": "ext \u27e8x, y\u27e9", "annotated_tactic": ["ext \u27e8x, y\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 s \u00d7\u02e2 insert b t = (fun a => (a, b)) '' s \u222a s \u00d7\u02e2 t", "state_after": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 s \u00d7\u02e2 insert b t \u2194 (x, y) \u2208 (fun a => (a, b)) '' s \u222a s \u00d7\u02e2 t"}, {"tactic": "simp only [mem_prod, mem_insert_iff, image, mem_union, mem_setOf_eq, Prod.mk.injEq]", "annotated_tactic": ["simp only [<a>mem_prod</a>, <a>mem_insert_iff</a>, <a>image</a>, <a>mem_union</a>, <a>mem_setOf_eq</a>, Prod.mk.injEq]", [{"full_name": "Set.mem_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [207, 9], "def_end_pos": [207, 17]}, {"full_name": "Set.mem_insert_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1117, 9], "def_end_pos": [1117, 23]}, {"full_name": "Set.image", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [204, 5], "def_end_pos": [204, 10]}, {"full_name": "Set.mem_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 18]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}]], "state_before": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 s \u00d7\u02e2 insert b t \u2194 (x, y) \u2208 (fun a => (a, b)) '' s \u222a s \u00d7\u02e2 t", "state_after": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 x \u2208 s \u2227 (y = b \u2228 y \u2208 t) \u2194 (\u2203 a \u2208 s, a = x \u2227 b = y) \u2228 x \u2208 s \u2227 y \u2208 t"}, {"tactic": "refine \u27e8fun h => ?_, fun h => ?_\u27e9", "annotated_tactic": ["refine \u27e8fun h => ?_, fun h => ?_\u27e9", []], "state_before": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 x \u2208 s \u2227 (y = b \u2228 y \u2208 t) \u2194 (\u2203 a \u2208 s, a = x \u2227 b = y) \u2228 x \u2208 s \u2227 y \u2208 t", "state_after": "case h.mk.refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\nh : x \u2208 s \u2227 (y = b \u2228 y \u2208 t)\n\u22a2 (\u2203 a \u2208 s, a = x \u2227 b = y) \u2228 x \u2208 s \u2227 y \u2208 t\n\ncase h.mk.refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\nh : (\u2203 a \u2208 s, a = x \u2227 b = y) \u2228 x \u2208 s \u2227 y \u2208 t\n\u22a2 x \u2208 s \u2227 (y = b \u2228 y \u2208 t)"}, {"tactic": "obtain \u27e8hx, rfl|hy\u27e9 := h", "annotated_tactic": ["obtain \u27e8hx, rfl|hy\u27e9 := h", []], "state_before": "case h.mk.refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\nh : x \u2208 s \u2227 (y = b \u2228 y \u2208 t)\n\u22a2 (\u2203 a \u2208 s, a = x \u2227 b = y) \u2228 x \u2208 s \u2227 y \u2208 t", "state_after": "case h.mk.refine_1.intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na x : \u03b1\ny : \u03b2\nhx : x \u2208 s\n\u22a2 (\u2203 a \u2208 s, a = x \u2227 y = y) \u2228 x \u2208 s \u2227 y \u2208 t\n\ncase h.mk.refine_1.intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\nhx : x \u2208 s\nhy : y \u2208 t\n\u22a2 (\u2203 a \u2208 s, a = x \u2227 b = y) \u2228 x \u2208 s \u2227 y \u2208 t"}, {"tactic": "exact Or.inl \u27e8x, hx, rfl, rfl\u27e9", "annotated_tactic": ["exact <a>Or.inl</a> \u27e8x, hx, <a>rfl</a>, <a>rfl</a>\u27e9", [{"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case h.mk.refine_1.intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na x : \u03b1\ny : \u03b2\nhx : x \u2208 s\n\u22a2 (\u2203 a \u2208 s, a = x \u2227 y = y) \u2228 x \u2208 s \u2227 y \u2208 t", "state_after": "no goals"}, {"tactic": "exact Or.inr \u27e8hx, hy\u27e9", "annotated_tactic": ["exact <a>Or.inr</a> \u27e8hx, hy\u27e9", [{"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}]], "state_before": "case h.mk.refine_1.intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\nhx : x \u2208 s\nhy : y \u2208 t\n\u22a2 (\u2203 a \u2208 s, a = x \u2227 b = y) \u2228 x \u2208 s \u2227 y \u2208 t", "state_after": "no goals"}, {"tactic": "obtain \u27e8x, hx, rfl, rfl\u27e9|\u27e8hx, hy\u27e9 := h", "annotated_tactic": ["obtain \u27e8x, hx, rfl, rfl\u27e9|\u27e8hx, hy\u27e9 := h", []], "state_before": "case h.mk.refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\nh : (\u2203 a \u2208 s, a = x \u2227 b = y) \u2228 x \u2208 s \u2227 y \u2208 t\n\u22a2 x \u2208 s \u2227 (y = b \u2228 y \u2208 t)", "state_after": "case h.mk.refine_2.inl.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\nhx : x \u2208 s\n\u22a2 x \u2208 s \u2227 (b = b \u2228 b \u2208 t)\n\ncase h.mk.refine_2.inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\nhx : x \u2208 s\nhy : y \u2208 t\n\u22a2 x \u2208 s \u2227 (y = b \u2228 y \u2208 t)"}, {"tactic": "exact \u27e8hx, Or.inl rfl\u27e9", "annotated_tactic": ["exact \u27e8hx, <a>Or.inl</a> <a>rfl</a>\u27e9", [{"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case h.mk.refine_2.inl.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\nhx : x \u2208 s\n\u22a2 x \u2208 s \u2227 (b = b \u2228 b \u2208 t)", "state_after": "no goals"}, {"tactic": "exact \u27e8hx, Or.inr hy\u27e9", "annotated_tactic": ["exact \u27e8hx, <a>Or.inr</a> hy\u27e9", [{"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}]], "state_before": "case h.mk.refine_2.inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\nhx : x \u2208 s\nhy : y \u2208 t\n\u22a2 x \u2208 s \u2227 (y = b \u2228 y \u2208 t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Finiteness.lean", "full_name": "Group.fg_iff", "start": [304, 1], "end": [305, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Defs.lean", "full_name": "mul_self_ne_zero", "start": [272, 1], "end": [272, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/EMetricSpace/Basic.lean", "full_name": "uniformity_edist", "start": [1113, 1], "end": [1114, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "dist_pi_const", "start": [1967, 1], "end": [1968, 78], "traced_tactics": [{"tactic": "simpa only [dist_edist] using congr_arg ENNReal.toReal (edist_pi_const a b)", "annotated_tactic": ["simpa only [<a>dist_edist</a>] using <a>congr_arg</a> <a>ENNReal.toReal</a> (<a>edist_pi_const</a> a b)", [{"full_name": "dist_edist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [391, 9], "def_end_pos": [391, 19]}, {"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "ENNReal.toReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [194, 25], "def_end_pos": [194, 31]}, {"full_name": "edist_pi_const", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean", "def_pos": [501, 9], "def_end_pos": [501, 23]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\ninst\u271d : Nonempty \u03b2\na b : \u03b1\n\u22a2 (dist (fun x => a) fun x => b) = dist a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Exponent.lean", "full_name": "Group.exponent_dvd_nat_card", "start": [562, 1], "end": [563, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Tower.lean", "full_name": "FiniteDimensional.trans", "start": [51, 1], "end": [52, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Units.lean", "full_name": "Int.units_natAbs", "start": [23, 1], "end": [27, 47], "traced_tactics": [{"tactic": "rw [\u2190 natAbs_mul, Units.mul_inv]", "annotated_tactic": ["rw [\u2190 <a>natAbs_mul</a>, <a>Units.mul_inv</a>]", [{"full_name": "Int.natAbs_mul", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [431, 9], "def_end_pos": [431, 19]}, {"full_name": "Units.mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [255, 9], "def_end_pos": [255, 16]}]], "state_before": "u : \u2124\u02e3\n\u22a2 natAbs \u2191u * natAbs \u2191u\u207b\u00b9 = 1", "state_after": "u : \u2124\u02e3\n\u22a2 natAbs 1 = 1"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "u : \u2124\u02e3\n\u22a2 natAbs 1 = 1", "state_after": "no goals"}, {"tactic": "rw [\u2190 natAbs_mul, Units.inv_mul]", "annotated_tactic": ["rw [\u2190 <a>natAbs_mul</a>, <a>Units.inv_mul</a>]", [{"full_name": "Int.natAbs_mul", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [431, 9], "def_end_pos": [431, 19]}, {"full_name": "Units.inv_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [249, 9], "def_end_pos": [249, 16]}]], "state_before": "u : \u2124\u02e3\n\u22a2 natAbs \u2191u\u207b\u00b9 * natAbs \u2191u = 1", "state_after": "u : \u2124\u02e3\n\u22a2 natAbs 1 = 1"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/Compact.lean", "full_name": "isClosedMap_snd_of_compactSpace", "start": [879, 1], "end": [889, 33], "traced_tactics": [{"tactic": "rw [\u2190 isOpen_compl_iff, isOpen_iff_mem_nhds]", "annotated_tactic": ["rw [\u2190 <a>isOpen_compl_iff</a>, <a>isOpen_iff_mem_nhds</a>]", [{"full_name": "isOpen_compl_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [161, 17], "def_end_pos": [161, 33]}, {"full_name": "isOpen_iff_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1183, 9], "def_end_pos": [1183, 28]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs : IsClosed s\n\u22a2 IsClosed (Prod.snd '' s)", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs : IsClosed s\n\u22a2 \u2200 x \u2208 (Prod.snd '' s)\u1d9c, (Prod.snd '' s)\u1d9c \u2208 \ud835\udcdd x"}, {"tactic": "intro y hy", "annotated_tactic": ["intro y hy", []], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs : IsClosed s\n\u22a2 \u2200 x \u2208 (Prod.snd '' s)\u1d9c, (Prod.snd '' s)\u1d9c \u2208 \ud835\udcdd x", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\n\u22a2 (Prod.snd '' s)\u1d9c \u2208 \ud835\udcdd y"}, {"tactic": "have : univ \u00d7\u02e2 {y} \u2286 s\u1d9c := by\n  exact fun (x, y') \u27e8_, rfl\u27e9 hs => hy \u27e8(x, y'), hs, rfl\u27e9", "annotated_tactic": ["have : <a>univ</a> \u00d7\u02e2 {y} \u2286 s\u1d9c := by\n    exact fun (x, y') \u27e8_, <a>rfl</a>\u27e9 hs => hy \u27e8(x, y'), hs, <a>rfl</a>\u27e9", [{"full_name": "Set.univ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [153, 5], "def_end_pos": [153, 9]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\n\u22a2 (Prod.snd '' s)\u1d9c \u2208 \ud835\udcdd y", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\nthis : univ \u00d7\u02e2 {y} \u2286 s\u1d9c\n\u22a2 (Prod.snd '' s)\u1d9c \u2208 \ud835\udcdd y"}, {"tactic": "rcases generalized_tube_lemma isCompact_univ isCompact_singleton hs.isOpen_compl this\n  with \u27e8U, V, -, hVo, hU, hV, hs\u27e9", "annotated_tactic": ["rcases <a>generalized_tube_lemma</a> <a>isCompact_univ</a> <a>isCompact_singleton</a> hs.isOpen_compl this\n    with \u27e8U, V, -, hVo, hU, hV, hs\u27e9", [{"full_name": "generalized_tube_lemma", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/Compact.lean", "def_pos": [689, 9], "def_end_pos": [689, 31]}, {"full_name": "isCompact_univ", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/Compact.lean", "def_pos": [707, 9], "def_end_pos": [707, 23]}, {"full_name": "isCompact_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/Compact.lean", "def_pos": [442, 9], "def_end_pos": [442, 28]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\nthis : univ \u00d7\u02e2 {y} \u2286 s\u1d9c\n\u22a2 (Prod.snd '' s)\u1d9c \u2208 \ud835\udcdd y", "state_after": "case intro.intro.intro.intro.intro.intro\nX : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs\u271d : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\nthis : univ \u00d7\u02e2 {y} \u2286 s\u1d9c\nU : Set X\nV : Set Y\nhVo : IsOpen V\nhU : univ \u2286 U\nhV : {y} \u2286 V\nhs : U \u00d7\u02e2 V \u2286 s\u1d9c\n\u22a2 (Prod.snd '' s)\u1d9c \u2208 \ud835\udcdd y"}, {"tactic": "refine mem_nhds_iff.2 \u27e8V, ?_, hVo, hV rfl\u27e9", "annotated_tactic": ["refine <a>mem_nhds_iff</a>.2 \u27e8V, ?_, hVo, hV <a>rfl</a>\u27e9", [{"full_name": "mem_nhds_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [824, 9], "def_end_pos": [824, 21]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro.intro.intro.intro.intro.intro\nX : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs\u271d : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\nthis : univ \u00d7\u02e2 {y} \u2286 s\u1d9c\nU : Set X\nV : Set Y\nhVo : IsOpen V\nhU : univ \u2286 U\nhV : {y} \u2286 V\nhs : U \u00d7\u02e2 V \u2286 s\u1d9c\n\u22a2 (Prod.snd '' s)\u1d9c \u2208 \ud835\udcdd y", "state_after": "case intro.intro.intro.intro.intro.intro\nX : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs\u271d : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\nthis : univ \u00d7\u02e2 {y} \u2286 s\u1d9c\nU : Set X\nV : Set Y\nhVo : IsOpen V\nhU : univ \u2286 U\nhV : {y} \u2286 V\nhs : U \u00d7\u02e2 V \u2286 s\u1d9c\n\u22a2 V \u2286 (Prod.snd '' s)\u1d9c"}, {"tactic": "rintro _ hzV \u27e8z, hzs, rfl\u27e9", "annotated_tactic": ["rintro _ hzV \u27e8z, hzs, rfl\u27e9", []], "state_before": "case intro.intro.intro.intro.intro.intro\nX : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs\u271d : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\nthis : univ \u00d7\u02e2 {y} \u2286 s\u1d9c\nU : Set X\nV : Set Y\nhVo : IsOpen V\nhU : univ \u2286 U\nhV : {y} \u2286 V\nhs : U \u00d7\u02e2 V \u2286 s\u1d9c\n\u22a2 V \u2286 (Prod.snd '' s)\u1d9c", "state_after": "case intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs\u271d : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\nthis : univ \u00d7\u02e2 {y} \u2286 s\u1d9c\nU : Set X\nV : Set Y\nhVo : IsOpen V\nhU : univ \u2286 U\nhV : {y} \u2286 V\nhs : U \u00d7\u02e2 V \u2286 s\u1d9c\nz : X \u00d7 Y\nhzs : z \u2208 s\nhzV : z.2 \u2208 V\n\u22a2 False"}, {"tactic": "exact hs \u27e8hU trivial, hzV\u27e9 hzs", "annotated_tactic": ["exact hs \u27e8hU <a>trivial</a>, hzV\u27e9 hzs", [{"full_name": "trivial", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [643, 31], "def_end_pos": [643, 38]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro.intro\nX : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs\u271d : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\nthis : univ \u00d7\u02e2 {y} \u2286 s\u1d9c\nU : Set X\nV : Set Y\nhVo : IsOpen V\nhU : univ \u2286 U\nhV : {y} \u2286 V\nhs : U \u00d7\u02e2 V \u2286 s\u1d9c\nz : X \u00d7 Y\nhzs : z \u2208 s\nhzV : z.2 \u2208 V\n\u22a2 False", "state_after": "no goals"}, {"tactic": "exact fun (x, y') \u27e8_, rfl\u27e9 hs => hy \u27e8(x, y'), hs, rfl\u27e9", "annotated_tactic": ["exact fun (x, y') \u27e8_, <a>rfl</a>\u27e9 hs => hy \u27e8(x, y'), hs, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ns\u271d t : Set X\ninst\u271d : CompactSpace X\ns : Set (X \u00d7 Y)\nhs : IsClosed s\ny : Y\nhy : y \u2208 (Prod.snd '' s)\u1d9c\n\u22a2 univ \u00d7\u02e2 {y} \u2286 s\u1d9c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.range_const_subset", "start": [990, 1], "end": [991, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/IsometricSMul.lean", "full_name": "edist_div_right", "start": [121, 1], "end": [123, 46], "traced_tactics": [{"tactic": "simp only [div_eq_mul_inv, edist_mul_right]", "annotated_tactic": ["simp only [<a>div_eq_mul_inv</a>, <a>edist_mul_right</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "edist_mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/IsometricSMul.lean", "def_pos": [114, 9], "def_end_pos": [114, 24]}]], "state_before": "M : Type u\nG : Type v\nX : Type w\ninst\u271d\u2076 : PseudoEMetricSpace X\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : MulAction G X\ninst\u271d\u00b3 : IsometricSMul G X\ninst\u271d\u00b2 : DivInvMonoid M\ninst\u271d\u00b9 : PseudoEMetricSpace M\ninst\u271d : IsometricSMul M\u1d50\u1d52\u1d56 M\na b c : M\n\u22a2 edist (a / c) (b / c) = edist a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.disjoint_comap_iff", "start": [2541, 1], "end": [2543, 74], "traced_tactics": [{"tactic": "rw [disjoint_iff, disjoint_iff, \u2190 comap_inf, comap_surjective_eq_bot h]", "annotated_tactic": ["rw [<a>disjoint_iff</a>, <a>disjoint_iff</a>, \u2190 <a>comap_inf</a>, <a>comap_surjective_eq_bot</a> h]", [{"full_name": "disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "Filter.comap_inf", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2365, 17], "def_end_pos": [2365, 26]}, {"full_name": "Filter.comap_surjective_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2536, 9], "def_end_pos": [2536, 32]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nh : Surjective m\n\u22a2 Disjoint (comap m g\u2081) (comap m g\u2082) \u2194 Disjoint g\u2081 g\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "Filter.Eventually.prod_inr_nhds", "start": [493, 1], "end": [495, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Isometry.lean", "full_name": "linear_isometry_complex_aux", "start": [125, 1], "end": [139, 35], "traced_tactics": [{"tactic": "simp only [ext_iff, \u2190 and_or_left, neg_re, I_re, neg_im, neg_zero]", "annotated_tactic": ["simp only [<a>ext_iff</a>, \u2190 <a>and_or_left</a>, <a>neg_re</a>, <a>I_re</a>, <a>neg_im</a>, <a>neg_zero</a>]", [{"full_name": "Complex.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 16]}, {"full_name": "and_or_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [90, 9], "def_end_pos": [90, 20]}, {"full_name": "Complex.neg_re", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [247, 9], "def_end_pos": [247, 15]}, {"full_name": "Complex.I_re", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [305, 9], "def_end_pos": [305, 13]}, {"full_name": "Complex.neg_im", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [252, 9], "def_end_pos": [252, 15]}, {"full_name": "neg_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1034, 3], "def_end_pos": [1034, 14]}]], "state_before": "f : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 f I = I \u2228 f I = -I", "state_after": "f : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 (f I).re = 0 \u2227 ((f I).im = I.im \u2228 (f I).im = -I.im)"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "f : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 (f I).re = 0 \u2227 ((f I).im = I.im \u2228 (f I).im = -I.im)", "state_after": "case left\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 (f I).re = 0\n\ncase right\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 (f I).im = I.im \u2228 (f I).im = -I.im"}, {"tactic": "rw [\u2190 I_re]", "annotated_tactic": ["rw [\u2190 <a>I_re</a>]", [{"full_name": "Complex.I_re", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [305, 9], "def_end_pos": [305, 13]}]], "state_before": "case left\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 (f I).re = 0", "state_after": "case left\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 (f I).re = I.re"}, {"tactic": "exact @LinearIsometry.re_apply_eq_re f.toLinearIsometry h I", "annotated_tactic": ["exact @<a>LinearIsometry.re_apply_eq_re</a> f.toLinearIsometry h <a>I</a>", [{"full_name": "LinearIsometry.re_apply_eq_re", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean", "def_pos": [119, 9], "def_end_pos": [119, 38]}, {"full_name": "Complex.I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [299, 5], "def_end_pos": [299, 6]}]], "state_before": "case left\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 (f I).re = I.re", "state_after": "no goals"}, {"tactic": "apply @LinearIsometry.im_apply_eq_im_or_neg_of_re_apply_eq_re f.toLinearIsometry", "annotated_tactic": ["apply @<a>LinearIsometry.im_apply_eq_im_or_neg_of_re_apply_eq_re</a> f.toLinearIsometry", [{"full_name": "LinearIsometry.im_apply_eq_im_or_neg_of_re_apply_eq_re", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean", "def_pos": [96, 9], "def_end_pos": [96, 63]}]], "state_before": "case right\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 (f I).im = I.im \u2228 (f I).im = -I.im", "state_after": "case right.h\u2082\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 \u2200 (z : \u2102), ((LinearIsometryEquiv.toLinearIsometry f) z).re = z.re"}, {"tactic": "intro z", "annotated_tactic": ["intro z", []], "state_before": "case right.h\u2082\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 \u2200 (z : \u2102), ((LinearIsometryEquiv.toLinearIsometry f) z).re = z.re", "state_after": "case right.h\u2082\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 ((LinearIsometryEquiv.toLinearIsometry f) z).re = z.re"}, {"tactic": "rw [@LinearIsometry.re_apply_eq_re f.toLinearIsometry h]", "annotated_tactic": ["rw [@<a>LinearIsometry.re_apply_eq_re</a> f.toLinearIsometry h]", [{"full_name": "LinearIsometry.re_apply_eq_re", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean", "def_pos": [119, 9], "def_end_pos": [119, 38]}]], "state_before": "case right.h\u2082\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 ((LinearIsometryEquiv.toLinearIsometry f) z).re = z.re", "state_after": "no goals"}, {"tactic": "apply LinearIsometryEquiv.toLinearEquiv_injective", "annotated_tactic": ["apply <a>LinearIsometryEquiv.toLinearEquiv_injective</a>", [{"full_name": "LinearIsometryEquiv.toLinearEquiv_injective", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "def_pos": [546, 9], "def_end_pos": [546, 32]}]], "state_before": "case refine'_2\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nh0 : f I = I \u2228 f I = -I\nh' : f I = -I\n\u22a2 f = conjLIE", "state_after": "case refine'_2.a\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nh0 : f I = I \u2228 f I = -I\nh' : f I = -I\n\u22a2 f.toLinearEquiv = conjLIE.toLinearEquiv"}, {"tactic": "apply Complex.basisOneI.ext'", "annotated_tactic": ["apply Complex.basisOneI.ext'", []], "state_before": "case refine'_2.a\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nh0 : f I = I \u2228 f I = -I\nh' : f I = -I\n\u22a2 f.toLinearEquiv = conjLIE.toLinearEquiv", "state_after": "case refine'_2.a\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nh0 : f I = I \u2228 f I = -I\nh' : f I = -I\n\u22a2 \u2200 (i : Fin 2), f.toLinearEquiv (basisOneI i) = conjLIE.toLinearEquiv (basisOneI i)"}, {"tactic": "intro i", "annotated_tactic": ["intro i", []], "state_before": "case refine'_2.a\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nh0 : f I = I \u2228 f I = -I\nh' : f I = -I\n\u22a2 \u2200 (i : Fin 2), f.toLinearEquiv (basisOneI i) = conjLIE.toLinearEquiv (basisOneI i)", "state_after": "case refine'_2.a\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nh0 : f I = I \u2228 f I = -I\nh' : f I = -I\ni : Fin 2\n\u22a2 f.toLinearEquiv (basisOneI i) = conjLIE.toLinearEquiv (basisOneI i)"}, {"tactic": "fin_cases i <;> simp [h, h']", "annotated_tactic": ["fin_cases i <;> simp [h, h']", []], "state_before": "case refine'_2.a\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nh0 : f I = I \u2228 f I = -I\nh' : f I = -I\ni : Fin 2\n\u22a2 f.toLinearEquiv (basisOneI i) = conjLIE.toLinearEquiv (basisOneI i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "toIocMod_add_right_eq_add", "start": [542, 1], "end": [543, 75], "traced_tactics": [{"tactic": "simp_rw [toIocMod, toIocDiv_sub_eq_toIocDiv_add', sub_add_eq_add_sub]", "annotated_tactic": ["simp_rw [<a>toIocMod</a>, <a>toIocDiv_sub_eq_toIocDiv_add'</a>, <a>sub_add_eq_add_sub</a>]", [{"full_name": "toIocMod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [79, 5], "def_end_pos": [79, 13]}, {"full_name": "toIocDiv_sub_eq_toIocDiv_add'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [374, 9], "def_end_pos": [374, 38]}, {"full_name": "sub_add_eq_add_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [626, 3], "def_end_pos": [626, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b\u271d c\u271d : \u03b1\nn : \u2124\na b c : \u03b1\n\u22a2 toIocMod hp a (b + c) = toIocMod hp (a - c) b + c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Hom.lean", "full_name": "AlgHom.comp_id", "start": [343, 1], "end": [344, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.monotone_iff", "start": [1201, 1], "end": [1206, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Lemmas.lean", "full_name": "Polynomial.coeff_add_eq_right_of_lt", "start": [194, 1], "end": [196, 35], "traced_tactics": [{"tactic": "rw [add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npn : natDegree p < n\n\u22a2 coeff (p + q) n = coeff q n", "state_after": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npn : natDegree p < n\n\u22a2 coeff (q + p) n = coeff q n"}, {"tactic": "exact coeff_add_eq_left_of_lt pn", "annotated_tactic": ["exact <a>coeff_add_eq_left_of_lt</a> pn", [{"full_name": "Polynomial.coeff_add_eq_left_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Lemmas.lean", "def_pos": [189, 9], "def_end_pos": [189, 32]}]], "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npn : natDegree p < n\n\u22a2 coeff (q + p) n = coeff q n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Basic.lean", "full_name": "IsLocalization.smul_mk'", "start": [436, 1], "end": [438, 42], "traced_tactics": [{"tactic": "nth_rw 2 [\u2190 one_mul m]", "annotated_tactic": ["nth_rw 2 [\u2190 <a>one_mul</a> m]", [{"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nx y : R\nm : \u21a5M\n\u22a2 x \u2022 mk' S y m = mk' S (x * y) m", "state_after": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nx y : R\nm : \u21a5M\n\u22a2 x \u2022 mk' S y m = mk' S (x * y) (1 * m)"}, {"tactic": "rw [mk'_mul, mk'_one, Algebra.smul_def]", "annotated_tactic": ["rw [<a>mk'_mul</a>, <a>mk'_one</a>, <a>Algebra.smul_def</a>]", [{"full_name": "IsLocalization.mk'_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [255, 9], "def_end_pos": [255, 16]}, {"full_name": "IsLocalization.mk'_one", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [259, 9], "def_end_pos": [259, 16]}, {"full_name": "Algebra.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nx y : R\nm : \u21a5M\n\u22a2 x \u2022 mk' S y m = mk' S (x * y) (1 * m)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Iic_injective", "start": [982, 1], "end": [983, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/LocalExtr.lean", "full_name": "IsLocalMax.add", "start": [370, 8], "end": [372, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Thickening.lean", "full_name": "Metric.closedBall_subset_cthickening_singleton", "start": [254, 1], "end": [258, 55], "traced_tactics": [{"tactic": "rcases lt_or_le \u03b4 0 with (h\u03b4 | h\u03b4)", "annotated_tactic": ["rcases <a>lt_or_le</a> \u03b4 0 with (h\u03b4 | h\u03b4)", [{"full_name": "lt_or_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [330, 9], "def_end_pos": [330, 17]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\u271d\nx\u271d : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\n\u22a2 closedBall x \u03b4 \u2286 cthickening \u03b4 {x}", "state_after": "case inl\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\u271d\nx\u271d : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : \u03b4 < 0\n\u22a2 closedBall x \u03b4 \u2286 cthickening \u03b4 {x}\n\ncase inr\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\u271d\nx\u271d : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\n\u22a2 closedBall x \u03b4 \u2286 cthickening \u03b4 {x}"}, {"tactic": "simp only [closedBall_eq_empty.mpr h\u03b4, empty_subset]", "annotated_tactic": ["simp only [closedBall_eq_empty.mpr h\u03b4, <a>empty_subset</a>]", [{"full_name": "Set.empty_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [548, 9], "def_end_pos": [548, 21]}]], "state_before": "case inl\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\u271d\nx\u271d : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : \u03b4 < 0\n\u22a2 closedBall x \u03b4 \u2286 cthickening \u03b4 {x}", "state_after": "no goals"}, {"tactic": "simp only [cthickening_singleton x h\u03b4, Subset.rfl]", "annotated_tactic": ["simp only [<a>cthickening_singleton</a> x h\u03b4, <a>Subset.rfl</a>]", [{"full_name": "Metric.cthickening_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [248, 9], "def_end_pos": [248, 30]}, {"full_name": "Set.Subset.rfl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [338, 9], "def_end_pos": [338, 19]}]], "state_before": "case inr\n\u03b9 : Sort u_1\n\u03b1\u271d : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\u271d\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\u271d\nx\u271d : \u03b1\u271d\n\u03b1 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b4 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\n\u22a2 closedBall x \u03b4 \u2286 cthickening \u03b4 {x}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Complex.tan_add_pi", "start": [1278, 1], "end": [1279, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/ModEq.lean", "full_name": "AddCommGroup.ModEq.add_nsmul", "start": [141, 11], "end": [142, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "DoubleQuot.quotQuotEquivComm_symm", "start": [743, 1], "end": [753, 6], "traced_tactics": [{"tactic": "change (((quotQuotEquivQuotSup I J).trans (quotEquivOfEq (sup_comm ..))).trans\n  (quotQuotEquivQuotSup J I).symm).symm =\n    ((quotQuotEquivQuotSup J I).trans (quotEquivOfEq (sup_comm ..))).trans\n      (quotQuotEquivQuotSup I J).symm", "annotated_tactic": ["change (((<a>quotQuotEquivQuotSup</a> I J).<a>trans</a> (<a>quotEquivOfEq</a> (<a>sup_comm</a> ..))).<a>trans</a>\n    (<a>quotQuotEquivQuotSup</a> J I).<a>symm</a>).<a>symm</a> =\n      ((<a>quotQuotEquivQuotSup</a> J I).<a>trans</a> (<a>quotEquivOfEq</a> (<a>sup_comm</a> ..))).<a>trans</a>\n        (<a>quotQuotEquivQuotSup</a> I J).<a>symm</a>", [{"full_name": "DoubleQuot.quotQuotEquivQuotSup", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [699, 5], "def_end_pos": [699, 25]}, {"full_name": "RingEquiv.trans", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean", "def_pos": [319, 15], "def_end_pos": [319, 20]}, {"full_name": "Ideal.quotEquivOfEq", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [300, 5], "def_end_pos": [300, 18]}, {"full_name": "sup_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}, {"full_name": "RingEquiv.trans", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean", "def_pos": [319, 15], "def_end_pos": [319, 20]}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [699, 5], "def_end_pos": [699, 25]}, {"full_name": "RingEquiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean", "def_pos": [267, 15], "def_end_pos": [267, 19]}, {"full_name": "RingEquiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean", "def_pos": [267, 15], "def_end_pos": [267, 19]}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [699, 5], "def_end_pos": [699, 25]}, {"full_name": "RingEquiv.trans", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean", "def_pos": [319, 15], "def_end_pos": [319, 20]}, {"full_name": "Ideal.quotEquivOfEq", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [300, 5], "def_end_pos": [300, 18]}, {"full_name": "sup_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}, {"full_name": "RingEquiv.trans", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean", "def_pos": [319, 15], "def_end_pos": [319, 20]}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [699, 5], "def_end_pos": [699, 25]}, {"full_name": "RingEquiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean", "def_pos": [267, 15], "def_end_pos": [267, 19]}]], "state_before": "R : Type u\ninst\u271d : CommRing R\nI J : Ideal R\n\u22a2 RingEquiv.symm (quotQuotEquivComm I J) = quotQuotEquivComm J I", "state_after": "R : Type u\ninst\u271d : CommRing R\nI J : Ideal R\n\u22a2 RingEquiv.symm\n      (RingEquiv.trans (RingEquiv.trans (quotQuotEquivQuotSup I J) (quotEquivOfEq \u22ef))\n        (RingEquiv.symm (quotQuotEquivQuotSup J I))) =\n    RingEquiv.trans (RingEquiv.trans (quotQuotEquivQuotSup J I) (quotEquivOfEq \u22ef))\n      (RingEquiv.symm (quotQuotEquivQuotSup I J))"}, {"tactic": "ext r", "annotated_tactic": ["ext r", []], "state_before": "R : Type u\ninst\u271d : CommRing R\nI J : Ideal R\n\u22a2 RingEquiv.symm\n      (RingEquiv.trans (RingEquiv.trans (quotQuotEquivQuotSup I J) (quotEquivOfEq \u22ef))\n        (RingEquiv.symm (quotQuotEquivQuotSup J I))) =\n    RingEquiv.trans (RingEquiv.trans (quotQuotEquivQuotSup J I) (quotEquivOfEq \u22ef))\n      (RingEquiv.symm (quotQuotEquivQuotSup I J))", "state_after": "case h\nR : Type u\ninst\u271d : CommRing R\nI J : Ideal R\nr : (R \u29f8 J) \u29f8 map (Ideal.Quotient.mk J) I\n\u22a2 (RingEquiv.symm\n        (RingEquiv.trans (RingEquiv.trans (quotQuotEquivQuotSup I J) (quotEquivOfEq \u22ef))\n          (RingEquiv.symm (quotQuotEquivQuotSup J I))))\n      r =\n    (RingEquiv.trans (RingEquiv.trans (quotQuotEquivQuotSup J I) (quotEquivOfEq \u22ef))\n        (RingEquiv.symm (quotQuotEquivQuotSup I J)))\n      r"}, {"tactic": "dsimp", "annotated_tactic": ["dsimp", []], "state_before": "case h\nR : Type u\ninst\u271d : CommRing R\nI J : Ideal R\nr : (R \u29f8 J) \u29f8 map (Ideal.Quotient.mk J) I\n\u22a2 (RingEquiv.symm\n        (RingEquiv.trans (RingEquiv.trans (quotQuotEquivQuotSup I J) (quotEquivOfEq \u22ef))\n          (RingEquiv.symm (quotQuotEquivQuotSup J I))))\n      r =\n    (RingEquiv.trans (RingEquiv.trans (quotQuotEquivQuotSup J I) (quotEquivOfEq \u22ef))\n        (RingEquiv.symm (quotQuotEquivQuotSup I J)))\n      r", "state_after": "case h\nR : Type u\ninst\u271d : CommRing R\nI J : Ideal R\nr : (R \u29f8 J) \u29f8 map (Ideal.Quotient.mk J) I\n\u22a2 (RingEquiv.symm (quotQuotEquivQuotSup I J))\n      ((RingEquiv.symm (quotEquivOfEq \u22ef)) ((RingEquiv.symm (RingEquiv.symm (quotQuotEquivQuotSup J I))) r)) =\n    (RingEquiv.symm (quotQuotEquivQuotSup I J)) ((quotEquivOfEq \u22ef) ((quotQuotEquivQuotSup J I) r))"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h\nR : Type u\ninst\u271d : CommRing R\nI J : Ideal R\nr : (R \u29f8 J) \u29f8 map (Ideal.Quotient.mk J) I\n\u22a2 (RingEquiv.symm (quotQuotEquivQuotSup I J))\n      ((RingEquiv.symm (quotEquivOfEq \u22ef)) ((RingEquiv.symm (RingEquiv.symm (quotQuotEquivQuotSup J I))) r)) =\n    (RingEquiv.symm (quotQuotEquivQuotSup I J)) ((quotEquivOfEq \u22ef) ((quotQuotEquivQuotSup J I) r))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "himp_eq", "start": [598, 1], "end": [599, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Basic.lean", "full_name": "Complex.div_int_cast", "start": [925, 1], "end": [926, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "ContDiffWithinAt.comp_continuousLinearMap", "start": [392, 1], "end": [398, 82], "traced_tactics": [{"tactic": "intro m hm", "annotated_tactic": ["intro m hm", []], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nx : G\ng : G \u2192L[\ud835\udd5c] E\nhf : ContDiffWithinAt \ud835\udd5c n f s (g x)\n\u22a2 ContDiffWithinAt \ud835\udd5c n (f \u2218 \u21d1g) (\u21d1g \u207b\u00b9' s) x", "state_after": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nx : G\ng : G \u2192L[\ud835\udd5c] E\nhf : ContDiffWithinAt \ud835\udd5c n f s (g x)\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x (\u21d1g \u207b\u00b9' s)] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) (f \u2218 \u21d1g) p u"}, {"tactic": "rcases hf m hm with \u27e8u, hu, p, hp\u27e9", "annotated_tactic": ["rcases hf m hm with \u27e8u, hu, p, hp\u27e9", []], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nx : G\ng : G \u2192L[\ud835\udd5c] E\nhf : ContDiffWithinAt \ud835\udd5c n f s (g x)\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x (\u21d1g \u207b\u00b9' s)] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) (f \u2218 \u21d1g) p u", "state_after": "case intro.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm\u271d n : \u2115\u221e\np\u271d : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nx : G\ng : G \u2192L[\ud835\udd5c] E\nhf : ContDiffWithinAt \ud835\udd5c n f s (g x)\nm : \u2115\nhm : \u2191m \u2264 n\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert (g x) s] g x\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhp : HasFTaylorSeriesUpToOn (\u2191m) f p u\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x (\u21d1g \u207b\u00b9' s)] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) (f \u2218 \u21d1g) p u"}, {"tactic": "refine \u27e8g \u207b\u00b9' u, ?_, _, hp.compContinuousLinearMap g\u27e9", "annotated_tactic": ["refine \u27e8g \u207b\u00b9' u, ?_, _, hp.compContinuousLinearMap g\u27e9", []], "state_before": "case intro.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm\u271d n : \u2115\u221e\np\u271d : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nx : G\ng : G \u2192L[\ud835\udd5c] E\nhf : ContDiffWithinAt \ud835\udd5c n f s (g x)\nm : \u2115\nhm : \u2191m \u2264 n\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert (g x) s] g x\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhp : HasFTaylorSeriesUpToOn (\u2191m) f p u\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x (\u21d1g \u207b\u00b9' s)] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) (f \u2218 \u21d1g) p u", "state_after": "case intro.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm\u271d n : \u2115\u221e\np\u271d : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nx : G\ng : G \u2192L[\ud835\udd5c] E\nhf : ContDiffWithinAt \ud835\udd5c n f s (g x)\nm : \u2115\nhm : \u2191m \u2264 n\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert (g x) s] g x\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhp : HasFTaylorSeriesUpToOn (\u2191m) f p u\n\u22a2 \u21d1g \u207b\u00b9' u \u2208 \ud835\udcdd[insert x (\u21d1g \u207b\u00b9' s)] x"}, {"tactic": "refine g.continuous.continuousWithinAt.tendsto_nhdsWithin ?_ hu", "annotated_tactic": ["refine g.continuous.continuousWithinAt.tendsto_nhdsWithin ?_ hu", []], "state_before": "case intro.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm\u271d n : \u2115\u221e\np\u271d : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nx : G\ng : G \u2192L[\ud835\udd5c] E\nhf : ContDiffWithinAt \ud835\udd5c n f s (g x)\nm : \u2115\nhm : \u2191m \u2264 n\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert (g x) s] g x\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhp : HasFTaylorSeriesUpToOn (\u2191m) f p u\n\u22a2 \u21d1g \u207b\u00b9' u \u2208 \ud835\udcdd[insert x (\u21d1g \u207b\u00b9' s)] x", "state_after": "case intro.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm\u271d n : \u2115\u221e\np\u271d : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nx : G\ng : G \u2192L[\ud835\udd5c] E\nhf : ContDiffWithinAt \ud835\udd5c n f s (g x)\nm : \u2115\nhm : \u2191m \u2264 n\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert (g x) s] g x\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhp : HasFTaylorSeriesUpToOn (\u2191m) f p u\n\u22a2 MapsTo (\u21d1g) (insert x (\u21d1g \u207b\u00b9' s)) (insert (g x) s)"}, {"tactic": "exact (mapsTo_singleton.2 <| mem_singleton _).union_union (mapsTo_preimage _ _)", "annotated_tactic": ["exact (<a>mapsTo_singleton</a>.2 <| <a>mem_singleton</a> _).<a>union_union</a> (<a>mapsTo_preimage</a> _ _)", [{"full_name": "Set.mapsTo_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [404, 9], "def_end_pos": [404, 25]}, {"full_name": "Set.mem_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1259, 9], "def_end_pos": [1259, 22]}, {"full_name": "Set.MapsTo.union_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [474, 9], "def_end_pos": [474, 27]}, {"full_name": "Set.mapsTo_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [273, 9], "def_end_pos": [273, 24]}]], "state_before": "case intro.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u\u271d : Set E\nf f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm\u271d n : \u2115\u221e\np\u271d : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nx : G\ng : G \u2192L[\ud835\udd5c] E\nhf : ContDiffWithinAt \ud835\udd5c n f s (g x)\nm : \u2115\nhm : \u2191m \u2264 n\nu : Set E\nhu : u \u2208 \ud835\udcdd[insert (g x) s] g x\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nhp : HasFTaylorSeriesUpToOn (\u2191m) f p u\n\u22a2 MapsTo (\u21d1g) (insert x (\u21d1g \u207b\u00b9' s)) (insert (g x) s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "Submodule.IsPrincipal.associated_generator_span_self", "start": [123, 1], "end": [126, 41], "traced_tactics": [{"tactic": "rw [\u2190 Ideal.span_singleton_eq_span_singleton]", "annotated_tactic": ["rw [\u2190 <a>Ideal.span_singleton_eq_span_singleton</a>]", [{"full_name": "Ideal.span_singleton_eq_span_singleton", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [515, 9], "def_end_pos": [515, 41]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nr : R\n\u22a2 Associated (generator (Ideal.span {r})) r", "state_after": "R : Type u\nM : Type v\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nr : R\n\u22a2 Ideal.span {generator (Ideal.span {r})} = Ideal.span {r}"}, {"tactic": "exact Ideal.span_singleton_generator _", "annotated_tactic": ["exact <a>Ideal.span_singleton_generator</a> _", [{"full_name": "Ideal.span_singleton_generator", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean", "def_pos": [97, 9], "def_end_pos": [97, 46]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nr : R\n\u22a2 Ideal.span {generator (Ideal.span {r})} = Ideal.span {r}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Basic.lean", "full_name": "algebraMap.coe_sum", "start": [192, 1], "end": [194, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "full_name": "ContinuousMultilinearMap.norm_mkPiAlgebraFin_zero", "start": [885, 1], "end": [890, 9], "traced_tactics": [{"tactic": "refine' le_antisymm _ _", "annotated_tactic": ["refine' <a>le_antisymm</a> _ _", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2076 : Fintype \u03b9\ninst\u271d\u00b9\u2075 : Fintype \u03b9'\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2077 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2075 : SeminormedAddCommGroup G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b3 : SeminormedAddCommGroup G'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G'\nA : Type u_1\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A\u2016 = \u20161\u2016", "state_after": "case refine'_1\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2076 : Fintype \u03b9\ninst\u271d\u00b9\u2075 : Fintype \u03b9'\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2077 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2075 : SeminormedAddCommGroup G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b3 : SeminormedAddCommGroup G'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G'\nA : Type u_1\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A\u2016 \u2264 \u20161\u2016\n\ncase refine'_2\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2076 : Fintype \u03b9\ninst\u271d\u00b9\u2075 : Fintype \u03b9'\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2077 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2075 : SeminormedAddCommGroup G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b3 : SeminormedAddCommGroup G'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G'\nA : Type u_1\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 \u20161\u2016 \u2264 \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A\u2016"}, {"tactic": "refine opNorm_le_bound _ (norm_nonneg (1 : A)) ?_", "annotated_tactic": ["refine <a>opNorm_le_bound</a> _ (<a>norm_nonneg</a> (1 : A)) ?_", [{"full_name": "ContinuousMultilinearMap.opNorm_le_bound", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "def_pos": [442, 9], "def_end_pos": [442, 24]}, {"full_name": "norm_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [551, 30], "def_end_pos": [551, 41]}]], "state_before": "case refine'_1\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2076 : Fintype \u03b9\ninst\u271d\u00b9\u2075 : Fintype \u03b9'\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2077 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2075 : SeminormedAddCommGroup G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b3 : SeminormedAddCommGroup G'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G'\nA : Type u_1\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A\u2016 \u2264 \u20161\u2016", "state_after": "case refine'_1\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2076 : Fintype \u03b9\ninst\u271d\u00b9\u2075 : Fintype \u03b9'\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2077 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2075 : SeminormedAddCommGroup G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b3 : SeminormedAddCommGroup G'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G'\nA : Type u_1\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 \u2200 (m : Fin 0 \u2192 A), \u2016(ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A) m\u2016 \u2264 \u20161\u2016 * \u220f i : Fin 0, \u2016m i\u2016"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case refine'_1\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2076 : Fintype \u03b9\ninst\u271d\u00b9\u2075 : Fintype \u03b9'\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2077 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2075 : SeminormedAddCommGroup G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b3 : SeminormedAddCommGroup G'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G'\nA : Type u_1\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 \u2200 (m : Fin 0 \u2192 A), \u2016(ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A) m\u2016 \u2264 \u20161\u2016 * \u220f i : Fin 0, \u2016m i\u2016", "state_after": "no goals"}, {"tactic": "convert ratio_le_opNorm (ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A) fun _ => (1 : A)", "annotated_tactic": ["convert <a>ratio_le_opNorm</a> (<a>ContinuousMultilinearMap.mkPiAlgebraFin</a> \ud835\udd5c 0 A) fun _ => (1 : A)", [{"full_name": "ContinuousMultilinearMap.ratio_le_opNorm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "def_pos": [423, 9], "def_end_pos": [423, 24]}, {"full_name": "ContinuousMultilinearMap.mkPiAlgebraFin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Multilinear/Basic.lean", "def_pos": [619, 15], "def_end_pos": [619, 29]}]], "state_before": "case refine'_2\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2076 : Fintype \u03b9\ninst\u271d\u00b9\u2075 : Fintype \u03b9'\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2077 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2075 : SeminormedAddCommGroup G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b3 : SeminormedAddCommGroup G'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G'\nA : Type u_1\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 \u20161\u2016 \u2264 \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A\u2016", "state_after": "case h.e'_3\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2076 : Fintype \u03b9\ninst\u271d\u00b9\u2075 : Fintype \u03b9'\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2077 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2075 : SeminormedAddCommGroup G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b3 : SeminormedAddCommGroup G'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G'\nA : Type u_1\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 \u20161\u2016 = \u2016(ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A) fun x => 1\u2016 / \u220f i : Fin 0, \u20161\u2016"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.e'_3\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2076 : Fintype \u03b9\ninst\u271d\u00b9\u2075 : Fintype \u03b9'\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2077 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2075 : SeminormedAddCommGroup G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b3 : SeminormedAddCommGroup G'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G'\nA : Type u_1\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 \u20161\u2016 = \u2016(ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c 0 A) fun x => 1\u2016 / \u220f i : Fin 0, \u20161\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "full_name": "AffineIsometry.id_apply", "start": [220, 1], "end": [221, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/UniqueProds.lean", "full_name": "UniqueProds.toIsCancelMul", "start": [366, 16], "end": [369, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.le_of_lt_minimalPeriod_of_iterate_eq", "start": [346, 1], "end": [355, 9], "traced_tactics": [{"tactic": "by_contra! hmn'", "annotated_tactic": ["by_contra! hmn'", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm\u271d n\u271d m n : \u2115\nhm : m < minimalPeriod f x\nhmn : f^[m] x = f^[n] x\n\u22a2 m \u2264 n", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm\u271d n\u271d m n : \u2115\nhm : m < minimalPeriod f x\nhmn : f^[m] x = f^[n] x\nhmn' : n < m\n\u22a2 False"}, {"tactic": "rw [\u2190 Nat.add_sub_of_le hmn'.le, add_comm, iterate_add_apply] at hmn", "annotated_tactic": ["rw [\u2190 <a>Nat.add_sub_of_le</a> hmn'.le, <a>add_comm</a>, <a>iterate_add_apply</a>] at hmn", [{"full_name": "Nat.add_sub_of_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [616, 9], "def_end_pos": [616, 22]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "Function.iterate_add_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [80, 9], "def_end_pos": [80, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm\u271d n\u271d m n : \u2115\nhm : m < minimalPeriod f x\nhmn : f^[m] x = f^[n] x\nhmn' : n < m\n\u22a2 False", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm\u271d n\u271d m n : \u2115\nhm : m < minimalPeriod f x\nhmn : f^[m - n] (f^[n] x) = f^[n] x\nhmn' : n < m\n\u22a2 False"}, {"tactic": "exact\n  ((IsPeriodicPt.minimalPeriod_le (tsub_pos_of_lt hmn')\n            (isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate\n              (minimalPeriod_pos_iff_mem_periodicPts.1 ((zero_le m).trans_lt hm)) hmn)).trans\n        (Nat.sub_le m n)).not_lt\n    hm", "annotated_tactic": ["exact\n    ((<a>IsPeriodicPt.minimalPeriod_le</a> (<a>tsub_pos_of_lt</a> hmn')\n              (<a>isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate</a>\n                (<a>minimalPeriod_pos_iff_mem_periodicPts</a>.1 ((<a>zero_le</a> m).<a>trans_lt</a> hm)) hmn)).<a>trans</a>\n          (<a>Nat.sub_le</a> m n)).<a>not_lt</a>\n      hm", [{"full_name": "Function.IsPeriodicPt.minimalPeriod_le", "def_path": ".lake/packages/mathlib/Mathlib/Dynamics/PeriodicPts.lean", "def_pos": [324, 9], "def_end_pos": [324, 38]}, {"full_name": "tsub_pos_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [361, 9], "def_end_pos": [361, 23]}, {"full_name": "Function.isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate", "def_path": ".lake/packages/mathlib/Mathlib/Dynamics/PeriodicPts.lean", "def_pos": [235, 9], "def_end_pos": [235, 64]}, {"full_name": "Function.minimalPeriod_pos_iff_mem_periodicPts", "def_path": ".lake/packages/mathlib/Mathlib/Dynamics/PeriodicPts.lean", "def_pos": [315, 9], "def_end_pos": [315, 46]}, {"full_name": "zero_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [204, 30], "def_end_pos": [204, 37]}, {"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "Nat.sub_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 15]}, {"full_name": "LE.le.not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [353, 7], "def_end_pos": [353, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm\u271d n\u271d m n : \u2115\nhm : m < minimalPeriod f x\nhmn : f^[m - n] (f^[n] x) = f^[n] x\nhmn' : n < m\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioc_union_Ioc_left", "start": [1871, 1], "end": [1872, 85], "traced_tactics": [{"tactic": "rw [Ioc_union_Ioc, max_self] <;> exact (min_le_right _ _).trans (le_max_right _ _)", "annotated_tactic": ["rw [<a>Ioc_union_Ioc</a>, <a>max_self</a>] <;> exact (<a>min_le_right</a> _ _).<a>trans</a> (<a>le_max_right</a> _ _)", [{"full_name": "Set.Ioc_union_Ioc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1638, 9], "def_end_pos": [1638, 22]}, {"full_name": "max_self", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [130, 9], "def_end_pos": [130, 17]}, {"full_name": "min_le_right", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [40, 9], "def_end_pos": [40, 21]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "le_max_right", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [61, 9], "def_end_pos": [61, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\n\u22a2 Ioc a c \u222a Ioc b c = Ioc (min a b) c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "full_name": "Matrix.charpoly_monic", "start": [127, 1], "end": [145, 10], "traced_tactics": [{"tactic": "nontriviality R", "annotated_tactic": ["nontriviality R", []], "state_before": "R : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\n\u22a2 Monic (charpoly M)", "state_after": "R : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\n\u22a2 Monic (charpoly M)"}, {"tactic": "by_cases h : Fintype.card n = 0", "annotated_tactic": ["by_cases h : <a>Fintype.card</a> n = 0", [{"full_name": "Fintype.card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [61, 5], "def_end_pos": [61, 9]}]], "state_before": "R : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\n\u22a2 Monic (charpoly M)", "state_after": "case pos\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : Fintype.card n = 0\n\u22a2 Monic (charpoly M)\n\ncase neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\n\u22a2 Monic (charpoly M)"}, {"tactic": "have mon : (\u220f i : n, (X - C (M i i))).Monic := by\n  apply monic_prod_of_monic univ fun i : n => X - C (M i i)\n  simp [monic_X_sub_C]", "annotated_tactic": ["have mon : (\u220f i : n, (<a>X</a> - <a>C</a> (M i i))).<a>Monic</a> := by\n    apply <a>monic_prod_of_monic</a> <a>univ</a> fun i : n => <a>X</a> - <a>C</a> (M i i)\n    simp [<a>monic_X_sub_C</a>]", [{"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}, {"full_name": "Polynomial.Monic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [79, 5], "def_end_pos": [79, 10]}, {"full_name": "Polynomial.monic_prod_of_monic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [287, 9], "def_end_pos": [287, 28]}, {"full_name": "Finset.univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [68, 5], "def_end_pos": [68, 9]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}, {"full_name": "Polynomial.monic_X_sub_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [388, 9], "def_end_pos": [388, 22]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\n\u22a2 Monic (charpoly M)", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : Monic (\u220f i : n, (X - C (M i i)))\n\u22a2 Monic (charpoly M)"}, {"tactic": "rw [\u2190 sub_add_cancel (\u220f i : n, (X - C (M i i))) M.charpoly] at mon", "annotated_tactic": ["rw [\u2190 <a>sub_add_cancel</a> (\u220f i : n, (<a>X</a> - <a>C</a> (M i i))) M.charpoly] at mon", [{"full_name": "sub_add_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [807, 30], "def_end_pos": [807, 44]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : Monic (\u220f i : n, (X - C (M i i)))\n\u22a2 Monic (charpoly M)", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : Monic (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M)\n\u22a2 Monic (charpoly M)"}, {"tactic": "rw [Monic] at *", "annotated_tactic": ["rw [<a>Monic</a>] at *", [{"full_name": "Polynomial.Monic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [79, 5], "def_end_pos": [79, 10]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : Monic (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M)\n\u22a2 Monic (charpoly M)", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 leadingCoeff (charpoly M) = 1"}, {"tactic": "rwa [leadingCoeff_add_of_degree_lt] at mon", "annotated_tactic": ["rwa [<a>leadingCoeff_add_of_degree_lt</a>] at mon", [{"full_name": "Polynomial.leadingCoeff_add_of_degree_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [928, 9], "def_end_pos": [928, 38]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 leadingCoeff (charpoly M) = 1", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 degree (\u220f i : n, (X - C (M i i)) - charpoly M) < degree (charpoly M)"}, {"tactic": "rw [charpoly_degree_eq_dim]", "annotated_tactic": ["rw [<a>charpoly_degree_eq_dim</a>]", [{"full_name": "Matrix.charpoly_degree_eq_dim", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "def_pos": [96, 9], "def_end_pos": [96, 31]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 degree (\u220f i : n, (X - C (M i i)) - charpoly M) < degree (charpoly M)", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 degree (\u220f i : n, (X - C (M i i)) - charpoly M) < \u2191(Fintype.card n)"}, {"tactic": "rw [\u2190 neg_sub]", "annotated_tactic": ["rw [\u2190 <a>neg_sub</a>]", [{"full_name": "neg_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [471, 3], "def_end_pos": [471, 14]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 degree (\u220f i : n, (X - C (M i i)) - charpoly M) < \u2191(Fintype.card n)", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 degree (-(charpoly M - \u220f i : n, (X - C (M i i)))) < \u2191(Fintype.card n)"}, {"tactic": "rw [degree_neg]", "annotated_tactic": ["rw [<a>degree_neg</a>]", [{"full_name": "Polynomial.degree_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [538, 9], "def_end_pos": [538, 19]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 degree (-(charpoly M - \u220f i : n, (X - C (M i i)))) < \u2191(Fintype.card n)", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 degree (charpoly M - \u220f i : n, (X - C (M i i))) < \u2191(Fintype.card n)"}, {"tactic": "apply lt_trans (charpoly_sub_diagonal_degree_lt M)", "annotated_tactic": ["apply <a>lt_trans</a> (<a>charpoly_sub_diagonal_degree_lt</a> M)", [{"full_name": "lt_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [84, 9], "def_end_pos": [84, 17]}, {"full_name": "Matrix.charpoly_sub_diagonal_degree_lt", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "def_pos": [61, 9], "def_end_pos": [61, 40]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 degree (charpoly M - \u220f i : n, (X - C (M i i))) < \u2191(Fintype.card n)", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 \u2191(Fintype.card n - 1) < \u2191(Fintype.card n)"}, {"tactic": "rw [Nat.cast_lt]", "annotated_tactic": ["rw [<a>Nat.cast_lt</a>]", [{"full_name": "Nat.cast_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Order.lean", "def_pos": [129, 9], "def_end_pos": [129, 16]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 \u2191(Fintype.card n - 1) < \u2191(Fintype.card n)", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 Fintype.card n - 1 < Fintype.card n"}, {"tactic": "rw [\u2190 Nat.pred_eq_sub_one]", "annotated_tactic": ["rw [\u2190 <a>Nat.pred_eq_sub_one</a>]", [{"full_name": "Nat.pred_eq_sub_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [139, 7], "def_end_pos": [139, 22]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 Fintype.card n - 1 < Fintype.card n", "state_after": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 Nat.pred (Fintype.card n) < Fintype.card n"}, {"tactic": "apply Nat.pred_lt", "annotated_tactic": ["apply <a>Nat.pred_lt</a>", [{"full_name": "Nat.pred_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [231, 9], "def_end_pos": [231, 16]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 Nat.pred (Fintype.card n) < Fintype.card n", "state_after": "case neg.a\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 Fintype.card n \u2260 0"}, {"tactic": "apply h", "annotated_tactic": ["apply h", []], "state_before": "case neg.a\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\nmon : leadingCoeff (\u220f i : n, (X - C (M i i)) - charpoly M + charpoly M) = 1\n\u22a2 Fintype.card n \u2260 0", "state_after": "no goals"}, {"tactic": "rw [charpoly, det_of_card_zero h]", "annotated_tactic": ["rw [<a>charpoly</a>, <a>det_of_card_zero</a> h]", [{"full_name": "Matrix.charpoly", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Charpoly/Basic.lean", "def_pos": [103, 5], "def_end_pos": [103, 13]}, {"full_name": "Matrix.det_of_card_zero", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "def_pos": [89, 9], "def_end_pos": [89, 25]}]], "state_before": "case pos\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : Fintype.card n = 0\n\u22a2 Monic (charpoly M)", "state_after": "case pos\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : Fintype.card n = 0\n\u22a2 Monic 1"}, {"tactic": "apply monic_one", "annotated_tactic": ["apply <a>monic_one</a>", [{"full_name": "Polynomial.monic_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [895, 9], "def_end_pos": [895, 18]}]], "state_before": "case pos\nR : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : Fintype.card n = 0\n\u22a2 Monic 1", "state_after": "no goals"}, {"tactic": "apply monic_prod_of_monic univ fun i : n => X - C (M i i)", "annotated_tactic": ["apply <a>monic_prod_of_monic</a> <a>univ</a> fun i : n => <a>X</a> - <a>C</a> (M i i)", [{"full_name": "Polynomial.monic_prod_of_monic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [287, 9], "def_end_pos": [287, 28]}, {"full_name": "Finset.univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [68, 5], "def_end_pos": [68, 9]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [499, 5], "def_end_pos": [499, 6]}]], "state_before": "R : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\n\u22a2 Monic (\u220f i : n, (X - C (M i i)))", "state_after": "R : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\n\u22a2 \u2200 i \u2208 univ, Monic (X - C (M i i))"}, {"tactic": "simp [monic_X_sub_C]", "annotated_tactic": ["simp [<a>monic_X_sub_C</a>]", [{"full_name": "Polynomial.monic_X_sub_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [388, 9], "def_end_pos": [388, 22]}]], "state_before": "R : Type u\ninst\u271d\u00b3 : CommRing R\nn G : Type v\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\n\u03b1 \u03b2 : Type v\ninst\u271d : DecidableEq \u03b1\nM\u271d M : Matrix n n R\na\u271d : Nontrivial R\nh : \u00acFintype.card n = 0\n\u22a2 \u2200 i \u2208 univ, Monic (X - C (M i i))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Multiplicity.lean", "full_name": "multiplicity.multiplicity_lt_iff_not_dvd", "start": [153, 1], "end": [154, 98], "traced_tactics": [{"tactic": "rw [pow_dvd_iff_le_multiplicity, not_le]", "annotated_tactic": ["rw [<a>pow_dvd_iff_le_multiplicity</a>, <a>not_le</a>]", [{"full_name": "multiplicity.pow_dvd_iff_le_multiplicity", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [148, 9], "def_end_pos": [148, 36]}, {"full_name": "not_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [367, 9], "def_end_pos": [367, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\n\u22a2 multiplicity a b < \u2191k \u2194 \u00aca ^ k \u2223 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "full_name": "CategoryTheory.Limits.BinaryCofan.\u03b9_app_right", "start": [263, 1], "end": [264, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearMap.isComplete_ker", "start": [1008, 1], "end": [1012, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "full_name": "MulChar.ofUnitHom_eq", "start": [224, 1], "end": [225, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/Compact.lean", "full_name": "Inducing.isCompact_iff", "start": [904, 1], "end": [909, 44], "traced_tactics": [{"tactic": "refine \u27e8fun hs => hs.image hf.continuous, fun hs F F_ne_bot F_le => ?_\u27e9", "annotated_tactic": ["refine \u27e8fun hs => hs.image hf.continuous, fun hs F F_ne_bot F_le => ?_\u27e9", []], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : X \u2192 Y\nhf : Inducing f\n\u22a2 IsCompact s \u2194 IsCompact (f '' s)", "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : X \u2192 Y\nhf : Inducing f\nhs : IsCompact (f '' s)\nF : Filter X\nF_ne_bot : NeBot F\nF_le : F \u2264 \ud835\udcdf s\n\u22a2 \u2203 x \u2208 s, ClusterPt x F"}, {"tactic": "obtain \u27e8_, \u27e8x, x_in : x \u2208 s, rfl\u27e9, hx : ClusterPt (f x) (map f F)\u27e9 :=\n  hs ((map_mono F_le).trans_eq map_principal)", "annotated_tactic": ["obtain \u27e8_, \u27e8x, x_in : x \u2208 s, rfl\u27e9, hx : <a>ClusterPt</a> (f x) (<a>map</a> f F)\u27e9 :=\n    hs ((<a>map_mono</a> F_le).<a>trans_eq</a> <a>map_principal</a>)", [{"full_name": "ClusterPt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [255, 5], "def_end_pos": [255, 14]}, {"full_name": "Filter.map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1921, 5], "def_end_pos": [1921, 8]}, {"full_name": "Filter.map_mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2331, 9], "def_end_pos": [2331, 17]}, {"full_name": "LE.le.trans_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [197, 7], "def_end_pos": [197, 21]}, {"full_name": "Filter.map_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1929, 9], "def_end_pos": [1929, 22]}]], "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : X \u2192 Y\nhf : Inducing f\nhs : IsCompact (f '' s)\nF : Filter X\nF_ne_bot : NeBot F\nF_le : F \u2264 \ud835\udcdf s\n\u22a2 \u2203 x \u2208 s, ClusterPt x F", "state_after": "case intro.intro.intro.intro\nX : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : X \u2192 Y\nhf : Inducing f\nhs : IsCompact (f '' s)\nF : Filter X\nF_ne_bot : NeBot F\nF_le : F \u2264 \ud835\udcdf s\nx : X\nx_in : x \u2208 s\nhx : ClusterPt (f x) (map f F)\n\u22a2 \u2203 x \u2208 s, ClusterPt x F"}, {"tactic": "exact \u27e8x, x_in, hf.mapClusterPt_iff.1 hx\u27e9", "annotated_tactic": ["exact \u27e8x, x_in, hf.mapClusterPt_iff.1 hx\u27e9", []], "state_before": "case intro.intro.intro.intro\nX : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nf : X \u2192 Y\nhf : Inducing f\nhs : IsCompact (f '' s)\nF : Filter X\nF_ne_bot : NeBot F\nF_le : F \u2264 \ud835\udcdf s\nx : X\nx_in : x \u2208 s\nhx : ClusterPt (f x) (map f F)\n\u22a2 \u2203 x \u2208 s, ClusterPt x F", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Basic.lean", "full_name": "Complex.nnnorm_real", "start": [195, 1], "end": [196, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.IsBigOWith.prod_left_snd", "start": [1030, 1], "end": [1032, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Normed.lean", "full_name": "convexOn_univ_norm", "start": [51, 1], "end": [52, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.mem_append", "start": [537, 9], "end": [538, 52], "traced_tactics": [{"tactic": "simp only [mem_def, append_data, List.mem_append]", "annotated_tactic": ["simp only [<a>mem_def</a>, <a>append_data</a>, <a>List.mem_append</a>]", [{"full_name": "Array.mem_def", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [186, 9], "def_end_pos": [186, 16]}, {"full_name": "Array.append_data", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean", "def_pos": [147, 17], "def_end_pos": [147, 28]}, {"full_name": "List.mem_append", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [169, 17], "def_end_pos": [169, 27]}]], "state_before": "\u03b1 : Type u_1\na : \u03b1\ns t : Array \u03b1\n\u22a2 a \u2208 s ++ t \u2194 a \u2208 s \u2228 a \u2208 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.comap_sup_comap_le", "start": [1527, 1], "end": [1529, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Functor/Basic.lean", "full_name": "CategoryTheory.Functor.id_comp", "start": [132, 11], "end": [132, 71], "traced_tactics": [{"tactic": "cases F", "annotated_tactic": ["cases F", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : C \u2964 D\n\u22a2 \ud835\udfed C \u22d9 F = F", "state_after": "case mk\nC : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\ntoPrefunctor\u271d : C \u2964q D\nmap_id\u271d : \u2200 (X : C), toPrefunctor\u271d.map (\ud835\udfd9 X) = \ud835\udfd9 (toPrefunctor\u271d.obj X)\nmap_comp\u271d : \u2200 {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z), toPrefunctor\u271d.map (f \u226b g) = toPrefunctor\u271d.map f \u226b toPrefunctor\u271d.map g\n\u22a2 \ud835\udfed C \u22d9 { toPrefunctor := toPrefunctor\u271d, map_id := map_id\u271d, map_comp := map_comp\u271d } =\n    { toPrefunctor := toPrefunctor\u271d, map_id := map_id\u271d, map_comp := map_comp\u271d }"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk\nC : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\ntoPrefunctor\u271d : C \u2964q D\nmap_id\u271d : \u2200 (X : C), toPrefunctor\u271d.map (\ud835\udfd9 X) = \ud835\udfd9 (toPrefunctor\u271d.obj X)\nmap_comp\u271d : \u2200 {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z), toPrefunctor\u271d.map (f \u226b g) = toPrefunctor\u271d.map f \u226b toPrefunctor\u271d.map g\n\u22a2 \ud835\udfed C \u22d9 { toPrefunctor := toPrefunctor\u271d, map_id := map_id\u271d, map_comp := map_comp\u271d } =\n    { toPrefunctor := toPrefunctor\u271d, map_id := map_id\u271d, map_comp := map_comp\u271d }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "full_name": "mem_balancedHull_iff", "start": [108, 1], "end": [109, 22], "traced_tactics": [{"tactic": "simp [balancedHull]", "annotated_tactic": ["simp [<a>balancedHull</a>]", [{"full_name": "balancedHull", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "def_pos": [67, 5], "def_end_pos": [67, 17]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nx : E\n\u22a2 x \u2208 balancedHull \ud835\udd5c s \u2194 \u2203 r, \u2016r\u2016 \u2264 1 \u2227 x \u2208 r \u2022 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.out_embedding", "start": [304, 1], "end": [307, 34], "traced_tactics": [{"tactic": "trans", "annotated_tactic": ["trans", []], "state_before": "\u03b1 \u03b2 : Type u\nc c' : Cardinal.{u_1}\n\u22a2 c \u2264 c' \u2194 Nonempty (Quotient.out c \u21aa Quotient.out c')", "state_after": "\u03b1 \u03b2 : Type u\nc c' : Cardinal.{u_1}\n\u22a2 c \u2264 c' \u2194 ?m.7205\n\n\u03b1 \u03b2 : Type u\nc c' : Cardinal.{u_1}\n\u22a2 ?m.7205 \u2194 Nonempty (Quotient.out c \u21aa Quotient.out c')\n\n\u03b1 \u03b2 : Type u\nc c' : Cardinal.{u_1}\n\u22a2 Prop"}, {"tactic": "rw [\u2190 Quotient.out_eq c, \u2190 Quotient.out_eq c']", "annotated_tactic": ["rw [\u2190 <a>Quotient.out_eq</a> c, \u2190 <a>Quotient.out_eq</a> c']", [{"full_name": "Quotient.out_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Quot.lean", "def_pos": [383, 9], "def_end_pos": [383, 24]}, {"full_name": "Quotient.out_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Quot.lean", "def_pos": [383, 9], "def_end_pos": [383, 24]}]], "state_before": "\u03b1 \u03b2 : Type u\nc c' : Cardinal.{u_1}\n\u22a2 c \u2264 c' \u2194 ?m.7205", "state_after": "no goals"}, {"tactic": "rw [mk'_def, mk'_def, le_def]", "annotated_tactic": ["rw [<a>mk'_def</a>, <a>mk'_def</a>, <a>le_def</a>]", [{"full_name": "Cardinal.mk'_def", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [148, 9], "def_end_pos": [148, 16]}, {"full_name": "Cardinal.mk'_def", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [148, 9], "def_end_pos": [148, 16]}, {"full_name": "Cardinal.le_def", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [266, 9], "def_end_pos": [266, 15]}]], "state_before": "\u03b1 \u03b2 : Type u\nc c' : Cardinal.{u_1}\n\u22a2 \u27e6Quotient.out c\u27e7 \u2264 \u27e6Quotient.out c'\u27e7 \u2194 Nonempty (Quotient.out c \u21aa Quotient.out c')", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Divisibility/Basic.lean", "full_name": "dvd_pow", "start": [160, 1], "end": [162, 57], "traced_tactics": [{"tactic": "rw [pow_succ]", "annotated_tactic": ["rw [<a>pow_succ</a>]", [{"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nm n\u271d : \u2115\nhab : a \u2223 b\nn : \u2115\nx\u271d : n + 1 \u2260 0\n\u22a2 a \u2223 b ^ (n + 1)", "state_after": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nm n\u271d : \u2115\nhab : a \u2223 b\nn : \u2115\nx\u271d : n + 1 \u2260 0\n\u22a2 a \u2223 b * b ^ n"}, {"tactic": "exact hab.mul_right _", "annotated_tactic": ["exact hab.mul_right _", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na b : \u03b1\nm n\u271d : \u2115\nhab : a \u2223 b\nn : \u2115\nx\u271d : n + 1 \u2260 0\n\u22a2 a \u2223 b * b ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Defs.lean", "full_name": "zpow_ofNat", "start": [974, 1], "end": [976, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometry.lipschitz", "start": [300, 11], "end": [301, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/CovariantAndContravariant.lean", "full_name": "Covariant.monotone_of_const", "start": [249, 1], "end": [250, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.inf_coe", "start": [464, 1], "end": [468, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "full_name": "Polynomial.integralNormalization_coeff_natDegree", "start": [66, 1], "end": [68, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "map_nhds_induced_of_surjective", "start": [835, 1], "end": [837, 48], "traced_tactics": [{"tactic": "rw [nhds_induced, map_comap_of_surjective hf]", "annotated_tactic": ["rw [<a>nhds_induced</a>, <a>map_comap_of_surjective</a> hf]", [{"full_name": "nhds_induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [824, 9], "def_end_pos": [824, 21]}, {"full_name": "Filter.map_comap_of_surjective", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2446, 9], "def_end_pos": [2446, 32]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\nf\u271d : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_2\nT : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nhf : Surjective f\na : \u03b2\n\u22a2 map f (\ud835\udcdd a) = \ud835\udcdd (f a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.diagonal_mul_diagonal", "start": [1066, 1], "end": [1070, 11], "traced_tactics": [{"tactic": "ext i j", "annotated_tactic": ["ext i j", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nd\u2081 d\u2082 : n \u2192 \u03b1\n\u22a2 diagonal d\u2081 * diagonal d\u2082 = diagonal fun i => d\u2081 i * d\u2082 i", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nd\u2081 d\u2082 : n \u2192 \u03b1\ni j : n\n\u22a2 (diagonal d\u2081 * diagonal d\u2082) i j = diagonal (fun i => d\u2081 i * d\u2082 i) i j"}, {"tactic": "by_cases h : i = j <;>\nsimp [h]", "annotated_tactic": ["by_cases h : i = j <;>\n  simp [h]", []], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9 : Fintype n\ninst\u271d : DecidableEq n\nd\u2081 d\u2082 : n \u2192 \u03b1\ni j : n\n\u22a2 (diagonal d\u2081 * diagonal d\u2082) i j = diagonal (fun i => d\u2081 i * d\u2082 i) i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "IsLinearMap.isLinearMap_sub", "start": [406, 1], "end": [414, 20], "traced_tactics": [{"tactic": "apply IsLinearMap.mk", "annotated_tactic": ["apply <a>IsLinearMap.mk</a>", [{"full_name": "IsLinearMap.mk", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [69, 11], "def_end_pos": [69, 22]}]], "state_before": "R\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 IsLinearMap R fun x => x.1 - x.2", "state_after": "case map_add\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u2200 (x y : M \u00d7 M), (x + y).1 - (x + y).2 = x.1 - x.2 + (y.1 - y.2)\n\ncase map_smul\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u2200 (c : R) (x : M \u00d7 M), (c \u2022 x).1 - (c \u2022 x).2 = c \u2022 (x.1 - x.2)"}, {"tactic": "intro x y", "annotated_tactic": ["intro x y", []], "state_before": "case map_add\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u2200 (x y : M \u00d7 M), (x + y).1 - (x + y).2 = x.1 - x.2 + (y.1 - y.2)", "state_after": "case map_add\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M \u00d7 M\n\u22a2 (x + y).1 - (x + y).2 = x.1 - x.2 + (y.1 - y.2)"}, {"tactic": "rw [Prod.fst_add, Prod.snd_add]", "annotated_tactic": ["rw [<a>Prod.fst_add</a>, <a>Prod.snd_add</a>]", [{"full_name": "Prod.fst_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [46, 3], "def_end_pos": [46, 14]}, {"full_name": "Prod.snd_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [52, 3], "def_end_pos": [52, 14]}]], "state_before": "case map_add\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M \u00d7 M\n\u22a2 (x + y).1 - (x + y).2 = x.1 - x.2 + (y.1 - y.2)", "state_after": "case map_add\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M \u00d7 M\n\u22a2 x.1 + y.1 - (x.2 + y.2) = x.1 - x.2 + (y.1 - y.2)"}, {"tactic": "abel", "annotated_tactic": ["abel", []], "state_before": "case map_add\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M \u00d7 M\n\u22a2 x.1 + y.1 - (x.2 + y.2) = x.1 - x.2 + (y.1 - y.2)", "state_after": "no goals"}, {"tactic": "intro x y", "annotated_tactic": ["intro x y", []], "state_before": "case map_smul\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 \u2200 (c : R) (x : M \u00d7 M), (c \u2022 x).1 - (c \u2022 x).2 = c \u2022 (x.1 - x.2)", "state_after": "case map_smul\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : R\ny : M \u00d7 M\n\u22a2 (x \u2022 y).1 - (x \u2022 y).2 = x \u2022 (y.1 - y.2)"}, {"tactic": "simp [smul_sub]", "annotated_tactic": ["simp [<a>smul_sub</a>]", [{"full_name": "smul_sub", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [1024, 9], "def_end_pos": [1024, 17]}]], "state_before": "case map_smul\nR\u271d : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM\u271d : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\nR : Type u_20\nM : Type u_21\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx : R\ny : M \u00d7 M\n\u22a2 (x \u2022 y).1 - (x \u2022 y).2 = x \u2022 (y.1 - y.2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean", "full_name": "hasSum_geometric_of_abs_lt_one", "start": [313, 1], "end": [315, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dual.lean", "full_name": "Subspace.dualAnnihilator_iInf_eq", "start": [1544, 1], "end": [1553, 61], "traced_tactics": [{"tactic": "revert \u03b9", "annotated_tactic": ["revert \u03b9", []], "state_before": "K : Type uK\ninst\u271d\u2075 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u2074 : AddCommGroup V\u2081\ninst\u271d\u00b3 : Module K V\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\n\u03b9 : Type u_1\ninst\u271d : _root_.Finite \u03b9\nW : \u03b9 \u2192 Subspace K V\u2081\n\u22a2 dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)", "state_after": "K : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u22a2 \u2200 {\u03b9 : Type u_1} [inst : _root_.Finite \u03b9] (W : \u03b9 \u2192 Subspace K V\u2081),\n    dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"tactic": "apply Finite.induction_empty_option", "annotated_tactic": ["apply <a>Finite.induction_empty_option</a>", [{"full_name": "Finite.induction_empty_option", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Option.lean", "def_pos": [112, 9], "def_end_pos": [112, 38]}]], "state_before": "K : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u22a2 \u2200 {\u03b9 : Type u_1} [inst : _root_.Finite \u03b9] (W : \u03b9 \u2192 Subspace K V\u2081),\n    dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)", "state_after": "case of_equiv\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u22a2 \u2200 {\u03b1 \u03b2 : Type u_1},\n    \u03b1 \u2243 \u03b2 \u2192\n      (\u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)) \u2192\n        \u2200 (W : \u03b2 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)\n\ncase h_empty\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u22a2 \u2200 (W : PEmpty.{u_1 + 1} \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)\n\ncase h_option\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u22a2 \u2200 {\u03b1 : Type u_1} [inst : Fintype \u03b1],\n    (\u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)) \u2192\n      \u2200 (W : Option \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"tactic": "intro \u03b1 \u03b2 h hyp W", "annotated_tactic": ["intro \u03b1 \u03b2 h hyp W", []], "state_before": "case of_equiv\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u22a2 \u2200 {\u03b1 \u03b2 : Type u_1},\n    \u03b1 \u2243 \u03b2 \u2192\n      (\u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)) \u2192\n        \u2200 (W : \u03b2 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)", "state_after": "case of_equiv\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u03b1 \u03b2 : Type u_1\nh : \u03b1 \u2243 \u03b2\nhyp : \u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)\nW : \u03b2 \u2192 Subspace K V\u2081\n\u22a2 dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"tactic": "rw [\u2190 h.iInf_comp, hyp _, \u2190 h.iSup_comp]", "annotated_tactic": ["rw [\u2190 h.iInf_comp, hyp _, \u2190 h.iSup_comp]", []], "state_before": "case of_equiv\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u03b1 \u03b2 : Type u_1\nh : \u03b1 \u2243 \u03b2\nhyp : \u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)\nW : \u03b2 \u2192 Subspace K V\u2081\n\u22a2 dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)", "state_after": "no goals"}, {"tactic": "intro W", "annotated_tactic": ["intro W", []], "state_before": "case h_empty\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u22a2 \u2200 (W : PEmpty.{u_1 + 1} \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)", "state_after": "case h_empty\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\nW : PEmpty.{u_1 + 1} \u2192 Subspace K V\u2081\n\u22a2 dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"tactic": "rw [iSup_of_empty', iInf_of_isEmpty, sInf_empty, sSup_empty, dualAnnihilator_top]", "annotated_tactic": ["rw [<a>iSup_of_empty'</a>, <a>iInf_of_isEmpty</a>, <a>sInf_empty</a>, <a>sSup_empty</a>, <a>dualAnnihilator_top</a>]", [{"full_name": "iSup_of_empty'", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1469, 9], "def_end_pos": [1469, 23]}, {"full_name": "iInf_of_isEmpty", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1473, 9], "def_end_pos": [1473, 24]}, {"full_name": "sInf_empty", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [428, 9], "def_end_pos": [428, 19]}, {"full_name": "sSup_empty", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [423, 9], "def_end_pos": [423, 19]}, {"full_name": "Submodule.dualAnnihilator_top", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dual.lean", "def_pos": [961, 9], "def_end_pos": [961, 28]}]], "state_before": "case h_empty\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\nW : PEmpty.{u_1 + 1} \u2192 Subspace K V\u2081\n\u22a2 dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)", "state_after": "no goals"}, {"tactic": "intro \u03b1 _ h W", "annotated_tactic": ["intro \u03b1 _ h W", []], "state_before": "case h_option\nK : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\n\u22a2 \u2200 {\u03b1 : Type u_1} [inst : Fintype \u03b1],\n    (\u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)) \u2192\n      \u2200 (W : Option \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)", "state_after": "case h_option\nK : Type uK\ninst\u271d\u2075 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u2074 : AddCommGroup V\u2081\ninst\u271d\u00b3 : Module K V\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\n\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\nh : \u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)\nW : Option \u03b1 \u2192 Subspace K V\u2081\n\u22a2 dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)"}, {"tactic": "rw [iInf_option, iSup_option, dualAnnihilator_inf_eq, h]", "annotated_tactic": ["rw [<a>iInf_option</a>, <a>iSup_option</a>, <a>dualAnnihilator_inf_eq</a>, h]", [{"full_name": "iInf_option", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1564, 9], "def_end_pos": [1564, 20]}, {"full_name": "iSup_option", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1560, 9], "def_end_pos": [1560, 20]}, {"full_name": "Subspace.dualAnnihilator_inf_eq", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dual.lean", "def_pos": [1520, 9], "def_end_pos": [1520, 31]}]], "state_before": "case h_option\nK : Type uK\ninst\u271d\u2075 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u2074 : AddCommGroup V\u2081\ninst\u271d\u00b3 : Module K V\u2081\ninst\u271d\u00b2 : AddCommGroup V\u2082\ninst\u271d\u00b9 : Module K V\u2082\n\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\nh : \u2200 (W : \u03b1 \u2192 Subspace K V\u2081), dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)\nW : Option \u03b1 \u2192 Subspace K V\u2081\n\u22a2 dualAnnihilator (\u2a05 i, W i) = \u2a06 i, dualAnnihilator (W i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Reindex.lean", "full_name": "Matrix.reindexLinearEquiv_refl_refl", "start": [61, 1], "end": [63, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.add_apply", "start": [234, 1], "end": [236, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Ioo_eq_empty_of_le", "start": [127, 1], "end": [128, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "inf_lt_left_or_right", "start": [441, 1], "end": [442, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Basic.lean", "full_name": "Submodule.coe_eq_zero", "start": [291, 1], "end": [292, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/FiniteDimensional.lean", "full_name": "LinearMap.mul_eq_one_comm", "start": [667, 1], "end": [668, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "sq_pos_iff", "start": [501, 1], "end": [501, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.mem_rootSet'", "start": [1228, 1], "end": [1231, 62], "traced_tactics": [{"tactic": "classical\nrw [rootSet_def, Finset.mem_coe, mem_toFinset, mem_aroots']", "annotated_tactic": ["classical\n  rw [<a>rootSet_def</a>, <a>Finset.mem_coe</a>, <a>mem_toFinset</a>, <a>mem_aroots'</a>]", [{"full_name": "Polynomial.rootSet_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1173, 9], "def_end_pos": [1173, 20]}, {"full_name": "Finset.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}, {"full_name": "Multiset.mem_toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3292, 9], "def_end_pos": [3292, 21]}, {"full_name": "Polynomial.mem_aroots'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1085, 9], "def_end_pos": [1085, 20]}]], "state_before": "R : Type u\nS\u271d : Type v\nT : Type w\na\u271d b : R\nn : \u2115\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\np\u271d q : R[X]\ninst\u271d\u00b3 : CommRing T\np : T[X]\nS : Type u_1\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra T S\na : S\n\u22a2 a \u2208 rootSet p S \u2194 map (algebraMap T S) p \u2260 0 \u2227 (aeval a) p = 0", "state_after": "no goals"}, {"tactic": "rw [rootSet_def, Finset.mem_coe, mem_toFinset, mem_aroots']", "annotated_tactic": ["rw [<a>rootSet_def</a>, <a>Finset.mem_coe</a>, <a>mem_toFinset</a>, <a>mem_aroots'</a>]", [{"full_name": "Polynomial.rootSet_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1173, 9], "def_end_pos": [1173, 20]}, {"full_name": "Finset.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}, {"full_name": "Multiset.mem_toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3292, 9], "def_end_pos": [3292, 21]}, {"full_name": "Polynomial.mem_aroots'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1085, 9], "def_end_pos": [1085, 20]}]], "state_before": "R : Type u\nS\u271d : Type v\nT : Type w\na\u271d b : R\nn : \u2115\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\np\u271d q : R[X]\ninst\u271d\u00b3 : CommRing T\np : T[X]\nS : Type u_1\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra T S\na : S\n\u22a2 a \u2208 rootSet p S \u2194 map (algebraMap T S) p \u2260 0 \u2227 (aeval a) p = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.coeff_add", "start": [619, 1], "end": [620, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "LinearMap.toMatrix_reindexRange", "start": [663, 1], "end": [668, 90], "traced_tactics": [{"tactic": "simp_rw [LinearMap.toMatrix_apply, Basis.reindexRange_self, Basis.reindexRange_repr]", "annotated_tactic": ["simp_rw [<a>LinearMap.toMatrix_apply</a>, <a>Basis.reindexRange_self</a>, <a>Basis.reindexRange_repr</a>]", [{"full_name": "LinearMap.toMatrix_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "def_pos": [601, 9], "def_end_pos": [601, 33]}, {"full_name": "Basis.reindexRange_self", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [467, 9], "def_end_pos": [467, 26]}, {"full_name": "Basis.reindexRange_repr", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [510, 9], "def_end_pos": [510, 26]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\ninst\u271d\u00b9 : DecidableEq M\u2081\ninst\u271d : DecidableEq M\u2082\nf : M\u2081 \u2192\u2097[R] M\u2082\nk : m\ni : n\n\u22a2 (toMatrix (Basis.reindexRange v\u2081) (Basis.reindexRange v\u2082)) f { val := v\u2082 k, property := \u22ef }\n      { val := v\u2081 i, property := \u22ef } =\n    (toMatrix v\u2081 v\u2082) f k i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Surjective.comp_left", "start": [536, 1], "end": [538, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/StarAlgHom.lean", "full_name": "StarAlgEquiv.toRingEquiv_eq_coe", "start": [822, 1], "end": [823, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Monic.lean", "full_name": "Polynomial.Monic.eq_one_of_map_eq_one", "start": [228, 1], "end": [238, 70], "traced_tactics": [{"tactic": "nontriviality R", "annotated_tactic": ["nontriviality R", []], "state_before": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\n\u22a2 p = 1", "state_after": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\n\u22a2 p = 1"}, {"tactic": "have hndeg : p.natDegree = 0 :=\n  WithBot.coe_eq_coe.mp ((degree_eq_natDegree hp.ne_zero).symm.trans hdeg)", "annotated_tactic": ["have hndeg : p.natDegree = 0 :=\n    WithBot.coe_eq_coe.mp ((<a>degree_eq_natDegree</a> hp.ne_zero).symm.trans hdeg)", [{"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}]], "state_before": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\nhdeg : degree p = 0\n\u22a2 p = 1", "state_after": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\nhdeg : degree p = 0\nhndeg : natDegree p = 0\n\u22a2 p = 1"}, {"tactic": "convert eq_C_of_degree_eq_zero hdeg", "annotated_tactic": ["convert <a>eq_C_of_degree_eq_zero</a> hdeg", [{"full_name": "Polynomial.eq_C_of_degree_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [637, 9], "def_end_pos": [637, 31]}]], "state_before": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\nhdeg : degree p = 0\nhndeg : natDegree p = 0\n\u22a2 p = 1", "state_after": "case h.e'_3\nR : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\nhdeg : degree p = 0\nhndeg : natDegree p = 0\n\u22a2 1 = C (coeff p 0)"}, {"tactic": "rw [\u2190 hndeg, \u2190 Polynomial.leadingCoeff, hp.leadingCoeff, C.map_one]", "annotated_tactic": ["rw [\u2190 hndeg, \u2190 <a>Polynomial.leadingCoeff</a>, hp.leadingCoeff, C.map_one]", [{"full_name": "Polynomial.leadingCoeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [74, 5], "def_end_pos": [74, 17]}]], "state_before": "case h.e'_3\nR : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\nhdeg : degree p = 0\nhndeg : natDegree p = 0\n\u22a2 1 = C (coeff p 0)", "state_after": "no goals"}, {"tactic": "rw [\u2190 degree_map_eq_of_leadingCoeff_ne_zero f _, map_eq, degree_one]", "annotated_tactic": ["rw [\u2190 <a>degree_map_eq_of_leadingCoeff_ne_zero</a> f _, map_eq, <a>degree_one</a>]", [{"full_name": "Polynomial.degree_map_eq_of_leadingCoeff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [902, 9], "def_end_pos": [902, 46]}, {"full_name": "Polynomial.degree_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [513, 9], "def_end_pos": [513, 19]}]], "state_before": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\n\u22a2 degree p = 0", "state_after": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\n\u22a2 f (Polynomial.leadingCoeff p) \u2260 0"}, {"tactic": "rw [hp.leadingCoeff, f.map_one]", "annotated_tactic": ["rw [hp.leadingCoeff, f.map_one]", []], "state_before": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\n\u22a2 f (Polynomial.leadingCoeff p) \u2260 0", "state_after": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\n\u22a2 1 \u2260 0"}, {"tactic": "exact one_ne_zero", "annotated_tactic": ["exact <a>one_ne_zero</a>", [{"full_name": "one_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}]], "state_before": "R : Type u\nS\u271d : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d\u00b2 : Semiring R\np q r : R[X]\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Nontrivial S\nf : R \u2192+* S\nhp : Monic p\nmap_eq : Polynomial.map f p = 1\na\u271d : Nontrivial R\n\u22a2 1 \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeAbelianGroup.lean", "full_name": "FreeAbelianGroup.neg_seq", "start": [281, 1], "end": [282, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/SesquilinearForm.lean", "full_name": "mem_selfAdjointMatricesSubmodule", "start": [620, 1], "end": [623, 6], "traced_tactics": [{"tactic": "erw [mem_pairSelfAdjointMatricesSubmodule]", "annotated_tactic": ["erw [<a>mem_pairSelfAdjointMatricesSubmodule</a>]", [{"full_name": "mem_pairSelfAdjointMatricesSubmodule", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/SesquilinearForm.lean", "def_pos": [598, 9], "def_end_pos": [598, 45]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nM : Type u_4\nM\u2081 : Type u_5\nM\u2082 : Type u_6\nM\u2081' : Type u_7\nM\u2082' : Type u_8\nn : Type u_9\nm : Type u_10\nn' : Type u_11\nm' : Type u_12\n\u03b9 : Type u_13\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : AddCommMonoid M\u2081\ninst\u271d\u2076 : Module R M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2082\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : Fintype n'\nb\u2081 : Basis n R M\u2081\nb\u2082 : Basis n' R M\u2082\nJ J\u2082 : Matrix n n R\nJ' : Matrix n' n' R\nA : Matrix n' n R\nA' : Matrix n n' R\nA\u2081 A\u2082 : Matrix n n R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : DecidableEq n'\n\u22a2 A\u2081 \u2208 selfAdjointMatricesSubmodule J \u2194 Matrix.IsSelfAdjoint J A\u2081", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nM : Type u_4\nM\u2081 : Type u_5\nM\u2082 : Type u_6\nM\u2081' : Type u_7\nM\u2082' : Type u_8\nn : Type u_9\nm : Type u_10\nn' : Type u_11\nm' : Type u_12\n\u03b9 : Type u_13\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : AddCommMonoid M\u2081\ninst\u271d\u2076 : Module R M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2082\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : Fintype n'\nb\u2081 : Basis n R M\u2081\nb\u2082 : Basis n' R M\u2082\nJ J\u2082 : Matrix n n R\nJ' : Matrix n' n' R\nA : Matrix n' n R\nA' : Matrix n n' R\nA\u2081 A\u2082 : Matrix n n R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : DecidableEq n'\n\u22a2 Matrix.IsAdjointPair J J A\u2081 A\u2081 \u2194 Matrix.IsSelfAdjoint J A\u2081"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nM : Type u_4\nM\u2081 : Type u_5\nM\u2082 : Type u_6\nM\u2081' : Type u_7\nM\u2082' : Type u_8\nn : Type u_9\nm : Type u_10\nn' : Type u_11\nm' : Type u_12\n\u03b9 : Type u_13\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : AddCommMonoid M\u2081\ninst\u271d\u2076 : Module R M\u2081\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R M\u2082\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : Fintype n'\nb\u2081 : Basis n R M\u2081\nb\u2082 : Basis n' R M\u2082\nJ J\u2082 : Matrix n n R\nJ' : Matrix n' n' R\nA : Matrix n' n R\nA' : Matrix n n' R\nA\u2081 A\u2082 : Matrix n n R\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : DecidableEq n'\n\u22a2 Matrix.IsAdjointPair J J A\u2081 A\u2081 \u2194 Matrix.IsSelfAdjoint J A\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bornology/Basic.lean", "full_name": "Filter.HasBasis.disjoint_cobounded_iff", "start": [310, 1], "end": [313, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pi.lean", "full_name": "Filter.pi_le_pi", "start": [198, 1], "end": [199, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/Composition.lean", "full_name": "List.map_length_splitWrtComposition", "start": [690, 1], "end": [692, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.exists_not_mem_of_length_lt", "start": [2233, 1], "end": [2240, 70], "traced_tactics": [{"tactic": "contrapose! h", "annotated_tactic": ["contrapose! h", []], "state_before": "\u03b1\u271d \u03b2 : Type u\nc : Cardinal.{?u.255975}\n\u03b1 : Type u_1\nl : List \u03b1\nh : \u2191(List.length l) < #\u03b1\n\u22a2 \u2203 z, z \u2209 l", "state_after": "\u03b1\u271d \u03b2 : Type u\nc : Cardinal.{?u.255975}\n\u03b1 : Type u_1\nl : List \u03b1\nh : \u2200 (z : \u03b1), z \u2208 l\n\u22a2 #\u03b1 \u2264 \u2191(List.length l)"}, {"tactic": "calc\n  #\u03b1 = #(Set.univ : Set \u03b1) := mk_univ.symm\n  _ \u2264 #l.toFinset := mk_le_mk_of_subset fun x _ => List.mem_toFinset.mpr (h x)\n  _ = l.toFinset.card := Cardinal.mk_coe_finset\n  _ \u2264 l.length := Cardinal.natCast_le.mpr (List.toFinset_card_le l)", "annotated_tactic": ["calc\n    #\u03b1 = #(<a>Set.univ</a> : <a>Set</a> \u03b1) := mk_univ.symm\n    _ \u2264 #l.toFinset := <a>mk_le_mk_of_subset</a> fun x _ => List.mem_toFinset.mpr (h x)\n    _ = l.toFinset.card := <a>Cardinal.mk_coe_finset</a>\n    _ \u2264 l.length := Cardinal.natCast_le.mpr (<a>List.toFinset_card_le</a> l)", [{"full_name": "Set.univ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [153, 5], "def_end_pos": [153, 9]}, {"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "Cardinal.mk_le_mk_of_subset", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2096, 9], "def_end_pos": [2096, 27]}, {"full_name": "Cardinal.mk_coe_finset", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1428, 9], "def_end_pos": [1428, 22]}, {"full_name": "List.toFinset_card_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [238, 9], "def_end_pos": [238, 30]}]], "state_before": "\u03b1\u271d \u03b2 : Type u\nc : Cardinal.{?u.255975}\n\u03b1 : Type u_1\nl : List \u03b1\nh : \u2200 (z : \u03b1), z \u2208 l\n\u22a2 #\u03b1 \u2264 \u2191(List.length l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/Lemmas.lean", "full_name": "Std.RBSet.find?_insert_of_eq", "start": [724, 1], "end": [726, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "BoundedLatticeHom.coe_toBoundedOrderHom", "start": [1239, 1], "end": [1239, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WellFoundedSet.lean", "full_name": "Set.WellFoundedOn.mono'", "start": [131, 1], "end": [133, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.smul_set_mono", "start": [351, 1], "end": [352, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/PartENat.lean", "full_name": "PartENat.withTopEquiv_le", "start": [762, 1], "end": [763, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/FunLike/Equiv.lean", "full_name": "EquivLike.inv_injective", "start": [155, 1], "end": [156, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "controlled_prod_of_mem_closure_range", "start": [1778, 1], "end": [1787, 51], "traced_tactics": [{"tactic": "obtain \u27e8v, sum_v, v_in, hv\u2080, hv_pos\u27e9 := controlled_prod_of_mem_closure hb b_pos", "annotated_tactic": ["obtain \u27e8v, sum_v, v_in, hv\u2080, hv_pos\u27e9 := <a>controlled_prod_of_mem_closure</a> hb b_pos", [{"full_name": "controlled_prod_of_mem_closure", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [1745, 9], "def_end_pos": [1745, 39]}]], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b\u271d b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nj : E \u2192* F\nb : F\nhb : b \u2208 closure \u2191(MonoidHom.range j)\nf : \u2115 \u2192 \u211d\nb_pos : \u2200 (n : \u2115), 0 < f n\n\u22a2 \u2203 a,\n    Tendsto (fun n => \u220f i in range (n + 1), j (a i)) atTop (\ud835\udcdd b) \u2227\n      \u2016j (a 0) / b\u2016 < f 0 \u2227 \u2200 (n : \u2115), 0 < n \u2192 \u2016j (a n)\u2016 < f n", "state_after": "case intro.intro.intro.intro\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b\u271d b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nj : E \u2192* F\nb : F\nhb : b \u2208 closure \u2191(MonoidHom.range j)\nf : \u2115 \u2192 \u211d\nb_pos : \u2200 (n : \u2115), 0 < f n\nv : \u2115 \u2192 F\nsum_v : Tendsto (fun n => \u220f i in range (n + 1), v i) atTop (\ud835\udcdd b)\nv_in : \u2200 (n : \u2115), v n \u2208 MonoidHom.range j\nhv\u2080 : \u2016v 0 / b\u2016 < f 0\nhv_pos : \u2200 (n : \u2115), 0 < n \u2192 \u2016v n\u2016 < f n\n\u22a2 \u2203 a,\n    Tendsto (fun n => \u220f i in range (n + 1), j (a i)) atTop (\ud835\udcdd b) \u2227\n      \u2016j (a 0) / b\u2016 < f 0 \u2227 \u2200 (n : \u2115), 0 < n \u2192 \u2016j (a n)\u2016 < f n"}, {"tactic": "choose g hg using v_in", "annotated_tactic": ["choose g hg using v_in", []], "state_before": "case intro.intro.intro.intro\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b\u271d b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nj : E \u2192* F\nb : F\nhb : b \u2208 closure \u2191(MonoidHom.range j)\nf : \u2115 \u2192 \u211d\nb_pos : \u2200 (n : \u2115), 0 < f n\nv : \u2115 \u2192 F\nsum_v : Tendsto (fun n => \u220f i in range (n + 1), v i) atTop (\ud835\udcdd b)\nv_in : \u2200 (n : \u2115), v n \u2208 MonoidHom.range j\nhv\u2080 : \u2016v 0 / b\u2016 < f 0\nhv_pos : \u2200 (n : \u2115), 0 < n \u2192 \u2016v n\u2016 < f n\n\u22a2 \u2203 a,\n    Tendsto (fun n => \u220f i in range (n + 1), j (a i)) atTop (\ud835\udcdd b) \u2227\n      \u2016j (a 0) / b\u2016 < f 0 \u2227 \u2200 (n : \u2115), 0 < n \u2192 \u2016j (a n)\u2016 < f n", "state_after": "case intro.intro.intro.intro\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b\u271d b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nj : E \u2192* F\nb : F\nhb : b \u2208 closure \u2191(MonoidHom.range j)\nf : \u2115 \u2192 \u211d\nb_pos : \u2200 (n : \u2115), 0 < f n\nv : \u2115 \u2192 F\nsum_v : Tendsto (fun n => \u220f i in range (n + 1), v i) atTop (\ud835\udcdd b)\nhv\u2080 : \u2016v 0 / b\u2016 < f 0\nhv_pos : \u2200 (n : \u2115), 0 < n \u2192 \u2016v n\u2016 < f n\ng : \u2115 \u2192 E\nhg : \u2200 (n : \u2115), j (g n) = v n\n\u22a2 \u2203 a,\n    Tendsto (fun n => \u220f i in range (n + 1), j (a i)) atTop (\ud835\udcdd b) \u2227\n      \u2016j (a 0) / b\u2016 < f 0 \u2227 \u2200 (n : \u2115), 0 < n \u2192 \u2016j (a n)\u2016 < f n"}, {"tactic": "exact\n  \u27e8g, by simpa [\u2190 hg] using sum_v, by simpa [hg 0] using hv\u2080,\n    fun n hn => by simpa [hg] using hv_pos n hn\u27e9", "annotated_tactic": ["exact\n    \u27e8g, by simpa [\u2190 hg] using sum_v, by simpa [hg 0] using hv\u2080,\n      fun n hn => by simpa [hg] using hv_pos n hn\u27e9", []], "state_before": "case intro.intro.intro.intro\n\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b\u271d b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nj : E \u2192* F\nb : F\nhb : b \u2208 closure \u2191(MonoidHom.range j)\nf : \u2115 \u2192 \u211d\nb_pos : \u2200 (n : \u2115), 0 < f n\nv : \u2115 \u2192 F\nsum_v : Tendsto (fun n => \u220f i in range (n + 1), v i) atTop (\ud835\udcdd b)\nhv\u2080 : \u2016v 0 / b\u2016 < f 0\nhv_pos : \u2200 (n : \u2115), 0 < n \u2192 \u2016v n\u2016 < f n\ng : \u2115 \u2192 E\nhg : \u2200 (n : \u2115), j (g n) = v n\n\u22a2 \u2203 a,\n    Tendsto (fun n => \u220f i in range (n + 1), j (a i)) atTop (\ud835\udcdd b) \u2227\n      \u2016j (a 0) / b\u2016 < f 0 \u2227 \u2200 (n : \u2115), 0 < n \u2192 \u2016j (a n)\u2016 < f n", "state_after": "no goals"}, {"tactic": "simpa [\u2190 hg] using sum_v", "annotated_tactic": ["simpa [\u2190 hg] using sum_v", []], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b\u271d b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nj : E \u2192* F\nb : F\nhb : b \u2208 closure \u2191(MonoidHom.range j)\nf : \u2115 \u2192 \u211d\nb_pos : \u2200 (n : \u2115), 0 < f n\nv : \u2115 \u2192 F\nsum_v : Tendsto (fun n => \u220f i in range (n + 1), v i) atTop (\ud835\udcdd b)\nhv\u2080 : \u2016v 0 / b\u2016 < f 0\nhv_pos : \u2200 (n : \u2115), 0 < n \u2192 \u2016v n\u2016 < f n\ng : \u2115 \u2192 E\nhg : \u2200 (n : \u2115), j (g n) = v n\n\u22a2 Tendsto (fun n => \u220f i in range (n + 1), j (g i)) atTop (\ud835\udcdd b)", "state_after": "no goals"}, {"tactic": "simpa [hg 0] using hv\u2080", "annotated_tactic": ["simpa [hg 0] using hv\u2080", []], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b\u271d b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nj : E \u2192* F\nb : F\nhb : b \u2208 closure \u2191(MonoidHom.range j)\nf : \u2115 \u2192 \u211d\nb_pos : \u2200 (n : \u2115), 0 < f n\nv : \u2115 \u2192 F\nsum_v : Tendsto (fun n => \u220f i in range (n + 1), v i) atTop (\ud835\udcdd b)\nhv\u2080 : \u2016v 0 / b\u2016 < f 0\nhv_pos : \u2200 (n : \u2115), 0 < n \u2192 \u2016v n\u2016 < f n\ng : \u2115 \u2192 E\nhg : \u2200 (n : \u2115), j (g n) = v n\n\u22a2 \u2016j (g 0) / b\u2016 < f 0", "state_after": "no goals"}, {"tactic": "simpa [hg] using hv_pos n hn", "annotated_tactic": ["simpa [hg] using hv_pos n hn", []], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b\u271d b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nj : E \u2192* F\nb : F\nhb : b \u2208 closure \u2191(MonoidHom.range j)\nf : \u2115 \u2192 \u211d\nb_pos : \u2200 (n : \u2115), 0 < f n\nv : \u2115 \u2192 F\nsum_v : Tendsto (fun n => \u220f i in range (n + 1), v i) atTop (\ud835\udcdd b)\nhv\u2080 : \u2016v 0 / b\u2016 < f 0\nhv_pos : \u2200 (n : \u2115), 0 < n \u2192 \u2016v n\u2016 < f n\ng : \u2115 \u2192 E\nhg : \u2200 (n : \u2115), j (g n) = v n\nn : \u2115\nhn : 0 < n\n\u22a2 \u2016j (g n)\u2016 < f n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rat/Cast/Defs.lean", "full_name": "Rat.cast_mk_of_ne_zero", "start": [79, 1], "end": [98, 49], "traced_tactics": [{"tactic": "have b0' : b \u2260 0 := by\n  refine' mt _ b0\n  simp (config := { contextual := true })", "annotated_tactic": ["have b0' : b \u2260 0 := by\n    refine' <a>mt</a> _ b0\n    simp (config := { contextual := <a>true</a> })", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\n\u22a2 \u2191(a /. b) = \u2191a / \u2191b", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\n\u22a2 \u2191(a /. b) = \u2191a / \u2191b"}, {"tactic": "cases' e : a /. b with n d h c", "annotated_tactic": ["cases' e : a /. b with n d h c", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\n\u22a2 \u2191(a /. b) = \u2191a / \u2191b", "state_after": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b"}, {"tactic": "have d0 : (d : \u03b1) \u2260 0 := by\n  intro d0\n  have dd := den_dvd a b\n  cases' show (d : \u2124) \u2223 b by rwa [e] at dd with k ke\n  have : (b : \u03b1) = (d : \u03b1) * (k : \u03b1) := by rw [ke, Int.cast_mul, Int.cast_ofNat]\n  rw [d0, zero_mul] at this\n  contradiction", "annotated_tactic": ["have d0 : (d : \u03b1) \u2260 0 := by\n    intro d0\n    have dd := <a>den_dvd</a> a b\n    cases' show (d : \u2124) \u2223 b by rwa [e] at dd with k ke\n    have : (b : \u03b1) = (d : \u03b1) * (k : \u03b1) := by rw [ke, <a>Int.cast_mul</a>, <a>Int.cast_ofNat</a>]\n    rw [d0, <a>zero_mul</a>] at this\n    contradiction", [{"full_name": "Rat.den_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Lemmas.lean", "def_pos": [31, 9], "def_end_pos": [31, 16]}, {"full_name": "Int.cast_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Basic.lean", "def_pos": [61, 9], "def_end_pos": [61, 17]}, {"full_name": "Int.cast_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}, {"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}]], "state_before": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b", "state_after": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d \u2260 0\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b"}, {"tactic": "rw [num_den'] at e", "annotated_tactic": ["rw [<a>num_den'</a>] at e", [{"full_name": "Rat.num_den'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 17]}]], "state_before": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d \u2260 0\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b", "state_after": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = n /. \u2191d\nd0 : \u2191d \u2260 0\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b"}, {"tactic": "have := congr_arg ((\u2191) : \u2124 \u2192 \u03b1)\n  ((divInt_eq_iff b0' <| ne_of_gt <| Int.coe_nat_pos.2 h.bot_lt).1 e)", "annotated_tactic": ["have := <a>congr_arg</a> ((\u2191) : \u2124 \u2192 \u03b1)\n    ((<a>divInt_eq_iff</a> b0' <| <a>ne_of_gt</a> <| <a>Int.coe_nat_pos</a>.2 h.bot_lt).1 e)", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}, {"full_name": "Rat.divInt_eq_iff", "def_path": ".lake/packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 22]}, {"full_name": "ne_of_gt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [98, 9], "def_end_pos": [98, 17]}, {"full_name": "Int.coe_nat_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [40, 9], "def_end_pos": [40, 20]}]], "state_before": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = n /. \u2191d\nd0 : \u2191d \u2260 0\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b", "state_after": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = n /. \u2191d\nd0 : \u2191d \u2260 0\nthis : \u2191(a * \u2191d) = \u2191(n * b)\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b"}, {"tactic": "rw [Int.cast_mul, Int.cast_mul, Int.cast_ofNat] at this", "annotated_tactic": ["rw [<a>Int.cast_mul</a>, <a>Int.cast_mul</a>, <a>Int.cast_ofNat</a>] at this", [{"full_name": "Int.cast_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Basic.lean", "def_pos": [61, 9], "def_end_pos": [61, 17]}, {"full_name": "Int.cast_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Basic.lean", "def_pos": [61, 9], "def_end_pos": [61, 17]}, {"full_name": "Int.cast_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}]], "state_before": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = n /. \u2191d\nd0 : \u2191d \u2260 0\nthis : \u2191(a * \u2191d) = \u2191(n * b)\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b", "state_after": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = n /. \u2191d\nd0 : \u2191d \u2260 0\nthis : \u2191a * \u2191d = \u2191n * \u2191b\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b"}, {"tactic": "apply Eq.symm", "annotated_tactic": ["apply <a>Eq.symm</a>", [{"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = n /. \u2191d\nd0 : \u2191d \u2260 0\nthis : \u2191a * \u2191d = \u2191n * \u2191b\n\u22a2 \u2191{ num := n, den := d, den_nz := h, reduced := c } = \u2191a / \u2191b", "state_after": "case mk'.h\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = n /. \u2191d\nd0 : \u2191d \u2260 0\nthis : \u2191a * \u2191d = \u2191n * \u2191b\n\u22a2 \u2191a / \u2191b = \u2191{ num := n, den := d, den_nz := h, reduced := c }"}, {"tactic": "rw [cast_def, div_eq_mul_inv, eq_div_iff_mul_eq d0, mul_assoc, (d.commute_cast _).eq, \u2190 mul_assoc,\n  this, mul_assoc, mul_inv_cancel b0, mul_one]", "annotated_tactic": ["rw [<a>cast_def</a>, <a>div_eq_mul_inv</a>, <a>eq_div_iff_mul_eq</a> d0, <a>mul_assoc</a>, (d.commute_cast _).<a>eq</a>, \u2190 <a>mul_assoc</a>,\n    this, <a>mul_assoc</a>, <a>mul_inv_cancel</a> b0, <a>mul_one</a>]", [{"full_name": "Rat.cast_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Field/Defs.lean", "def_pos": [140, 9], "def_end_pos": [140, 17]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "eq_div_iff_mul_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [365, 7], "def_end_pos": [365, 24]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "Commute.eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [55, 19], "def_end_pos": [55, 21]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_inv_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [193, 15], "def_end_pos": [193, 29]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "case mk'.h\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = n /. \u2191d\nd0 : \u2191d \u2260 0\nthis : \u2191a * \u2191d = \u2191n * \u2191b\n\u22a2 \u2191a / \u2191b = \u2191{ num := n, den := d, den_nz := h, reduced := c }", "state_after": "no goals"}, {"tactic": "refine' mt _ b0", "annotated_tactic": ["refine' <a>mt</a> _ b0", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\n\u22a2 b \u2260 0", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\n\u22a2 b = 0 \u2192 \u2191b = 0"}, {"tactic": "simp (config := { contextual := true })", "annotated_tactic": ["simp (config := { contextual := <a>true</a> })", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\n\u22a2 b = 0 \u2192 \u2191b = 0", "state_after": "no goals"}, {"tactic": "intro d0", "annotated_tactic": ["intro d0", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\n\u22a2 \u2191d \u2260 0", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\n\u22a2 False"}, {"tactic": "have dd := den_dvd a b", "annotated_tactic": ["have dd := <a>den_dvd</a> a b", [{"full_name": "Rat.den_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Lemmas.lean", "def_pos": [31, 9], "def_end_pos": [31, 16]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\n\u22a2 False", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\n\u22a2 False"}, {"tactic": "cases' show (d : \u2124) \u2223 b by rwa [e] at dd with k ke", "annotated_tactic": ["cases' show (d : \u2124) \u2223 b by rwa [e] at dd with k ke", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\n\u22a2 False", "state_after": "case intro\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\nk : \u2124\nke : b = \u2191d * k\n\u22a2 False"}, {"tactic": "have : (b : \u03b1) = (d : \u03b1) * (k : \u03b1) := by rw [ke, Int.cast_mul, Int.cast_ofNat]", "annotated_tactic": ["have : (b : \u03b1) = (d : \u03b1) * (k : \u03b1) := by rw [ke, <a>Int.cast_mul</a>, <a>Int.cast_ofNat</a>]", [{"full_name": "Int.cast_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Basic.lean", "def_pos": [61, 9], "def_end_pos": [61, 17]}, {"full_name": "Int.cast_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}]], "state_before": "case intro\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\nk : \u2124\nke : b = \u2191d * k\n\u22a2 False", "state_after": "case intro\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\nk : \u2124\nke : b = \u2191d * k\nthis : \u2191b = \u2191d * \u2191k\n\u22a2 False"}, {"tactic": "rw [d0, zero_mul] at this", "annotated_tactic": ["rw [d0, <a>zero_mul</a>] at this", [{"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}]], "state_before": "case intro\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\nk : \u2124\nke : b = \u2191d * k\nthis : \u2191b = \u2191d * \u2191k\n\u22a2 False", "state_after": "case intro\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\nk : \u2124\nke : b = \u2191d * k\nthis : \u2191b = 0\n\u22a2 False"}, {"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "case intro\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\nk : \u2124\nke : b = \u2191d * k\nthis : \u2191b = 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rwa [e] at dd", "annotated_tactic": ["rwa [e] at dd", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\n\u22a2 \u2191d \u2223 b", "state_after": "no goals"}, {"tactic": "rw [ke, Int.cast_mul, Int.cast_ofNat]", "annotated_tactic": ["rw [ke, <a>Int.cast_mul</a>, <a>Int.cast_ofNat</a>]", [{"full_name": "Int.cast_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Basic.lean", "def_pos": [61, 9], "def_end_pos": [61, 17]}, {"full_name": "Int.cast_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\na b : \u2124\nb0 : \u2191b \u2260 0\nb0' : b \u2260 0\nn : \u2124\nd : \u2115\nh : d \u2260 0\nc : Nat.Coprime (Int.natAbs n) d\ne : a /. b = { num := n, den := d, den_nz := h, reduced := c }\nd0 : \u2191d = 0\ndd : \u2191(a /. b).den \u2223 b\nk : \u2124\nke : b = \u2191d * k\n\u22a2 \u2191b = \u2191d * \u2191k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Defs.lean", "full_name": "Finsupp.neg_apply", "start": [1301, 1], "end": [1302, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/LocallyFinite.lean", "full_name": "locallyFinite_sum", "start": [214, 1], "end": [217, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/CountableInter.lean", "full_name": "EventuallyEq.countable_iInter", "start": [106, 1], "end": [109, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "ne_top_of_lt", "start": [90, 1], "end": [91, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Basic.lean", "full_name": "mem_nhds_uniformity_iff_left", "start": [718, 1], "end": [721, 80], "traced_tactics": [{"tactic": "rw [uniformity_eq_symm, mem_nhds_uniformity_iff_right]", "annotated_tactic": ["rw [<a>uniformity_eq_symm</a>, <a>mem_nhds_uniformity_iff_right</a>]", [{"full_name": "uniformity_eq_symm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 27]}, {"full_name": "mem_nhds_uniformity_iff_right", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [701, 9], "def_end_pos": [701, 38]}]], "state_before": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\n\u03b4 : Type ud\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 \ud835\udcdd x \u2194 {p | p.2 = x \u2192 p.1 \u2208 s} \u2208 \ud835\udce4 \u03b1", "state_after": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\n\u03b4 : Type ud\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 \ud835\udce4 \u03b1 \u2194 {p | p.2 = x \u2192 p.1 \u2208 s} \u2208 Prod.swap <$> \ud835\udce4 \u03b1"}, {"tactic": "simp only [map_def, mem_map, preimage_setOf_eq, Prod.snd_swap, Prod.fst_swap]", "annotated_tactic": ["simp only [<a>map_def</a>, <a>mem_map</a>, <a>preimage_setOf_eq</a>, <a>Prod.snd_swap</a>, <a>Prod.fst_swap</a>]", [{"full_name": "Filter.map_def", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2204, 9], "def_end_pos": [2204, 16]}, {"full_name": "Filter.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1946, 9], "def_end_pos": [1946, 16]}, {"full_name": "Set.preimage_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [106, 9], "def_end_pos": [106, 26]}, {"full_name": "Prod.snd_swap", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [173, 9], "def_end_pos": [173, 17]}, {"full_name": "Prod.fst_swap", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [168, 9], "def_end_pos": [168, 17]}]], "state_before": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\n\u03b4 : Type ud\n\u03b9 : Sort u_1\ninst\u271d : UniformSpace \u03b1\nx : \u03b1\ns : Set \u03b1\n\u22a2 {p | p.1 = x \u2192 p.2 \u2208 s} \u2208 \ud835\udce4 \u03b1 \u2194 {p | p.2 = x \u2192 p.1 \u2208 s} \u2208 Prod.swap <$> \ud835\udce4 \u03b1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.IsBigO.mul", "start": [1616, 1], "end": [1620, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "full_name": "Finset.sum_centroidWeightsIndicator_eq_one_of_nonempty", "start": [915, 1], "end": [918, 53], "traced_tactics": [{"tactic": "rw [sum_centroidWeightsIndicator]", "annotated_tactic": ["rw [<a>sum_centroidWeightsIndicator</a>]", [{"full_name": "Finset.sum_centroidWeightsIndicator", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [899, 9], "def_end_pos": [899, 37]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2075 : DivisionRing k\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module k V\ninst\u271d\u00b2 : AffineSpace V P\n\u03b9 : Type u_4\ns : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\ninst\u271d\u00b9 : CharZero k\ninst\u271d : Fintype \u03b9\nh : s.Nonempty\n\u22a2 \u2211 i : \u03b9, centroidWeightsIndicator k s i = 1", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2075 : DivisionRing k\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module k V\ninst\u271d\u00b2 : AffineSpace V P\n\u03b9 : Type u_4\ns : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\ninst\u271d\u00b9 : CharZero k\ninst\u271d : Fintype \u03b9\nh : s.Nonempty\n\u22a2 \u2211 i in s, centroidWeights k s i = 1"}, {"tactic": "exact s.sum_centroidWeights_eq_one_of_nonempty k h", "annotated_tactic": ["exact s.sum_centroidWeights_eq_one_of_nonempty k h", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2075 : DivisionRing k\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module k V\ninst\u271d\u00b2 : AffineSpace V P\n\u03b9 : Type u_4\ns : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\ninst\u271d\u00b9 : CharZero k\ninst\u271d : Fintype \u03b9\nh : s.Nonempty\n\u22a2 \u2211 i in s, centroidWeights k s i = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.elem_iff", "start": [97, 9], "end": [98, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Between.lean", "full_name": "wbtw_smul_vadd_smul_vadd_of_nonneg_of_le", "start": [762, 1], "end": [766, 76], "traced_tactics": [{"tactic": "refine' \u27e8r\u2081 / r\u2082, \u27e8div_nonneg hr\u2081 (hr\u2081.trans hr\u2082), div_le_one_of_le hr\u2082 (hr\u2081.trans hr\u2082)\u27e9, _\u27e9", "annotated_tactic": ["refine' \u27e8r\u2081 / r\u2082, \u27e8<a>div_nonneg</a> hr\u2081 (hr\u2081.trans hr\u2082), <a>div_le_one_of_le</a> hr\u2082 (hr\u2081.trans hr\u2082)\u27e9, _\u27e9", [{"full_name": "div_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [95, 9], "def_end_pos": [95, 19]}, {"full_name": "div_le_one_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [243, 9], "def_end_pos": [243, 25]}]], "state_before": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u00b3 : LinearOrderedField R\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module R V\ninst\u271d : AddTorsor V P\nx : P\nv : V\nr\u2081 r\u2082 : R\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : r\u2081 \u2264 r\u2082\n\u22a2 Wbtw R x (r\u2081 \u2022 v +\u1d65 x) (r\u2082 \u2022 v +\u1d65 x)", "state_after": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u00b3 : LinearOrderedField R\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module R V\ninst\u271d : AddTorsor V P\nx : P\nv : V\nr\u2081 r\u2082 : R\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : r\u2081 \u2264 r\u2082\n\u22a2 (lineMap x (r\u2082 \u2022 v +\u1d65 x)) (r\u2081 / r\u2082) = r\u2081 \u2022 v +\u1d65 x"}, {"tactic": "by_cases h : r\u2081 = 0", "annotated_tactic": ["by_cases h : r\u2081 = 0", []], "state_before": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u00b3 : LinearOrderedField R\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module R V\ninst\u271d : AddTorsor V P\nx : P\nv : V\nr\u2081 r\u2082 : R\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : r\u2081 \u2264 r\u2082\n\u22a2 (lineMap x (r\u2082 \u2022 v +\u1d65 x)) (r\u2081 / r\u2082) = r\u2081 \u2022 v +\u1d65 x", "state_after": "case pos\nR : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u00b3 : LinearOrderedField R\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module R V\ninst\u271d : AddTorsor V P\nx : P\nv : V\nr\u2081 r\u2082 : R\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : r\u2081 \u2264 r\u2082\nh : r\u2081 = 0\n\u22a2 (lineMap x (r\u2082 \u2022 v +\u1d65 x)) (r\u2081 / r\u2082) = r\u2081 \u2022 v +\u1d65 x\n\ncase neg\nR : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u00b3 : LinearOrderedField R\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module R V\ninst\u271d : AddTorsor V P\nx : P\nv : V\nr\u2081 r\u2082 : R\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : r\u2081 \u2264 r\u2082\nh : \u00acr\u2081 = 0\n\u22a2 (lineMap x (r\u2082 \u2022 v +\u1d65 x)) (r\u2081 / r\u2082) = r\u2081 \u2022 v +\u1d65 x"}, {"tactic": "simp [lineMap_apply, smul_smul, ((hr\u2081.lt_of_ne' h).trans_le hr\u2082).ne.symm]", "annotated_tactic": ["simp [<a>lineMap_apply</a>, <a>smul_smul</a>, ((hr\u2081.lt_of_ne' h).<a>trans_le</a> hr\u2082).ne.symm]", [{"full_name": "AffineMap.lineMap_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "def_pos": [506, 9], "def_end_pos": [506, 22]}, {"full_name": "smul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [473, 9], "def_end_pos": [473, 18]}, {"full_name": "LT.lt.trans_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [145, 7], "def_end_pos": [145, 21]}]], "state_before": "case neg\nR : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u00b3 : LinearOrderedField R\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module R V\ninst\u271d : AddTorsor V P\nx : P\nv : V\nr\u2081 r\u2082 : R\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : r\u2081 \u2264 r\u2082\nh : \u00acr\u2081 = 0\n\u22a2 (lineMap x (r\u2082 \u2022 v +\u1d65 x)) (r\u2081 / r\u2082) = r\u2081 \u2022 v +\u1d65 x", "state_after": "no goals"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case pos\nR : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u00b3 : LinearOrderedField R\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module R V\ninst\u271d : AddTorsor V P\nx : P\nv : V\nr\u2081 r\u2082 : R\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : r\u2081 \u2264 r\u2082\nh : r\u2081 = 0\n\u22a2 (lineMap x (r\u2082 \u2022 v +\u1d65 x)) (r\u2081 / r\u2082) = r\u2081 \u2022 v +\u1d65 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "LinearEquiv.coe_prod", "start": [819, 1], "end": [821, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Image.lean", "full_name": "StrictMono.image_Ioc_subset", "start": [235, 1], "end": [236, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Basic.lean", "full_name": "NormedSpace.noncompactSpace", "start": [231, 11], "end": [241, 54], "traced_tactics": [{"tactic": "by_cases H : \u2203 c : \ud835\udd5c, c \u2260 0 \u2227 \u2016c\u2016 \u2260 1", "annotated_tactic": ["by_cases H : \u2203 c : \ud835\udd5c, c \u2260 0 \u2227 \u2016c\u2016 \u2260 1", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\n\u22a2 NoncompactSpace E", "state_after": "case pos\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2203 c, c \u2260 0 \u2227 \u2016c\u2016 \u2260 1\n\u22a2 NoncompactSpace E\n\ncase neg\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u00ac\u2203 c, c \u2260 0 \u2227 \u2016c\u2016 \u2260 1\n\u22a2 NoncompactSpace E"}, {"tactic": "letI := NontriviallyNormedField.ofNormNeOne H", "annotated_tactic": ["letI := <a>NontriviallyNormedField.ofNormNeOne</a> H", [{"full_name": "NontriviallyNormedField.ofNormNeOne", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Field/Basic.lean", "def_pos": [1026, 5], "def_end_pos": [1026, 40]}]], "state_before": "case pos\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2203 c, c \u2260 0 \u2227 \u2016c\u2016 \u2260 1\n\u22a2 NoncompactSpace E", "state_after": "case pos\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2203 c, c \u2260 0 \u2227 \u2016c\u2016 \u2260 1\nthis : NontriviallyNormedField \ud835\udd5c := NontriviallyNormedField.ofNormNeOne H\n\u22a2 NoncompactSpace E"}, {"tactic": "exact \u27e8fun h \u21a6 NormedSpace.unbounded_univ \ud835\udd5c E h.isBounded\u27e9", "annotated_tactic": ["exact \u27e8fun h \u21a6 <a>NormedSpace.unbounded_univ</a> \ud835\udd5c E h.isBounded\u27e9", [{"full_name": "NormedSpace.unbounded_univ", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Basic.lean", "def_pos": [201, 19], "def_end_pos": [201, 45]}]], "state_before": "case pos\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2203 c, c \u2260 0 \u2227 \u2016c\u2016 \u2260 1\nthis : NontriviallyNormedField \ud835\udd5c := NontriviallyNormedField.ofNormNeOne H\n\u22a2 NoncompactSpace E", "state_after": "no goals"}, {"tactic": "push_neg at H", "annotated_tactic": ["push_neg at H", []], "state_before": "case neg\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u00ac\u2203 c, c \u2260 0 \u2227 \u2016c\u2016 \u2260 1\n\u22a2 NoncompactSpace E", "state_after": "case neg\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\n\u22a2 NoncompactSpace E"}, {"tactic": "rcases exists_ne (0 : E) with \u27e8x, hx\u27e9", "annotated_tactic": ["rcases <a>exists_ne</a> (0 : E) with \u27e8x, hx\u27e9", [{"full_name": "exists_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [53, 9], "def_end_pos": [53, 18]}]], "state_before": "case neg\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\n\u22a2 NoncompactSpace E", "state_after": "case neg.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\nx : E\nhx : x \u2260 0\n\u22a2 NoncompactSpace E"}, {"tactic": "refine closedEmbedding_of_pairwise_le_dist (norm_pos_iff.2 hx) fun k n hne \u21a6 ?_", "annotated_tactic": ["refine <a>closedEmbedding_of_pairwise_le_dist</a> (<a>norm_pos_iff</a>.2 hx) fun k n hne \u21a6 ?_", [{"full_name": "Metric.closedEmbedding_of_pairwise_le_dist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Basic.lean", "def_pos": [166, 9], "def_end_pos": [166, 44]}, {"full_name": "norm_pos_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2106, 30], "def_end_pos": [2106, 42]}]], "state_before": "case neg.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\nx : E\nhx : x \u2260 0\n\u22a2 ClosedEmbedding fun x_1 => (Infinite.natEmbedding \ud835\udd5c) x_1 \u2022 x", "state_after": "case neg.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\nx : E\nhx : x \u2260 0\nk n : \u2115\nhne : k \u2260 n\n\u22a2 (fun x_1 y => \u2016x\u2016 \u2264 dist ((Infinite.natEmbedding \ud835\udd5c) x_1 \u2022 x) ((Infinite.natEmbedding \ud835\udd5c) y \u2022 x)) k n"}, {"tactic": "simp only [dist_eq_norm, \u2190 sub_smul, norm_smul]", "annotated_tactic": ["simp only [<a>dist_eq_norm</a>, \u2190 <a>sub_smul</a>, <a>norm_smul</a>]", [{"full_name": "dist_eq_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [411, 7], "def_end_pos": [411, 19]}, {"full_name": "sub_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [274, 9], "def_end_pos": [274, 17]}, {"full_name": "norm_smul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/MulAction.lean", "def_pos": [90, 9], "def_end_pos": [90, 18]}]], "state_before": "case neg.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\nx : E\nhx : x \u2260 0\nk n : \u2115\nhne : k \u2260 n\n\u22a2 (fun x_1 y => \u2016x\u2016 \u2264 dist ((Infinite.natEmbedding \ud835\udd5c) x_1 \u2022 x) ((Infinite.natEmbedding \ud835\udd5c) y \u2022 x)) k n", "state_after": "case neg.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\nx : E\nhx : x \u2260 0\nk n : \u2115\nhne : k \u2260 n\n\u22a2 \u2016x\u2016 \u2264 \u2016(Infinite.natEmbedding \ud835\udd5c) k - (Infinite.natEmbedding \ud835\udd5c) n\u2016 * \u2016x\u2016"}, {"tactic": "rw [H, one_mul]", "annotated_tactic": ["rw [H, <a>one_mul</a>]", [{"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "case neg.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\nx : E\nhx : x \u2260 0\nk n : \u2115\nhne : k \u2260 n\n\u22a2 \u2016x\u2016 \u2264 \u2016(Infinite.natEmbedding \ud835\udd5c) k - (Infinite.natEmbedding \ud835\udd5c) n\u2016 * \u2016x\u2016", "state_after": "case neg.intro._\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\nx : E\nhx : x \u2260 0\nk n : \u2115\nhne : k \u2260 n\n\u22a2 (Infinite.natEmbedding \ud835\udd5c) k - (Infinite.natEmbedding \ud835\udd5c) n \u2260 0"}, {"tactic": "rwa [sub_ne_zero, (Embedding.injective _).ne_iff]", "annotated_tactic": ["rwa [<a>sub_ne_zero</a>, (<a>Embedding.injective</a> _).<a>ne_iff</a>]", [{"full_name": "sub_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [892, 3], "def_end_pos": [892, 14]}, {"full_name": "Function.Embedding.injective", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [137, 19], "def_end_pos": [137, 28]}, {"full_name": "Function.Injective.ne_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 25]}]], "state_before": "case neg.intro._\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : Infinite \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : Nontrivial E\ninst\u271d : NormedSpace \ud835\udd5c E\nH : \u2200 (c : \ud835\udd5c), c \u2260 0 \u2192 \u2016c\u2016 = 1\nx : E\nhx : x \u2260 0\nk n : \u2115\nhne : k \u2260 n\n\u22a2 (Infinite.natEmbedding \ud835\udd5c) k - (Infinite.natEmbedding \ud835\udd5c) n \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "full_name": "MeasureTheory.SimpleFunc.FinMeasSupp.lintegral_lt_top", "start": [1242, 1], "end": [1251, 58], "traced_tactics": [{"tactic": "refine' sum_lt_top fun a ha => _", "annotated_tactic": ["refine' <a>sum_lt_top</a> fun a ha => _", [{"full_name": "ENNReal.sum_lt_top", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Operations.lean", "def_pos": [490, 9], "def_end_pos": [490, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\n\u22a2 lintegral f \u03bc < \u22a4", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\na : \u211d\u22650\u221e\nha : a \u2208 SimpleFunc.range f\n\u22a2 a * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {a}) \u2260 \u22a4"}, {"tactic": "rcases eq_or_ne a \u221e with (rfl | ha)", "annotated_tactic": ["rcases <a>eq_or_ne</a> a \u221e with (rfl | ha)", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\na : \u211d\u22650\u221e\nha : a \u2208 SimpleFunc.range f\n\u22a2 a * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {a}) \u2260 \u22a4", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\nha : \u22a4 \u2208 SimpleFunc.range f\n\u22a2 \u22a4 * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {\u22a4}) \u2260 \u22a4\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\na : \u211d\u22650\u221e\nha\u271d : a \u2208 SimpleFunc.range f\nha : a \u2260 \u22a4\n\u22a2 a * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {a}) \u2260 \u22a4"}, {"tactic": "simp only [ae_iff, Ne.def, Classical.not_not] at hf", "annotated_tactic": ["simp only [<a>ae_iff</a>, <a>Ne.def</a>, <a>Classical.not_not</a>] at hf", [{"full_name": "MeasureTheory.ae_iff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [388, 9], "def_end_pos": [388, 15]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Classical.not_not", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [128, 24], "def_end_pos": [128, 31]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\nha : \u22a4 \u2208 SimpleFunc.range f\n\u22a2 \u22a4 * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {\u22a4}) \u2260 \u22a4", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nha : \u22a4 \u2208 SimpleFunc.range f\nhf : \u2191\u2191\u03bc {a | \u2191f a = \u22a4} = 0\n\u22a2 \u22a4 * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {\u22a4}) \u2260 \u22a4"}, {"tactic": "simp [Set.preimage, hf]", "annotated_tactic": ["simp [<a>Set.preimage</a>, hf]", [{"full_name": "Set.preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [113, 5], "def_end_pos": [113, 13]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nha : \u22a4 \u2208 SimpleFunc.range f\nhf : \u2191\u2191\u03bc {a | \u2191f a = \u22a4} = 0\n\u22a2 \u22a4 * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {\u22a4}) \u2260 \u22a4", "state_after": "no goals"}, {"tactic": "by_cases ha0 : a = 0", "annotated_tactic": ["by_cases ha0 : a = 0", []], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\na : \u211d\u22650\u221e\nha\u271d : a \u2208 SimpleFunc.range f\nha : a \u2260 \u22a4\n\u22a2 a * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {a}) \u2260 \u22a4", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\na : \u211d\u22650\u221e\nha\u271d : a \u2208 SimpleFunc.range f\nha : a \u2260 \u22a4\nha0 : a = 0\n\u22a2 a * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {a}) \u2260 \u22a4\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\na : \u211d\u22650\u221e\nha\u271d : a \u2208 SimpleFunc.range f\nha : a \u2260 \u22a4\nha0 : \u00aca = 0\n\u22a2 a * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {a}) \u2260 \u22a4"}, {"tactic": "subst a", "annotated_tactic": ["subst a", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\na : \u211d\u22650\u221e\nha\u271d : a \u2208 SimpleFunc.range f\nha : a \u2260 \u22a4\nha0 : a = 0\n\u22a2 a * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {a}) \u2260 \u22a4", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\nha\u271d : 0 \u2208 SimpleFunc.range f\nha : 0 \u2260 \u22a4\n\u22a2 0 * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {0}) \u2260 \u22a4"}, {"tactic": "rwa [zero_mul]", "annotated_tactic": ["rwa [<a>zero_mul</a>]", [{"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\nha\u271d : 0 \u2208 SimpleFunc.range f\nha : 0 \u2260 \u22a4\n\u22a2 0 * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {0}) \u2260 \u22a4", "state_after": "no goals"}, {"tactic": "exact mul_ne_top ha (finMeasSupp_iff.1 hm _ ha0).ne", "annotated_tactic": ["exact <a>mul_ne_top</a> ha (<a>finMeasSupp_iff</a>.1 hm _ ha0).<a>ne</a>", [{"full_name": "ENNReal.mul_ne_top", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Operations.lean", "def_pos": [235, 9], "def_end_pos": [235, 19]}, {"full_name": "MeasureTheory.SimpleFunc.finMeasSupp_iff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "def_pos": [1186, 9], "def_end_pos": [1186, 24]}, {"full_name": "LT.lt.ne", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [149, 7], "def_end_pos": [149, 15]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : Zero \u03b3\n\u03bc : Measure \u03b1\nf\u271d : \u03b1 \u2192\u209b \u03b2\nf : \u03b1 \u2192\u209b \u211d\u22650\u221e\nhm : SimpleFunc.FinMeasSupp f \u03bc\nhf : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2191f a \u2260 \u22a4\na : \u211d\u22650\u221e\nha\u271d : a \u2208 SimpleFunc.range f\nha : a \u2260 \u22a4\nha0 : \u00aca = 0\n\u22a2 a * \u2191\u2191\u03bc (\u2191f \u207b\u00b9' {a}) \u2260 \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Sqrt.lean", "full_name": "Nat.sqrt_le_self", "start": [100, 1], "end": [101, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Subtype.lean", "full_name": "Subtype.refl", "start": [235, 11], "end": [236, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.IsSuffix.filter", "start": [2034, 1], "end": [2037, 42], "traced_tactics": [{"tactic": "obtain \u27e8xs, rfl\u27e9 := h", "annotated_tactic": ["obtain \u27e8xs, rfl\u27e9 := h", []], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\nh : l\u2081 <:+ l\u2082\n\u22a2 List.filter p l\u2081 <:+ List.filter p l\u2082", "state_after": "case intro\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 xs : List \u03b1\n\u22a2 List.filter p l\u2081 <:+ List.filter p (xs ++ l\u2081)"}, {"tactic": "rw [filter_append]", "annotated_tactic": ["rw [<a>filter_append</a>]", [{"full_name": "List.filter_append", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1296, 17], "def_end_pos": [1296, 30]}]], "state_before": "case intro\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 xs : List \u03b1\n\u22a2 List.filter p l\u2081 <:+ List.filter p (xs ++ l\u2081)", "state_after": "case intro\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 xs : List \u03b1\n\u22a2 List.filter p l\u2081 <:+ List.filter p xs ++ List.filter p l\u2081"}, {"tactic": "apply suffix_append", "annotated_tactic": ["apply <a>suffix_append</a>", [{"full_name": "List.suffix_append", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1854, 17], "def_end_pos": [1854, 30]}]], "state_before": "case intro\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 xs : List \u03b1\n\u22a2 List.filter p l\u2081 <:+ List.filter p xs ++ List.filter p l\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Fintype.lean", "full_name": "Equiv.extendSubtype_apply_of_mem", "start": [125, 1], "end": [129, 74], "traced_tactics": [{"tactic": "dsimp only [extendSubtype]", "annotated_tactic": ["dsimp only [<a>extendSubtype</a>]", [{"full_name": "Equiv.extendSubtype", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Fintype.lean", "def_pos": [121, 22], "def_end_pos": [121, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 (extendSubtype e) x = \u2191(e { val := x, property := hx })", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 (subtypeCongr e (toCompl e)) x = \u2191(e { val := x, property := hx })"}, {"tactic": "simp only [subtypeCongr, Equiv.trans_apply, Equiv.sumCongr_apply]", "annotated_tactic": ["simp only [<a>subtypeCongr</a>, <a>Equiv.trans_apply</a>, <a>Equiv.sumCongr_apply</a>]", [{"full_name": "Equiv.subtypeCongr", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [613, 5], "def_end_pos": [613, 17]}, {"full_name": "Equiv.trans_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [280, 17], "def_end_pos": [280, 28]}, {"full_name": "Equiv.sumCongr_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [297, 9], "def_end_pos": [297, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 (subtypeCongr e (toCompl e)) x = \u2191(e { val := x, property := hx })", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 (sumCompl fun x => q x) (Sum.map (\u21d1e) (\u21d1(toCompl e)) ((sumCompl fun x => p x).symm x)) =\n    \u2191(e { val := x, property := hx })"}, {"tactic": "rw [sumCompl_apply_symm_of_pos _ _ hx, Sum.map_inl, sumCompl_apply_inl]", "annotated_tactic": ["rw [<a>sumCompl_apply_symm_of_pos</a> _ _ hx, <a>Sum.map_inl</a>, <a>sumCompl_apply_inl</a>]", [{"full_name": "Equiv.sumCompl_apply_symm_of_pos", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [600, 9], "def_end_pos": [600, 35]}, {"full_name": "Sum.map_inl", "def_path": ".lake/packages/std/Std/Data/Sum/Basic.lean", "def_pos": [95, 17], "def_end_pos": [95, 24]}, {"full_name": "Equiv.sumCompl_apply_inl", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [588, 9], "def_end_pos": [588, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Finite \u03b1\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 (sumCompl fun x => q x) (Sum.map (\u21d1e) (\u21d1(toCompl e)) ((sumCompl fun x => p x).symm x)) =\n    \u2191(e { val := x, property := hx })", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Clopen.lean", "full_name": "isClopen_empty", "start": [48, 1], "end": [48, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.image_add_left_Ioo", "start": [1147, 1], "end": [1148, 78], "traced_tactics": [{"tactic": "rw [\u2190 map_add_left_Ioo, map_eq_image, addLeftEmbedding, Embedding.coeFn_mk]", "annotated_tactic": ["rw [\u2190 <a>map_add_left_Ioo</a>, <a>map_eq_image</a>, <a>addLeftEmbedding</a>, <a>Embedding.coeFn_mk</a>]", [{"full_name": "Finset.map_add_left_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/LocallyFinite/Basic.lean", "def_pos": [1116, 9], "def_end_pos": [1116, 25]}, {"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}, {"full_name": "addLeftEmbedding", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Embedding.lean", "def_pos": [22, 3], "def_end_pos": [22, 14]}, {"full_name": "Function.Embedding.coeFn_mk", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b2 : ExistsAddOfLE \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\n\u22a2 image (fun x => c + x) (Ioo a b) = Ioo (c + a) (c + b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Nilpotent.lean", "full_name": "IsNilpotent.map_iff", "start": [107, 1], "end": [110, 86], "traced_tactics": [{"tactic": "rwa [map_pow]", "annotated_tactic": ["rwa [<a>map_pow</a>]", [{"full_name": "map_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [469, 9], "def_end_pos": [469, 16]}]], "state_before": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d\u00b3 : MonoidWithZero R\ninst\u271d\u00b2 : MonoidWithZero S\nr : R\nF : Type u_3\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : MonoidWithZeroHomClass F R S\nf : F\nhf : Injective \u21d1f\nx\u271d : IsNilpotent (f r)\nk : \u2115\nhk : f r ^ k = 0\n\u22a2 f (r ^ k) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "full_name": "Polynomial.degree_scaleRoots", "start": [76, 1], "end": [84, 16], "traced_tactics": [{"tactic": "haveI := Classical.propDecidable", "annotated_tactic": ["haveI := <a>Classical.propDecidable</a>", [{"full_name": "Classical.propDecidable", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [68, 49], "def_end_pos": [68, 62]}]], "state_before": "R : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\n\u22a2 degree (scaleRoots p s) = degree p", "state_after": "R : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\n\u22a2 degree (scaleRoots p s) = degree p"}, {"tactic": "by_cases hp : p = 0", "annotated_tactic": ["by_cases hp : p = 0", []], "state_before": "R : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\n\u22a2 degree (scaleRoots p s) = degree p", "state_after": "case pos\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : p = 0\n\u22a2 degree (scaleRoots p s) = degree p\n\ncase neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\n\u22a2 degree (scaleRoots p s) = degree p"}, {"tactic": "refine' le_antisymm (Finset.sup_mono (support_scaleRoots_le p s)) (degree_le_degree _)", "annotated_tactic": ["refine' <a>le_antisymm</a> (<a>Finset.sup_mono</a> (<a>support_scaleRoots_le</a> p s)) (<a>degree_le_degree</a> _)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Finset.sup_mono", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [149, 9], "def_end_pos": [149, 17]}, {"full_name": "Polynomial.support_scaleRoots_le", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "def_pos": [60, 9], "def_end_pos": [60, 30]}, {"full_name": "Polynomial.degree_le_degree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [215, 9], "def_end_pos": [215, 25]}]], "state_before": "case neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\n\u22a2 degree (scaleRoots p s) = degree p", "state_after": "case neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\n\u22a2 coeff (scaleRoots p s) (natDegree p) \u2260 0"}, {"tactic": "rw [coeff_scaleRoots_natDegree]", "annotated_tactic": ["rw [<a>coeff_scaleRoots_natDegree</a>]", [{"full_name": "Polynomial.coeff_scaleRoots_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "def_pos": [40, 9], "def_end_pos": [40, 35]}]], "state_before": "case neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\n\u22a2 coeff (scaleRoots p s) (natDegree p) \u2260 0", "state_after": "case neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\n\u22a2 leadingCoeff p \u2260 0"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\n\u22a2 leadingCoeff p \u2260 0", "state_after": "case neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\nh : leadingCoeff p = 0\n\u22a2 False"}, {"tactic": "have := leadingCoeff_eq_zero.mp h", "annotated_tactic": ["have := leadingCoeff_eq_zero.mp h", []], "state_before": "case neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\nh : leadingCoeff p = 0\n\u22a2 False", "state_after": "case neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis\u271d : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\nh : leadingCoeff p = 0\nthis : p = 0\n\u22a2 False"}, {"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "case neg\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis\u271d : (a : Prop) \u2192 Decidable a\nhp : \u00acp = 0\nh : leadingCoeff p = 0\nthis : p = 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [hp, zero_scaleRoots]", "annotated_tactic": ["rw [hp, <a>zero_scaleRoots</a>]", [{"full_name": "Polynomial.zero_scaleRoots", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/ScaleRoots.lean", "def_pos": [46, 9], "def_end_pos": [46, 24]}]], "state_before": "case pos\nR : Type u_1\nS : Type u_2\nA : Type u_3\nK : Type u_4\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\np : R[X]\ns : R\nthis : (a : Prop) \u2192 Decidable a\nhp : p = 0\n\u22a2 degree (scaleRoots p s) = degree p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Data/Bool/Lemmas.lean", "full_name": "Bool.of_decide_true", "start": [123, 1], "end": [124, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Bilinear.lean", "full_name": "Submodule.map\u2082_le", "start": [54, 1], "end": [57, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Pointwise.lean", "full_name": "bddAbove_smul_iff_of_neg", "start": [105, 1], "end": [106, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Lattice.lean", "full_name": "ContinuousAt.finset_sup'_apply", "start": [257, 1], "end": [259, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.mapDomain.addMonoidHom_id", "start": [523, 1], "end": [524, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean", "full_name": "Ordinal.log_mono_right", "start": [358, 1], "end": [364, 67], "traced_tactics": [{"tactic": "simp only [hx, log_zero_right, Ordinal.zero_le]", "annotated_tactic": ["simp only [hx, <a>log_zero_right</a>, <a>Ordinal.zero_le</a>]", [{"full_name": "Ordinal.log_zero_right", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [284, 9], "def_end_pos": [284, 23]}, {"full_name": "Ordinal.zero_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [388, 19], "def_end_pos": [388, 26]}]], "state_before": "b x y : Ordinal.{u_1}\nxy : x \u2264 y\nhx : x = 0\n\u22a2 log b x \u2264 log b y", "state_after": "no goals"}, {"tactic": "simp only [log_of_not_one_lt_left hb, Ordinal.zero_le]", "annotated_tactic": ["simp only [<a>log_of_not_one_lt_left</a> hb, <a>Ordinal.zero_le</a>]", [{"full_name": "Ordinal.log_of_not_one_lt_left", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [270, 9], "def_end_pos": [270, 31]}, {"full_name": "Ordinal.zero_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [388, 19], "def_end_pos": [388, 26]}]], "state_before": "b x y : Ordinal.{u_1}\nxy : x \u2264 y\nhx : \u00acx = 0\nhb : \u00ac1 < b\n\u22a2 log b x \u2264 log b y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Function.lean", "full_name": "Function.LeftInverse.id", "start": [237, 11], "end": [238, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "full_name": "MeasureTheory.SimpleFunc.inv_apply", "start": [525, 1], "end": [526, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/Bounded.lean", "full_name": "TotallyBounded.isVonNBounded", "start": [337, 1], "end": [354, 80], "traced_tactics": [{"tactic": "rw [totallyBounded_iff_subset_finite_iUnion_nhds_zero] at hs", "annotated_tactic": ["rw [<a>totallyBounded_iff_subset_finite_iUnion_nhds_zero</a>] at hs", [{"full_name": "totallyBounded_iff_subset_finite_iUnion_nhds_zero", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/UniformGroup.lean", "def_pos": [466, 3], "def_end_pos": [466, 14]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : TotallyBounded s\n\u22a2 Bornology.IsVonNBounded \ud835\udd5c s", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\n\u22a2 Bornology.IsVonNBounded \ud835\udd5c s"}, {"tactic": "intro U hU", "annotated_tactic": ["intro U hU", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\n\u22a2 Bornology.IsVonNBounded \ud835\udd5c s", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\n\u22a2 Absorbs \ud835\udd5c U s"}, {"tactic": "have h : Filter.Tendsto (fun x : E \u00d7 E => x.fst + x.snd) (\ud835\udcdd (0, 0)) (\ud835\udcdd ((0 : E) + (0 : E))) :=\n  tendsto_add", "annotated_tactic": ["have h : <a>Filter.Tendsto</a> (fun x : E \u00d7 E => x.fst + x.snd) (\ud835\udcdd (0, 0)) (\ud835\udcdd ((0 : E) + (0 : E))) :=\n    <a>tendsto_add</a>", [{"full_name": "Filter.Tendsto", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2962, 5], "def_end_pos": [2962, 12]}, {"full_name": "tendsto_add", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Monoid.lean", "def_pos": [114, 3], "def_end_pos": [114, 14]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\n\u22a2 Absorbs \ud835\udd5c U s", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd (0 + 0))\n\u22a2 Absorbs \ud835\udd5c U s"}, {"tactic": "rw [add_zero] at h", "annotated_tactic": ["rw [<a>add_zero</a>] at h", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd (0 + 0))\n\u22a2 Absorbs \ud835\udd5c U s", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\n\u22a2 Absorbs \ud835\udd5c U s"}, {"tactic": "have h' := (nhds_basis_balanced \ud835\udd5c E).prod (nhds_basis_balanced \ud835\udd5c E)", "annotated_tactic": ["have h' := (<a>nhds_basis_balanced</a> \ud835\udd5c E).<a>prod</a> (<a>nhds_basis_balanced</a> \ud835\udd5c E)", [{"full_name": "nhds_basis_balanced", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "def_pos": [264, 9], "def_end_pos": [264, 28]}, {"full_name": "Filter.HasBasis.prod", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [921, 9], "def_end_pos": [921, 22]}, {"full_name": "nhds_basis_balanced", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "def_pos": [264, 9], "def_end_pos": [264, 28]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\n\u22a2 Absorbs \ud835\udd5c U s", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' :\n  HasBasis (\ud835\udcdd 0 \u00d7\u02e2 \ud835\udcdd 0) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => id i.1 \u00d7\u02e2 id i.2\n\u22a2 Absorbs \ud835\udd5c U s"}, {"tactic": "simp_rw [\u2190 nhds_prod_eq, id.def] at h'", "annotated_tactic": ["simp_rw [\u2190 <a>nhds_prod_eq</a>, <a>id.def</a>] at h'", [{"full_name": "nhds_prod_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [534, 9], "def_end_pos": [534, 21]}, {"full_name": "id.def", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [22, 9], "def_end_pos": [22, 15]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' :\n  HasBasis (\ud835\udcdd 0 \u00d7\u02e2 \ud835\udcdd 0) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => id i.1 \u00d7\u02e2 id i.2\n\u22a2 Absorbs \ud835\udd5c U s", "state_after": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\n\u22a2 Absorbs \ud835\udd5c U s"}, {"tactic": "rcases h.basis_left h' U hU with \u27e8x, hx, h''\u27e9", "annotated_tactic": ["rcases h.basis_left h' U hU with \u27e8x, hx, h''\u27e9", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\n\u22a2 Absorbs \ud835\udd5c U s", "state_after": "case intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\n\u22a2 Absorbs \ud835\udd5c U s"}, {"tactic": "rcases hs x.snd hx.2.1 with \u27e8t, ht, hs\u27e9", "annotated_tactic": ["rcases hs x.snd hx.2.1 with \u27e8t, ht, hs\u27e9", []], "state_before": "case intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\n\u22a2 Absorbs \ud835\udd5c U s", "state_after": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\n\u22a2 Absorbs \ud835\udd5c U s"}, {"tactic": "refine Absorbs.mono_right ?_ hs", "annotated_tactic": ["refine <a>Absorbs.mono_right</a> ?_ hs", [{"full_name": "Absorbs.mono_right", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bornology/Absorbs.lean", "def_pos": [80, 7], "def_end_pos": [80, 17]}]], "state_before": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\n\u22a2 Absorbs \ud835\udd5c U s", "state_after": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\n\u22a2 Absorbs \ud835\udd5c U (\u22c3 y \u2208 t, y +\u1d65 x.2)"}, {"tactic": "rw [ht.absorbs_biUnion]", "annotated_tactic": ["rw [ht.absorbs_biUnion]", []], "state_before": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\n\u22a2 Absorbs \ud835\udd5c U (\u22c3 y \u2208 t, y +\u1d65 x.2)", "state_after": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\n\u22a2 \u2200 i \u2208 t, Absorbs \ud835\udd5c U (i +\u1d65 x.2)"}, {"tactic": "have hx_fstsnd : x.fst + x.snd \u2286 U := add_subset_iff.mpr fun z1 hz1 z2 hz2 \u21a6\n  h'' <| mk_mem_prod hz1 hz2", "annotated_tactic": ["have hx_fstsnd : x.fst + x.snd \u2286 U := add_subset_iff.mpr fun z1 hz1 z2 hz2 \u21a6\n    h'' <| <a>mk_mem_prod</a> hz1 hz2", [{"full_name": "Set.mk_mem_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [214, 9], "def_end_pos": [214, 20]}]], "state_before": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\n\u22a2 \u2200 i \u2208 t, Absorbs \ud835\udd5c U (i +\u1d65 x.2)", "state_after": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\nhx_fstsnd : x.1 + x.2 \u2286 U\n\u22a2 \u2200 i \u2208 t, Absorbs \ud835\udd5c U (i +\u1d65 x.2)"}, {"tactic": "refine fun y _ => Absorbs.mono_left ?_ hx_fstsnd", "annotated_tactic": ["refine fun y _ => <a>Absorbs.mono_left</a> ?_ hx_fstsnd", [{"full_name": "Absorbs.mono_left", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bornology/Absorbs.lean", "def_pos": [76, 7], "def_end_pos": [76, 16]}]], "state_before": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\nhx_fstsnd : x.1 + x.2 \u2286 U\n\u22a2 \u2200 i \u2208 t, Absorbs \ud835\udd5c U (i +\u1d65 x.2)", "state_after": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\nhx_fstsnd : x.1 + x.2 \u2286 U\ny : E\nx\u271d : y \u2208 t\n\u22a2 Absorbs \ud835\udd5c (x.1 + x.2) (y +\u1d65 x.2)"}, {"tactic": "exact Absorbent.vadd_absorbs (absorbent_nhds_zero hx.1.1) hx.2.2.absorbs_self", "annotated_tactic": ["exact <a>Absorbent.vadd_absorbs</a> (<a>absorbent_nhds_zero</a> hx.1.1) hx.2.2.<a>absorbs_self</a>", [{"full_name": "Absorbent.vadd_absorbs", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bornology/Absorbs.lean", "def_pos": [249, 9], "def_end_pos": [249, 21]}, {"full_name": "absorbent_nhds_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/LocallyConvex/Basic.lean", "def_pos": [245, 9], "def_end_pos": [245, 28]}, {"full_name": "Balanced.absorbs_self", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/LocallyConvex/Basic.lean", "def_pos": [231, 9], "def_end_pos": [231, 30]}]], "state_before": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\nE : Type u_3\nE' : Type u_4\nF : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : UniformSpace E\ninst\u271d\u00b9 : UniformAddGroup E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs\u271d : \u2200 U \u2208 \ud835\udcdd 0, \u2203 t, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, y +\u1d65 U\nU : Set E\nhU : U \u2208 \ud835\udcdd 0\nh : Tendsto (fun x => x.1 + x.2) (\ud835\udcdd (0, 0)) (\ud835\udcdd 0)\nh' : HasBasis (\ud835\udcdd (0, 0)) (fun i => (i.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.1) \u2227 i.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c i.2) fun i => i.1 \u00d7\u02e2 i.2\nx : Set E \u00d7 Set E\nhx : (x.1 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.1) \u2227 x.2 \u2208 \ud835\udcdd 0 \u2227 Balanced \ud835\udd5c x.2\nh'' : MapsTo (fun x => x.1 + x.2) (x.1 \u00d7\u02e2 x.2) U\nt : Set E\nht : Set.Finite t\nhs : s \u2286 \u22c3 y \u2208 t, y +\u1d65 x.2\nhx_fstsnd : x.1 + x.2 \u2286 U\ny : E\nx\u271d : y \u2208 t\n\u22a2 Absorbs \ud835\udd5c (x.1 + x.2) (y +\u1d65 x.2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Order.lean", "full_name": "Finset.le_prod_nonempty_of_submultiplicative", "start": [58, 1], "end": [61, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "closedBall_prod_same", "start": [1654, 1], "end": [1656, 38], "traced_tactics": [{"tactic": "simp [Prod.dist_eq]", "annotated_tactic": ["simp [<a>Prod.dist_eq</a>]", [{"full_name": "Prod.dist_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1637, 9], "def_end_pos": [1637, 21]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1\ny : \u03b2\nr : \u211d\nz : \u03b1 \u00d7 \u03b2\n\u22a2 z \u2208 closedBall x r \u00d7\u02e2 closedBall y r \u2194 z \u2208 closedBall (x, y) r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "tsub_add_min", "start": [515, 1], "end": [517, 20], "traced_tactics": [{"tactic": "rw [\u2190 tsub_min, @tsub_add_cancel_of_le]", "annotated_tactic": ["rw [\u2190 <a>tsub_min</a>, @<a>tsub_add_cancel_of_le</a>]", [{"full_name": "tsub_min", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [509, 9], "def_end_pos": [509, 17]}, {"full_name": "tsub_add_cancel_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [30, 9], "def_end_pos": [30, 30]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\n\u22a2 a - b + min a b = a", "state_after": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\n\u22a2 min a b \u2264 a"}, {"tactic": "apply min_le_left", "annotated_tactic": ["apply <a>min_le_left</a>", [{"full_name": "min_le_left", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [33, 9], "def_end_pos": [33, 20]}]], "state_before": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\n\u22a2 min a b \u2264 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "Metric.closedBall_diff_ball", "start": [575, 1], "end": [576, 88], "traced_tactics": [{"tactic": "rw [\u2190 ball_union_sphere, Set.union_diff_cancel_left sphere_disjoint_ball.symm.le_bot]", "annotated_tactic": ["rw [\u2190 <a>ball_union_sphere</a>, <a>Set.union_diff_cancel_left</a> sphere_disjoint_ball.symm.le_bot]", [{"full_name": "Metric.ball_union_sphere", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [560, 9], "def_end_pos": [560, 26]}, {"full_name": "Set.union_diff_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1824, 9], "def_end_pos": [1824, 31]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\n\u03b4 \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\ns : Set \u03b1\n\u22a2 closedBall x \u03b5 \\ ball x \u03b5 = sphere x \u03b5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/GDelta.lean", "full_name": "isG\u03b4_iff_eq_iInter_nat", "start": [96, 1], "end": [105, 31], "traced_tactics": [{"tactic": "refine \u27e8?_, ?_\u27e9", "annotated_tactic": ["refine \u27e8?_, ?_\u27e9", []], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsG\u03b4 s \u2194 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 s = \u22c2 n, f n", "state_after": "case refine_1\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsG\u03b4 s \u2192 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 s = \u22c2 n, f n\n\ncase refine_2\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 s = \u22c2 n, f n) \u2192 IsG\u03b4 s"}, {"tactic": "rintro \u27e8T, hT, T_count, rfl\u27e9", "annotated_tactic": ["rintro \u27e8T, hT, T_count, rfl\u27e9", []], "state_before": "case refine_1\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsG\u03b4 s \u2192 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 s = \u22c2 n, f n", "state_after": "case refine_1.intro.intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nT : Set (Set X)\nhT : \u2200 t \u2208 T, IsOpen t\nT_count : Set.Countable T\n\u22a2 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 \u22c2\u2080 T = \u22c2 n, f n"}, {"tactic": "rcases Set.eq_empty_or_nonempty T with rfl|hT", "annotated_tactic": ["rcases <a>Set.eq_empty_or_nonempty</a> T with rfl|hT", [{"full_name": "Set.eq_empty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [609, 9], "def_end_pos": [609, 29]}]], "state_before": "case refine_1.intro.intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nT : Set (Set X)\nhT : \u2200 t \u2208 T, IsOpen t\nT_count : Set.Countable T\n\u22a2 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 \u22c2\u2080 T = \u22c2 n, f n", "state_after": "case refine_1.intro.intro.intro.inl\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nhT : \u2200 t \u2208 \u2205, IsOpen t\nT_count : Set.Countable \u2205\n\u22a2 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 \u22c2\u2080 \u2205 = \u22c2 n, f n\n\ncase refine_1.intro.intro.intro.inr\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nT : Set (Set X)\nhT\u271d : \u2200 t \u2208 T, IsOpen t\nT_count : Set.Countable T\nhT : Set.Nonempty T\n\u22a2 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 \u22c2\u2080 T = \u22c2 n, f n"}, {"tactic": "exact \u27e8fun _n \u21a6 univ, fun _n \u21a6 isOpen_univ, by simp\u27e9", "annotated_tactic": ["exact \u27e8fun _n \u21a6 <a>univ</a>, fun _n \u21a6 <a>isOpen_univ</a>, by simp\u27e9", [{"full_name": "Set.univ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [153, 5], "def_end_pos": [153, 9]}, {"full_name": "isOpen_univ", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Basic.lean", "def_pos": [88, 17], "def_end_pos": [88, 28]}]], "state_before": "case refine_1.intro.intro.intro.inl\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nhT : \u2200 t \u2208 \u2205, IsOpen t\nT_count : Set.Countable \u2205\n\u22a2 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 \u22c2\u2080 \u2205 = \u22c2 n, f n", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nhT : \u2200 t \u2208 \u2205, IsOpen t\nT_count : Set.Countable \u2205\n\u22a2 \u22c2\u2080 \u2205 = \u22c2 n, (fun _n => univ) n", "state_after": "no goals"}, {"tactic": "obtain \u27e8f, hf\u27e9 : \u2203 (f : \u2115 \u2192 Set X), T = range f := Countable.exists_eq_range T_count hT", "annotated_tactic": ["obtain \u27e8f, hf\u27e9 : \u2203 (f : \u2115 \u2192 <a>Set</a> X), T = <a>range</a> f := <a>Countable.exists_eq_range</a> T_count hT", [{"full_name": "Set", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [47, 5], "def_end_pos": [47, 8]}, {"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}, {"full_name": "Set.Countable.exists_eq_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Countable.lean", "def_pos": [157, 9], "def_end_pos": [157, 34]}]], "state_before": "case refine_1.intro.intro.intro.inr\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nT : Set (Set X)\nhT\u271d : \u2200 t \u2208 T, IsOpen t\nT_count : Set.Countable T\nhT : Set.Nonempty T\n\u22a2 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 \u22c2\u2080 T = \u22c2 n, f n", "state_after": "case refine_1.intro.intro.intro.inr.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nT : Set (Set X)\nhT\u271d : \u2200 t \u2208 T, IsOpen t\nT_count : Set.Countable T\nhT : Set.Nonempty T\nf : \u2115 \u2192 Set X\nhf : T = range f\n\u22a2 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 \u22c2\u2080 T = \u22c2 n, f n"}, {"tactic": "exact \u27e8f, by aesop, by simp [hf]\u27e9", "annotated_tactic": ["exact \u27e8f, by aesop, by simp [hf]\u27e9", []], "state_before": "case refine_1.intro.intro.intro.inr.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nT : Set (Set X)\nhT\u271d : \u2200 t \u2208 T, IsOpen t\nT_count : Set.Countable T\nhT : Set.Nonempty T\nf : \u2115 \u2192 Set X\nhf : T = range f\n\u22a2 \u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 \u22c2\u2080 T = \u22c2 n, f n", "state_after": "no goals"}, {"tactic": "aesop", "annotated_tactic": ["aesop", []], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nT : Set (Set X)\nhT\u271d : \u2200 t \u2208 T, IsOpen t\nT_count : Set.Countable T\nhT : Set.Nonempty T\nf : \u2115 \u2192 Set X\nhf : T = range f\n\u22a2 \u2200 (n : \u2115), IsOpen (f n)", "state_after": "no goals"}, {"tactic": "simp [hf]", "annotated_tactic": ["simp [hf]", []], "state_before": "X : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nT : Set (Set X)\nhT\u271d : \u2200 t \u2208 T, IsOpen t\nT_count : Set.Countable T\nhT : Set.Nonempty T\nf : \u2115 \u2192 Set X\nhf : T = range f\n\u22a2 \u22c2\u2080 T = \u22c2 n, f n", "state_after": "no goals"}, {"tactic": "rintro \u27e8f, hf, rfl\u27e9", "annotated_tactic": ["rintro \u27e8f, hf, rfl\u27e9", []], "state_before": "case refine_2\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2203 f, (\u2200 (n : \u2115), IsOpen (f n)) \u2227 s = \u22c2 n, f n) \u2192 IsG\u03b4 s", "state_after": "case refine_2.intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nf : \u2115 \u2192 Set X\nhf : \u2200 (n : \u2115), IsOpen (f n)\n\u22a2 IsG\u03b4 (\u22c2 n, f n)"}, {"tactic": "exact .iInter_of_isOpen hf", "annotated_tactic": ["exact .iInter_of_isOpen hf", []], "state_before": "case refine_2.intro.intro\nX : Type u_1\nY : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Sort u_4\ninst\u271d : TopologicalSpace X\nf : \u2115 \u2192 Set X\nhf : \u2200 (n : \u2115), IsOpen (f n)\n\u22a2 IsG\u03b4 (\u22c2 n, f n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_mem_eq_one_of_infinite", "start": [535, 1], "end": [539, 40], "traced_tactics": [{"tactic": "rw [finprod_mem_def]", "annotated_tactic": ["rw [<a>finprod_mem_def</a>]", [{"full_name": "finprod_mem_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [377, 9], "def_end_pos": [377, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : \u03b1 \u2192 M\ns : Set \u03b1\nhs : Set.Infinite (s \u2229 mulSupport f)\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i = 1", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : \u03b1 \u2192 M\ns : Set \u03b1\nhs : Set.Infinite (s \u2229 mulSupport f)\n\u22a2 \u220f\u1da0 (a : \u03b1), mulIndicator s (fun i => f i) a = 1"}, {"tactic": "apply finprod_of_infinite_mulSupport", "annotated_tactic": ["apply <a>finprod_of_infinite_mulSupport</a>", [{"full_name": "finprod_of_infinite_mulSupport", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [425, 9], "def_end_pos": [425, 39]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : \u03b1 \u2192 M\ns : Set \u03b1\nhs : Set.Infinite (s \u2229 mulSupport f)\n\u22a2 \u220f\u1da0 (a : \u03b1), mulIndicator s (fun i => f i) a = 1", "state_after": "case hf\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : \u03b1 \u2192 M\ns : Set \u03b1\nhs : Set.Infinite (s \u2229 mulSupport f)\n\u22a2 Set.Infinite (mulSupport fun i => mulIndicator s (fun i => f i) i)"}, {"tactic": "rwa [\u2190 mulSupport_mulIndicator] at hs", "annotated_tactic": ["rwa [\u2190 <a>mulSupport_mulIndicator</a>] at hs", [{"full_name": "Set.mulSupport_mulIndicator", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [135, 9], "def_end_pos": [135, 32]}]], "state_before": "case hf\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf : \u03b1 \u2192 M\ns : Set \u03b1\nhs : Set.Infinite (s \u2229 mulSupport f)\n\u22a2 Set.Infinite (mulSupport fun i => mulIndicator s (fun i => f i) i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/Order.lean", "full_name": "Int.natAbs_add_le", "start": [494, 1], "end": [510, 27], "traced_tactics": [{"tactic": "suffices \u2200 a b : Nat, natAbs (subNatNat a b.succ) \u2264 (a + b).succ by\n  match a, b with\n  | (a:Nat), (b:Nat) => rw [ofNat_add_ofNat, natAbs_ofNat]; apply Nat.le_refl\n  | (a:Nat), -[b+1]  => rw [natAbs_ofNat, natAbs_negSucc]; apply this\n  | -[a+1],  (b:Nat) =>\n    rw [natAbs_negSucc, natAbs_ofNat, Nat.succ_add, Nat.add_comm a b]; apply this\n  | -[a+1],  -[b+1]  => rw [natAbs_negSucc, succ_add]; apply Nat.le_refl", "annotated_tactic": ["suffices \u2200 a b : <a>Nat</a>, <a>natAbs</a> (<a>subNatNat</a> a b.succ) \u2264 (a + b).<a>succ</a> by\n    match a, b with\n    | (a:Nat), (b:Nat) => rw [<a>ofNat_add_ofNat</a>, <a>natAbs_ofNat</a>]; apply <a>Nat.le_refl</a>\n    | (a:Nat), -[b+1]  => rw [<a>natAbs_ofNat</a>, <a>natAbs_negSucc</a>]; apply this\n    | -[a+1],  (b:Nat) =>\n      rw [<a>natAbs_negSucc</a>, <a>natAbs_ofNat</a>, <a>Nat.succ_add</a>, <a>Nat.add_comm</a> a b]; apply this\n    | -[a+1],  -[b+1]  => rw [<a>natAbs_negSucc</a>, <a>succ_add</a>]; apply <a>Nat.le_refl</a>", [{"full_name": "Nat", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1065, 11], "def_end_pos": [1065, 14]}, {"full_name": "Int.natAbs", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [262, 5], "def_end_pos": [262, 11]}, {"full_name": "Int.subNatNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [107, 5], "def_end_pos": [107, 14]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Int.ofNat_add_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [41, 23], "def_end_pos": [41, 38]}, {"full_name": "Int.natAbs_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [406, 17], "def_end_pos": [406, 29]}, {"full_name": "Nat.le_refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1671, 19], "def_end_pos": [1671, 30]}, {"full_name": "Int.natAbs_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [406, 17], "def_end_pos": [406, 29]}, {"full_name": "Int.natAbs_negSucc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [407, 17], "def_end_pos": [407, 31]}, {"full_name": "Int.natAbs_negSucc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [407, 17], "def_end_pos": [407, 31]}, {"full_name": "Int.natAbs_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [406, 17], "def_end_pos": [406, 29]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.add_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}, {"full_name": "Int.natAbs_negSucc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [407, 17], "def_end_pos": [407, 31]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.le_refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1671, 19], "def_end_pos": [1671, 30]}]], "state_before": "a b : Int\n\u22a2 natAbs (a + b) \u2264 natAbs a + natAbs b", "state_after": "a b : Int\n\u22a2 \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)"}, {"tactic": "refine fun a b => subNatNat_elim a b.succ\n  (fun m n i => n = b.succ \u2192 natAbs i \u2264 (m + b).succ) ?_\n  (fun i n (e : (n + i).succ = _) => ?_) rfl", "annotated_tactic": ["refine fun a b => <a>subNatNat_elim</a> a b.succ\n    (fun m n i => n = b.succ \u2192 <a>natAbs</a> i \u2264 (m + b).<a>succ</a>) ?_\n    (fun i n (e : (n + i).<a>succ</a> = _) => ?_) <a>rfl</a>", [{"full_name": "Int.subNatNat_elim", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [94, 9], "def_end_pos": [94, 23]}, {"full_name": "Int.natAbs", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [262, 5], "def_end_pos": [262, 11]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "a b : Int\n\u22a2 \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)", "state_after": "case refine_1\na\u271d b\u271d : Int\na b : Nat\n\u22a2 \u2200 (i n : Nat), (fun m n i => n = succ b \u2192 natAbs i \u2264 succ (m + b)) (n + i) n \u2191i\n\ncase refine_2\na\u271d b\u271d : Int\na b i n : Nat\ne : succ (n + i) = succ b\n\u22a2 natAbs -[i+1] \u2264 succ (n + b)"}, {"tactic": "match a, b with\n| (a:Nat), (b:Nat) => rw [ofNat_add_ofNat, natAbs_ofNat]; apply Nat.le_refl\n| (a:Nat), -[b+1]  => rw [natAbs_ofNat, natAbs_negSucc]; apply this\n| -[a+1],  (b:Nat) =>\n  rw [natAbs_negSucc, natAbs_ofNat, Nat.succ_add, Nat.add_comm a b]; apply this\n| -[a+1],  -[b+1]  => rw [natAbs_negSucc, succ_add]; apply Nat.le_refl", "annotated_tactic": ["match a, b with\n    | (a:Nat), (b:Nat) => rw [<a>ofNat_add_ofNat</a>, <a>natAbs_ofNat</a>]; apply <a>Nat.le_refl</a>\n    | (a:Nat), -[b+1]  => rw [<a>natAbs_ofNat</a>, <a>natAbs_negSucc</a>]; apply this\n    | -[a+1],  (b:Nat) =>\n      rw [<a>natAbs_negSucc</a>, <a>natAbs_ofNat</a>, <a>Nat.succ_add</a>, <a>Nat.add_comm</a> a b]; apply this\n    | -[a+1],  -[b+1]  => rw [<a>natAbs_negSucc</a>, <a>succ_add</a>]; apply <a>Nat.le_refl</a>", [{"full_name": "Int.ofNat_add_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [41, 23], "def_end_pos": [41, 38]}, {"full_name": "Int.natAbs_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [406, 17], "def_end_pos": [406, 29]}, {"full_name": "Nat.le_refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1671, 19], "def_end_pos": [1671, 30]}, {"full_name": "Int.natAbs_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [406, 17], "def_end_pos": [406, 29]}, {"full_name": "Int.natAbs_negSucc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [407, 17], "def_end_pos": [407, 31]}, {"full_name": "Int.natAbs_negSucc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [407, 17], "def_end_pos": [407, 31]}, {"full_name": "Int.natAbs_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [406, 17], "def_end_pos": [406, 29]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.add_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}, {"full_name": "Int.natAbs_negSucc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [407, 17], "def_end_pos": [407, 31]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.le_refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1671, 19], "def_end_pos": [1671, 30]}]], "state_before": "a b : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\n\u22a2 natAbs (a + b) \u2264 natAbs a + natAbs b", "state_after": "no goals"}, {"tactic": "rw [ofNat_add_ofNat, natAbs_ofNat]", "annotated_tactic": ["rw [<a>ofNat_add_ofNat</a>, <a>natAbs_ofNat</a>]", [{"full_name": "Int.ofNat_add_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [41, 23], "def_end_pos": [41, 38]}, {"full_name": "Int.natAbs_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [406, 17], "def_end_pos": [406, 29]}]], "state_before": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (\u2191a + \u2191b) \u2264 natAbs \u2191a + natAbs \u2191b", "state_after": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 a + b \u2264 natAbs \u2191a + natAbs \u2191b"}, {"tactic": "apply Nat.le_refl", "annotated_tactic": ["apply <a>Nat.le_refl</a>", [{"full_name": "Nat.le_refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1671, 19], "def_end_pos": [1671, 30]}]], "state_before": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 a + b \u2264 natAbs \u2191a + natAbs \u2191b", "state_after": "no goals"}, {"tactic": "rw [natAbs_ofNat, natAbs_negSucc]", "annotated_tactic": ["rw [<a>natAbs_ofNat</a>, <a>natAbs_negSucc</a>]", [{"full_name": "Int.natAbs_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [406, 17], "def_end_pos": [406, 29]}, {"full_name": "Int.natAbs_negSucc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [407, 17], "def_end_pos": [407, 31]}]], "state_before": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (\u2191a + -[b+1]) \u2264 natAbs \u2191a + natAbs -[b+1]", "state_after": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (\u2191a + -[b+1]) \u2264 a + succ b"}, {"tactic": "apply this", "annotated_tactic": ["apply this", []], "state_before": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (\u2191a + -[b+1]) \u2264 a + succ b", "state_after": "no goals"}, {"tactic": "rw [natAbs_negSucc, natAbs_ofNat, Nat.succ_add, Nat.add_comm a b]", "annotated_tactic": ["rw [<a>natAbs_negSucc</a>, <a>natAbs_ofNat</a>, <a>Nat.succ_add</a>, <a>Nat.add_comm</a> a b]", [{"full_name": "Int.natAbs_negSucc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [407, 17], "def_end_pos": [407, 31]}, {"full_name": "Int.natAbs_ofNat", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [406, 17], "def_end_pos": [406, 29]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.add_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}]], "state_before": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (-[a+1] + \u2191b) \u2264 natAbs -[a+1] + natAbs \u2191b", "state_after": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (-[a+1] + \u2191b) \u2264 succ (b + a)"}, {"tactic": "apply this", "annotated_tactic": ["apply this", []], "state_before": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (-[a+1] + \u2191b) \u2264 succ (b + a)", "state_after": "no goals"}, {"tactic": "rw [natAbs_negSucc, succ_add]", "annotated_tactic": ["rw [<a>natAbs_negSucc</a>, <a>succ_add</a>]", [{"full_name": "Int.natAbs_negSucc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [407, 17], "def_end_pos": [407, 31]}, {"full_name": "Nat.succ_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}]], "state_before": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (-[a+1] + -[b+1]) \u2264 natAbs -[a+1] + natAbs -[b+1]", "state_after": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (-[a+1] + -[b+1]) \u2264 succ (a + natAbs -[b+1])"}, {"tactic": "apply Nat.le_refl", "annotated_tactic": ["apply <a>Nat.le_refl</a>", [{"full_name": "Nat.le_refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1671, 19], "def_end_pos": [1671, 30]}]], "state_before": "a\u271d b\u271d : Int\nthis : \u2200 (a b : Nat), natAbs (subNatNat a (succ b)) \u2264 succ (a + b)\na b : Nat\n\u22a2 natAbs (-[a+1] + -[b+1]) \u2264 succ (a + natAbs -[b+1])", "state_after": "no goals"}, {"tactic": "rintro i n rfl", "annotated_tactic": ["rintro i n rfl", []], "state_before": "case refine_1\na\u271d b\u271d : Int\na b : Nat\n\u22a2 \u2200 (i n : Nat), (fun m n i => n = succ b \u2192 natAbs i \u2264 succ (m + b)) (n + i) n \u2191i", "state_after": "case refine_1\na\u271d b\u271d : Int\na b i : Nat\n\u22a2 natAbs \u2191i \u2264 succ (succ b + i + b)"}, {"tactic": "rw [Nat.add_comm _ i, Nat.add_assoc]", "annotated_tactic": ["rw [<a>Nat.add_comm</a> _ i, <a>Nat.add_assoc</a>]", [{"full_name": "Nat.add_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}, {"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "case refine_1\na\u271d b\u271d : Int\na b i : Nat\n\u22a2 natAbs \u2191i \u2264 succ (succ b + i + b)", "state_after": "case refine_1\na\u271d b\u271d : Int\na b i : Nat\n\u22a2 natAbs \u2191i \u2264 succ (i + (succ b + b))"}, {"tactic": "exact Nat.le_add_right i (b.succ + b).succ", "annotated_tactic": ["exact <a>Nat.le_add_right</a> i (b.succ + b).<a>succ</a>", [{"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}, {"full_name": "Nat.succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1071, 5], "def_end_pos": [1071, 9]}]], "state_before": "case refine_1\na\u271d b\u271d : Int\na b i : Nat\n\u22a2 natAbs \u2191i \u2264 succ (i + (succ b + b))", "state_after": "no goals"}, {"tactic": "apply succ_le_succ", "annotated_tactic": ["apply <a>succ_le_succ</a>", [{"full_name": "Nat.succ_le_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1648, 9], "def_end_pos": [1648, 25]}]], "state_before": "case refine_2\na\u271d b\u271d : Int\na b i n : Nat\ne : succ (n + i) = succ b\n\u22a2 natAbs -[i+1] \u2264 succ (n + b)", "state_after": "case refine_2.a\na\u271d b\u271d : Int\na b i n : Nat\ne : succ (n + i) = succ b\n\u22a2 i \u2264 n + b"}, {"tactic": "rw [\u2190 succ.inj e, \u2190 Nat.add_assoc, Nat.add_comm]", "annotated_tactic": ["rw [\u2190 succ.inj e, \u2190 <a>Nat.add_assoc</a>, <a>Nat.add_comm</a>]", [{"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}, {"full_name": "Nat.add_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}]], "state_before": "case refine_2.a\na\u271d b\u271d : Int\na b i n : Nat\ne : succ (n + i) = succ b\n\u22a2 i \u2264 n + b", "state_after": "case refine_2.a\na\u271d b\u271d : Int\na b i n : Nat\ne : succ (n + i) = succ b\n\u22a2 i \u2264 i + (n + n)"}, {"tactic": "apply Nat.le_add_right", "annotated_tactic": ["apply <a>Nat.le_add_right</a>", [{"full_name": "Nat.le_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [333, 9], "def_end_pos": [333, 21]}]], "state_before": "case refine_2.a\na\u271d b\u271d : Int\na b i n : Nat\ne : succ (n + i) = succ b\n\u22a2 i \u2264 i + (n + n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Regular/Basic.lean", "full_name": "not_isLeftRegular_zero", "start": [268, 1], "end": [269, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.vecMulLinear_transpose", "start": [249, 9], "end": [251, 31], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d : Fintype n\nM : Matrix m n R\n\u22a2 vecMulLinear M\u1d40 = mulVecLin M", "state_after": "case h.h\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d : Fintype n\nM : Matrix m n R\nx\u271d\u00b9 : n \u2192 R\nx\u271d : m\n\u22a2 (vecMulLinear M\u1d40) x\u271d\u00b9 x\u271d = (mulVecLin M) x\u271d\u00b9 x\u271d"}, {"tactic": "simp [vecMul_transpose]", "annotated_tactic": ["simp [<a>vecMul_transpose</a>]", [{"full_name": "Matrix.vecMul_transpose", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1963, 9], "def_end_pos": [1963, 25]}]], "state_before": "case h.h\nR : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d : Fintype n\nM : Matrix m n R\nx\u271d\u00b9 : n \u2192 R\nx\u271d : m\n\u22a2 (vecMulLinear M\u1d40) x\u271d\u00b9 x\u271d = (mulVecLin M) x\u271d\u00b9 x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Torsion.lean", "full_name": "Submodule.mem_torsionBySet_iff", "start": [265, 1], "end": [267, 41], "traced_tactics": [{"tactic": "refine' \u27e8fun h \u27e8a, ha\u27e9 => mem_sInf.mp h _ (Set.mem_image_of_mem _ ha), fun h => mem_sInf.mpr _\u27e9", "annotated_tactic": ["refine' \u27e8fun h \u27e8a, ha\u27e9 => mem_sInf.mp h _ (<a>Set.mem_image_of_mem</a> _ ha), fun h => mem_sInf.mpr _\u27e9", [{"full_name": "Set.mem_image_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [132, 9], "def_end_pos": [132, 25]}]], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set R\na : R\nx : M\n\u22a2 x \u2208 torsionBySet R M s \u2194 \u2200 (a : \u2191s), \u2191a \u2022 x = 0", "state_after": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set R\na : R\nx : M\nh : \u2200 (a : \u2191s), \u2191a \u2022 x = 0\n\u22a2 \u2200 p \u2208 torsionBy R M '' s, x \u2208 p"}, {"tactic": "rintro _ \u27e8a, ha, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8a, ha, rfl\u27e9", []], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set R\na : R\nx : M\nh : \u2200 (a : \u2191s), \u2191a \u2022 x = 0\n\u22a2 \u2200 p \u2208 torsionBy R M '' s, x \u2208 p", "state_after": "case intro.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set R\na\u271d : R\nx : M\nh : \u2200 (a : \u2191s), \u2191a \u2022 x = 0\na : R\nha : a \u2208 s\n\u22a2 x \u2208 torsionBy R M a"}, {"tactic": "exact h \u27e8a, ha\u27e9", "annotated_tactic": ["exact h \u27e8a, ha\u27e9", []], "state_before": "case intro.intro\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Set R\na\u271d : R\nx : M\nh : \u2200 (a : \u2191s), \u2191a \u2022 x = 0\na : R\nha : a \u2208 s\n\u22a2 x \u2208 torsionBy R M a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csInf_univ", "start": [1198, 1], "end": [1199, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Field/Basic.lean", "full_name": "Filter.map_mul_right_cobounded", "start": [810, 1], "end": [813, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/OrdConnected.lean", "full_name": "Set.ordConnected_biInter", "start": [171, 1], "end": [173, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Field/Basic.lean", "full_name": "List.nnnorm_prod", "start": [725, 11], "end": [726, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Quot.lean", "full_name": "nonempty_quotient_iff", "start": [449, 1], "end": [450, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.prod_preimage_right", "start": [206, 1], "end": [208, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Int.lean", "full_name": "Int.ball_eq_Ioo", "start": [62, 1], "end": [63, 55], "traced_tactics": [{"tactic": "rw [\u2190 preimage_ball, Real.ball_eq_Ioo, preimage_Ioo]", "annotated_tactic": ["rw [\u2190 <a>preimage_ball</a>, <a>Real.ball_eq_Ioo</a>, <a>preimage_Ioo</a>]", [{"full_name": "Int.preimage_ball", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/Int.lean", "def_pos": [56, 9], "def_end_pos": [56, 22]}, {"full_name": "Real.ball_eq_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1385, 9], "def_end_pos": [1385, 25]}, {"full_name": "Int.preimage_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [1375, 9], "def_end_pos": [1375, 21]}]], "state_before": "x : \u2124\nr : \u211d\n\u22a2 ball x r = Ioo \u230a\u2191x - r\u230b \u2308\u2191x + r\u2309", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.toFinset_image", "start": [299, 11], "end": [302, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t : Set \u03b1\na : \u03b1\nhs\u271d : Set.Finite s\nht : Set.Finite t\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhs : Set.Finite s\nh : Set.Finite (f '' s)\n\u22a2 Finite.toFinset h = Finset.image f (Finite.toFinset hs)", "state_after": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t : Set \u03b1\na : \u03b1\nhs\u271d : Set.Finite s\nht : Set.Finite t\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhs : Set.Finite s\nh : Set.Finite (f '' s)\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 Finite.toFinset h \u2194 a\u271d \u2208 Finset.image f (Finite.toFinset hs)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t : Set \u03b1\na : \u03b1\nhs\u271d : Set.Finite s\nht : Set.Finite t\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhs : Set.Finite s\nh : Set.Finite (f '' s)\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 Finite.toFinset h \u2194 a\u271d \u2208 Finset.image f (Finite.toFinset hs)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearMap.coe_zero'", "start": [648, 1], "end": [649, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dual.lean", "full_name": "Basis.dual_rank_eq", "start": [521, 1], "end": [523, 83], "traced_tactics": [{"tactic": "classical rw [\u2190 lift_umax.{uV,uK}, b.toDualEquiv.lift_rank_eq, lift_id'.{uV,uK}]", "annotated_tactic": ["classical rw [\u2190 <a>lift_umax</a>.{uV,uK}, b.toDualEquiv.lift_rank_eq, <a>lift_id'</a>.{uV,uK}]", [{"full_name": "Cardinal.lift_umax", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [202, 9], "def_end_pos": [202, 18]}, {"full_name": "Cardinal.lift_id'", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [218, 9], "def_end_pos": [218, 17]}]], "state_before": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : _root_.Finite \u03b9\nb : Basis \u03b9 K V\n\u22a2 lift.{uK, uV} (Module.rank K V) = Module.rank K (Dual K V)", "state_after": "no goals"}, {"tactic": "rw [\u2190 lift_umax.{uV,uK}, b.toDualEquiv.lift_rank_eq, lift_id'.{uV,uK}]", "annotated_tactic": ["rw [\u2190 <a>lift_umax</a>.{uV,uK}, b.toDualEquiv.lift_rank_eq, <a>lift_id'</a>.{uV,uK}]", [{"full_name": "Cardinal.lift_umax", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [202, 9], "def_end_pos": [202, 18]}, {"full_name": "Cardinal.lift_id'", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [218, 9], "def_end_pos": [218, 17]}]], "state_before": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module K V\ninst\u271d : _root_.Finite \u03b9\nb : Basis \u03b9 K V\n\u22a2 lift.{uK, uV} (Module.rank K V) = Module.rank K (Dual K V)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/PNat/Basic.lean", "full_name": "Nat.succPNat_inj", "start": [102, 1], "end": [103, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Basic.lean", "full_name": "Equiv.Perm.inv_def", "start": [93, 1], "end": [94, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isBigOWith_top", "start": [1328, 1], "end": [1329, 38], "traced_tactics": [{"tactic": "rw [IsBigOWith_def, eventually_top]", "annotated_tactic": ["rw [<a>IsBigOWith_def</a>, <a>eventually_top</a>]", [{"full_name": "Asymptotics.IsBigOWith_def", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Asymptotics/Asymptotics.lean", "def_pos": [1, 1], "def_end_pos": [1, 1]}, {"full_name": "Filter.eventually_top", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1233, 9], "def_end_pos": [1233, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\n\u22a2 IsBigOWith c \u22a4 f g \u2194 \u2200 (x : \u03b1), \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.isLimit_add_iff", "start": [975, 1], "end": [986, 77], "traced_tactics": [{"tactic": "constructor <;> intro h", "annotated_tactic": ["constructor <;> intro h", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\n\u22a2 IsLimit (a + b) \u2194 IsLimit b \u2228 b = 0 \u2227 IsLimit a", "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\n\u22a2 IsLimit b \u2228 b = 0 \u2227 IsLimit a\n\ncase mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit b \u2228 b = 0 \u2227 IsLimit a\n\u22a2 IsLimit (a + b)"}, {"tactic": "rcases h with (h | \u27e8rfl, h\u27e9)", "annotated_tactic": ["rcases h with (h | \u27e8rfl, h\u27e9)", []], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit b \u2228 b = 0 \u2227 IsLimit a\n\u22a2 IsLimit (a + b)", "state_after": "case mpr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit b\n\u22a2 IsLimit (a + b)\n\ncase mpr.inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na : Ordinal.{u_4}\nh : IsLimit a\n\u22a2 IsLimit (a + 0)"}, {"tactic": "exact add_isLimit a h", "annotated_tactic": ["exact <a>add_isLimit</a> a h", [{"full_name": "Ordinal.add_isLimit", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [521, 9], "def_end_pos": [521, 20]}]], "state_before": "case mpr.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit b\n\u22a2 IsLimit (a + b)\n\ncase mpr.inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na : Ordinal.{u_4}\nh : IsLimit a\n\u22a2 IsLimit (a + 0)", "state_after": "case mpr.inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na : Ordinal.{u_4}\nh : IsLimit a\n\u22a2 IsLimit (a + 0)"}, {"tactic": "simpa only [add_zero]", "annotated_tactic": ["simpa only [<a>add_zero</a>]", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "case mpr.inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na : Ordinal.{u_4}\nh : IsLimit a\n\u22a2 IsLimit (a + 0)", "state_after": "no goals"}, {"tactic": "by_cases h' : b = 0", "annotated_tactic": ["by_cases h' : b = 0", []], "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\n\u22a2 IsLimit b \u2228 b = 0 \u2227 IsLimit a", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : b = 0\n\u22a2 IsLimit b \u2228 b = 0 \u2227 IsLimit a\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 IsLimit b \u2228 b = 0 \u2227 IsLimit a"}, {"tactic": "left", "annotated_tactic": ["left", []], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 IsLimit b \u2228 b = 0 \u2227 IsLimit a", "state_after": "case neg.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 IsLimit b"}, {"tactic": "rw [\u2190 add_sub_cancel a b]", "annotated_tactic": ["rw [\u2190 <a>add_sub_cancel</a> a b]", [{"full_name": "Ordinal.add_sub_cancel", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [552, 9], "def_end_pos": [552, 23]}]], "state_before": "case neg.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 IsLimit b", "state_after": "case neg.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 IsLimit (a + b - a)"}, {"tactic": "apply sub_isLimit h", "annotated_tactic": ["apply <a>sub_isLimit</a> h", [{"full_name": "Ordinal.sub_isLimit", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [611, 9], "def_end_pos": [611, 20]}]], "state_before": "case neg.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 IsLimit (a + b - a)", "state_after": "case neg.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 a < a + b"}, {"tactic": "suffices a + 0 < a + b by simpa only [add_zero] using this", "annotated_tactic": ["suffices a + 0 < a + b by simpa only [<a>add_zero</a>] using this", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "case neg.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 a < a + b", "state_after": "case neg.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 a + 0 < a + b"}, {"tactic": "rwa [add_lt_add_iff_left, Ordinal.pos_iff_ne_zero]", "annotated_tactic": ["rwa [<a>add_lt_add_iff_left</a>, <a>Ordinal.pos_iff_ne_zero</a>]", [{"full_name": "add_lt_add_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [104, 3], "def_end_pos": [104, 14]}, {"full_name": "Ordinal.pos_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [406, 19], "def_end_pos": [406, 34]}]], "state_before": "case neg.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\n\u22a2 a + 0 < a + b", "state_after": "no goals"}, {"tactic": "rw [h', add_zero] at h", "annotated_tactic": ["rw [h', <a>add_zero</a>] at h", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : b = 0\n\u22a2 IsLimit b \u2228 b = 0 \u2227 IsLimit a", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit a\nh' : b = 0\n\u22a2 IsLimit b \u2228 b = 0 \u2227 IsLimit a"}, {"tactic": "right", "annotated_tactic": ["right", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit a\nh' : b = 0\n\u22a2 IsLimit b \u2228 b = 0 \u2227 IsLimit a", "state_after": "case pos.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit a\nh' : b = 0\n\u22a2 b = 0 \u2227 IsLimit a"}, {"tactic": "exact \u27e8h', h\u27e9", "annotated_tactic": ["exact \u27e8h', h\u27e9", []], "state_before": "case pos.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit a\nh' : b = 0\n\u22a2 b = 0 \u2227 IsLimit a", "state_after": "no goals"}, {"tactic": "simpa only [add_zero] using this", "annotated_tactic": ["simpa only [<a>add_zero</a>] using this", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\na b : Ordinal.{u_4}\nh : IsLimit (a + b)\nh' : \u00acb = 0\nthis : a + 0 < a + b\n\u22a2 a < a + b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.nonempty_of_mem", "start": [711, 1], "end": [712, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "full_name": "tsum_subtype_eq_of_support_subset", "start": [416, 1], "end": [418, 44], "traced_tactics": [{"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf\u271d g : \u03b2 \u2192 \u03b1\na a\u2081 a\u2082 : \u03b1\nf : \u03b2 \u2192 \u03b1\ns : Set \u03b2\nhs : support f \u2286 s\n\u22a2 support f \u2286 Set.range Subtype.val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Rat/Lemmas.lean", "full_name": "Rat.divInt_eq_iff", "start": [152, 1], "end": [157, 70], "traced_tactics": [{"tactic": "rcases Int.eq_nat_or_neg d\u2081 with \u27e8_, rfl | rfl\u27e9 <;>\nrcases Int.eq_nat_or_neg d\u2082 with \u27e8_, rfl | rfl\u27e9 <;>\nsimp_all [divInt_neg', Int.ofNat_eq_zero, Int.neg_eq_zero,\n  mkRat_eq_iff, Int.neg_mul, Int.mul_neg, Int.eq_neg_comm, eq_comm]", "annotated_tactic": ["rcases <a>Int.eq_nat_or_neg</a> d\u2081 with \u27e8_, rfl | rfl\u27e9 <;>\n  rcases <a>Int.eq_nat_or_neg</a> d\u2082 with \u27e8_, rfl | rfl\u27e9 <;>\n  simp_all [<a>divInt_neg'</a>, <a>Int.ofNat_eq_zero</a>, <a>Int.neg_eq_zero</a>,\n    <a>mkRat_eq_iff</a>, <a>Int.neg_mul</a>, <a>Int.mul_neg</a>, <a>Int.eq_neg_comm</a>, <a>eq_comm</a>]", [{"full_name": "Int.eq_nat_or_neg", "def_path": ".lake/packages/std/Std/Data/Int/Order.lean", "def_pos": [481, 9], "def_end_pos": [481, 22]}, {"full_name": "Int.eq_nat_or_neg", "def_path": ".lake/packages/std/Std/Data/Int/Order.lean", "def_pos": [481, 9], "def_end_pos": [481, 22]}, {"full_name": "Rat.divInt_neg'", "def_path": ".lake/packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [150, 9], "def_end_pos": [150, 20]}, {"full_name": "Int.ofNat_eq_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [58, 9], "def_end_pos": [58, 22]}, {"full_name": "Int.neg_eq_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [83, 27], "def_end_pos": [83, 38]}, {"full_name": "Rat.mkRat_eq_iff", "def_path": ".lake/packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [128, 9], "def_end_pos": [128, 21]}, {"full_name": "Int.neg_mul", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [441, 33], "def_end_pos": [441, 40]}, {"full_name": "Int.mul_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [444, 33], "def_end_pos": [444, 40]}, {"full_name": "Int.eq_neg_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [229, 19], "def_end_pos": [229, 30]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "d\u2081 d\u2082 n\u2081 n\u2082 : Int\nz\u2081 : d\u2081 \u2260 0\nz\u2082 : d\u2082 \u2260 0\n\u22a2 n\u2081 /. d\u2081 = n\u2082 /. d\u2082 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "full_name": "hasSum_singleton", "start": [125, 1], "end": [126, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Count.lean", "full_name": "MeasureTheory.Measure.count_injective_image", "start": [177, 1], "end": [183, 31], "traced_tactics": [{"tactic": "by_cases hs : s.Finite", "annotated_tactic": ["by_cases hs : s.Finite", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\ninst\u271d : MeasurableSingletonClass \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : Function.Injective f\ns : Set \u03b2\n\u22a2 \u2191\u2191count (f '' s) = \u2191\u2191count s", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\ninst\u271d : MeasurableSingletonClass \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : Function.Injective f\ns : Set \u03b2\nhs : Set.Finite s\n\u22a2 \u2191\u2191count (f '' s) = \u2191\u2191count s\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\ninst\u271d : MeasurableSingletonClass \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : Function.Injective f\ns : Set \u03b2\nhs : \u00acSet.Finite s\n\u22a2 \u2191\u2191count (f '' s) = \u2191\u2191count s"}, {"tactic": "rw [count_apply_infinite hs]", "annotated_tactic": ["rw [<a>count_apply_infinite</a> hs]", [{"full_name": "MeasureTheory.Measure.count_apply_infinite", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Count.lean", "def_pos": [74, 9], "def_end_pos": [74, 29]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\ninst\u271d : MeasurableSingletonClass \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : Function.Injective f\ns : Set \u03b2\nhs : \u00acSet.Finite s\n\u22a2 \u2191\u2191count (f '' s) = \u2191\u2191count s", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\ninst\u271d : MeasurableSingletonClass \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : Function.Injective f\ns : Set \u03b2\nhs : \u00acSet.Finite s\n\u22a2 \u2191\u2191count (f '' s) = \u22a4"}, {"tactic": "rw [\u2190 finite_image_iff <| hf.injOn _] at hs", "annotated_tactic": ["rw [\u2190 <a>finite_image_iff</a> <| hf.injOn _] at hs", [{"full_name": "Set.finite_image_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1080, 9], "def_end_pos": [1080, 25]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\ninst\u271d : MeasurableSingletonClass \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : Function.Injective f\ns : Set \u03b2\nhs : \u00acSet.Finite s\n\u22a2 \u2191\u2191count (f '' s) = \u22a4", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\ninst\u271d : MeasurableSingletonClass \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : Function.Injective f\ns : Set \u03b2\nhs : \u00acSet.Finite (f '' s)\n\u22a2 \u2191\u2191count (f '' s) = \u22a4"}, {"tactic": "rw [count_apply_infinite hs]", "annotated_tactic": ["rw [<a>count_apply_infinite</a> hs]", [{"full_name": "MeasureTheory.Measure.count_apply_infinite", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Count.lean", "def_pos": [74, 9], "def_end_pos": [74, 29]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\ninst\u271d : MeasurableSingletonClass \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : Function.Injective f\ns : Set \u03b2\nhs : \u00acSet.Finite (f '' s)\n\u22a2 \u2191\u2191count (f '' s) = \u22a4", "state_after": "no goals"}, {"tactic": "exact count_injective_image' hf hs.measurableSet (Finite.image f hs).measurableSet", "annotated_tactic": ["exact <a>count_injective_image'</a> hf hs.measurableSet (<a>Finite.image</a> f hs).<a>measurableSet</a>", [{"full_name": "MeasureTheory.Measure.count_injective_image'", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Count.lean", "def_pos": [165, 9], "def_end_pos": [165, 31]}, {"full_name": "Set.Finite.image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [859, 9], "def_end_pos": [859, 21]}, {"full_name": "Set.Finite.measurableSet", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [314, 9], "def_end_pos": [314, 33]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ns\u271d : Set \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\ninst\u271d : MeasurableSingletonClass \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : Function.Injective f\ns : Set \u03b2\nhs : Set.Finite s\n\u22a2 \u2191\u2191count (f '' s) = \u2191\u2191count s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Powerset.lean", "full_name": "Finset.powersetCard_nonempty", "start": [275, 1], "end": [277, 71], "traced_tactics": [{"tactic": "aesop (add simp [Finset.Nonempty, exists_smaller_set, card_le_card])", "annotated_tactic": ["aesop (add simp [Finset.Nonempty, exists_smaller_set, card_le_card])", []], "state_before": "\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\nn : \u2115\ns t : Finset \u03b1\n\u22a2 (powersetCard n s).Nonempty \u2194 n \u2264 s.card", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/NonUnitalHom.lean", "full_name": "NonUnitalAlgHom.toMulHom_eq_coe", "start": [200, 1], "end": [201, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/PartialSups.lean", "full_name": "partialSups_eq_ciSup_Iic", "start": [158, 1], "end": [161, 31], "traced_tactics": [{"tactic": "rw [ciSup_set_le_iff Set.nonempty_Iic ((Set.finite_le_nat _).image _).bddAbove,\n  partialSups_le_iff]", "annotated_tactic": ["rw [<a>ciSup_set_le_iff</a> <a>Set.nonempty_Iic</a> ((<a>Set.finite_le_nat</a> _).<a>image</a> _).<a>bddAbove</a>,\n      <a>partialSups_le_iff</a>]", [{"full_name": "ciSup_set_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [538, 9], "def_end_pos": [538, 25]}, {"full_name": "Set.nonempty_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [286, 9], "def_end_pos": [286, 21]}, {"full_name": "Set.finite_le_nat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [919, 9], "def_end_pos": [919, 22]}, {"full_name": "Set.Finite.image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [859, 9], "def_end_pos": [859, 21]}, {"full_name": "Set.Finite.bddAbove", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1670, 19], "def_end_pos": [1670, 34]}, {"full_name": "partialSups_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/PartialSups.lean", "def_pos": [69, 7], "def_end_pos": [69, 25]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\nn : \u2115\nx\u271d : \u03b1\n\u22a2 (partialSups f) n \u2264 x\u271d \u2194 \u2a06 i, f \u2191i \u2264 x\u271d", "state_after": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\nn : \u2115\nx\u271d : \u03b1\n\u22a2 (\u2200 k \u2264 n, f k \u2264 x\u271d) \u2194 \u2200 i \u2208 Set.Iic n, f i \u2264 x\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : ConditionallyCompleteLattice \u03b1\nf : \u2115 \u2192 \u03b1\nn : \u2115\nx\u271d : \u03b1\n\u22a2 (\u2200 k \u2264 n, f k \u2264 x\u271d) \u2194 \u2200 i \u2208 Set.Iic n, f i \u2264 x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GCDMonoid/Finset.lean", "full_name": "Finset.lcm_empty", "start": [57, 1], "end": [58, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/OrderIsoNat.lean", "full_name": "RelEmbedding.coe_natLT", "start": [43, 1], "end": [44, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Basic.lean", "full_name": "sq_eq_zero_iff", "start": [205, 1], "end": [205, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/PartENat.lean", "full_name": "PartENat.coe_succ_le_iff", "start": [543, 1], "end": [544, 95], "traced_tactics": [{"tactic": "rw [Nat.succ_eq_add_one n, Nat.cast_add, Nat.cast_one, add_one_le_iff_lt (natCast_ne_top n)]", "annotated_tactic": ["rw [<a>Nat.succ_eq_add_one</a> n, <a>Nat.cast_add</a>, <a>Nat.cast_one</a>, <a>add_one_le_iff_lt</a> (<a>natCast_ne_top</a> n)]", [{"full_name": "Nat.succ_eq_add_one", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 24]}, {"full_name": "Nat.cast_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [155, 9], "def_end_pos": [155, 17]}, {"full_name": "Nat.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [150, 9], "def_end_pos": [150, 17]}, {"full_name": "PartENat.add_one_le_iff_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [534, 9], "def_end_pos": [534, 26]}, {"full_name": "PartENat.natCast_ne_top", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [380, 9], "def_end_pos": [380, 23]}]], "state_before": "n : \u2115\ne : PartENat\n\u22a2 \u2191(Nat.succ n) \u2264 e \u2194 \u2191n < e", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.top_eq_last", "start": [444, 1], "end": [445, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean", "full_name": "Ordinal.opow_lt_opow_left_of_succ", "start": [180, 1], "end": [184, 81], "traced_tactics": [{"tactic": "rw [opow_succ, opow_succ]", "annotated_tactic": ["rw [<a>opow_succ</a>, <a>opow_succ</a>]", [{"full_name": "Ordinal.opow_succ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [58, 9], "def_end_pos": [58, 18]}, {"full_name": "Ordinal.opow_succ", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [58, 9], "def_end_pos": [58, 18]}]], "state_before": "a b c : Ordinal.{u_1}\nab : a < b\n\u22a2 a ^ succ c < b ^ succ c", "state_after": "a b c : Ordinal.{u_1}\nab : a < b\n\u22a2 a ^ c * a < b ^ c * b"}, {"tactic": "exact\n  (mul_le_mul_right' (opow_le_opow_left c ab.le) a).trans_lt\n    (mul_lt_mul_of_pos_left ab (opow_pos c ((Ordinal.zero_le a).trans_lt ab)))", "annotated_tactic": ["exact\n    (<a>mul_le_mul_right'</a> (<a>opow_le_opow_left</a> c ab.le) a).<a>trans_lt</a>\n      (<a>mul_lt_mul_of_pos_left</a> ab (<a>opow_pos</a> c ((<a>Ordinal.zero_le</a> a).<a>trans_lt</a> ab)))", [{"full_name": "mul_le_mul_right'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [67, 9], "def_end_pos": [67, 26]}, {"full_name": "Ordinal.opow_le_opow_left", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [147, 9], "def_end_pos": [147, 26]}, {"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}, {"full_name": "Ordinal.mul_lt_mul_of_pos_left", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [827, 9], "def_end_pos": [827, 31]}, {"full_name": "Ordinal.opow_pos", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Exponential.lean", "def_pos": [94, 9], "def_end_pos": [94, 17]}, {"full_name": "Ordinal.zero_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [388, 19], "def_end_pos": [388, 26]}, {"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}]], "state_before": "a b c : Ordinal.{u_1}\nab : a < b\n\u22a2 a ^ c * a < b ^ c * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Bounds.lean", "full_name": "ciSup_div", "start": [175, 1], "end": [176, 43], "traced_tactics": [{"tactic": "simp only [div_eq_mul_inv, ciSup_mul hf]", "annotated_tactic": ["simp only [<a>div_eq_mul_inv</a>, <a>ciSup_mul</a> hf]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "ciSup_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Bounds.lean", "def_pos": [169, 9], "def_end_pos": [169, 18]}]], "state_before": "\u03b9 : Type u_1\nG : Type u_2\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : ConditionallyCompleteLattice G\ninst\u271d\u00b9 : CovariantClass G G (swap fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 G\nhf : BddAbove (range f)\na : G\n\u22a2 (\u2a06 i, f i) / a = \u2a06 i, f i / a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean", "full_name": "Fin.range_fin_succ", "start": [278, 1], "end": [280, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/Bounded.lean", "full_name": "Bornology.IsVonNBounded.of_sub_right", "start": [287, 1], "end": [289, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Prod/Lex.lean", "full_name": "Prod.Lex.toLex_strictMono", "start": [118, 1], "end": [122, 22], "traced_tactics": [{"tactic": "rintro \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9 h", "annotated_tactic": ["rintro \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9 h", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\n\u22a2 StrictMono \u21d1toLex", "state_after": "case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 : \u03b2\na\u2082 : \u03b1\nb\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2082, b\u2082)\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2082, b\u2082)"}, {"tactic": "obtain rfl | ha : a\u2081 = a\u2082 \u2228 _ := h.le.1.eq_or_lt", "annotated_tactic": ["obtain rfl | ha : a\u2081 = a\u2082 \u2228 _ := h.le.1.<a>eq_or_lt</a>", [{"full_name": "LE.le.eq_or_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [402, 7], "def_end_pos": [402, 21]}]], "state_before": "case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 : \u03b2\na\u2082 : \u03b1\nb\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2082, b\u2082)\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2082, b\u2082)", "state_after": "case mk.mk.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 b\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2081, b\u2082)\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2081, b\u2082)\n\ncase mk.mk.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 : \u03b2\na\u2082 : \u03b1\nb\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2082, b\u2082)\nha : (a\u2081, b\u2081).1 < (a\u2082, b\u2082).1\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2082, b\u2082)"}, {"tactic": "exact right _ (Prod.mk_lt_mk_iff_right.1 h)", "annotated_tactic": ["exact <a>right</a> _ (<a>Prod.mk_lt_mk_iff_right</a>.1 h)", [{"full_name": "Prod.Lex.right", "def_path": ".lake/packages/lean4/src/lean/Init/WF.lean", "def_pos": [207, 5], "def_end_pos": [207, 10]}, {"full_name": "Prod.mk_lt_mk_iff_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [1315, 9], "def_end_pos": [1315, 27]}]], "state_before": "case mk.mk.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 b\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2081, b\u2082)\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2081, b\u2082)", "state_after": "no goals"}, {"tactic": "exact left _ _ ha", "annotated_tactic": ["exact <a>left</a> _ _ ha", [{"full_name": "Prod.Lex.left", "def_path": ".lake/packages/lean4/src/lean/Init/WF.lean", "def_pos": [206, 5], "def_end_pos": [206, 9]}]], "state_before": "case mk.mk.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 : \u03b2\na\u2082 : \u03b1\nb\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2082, b\u2082)\nha : (a\u2081, b\u2081).1 < (a\u2082, b\u2082).1\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2082, b\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "full_name": "CategoryTheory.Limits.BinaryFan.isLimit_iff_isIso_fst", "start": [409, 1], "end": [422, 69], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\n\u22a2 Nonempty (IsLimit c) \u2194 IsIso (fst c)", "state_after": "case mp\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\n\u22a2 Nonempty (IsLimit c) \u2192 IsIso (fst c)\n\ncase mpr\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\n\u22a2 IsIso (fst c) \u2192 Nonempty (IsLimit c)"}, {"tactic": "rintro \u27e8H\u27e9", "annotated_tactic": ["rintro \u27e8H\u27e9", []], "state_before": "case mp\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\n\u22a2 Nonempty (IsLimit c) \u2192 IsIso (fst c)", "state_after": "case mp.intro\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\nH : IsLimit c\n\u22a2 IsIso (fst c)"}, {"tactic": "obtain \u27e8l, hl, -\u27e9 := BinaryFan.IsLimit.lift' H (\ud835\udfd9 X) (h.from X)", "annotated_tactic": ["obtain \u27e8l, hl, -\u27e9 := <a>BinaryFan.IsLimit.lift'</a> H (\ud835\udfd9 X) (h.from X)", [{"full_name": "CategoryTheory.Limits.BinaryFan.IsLimit.lift'", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "def_pos": [385, 5], "def_end_pos": [385, 28]}]], "state_before": "case mp.intro\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\nH : IsLimit c\n\u22a2 IsIso (fst c)", "state_after": "case mp.intro.mk.intro\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\nH : IsLimit c\nl : X \u27f6 c.pt\nhl : l \u226b fst c = \ud835\udfd9 X\n\u22a2 IsIso (fst c)"}, {"tactic": "exact\n  \u27e8\u27e8l,\n      BinaryFan.IsLimit.hom_ext H (by simpa [hl, -Category.comp_id] using Category.comp_id _)\n        (h.hom_ext _ _),\n      hl\u27e9\u27e9", "annotated_tactic": ["exact\n      \u27e8\u27e8l,\n          <a>BinaryFan.IsLimit.hom_ext</a> H (by simpa [hl, -Category.comp_id] using <a>Category.comp_id</a> _)\n            (h.hom_ext _ _),\n          hl\u27e9\u27e9", [{"full_name": "CategoryTheory.Limits.BinaryFan.IsLimit.hom_ext", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "def_pos": [240, 9], "def_end_pos": [240, 34]}, {"full_name": "CategoryTheory.Category.comp_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [166, 3], "def_end_pos": [166, 10]}]], "state_before": "case mp.intro.mk.intro\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\nH : IsLimit c\nl : X \u27f6 c.pt\nhl : l \u226b fst c = \ud835\udfd9 X\n\u22a2 IsIso (fst c)", "state_after": "no goals"}, {"tactic": "simpa [hl, -Category.comp_id] using Category.comp_id _", "annotated_tactic": ["simpa [hl, -Category.comp_id] using <a>Category.comp_id</a> _", [{"full_name": "CategoryTheory.Category.comp_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [166, 3], "def_end_pos": [166, 10]}]], "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\nH : IsLimit c\nl : X \u27f6 c.pt\nhl : l \u226b fst c = \ud835\udfd9 X\n\u22a2 (fst c \u226b l) \u226b fst c = \ud835\udfd9 (((Functor.const (Discrete WalkingPair)).obj c.pt).obj { as := left }) \u226b fst c", "state_after": "no goals"}, {"tactic": "intro", "annotated_tactic": ["intro", []], "state_before": "case mpr\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\n\u22a2 IsIso (fst c) \u2192 Nonempty (IsLimit c)", "state_after": "case mpr\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\na\u271d : IsIso (fst c)\n\u22a2 Nonempty (IsLimit c)"}, {"tactic": "exact\n  \u27e8BinaryFan.IsLimit.mk _ (fun f _ => f \u226b inv c.fst) (fun _ _ => by simp)\n      (fun _ _ => h.hom_ext _ _) fun _ _ _ e _ => by simp [\u2190 e]\u27e9", "annotated_tactic": ["exact\n      \u27e8<a>BinaryFan.IsLimit.mk</a> _ (fun f _ => f \u226b <a>inv</a> c.fst) (fun _ _ => by simp)\n          (fun _ _ => h.hom_ext _ _) fun _ _ _ e _ => by simp [\u2190 e]\u27e9", [{"full_name": "CategoryTheory.Limits.BinaryFan.IsLimit.mk", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "def_pos": [224, 5], "def_end_pos": [224, 25]}, {"full_name": "CategoryTheory.inv", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [263, 19], "def_end_pos": [263, 22]}]], "state_before": "case mpr\nC : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\na\u271d : IsIso (fst c)\n\u22a2 Nonempty (IsLimit c)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\na\u271d : IsIso (fst c)\nT\u271d : C\nx\u271d\u00b9 : T\u271d \u27f6 X\nx\u271d : T\u271d \u27f6 Y\n\u22a2 (fun {T} f x => f \u226b inv (fst c)) x\u271d\u00b9 x\u271d \u226b fst c = x\u271d\u00b9", "state_after": "no goals"}, {"tactic": "simp [\u2190 e]", "annotated_tactic": ["simp [\u2190 e]", []], "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d X Y : C\nh : IsTerminal Y\nc : BinaryFan X Y\na\u271d : IsIso (fst c)\nT\u271d : C\nx\u271d\u00b3 : T\u271d \u27f6 X\nx\u271d\u00b2 : T\u271d \u27f6 Y\nx\u271d\u00b9 : T\u271d \u27f6 c.pt\ne : x\u271d\u00b9 \u226b fst c = x\u271d\u00b3\nx\u271d : x\u271d\u00b9 \u226b snd c = x\u271d\u00b2\n\u22a2 x\u271d\u00b9 = (fun {T} f x => f \u226b inv (fst c)) x\u271d\u00b3 x\u271d\u00b2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isLittleO_irrefl'", "start": [618, 1], "end": [622, 76], "traced_tactics": [{"tactic": "intro ho", "annotated_tactic": ["intro ho", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\nh : \u2203\u1da0 (x : \u03b1) in l, \u2016f' x\u2016 \u2260 0\n\u22a2 \u00acf' =o[l] f'", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\nh : \u2203\u1da0 (x : \u03b1) in l, \u2016f' x\u2016 \u2260 0\nho : f' =o[l] f'\n\u22a2 False"}, {"tactic": "rcases ((ho.bound one_half_pos).and_frequently h).exists with \u27e8x, hle, hne\u27e9", "annotated_tactic": ["rcases ((ho.bound <a>one_half_pos</a>).<a>and_frequently</a> h).<a>exists</a> with \u27e8x, hle, hne\u27e9", [{"full_name": "one_half_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [528, 9], "def_end_pos": [528, 21]}, {"full_name": "Filter.Eventually.and_frequently", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1316, 9], "def_end_pos": [1316, 34]}, {"full_name": "Filter.Frequently.exists", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1321, 9], "def_end_pos": [1321, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\nh : \u2203\u1da0 (x : \u03b1) in l, \u2016f' x\u2016 \u2260 0\nho : f' =o[l] f'\n\u22a2 False", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\nh : \u2203\u1da0 (x : \u03b1) in l, \u2016f' x\u2016 \u2260 0\nho : f' =o[l] f'\nx : \u03b1\nhle : \u2016f' x\u2016 \u2264 1 / 2 * \u2016f' x\u2016\nhne : \u2016f' x\u2016 \u2260 0\n\u22a2 False"}, {"tactic": "rw [one_div, \u2190 div_eq_inv_mul] at hle", "annotated_tactic": ["rw [<a>one_div</a>, \u2190 <a>div_eq_inv_mul</a>] at hle", [{"full_name": "one_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [386, 9], "def_end_pos": [386, 16]}, {"full_name": "div_eq_inv_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [567, 9], "def_end_pos": [567, 23]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\nh : \u2203\u1da0 (x : \u03b1) in l, \u2016f' x\u2016 \u2260 0\nho : f' =o[l] f'\nx : \u03b1\nhle : \u2016f' x\u2016 \u2264 1 / 2 * \u2016f' x\u2016\nhne : \u2016f' x\u2016 \u2260 0\n\u22a2 False", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\nh : \u2203\u1da0 (x : \u03b1) in l, \u2016f' x\u2016 \u2260 0\nho : f' =o[l] f'\nx : \u03b1\nhle : \u2016f' x\u2016 \u2264 \u2016f' x\u2016 / 2\nhne : \u2016f' x\u2016 \u2260 0\n\u22a2 False"}, {"tactic": "exact (half_lt_self (lt_of_le_of_ne (norm_nonneg _) hne.symm)).not_le hle", "annotated_tactic": ["exact (<a>half_lt_self</a> (<a>lt_of_le_of_ne</a> (<a>norm_nonneg</a> _) hne.symm)).<a>not_le</a> hle", [{"full_name": "half_lt_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [545, 11], "def_end_pos": [545, 23]}, {"full_name": "lt_of_le_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [190, 9], "def_end_pos": [190, 23]}, {"full_name": "norm_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [551, 30], "def_end_pos": [551, 41]}, {"full_name": "LT.lt.not_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [348, 7], "def_end_pos": [348, 19]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\nF : Type u_4\nG : Type u_5\nE' : Type u_6\nF' : Type u_7\nG' : Type u_8\nE'' : Type u_9\nF'' : Type u_10\nG'' : Type u_11\nE''' : Type u_12\nR : Type u_13\nR' : Type u_14\n\ud835\udd5c : Type u_15\n\ud835\udd5c' : Type u_16\ninst\u271d\u00b9\u00b3 : Norm E\ninst\u271d\u00b9\u00b2 : Norm F\ninst\u271d\u00b9\u00b9 : Norm G\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E'\ninst\u271d\u2079 : SeminormedAddCommGroup F'\ninst\u271d\u2078 : SeminormedAddCommGroup G'\ninst\u271d\u2077 : NormedAddCommGroup E''\ninst\u271d\u2076 : NormedAddCommGroup F''\ninst\u271d\u2075 : NormedAddCommGroup G''\ninst\u271d\u2074 : SeminormedRing R\ninst\u271d\u00b3 : SeminormedAddGroup E'''\ninst\u271d\u00b2 : SeminormedRing R'\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : NormedDivisionRing \ud835\udd5c'\nc c' c\u2081 c\u2082 : \u211d\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\nk : \u03b1 \u2192 G\nf' : \u03b1 \u2192 E'\ng' : \u03b1 \u2192 F'\nk' : \u03b1 \u2192 G'\nf'' : \u03b1 \u2192 E''\ng'' : \u03b1 \u2192 F''\nk'' : \u03b1 \u2192 G''\nl l' : Filter \u03b1\nh : \u2203\u1da0 (x : \u03b1) in l, \u2016f' x\u2016 \u2260 0\nho : f' =o[l] f'\nx : \u03b1\nhle : \u2016f' x\u2016 \u2264 \u2016f' x\u2016 / 2\nhne : \u2016f' x\u2016 \u2260 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/NAry.lean", "full_name": "Filter.le_map\u2082_iff", "start": [84, 1], "end": [87, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "full_name": "Equiv.Perm.support_cycleOf_eq_nil_iff", "start": [219, 1], "end": [219, 90], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nx y : \u03b1\n\u22a2 support (cycleOf f x) = \u2205 \u2194 x \u2209 support f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "And.exists", "start": [829, 1], "end": [830, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Completion.lean", "full_name": "UniformSpace.Completion.induction_on\u2083", "start": [466, 1], "end": [472, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Functor/Const.lean", "full_name": "CategoryTheory.Functor.const.unop_functor_op_obj_map", "start": [81, 1], "end": [83, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.extend_iUnion_le_tsum_nat", "start": [1554, 1], "end": [1561, 77], "traced_tactics": [{"tactic": "refine' extend_iUnion_le_tsum_nat' MeasurableSet.iUnion _", "annotated_tactic": ["refine' <a>extend_iUnion_le_tsum_nat'</a> <a>MeasurableSet.iUnion</a> _", [{"full_name": "MeasureTheory.extend_iUnion_le_tsum_nat'", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1376, 9], "def_end_pos": [1376, 35]}, {"full_name": "MeasurableSet.iUnion", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [116, 19], "def_end_pos": [116, 39]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\n\u22a2 \u2200 (s : \u2115 \u2192 Set \u03b1), extend m (\u22c3 i, s i) \u2264 \u2211' (i : \u2115), extend m (s i)", "state_after": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\n\u22a2 \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef"}, {"tactic": "intro f h", "annotated_tactic": ["intro f h", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\n\u22a2 \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef", "state_after": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\n\u22a2 m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef"}, {"tactic": "simp (config := { singlePass := true }) only [iUnion_disjointed.symm]", "annotated_tactic": ["simp (config := { singlePass := <a>true</a> }) only [iUnion_disjointed.symm]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\n\u22a2 m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef", "state_after": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\n\u22a2 m (\u22c3 n, disjointed (fun n => f n) n) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef"}, {"tactic": "rw [mU (MeasurableSet.disjointed h) (disjoint_disjointed _)]", "annotated_tactic": ["rw [mU (<a>MeasurableSet.disjointed</a> h) (<a>disjoint_disjointed</a> _)]", [{"full_name": "MeasurableSet.disjointed", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [245, 19], "def_end_pos": [245, 43]}, {"full_name": "disjoint_disjointed", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjointed.lean", "def_pos": [74, 9], "def_end_pos": [74, 28]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\n\u22a2 m (\u22c3 n, disjointed (fun n => f n) n) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef", "state_after": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\n\u22a2 \u2211' (i : \u2115), m (disjointed (fun i => f i) i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef"}, {"tactic": "refine' ENNReal.tsum_le_tsum fun i => _", "annotated_tactic": ["refine' <a>ENNReal.tsum_le_tsum</a> fun i => _", [{"full_name": "ENNReal.tsum_le_tsum", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [851, 19], "def_end_pos": [851, 31]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\n\u22a2 \u2211' (i : \u2115), m (disjointed (fun i => f i) i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef", "state_after": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\ni : \u2115\n\u22a2 m (disjointed (fun i => f i) i) \u22ef \u2264 m (f i) \u22ef"}, {"tactic": "rw [\u2190 extend_eq m, \u2190 extend_eq m]", "annotated_tactic": ["rw [\u2190 <a>extend_eq</a> m, \u2190 <a>extend_eq</a> m]", [{"full_name": "MeasureTheory.extend_eq", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1311, 9], "def_end_pos": [1311, 18]}, {"full_name": "MeasureTheory.extend_eq", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1311, 9], "def_end_pos": [1311, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\ni : \u2115\n\u22a2 m (disjointed (fun i => f i) i) \u22ef \u2264 m (f i) \u22ef", "state_after": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\ni : \u2115\n\u22a2 extend m (disjointed (fun i => f i) i) \u2264 extend m (f i)"}, {"tactic": "exact extend_mono m0 mU (MeasurableSet.disjointed h _) (disjointed_le f _)", "annotated_tactic": ["exact <a>extend_mono</a> m0 mU (<a>MeasurableSet.disjointed</a> h _) (<a>disjointed_le</a> f _)", [{"full_name": "MeasureTheory.extend_mono", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1543, 9], "def_end_pos": [1543, 20]}, {"full_name": "MeasurableSet.disjointed", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [245, 19], "def_end_pos": [245, 43]}, {"full_name": "disjointed_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjointed.lean", "def_pos": [70, 9], "def_end_pos": [70, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm : (s : Set \u03b1) \u2192 MeasurableSet s \u2192 \u211d\u22650\u221e\nm0 : m \u2205 \u22ef = 0\nmU :\n  \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), MeasurableSet (f i)),\n    Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nf : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), MeasurableSet (f i)\ni : \u2115\n\u22a2 extend m (disjointed (fun i => f i) i) \u2264 extend m (f i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.image_image\u2082_antidistrib", "start": [447, 1], "end": [451, 58], "traced_tactics": [{"tactic": "rw [image\u2082_swap f]", "annotated_tactic": ["rw [<a>image\u2082_swap</a> f]", [{"full_name": "Finset.image\u2082_swap", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [328, 9], "def_end_pos": [328, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f'\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ng : \u03b3 \u2192 \u03b4\nf' : \u03b2' \u2192 \u03b1' \u2192 \u03b4\ng\u2081 : \u03b2 \u2192 \u03b2'\ng\u2082 : \u03b1 \u2192 \u03b1'\nh_antidistrib : \u2200 (a : \u03b1) (b : \u03b2), g (f a b) = f' (g\u2081 b) (g\u2082 a)\n\u22a2 image g (image\u2082 f s t) = image\u2082 f' (image g\u2081 t) (image g\u2082 s)", "state_after": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f'\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ng : \u03b3 \u2192 \u03b4\nf' : \u03b2' \u2192 \u03b1' \u2192 \u03b4\ng\u2081 : \u03b2 \u2192 \u03b2'\ng\u2082 : \u03b1 \u2192 \u03b1'\nh_antidistrib : \u2200 (a : \u03b1) (b : \u03b2), g (f a b) = f' (g\u2081 b) (g\u2082 a)\n\u22a2 image g (image\u2082 (fun a b => f b a) t s) = image\u2082 f' (image g\u2081 t) (image g\u2082 s)"}, {"tactic": "exact image_image\u2082_distrib fun _ _ => h_antidistrib _ _", "annotated_tactic": ["exact <a>image_image\u2082_distrib</a> fun _ _ => h_antidistrib _ _", [{"full_name": "Finset.image_image\u2082_distrib", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [387, 9], "def_end_pos": [387, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f'\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ng : \u03b3 \u2192 \u03b4\nf' : \u03b2' \u2192 \u03b1' \u2192 \u03b4\ng\u2081 : \u03b2 \u2192 \u03b2'\ng\u2082 : \u03b1 \u2192 \u03b1'\nh_antidistrib : \u2200 (a : \u03b1) (b : \u03b2), g (f a b) = f' (g\u2081 b) (g\u2082 a)\n\u22a2 image g (image\u2082 (fun a b => f b a) t s) = image\u2082 f' (image g\u2081 t) (image g\u2082 s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Star.lean", "full_name": "continuous_decomposeProdAdjoint_symm", "start": [65, 1], "end": [67, 96], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Content.lean", "full_name": "Polynomial.eval\u2082_primPart_eq_zero", "start": [321, 1], "end": [328, 56], "traced_tactics": [{"tactic": "rw [eq_C_content_mul_primPart p, eval\u2082_mul, eval\u2082_C] at hp", "annotated_tactic": ["rw [<a>eq_C_content_mul_primPart</a> p, <a>eval\u2082_mul</a>, <a>eval\u2082_C</a>] at hp", [{"full_name": "Polynomial.eq_C_content_mul_primPart", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [251, 9], "def_end_pos": [251, 34]}, {"full_name": "Polynomial.eval\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [263, 9], "def_end_pos": [263, 18]}, {"full_name": "Polynomial.eval\u2082_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [69, 9], "def_end_pos": [69, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizedGCDMonoid R\nS : Type u_2\ninst\u271d\u00b9 : CommRing S\ninst\u271d : IsDomain S\nf : R \u2192+* S\nhinj : Function.Injective \u21d1f\np : R[X]\ns : S\nhpzero : p \u2260 0\nhp : eval\u2082 f s p = 0\n\u22a2 eval\u2082 f s (primPart p) = 0", "state_after": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizedGCDMonoid R\nS : Type u_2\ninst\u271d\u00b9 : CommRing S\ninst\u271d : IsDomain S\nf : R \u2192+* S\nhinj : Function.Injective \u21d1f\np : R[X]\ns : S\nhpzero : p \u2260 0\nhp : f (content p) * eval\u2082 f s (primPart p) = 0\n\u22a2 eval\u2082 f s (primPart p) = 0"}, {"tactic": "have hcont : p.content \u2260 0 := fun h => hpzero (content_eq_zero_iff.1 h)", "annotated_tactic": ["have hcont : p.content \u2260 0 := fun h => hpzero (<a>content_eq_zero_iff</a>.1 h)", [{"full_name": "Polynomial.content_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [158, 9], "def_end_pos": [158, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizedGCDMonoid R\nS : Type u_2\ninst\u271d\u00b9 : CommRing S\ninst\u271d : IsDomain S\nf : R \u2192+* S\nhinj : Function.Injective \u21d1f\np : R[X]\ns : S\nhpzero : p \u2260 0\nhp : f (content p) * eval\u2082 f s (primPart p) = 0\n\u22a2 eval\u2082 f s (primPart p) = 0", "state_after": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizedGCDMonoid R\nS : Type u_2\ninst\u271d\u00b9 : CommRing S\ninst\u271d : IsDomain S\nf : R \u2192+* S\nhinj : Function.Injective \u21d1f\np : R[X]\ns : S\nhpzero : p \u2260 0\nhp : f (content p) * eval\u2082 f s (primPart p) = 0\nhcont : content p \u2260 0\n\u22a2 eval\u2082 f s (primPart p) = 0"}, {"tactic": "replace hcont := Function.Injective.ne hinj hcont", "annotated_tactic": ["replace hcont := <a>Function.Injective.ne</a> hinj hcont", [{"full_name": "Function.Injective.ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [103, 9], "def_end_pos": [103, 21]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizedGCDMonoid R\nS : Type u_2\ninst\u271d\u00b9 : CommRing S\ninst\u271d : IsDomain S\nf : R \u2192+* S\nhinj : Function.Injective \u21d1f\np : R[X]\ns : S\nhpzero : p \u2260 0\nhp : f (content p) * eval\u2082 f s (primPart p) = 0\nhcont : content p \u2260 0\n\u22a2 eval\u2082 f s (primPart p) = 0", "state_after": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizedGCDMonoid R\nS : Type u_2\ninst\u271d\u00b9 : CommRing S\ninst\u271d : IsDomain S\nf : R \u2192+* S\nhinj : Function.Injective \u21d1f\np : R[X]\ns : S\nhpzero : p \u2260 0\nhp : f (content p) * eval\u2082 f s (primPart p) = 0\nhcont : f (content p) \u2260 f 0\n\u22a2 eval\u2082 f s (primPart p) = 0"}, {"tactic": "rw [map_zero] at hcont", "annotated_tactic": ["rw [<a>map_zero</a>] at hcont", [{"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizedGCDMonoid R\nS : Type u_2\ninst\u271d\u00b9 : CommRing S\ninst\u271d : IsDomain S\nf : R \u2192+* S\nhinj : Function.Injective \u21d1f\np : R[X]\ns : S\nhpzero : p \u2260 0\nhp : f (content p) * eval\u2082 f s (primPart p) = 0\nhcont : f (content p) \u2260 f 0\n\u22a2 eval\u2082 f s (primPart p) = 0", "state_after": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizedGCDMonoid R\nS : Type u_2\ninst\u271d\u00b9 : CommRing S\ninst\u271d : IsDomain S\nf : R \u2192+* S\nhinj : Function.Injective \u21d1f\np : R[X]\ns : S\nhpzero : p \u2260 0\nhp : f (content p) * eval\u2082 f s (primPart p) = 0\nhcont : f (content p) \u2260 0\n\u22a2 eval\u2082 f s (primPart p) = 0"}, {"tactic": "exact eq_zero_of_ne_zero_of_mul_left_eq_zero hcont hp", "annotated_tactic": ["exact <a>eq_zero_of_ne_zero_of_mul_left_eq_zero</a> hcont hp", [{"full_name": "eq_zero_of_ne_zero_of_mul_left_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean", "def_pos": [193, 9], "def_end_pos": [193, 47]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDomain R\ninst\u271d\u00b2 : NormalizedGCDMonoid R\nS : Type u_2\ninst\u271d\u00b9 : CommRing S\ninst\u271d : IsDomain S\nf : R \u2192+* S\nhinj : Function.Injective \u21d1f\np : R[X]\ns : S\nhpzero : p \u2260 0\nhp : f (content p) * eval\u2082 f s (primPart p) = 0\nhcont : f (content p) \u2260 0\n\u22a2 eval\u2082 f s (primPart p) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Fin.lean", "full_name": "finSuccAboveEquiv_symm_apply_ne_last", "start": [256, 1], "end": [260, 90], "traced_tactics": [{"tactic": "rw [\u2190 Option.some_inj]", "annotated_tactic": ["rw [\u2190 <a>Option.some_inj</a>]", [{"full_name": "Option.some_inj", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Instances.lean", "def_pos": [32, 9], "def_end_pos": [32, 17]}]], "state_before": "m n : \u2115\np : Fin (n + 1)\nh : p \u2260 Fin.last n\nx : { x // x \u2260 p }\n\u22a2 (OrderIso.symm (finSuccAboveEquiv p)) x = Fin.predAbove (Fin.castLT p \u22ef) \u2191x", "state_after": "m n : \u2115\np : Fin (n + 1)\nh : p \u2260 Fin.last n\nx : { x // x \u2260 p }\n\u22a2 some ((OrderIso.symm (finSuccAboveEquiv p)) x) = some (Fin.predAbove (Fin.castLT p \u22ef) \u2191x)"}, {"tactic": "simpa [finSuccAboveEquiv, OrderIso.symm] using finSuccEquiv'_ne_last_apply h x.property", "annotated_tactic": ["simpa [<a>finSuccAboveEquiv</a>, <a>OrderIso.symm</a>] using <a>finSuccEquiv'_ne_last_apply</a> h x.property", [{"full_name": "finSuccAboveEquiv", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Fin.lean", "def_pos": [240, 5], "def_end_pos": [240, 22]}, {"full_name": "OrderIso.symm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Hom/Basic.lean", "def_pos": [856, 5], "def_end_pos": [856, 9]}, {"full_name": "finSuccEquiv'_ne_last_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Fin.lean", "def_pos": [232, 9], "def_end_pos": [232, 36]}]], "state_before": "m n : \u2115\np : Fin (n + 1)\nh : p \u2260 Fin.last n\nx : { x // x \u2260 p }\n\u22a2 some ((OrderIso.symm (finSuccAboveEquiv p)) x) = some (Fin.predAbove (Fin.castLT p \u22ef) \u2191x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "isOpen_interior", "start": [256, 1], "end": [257, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Image.lean", "full_name": "Set.image_subtype_val_Ici_subset", "start": [283, 1], "end": [285, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.preimage_const_add_Ici", "start": [127, 1], "end": [128, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "sq_lt_one_iff", "start": [363, 1], "end": [364, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Field/UnitBall.lean", "full_name": "coe_mul_unitSphere", "start": [162, 1], "end": [164, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sign.lean", "full_name": "SignType.nonpos_iff", "start": [172, 1], "end": [172, 84], "traced_tactics": [{"tactic": "cases a <;> decide", "annotated_tactic": ["cases a <;> decide", []], "state_before": "a : SignType\n\u22a2 a \u2264 0 \u2194 a = -1 \u2228 a = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.head!_mem_head?", "start": [835, 1], "end": [837, 21], "traced_tactics": [{"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : Inhabited \u03b1\nh : [] \u2260 []\n\u22a2 head! [] \u2208 head? []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Module.lean", "full_name": "tsum_const_smul", "start": [32, 1], "end": [33, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean", "full_name": "Ordinal.nfp_mul_zero", "start": [626, 1], "end": [630, 49], "traced_tactics": [{"tactic": "rw [\u2190 Ordinal.le_zero, nfp_le_iff]", "annotated_tactic": ["rw [\u2190 <a>Ordinal.le_zero</a>, <a>nfp_le_iff</a>]", [{"full_name": "Ordinal.le_zero", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [402, 19], "def_end_pos": [402, 26]}, {"full_name": "Ordinal.nfp_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/FixedPoint.lean", "def_pos": [449, 9], "def_end_pos": [449, 19]}]], "state_before": "a : Ordinal.{u_1}\n\u22a2 nfp (fun x => a * x) 0 = 0", "state_after": "a : Ordinal.{u_1}\n\u22a2 \u2200 (n : \u2115), (fun x => a * x)^[n] 0 \u2264 0"}, {"tactic": "intro n", "annotated_tactic": ["intro n", []], "state_before": "a : Ordinal.{u_1}\n\u22a2 \u2200 (n : \u2115), (fun x => a * x)^[n] 0 \u2264 0", "state_after": "a : Ordinal.{u_1}\nn : \u2115\n\u22a2 (fun x => a * x)^[n] 0 \u2264 0"}, {"tactic": "induction' n with n hn", "annotated_tactic": ["induction' n with n hn", []], "state_before": "a : Ordinal.{u_1}\nn : \u2115\n\u22a2 (fun x => a * x)^[n] 0 \u2264 0", "state_after": "case zero\na : Ordinal.{u_1}\n\u22a2 (fun x => a * x)^[Nat.zero] 0 \u2264 0\n\ncase succ\na : Ordinal.{u_1}\nn : \u2115\nhn : (fun x => a * x)^[n] 0 \u2264 0\n\u22a2 (fun x => a * x)^[Nat.succ n] 0 \u2264 0"}, {"tactic": "rwa [iterate_succ_apply, mul_zero]", "annotated_tactic": ["rwa [<a>iterate_succ_apply</a>, <a>mul_zero</a>]", [{"full_name": "Function.iterate_succ_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [66, 9], "def_end_pos": [66, 27]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}]], "state_before": "case succ\na : Ordinal.{u_1}\nn : \u2115\nhn : (fun x => a * x)^[n] 0 \u2264 0\n\u22a2 (fun x => a * x)^[Nat.succ n] 0 \u2264 0", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case zero\na : Ordinal.{u_1}\n\u22a2 (fun x => a * x)^[Nat.zero] 0 \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "ne_iff_ne_of_mul_eq_mul", "start": [298, 1], "end": [298, 93], "traced_tactics": [{"tactic": "aesop", "annotated_tactic": ["aesop", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : CancelCommMonoid \u03b1\na b c d : \u03b1\nh : a * b = c * d\n\u22a2 a \u2260 c \u2194 b \u2260 d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finite/Defs.lean", "full_name": "not_infinite_iff_finite", "start": [128, 1], "end": [129, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.subgroupOf_self", "start": [1668, 1], "end": [1669, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Cofinite.lean", "full_name": "Filter.eventually_cofinite_ne", "start": [97, 1], "end": [98, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Set.toFinset_symmDiff", "start": [752, 1], "end": [755, 43], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \u2206 t)\n\u22a2 toFinset (s \u2206 t) = toFinset s \u2206 toFinset t", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \u2206 t)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 toFinset (s \u2206 t) \u2194 a\u271d \u2208 toFinset s \u2206 toFinset t"}, {"tactic": "simp [mem_symmDiff, Finset.mem_symmDiff]", "annotated_tactic": ["simp [<a>mem_symmDiff</a>, <a>Finset.mem_symmDiff</a>]", [{"full_name": "Set.mem_symmDiff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2089, 9], "def_end_pos": [2089, 21]}, {"full_name": "Finset.mem_symmDiff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2489, 9], "def_end_pos": [2489, 21]}]], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns t : Set \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(s \u2206 t)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 toFinset (s \u2206 t) \u2194 a\u271d \u2208 toFinset s \u2206 toFinset t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Theta.lean", "full_name": "Asymptotics.IsTheta.eq_zero_iff", "start": [210, 1], "end": [211, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "contDiffOn_of_continuousOn_differentiableOn", "start": [1057, 1], "end": [1072, 35], "traced_tactics": [{"tactic": "intro x hx m hm", "annotated_tactic": ["intro x hx m hm", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\n\u22a2 ContDiffOn \ud835\udd5c n f s", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p u"}, {"tactic": "rw [insert_eq_of_mem hx]", "annotated_tactic": ["rw [<a>insert_eq_of_mem</a> hx]", [{"full_name": "Set.insert_eq_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1122, 9], "def_end_pos": [1122, 25]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 u \u2208 \ud835\udcdd[insert x s] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p u", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 u \u2208 \ud835\udcdd[s] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p u"}, {"tactic": "refine' \u27e8s, self_mem_nhdsWithin, ftaylorSeriesWithin \ud835\udd5c f s, _\u27e9", "annotated_tactic": ["refine' \u27e8s, <a>self_mem_nhdsWithin</a>, <a>ftaylorSeriesWithin</a> \ud835\udd5c f s, _\u27e9", [{"full_name": "self_mem_nhdsWithin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/ContinuousOn.lean", "def_pos": [148, 9], "def_end_pos": [148, 28]}, {"full_name": "ftaylorSeriesWithin", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [777, 5], "def_end_pos": [777, 24]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2203 u \u2208 \ud835\udcdd[s] x, \u2203 p, HasFTaylorSeriesUpToOn (\u2191m) f p u", "state_after": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 HasFTaylorSeriesUpToOn (\u2191m) f (ftaylorSeriesWithin \ud835\udd5c f s) s"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 HasFTaylorSeriesUpToOn (\u2191m) f (ftaylorSeriesWithin \ud835\udd5c f s) s", "state_after": "case zero_eq\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2200 x \u2208 s, ContinuousMultilinearMap.uncurry0 (ftaylorSeriesWithin \ud835\udd5c f s x 0) = f x\n\ncase fderivWithin\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2200 (m_1 : \u2115),\n    \u2191m_1 < \u2191m \u2192\n      \u2200 x \u2208 s,\n        HasFDerivWithinAt (fun x => ftaylorSeriesWithin \ud835\udd5c f s x m_1)\n          (ContinuousMultilinearMap.curryLeft (ftaylorSeriesWithin \ud835\udd5c f s x (Nat.succ m_1))) s x\n\ncase cont\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2200 (m_1 : \u2115), \u2191m_1 \u2264 \u2191m \u2192 ContinuousOn (fun x => ftaylorSeriesWithin \ud835\udd5c f s x m_1) s"}, {"tactic": "intro y _", "annotated_tactic": ["intro y _", []], "state_before": "case zero_eq\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2200 x \u2208 s, ContinuousMultilinearMap.uncurry0 (ftaylorSeriesWithin \ud835\udd5c f s x 0) = f x", "state_after": "case zero_eq\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\ny : E\na\u271d : y \u2208 s\n\u22a2 ContinuousMultilinearMap.uncurry0 (ftaylorSeriesWithin \ud835\udd5c f s y 0) = f y"}, {"tactic": "simp only [ftaylorSeriesWithin, ContinuousMultilinearMap.uncurry0_apply,\n  iteratedFDerivWithin_zero_apply]", "annotated_tactic": ["simp only [<a>ftaylorSeriesWithin</a>, <a>ContinuousMultilinearMap.uncurry0_apply</a>,\n      <a>iteratedFDerivWithin_zero_apply</a>]", [{"full_name": "ftaylorSeriesWithin", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [777, 5], "def_end_pos": [777, 24]}, {"full_name": "ContinuousMultilinearMap.uncurry0_apply", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Multilinear/Curry.lean", "def_pos": [425, 9], "def_end_pos": [425, 48]}, {"full_name": "iteratedFDerivWithin_zero_apply", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [784, 9], "def_end_pos": [784, 40]}]], "state_before": "case zero_eq\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\ny : E\na\u271d : y \u2208 s\n\u22a2 ContinuousMultilinearMap.uncurry0 (ftaylorSeriesWithin \ud835\udd5c f s y 0) = f y", "state_after": "no goals"}, {"tactic": "intro k hk y hy", "annotated_tactic": ["intro k hk y hy", []], "state_before": "case fderivWithin\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2200 (m_1 : \u2115),\n    \u2191m_1 < \u2191m \u2192\n      \u2200 x \u2208 s,\n        HasFDerivWithinAt (fun x => ftaylorSeriesWithin \ud835\udd5c f s x m_1)\n          (ContinuousMultilinearMap.curryLeft (ftaylorSeriesWithin \ud835\udd5c f s x (Nat.succ m_1))) s x", "state_after": "case fderivWithin\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\nk : \u2115\nhk : \u2191k < \u2191m\ny : E\nhy : y \u2208 s\n\u22a2 HasFDerivWithinAt (fun x => ftaylorSeriesWithin \ud835\udd5c f s x k)\n    (ContinuousMultilinearMap.curryLeft (ftaylorSeriesWithin \ud835\udd5c f s y (Nat.succ k))) s y"}, {"tactic": "convert (Hdiff k (lt_of_lt_of_le hk hm) y hy).hasFDerivWithinAt", "annotated_tactic": ["convert (Hdiff k (<a>lt_of_lt_of_le</a> hk hm) y hy).<a>hasFDerivWithinAt</a>", [{"full_name": "lt_of_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [109, 9], "def_end_pos": [109, 23]}, {"full_name": "DifferentiableWithinAt.hasFDerivWithinAt", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [543, 9], "def_end_pos": [543, 49]}]], "state_before": "case fderivWithin\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\nk : \u2115\nhk : \u2191k < \u2191m\ny : E\nhy : y \u2208 s\n\u22a2 HasFDerivWithinAt (fun x => ftaylorSeriesWithin \ud835\udd5c f s x k)\n    (ContinuousMultilinearMap.curryLeft (ftaylorSeriesWithin \ud835\udd5c f s y (Nat.succ k))) s y", "state_after": "no goals"}, {"tactic": "intro k hk", "annotated_tactic": ["intro k hk", []], "state_before": "case cont\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\n\u22a2 \u2200 (m_1 : \u2115), \u2191m_1 \u2264 \u2191m \u2192 ContinuousOn (fun x => ftaylorSeriesWithin \ud835\udd5c f s x m_1) s", "state_after": "case cont\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\nk : \u2115\nhk : \u2191k \u2264 \u2191m\n\u22a2 ContinuousOn (fun x => ftaylorSeriesWithin \ud835\udd5c f s x k) s"}, {"tactic": "exact Hcont k (le_trans hk hm)", "annotated_tactic": ["exact Hcont k (<a>le_trans</a> hk hm)", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}]], "state_before": "case cont\n\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nm\u271d n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nHcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 ContinuousOn (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nHdiff : \u2200 (m : \u2115), \u2191m < n \u2192 DifferentiableOn \ud835\udd5c (fun x => iteratedFDerivWithin \ud835\udd5c m f s x) s\nx : E\nhx : x \u2208 s\nm : \u2115\nhm : \u2191m \u2264 n\nk : \u2115\nhk : \u2191k \u2264 \u2191m\n\u22a2 ContinuousOn (fun x => ftaylorSeriesWithin \ud835\udd5c f s x k) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Pi/Lemmas.lean", "full_name": "Function.const_eq_one", "start": [509, 1], "end": [510, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Divisors.lean", "full_name": "Nat.image_snd_divisorsAntidiagonal", "start": [305, 1], "end": [307, 39], "traced_tactics": [{"tactic": "rw [\u2190 map_swap_divisorsAntidiagonal, map_eq_image, image_image]", "annotated_tactic": ["rw [\u2190 <a>map_swap_divisorsAntidiagonal</a>, <a>map_eq_image</a>, <a>image_image</a>]", [{"full_name": "Nat.map_swap_divisorsAntidiagonal", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [290, 9], "def_end_pos": [290, 38]}, {"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}, {"full_name": "Finset.image_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [461, 9], "def_end_pos": [461, 20]}]], "state_before": "n : \u2115\n\u22a2 image Prod.snd (divisorsAntidiagonal n) = divisors n", "state_after": "n : \u2115\n\u22a2 image (Prod.snd \u2218 \u21d1(Equiv.toEmbedding (Equiv.prodComm \u2115 \u2115))) (divisorsAntidiagonal n) = divisors n"}, {"tactic": "exact image_fst_divisorsAntidiagonal", "annotated_tactic": ["exact <a>image_fst_divisorsAntidiagonal</a>", [{"full_name": "Nat.image_fst_divisorsAntidiagonal", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [299, 9], "def_end_pos": [299, 39]}]], "state_before": "n : \u2115\n\u22a2 image (Prod.snd \u2218 \u21d1(Equiv.toEmbedding (Equiv.prodComm \u2115 \u2115))) (divisorsAntidiagonal n) = divisors n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/Composition.lean", "full_name": "Composition.length_pos_of_pos", "start": [194, 1], "end": [197, 21], "traced_tactics": [{"tactic": "apply length_pos_of_sum_pos", "annotated_tactic": ["apply <a>length_pos_of_sum_pos</a>", [{"full_name": "List.length_pos_of_sum_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [212, 15], "def_end_pos": [212, 36]}]], "state_before": "n : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 0 < length c", "state_after": "case h\nn : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 0 < sum c.blocks"}, {"tactic": "convert h", "annotated_tactic": ["convert h", []], "state_before": "case h\nn : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 0 < sum c.blocks", "state_after": "case h.e'_4\nn : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 sum c.blocks = n"}, {"tactic": "exact c.blocks_sum", "annotated_tactic": ["exact c.blocks_sum", []], "state_before": "case h.e'_4\nn : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 sum c.blocks = n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/Alter.lean", "full_name": "Std.RBNode.Path.Ordered.erase", "start": [333, 1], "end": [336, 96], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.lintegral_iSup_directed_of_measurable", "start": [1240, 1], "end": [1258, 88], "traced_tactics": [{"tactic": "cases nonempty_encodable \u03b2", "annotated_tactic": ["cases <a>nonempty_encodable</a> \u03b2", [{"full_name": "nonempty_encodable", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Encodable/Basic.lean", "def_pos": [468, 9], "def_end_pos": [468, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc"}, {"tactic": "cases isEmpty_or_nonempty \u03b2", "annotated_tactic": ["cases <a>isEmpty_or_nonempty</a> \u03b2", [{"full_name": "isEmpty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [215, 9], "def_end_pos": [215, 28]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc", "state_after": "case intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : IsEmpty \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc\n\ncase intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc"}, {"tactic": "inhabit \u03b2", "annotated_tactic": ["inhabit \u03b2", []], "state_before": "case intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc", "state_after": "case intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc"}, {"tactic": "have : \u2200 a, \u2a06 b, f b a = \u2a06 n, f (h_directed.sequence f n) a := by\n  intro a\n  refine' le_antisymm (iSup_le fun b => _) (iSup_le fun n => le_iSup (fun n => f n a) _)\n  exact le_iSup_of_le (encode b + 1) (h_directed.le_sequence b a)", "annotated_tactic": ["have : \u2200 a, \u2a06 b, f b a = \u2a06 n, f (h_directed.sequence f n) a := by\n    intro a\n    refine' <a>le_antisymm</a> (<a>iSup_le</a> fun b => _) (<a>iSup_le</a> fun n => <a>le_iSup</a> (fun n => f n a) _)\n    exact <a>le_iSup_of_le</a> (<a>encode</a> b + 1) (h_directed.le_sequence b a)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "iSup_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [764, 9], "def_end_pos": [764, 16]}, {"full_name": "iSup_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [764, 9], "def_end_pos": [764, 16]}, {"full_name": "le_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [706, 9], "def_end_pos": [706, 16]}, {"full_name": "le_iSup_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [738, 9], "def_end_pos": [738, 22]}, {"full_name": "Encodable.encode", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Encodable/Basic.lean", "def_pos": [47, 3], "def_end_pos": [47, 9]}]], "state_before": "case intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc", "state_after": "case intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\nthis : \u2200 (a : \u03b1), \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc"}, {"tactic": "simp [iSup_of_empty]", "annotated_tactic": ["simp [<a>iSup_of_empty</a>]", [{"full_name": "iSup_of_empty", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1477, 9], "def_end_pos": [1477, 22]}]], "state_before": "case intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : IsEmpty \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc", "state_after": "no goals"}, {"tactic": "intro a", "annotated_tactic": ["intro a", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\n\u22a2 \u2200 (a : \u03b1), \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\na : \u03b1\n\u22a2 \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a"}, {"tactic": "refine' le_antisymm (iSup_le fun b => _) (iSup_le fun n => le_iSup (fun n => f n a) _)", "annotated_tactic": ["refine' <a>le_antisymm</a> (<a>iSup_le</a> fun b => _) (<a>iSup_le</a> fun n => <a>le_iSup</a> (fun n => f n a) _)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "iSup_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [764, 9], "def_end_pos": [764, 16]}, {"full_name": "iSup_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [764, 9], "def_end_pos": [764, 16]}, {"full_name": "le_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [706, 9], "def_end_pos": [706, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\na : \u03b1\n\u22a2 \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 f b a \u2264 \u2a06 n, f (Directed.sequence f h_directed n) a"}, {"tactic": "exact le_iSup_of_le (encode b + 1) (h_directed.le_sequence b a)", "annotated_tactic": ["exact <a>le_iSup_of_le</a> (<a>encode</a> b + 1) (h_directed.le_sequence b a)", [{"full_name": "le_iSup_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [738, 9], "def_end_pos": [738, 22]}, {"full_name": "Encodable.encode", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Encodable/Basic.lean", "def_pos": [47, 3], "def_end_pos": [47, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 f b a \u2264 \u2a06 n, f (Directed.sequence f h_directed n) a", "state_after": "no goals"}, {"tactic": "simp only [this]", "annotated_tactic": ["simp only [this]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\nthis : \u2200 (a : \u03b1), \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a\n\u22a2 \u222b\u207b (a : \u03b1), \u2a06 b, f b a \u2202\u03bc = \u222b\u207b (a : \u03b1), \u2a06 n, f (Directed.sequence f h_directed n) a \u2202\u03bc", "state_after": "no goals"}, {"tactic": "refine' le_antisymm (iSup_le fun n => _) (iSup_le fun b => _)", "annotated_tactic": ["refine' <a>le_antisymm</a> (<a>iSup_le</a> fun n => _) (<a>iSup_le</a> fun b => _)", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "iSup_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [764, 9], "def_end_pos": [764, 16]}, {"full_name": "iSup_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [764, 9], "def_end_pos": [764, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\nthis : \u2200 (a : \u03b1), \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a\n\u22a2 \u2a06 n, \u222b\u207b (a : \u03b1), f (Directed.sequence f h_directed n) a \u2202\u03bc = \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\nthis : \u2200 (a : \u03b1), \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a\nn : \u2115\n\u22a2 \u222b\u207b (a : \u03b1), f (Directed.sequence f h_directed n) a \u2202\u03bc \u2264 \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc\n\ncase refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\nthis : \u2200 (a : \u03b1), \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a\nb : \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), f b a \u2202\u03bc \u2264 \u2a06 n, \u222b\u207b (a : \u03b1), f (Directed.sequence f h_directed n) a \u2202\u03bc"}, {"tactic": "exact le_iSup (fun b => \u222b\u207b a, f b a \u2202\u03bc) _", "annotated_tactic": ["exact <a>le_iSup</a> (fun b => \u222b\u207b a, f b a \u2202\u03bc) _", [{"full_name": "le_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [706, 9], "def_end_pos": [706, 16]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\nthis : \u2200 (a : \u03b1), \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a\nn : \u2115\n\u22a2 \u222b\u207b (a : \u03b1), f (Directed.sequence f h_directed n) a \u2202\u03bc \u2264 \u2a06 b, \u222b\u207b (a : \u03b1), f b a \u2202\u03bc", "state_after": "no goals"}, {"tactic": "exact le_iSup_of_le (encode b + 1) (lintegral_mono <| h_directed.le_sequence b)", "annotated_tactic": ["exact <a>le_iSup_of_le</a> (<a>encode</a> b + 1) (<a>lintegral_mono</a> <| h_directed.le_sequence b)", [{"full_name": "le_iSup_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [738, 9], "def_end_pos": [738, 22]}, {"full_name": "Encodable.encode", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Encodable/Basic.lean", "def_pos": [47, 3], "def_end_pos": [47, 9]}, {"full_name": "MeasureTheory.lintegral_mono", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [101, 9], "def_end_pos": [101, 23]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : Countable \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2200 (b : \u03b2), Measurable (f b)\nh_directed : Directed (fun x x_1 => x \u2264 x_1) f\nval\u271d : Encodable \u03b2\nh\u271d : Nonempty \u03b2\ninhabited_h : Inhabited \u03b2\nthis : \u2200 (a : \u03b1), \u2a06 b, f b a = \u2a06 n, f (Directed.sequence f h_directed n) a\nb : \u03b2\n\u22a2 \u222b\u207b (a : \u03b1), f b a \u2202\u03bc \u2264 \u2a06 n, \u222b\u207b (a : \u03b1), f (Directed.sequence f h_directed n) a \u2202\u03bc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Order.lean", "full_name": "Finsupp.single_le_iff", "start": [226, 1], "end": [227, 55], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : CanonicallyOrderedAddCommMonoid \u03b1\nf\u271d g : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\nx : \u03b1\nf : \u03b9 \u2192\u2080 \u03b1\n\u22a2 (\u2200 i_1 \u2208 {i}, (single i x) i_1 \u2264 f i_1) \u2194 x \u2264 f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Positivity/Basic.lean", "full_name": "Mathlib.Meta.Positivity.abs_pos_of_ne_zero", "start": [305, 9], "end": [306, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Nodup.lean", "full_name": "List.nodup_iff_injective_get", "start": [92, 1], "end": [101, 74], "traced_tactics": [{"tactic": "cases' i with i hi", "annotated_tactic": ["cases' i with i hi", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\ni j : Fin (length l)\nhg : get l i = get l j\n\u22a2 i = j", "state_after": "case mk\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\nj : Fin (length l)\ni : \u2115\nhi : i < length l\nhg : get l { val := i, isLt := hi } = get l j\n\u22a2 { val := i, isLt := hi } = j"}, {"tactic": "cases' j with j hj", "annotated_tactic": ["cases' j with j hj", []], "state_before": "case mk\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\nj : Fin (length l)\ni : \u2115\nhi : i < length l\nhg : get l { val := i, isLt := hi } = get l j\n\u22a2 { val := i, isLt := hi } = j", "state_after": "case mk.mk\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\ni : \u2115\nhi : i < length l\nj : \u2115\nhj : j < length l\nhg : get l { val := i, isLt := hi } = get l { val := j, isLt := hj }\n\u22a2 { val := i, isLt := hi } = { val := j, isLt := hj }"}, {"tactic": "rcases lt_trichotomy i j with (hij | rfl | hji)", "annotated_tactic": ["rcases <a>lt_trichotomy</a> i j with (hij | rfl | hji)", [{"full_name": "lt_trichotomy", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [305, 9], "def_end_pos": [305, 22]}]], "state_before": "case mk.mk\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\ni : \u2115\nhi : i < length l\nj : \u2115\nhj : j < length l\nhg : get l { val := i, isLt := hi } = get l { val := j, isLt := hj }\n\u22a2 { val := i, isLt := hi } = { val := j, isLt := hj }", "state_after": "case mk.mk.inl\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\ni : \u2115\nhi : i < length l\nj : \u2115\nhj : j < length l\nhg : get l { val := i, isLt := hi } = get l { val := j, isLt := hj }\nhij : i < j\n\u22a2 { val := i, isLt := hi } = { val := j, isLt := hj }\n\ncase mk.mk.inr.inl\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\ni : \u2115\nhi hj : i < length l\nhg : get l { val := i, isLt := hi } = get l { val := i, isLt := hj }\n\u22a2 { val := i, isLt := hi } = { val := i, isLt := hj }\n\ncase mk.mk.inr.inr\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\ni : \u2115\nhi : i < length l\nj : \u2115\nhj : j < length l\nhg : get l { val := i, isLt := hi } = get l { val := j, isLt := hj }\nhji : j < i\n\u22a2 { val := i, isLt := hi } = { val := j, isLt := hj }"}, {"tactic": "exact (h \u27e8i, hi\u27e9 \u27e8j, hj\u27e9 hij hg).elim", "annotated_tactic": ["exact (h \u27e8i, hi\u27e9 \u27e8j, hj\u27e9 hij hg).<a>elim</a>", [{"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}]], "state_before": "case mk.mk.inl\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\ni : \u2115\nhi : i < length l\nj : \u2115\nhj : j < length l\nhg : get l { val := i, isLt := hi } = get l { val := j, isLt := hj }\nhij : i < j\n\u22a2 { val := i, isLt := hi } = { val := j, isLt := hj }", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk.mk.inr.inl\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\ni : \u2115\nhi hj : i < length l\nhg : get l { val := i, isLt := hi } = get l { val := i, isLt := hj }\n\u22a2 { val := i, isLt := hi } = { val := i, isLt := hj }", "state_after": "no goals"}, {"tactic": "exact (h \u27e8j, hj\u27e9 \u27e8i, hi\u27e9 hji hg.symm).elim", "annotated_tactic": ["exact (h \u27e8j, hj\u27e9 \u27e8i, hi\u27e9 hji hg.symm).<a>elim</a>", [{"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}]], "state_before": "case mk.mk.inr.inr\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\nh : \u2200 (i j : Fin (length l)), i < j \u2192 get l i \u2260 get l j\ni : \u2115\nhi : i < length l\nj : \u2115\nhj : j < length l\nhg : get l { val := i, isLt := hi } = get l { val := j, isLt := hj }\nhji : j < i\n\u22a2 { val := i, isLt := hi } = { val := j, isLt := hj }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Coset.lean", "full_name": "mem_leftCoset", "start": [62, 1], "end": [63, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Monoid.lean", "full_name": "Submonoid.top_closure_mul_self_subset", "start": [445, 1], "end": [448, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factors.lean", "full_name": "Nat.eq_two_pow_or_exists_odd_prime_and_dvd", "start": [299, 1], "end": [305, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.characteristic_iff_map_eq", "start": [2028, 1], "end": [2030, 85], "traced_tactics": [{"tactic": "simp_rw [map_equiv_eq_comap_symm']", "annotated_tactic": ["simp_rw [<a>map_equiv_eq_comap_symm'</a>]", [{"full_name": "Subgroup.map_equiv_eq_comap_symm'", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1466, 9], "def_end_pos": [1466, 33]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Group G'\ninst\u271d\u00b9 : Group G''\nA : Type u_4\ninst\u271d : AddGroup A\nH K : Subgroup G\n\u22a2 Characteristic H \u2194 \u2200 (\u03d5 : G \u2243* G), map (MulEquiv.toMonoidHom \u03d5) H = H", "state_after": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Group G'\ninst\u271d\u00b9 : Group G''\nA : Type u_4\ninst\u271d : AddGroup A\nH K : Subgroup G\n\u22a2 Characteristic H \u2194 \u2200 (\u03d5 : G \u2243* G), comap (MulEquiv.toMonoidHom (MulEquiv.symm \u03d5)) H = H"}, {"tactic": "exact characteristic_iff_comap_eq.trans \u27e8fun h \u03d5 => h \u03d5.symm, fun h \u03d5 => h \u03d5.symm\u27e9", "annotated_tactic": ["exact characteristic_iff_comap_eq.trans \u27e8fun h \u03d5 => h \u03d5.symm, fun h \u03d5 => h \u03d5.symm\u27e9", []], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Group G'\ninst\u271d\u00b9 : Group G''\nA : Type u_4\ninst\u271d : AddGroup A\nH K : Subgroup G\n\u22a2 Characteristic H \u2194 \u2200 (\u03d5 : G \u2243* G), comap (MulEquiv.toMonoidHom (MulEquiv.symm \u03d5)) H = H", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/Over.lean", "full_name": "CategoryTheory.Under.comp_right", "start": [375, 1], "end": [376, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Basic.lean", "full_name": "AddMonoidHom.coe_mulLeft", "start": [73, 1], "end": [75, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Tower.lean", "full_name": "AlgHom.map_algebraMap", "start": [162, 1], "end": [164, 70], "traced_tactics": [{"tactic": "rw [algebraMap_apply R S A r, f.commutes, \u2190 algebraMap_apply R S B]", "annotated_tactic": ["rw [<a>algebraMap_apply</a> R S A r, f.commutes, \u2190 <a>algebraMap_apply</a> R S B]", [{"full_name": "IsScalarTower.algebraMap_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Tower.lean", "def_pos": [130, 9], "def_end_pos": [130, 25]}, {"full_name": "IsScalarTower.algebraMap_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Tower.lean", "def_pos": [130, 9], "def_end_pos": [130, 25]}]], "state_before": "R : Type u\nS : Type v\nA : Type w\nB : Type u\u2081\nM : Type v\u2081\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : CommSemiring S\ninst\u271d\u2078 : Semiring A\ninst\u271d\u2077 : Semiring B\ninst\u271d\u2076 : Algebra R S\ninst\u271d\u2075 : Algebra S A\ninst\u271d\u2074 : Algebra S B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : IsScalarTower R S A\ninst\u271d : IsScalarTower R S B\nf : A \u2192\u2090[S] B\nr : R\n\u22a2 f ((algebraMap R A) r) = (algebraMap R B) r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/Pointwise.lean", "full_name": "Set.star_empty", "start": [42, 1], "end": [42, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "DifferentiableWithinAt.inverse", "start": [901, 1], "end": [903, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/PartENat.lean", "full_name": "PartENat.ne_top_iff", "start": [401, 1], "end": [402, 56], "traced_tactics": [{"tactic": "simpa only [\u2190 some_eq_natCast] using Part.ne_none_iff", "annotated_tactic": ["simpa only [\u2190 <a>some_eq_natCast</a>] using <a>Part.ne_none_iff</a>", [{"full_name": "PartENat.some_eq_natCast", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [108, 9], "def_end_pos": [108, 24]}, {"full_name": "Part.ne_none_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [202, 9], "def_end_pos": [202, 20]}]], "state_before": "x : PartENat\n\u22a2 x \u2260 \u22a4 \u2194 \u2203 n, x = \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_atBot_pure", "start": [339, 1], "end": [341, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.not_any_eq_all_not", "start": [1045, 1], "end": [1046, 62], "traced_tactics": [{"tactic": "induction l with simp | cons _ _ ih => rw [Bool.not_or, ih]", "annotated_tactic": ["induction l with simp | <a>cons</a> _ _ ih => rw [<a>Bool.not_or</a>, ih]", [{"full_name": "List.cons", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2271, 5], "def_end_pos": [2271, 9]}, {"full_name": "Bool.not_or", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Bool.lean", "def_pos": [105, 9], "def_end_pos": [105, 15]}]], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\np : \u03b1 \u2192 Bool\n\u22a2 (!any l p) = all l fun a => !p a", "state_after": "no goals"}, {"tactic": "rw [Bool.not_or, ih]", "annotated_tactic": ["rw [<a>Bool.not_or</a>, ih]", [{"full_name": "Bool.not_or", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Bool.lean", "def_pos": [105, 9], "def_end_pos": [105, 15]}]], "state_before": "case cons\n\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nih : (!any tail\u271d p) = all tail\u271d fun a => !p a\n\u22a2 (!(p head\u271d || any tail\u271d p)) = (!p head\u271d && all tail\u271d fun a => !p a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Defs.lean", "full_name": "inv_smul_lt_iff_of_neg", "start": [1022, 1], "end": [1023, 61], "traced_tactics": [{"tactic": "rw [\u2190 smul_lt_smul_iff_of_neg_left h, smul_inv_smul\u2080 h.ne]", "annotated_tactic": ["rw [\u2190 <a>smul_lt_smul_iff_of_neg_left</a> h, <a>smul_inv_smul\u2080</a> h.ne]", [{"full_name": "smul_lt_smul_iff_of_neg_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Module/Defs.lean", "def_pos": [875, 7], "def_end_pos": [875, 35]}, {"full_name": "smul_inv_smul\u2080", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [219, 9], "def_end_pos": [219, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u00b3 : LinearOrderedField \u03b1\ninst\u271d\u00b2 : OrderedAddCommGroup \u03b2\ninst\u271d\u00b9 : Module \u03b1 \u03b2\na : \u03b1\nb\u2081 b\u2082 : \u03b2\ninst\u271d : PosSMulStrictMono \u03b1 \u03b2\nh : a < 0\n\u22a2 a\u207b\u00b9 \u2022 b\u2081 < b\u2082 \u2194 a \u2022 b\u2082 < b\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/Lemmas.lean", "full_name": "Std.RBSet.mem_congr", "start": [628, 1], "end": [629, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "full_name": "Filter.EventuallyEq.fderivWithin_eq_nhds", "start": [1047, 1], "end": [1049, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Order.lean", "full_name": "Finset.prod_sdiff_lt_prod_sdiff", "start": [559, 1], "end": [563, 57], "traced_tactics": [{"tactic": "rw [\u2190 mul_lt_mul_iff_right, \u2190 prod_union (disjoint_sdiff_inter _ _), sdiff_union_inter,\n  \u2190 prod_union, inter_comm, sdiff_union_inter]", "annotated_tactic": ["rw [\u2190 <a>mul_lt_mul_iff_right</a>, \u2190 <a>prod_union</a> (<a>disjoint_sdiff_inter</a> _ _), <a>sdiff_union_inter</a>,\n    \u2190 <a>prod_union</a>, <a>inter_comm</a>, <a>sdiff_union_inter</a>]", [{"full_name": "mul_lt_mul_iff_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [113, 9], "def_end_pos": [113, 29]}, {"full_name": "Finset.prod_union", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [422, 9], "def_end_pos": [422, 19]}, {"full_name": "Finset.disjoint_sdiff_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2466, 9], "def_end_pos": [2466, 29]}, {"full_name": "Finset.sdiff_union_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2235, 9], "def_end_pos": [2235, 26]}, {"full_name": "Finset.prod_union", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [422, 9], "def_end_pos": [422, 19]}, {"full_name": "Finset.inter_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1679, 9], "def_end_pos": [1679, 19]}, {"full_name": "Finset.sdiff_union_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2235, 9], "def_end_pos": [2235, 26]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nM : Type u_4\nN : Type u_5\nG : Type u_6\nk : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : OrderedCancelCommMonoid M\nf g : \u03b9 \u2192 M\ns t : Finset \u03b9\ninst\u271d : DecidableEq \u03b9\n\u22a2 \u220f i in s \\ t, f i < \u220f i in t \\ s, f i \u2194 \u220f i in s, f i < \u220f i in t, f i", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nM : Type u_4\nN : Type u_5\nG : Type u_6\nk : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : OrderedCancelCommMonoid M\nf g : \u03b9 \u2192 M\ns t : Finset \u03b9\ninst\u271d : DecidableEq \u03b9\n\u22a2 Disjoint (t \\ s) (s \u2229 t)"}, {"tactic": "simpa only [inter_comm] using disjoint_sdiff_inter t s", "annotated_tactic": ["simpa only [<a>inter_comm</a>] using <a>disjoint_sdiff_inter</a> t s", [{"full_name": "Finset.inter_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1679, 9], "def_end_pos": [1679, 19]}, {"full_name": "Finset.disjoint_sdiff_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2466, 9], "def_end_pos": [2466, 29]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nM : Type u_4\nN : Type u_5\nG : Type u_6\nk : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : OrderedCancelCommMonoid M\nf g : \u03b9 \u2192 M\ns t : Finset \u03b9\ninst\u271d : DecidableEq \u03b9\n\u22a2 Disjoint (t \\ s) (s \u2229 t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/LinearMap.lean", "full_name": "LinearMap.restrict_eq_codRestrict_domRestrict", "start": [202, 1], "end": [205, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Sigma.lean", "full_name": "Finset.univ_sigma_univ", "start": [44, 1], "end": [44, 101], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "full_name": "Equiv.Perm.IsCycle.cycleType", "start": [105, 1], "end": [107, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.foldr_zero", "start": [1438, 1], "end": [1439, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "full_name": "NonUnitalRingHom.map_srange", "start": [380, 1], "end": [381, 76], "traced_tactics": [{"tactic": "simpa only [srange_eq_map] using (\u22a4 : NonUnitalSubsemiring R).map_map g f", "annotated_tactic": ["simpa only [<a>srange_eq_map</a>] using (\u22a4 : <a>NonUnitalSubsemiring</a> R).<a>map_map</a> g f", [{"full_name": "NonUnitalRingHom.srange_eq_map", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "def_pos": [371, 9], "def_end_pos": [371, 22]}, {"full_name": "NonUnitalSubsemiring", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "def_pos": [94, 11], "def_end_pos": [94, 31]}, {"full_name": "NonUnitalSubsemiring.map_map", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "def_pos": [317, 9], "def_end_pos": [317, 16]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u2076 : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\ninst\u271d\u2075 : NonUnitalNonAssocSemiring S\ninst\u271d\u2074 : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b3 : FunLike F R S\ninst\u271d\u00b2 : NonUnitalRingHomClass F R S\ninst\u271d\u00b9 : FunLike G S T\ninst\u271d : NonUnitalRingHomClass G S T\nf\u271d : F\ng\u271d : G\ng : S \u2192\u2099+* T\nf : R \u2192\u2099+* S\n\u22a2 map g (srange f) = srange (comp g f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.image_preimage_eq_of_subset", "start": [781, 1], "end": [782, 98], "traced_tactics": [{"tactic": "rw [image_preimage_eq_range_inter, inter_eq_self_of_subset_right hs]", "annotated_tactic": ["rw [<a>image_preimage_eq_range_inter</a>, <a>inter_eq_self_of_subset_right</a> hs]", [{"full_name": "Set.image_preimage_eq_range_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [772, 9], "def_end_pos": [772, 38]}, {"full_name": "Set.inter_eq_self_of_subset_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [963, 9], "def_end_pos": [963, 38]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns\u271d t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhs : s \u2286 range f\n\u22a2 f '' (f \u207b\u00b9' s) = s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Algebra.inf_toSubsemiring", "start": [817, 1], "end": [819, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "Measurable.piecewise", "start": [336, 11], "end": [340, 31], "traced_tactics": [{"tactic": "intro t ht", "annotated_tactic": ["intro t ht", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns t u : Set \u03b1\nf g : \u03b1 \u2192 \u03b2\nm : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nx\u271d : DecidablePred fun x => x \u2208 s\nhs : MeasurableSet s\nhf : Measurable f\nhg : Measurable g\n\u22a2 Measurable (piecewise s f g)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns t\u271d u : Set \u03b1\nf g : \u03b1 \u2192 \u03b2\nm : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nx\u271d : DecidablePred fun x => x \u2208 s\nhs : MeasurableSet s\nhf : Measurable f\nhg : Measurable g\nt : Set \u03b2\nht : MeasurableSet t\n\u22a2 MeasurableSet (piecewise s f g \u207b\u00b9' t)"}, {"tactic": "rw [piecewise_preimage]", "annotated_tactic": ["rw [<a>piecewise_preimage</a>]", [{"full_name": "Set.piecewise_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [1540, 9], "def_end_pos": [1540, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns t\u271d u : Set \u03b1\nf g : \u03b1 \u2192 \u03b2\nm : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nx\u271d : DecidablePred fun x => x \u2208 s\nhs : MeasurableSet s\nhf : Measurable f\nhg : Measurable g\nt : Set \u03b2\nht : MeasurableSet t\n\u22a2 MeasurableSet (piecewise s f g \u207b\u00b9' t)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns t\u271d u : Set \u03b1\nf g : \u03b1 \u2192 \u03b2\nm : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nx\u271d : DecidablePred fun x => x \u2208 s\nhs : MeasurableSet s\nhf : Measurable f\nhg : Measurable g\nt : Set \u03b2\nht : MeasurableSet t\n\u22a2 MeasurableSet (Set.ite s (f \u207b\u00b9' t) (g \u207b\u00b9' t))"}, {"tactic": "exact hs.ite (hf ht) (hg ht)", "annotated_tactic": ["exact hs.ite (hf ht) (hg ht)", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns t\u271d u : Set \u03b1\nf g : \u03b1 \u2192 \u03b2\nm : MeasurableSpace \u03b1\nm\u03b2 : MeasurableSpace \u03b2\nx\u271d : DecidablePred fun x => x \u2208 s\nhs : MeasurableSet s\nhf : Measurable f\nhg : Measurable g\nt : Set \u03b2\nht : MeasurableSet t\n\u22a2 MeasurableSet (Set.ite s (f \u207b\u00b9' t) (g \u207b\u00b9' t))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearMap.projKerOfRightInverse_apply_idem", "start": [1558, 1], "end": [1562, 7], "traced_tactics": [{"tactic": "ext1", "annotated_tactic": ["ext1", []], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2075 : Ring R\nR\u2082 : Type u_2\ninst\u271d\u00b9\u2074 : Ring R\u2082\nR\u2083 : Type u_3\ninst\u271d\u00b9\u00b3 : Ring R\u2083\nM : Type u_4\ninst\u271d\u00b9\u00b2 : TopologicalSpace M\ninst\u271d\u00b9\u00b9 : AddCommGroup M\nM\u2082 : Type u_5\ninst\u271d\u00b9\u2070 : TopologicalSpace M\u2082\ninst\u271d\u2079 : AddCommGroup M\u2082\nM\u2083 : Type u_6\ninst\u271d\u2078 : TopologicalSpace M\u2083\ninst\u271d\u2077 : AddCommGroup M\u2083\nM\u2084 : Type u_7\ninst\u271d\u2076 : TopologicalSpace M\u2084\ninst\u271d\u2075 : AddCommGroup M\u2084\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R\u2082 M\u2082\ninst\u271d\u00b2 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d : TopologicalAddGroup M\nf\u2081 : M \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\nh : Function.RightInverse \u21d1f\u2082 \u21d1f\u2081\nx : \u21a5(LinearMap.ker f\u2081)\n\u22a2 (projKerOfRightInverse f\u2081 f\u2082 h) \u2191x = x", "state_after": "case a\nR : Type u_1\ninst\u271d\u00b9\u2075 : Ring R\nR\u2082 : Type u_2\ninst\u271d\u00b9\u2074 : Ring R\u2082\nR\u2083 : Type u_3\ninst\u271d\u00b9\u00b3 : Ring R\u2083\nM : Type u_4\ninst\u271d\u00b9\u00b2 : TopologicalSpace M\ninst\u271d\u00b9\u00b9 : AddCommGroup M\nM\u2082 : Type u_5\ninst\u271d\u00b9\u2070 : TopologicalSpace M\u2082\ninst\u271d\u2079 : AddCommGroup M\u2082\nM\u2083 : Type u_6\ninst\u271d\u2078 : TopologicalSpace M\u2083\ninst\u271d\u2077 : AddCommGroup M\u2083\nM\u2084 : Type u_7\ninst\u271d\u2076 : TopologicalSpace M\u2084\ninst\u271d\u2075 : AddCommGroup M\u2084\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R\u2082 M\u2082\ninst\u271d\u00b2 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d : TopologicalAddGroup M\nf\u2081 : M \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\nh : Function.RightInverse \u21d1f\u2082 \u21d1f\u2081\nx : \u21a5(LinearMap.ker f\u2081)\n\u22a2 \u2191((projKerOfRightInverse f\u2081 f\u2082 h) \u2191x) = \u2191x"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\nR : Type u_1\ninst\u271d\u00b9\u2075 : Ring R\nR\u2082 : Type u_2\ninst\u271d\u00b9\u2074 : Ring R\u2082\nR\u2083 : Type u_3\ninst\u271d\u00b9\u00b3 : Ring R\u2083\nM : Type u_4\ninst\u271d\u00b9\u00b2 : TopologicalSpace M\ninst\u271d\u00b9\u00b9 : AddCommGroup M\nM\u2082 : Type u_5\ninst\u271d\u00b9\u2070 : TopologicalSpace M\u2082\ninst\u271d\u2079 : AddCommGroup M\u2082\nM\u2083 : Type u_6\ninst\u271d\u2078 : TopologicalSpace M\u2083\ninst\u271d\u2077 : AddCommGroup M\u2083\nM\u2084 : Type u_7\ninst\u271d\u2076 : TopologicalSpace M\u2084\ninst\u271d\u2075 : AddCommGroup M\u2084\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R\u2082 M\u2082\ninst\u271d\u00b2 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d : TopologicalAddGroup M\nf\u2081 : M \u2192SL[\u03c3\u2081\u2082] M\u2082\nf\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\nh : Function.RightInverse \u21d1f\u2082 \u21d1f\u2081\nx : \u21a5(LinearMap.ker f\u2081)\n\u22a2 \u2191((projKerOfRightInverse f\u2081 f\u2082 h) \u2191x) = \u2191x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.le_measure_diff", "start": [250, 1], "end": [255, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Bicategory/Basic.lean", "full_name": "CategoryTheory.Bicategory.pentagon_inv_inv_hom_inv_inv", "start": [312, 1], "end": [315, 29], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "B : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf : a \u27f6 b\ng : b \u27f6 c\nh : c \u27f6 d\ni : d \u27f6 e\n\u22a2 inv ((\u03b1_ f g (h \u226b i)).inv \u226b (\u03b1_ (f \u226b g) h i).inv \u226b (\u03b1_ f g h).hom \u25b7 i) =\n    inv (f \u25c1 (\u03b1_ g h i).inv \u226b (\u03b1_ f (g \u226b h) i).inv)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.Measure.map_smul_nnreal", "start": [1229, 11], "end": [1231, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.image_subset_iff", "start": [480, 1], "end": [481, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "full_name": "MeasureTheory.ae_le_set", "start": [464, 1], "end": [467, 47], "traced_tactics": [{"tactic": "simp [ae_iff]", "annotated_tactic": ["simp [<a>ae_iff</a>]", [{"full_name": "MeasureTheory.ae_iff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [388, 9], "def_end_pos": [388, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns s\u2081 s\u2082 t : Set \u03b1\n\u22a2 (\u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 x \u2208 t) \u2194 \u2191\u2191\u03bc (s \\ t) = 0", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns s\u2081 s\u2082 t : Set \u03b1\n\u22a2 \u2191\u2191\u03bc {a | a \u2208 s \u2227 a \u2209 t} = 0 \u2194 \u2191\u2191\u03bc (s \\ t) = 0"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns s\u2081 s\u2082 t : Set \u03b1\n\u22a2 \u2191\u2191\u03bc {a | a \u2208 s \u2227 a \u2209 t} = 0 \u2194 \u2191\u2191\u03bc (s \\ t) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearMap.add_apply", "start": [721, 1], "end": [722, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "RingHom.rangeS_eq_map", "start": [531, 1], "end": [533, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : NonAssocSemiring R\nM : Submonoid R\ninst\u271d\u00b9 : NonAssocSemiring S\ninst\u271d : NonAssocSemiring T\ng : S \u2192+* T\nf\u271d f : R \u2192+* S\n\u22a2 rangeS f = Subsemiring.map f \u22a4", "state_after": "case h\nR : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : NonAssocSemiring R\nM : Submonoid R\ninst\u271d\u00b9 : NonAssocSemiring S\ninst\u271d : NonAssocSemiring T\ng : S \u2192+* T\nf\u271d f : R \u2192+* S\nx\u271d : S\n\u22a2 x\u271d \u2208 rangeS f \u2194 x\u271d \u2208 Subsemiring.map f \u22a4"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\nR : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : NonAssocSemiring R\nM : Submonoid R\ninst\u271d\u00b9 : NonAssocSemiring S\ninst\u271d : NonAssocSemiring T\ng : S \u2192+* T\nf\u271d f : R \u2192+* S\nx\u271d : S\n\u22a2 x\u271d \u2208 rangeS f \u2194 x\u271d \u2208 Subsemiring.map f \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "full_name": "Finset.centroid_map", "start": [878, 1], "end": [879, 65], "traced_tactics": [{"tactic": "simp [centroid_def, affineCombination_map, centroidWeights]", "annotated_tactic": ["simp [<a>centroid_def</a>, <a>affineCombination_map</a>, <a>centroidWeights</a>]", [{"full_name": "Finset.centroid_def", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [835, 9], "def_end_pos": [835, 21]}, {"full_name": "Finset.affineCombination_map", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [498, 9], "def_end_pos": [498, 30]}, {"full_name": "Finset.centroidWeights", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [778, 5], "def_end_pos": [778, 20]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : DivisionRing k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\ns : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\ne : \u03b9\u2082 \u21aa \u03b9\np : \u03b9 \u2192 P\n\u22a2 centroid k (map e s\u2082) p = centroid k s\u2082 (p \u2218 \u21d1e)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "Continuous.coinduced_le", "start": [405, 1], "end": [406, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "full_name": "affineIndependent_iff", "start": [488, 1], "end": [491, 80], "traced_tactics": [{"tactic": "simp [s.weightedVSub_eq_linear_combination hw]", "annotated_tactic": ["simp [s.weightedVSub_eq_linear_combination hw]", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9\u271d : Type u_4\ns\u271d : Finset \u03b9\u271d\nw\u271d w\u2081 w\u2082 : \u03b9\u271d \u2192 k\np\u271d : \u03b9\u271d \u2192 V\n\u03b9 : Type u_5\np : \u03b9 \u2192 V\ns : Finset \u03b9\nw : \u03b9 \u2192 k\nhw : \u2211 i in s, w i = 0\n\u22a2 ((weightedVSub s p) w = 0 \u2192 \u2200 i \u2208 s, w i = 0) \u2194 \u2211 e in s, w e \u2022 p e = 0 \u2192 \u2200 e \u2208 s, w e = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pointwise.lean", "full_name": "Filter.pure_smul_pure", "start": [1059, 1], "end": [1060, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.mul_subset_iff", "start": [483, 1], "end": [484, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.induction_on", "start": [366, 11], "end": [369, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Quotient.lean", "full_name": "Subgroup.quotientCentralizerEmbedding_apply", "start": [395, 1], "end": [397, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Charpoly/Minpoly.lean", "full_name": "LinearMap.minpoly_toMatrix'", "start": [61, 1], "end": [62, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.not_mem_compl_iff", "start": [1643, 1], "end": [1644, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Bits.lean", "full_name": "Nat.bitCasesOn_bit0", "start": [128, 1], "end": [130, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Strict.lean", "full_name": "Convex.strictConvex_of_isOpen", "start": [113, 11], "end": [115, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Ioo_subset_Ici_self", "start": [423, 1], "end": [424, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "odd_abs", "start": [505, 1], "end": [506, 58], "traced_tactics": [{"tactic": "cases' abs_choice a with h h <;> simp only [h, odd_neg]", "annotated_tactic": ["cases' <a>abs_choice</a> a with h h <;> simp only [h, <a>odd_neg</a>]", [{"full_name": "abs_choice", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [234, 3], "def_end_pos": [234, 14]}, {"full_name": "odd_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Parity.lean", "def_pos": [478, 9], "def_end_pos": [478, 16]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Ring \u03b1\na b : \u03b1\nn : \u2115\ninst\u271d : LinearOrder \u03b1\n\u22a2 Odd |a| \u2194 Odd a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Ico_filter_le_of_right_le", "start": [339, 1], "end": [341, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.iSup_le_sum", "start": [1003, 1], "end": [1004, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.reindexFinsetRange_self", "start": [525, 1], "end": [528, 6], "traced_tactics": [{"tactic": "rw [reindexFinsetRange, reindex_apply, reindexRange_apply]", "annotated_tactic": ["rw [<a>reindexFinsetRange</a>, <a>reindex_apply</a>, <a>reindexRange_apply</a>]", [{"full_name": "Basis.reindexFinsetRange", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [521, 5], "def_end_pos": [521, 23]}, {"full_name": "Basis.reindex_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [419, 9], "def_end_pos": [419, 22]}, {"full_name": "Basis.reindexRange_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [486, 9], "def_end_pos": [486, 27]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ne : \u03b9 \u2243 \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\ni : \u03b9\nh : optParam (b i \u2208 Finset.image (\u21d1b) Finset.univ) \u22ef\n\u22a2 (reindexFinsetRange b) { val := b i, property := h } = b i", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ne : \u03b9 \u2243 \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\ni : \u03b9\nh : optParam (b i \u2208 Finset.image (\u21d1b) Finset.univ) \u22ef\n\u22a2 \u2191((Equiv.subtypeEquiv (Equiv.refl M) \u22ef).symm { val := b i, property := h }) = b i"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : AddCommMonoid M'\ninst\u271d\u00b2 : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ne : \u03b9 \u2243 \u03b9'\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq M\ni : \u03b9\nh : optParam (b i \u2208 Finset.image (\u21d1b) Finset.univ) \u22ef\n\u22a2 \u2191((Equiv.subtypeEquiv (Equiv.refl M) \u22ef).symm { val := b i, property := h }) = b i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/NNNorm.lean", "full_name": "ContinuousLinearMap.nnnorm_def", "start": [49, 1], "end": [53, 17], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2078 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : NormedSpace \ud835\udd5c E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2077 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2075 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b2 : FunLike \ud835\udcd5 E F\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2081\u2082\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083\nf\u271d g : E \u2192SL[\u03c3\u2081\u2082] F\nh : F \u2192SL[\u03c3\u2082\u2083] G\nx : E\nf : E \u2192SL[\u03c3\u2081\u2082] F\n\u22a2 \u2016f\u2016\u208a = sInf {c | \u2200 (x : E), \u2016f x\u2016\u208a \u2264 c * \u2016x\u2016\u208a}", "state_after": "case a\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2078 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : NormedSpace \ud835\udd5c E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2077 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2075 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b2 : FunLike \ud835\udcd5 E F\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2081\u2082\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083\nf\u271d g : E \u2192SL[\u03c3\u2081\u2082] F\nh : F \u2192SL[\u03c3\u2082\u2083] G\nx : E\nf : E \u2192SL[\u03c3\u2081\u2082] F\n\u22a2 \u2191\u2016f\u2016\u208a = \u2191(sInf {c | \u2200 (x : E), \u2016f x\u2016\u208a \u2264 c * \u2016x\u2016\u208a})"}, {"tactic": "rw [NNReal.coe_sInf, coe_nnnorm, norm_def, NNReal.coe_image]", "annotated_tactic": ["rw [<a>NNReal.coe_sInf</a>, <a>coe_nnnorm</a>, <a>norm_def</a>, <a>NNReal.coe_image</a>]", [{"full_name": "NNReal.coe_sInf", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [525, 9], "def_end_pos": [525, 17]}, {"full_name": "coe_nnnorm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [973, 41], "def_end_pos": [973, 51]}, {"full_name": "ContinuousLinearMap.norm_def", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean", "def_pos": [131, 9], "def_end_pos": [131, 17]}, {"full_name": "NNReal.coe_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [483, 9], "def_end_pos": [483, 18]}]], "state_before": "case a\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2078 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : NormedSpace \ud835\udd5c E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2077 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2075 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b2 : FunLike \ud835\udcd5 E F\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2081\u2082\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083\nf\u271d g : E \u2192SL[\u03c3\u2081\u2082] F\nh : F \u2192SL[\u03c3\u2082\u2083] G\nx : E\nf : E \u2192SL[\u03c3\u2081\u2082] F\n\u22a2 \u2191\u2016f\u2016\u208a = \u2191(sInf {c | \u2200 (x : E), \u2016f x\u2016\u208a \u2264 c * \u2016x\u2016\u208a})", "state_after": "case a\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2078 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : NormedSpace \ud835\udd5c E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2077 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2075 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b2 : FunLike \ud835\udcd5 E F\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2081\u2082\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083\nf\u271d g : E \u2192SL[\u03c3\u2081\u2082] F\nh : F \u2192SL[\u03c3\u2082\u2083] G\nx : E\nf : E \u2192SL[\u03c3\u2081\u2082] F\n\u22a2 sInf {c | 0 \u2264 c \u2227 \u2200 (x : E), \u2016f x\u2016 \u2264 c * \u2016x\u2016} =\n    sInf {x | \u2203 (h : 0 \u2264 x), { val := x, property := h } \u2208 {c | \u2200 (x : E), \u2016f x\u2016\u208a \u2264 c * \u2016x\u2016\u208a}}"}, {"tactic": "simp_rw [\u2190 NNReal.coe_le_coe, NNReal.coe_mul, coe_nnnorm, mem_setOf_eq, NNReal.coe_mk,\n  exists_prop]", "annotated_tactic": ["simp_rw [\u2190 <a>NNReal.coe_le_coe</a>, <a>NNReal.coe_mul</a>, <a>coe_nnnorm</a>, <a>mem_setOf_eq</a>, <a>NNReal.coe_mk</a>,\n    <a>exists_prop</a>]", [{"full_name": "NNReal.coe_le_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [371, 26], "def_end_pos": [371, 36]}, {"full_name": "NNReal.coe_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [184, 19], "def_end_pos": [184, 26]}, {"full_name": "coe_nnnorm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [973, 41], "def_end_pos": [973, 51]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}, {"full_name": "NNReal.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [137, 28], "def_end_pos": [137, 34]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}]], "state_before": "case a\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2078 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u2077 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u2076 : SeminormedAddCommGroup F\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup G\u2097\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : NormedSpace \ud835\udd5c E\ninst\u271d\u2078 : NormedSpace \ud835\udd5c E\u2097\ninst\u271d\u2077 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u2076 : NormedSpace \ud835\udd5c F\u2097\ninst\u271d\u2075 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u2074 : NormedSpace \ud835\udd5c G\u2097\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b2 : FunLike \ud835\udcd5 E F\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2081\u2082\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083\nf\u271d g : E \u2192SL[\u03c3\u2081\u2082] F\nh : F \u2192SL[\u03c3\u2082\u2083] G\nx : E\nf : E \u2192SL[\u03c3\u2081\u2082] F\n\u22a2 sInf {c | 0 \u2264 c \u2227 \u2200 (x : E), \u2016f x\u2016 \u2264 c * \u2016x\u2016} =\n    sInf {x | \u2203 (h : 0 \u2264 x), { val := x, property := h } \u2208 {c | \u2200 (x : E), \u2016f x\u2016\u208a \u2264 c * \u2016x\u2016\u208a}}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/IsPrimePow.lean", "full_name": "IsPrimePow.ne_one", "start": [70, 1], "end": [71, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "Valuation.map_pow", "start": [208, 1], "end": [209, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.exp_nsmul", "start": [839, 1], "end": [840, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsCoprime.mul_add_right_right_iff", "start": [391, 1], "end": [392, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Thickening.lean", "full_name": "Metric.eventually_not_mem_cthickening_of_infEdist_pos", "start": [188, 1], "end": [195, 57], "traced_tactics": [{"tactic": "obtain \u27e8\u03b5, \u27e8\u03b5_pos, \u03b5_lt\u27e9\u27e9 := exists_real_pos_lt_infEdist_of_not_mem_closure h", "annotated_tactic": ["obtain \u27e8\u03b5, \u27e8\u03b5_pos, \u03b5_lt\u27e9\u27e9 := <a>exists_real_pos_lt_infEdist_of_not_mem_closure</a> h", [{"full_name": "EMetric.exists_real_pos_lt_infEdist_of_not_mem_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "def_pos": [193, 9], "def_end_pos": [193, 55]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 \u03b5 : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\nE : Set \u03b1\nx : \u03b1\nh : x \u2209 closure E\n\u22a2 \u2200\u1da0 (\u03b4 : \u211d) in \ud835\udcdd 0, x \u2209 cthickening \u03b4 E", "state_after": "case intro.intro\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 \u03b5\u271d : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\nE : Set \u03b1\nx : \u03b1\nh : x \u2209 closure E\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\n\u03b5_lt : ENNReal.ofReal \u03b5 < infEdist x E\n\u22a2 \u2200\u1da0 (\u03b4 : \u211d) in \ud835\udcdd 0, x \u2209 cthickening \u03b4 E"}, {"tactic": "filter_upwards [eventually_lt_nhds \u03b5_pos] with \u03b4 h\u03b4", "annotated_tactic": ["filter_upwards [<a>eventually_lt_nhds</a> \u03b5_pos] with \u03b4 h\u03b4", [{"full_name": "eventually_lt_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/OrderClosed.lean", "def_pos": [462, 9], "def_end_pos": [462, 27]}]], "state_before": "case intro.intro\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4 \u03b5\u271d : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\nE : Set \u03b1\nx : \u03b1\nh : x \u2209 closure E\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\n\u03b5_lt : ENNReal.ofReal \u03b5 < infEdist x E\n\u22a2 \u2200\u1da0 (\u03b4 : \u211d) in \ud835\udcdd 0, x \u2209 cthickening \u03b4 E", "state_after": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5\u271d : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\nE : Set \u03b1\nx : \u03b1\nh : x \u2209 closure E\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\n\u03b5_lt : ENNReal.ofReal \u03b5 < infEdist x E\n\u03b4 : \u211d\nh\u03b4 : \u03b4 < \u03b5\n\u22a2 x \u2209 cthickening \u03b4 E"}, {"tactic": "simp only [cthickening, mem_setOf_eq, not_le]", "annotated_tactic": ["simp only [<a>cthickening</a>, <a>mem_setOf_eq</a>, <a>not_le</a>]", [{"full_name": "Metric.cthickening", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [179, 5], "def_end_pos": [179, 16]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}, {"full_name": "not_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [367, 9], "def_end_pos": [367, 15]}]], "state_before": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5\u271d : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\nE : Set \u03b1\nx : \u03b1\nh : x \u2209 closure E\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\n\u03b5_lt : ENNReal.ofReal \u03b5 < infEdist x E\n\u03b4 : \u211d\nh\u03b4 : \u03b4 < \u03b5\n\u22a2 x \u2209 cthickening \u03b4 E", "state_after": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5\u271d : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\nE : Set \u03b1\nx : \u03b1\nh : x \u2209 closure E\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\n\u03b5_lt : ENNReal.ofReal \u03b5 < infEdist x E\n\u03b4 : \u211d\nh\u03b4 : \u03b4 < \u03b5\n\u22a2 ENNReal.ofReal \u03b4 < infEdist x E"}, {"tactic": "exact ((ofReal_lt_ofReal_iff \u03b5_pos).mpr h\u03b4).trans \u03b5_lt", "annotated_tactic": ["exact ((<a>ofReal_lt_ofReal_iff</a> \u03b5_pos).<a>mpr</a> h\u03b4).<a>trans</a> \u03b5_lt", [{"full_name": "ENNReal.ofReal_lt_ofReal_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Real.lean", "def_pos": [206, 9], "def_end_pos": [206, 29]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}, {"full_name": "LT.lt.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [141, 7], "def_end_pos": [141, 18]}]], "state_before": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5\u271d : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\nE : Set \u03b1\nx : \u03b1\nh : x \u2209 closure E\n\u03b5 : \u211d\n\u03b5_pos : 0 < \u03b5\n\u03b5_lt : ENNReal.ofReal \u03b5 < infEdist x E\n\u03b4 : \u211d\nh\u03b4 : \u03b4 < \u03b5\n\u22a2 ENNReal.ofReal \u03b4 < infEdist x E", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.indexOf_le_length", "start": [1157, 1], "end": [1162, 41], "traced_tactics": [{"tactic": "induction' l with b l ih", "annotated_tactic": ["induction' l with b l ih", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\n\u22a2 indexOf a l \u2264 length l", "state_after": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 indexOf a [] \u2264 length []\n\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\n\u22a2 indexOf a (b :: l) \u2264 length (b :: l)"}, {"tactic": "simp only [length, indexOf_cons, cond_eq_if, beq_iff_eq]", "annotated_tactic": ["simp only [<a>length</a>, <a>indexOf_cons</a>, <a>cond_eq_if</a>, <a>beq_iff_eq</a>]", [{"full_name": "List.length", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2316, 5], "def_end_pos": [2316, 16]}, {"full_name": "List.indexOf_cons", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2364, 9], "def_end_pos": [2364, 21]}, {"full_name": "cond_eq_if", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Bool.lean", "def_pos": [237, 9], "def_end_pos": [237, 19]}, {"full_name": "beq_iff_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1314, 17], "def_end_pos": [1314, 27]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\n\u22a2 indexOf a (b :: l) \u2264 length (b :: l)", "state_after": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\n\u22a2 (if b = a then 0 else indexOf a l + 1) \u2264 length l + 1"}, {"tactic": "by_cases h : b = a", "annotated_tactic": ["by_cases h : b = a", []], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\n\u22a2 (if b = a then 0 else indexOf a l + 1) \u2264 length l + 1", "state_after": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\nh : b = a\n\u22a2 (if b = a then 0 else indexOf a l + 1) \u2264 length l + 1\n\ncase neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\nh : \u00acb = a\n\u22a2 (if b = a then 0 else indexOf a l + 1) \u2264 length l + 1"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 indexOf a [] \u2264 length []", "state_after": "no goals"}, {"tactic": "rw [if_pos h]", "annotated_tactic": ["rw [<a>if_pos</a> h]", [{"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}]], "state_before": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\nh : b = a\n\u22a2 (if b = a then 0 else indexOf a l + 1) \u2264 length l + 1", "state_after": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\nh : b = a\n\u22a2 0 \u2264 length l + 1"}, {"tactic": "exact Nat.zero_le _", "annotated_tactic": ["exact <a>Nat.zero_le</a> _", [{"full_name": "Nat.zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1644, 9], "def_end_pos": [1644, 20]}]], "state_before": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\nh : b = a\n\u22a2 0 \u2264 length l + 1", "state_after": "no goals"}, {"tactic": "rw [if_neg h]", "annotated_tactic": ["rw [<a>if_neg</a> h]", [{"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}]], "state_before": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\nh : \u00acb = a\n\u22a2 (if b = a then 0 else indexOf a l + 1) \u2264 length l + 1", "state_after": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\nh : \u00acb = a\n\u22a2 indexOf a l + 1 \u2264 length l + 1"}, {"tactic": "exact succ_le_succ ih", "annotated_tactic": ["exact <a>succ_le_succ</a> ih", [{"full_name": "Nat.succ_le_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1648, 9], "def_end_pos": [1648, 25]}]], "state_before": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nl : List \u03b1\nih : indexOf a l \u2264 length l\nh : \u00acb = a\n\u22a2 indexOf a l + 1 \u2264 length l + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Group/Abs.lean", "full_name": "abs_le", "start": [376, 1], "end": [376, 82], "traced_tactics": [{"tactic": "rw [abs_le', and_comm, @neg_le \u03b1]", "annotated_tactic": ["rw [<a>abs_le'</a>, <a>and_comm</a>, @<a>neg_le</a> \u03b1]", [{"full_name": "abs_le'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [69, 3], "def_end_pos": [69, 14]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}, {"full_name": "neg_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/OrderIso.lean", "def_pos": [48, 15], "def_end_pos": [48, 21]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\na b c d : \u03b1\n\u22a2 |a| \u2264 b \u2194 -b \u2264 a \u2227 a \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Operations.lean", "full_name": "Submonoid.coe_prod", "start": [773, 1], "end": [775, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dual.lean", "full_name": "LinearMap.dualMap_bijective_iff", "start": [1604, 1], "end": [1606, 88], "traced_tactics": [{"tactic": "simp_rw [Function.Bijective, dualMap_surjective_iff, dualMap_injective_iff, and_comm]", "annotated_tactic": ["simp_rw [<a>Function.Bijective</a>, <a>dualMap_surjective_iff</a>, <a>dualMap_injective_iff</a>, <a>and_comm</a>]", [{"full_name": "Function.Bijective", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [138, 5], "def_end_pos": [138, 14]}, {"full_name": "LinearMap.dualMap_surjective_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dual.lean", "def_pos": [1477, 9], "def_end_pos": [1477, 31]}, {"full_name": "LinearMap.dualMap_injective_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dual.lean", "def_pos": [1594, 9], "def_end_pos": [1594, 30]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}]], "state_before": "K : Type uK\ninst\u271d\u2074 : Field K\nV\u2081 : Type uV\u2081\nV\u2082 : Type uV\u2082\ninst\u271d\u00b3 : AddCommGroup V\u2081\ninst\u271d\u00b2 : Module K V\u2081\ninst\u271d\u00b9 : AddCommGroup V\u2082\ninst\u271d : Module K V\u2082\nf : V\u2081 \u2192\u2097[K] V\u2082\n\u22a2 Function.Bijective \u21d1(dualMap f) \u2194 Function.Bijective \u21d1f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Constructions.lean", "full_name": "MulOpposite.map_unop_nhds", "start": [77, 1], "end": [78, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "full_name": "setOf_isPreconnected_eq_of_ordered", "start": [505, 1], "end": [516, 47], "traced_tactics": [{"tactic": "refine' Subset.antisymm setOf_isPreconnected_subset_of_ordered _", "annotated_tactic": ["refine' <a>Subset.antisymm</a> <a>setOf_isPreconnected_subset_of_ordered</a> _", [{"full_name": "Set.Subset.antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [351, 9], "def_end_pos": [351, 24]}, {"full_name": "setOf_isPreconnected_subset_of_ordered", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "def_pos": [315, 9], "def_end_pos": [315, 47]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2077 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : OrderTopology \u03b1\ninst\u271d\u2074 : ConditionallyCompleteLinearOrder \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : OrderTopology \u03b2\ninst\u271d\u00b9 : Nonempty \u03b3\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\n\u22a2 {s | IsPreconnected s} =\n    range (uncurry Icc) \u222a range (uncurry Ico) \u222a range (uncurry Ioc) \u222a range (uncurry Ioo) \u222a\n      (range Ici \u222a range Ioi \u222a range Iic \u222a range Iio \u222a {univ, \u2205})", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2077 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : OrderTopology \u03b1\ninst\u271d\u2074 : ConditionallyCompleteLinearOrder \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : OrderTopology \u03b2\ninst\u271d\u00b9 : Nonempty \u03b3\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\n\u22a2 range (uncurry Icc) \u222a range (uncurry Ico) \u222a range (uncurry Ioc) \u222a range (uncurry Ioo) \u222a\n      (range Ici \u222a range Ioi \u222a range Iic \u222a range Iio \u222a {univ, \u2205}) \u2286\n    {s | IsPreconnected s}"}, {"tactic": "simp only [subset_def, forall_mem_range, uncurry, or_imp, forall_and, mem_union,\n  mem_setOf_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true_iff,\n  isPreconnected_Icc, isPreconnected_Ico, isPreconnected_Ioc, isPreconnected_Ioo,\n  isPreconnected_Ioi, isPreconnected_Iio, isPreconnected_Ici, isPreconnected_Iic,\n  isPreconnected_univ, isPreconnected_empty]", "annotated_tactic": ["simp only [<a>subset_def</a>, <a>forall_mem_range</a>, <a>uncurry</a>, <a>or_imp</a>, <a>forall_and</a>, <a>mem_union</a>,\n    <a>mem_setOf_eq</a>, <a>insert_eq</a>, <a>mem_singleton_iff</a>, <a>forall_eq</a>, <a>forall_true_iff</a>, <a>and_true_iff</a>,\n    <a>isPreconnected_Icc</a>, <a>isPreconnected_Ico</a>, <a>isPreconnected_Ioc</a>, <a>isPreconnected_Ioo</a>,\n    <a>isPreconnected_Ioi</a>, <a>isPreconnected_Iio</a>, <a>isPreconnected_Ici</a>, <a>isPreconnected_Iic</a>,\n    <a>isPreconnected_univ</a>, <a>isPreconnected_empty</a>]", [{"full_name": "Set.subset_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [326, 9], "def_end_pos": [326, 19]}, {"full_name": "Set.forall_mem_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [653, 9], "def_end_pos": [653, 25]}, {"full_name": "Function.uncurry", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [224, 5], "def_end_pos": [224, 12]}, {"full_name": "or_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 15]}, {"full_name": "forall_and", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [189, 9], "def_end_pos": [189, 19]}, {"full_name": "Set.mem_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 18]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}, {"full_name": "Set.insert_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1280, 9], "def_end_pos": [1280, 18]}, {"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}, {"full_name": "forall_eq", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [206, 17], "def_end_pos": [206, 26]}, {"full_name": "forall_true_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [707, 9], "def_end_pos": [707, 24]}, {"full_name": "and_true_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [138, 9], "def_end_pos": [138, 21]}, {"full_name": "isPreconnected_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "def_pos": [412, 9], "def_end_pos": [412, 27]}, {"full_name": "isPreconnected_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "def_pos": [461, 9], "def_end_pos": [461, 27]}, {"full_name": "isPreconnected_Ioc", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "def_pos": [457, 9], "def_end_pos": [457, 27]}, {"full_name": "isPreconnected_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "def_pos": [453, 9], "def_end_pos": [453, 27]}, {"full_name": "isPreconnected_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "def_pos": [449, 9], "def_end_pos": [449, 27]}, {"full_name": "isPreconnected_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "def_pos": [445, 9], "def_end_pos": [445, 27]}, {"full_name": "isPreconnected_Ici", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "def_pos": [437, 9], "def_end_pos": [437, 27]}, {"full_name": "isPreconnected_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "def_pos": [441, 9], "def_end_pos": [441, 27]}, {"full_name": "PreconnectedSpace.isPreconnected_univ", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/Basic.lean", "def_pos": [746, 3], "def_end_pos": [746, 22]}, {"full_name": "isPreconnected_empty", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Connected/Basic.lean", "def_pos": [78, 9], "def_end_pos": [78, 29]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2077 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : OrderTopology \u03b1\ninst\u271d\u2074 : ConditionallyCompleteLinearOrder \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : OrderTopology \u03b2\ninst\u271d\u00b9 : Nonempty \u03b3\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\n\u22a2 range (uncurry Icc) \u222a range (uncurry Ico) \u222a range (uncurry Ioc) \u222a range (uncurry Ioo) \u222a\n      (range Ici \u222a range Ioi \u222a range Iic \u222a range Iio \u222a {univ, \u2205}) \u2286\n    {s | IsPreconnected s}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Parity.lean", "full_name": "Int.two_not_dvd_two_mul_add_one", "start": [121, 1], "end": [122, 18], "traced_tactics": [{"tactic": "simp [add_emod]", "annotated_tactic": ["simp [<a>add_emod</a>]", [{"full_name": "Int.add_emod", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean", "def_pos": [181, 9], "def_end_pos": [181, 17]}]], "state_before": "m n\u271d n : \u2124\n\u22a2 \u00ac2 \u2223 2 * n + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/UniformGroup.lean", "full_name": "Subgroup.tendsto_coe_cofinite_of_discrete", "start": [610, 1], "end": [613, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "Real.dist_le_of_mem_pi_Icc", "start": [2048, 1], "end": [2052, 46], "traced_tactics": [{"tactic": "refine' (dist_pi_le_iff dist_nonneg).2 fun b =>\n  (Real.dist_le_of_mem_uIcc _ _).trans (dist_le_pi_dist x' y' b) <;> refine' Icc_subset_uIcc _", "annotated_tactic": ["refine' (<a>dist_pi_le_iff</a> <a>dist_nonneg</a>).2 fun b =>\n    (<a>Real.dist_le_of_mem_uIcc</a> _ _).<a>trans</a> (<a>dist_le_pi_dist</a> x' y' b) <;> refine' <a>Icc_subset_uIcc</a> _", [{"full_name": "dist_pi_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1938, 9], "def_end_pos": [1938, 23]}, {"full_name": "dist_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [261, 9], "def_end_pos": [261, 20]}, {"full_name": "Real.dist_le_of_mem_uIcc", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1366, 9], "def_end_pos": [1366, 33]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "dist_le_pi_dist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1982, 9], "def_end_pos": [1982, 24]}, {"full_name": "Set.Icc_subset_uIcc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "def_pos": [94, 7], "def_end_pos": [94, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nx y x' y' : \u03b2 \u2192 \u211d\nhx : x \u2208 Set.Icc x' y'\nhy : y \u2208 Set.Icc x' y'\n\u22a2 dist x y \u2264 dist x' y'", "state_after": "case refine'_1\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nx y x' y' : \u03b2 \u2192 \u211d\nhx : x \u2208 Set.Icc x' y'\nhy : y \u2208 Set.Icc x' y'\nb : \u03b2\n\u22a2 x b \u2208 Set.Icc (x' b) (y' b)\n\ncase refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nx y x' y' : \u03b2 \u2192 \u211d\nhx : x \u2208 Set.Icc x' y'\nhy : y \u2208 Set.Icc x' y'\nb : \u03b2\n\u22a2 y b \u2208 Set.Icc (x' b) (y' b)"}, {"tactic": "exacts [\u27e8hx.1 _, hx.2 _\u27e9, \u27e8hy.1 _, hy.2 _\u27e9]", "annotated_tactic": ["exacts [\u27e8hx.1 _, hx.2 _\u27e9, \u27e8hy.1 _, hy.2 _\u27e9]", []], "state_before": "case refine'_1\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nx y x' y' : \u03b2 \u2192 \u211d\nhx : x \u2208 Set.Icc x' y'\nhy : y \u2208 Set.Icc x' y'\nb : \u03b2\n\u22a2 x b \u2208 Set.Icc (x' b) (y' b)\n\ncase refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\n\u03c0 : \u03b2 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : (b : \u03b2) \u2192 PseudoMetricSpace (\u03c0 b)\nx y x' y' : \u03b2 \u2192 \u211d\nhx : x \u2208 Set.Icc x' y'\nhy : y \u2208 Set.Icc x' y'\nb : \u03b2\n\u22a2 y b \u2208 Set.Icc (x' b) (y' b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finsupp.lean", "full_name": "Finsupp.liftAddHom_symm_apply_apply", "start": [466, 1], "end": [468, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "specializes_eq_eq", "start": [561, 9], "end": [562, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.comap_sup", "start": [2416, 1], "end": [2417, 78], "traced_tactics": [{"tactic": "rw [sup_eq_iSup, comap_iSup, iSup_bool_eq, Bool.cond_true, Bool.cond_false]", "annotated_tactic": ["rw [<a>sup_eq_iSup</a>, <a>comap_iSup</a>, <a>iSup_bool_eq</a>, <a>Bool.cond_true</a>, <a>Bool.cond_false</a>]", [{"full_name": "sup_eq_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1493, 9], "def_end_pos": [1493, 20]}, {"full_name": "Filter.comap_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2408, 9], "def_end_pos": [2408, 19]}, {"full_name": "iSup_bool_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1485, 9], "def_end_pos": [1485, 21]}, {"full_name": "Bool.cond_true", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Bool/Lemmas.lean", "def_pos": [39, 15], "def_end_pos": [39, 24]}, {"full_name": "Bool.cond_false", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Bool/Lemmas.lean", "def_pos": [42, 15], "def_end_pos": [42, 25]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 comap m (g\u2081 \u2294 g\u2082) = comap m g\u2081 \u2294 comap m g\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/NormNum/DivMod.lean", "full_name": "Mathlib.Meta.NormNum.isInt_ediv_zero", "start": [25, 1], "end": [26, 55], "traced_tactics": [{"tactic": "simp [Int.ediv_zero]", "annotated_tactic": ["simp [<a>Int.ediv_zero</a>]", [{"full_name": "Int.ediv_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean", "def_pos": [31, 27], "def_end_pos": [31, 36]}]], "state_before": "n\u271d : \u2124\n\u22a2 \u2191n\u271d / \u21910 = \u21910", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.isCompl_principal", "start": [1020, 1], "end": [1022, 57], "traced_tactics": [{"tactic": "rw [inf_principal, inter_compl_self, principal_empty]", "annotated_tactic": ["rw [<a>inf_principal</a>, <a>inter_compl_self</a>, <a>principal_empty</a>]", [{"full_name": "Filter.inf_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [991, 9], "def_end_pos": [991, 22]}, {"full_name": "Set.inter_compl_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1648, 9], "def_end_pos": [1648, 25]}, {"full_name": "Filter.principal_empty", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [697, 9], "def_end_pos": [697, 24]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf g : Filter \u03b1\ns\u271d t s : Set \u03b1\n\u22a2 \ud835\udcdf s \u2293 \ud835\udcdf s\u1d9c = \u22a5", "state_after": "no goals"}, {"tactic": "rw [sup_principal, union_compl_self, principal_univ]", "annotated_tactic": ["rw [<a>sup_principal</a>, <a>union_compl_self</a>, <a>principal_univ</a>]", [{"full_name": "Filter.sup_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [998, 9], "def_end_pos": [998, 22]}, {"full_name": "Set.union_compl_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1720, 9], "def_end_pos": [1720, 25]}, {"full_name": "Filter.principal_univ", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [692, 17], "def_end_pos": [692, 31]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf g : Filter \u03b1\ns\u271d t s : Set \u03b1\n\u22a2 \ud835\udcdf s \u2294 \ud835\udcdf s\u1d9c = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Complex.sin_mul_I", "start": [513, 1], "end": [519, 29], "traced_tactics": [{"tactic": "have h : I * sin (x * I) = -sinh x := by\n  rw [mul_comm, \u2190 sinh_mul_I]\n  ring_nf\n  simp", "annotated_tactic": ["have h : <a>I</a> * <a>sin</a> (x * <a>I</a>) = -<a>sinh</a> x := by\n    rw [<a>mul_comm</a>, \u2190 <a>sinh_mul_I</a>]\n    ring_nf\n    simp", [{"full_name": "Complex.I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [299, 5], "def_end_pos": [299, 6]}, {"full_name": "Complex.sin", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [60, 5], "def_end_pos": [60, 8]}, {"full_name": "Complex.I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [299, 5], "def_end_pos": [299, 6]}, {"full_name": "Complex.sinh", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [78, 5], "def_end_pos": [78, 9]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Complex.sinh_mul_I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [493, 9], "def_end_pos": [493, 19]}]], "state_before": "x y : \u2102\n\u22a2 sin (x * I) = sinh x * I", "state_after": "x y : \u2102\nh : I * sin (x * I) = -sinh x\n\u22a2 sin (x * I) = sinh x * I"}, {"tactic": "rw [\u2190 neg_neg (sinh x), \u2190 h]", "annotated_tactic": ["rw [\u2190 <a>neg_neg</a> (<a>sinh</a> x), \u2190 h]", [{"full_name": "neg_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [810, 3], "def_end_pos": [810, 14]}, {"full_name": "Complex.sinh", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [78, 5], "def_end_pos": [78, 9]}]], "state_before": "x y : \u2102\nh : I * sin (x * I) = -sinh x\n\u22a2 sin (x * I) = sinh x * I", "state_after": "x y : \u2102\nh : I * sin (x * I) = -sinh x\n\u22a2 sin (x * I) = -(I * sin (x * I)) * I"}, {"tactic": "apply Complex.ext <;> simp", "annotated_tactic": ["apply <a>Complex.ext</a> <;> simp", [{"full_name": "Complex.ext", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 12]}]], "state_before": "x y : \u2102\nh : I * sin (x * I) = -sinh x\n\u22a2 sin (x * I) = -(I * sin (x * I)) * I", "state_after": "no goals"}, {"tactic": "rw [mul_comm, \u2190 sinh_mul_I]", "annotated_tactic": ["rw [<a>mul_comm</a>, \u2190 <a>sinh_mul_I</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "Complex.sinh_mul_I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [493, 9], "def_end_pos": [493, 19]}]], "state_before": "x y : \u2102\n\u22a2 I * sin (x * I) = -sinh x", "state_after": "x y : \u2102\n\u22a2 sinh (x * I * I) = -sinh x"}, {"tactic": "ring_nf", "annotated_tactic": ["ring_nf", []], "state_before": "x y : \u2102\n\u22a2 sinh (x * I * I) = -sinh x", "state_after": "x y : \u2102\n\u22a2 sinh (x * I ^ 2) = -sinh x"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "x y : \u2102\n\u22a2 sinh (x * I ^ 2) = -sinh x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Abelianization.lean", "full_name": "card_commutatorSet_closureCommutatorRepresentatives", "start": [309, 1], "end": [312, 67], "traced_tactics": [{"tactic": "rw [\u2190 image_commutatorSet_closureCommutatorRepresentatives G]", "annotated_tactic": ["rw [\u2190 <a>image_commutatorSet_closureCommutatorRepresentatives</a> G]", [{"full_name": "image_commutatorSet_closureCommutatorRepresentatives", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Abelianization.lean", "def_pos": [295, 9], "def_end_pos": [295, 61]}]], "state_before": "G : Type u\ninst\u271d : Group G\n\u22a2 Nat.card \u2191(commutatorSet \u21a5(closureCommutatorRepresentatives G)) = Nat.card \u2191(commutatorSet G)", "state_after": "G : Type u\ninst\u271d : Group G\n\u22a2 Nat.card \u2191(commutatorSet \u21a5(closureCommutatorRepresentatives G)) =\n    Nat.card\n      \u2191(\u21d1(Subgroup.subtype (closureCommutatorRepresentatives G)) '' commutatorSet \u21a5(closureCommutatorRepresentatives G))"}, {"tactic": "exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))", "annotated_tactic": ["exact <a>Nat.card_congr</a> (<a>Equiv.Set.image</a> _ _ (<a>subtype_injective</a> _))", [{"full_name": "Nat.card_congr", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Finite.lean", "def_pos": [81, 9], "def_end_pos": [81, 19]}, {"full_name": "Equiv.Set.image", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Set.lean", "def_pos": [488, 29], "def_end_pos": [488, 34]}, {"full_name": "Subgroup.subtype_injective", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [771, 9], "def_end_pos": [771, 26]}]], "state_before": "G : Type u\ninst\u271d : Group G\n\u22a2 Nat.card \u2191(commutatorSet \u21a5(closureCommutatorRepresentatives G)) =\n    Nat.card\n      \u2191(\u21d1(Subgroup.subtype (closureCommutatorRepresentatives G)) '' commutatorSet \u21a5(closureCommutatorRepresentatives G))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Rename.lean", "full_name": "MvPolynomial.eval\u2082_cast_comp", "start": [287, 1], "end": [291, 98], "traced_tactics": [{"tactic": "apply MvPolynomial.induction_on p (fun n => by simp only [eval\u2082_C, rename_C])\n  (fun p q hp hq => by simp only [hp, hq, rename, eval\u2082_add, AlgHom.map_add])\n  fun p n hp => by simp only [eval\u2082_mul, hp, eval\u2082_X, comp_apply, map_mul, rename_X, eval\u2082_mul]", "annotated_tactic": ["apply <a>MvPolynomial.induction_on</a> p (fun n => by simp only [<a>eval\u2082_C</a>, <a>rename_C</a>])\n    (fun p q hp hq => by simp only [hp, hq, <a>rename</a>, <a>eval\u2082_add</a>, <a>AlgHom.map_add</a>])\n    fun p n hp => by simp only [<a>eval\u2082_mul</a>, hp, <a>eval\u2082_X</a>, <a>comp_apply</a>, <a>map_mul</a>, <a>rename_X</a>, <a>eval\u2082_mul</a>]", [{"full_name": "MvPolynomial.induction_on", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [456, 9], "def_end_pos": [456, 21]}, {"full_name": "MvPolynomial.eval\u2082_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [992, 9], "def_end_pos": [992, 16]}, {"full_name": "MvPolynomial.rename_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Rename.lean", "def_pos": [61, 9], "def_end_pos": [61, 17]}, {"full_name": "MvPolynomial.rename", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Rename.lean", "def_pos": [56, 5], "def_end_pos": [56, 11]}, {"full_name": "MvPolynomial.eval\u2082_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [982, 9], "def_end_pos": [982, 18]}, {"full_name": "AlgHom.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [240, 19], "def_end_pos": [240, 26]}, {"full_name": "MvPolynomial.eval\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1029, 9], "def_end_pos": [1029, 18]}, {"full_name": "MvPolynomial.eval\u2082_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1002, 9], "def_end_pos": [1002, 16]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [308, 9], "def_end_pos": [308, 16]}, {"full_name": "MvPolynomial.rename_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Rename.lean", "def_pos": [67, 9], "def_end_pos": [67, 17]}, {"full_name": "MvPolynomial.eval\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1029, 9], "def_end_pos": [1029, 18]}]], "state_before": "\u03c3 : Type u_1\n\u03c4 : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : \u03c3 \u2192 \u03c4\nc : \u2124 \u2192+* R\ng : \u03c4 \u2192 R\np : MvPolynomial \u03c3 \u2124\n\u22a2 eval\u2082 c (g \u2218 f) p = eval\u2082 c g ((rename f) p)", "state_after": "no goals"}, {"tactic": "simp only [eval\u2082_C, rename_C]", "annotated_tactic": ["simp only [<a>eval\u2082_C</a>, <a>rename_C</a>]", [{"full_name": "MvPolynomial.eval\u2082_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [992, 9], "def_end_pos": [992, 16]}, {"full_name": "MvPolynomial.rename_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Rename.lean", "def_pos": [61, 9], "def_end_pos": [61, 17]}]], "state_before": "\u03c3 : Type u_1\n\u03c4 : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : \u03c3 \u2192 \u03c4\nc : \u2124 \u2192+* R\ng : \u03c4 \u2192 R\np : MvPolynomial \u03c3 \u2124\nn : \u2124\n\u22a2 eval\u2082 c (g \u2218 f) (C n) = eval\u2082 c g ((rename f) (C n))", "state_after": "no goals"}, {"tactic": "simp only [hp, hq, rename, eval\u2082_add, AlgHom.map_add]", "annotated_tactic": ["simp only [hp, hq, <a>rename</a>, <a>eval\u2082_add</a>, <a>AlgHom.map_add</a>]", [{"full_name": "MvPolynomial.rename", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Rename.lean", "def_pos": [56, 5], "def_end_pos": [56, 11]}, {"full_name": "MvPolynomial.eval\u2082_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [982, 9], "def_end_pos": [982, 18]}, {"full_name": "AlgHom.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [240, 19], "def_end_pos": [240, 26]}]], "state_before": "\u03c3 : Type u_1\n\u03c4 : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : \u03c3 \u2192 \u03c4\nc : \u2124 \u2192+* R\ng : \u03c4 \u2192 R\np\u271d p q : MvPolynomial \u03c3 \u2124\nhp : eval\u2082 c (g \u2218 f) p = eval\u2082 c g ((rename f) p)\nhq : eval\u2082 c (g \u2218 f) q = eval\u2082 c g ((rename f) q)\n\u22a2 eval\u2082 c (g \u2218 f) (p + q) = eval\u2082 c g ((rename f) (p + q))", "state_after": "no goals"}, {"tactic": "simp only [eval\u2082_mul, hp, eval\u2082_X, comp_apply, map_mul, rename_X, eval\u2082_mul]", "annotated_tactic": ["simp only [<a>eval\u2082_mul</a>, hp, <a>eval\u2082_X</a>, <a>comp_apply</a>, <a>map_mul</a>, <a>rename_X</a>, <a>eval\u2082_mul</a>]", [{"full_name": "MvPolynomial.eval\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1029, 9], "def_end_pos": [1029, 18]}, {"full_name": "MvPolynomial.eval\u2082_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1002, 9], "def_end_pos": [1002, 16]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [308, 9], "def_end_pos": [308, 16]}, {"full_name": "MvPolynomial.rename_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Rename.lean", "def_pos": [67, 9], "def_end_pos": [67, 17]}, {"full_name": "MvPolynomial.eval\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1029, 9], "def_end_pos": [1029, 18]}]], "state_before": "\u03c3 : Type u_1\n\u03c4 : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nf : \u03c3 \u2192 \u03c4\nc : \u2124 \u2192+* R\ng : \u03c4 \u2192 R\np\u271d p : MvPolynomial \u03c3 \u2124\nn : \u03c3\nhp : eval\u2082 c (g \u2218 f) p = eval\u2082 c g ((rename f) p)\n\u22a2 eval\u2082 c (g \u2218 f) (p * X n) = eval\u2082 c g ((rename f) (p * X n))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Circular.lean", "full_name": "Set.mem_cIoo", "start": [351, 1], "end": [352, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/CharP/ExpChar.lean", "full_name": "frobenius_def", "start": [293, 1], "end": [293, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Basic.lean", "full_name": "Complex.I_mul_I", "start": [317, 1], "end": [318, 23], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u22a2 (I * I).re = (-1).re \u2227 (I * I).im = (-1).im", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/LinearCombination.lean", "full_name": "Mathlib.Tactic.LinearCombination.c_sub_pf", "start": [43, 1], "end": [43, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "AntitoneOn.min", "start": [1219, 11], "end": [1221, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Function.Injective.map_atTop_finset_prod_eq", "start": [2050, 1], "end": [2065, 62], "traced_tactics": [{"tactic": "haveI := Classical.decEq \u03b2", "annotated_tactic": ["haveI := <a>Classical.decEq</a> \u03b2", [{"full_name": "Classical.decEq", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [979, 19], "def_end_pos": [979, 24]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\n\u22a2 Filter.map (fun s => \u220f i in s, f (g i)) atTop = Filter.map (fun s => \u220f i in s, f i) atTop", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\n\u22a2 Filter.map (fun s => \u220f i in s, f (g i)) atTop = Filter.map (fun s => \u220f i in s, f i) atTop"}, {"tactic": "apply le_antisymm <;> refine' map_atTop_finset_prod_le_of_prod_eq fun s => _", "annotated_tactic": ["apply <a>le_antisymm</a> <;> refine' <a>map_atTop_finset_prod_le_of_prod_eq</a> fun s => _", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Filter.map_atTop_finset_prod_le_of_prod_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [1842, 9], "def_end_pos": [1842, 44]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\n\u22a2 Filter.map (fun s => \u220f i in s, f (g i)) atTop = Filter.map (fun s => \u220f i in s, f i) atTop", "state_after": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\n\u22a2 \u2203 v, \u2200 (v' : Finset \u03b3), v \u2286 v' \u2192 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f x = \u220f b in v', f (g b)\n\ncase a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b3\n\u22a2 \u2203 v, \u2200 (v' : Finset \u03b2), v \u2286 v' \u2192 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f (g x) = \u220f b in v', f b"}, {"tactic": "refine' \u27e8s.preimage g (hg.injOn _), fun t ht => _\u27e9", "annotated_tactic": ["refine' \u27e8s.preimage g (hg.injOn _), fun t ht => _\u27e9", []], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\n\u22a2 \u2203 v, \u2200 (v' : Finset \u03b3), v \u2286 v' \u2192 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f x = \u220f b in v', f (g b)", "state_after": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f x = \u220f b in t, f (g b)"}, {"tactic": "refine' \u27e8t.image g \u222a s, Finset.subset_union_right _ _, _\u27e9", "annotated_tactic": ["refine' \u27e8t.image g \u222a s, <a>Finset.subset_union_right</a> _ _, _\u27e9", [{"full_name": "Finset.subset_union_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1445, 9], "def_end_pos": [1445, 27]}]], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f x = \u220f b in t, f (g b)", "state_after": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u220f x in Finset.image g t \u222a s, f x = \u220f b in t, f (g b)"}, {"tactic": "rw [\u2190 Finset.prod_image (hg.injOn _)]", "annotated_tactic": ["rw [\u2190 <a>Finset.prod_image</a> (hg.injOn _)]", [{"full_name": "Finset.prod_image", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [362, 9], "def_end_pos": [362, 19]}]], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u220f x in Finset.image g t \u222a s, f x = \u220f b in t, f (g b)", "state_after": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u220f x in Finset.image g t \u222a s, f x = \u220f x in Finset.image (fun x => g x) t, f x"}, {"tactic": "refine' (prod_subset (subset_union_left _ _) _).symm", "annotated_tactic": ["refine' (<a>prod_subset</a> (<a>subset_union_left</a> _ _) _).<a>symm</a>", [{"full_name": "Finset.prod_subset", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [556, 9], "def_end_pos": [556, 20]}, {"full_name": "Finset.subset_union_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1442, 9], "def_end_pos": [1442, 26]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u220f x in Finset.image g t \u222a s, f x = \u220f x in Finset.image (fun x => g x) t, f x", "state_after": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u2200 x \u2208 Finset.image g t \u222a s, x \u2209 Finset.image g t \u2192 f x = 1"}, {"tactic": "simp only [Finset.mem_union, Finset.mem_image]", "annotated_tactic": ["simp only [<a>Finset.mem_union</a>, <a>Finset.mem_image</a>]", [{"full_name": "Finset.mem_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1408, 9], "def_end_pos": [1408, 18]}, {"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}]], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u2200 x \u2208 Finset.image g t \u222a s, x \u2209 Finset.image g t \u2192 f x = 1", "state_after": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u2200 (x : \u03b2), (\u2203 a \u2208 t, g a = x) \u2228 x \u2208 s \u2192 (\u00ac\u2203 a \u2208 t, g a = x) \u2192 f x = 1"}, {"tactic": "refine' fun y hy hyt => hf y (mt _ hyt)", "annotated_tactic": ["refine' fun y hy hyt => hf y (<a>mt</a> _ hyt)", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}]], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\n\u22a2 \u2200 (x : \u03b2), (\u2203 a \u2208 t, g a = x) \u2228 x \u2208 s \u2192 (\u00ac\u2203 a \u2208 t, g a = x) \u2192 f x = 1", "state_after": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\ny : \u03b2\nhy : (\u2203 a \u2208 t, g a = y) \u2228 y \u2208 s\nhyt : \u00ac\u2203 a \u2208 t, g a = y\n\u22a2 y \u2208 Set.range g \u2192 \u2203 a \u2208 t, g a = y"}, {"tactic": "rintro \u27e8x, rfl\u27e9", "annotated_tactic": ["rintro \u27e8x, rfl\u27e9", []], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\ny : \u03b2\nhy : (\u2203 a \u2208 t, g a = y) \u2228 y \u2208 s\nhyt : \u00ac\u2203 a \u2208 t, g a = y\n\u22a2 y \u2208 Set.range g \u2192 \u2203 a \u2208 t, g a = y", "state_after": "case a.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\nx : \u03b3\nhy : (\u2203 a \u2208 t, g a = g x) \u2228 g x \u2208 s\nhyt : \u00ac\u2203 a \u2208 t, g a = g x\n\u22a2 \u2203 a \u2208 t, g a = g x"}, {"tactic": "exact \u27e8x, ht (Finset.mem_preimage.2 <| hy.resolve_left hyt), rfl\u27e9", "annotated_tactic": ["exact \u27e8x, ht (<a>Finset.mem_preimage</a>.2 <| hy.resolve_left hyt), <a>rfl</a>\u27e9", [{"full_name": "Finset.mem_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case a.intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b2\nt : Finset \u03b3\nht : Finset.preimage s g \u22ef \u2286 t\nx : \u03b3\nhy : (\u2203 a \u2208 t, g a = g x) \u2228 g x \u2208 s\nhyt : \u00ac\u2203 a \u2208 t, g a = g x\n\u22a2 \u2203 a \u2208 t, g a = g x", "state_after": "no goals"}, {"tactic": "refine' \u27e8s.image g, fun t ht => _\u27e9", "annotated_tactic": ["refine' \u27e8s.image g, fun t ht => _\u27e9", []], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b3\n\u22a2 \u2203 v, \u2200 (v' : Finset \u03b2), v \u2286 v' \u2192 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f (g x) = \u220f b in v', f b", "state_after": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b3\nt : Finset \u03b2\nht : Finset.image g s \u2286 t\n\u22a2 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f (g x) = \u220f b in t, f b"}, {"tactic": "simp only [\u2190 prod_preimage _ _ (hg.injOn _) _ fun x _ => hf x]", "annotated_tactic": ["simp only [\u2190 <a>prod_preimage</a> _ _ (hg.injOn _) _ fun x _ => hf x]", [{"full_name": "Finset.prod_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [155, 9], "def_end_pos": [155, 22]}]], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b3\nt : Finset \u03b2\nht : Finset.image g s \u2286 t\n\u22a2 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f (g x) = \u220f b in t, f b", "state_after": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b3\nt : Finset \u03b2\nht : Finset.image g s \u2286 t\n\u22a2 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f (g x) = \u220f x in Finset.preimage t g \u22ef, f (g x)"}, {"tactic": "exact \u27e8_, (image_subset_iff_subset_preimage _).1 ht, rfl\u27e9", "annotated_tactic": ["exact \u27e8_, (<a>image_subset_iff_subset_preimage</a> _).1 ht, <a>rfl</a>\u27e9", [{"full_name": "Finset.image_subset_iff_subset_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [89, 9], "def_end_pos": [89, 41]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case a\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b1\ng : \u03b3 \u2192 \u03b2\nhg : Injective g\nf : \u03b2 \u2192 \u03b1\nhf : \u2200 x \u2209 Set.range g, f x = 1\nthis : DecidableEq \u03b2\ns : Finset \u03b3\nt : Finset \u03b2\nht : Finset.image g s \u2286 t\n\u22a2 \u2203 u', s \u2286 u' \u2227 \u220f x in u', f (g x) = \u220f x in Finset.preimage t g \u22ef, f (g x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Iso.lean", "full_name": "CategoryTheory.Iso.cancel_iso_inv_right", "start": [550, 1], "end": [552, 26], "traced_tactics": [{"tactic": "simp only [cancel_mono]", "annotated_tactic": ["simp only [<a>cancel_mono</a>]", [{"full_name": "CategoryTheory.cancel_mono", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 20]}]], "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d Z\u271d X Y Z : C\nf f' : X \u27f6 Y\ng : Z \u2245 Y\n\u22a2 f \u226b g.inv = f' \u226b g.inv \u2194 f = f'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rel.lean", "full_name": "Rel.image_inter_dom_eq", "start": [281, 1], "end": [290, 10], "traced_tactics": [{"tactic": "apply Set.eq_of_subset_of_subset", "annotated_tactic": ["apply <a>Set.eq_of_subset_of_subset</a>", [{"full_name": "Set.eq_of_subset_of_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [360, 9], "def_end_pos": [360, 31]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\n\u22a2 image r (s \u2229 dom r) = image r s", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\n\u22a2 image r (s \u2229 dom r) \u2286 image r s\n\ncase a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\n\u22a2 image r s \u2286 image r (s \u2229 dom r)"}, {"tactic": "apply r.image_mono (by simp)", "annotated_tactic": ["apply r.image_mono (by simp)", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\n\u22a2 image r (s \u2229 dom r) \u2286 image r s", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\n\u22a2 s \u2229 dom r \u2264 s", "state_after": "no goals"}, {"tactic": "intro x h", "annotated_tactic": ["intro x h", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\n\u22a2 image r s \u2286 image r (s \u2229 dom r)", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\nh : x \u2208 image r s\n\u22a2 x \u2208 image r (s \u2229 dom r)"}, {"tactic": "rw [mem_image] at *", "annotated_tactic": ["rw [<a>mem_image</a>] at *", [{"full_name": "Rel.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rel.lean", "def_pos": [162, 9], "def_end_pos": [162, 18]}]], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\nh : x \u2208 image r s\n\u22a2 x \u2208 image r (s \u2229 dom r)", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\nh : \u2203 x_1 \u2208 s, r x_1 x\n\u22a2 \u2203 x_1 \u2208 s \u2229 dom r, r x_1 x"}, {"tactic": "rcases h with \u27e8y, hy, ryx\u27e9", "annotated_tactic": ["rcases h with \u27e8y, hy, ryx\u27e9", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\nh : \u2203 x_1 \u2208 s, r x_1 x\n\u22a2 \u2203 x_1 \u2208 s \u2229 dom r, r x_1 x", "state_after": "case a.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\ny : \u03b1\nhy : y \u2208 s\nryx : r y x\n\u22a2 \u2203 x_1 \u2208 s \u2229 dom r, r x_1 x"}, {"tactic": "use y", "annotated_tactic": ["use y", []], "state_before": "case a.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\ny : \u03b1\nhy : y \u2208 s\nryx : r y x\n\u22a2 \u2203 x_1 \u2208 s \u2229 dom r, r x_1 x", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\ny : \u03b1\nhy : y \u2208 s\nryx : r y x\n\u22a2 y \u2208 s \u2229 dom r \u2227 r y x"}, {"tactic": "suffices h : y \u2208 r.dom by simp_all only [Set.mem_inter_iff, and_self]", "annotated_tactic": ["suffices h : y \u2208 r.dom by simp_all only [<a>Set.mem_inter_iff</a>, <a>and_self</a>]", [{"full_name": "Set.mem_inter_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 22]}, {"full_name": "and_self", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [105, 17], "def_end_pos": [105, 25]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\ny : \u03b1\nhy : y \u2208 s\nryx : r y x\n\u22a2 y \u2208 s \u2229 dom r \u2227 r y x", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\ny : \u03b1\nhy : y \u2208 s\nryx : r y x\n\u22a2 y \u2208 dom r"}, {"tactic": "rw [dom, Set.mem_setOf_eq]", "annotated_tactic": ["rw [<a>dom</a>, <a>Set.mem_setOf_eq</a>]", [{"full_name": "Rel.dom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rel.lean", "def_pos": [71, 5], "def_end_pos": [71, 8]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\ny : \u03b1\nhy : y \u2208 s\nryx : r y x\n\u22a2 y \u2208 dom r", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\ny : \u03b1\nhy : y \u2208 s\nryx : r y x\n\u22a2 \u2203 y_1, r y y_1"}, {"tactic": "use x", "annotated_tactic": ["use x", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\ny : \u03b1\nhy : y \u2208 s\nryx : r y x\n\u22a2 \u2203 y_1, r y y_1", "state_after": "no goals"}, {"tactic": "simp_all only [Set.mem_inter_iff, and_self]", "annotated_tactic": ["simp_all only [<a>Set.mem_inter_iff</a>, <a>and_self</a>]", [{"full_name": "Set.mem_inter_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 22]}, {"full_name": "and_self", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [105, 17], "def_end_pos": [105, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\ny : \u03b1\nhy : y \u2208 s\nryx : r y x\nh : y \u2208 dom r\n\u22a2 y \u2208 s \u2229 dom r \u2227 r y x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "div_le_one_of_ge", "start": [780, 1], "end": [781, 94], "traced_tactics": [{"tactic": "simpa only [neg_div_neg_eq] using div_le_one_of_le (neg_le_neg h) (neg_nonneg_of_nonpos hb)", "annotated_tactic": ["simpa only [<a>neg_div_neg_eq</a>] using <a>div_le_one_of_le</a> (<a>neg_le_neg</a> h) (<a>neg_nonneg_of_nonpos</a> hb)", [{"full_name": "neg_div_neg_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Field/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 23]}, {"full_name": "div_le_one_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [243, 9], "def_end_pos": [243, 25]}, {"full_name": "neg_le_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [1196, 32], "def_end_pos": [1196, 42]}, {"full_name": "neg_nonneg_of_nonpos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [1224, 15], "def_end_pos": [1224, 35]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nh : b \u2264 a\nhb : b \u2264 0\n\u22a2 a / b \u2264 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/FixedPoints.lean", "full_name": "OrderHom.isFixedPt_lfp", "start": [82, 1], "end": [83, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Sqrt.lean", "full_name": "Real.sqrt_eq_zero", "start": [330, 1], "end": [330, 90], "traced_tactics": [{"tactic": "simpa using sqrt_inj h le_rfl", "annotated_tactic": ["simpa using <a>sqrt_inj</a> h <a>le_rfl</a>", [{"full_name": "Real.sqrt_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Sqrt.lean", "def_pos": [325, 9], "def_end_pos": [325, 17]}, {"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}]], "state_before": "x y : \u211d\nh : 0 \u2264 x\n\u22a2 sqrt x = 0 \u2194 x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.equivFun_ofEquivFun", "start": [973, 1], "end": [976, 62], "traced_tactics": [{"tactic": "ext j", "annotated_tactic": ["ext j", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : AddCommMonoid M'\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Finite \u03b9\ne : M \u2243\u2097[R] \u03b9 \u2192 R\n\u22a2 equivFun (ofEquivFun e) = e", "state_after": "case h.h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : AddCommMonoid M'\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Finite \u03b9\ne : M \u2243\u2097[R] \u03b9 \u2192 R\nj : M\nx\u271d : \u03b9\n\u22a2 (equivFun (ofEquivFun e)) j x\u271d = e j x\u271d"}, {"tactic": "simp_rw [Basis.equivFun_apply, Basis.ofEquivFun_repr_apply]", "annotated_tactic": ["simp_rw [<a>Basis.equivFun_apply</a>, <a>Basis.ofEquivFun_repr_apply</a>]", [{"full_name": "Basis.equivFun_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [916, 9], "def_end_pos": [916, 29]}, {"full_name": "Basis.ofEquivFun_repr_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [952, 9], "def_end_pos": [952, 36]}]], "state_before": "case h.h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : AddCommMonoid M'\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Finite \u03b9\ne : M \u2243\u2097[R] \u03b9 \u2192 R\nj : M\nx\u271d : \u03b9\n\u22a2 (equivFun (ofEquivFun e)) j x\u271d = e j x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Image.lean", "full_name": "StrictMonoOn.image_Ioi_subset", "start": [126, 1], "end": [127, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/TensorProduct/Basic.lean", "full_name": "Algebra.TensorProduct.one_mul", "start": [292, 11], "end": [293, 91], "traced_tactics": [{"tactic": "refine TensorProduct.induction_on x ?_ ?_ ?_ <;> simp (config := { contextual := true })", "annotated_tactic": ["refine <a>TensorProduct.induction_on</a> x ?_ ?_ ?_ <;> simp (config := { contextual := <a>true</a> })", [{"full_name": "TensorProduct.induction_on", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/TensorProduct/Basic.lean", "def_pos": [135, 19], "def_end_pos": [135, 31]}, {"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\nE : Type uE\nF : Type uF\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : NonAssocSemiring A\ninst\u271d\u2076 : Module R A\ninst\u271d\u2075 : SMulCommClass R A A\ninst\u271d\u2074 : IsScalarTower R A A\ninst\u271d\u00b3 : NonAssocSemiring B\ninst\u271d\u00b2 : Module R B\ninst\u271d\u00b9 : SMulCommClass R B B\ninst\u271d : IsScalarTower R B B\nx : A \u2297[R] B\n\u22a2 (mul (1 \u2297\u209c[R] 1)) x = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isBigOWith_of_le'", "start": [574, 1], "end": [575, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iSup_image", "start": [1444, 1], "end": [1445, 98], "traced_tactics": [{"tactic": "rw [\u2190 sSup_image, \u2190 sSup_image, \u2190 image_comp]", "annotated_tactic": ["rw [\u2190 <a>sSup_image</a>, \u2190 <a>sSup_image</a>, \u2190 <a>image_comp</a>]", [{"full_name": "sSup_image", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1353, 9], "def_end_pos": [1353, 19]}, {"full_name": "sSup_image", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1353, 9], "def_end_pos": [1353, 19]}, {"full_name": "Set.image_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [265, 9], "def_end_pos": [265, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3\u271d : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g\u271d s t\u271d : \u03b9 \u2192 \u03b1\na b : \u03b1\n\u03b3 : Type u_9\nf : \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b1\nt : Set \u03b2\n\u22a2 \u2a06 c \u2208 f '' t, g c = \u2a06 b \u2208 t, g (f b)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3\u271d : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g\u271d s t\u271d : \u03b9 \u2192 \u03b1\na b : \u03b1\n\u03b3 : Type u_9\nf : \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b1\nt : Set \u03b2\n\u22a2 sSup ((fun c => g c) \u2218 f '' t) = sSup ((fun b => g (f b)) '' t)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3\u271d : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g\u271d s t\u271d : \u03b9 \u2192 \u03b1\na b : \u03b1\n\u03b3 : Type u_9\nf : \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b1\nt : Set \u03b2\n\u22a2 sSup ((fun c => g c) \u2218 f '' t) = sSup ((fun b => g (f b)) '' t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Divisors.lean", "full_name": "Nat.prime_divisors_eq_to_filter_divisors_prime", "start": [530, 1], "end": [535, 51], "traced_tactics": [{"tactic": "rcases n.eq_zero_or_pos with (rfl | hn)", "annotated_tactic": ["rcases n.eq_zero_or_pos with (rfl | hn)", []], "state_before": "n\u271d n : \u2115\n\u22a2 List.toFinset (factors n) = filter Prime (divisors n)", "state_after": "case inl\nn : \u2115\n\u22a2 List.toFinset (factors 0) = filter Prime (divisors 0)\n\ncase inr\nn\u271d n : \u2115\nhn : n > 0\n\u22a2 List.toFinset (factors n) = filter Prime (divisors n)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inl\nn : \u2115\n\u22a2 List.toFinset (factors 0) = filter Prime (divisors 0)", "state_after": "no goals"}, {"tactic": "ext q", "annotated_tactic": ["ext q", []], "state_before": "case inr\nn\u271d n : \u2115\nhn : n > 0\n\u22a2 List.toFinset (factors n) = filter Prime (divisors n)", "state_after": "case inr.a\nn\u271d n : \u2115\nhn : n > 0\nq : \u2115\n\u22a2 q \u2208 List.toFinset (factors n) \u2194 q \u2208 filter Prime (divisors n)"}, {"tactic": "simpa [hn, hn.ne', mem_factors] using and_comm", "annotated_tactic": ["simpa [hn, hn.ne', <a>mem_factors</a>] using <a>and_comm</a>", [{"full_name": "Nat.mem_factors", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factors.lean", "def_pos": [154, 9], "def_end_pos": [154, 20]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}]], "state_before": "case inr.a\nn\u271d n : \u2115\nhn : n > 0\nq : \u2115\n\u22a2 q \u2208 List.toFinset (factors n) \u2194 q \u2208 filter Prime (divisors n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "orderTopology_of_nhds_abs", "start": [1102, 1], "end": [1107, 38], "traced_tactics": [{"tactic": "refine' \u27e8TopologicalSpace.ext_nhds fun a => _\u27e9", "annotated_tactic": ["refine' \u27e8<a>TopologicalSpace.ext_nhds</a> fun a => _\u27e9", [{"full_name": "TopologicalSpace.ext_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1181, 11], "def_end_pos": [1181, 36]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b1\u271d\ninst\u271d\u00b2 : OrderTopology \u03b1\u271d\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh_nhds : \u2200 (a : \u03b1), \ud835\udcdd a = \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r}\n\u22a2 OrderTopology \u03b1", "state_after": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b1\u271d\ninst\u271d\u00b2 : OrderTopology \u03b1\u271d\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh_nhds : \u2200 (a : \u03b1), \ud835\udcdd a = \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r}\na : \u03b1\n\u22a2 \ud835\udcdd a = \ud835\udcdd a"}, {"tactic": "rw [h_nhds]", "annotated_tactic": ["rw [h_nhds]", []], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b1\u271d\ninst\u271d\u00b2 : OrderTopology \u03b1\u271d\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh_nhds : \u2200 (a : \u03b1), \ud835\udcdd a = \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r}\na : \u03b1\n\u22a2 \ud835\udcdd a = \ud835\udcdd a", "state_after": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b1\u271d\ninst\u271d\u00b2 : OrderTopology \u03b1\u271d\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh_nhds : \u2200 (a : \u03b1), \ud835\udcdd a = \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r}\na : \u03b1\n\u22a2 \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r} = \ud835\udcdd a"}, {"tactic": "letI := Preorder.topology \u03b1", "annotated_tactic": ["letI := <a>Preorder.topology</a> \u03b1", [{"full_name": "Preorder.topology", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [77, 5], "def_end_pos": [77, 22]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b1\u271d\ninst\u271d\u00b2 : OrderTopology \u03b1\u271d\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh_nhds : \u2200 (a : \u03b1), \ud835\udcdd a = \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r}\na : \u03b1\n\u22a2 \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r} = \ud835\udcdd a", "state_after": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b1\u271d\ninst\u271d\u00b2 : OrderTopology \u03b1\u271d\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh_nhds : \u2200 (a : \u03b1), \ud835\udcdd a = \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r}\na : \u03b1\nthis : TopologicalSpace \u03b1 := Preorder.topology \u03b1\n\u22a2 \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r} = \ud835\udcdd a"}, {"tactic": "letI : OrderTopology \u03b1 := \u27e8rfl\u27e9", "annotated_tactic": ["letI : <a>OrderTopology</a> \u03b1 := \u27e8<a>rfl</a>\u27e9", [{"full_name": "OrderTopology", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [68, 7], "def_end_pos": [68, 20]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b1\u271d\ninst\u271d\u00b2 : OrderTopology \u03b1\u271d\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh_nhds : \u2200 (a : \u03b1), \ud835\udcdd a = \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r}\na : \u03b1\nthis : TopologicalSpace \u03b1 := Preorder.topology \u03b1\n\u22a2 \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r} = \ud835\udcdd a", "state_after": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b1\u271d\ninst\u271d\u00b2 : OrderTopology \u03b1\u271d\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh_nhds : \u2200 (a : \u03b1), \ud835\udcdd a = \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r}\na : \u03b1\nthis\u271d : TopologicalSpace \u03b1 := Preorder.topology \u03b1\nthis : OrderTopology \u03b1 := { topology_eq_generate_intervals := rfl }\n\u22a2 \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r} = \ud835\udcdd a"}, {"tactic": "exact (nhds_eq_iInf_abs_sub a).symm", "annotated_tactic": ["exact (<a>nhds_eq_iInf_abs_sub</a> a).<a>symm</a>", [{"full_name": "nhds_eq_iInf_abs_sub", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [1095, 9], "def_end_pos": [1095, 29]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : TopologicalSpace \u03b1\u271d\ninst\u271d\u00b3 : LinearOrderedAddCommGroup \u03b1\u271d\ninst\u271d\u00b2 : OrderTopology \u03b1\u271d\nl : Filter \u03b2\nf g : \u03b2 \u2192 \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh_nhds : \u2200 (a : \u03b1), \ud835\udcdd a = \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r}\na : \u03b1\nthis\u271d : TopologicalSpace \u03b1 := Preorder.topology \u03b1\nthis : OrderTopology \u03b1 := { topology_eq_generate_intervals := rfl }\n\u22a2 \u2a05 r, \u2a05 (_ : r > 0), \ud835\udcdf {b | |a - b| < r} = \ud835\udcdd a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "full_name": "MultilinearMap.norm_image_sub_le_of_bound'", "start": [162, 1], "end": [204, 7], "traced_tactics": [{"tactic": "convert A univ", "annotated_tactic": ["convert A <a>univ</a>", [{"full_name": "Finset.univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [68, 5], "def_end_pos": [68, 9]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\nA :\n  \u2200 (s : Finset \u03b9),\n    \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 \u2016f m\u2081 - f m\u2082\u2016 \u2264 C * \u2211 i : \u03b9, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "case h.e'_3.h.e'_3.h.e'_6.h.e'_6\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\nA :\n  \u2200 (s : Finset \u03b9),\n    \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 m\u2082 = piecewise univ m\u2082 m\u2081"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.e'_3.h.e'_3.h.e'_6.h.e'_6\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\nA :\n  \u2200 (s : Finset \u03b9),\n    \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 m\u2082 = piecewise univ m\u2082 m\u2081", "state_after": "no goals"}, {"tactic": "intro s", "annotated_tactic": ["intro s", []], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\n\u22a2 \u2200 (s : Finset \u03b9),\n    \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ns : Finset \u03b9\n\u22a2 \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016"}, {"tactic": "induction' s using Finset.induction with i s his Hrec", "annotated_tactic": ["induction' s using <a>Finset.induction</a> with i s his Hrec", [{"full_name": "Finset.induction", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1272, 19], "def_end_pos": [1272, 28]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ns : Finset \u03b9\n\u22a2 \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "case empty\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\n\u22a2 \u2016f m\u2081 - f (piecewise \u2205 m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in \u2205, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\ncase insert\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 \u2016f m\u2081 - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u2211 i in insert i s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016"}, {"tactic": "calc\n  \u2016f m\u2081 - f ((insert i s).piecewise m\u2082 m\u2081)\u2016 \u2264\n      \u2016f m\u2081 - f (s.piecewise m\u2082 m\u2081)\u2016 +\n        \u2016f (s.piecewise m\u2082 m\u2081) - f ((insert i s).piecewise m\u2082 m\u2081)\u2016 := by\n    rw [\u2190 dist_eq_norm, \u2190 dist_eq_norm, \u2190 dist_eq_norm]\n    exact dist_triangle _ _ _\n  _ \u2264\n      (C * \u2211 i in s, \u220f j, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016) +\n        C * \u220f j, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016 :=\n    (add_le_add Hrec I)\n  _ = C * \u2211 i in insert i s, \u220f j, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016 := by\n    simp [his, add_comm, left_distrib]", "annotated_tactic": ["calc\n      \u2016f m\u2081 - f ((<a>insert</a> i s).<a>piecewise</a> m\u2082 m\u2081)\u2016 \u2264\n          \u2016f m\u2081 - f (s.piecewise m\u2082 m\u2081)\u2016 +\n            \u2016f (s.piecewise m\u2082 m\u2081) - f ((<a>insert</a> i s).<a>piecewise</a> m\u2082 m\u2081)\u2016 := by\n        rw [\u2190 <a>dist_eq_norm</a>, \u2190 <a>dist_eq_norm</a>, \u2190 <a>dist_eq_norm</a>]\n        exact <a>dist_triangle</a> _ _ _\n      _ \u2264\n          (C * \u2211 i in s, \u220f j, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else <a>max</a> \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016) +\n            C * \u220f j, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else <a>max</a> \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016 :=\n        (<a>add_le_add</a> Hrec I)\n      _ = C * \u2211 i in <a>insert</a> i s, \u220f j, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else <a>max</a> \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016 := by\n        simp [his, <a>add_comm</a>, <a>left_distrib</a>]", [{"full_name": "Insert.insert", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [456, 3], "def_end_pos": [456, 9]}, {"full_name": "Finset.piecewise", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2556, 5], "def_end_pos": [2556, 14]}, {"full_name": "Insert.insert", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [456, 3], "def_end_pos": [456, 9]}, {"full_name": "Finset.piecewise", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2556, 5], "def_end_pos": [2556, 14]}, {"full_name": "dist_eq_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [411, 7], "def_end_pos": [411, 19]}, {"full_name": "dist_eq_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [411, 7], "def_end_pos": [411, 19]}, {"full_name": "dist_eq_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [411, 7], "def_end_pos": [411, 19]}, {"full_name": "dist_triangle", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [187, 9], "def_end_pos": [187, 22]}, {"full_name": "Max.max", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1117, 3], "def_end_pos": [1117, 6]}, {"full_name": "Max.max", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1117, 3], "def_end_pos": [1117, 6]}, {"full_name": "add_le_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [205, 32], "def_end_pos": [205, 42]}, {"full_name": "Insert.insert", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [456, 3], "def_end_pos": [456, 9]}, {"full_name": "Max.max", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1117, 3], "def_end_pos": [1117, 6]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "left_distrib", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [78, 9], "def_end_pos": [78, 21]}]], "state_before": "case insert\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nI :\n  \u2016f (piecewise s m\u2082 m\u2081) - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 \u2016f m\u2081 - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u2211 i in insert i s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case empty\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\n\u22a2 \u2016f m\u2081 - f (piecewise \u2205 m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in \u2205, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "no goals"}, {"tactic": "have A : (insert i s).piecewise m\u2082 m\u2081 = Function.update (s.piecewise m\u2082 m\u2081) i (m\u2082 i) :=\n  s.piecewise_insert _ _ _", "annotated_tactic": ["have A : (<a>insert</a> i s).<a>piecewise</a> m\u2082 m\u2081 = <a>Function.update</a> (s.piecewise m\u2082 m\u2081) i (m\u2082 i) :=\n        s.piecewise_insert _ _ _", [{"full_name": "Insert.insert", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [456, 3], "def_end_pos": [456, 9]}, {"full_name": "Finset.piecewise", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2556, 5], "def_end_pos": [2556, 14]}, {"full_name": "Function.update", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [556, 5], "def_end_pos": [556, 11]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 \u2016f (piecewise s m\u2082 m\u2081) - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\n\u22a2 \u2016f (piecewise s m\u2082 m\u2081) - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016"}, {"tactic": "rw [B, A, \u2190 f.map_sub]", "annotated_tactic": ["rw [B, A, \u2190 f.map_sub]", []], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\n\u22a2 \u2016f (piecewise s m\u2082 m\u2081) - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\n\u22a2 \u2016f (update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i))\u2016 \u2264 C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016"}, {"tactic": "apply le_trans (H _)", "annotated_tactic": ["apply <a>le_trans</a> (H _)", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\n\u22a2 \u2016f (update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i))\u2016 \u2264 C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\n\u22a2 C * \u220f i_1 : \u03b9, \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) i_1\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016"}, {"tactic": "gcongr with j", "annotated_tactic": ["gcongr with j", []], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\n\u22a2 C * \u220f i_1 : \u03b9, \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) i_1\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "case h.h0\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\n\u22a2 \u2200 i_1 \u2208 univ, 0 \u2264 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) i_1\u2016\n\ncase h.h1\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\nj : \u03b9\na\u271d : j \u2208 univ\n\u22a2 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) j\u2016 \u2264 if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016"}, {"tactic": "by_cases h : j = i", "annotated_tactic": ["by_cases h : j = i", []], "state_before": "case h.h1\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\nj : \u03b9\na\u271d : j \u2208 univ\n\u22a2 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) j\u2016 \u2264 if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "case pos\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\nj : \u03b9\na\u271d : j \u2208 univ\nh : j = i\n\u22a2 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) j\u2016 \u2264 if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\ncase neg\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\nj : \u03b9\na\u271d : j \u2208 univ\nh : \u00acj = i\n\u22a2 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) j\u2016 \u2264 if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016"}, {"tactic": "ext j", "annotated_tactic": ["ext j", []], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\n\u22a2 piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)", "state_after": "case h\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nj : \u03b9\n\u22a2 piecewise s m\u2082 m\u2081 j = update (piecewise s m\u2082 m\u2081) i (m\u2081 i) j"}, {"tactic": "by_cases h : j = i", "annotated_tactic": ["by_cases h : j = i", []], "state_before": "case h\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nj : \u03b9\n\u22a2 piecewise s m\u2082 m\u2081 j = update (piecewise s m\u2082 m\u2081) i (m\u2081 i) j", "state_after": "case pos\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nj : \u03b9\nh : j = i\n\u22a2 piecewise s m\u2082 m\u2081 j = update (piecewise s m\u2082 m\u2081) i (m\u2081 i) j\n\ncase neg\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nj : \u03b9\nh : \u00acj = i\n\u22a2 piecewise s m\u2082 m\u2081 j = update (piecewise s m\u2082 m\u2081) i (m\u2081 i) j"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "case pos\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nj : \u03b9\nh : j = i\n\u22a2 piecewise s m\u2082 m\u2081 j = update (piecewise s m\u2082 m\u2081) i (m\u2081 i) j", "state_after": "case pos\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nj : \u03b9\nh : j = i\n\u22a2 piecewise s m\u2082 m\u2081 i = update (piecewise s m\u2082 m\u2081) i (m\u2081 i) i"}, {"tactic": "simp [his]", "annotated_tactic": ["simp [his]", []], "state_before": "case pos\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nj : \u03b9\nh : j = i\n\u22a2 piecewise s m\u2082 m\u2081 i = update (piecewise s m\u2082 m\u2081) i (m\u2081 i) i", "state_after": "no goals"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case neg\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nj : \u03b9\nh : \u00acj = i\n\u22a2 piecewise s m\u2082 m\u2081 j = update (piecewise s m\u2082 m\u2081) i (m\u2081 i) j", "state_after": "no goals"}, {"tactic": "exact fun j _ => norm_nonneg _", "annotated_tactic": ["exact fun j _ => <a>norm_nonneg</a> _", [{"full_name": "norm_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [551, 30], "def_end_pos": [551, 41]}]], "state_before": "case h.h0\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\n\u22a2 \u2200 i_1 \u2208 univ, 0 \u2264 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) i_1\u2016", "state_after": "no goals"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "case pos\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\nj : \u03b9\na\u271d : j \u2208 univ\nh : j = i\n\u22a2 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) j\u2016 \u2264 if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "case pos\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\nj : \u03b9\na\u271d : j \u2208 univ\nh : j = i\n\u22a2 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) i\u2016 \u2264 if i = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 i\u2016 \u2016m\u2082 i\u2016"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case pos\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\nj : \u03b9\na\u271d : j \u2208 univ\nh : j = i\n\u22a2 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) i\u2016 \u2264 if i = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 i\u2016 \u2016m\u2082 i\u2016", "state_after": "no goals"}, {"tactic": "by_cases h' : j \u2208 s <;> simp [h', h, le_refl]", "annotated_tactic": ["by_cases h' : j \u2208 s <;> simp [h', h, <a>le_refl</a>]", [{"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "case neg\n\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nA : piecewise (insert i s) m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2082 i)\nB : piecewise s m\u2082 m\u2081 = update (piecewise s m\u2082 m\u2081) i (m\u2081 i)\nj : \u03b9\na\u271d : j \u2208 univ\nh : \u00acj = i\n\u22a2 \u2016update (piecewise s m\u2082 m\u2081) i (m\u2081 i - m\u2082 i) j\u2016 \u2264 if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "no goals"}, {"tactic": "rw [\u2190 dist_eq_norm, \u2190 dist_eq_norm, \u2190 dist_eq_norm]", "annotated_tactic": ["rw [\u2190 <a>dist_eq_norm</a>, \u2190 <a>dist_eq_norm</a>, \u2190 <a>dist_eq_norm</a>]", [{"full_name": "dist_eq_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [411, 7], "def_end_pos": [411, 19]}, {"full_name": "dist_eq_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [411, 7], "def_end_pos": [411, 19]}, {"full_name": "dist_eq_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [411, 7], "def_end_pos": [411, 19]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nI :\n  \u2016f (piecewise s m\u2082 m\u2081) - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 \u2016f m\u2081 - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 + \u2016f (piecewise s m\u2082 m\u2081) - f (piecewise (insert i s) m\u2082 m\u2081)\u2016", "state_after": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nI :\n  \u2016f (piecewise s m\u2082 m\u2081) - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 dist (f m\u2081) (f (piecewise (insert i s) m\u2082 m\u2081)) \u2264\n    dist (f m\u2081) (f (piecewise s m\u2082 m\u2081)) + dist (f (piecewise s m\u2082 m\u2081)) (f (piecewise (insert i s) m\u2082 m\u2081))"}, {"tactic": "exact dist_triangle _ _ _", "annotated_tactic": ["exact <a>dist_triangle</a> _ _ _", [{"full_name": "dist_triangle", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [187, 9], "def_end_pos": [187, 22]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nI :\n  \u2016f (piecewise s m\u2082 m\u2081) - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 dist (f m\u2081) (f (piecewise (insert i s) m\u2082 m\u2081)) \u2264\n    dist (f m\u2081) (f (piecewise s m\u2082 m\u2081)) + dist (f (piecewise s m\u2082 m\u2081)) (f (piecewise (insert i s) m\u2082 m\u2081))", "state_after": "no goals"}, {"tactic": "simp [his, add_comm, left_distrib]", "annotated_tactic": ["simp [his, <a>add_comm</a>, <a>left_distrib</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "left_distrib", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [78, 9], "def_end_pos": [78, 21]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2075 : Fintype \u03b9\ninst\u271d\u00b9\u2074 : Fintype \u03b9'\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b2 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2076 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u2074 : SeminormedAddCommGroup G\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b2 : SeminormedAddCommGroup G'\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c G'\nf : MultilinearMap \ud835\udd5c E G\ninst\u271d : DecidableEq \u03b9\nC : \u211d\nhC : 0 \u2264 C\nH : \u2200 (m : (i : \u03b9) \u2192 E i), \u2016f m\u2016 \u2264 C * \u220f i : \u03b9, \u2016m i\u2016\nm\u2081 m\u2082 : (i : \u03b9) \u2192 E i\ni : \u03b9\ns : Finset \u03b9\nhis : i \u2209 s\nHrec : \u2016f m\u2081 - f (piecewise s m\u2082 m\u2081)\u2016 \u2264 C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\nI :\n  \u2016f (piecewise s m\u2082 m\u2081) - f (piecewise (insert i s) m\u2082 m\u2081)\u2016 \u2264\n    C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016\n\u22a2 ((C * \u2211 i in s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016) +\n      C * \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016) =\n    C * \u2211 i in insert i s, \u220f j : \u03b9, if j = i then \u2016m\u2081 i - m\u2082 i\u2016 else max \u2016m\u2081 j\u2016 \u2016m\u2082 j\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Matrix.lean", "full_name": "continuous_matrix", "start": [70, 1], "end": [72, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.codisjoint_coe", "start": [693, 1], "end": [694, 56], "traced_tactics": [{"tactic": "simp [disjoint_iff, codisjoint_iff, SetLike.ext'_iff]", "annotated_tactic": ["simp [<a>disjoint_iff</a>, <a>codisjoint_iff</a>, <a>SetLike.ext'_iff</a>]", [{"full_name": "disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "codisjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [329, 9], "def_end_pos": [329, 23]}, {"full_name": "SetLike.ext'_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [166, 9], "def_end_pos": [166, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nS : Set (UpperSet \u03b1)\ns t : UpperSet \u03b1\na : \u03b1\n\u22a2 Codisjoint \u2191s \u2191t \u2194 Disjoint s t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "full_name": "IsPreconnected.eq_univ_of_unbounded", "start": [235, 1], "end": [240, 55], "traced_tactics": [{"tactic": "refine' eq_univ_of_forall fun x => _", "annotated_tactic": ["refine' <a>eq_univ_of_forall</a> fun x => _", [{"full_name": "Set.eq_univ_of_forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [675, 9], "def_end_pos": [675, 26]}]], "state_before": "X : Type u\n\u03b1 : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns : Set \u03b1\nhs : IsPreconnected s\nhb : \u00acBddBelow s\nha : \u00acBddAbove s\n\u22a2 s = univ", "state_after": "X : Type u\n\u03b1 : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns : Set \u03b1\nhs : IsPreconnected s\nhb : \u00acBddBelow s\nha : \u00acBddAbove s\nx : \u03b1\n\u22a2 x \u2208 s"}, {"tactic": "obtain \u27e8y, ys, hy\u27e9 : \u2203 y \u2208 s, y < x := not_bddBelow_iff.1 hb x", "annotated_tactic": ["obtain \u27e8y, ys, hy\u27e9 : \u2203 y \u2208 s, y < x := <a>not_bddBelow_iff</a>.1 hb x", [{"full_name": "not_bddBelow_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [146, 9], "def_end_pos": [146, 25]}]], "state_before": "X : Type u\n\u03b1 : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns : Set \u03b1\nhs : IsPreconnected s\nhb : \u00acBddBelow s\nha : \u00acBddAbove s\nx : \u03b1\n\u22a2 x \u2208 s", "state_after": "case intro.intro\nX : Type u\n\u03b1 : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns : Set \u03b1\nhs : IsPreconnected s\nhb : \u00acBddBelow s\nha : \u00acBddAbove s\nx y : \u03b1\nys : y \u2208 s\nhy : y < x\n\u22a2 x \u2208 s"}, {"tactic": "obtain \u27e8z, zs, hz\u27e9 : \u2203 z \u2208 s, x < z := not_bddAbove_iff.1 ha x", "annotated_tactic": ["obtain \u27e8z, zs, hz\u27e9 : \u2203 z \u2208 s, x < z := <a>not_bddAbove_iff</a>.1 ha x", [{"full_name": "not_bddAbove_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [139, 9], "def_end_pos": [139, 25]}]], "state_before": "case intro.intro\nX : Type u\n\u03b1 : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns : Set \u03b1\nhs : IsPreconnected s\nhb : \u00acBddBelow s\nha : \u00acBddAbove s\nx y : \u03b1\nys : y \u2208 s\nhy : y < x\n\u22a2 x \u2208 s", "state_after": "case intro.intro.intro.intro\nX : Type u\n\u03b1 : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns : Set \u03b1\nhs : IsPreconnected s\nhb : \u00acBddBelow s\nha : \u00acBddAbove s\nx y : \u03b1\nys : y \u2208 s\nhy : y < x\nz : \u03b1\nzs : z \u2208 s\nhz : x < z\n\u22a2 x \u2208 s"}, {"tactic": "exact hs.Icc_subset ys zs \u27e8le_of_lt hy, le_of_lt hz\u27e9", "annotated_tactic": ["exact hs.Icc_subset ys zs \u27e8<a>le_of_lt</a> hy, <a>le_of_lt</a> hz\u27e9", [{"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}, {"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}]], "state_before": "case intro.intro.intro.intro\nX : Type u\n\u03b1 : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns : Set \u03b1\nhs : IsPreconnected s\nhb : \u00acBddBelow s\nha : \u00acBddAbove s\nx y : \u03b1\nys : y \u2208 s\nhy : y < x\nz : \u03b1\nzs : z \u2208 s\nhz : x < z\n\u22a2 x \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.arrowCongr_comp", "start": [542, 1], "end": [545, 63], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\n\u03b1\u2081 : Sort u_1\n\u03b2\u2081 : Sort u_2\n\u03b3\u2081 : Sort u_3\n\u03b1\u2082 : Sort u_4\n\u03b2\u2082 : Sort u_5\n\u03b3\u2082 : Sort u_6\nea : \u03b1\u2081 \u2243 \u03b1\u2082\neb : \u03b2\u2081 \u2243 \u03b2\u2082\nec : \u03b3\u2081 \u2243 \u03b3\u2082\nf : \u03b1\u2081 \u2192 \u03b2\u2081\ng : \u03b2\u2081 \u2192 \u03b3\u2081\n\u22a2 (arrowCongr ea ec) (g \u2218 f) = (arrowCongr eb ec) g \u2218 (arrowCongr ea eb) f", "state_after": "case h\n\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\n\u03b1\u2081 : Sort u_1\n\u03b2\u2081 : Sort u_2\n\u03b3\u2081 : Sort u_3\n\u03b1\u2082 : Sort u_4\n\u03b2\u2082 : Sort u_5\n\u03b3\u2082 : Sort u_6\nea : \u03b1\u2081 \u2243 \u03b1\u2082\neb : \u03b2\u2081 \u2243 \u03b2\u2082\nec : \u03b3\u2081 \u2243 \u03b3\u2082\nf : \u03b1\u2081 \u2192 \u03b2\u2081\ng : \u03b2\u2081 \u2192 \u03b3\u2081\nx\u271d : \u03b1\u2082\n\u22a2 (arrowCongr ea ec) (g \u2218 f) x\u271d = ((arrowCongr eb ec) g \u2218 (arrowCongr ea eb) f) x\u271d"}, {"tactic": "simp only [comp, arrowCongr_apply, eb.symm_apply_apply]", "annotated_tactic": ["simp only [<a>comp</a>, <a>arrowCongr_apply</a>, eb.symm_apply_apply]", [{"full_name": "Function.comp", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}, {"full_name": "Equiv.arrowCongr_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [533, 9], "def_end_pos": [533, 14]}]], "state_before": "case h\n\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\n\u03b1\u2081 : Sort u_1\n\u03b2\u2081 : Sort u_2\n\u03b3\u2081 : Sort u_3\n\u03b1\u2082 : Sort u_4\n\u03b2\u2082 : Sort u_5\n\u03b3\u2082 : Sort u_6\nea : \u03b1\u2081 \u2243 \u03b1\u2082\neb : \u03b2\u2081 \u2243 \u03b2\u2082\nec : \u03b3\u2081 \u2243 \u03b3\u2082\nf : \u03b1\u2081 \u2192 \u03b2\u2081\ng : \u03b2\u2081 \u2192 \u03b3\u2081\nx\u271d : \u03b1\u2082\n\u22a2 (arrowCongr ea ec) (g \u2218 f) x\u271d = ((arrowCongr eb ec) g \u2218 (arrowCongr ea eb) f) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.cosh_add", "start": [1063, 8], "end": [1064, 37], "traced_tactics": [{"tactic": "rw [\u2190 ofReal_inj]", "annotated_tactic": ["rw [\u2190 <a>ofReal_inj</a>]", [{"full_name": "Complex.ofReal_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [109, 9], "def_end_pos": [109, 19]}]], "state_before": "x y : \u211d\n\u22a2 cosh (x + y) = cosh x * cosh y + sinh x * sinh y", "state_after": "x y : \u211d\n\u22a2 \u2191(cosh (x + y)) = \u2191(cosh x * cosh y + sinh x * sinh y)"}, {"tactic": "simp [cosh_add]", "annotated_tactic": ["simp [<a>cosh_add</a>]", [{"full_name": "Complex.cosh_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [310, 9], "def_end_pos": [310, 17]}]], "state_before": "x y : \u211d\n\u22a2 \u2191(cosh (x + y)) = \u2191(cosh x * cosh y + sinh x * sinh y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupRingAction/Invariant.lean", "full_name": "IsInvariantSubring.coe_subtypeHom'", "start": [60, 1], "end": [61, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/DenseEmbedding.lean", "full_name": "DenseRange.induction_on\u2082", "start": [337, 1], "end": [340, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.mem_comap_iff_compl", "start": [2050, 1], "end": [2051, 46], "traced_tactics": [{"tactic": "simp only [mem_comap'', kernImage_eq_compl]", "annotated_tactic": ["simp only [<a>mem_comap''</a>, <a>kernImage_eq_compl</a>]", [{"full_name": "Filter.mem_comap''", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2031, 9], "def_end_pos": [2031, 20]}, {"full_name": "Set.kernImage_eq_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [128, 7], "def_end_pos": [128, 25]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b2\np : \u03b1 \u2192 Prop\ns : Set \u03b1\n\u22a2 s \u2208 comap f l \u2194 (f '' s\u1d9c)\u1d9c \u2208 l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/DilationEquiv.lean", "full_name": "DilationEquiv.coe_inv", "start": [153, 1], "end": [153, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Regular/Basic.lean", "full_name": "not_isRightRegular_zero_iff", "start": [234, 1], "end": [237, 16], "traced_tactics": [{"tactic": "rw [nontrivial_iff, not_iff_comm, isRightRegular_zero_iff_subsingleton, subsingleton_iff]", "annotated_tactic": ["rw [<a>nontrivial_iff</a>, <a>not_iff_comm</a>, <a>isRightRegular_zero_iff_subsingleton</a>, <a>subsingleton_iff</a>]", [{"full_name": "nontrivial_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [36, 9], "def_end_pos": [36, 23]}, {"full_name": "not_iff_comm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [452, 9], "def_end_pos": [452, 21]}, {"full_name": "isRightRegular_zero_iff_subsingleton", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Regular/Basic.lean", "def_pos": [229, 9], "def_end_pos": [229, 45]}, {"full_name": "subsingleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [77, 9], "def_end_pos": [77, 25]}]], "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 \u00acIsRightRegular 0 \u2194 Nontrivial R", "state_after": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 (\u00ac\u2203 x y, x \u2260 y) \u2194 \u2200 (x y : R), x = y"}, {"tactic": "push_neg", "annotated_tactic": ["push_neg", []], "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 (\u00ac\u2203 x y, x \u2260 y) \u2194 \u2200 (x y : R), x = y", "state_after": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 (\u2200 (x y : R), x = y) \u2194 \u2200 (x y : R), x = y"}, {"tactic": "exact Iff.rfl", "annotated_tactic": ["exact <a>Iff.rfl</a>", [{"full_name": "Iff.rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [791, 19], "def_end_pos": [791, 26]}]], "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 (\u2200 (x y : R), x = y) \u2194 \u2200 (x y : R), x = y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Pairwise.lean", "full_name": "List.Pairwise.forall", "start": [81, 1], "end": [86, 46], "traced_tactics": [{"tactic": "apply Pairwise.forall_of_forall", "annotated_tactic": ["apply <a>Pairwise.forall_of_forall</a>", [{"full_name": "List.Pairwise.forall_of_forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Pairwise.lean", "def_pos": [76, 9], "def_end_pos": [76, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl : List \u03b1\nhR : Symmetric R\nhl : Pairwise R l\n\u22a2 \u2200 \u2983a : \u03b1\u2984, a \u2208 l \u2192 \u2200 \u2983b : \u03b1\u2984, b \u2208 l \u2192 a \u2260 b \u2192 R a b", "state_after": "case H\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl : List \u03b1\nhR : Symmetric R\nhl : Pairwise R l\n\u22a2 Symmetric fun x y => x \u2260 y \u2192 R x y\n\ncase H\u2081\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl : List \u03b1\nhR : Symmetric R\nhl : Pairwise R l\n\u22a2 \u2200 (x : \u03b1), x \u2208 l \u2192 x \u2260 x \u2192 R x x\n\ncase H\u2082\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl : List \u03b1\nhR : Symmetric R\nhl : Pairwise R l\n\u22a2 Pairwise (fun x y => x \u2260 y \u2192 R x y) l"}, {"tactic": "exact fun a b h hne => hR (h hne.symm)", "annotated_tactic": ["exact fun a b h hne => hR (h hne.symm)", []], "state_before": "case H\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl : List \u03b1\nhR : Symmetric R\nhl : Pairwise R l\n\u22a2 Symmetric fun x y => x \u2260 y \u2192 R x y", "state_after": "no goals"}, {"tactic": "exact fun _ _ hx => (hx rfl).elim", "annotated_tactic": ["exact fun _ _ hx => (hx <a>rfl</a>).<a>elim</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}]], "state_before": "case H\u2081\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl : List \u03b1\nhR : Symmetric R\nhl : Pairwise R l\n\u22a2 \u2200 (x : \u03b1), x \u2208 l \u2192 x \u2260 x \u2192 R x x", "state_after": "no goals"}, {"tactic": "exact hl.imp (@fun a b h _ => by exact h)", "annotated_tactic": ["exact hl.imp (@fun a b h _ => by exact h)", []], "state_before": "case H\u2082\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nl : List \u03b1\nhR : Symmetric R\nhl : Pairwise R l\n\u22a2 Pairwise (fun x y => x \u2260 y \u2192 R x y) l", "state_after": "no goals"}, {"tactic": "exact h", "annotated_tactic": ["exact h", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR S T : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d : \u03b1\nl : List \u03b1\nhR : Symmetric R\nhl : Pairwise R l\na b : \u03b1\nh : R a b\nx\u271d : a \u2260 b\n\u22a2 R a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.mul_mem_mul", "start": [386, 1], "end": [387, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "linearIndependent_sum", "start": [756, 1], "end": [794, 50], "traced_tactics": [{"tactic": "rw [range_comp v, range_comp v]", "annotated_tactic": ["rw [<a>range_comp</a> v, <a>range_comp</a> v]", [{"full_name": "Set.range_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [722, 9], "def_end_pos": [722, 19]}, {"full_name": "Set.range_comp", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [722, 9], "def_end_pos": [722, 19]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\n\u22a2 LinearIndependent R v \u2194\n    LinearIndependent R (v \u2218 Sum.inl) \u2227\n      LinearIndependent R (v \u2218 Sum.inr) \u2227 Disjoint (span R (range (v \u2218 Sum.inl))) (span R (range (v \u2218 Sum.inr)))", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\n\u22a2 LinearIndependent R v \u2194\n    LinearIndependent R (v \u2218 Sum.inl) \u2227\n      LinearIndependent R (v \u2218 Sum.inr) \u2227 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))"}, {"tactic": "refine' \u27e8_, _\u27e9", "annotated_tactic": ["refine' \u27e8_, _\u27e9", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\n\u22a2 LinearIndependent R v \u2194\n    LinearIndependent R (v \u2218 Sum.inl) \u2227\n      LinearIndependent R (v \u2218 Sum.inr) \u2227 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))", "state_after": "case refine'_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\n\u22a2 LinearIndependent R v \u2192\n    LinearIndependent R (v \u2218 Sum.inl) \u2227\n      LinearIndependent R (v \u2218 Sum.inr) \u2227 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\n\ncase refine'_2\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\n\u22a2 LinearIndependent R (v \u2218 Sum.inl) \u2227\n      LinearIndependent R (v \u2218 Sum.inr) \u2227 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr)) \u2192\n    LinearIndependent R v"}, {"tactic": "rintro \u27e8hl, hr, hlr\u27e9", "annotated_tactic": ["rintro \u27e8hl, hr, hlr\u27e9", []], "state_before": "case refine'_2\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\n\u22a2 LinearIndependent R (v \u2218 Sum.inl) \u2227\n      LinearIndependent R (v \u2218 Sum.inr) \u2227 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr)) \u2192\n    LinearIndependent R v", "state_after": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : LinearIndependent R (v \u2218 Sum.inl)\nhr : LinearIndependent R (v \u2218 Sum.inr)\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\n\u22a2 LinearIndependent R v"}, {"tactic": "rw [linearIndependent_iff'] at *", "annotated_tactic": ["rw [<a>linearIndependent_iff'</a>] at *", [{"full_name": "linearIndependent_iff'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [130, 9], "def_end_pos": [130, 31]}]], "state_before": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : LinearIndependent R (v \u2218 Sum.inl)\nhr : LinearIndependent R (v \u2218 Sum.inr)\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\n\u22a2 LinearIndependent R v", "state_after": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\n\u22a2 \u2200 (s : Finset (\u03b9 \u2295 \u03b9')) (g : \u03b9 \u2295 \u03b9' \u2192 R), \u2211 i in s, g i \u2022 v i = 0 \u2192 \u2200 i \u2208 s, g i = 0"}, {"tactic": "intro s g hg i hi", "annotated_tactic": ["intro s g hg i hi", []], "state_before": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\n\u22a2 \u2200 (s : Finset (\u03b9 \u2295 \u03b9')) (g : \u03b9 \u2295 \u03b9' \u2192 R), \u2211 i in s, g i \u2022 v i = 0 \u2192 \u2200 i \u2208 s, g i = 0", "state_after": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\n\u22a2 g i = 0"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case refine'_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\n\u22a2 LinearIndependent R v \u2192\n    LinearIndependent R (v \u2218 Sum.inl) \u2227\n      LinearIndependent R (v \u2218 Sum.inr) \u2227 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))", "state_after": "case refine'_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nh : LinearIndependent R v\n\u22a2 LinearIndependent R (v \u2218 Sum.inl) \u2227\n    LinearIndependent R (v \u2218 Sum.inr) \u2227 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))"}, {"tactic": "refine' \u27e8h.comp _ Sum.inl_injective, h.comp _ Sum.inr_injective, _\u27e9", "annotated_tactic": ["refine' \u27e8h.comp _ <a>Sum.inl_injective</a>, h.comp _ <a>Sum.inr_injective</a>, _\u27e9", [{"full_name": "Sum.inl_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sum/Basic.lean", "def_pos": [32, 9], "def_end_pos": [32, 22]}, {"full_name": "Sum.inr_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sum/Basic.lean", "def_pos": [35, 9], "def_end_pos": [35, 22]}]], "state_before": "case refine'_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nh : LinearIndependent R v\n\u22a2 LinearIndependent R (v \u2218 Sum.inl) \u2227\n    LinearIndependent R (v \u2218 Sum.inr) \u2227 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))", "state_after": "case refine'_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nh : LinearIndependent R v\n\u22a2 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))"}, {"tactic": "refine' h.disjoint_span_image _", "annotated_tactic": ["refine' h.disjoint_span_image _", []], "state_before": "case refine'_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nh : LinearIndependent R v\n\u22a2 Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))", "state_after": "case refine'_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nh : LinearIndependent R v\n\u22a2 Disjoint (range Sum.inl) (range Sum.inr)"}, {"tactic": "exact IsCompl.disjoint isCompl_range_inl_range_inr", "annotated_tactic": ["exact <a>IsCompl.disjoint</a> <a>isCompl_range_inl_range_inr</a>", [{"full_name": "IsCompl.disjoint", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [471, 13], "def_end_pos": [471, 21]}, {"full_name": "Set.isCompl_range_inl_range_inr", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [882, 9], "def_end_pos": [882, 36]}]], "state_before": "case refine'_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nh : LinearIndependent R v\n\u22a2 Disjoint (range Sum.inl) (range Sum.inr)", "state_after": "no goals"}, {"tactic": "rw [Finset.sum_preimage' (g := fun x => g x \u2022 v x),\n  Finset.sum_preimage' (g := fun x => g x \u2022 v x), \u2190 Finset.sum_union, \u2190 Finset.filter_or]", "annotated_tactic": ["rw [<a>Finset.sum_preimage'</a> (g := fun x => g x \u2022 v x),\n      <a>Finset.sum_preimage'</a> (g := fun x => g x \u2022 v x), \u2190 <a>Finset.sum_union</a>, \u2190 <a>Finset.filter_or</a>]", [{"full_name": "Finset.sum_preimage'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [142, 3], "def_end_pos": [142, 14]}, {"full_name": "Finset.sum_preimage'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [142, 3], "def_end_pos": [142, 14]}, {"full_name": "Finset.sum_union", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [421, 3], "def_end_pos": [421, 14]}, {"full_name": "Finset.filter_or", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2996, 9], "def_end_pos": [2996, 18]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\n\u22a2 \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) +\n      \u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i) =\n    0", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\n\u22a2 \u2211 x in Finset.filter (fun a => a \u2208 range Sum.inl \u2228 a \u2208 range Sum.inr) s, g x \u2022 v x = 0\n\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\n\u22a2 Disjoint (Finset.filter (fun x => x \u2208 range Sum.inl) s) (Finset.filter (fun x => x \u2208 range Sum.inr) s)"}, {"tactic": "simpa only [\u2190 mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_True]", "annotated_tactic": ["simpa only [\u2190 <a>mem_union</a>, <a>range_inl_union_range_inr</a>, <a>mem_univ</a>, <a>Finset.filter_True</a>]", [{"full_name": "Set.mem_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 18]}, {"full_name": "Set.range_inl_union_range_inr", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [891, 9], "def_end_pos": [891, 34]}, {"full_name": "Set.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [82, 29], "def_end_pos": [82, 37]}, {"full_name": "Finset.filter_True", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2821, 9], "def_end_pos": [2821, 20]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\n\u22a2 \u2211 x in Finset.filter (fun a => a \u2208 range Sum.inl \u2228 a \u2208 range Sum.inr) s, g x \u2022 v x = 0", "state_after": "no goals"}, {"tactic": "refine Finset.disjoint_filter.2 fun x _ hx =>\n  disjoint_left.1 ?_ hx", "annotated_tactic": ["refine <a>Finset.disjoint_filter</a>.2 fun x _ hx =>\n        <a>disjoint_left</a>.1 ?_ hx", [{"full_name": "Finset.disjoint_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2905, 9], "def_end_pos": [2905, 24]}, {"full_name": "Set.disjoint_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1530, 9], "def_end_pos": [1530, 22]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\n\u22a2 Disjoint (Finset.filter (fun x => x \u2208 range Sum.inl) s) (Finset.filter (fun x => x \u2208 range Sum.inr) s)", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d\u00b9 y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\nx : \u03b9 \u2295 \u03b9'\nx\u271d : x \u2208 s\nhx : x \u2208 range Sum.inl\n\u22a2 Disjoint (range Sum.inl) (range Sum.inr)"}, {"tactic": "exact IsCompl.disjoint isCompl_range_inl_range_inr", "annotated_tactic": ["exact <a>IsCompl.disjoint</a> <a>isCompl_range_inl_range_inr</a>", [{"full_name": "IsCompl.disjoint", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [471, 13], "def_end_pos": [471, 21]}, {"full_name": "Set.isCompl_range_inl_range_inr", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [882, 9], "def_end_pos": [882, 36]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d\u00b9 y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\nx : \u03b9 \u2295 \u03b9'\nx\u271d : x \u2208 s\nhx : x \u2208 range Sum.inl\n\u22a2 Disjoint (range Sum.inl) (range Sum.inr)", "state_after": "no goals"}, {"tactic": "rw [\u2190 eq_neg_iff_add_eq_zero] at this", "annotated_tactic": ["rw [\u2190 <a>eq_neg_iff_add_eq_zero</a>] at this", [{"full_name": "eq_neg_iff_add_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [741, 3], "def_end_pos": [741, 14]}]], "state_before": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) +\n      \u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i) =\n    0\n\u22a2 g i = 0", "state_after": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\n\u22a2 g i = 0"}, {"tactic": "rw [disjoint_def'] at hlr", "annotated_tactic": ["rw [<a>disjoint_def'</a>] at hlr", [{"full_name": "Submodule.disjoint_def'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [379, 9], "def_end_pos": [379, 22]}]], "state_before": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : Disjoint (span R (v '' range Sum.inl)) (span R (v '' range Sum.inr))\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\n\u22a2 g i = 0", "state_after": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\n\u22a2 g i = 0"}, {"tactic": "cases' i with i i", "annotated_tactic": ["cases' i with i i", []], "state_before": "case refine'_2.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\nA : \u2211 c in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl c) = 0\n\u22a2 g i = 0", "state_after": "case refine'_2.intro.intro.inl\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\nA : \u2211 c in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl c) = 0\ni : \u03b9\nhi : Sum.inl i \u2208 s\n\u22a2 g (Sum.inl i) = 0\n\ncase refine'_2.intro.intro.inr\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\nA : \u2211 c in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl c) = 0\ni : \u03b9'\nhi : Sum.inr i \u2208 s\n\u22a2 g (Sum.inr i) = 0"}, {"tactic": "refine hlr _ (sum_mem fun i _ => ?_) _ (neg_mem <| sum_mem fun i _ => ?_) this", "annotated_tactic": ["refine hlr _ (<a>sum_mem</a> fun i _ => ?_) _ (<a>neg_mem</a> <| <a>sum_mem</a> fun i _ => ?_) this", [{"full_name": "sum_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [95, 3], "def_end_pos": [95, 14]}, {"full_name": "NegMemClass.neg_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [106, 3], "def_end_pos": [106, 10]}, {"full_name": "sum_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [95, 3], "def_end_pos": [95, 14]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9 \u2295 \u03b9'\nhi : i \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\n\u22a2 ?m.414211", "state_after": "case refine_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni\u271d : \u03b9 \u2295 \u03b9'\nhi : i\u271d \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\ni : \u03b9\nx\u271d : i \u2208 Finset.preimage s Sum.inl \u22ef\n\u22a2 (fun x => g x \u2022 v x) (Sum.inl i) \u2208 span R (v '' range Sum.inl)\n\ncase refine_2\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni\u271d : \u03b9 \u2295 \u03b9'\nhi : i\u271d \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\ni : \u03b9'\nx\u271d : i \u2208 Finset.preimage s Sum.inr \u22ef\n\u22a2 (fun x => g x \u2022 v x) (Sum.inr i) \u2208 span R (v '' range Sum.inr)"}, {"tactic": "exact smul_mem _ _ (subset_span \u27e8Sum.inl i, mem_range_self _, rfl\u27e9)", "annotated_tactic": ["exact <a>smul_mem</a> _ _ (<a>subset_span</a> \u27e8<a>Sum.inl</a> i, <a>mem_range_self</a> _, <a>rfl</a>\u27e9)", [{"full_name": "Submodule.smul_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}, {"full_name": "Submodule.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}, {"full_name": "Sum.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [132, 5], "def_end_pos": [132, 8]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case refine_1\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni\u271d : \u03b9 \u2295 \u03b9'\nhi : i\u271d \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\ni : \u03b9\nx\u271d : i \u2208 Finset.preimage s Sum.inl \u22ef\n\u22a2 (fun x => g x \u2022 v x) (Sum.inl i) \u2208 span R (v '' range Sum.inl)", "state_after": "no goals"}, {"tactic": "exact smul_mem _ _ (subset_span \u27e8Sum.inr i, mem_range_self _, rfl\u27e9)", "annotated_tactic": ["exact <a>smul_mem</a> _ _ (<a>subset_span</a> \u27e8<a>Sum.inr</a> i, <a>mem_range_self</a> _, <a>rfl</a>\u27e9)", [{"full_name": "Submodule.smul_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}, {"full_name": "Submodule.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}, {"full_name": "Sum.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [134, 5], "def_end_pos": [134, 8]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case refine_2\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni\u271d : \u03b9 \u2295 \u03b9'\nhi : i\u271d \u2208 s\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\ni : \u03b9'\nx\u271d : i \u2208 Finset.preimage s Sum.inr \u22ef\n\u22a2 (fun x => g x \u2022 v x) (Sum.inr i) \u2208 span R (v '' range Sum.inr)", "state_after": "no goals"}, {"tactic": "exact hl _ _ A i (Finset.mem_preimage.2 hi)", "annotated_tactic": ["exact hl _ _ A i (<a>Finset.mem_preimage</a>.2 hi)", [{"full_name": "Finset.mem_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}]], "state_before": "case refine'_2.intro.intro.inl\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\nA : \u2211 c in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl c) = 0\ni : \u03b9\nhi : Sum.inl i \u2208 s\n\u22a2 g (Sum.inl i) = 0", "state_after": "no goals"}, {"tactic": "rw [this, neg_eq_zero] at A", "annotated_tactic": ["rw [this, <a>neg_eq_zero</a>] at A", [{"full_name": "neg_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [497, 3], "def_end_pos": [497, 14]}]], "state_before": "case refine'_2.intro.intro.inr\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\nA : \u2211 c in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl c) = 0\ni : \u03b9'\nhi : Sum.inr i \u2208 s\n\u22a2 g (Sum.inr i) = 0", "state_after": "case refine'_2.intro.intro.inr\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\nA : \u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i) = 0\ni : \u03b9'\nhi : Sum.inr i \u2208 s\n\u22a2 g (Sum.inr i) = 0"}, {"tactic": "exact hr _ _ A i (Finset.mem_preimage.2 hi)", "annotated_tactic": ["exact hr _ _ A i (<a>Finset.mem_preimage</a>.2 hi)", [{"full_name": "Finset.mem_preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Preimage.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}]], "state_before": "case refine'_2.intro.intro.inr\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nv : \u03b9 \u2295 \u03b9' \u2192 M\nhl : \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inl) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhr : \u2200 (s : Finset \u03b9') (g : \u03b9' \u2192 R), \u2211 i in s, g i \u2022 (v \u2218 Sum.inr) i = 0 \u2192 \u2200 i \u2208 s, g i = 0\nhlr : \u2200 x \u2208 span R (v '' range Sum.inl), \u2200 y \u2208 span R (v '' range Sum.inr), x = y \u2192 x = 0\ns : Finset (\u03b9 \u2295 \u03b9')\ng : \u03b9 \u2295 \u03b9' \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\nthis :\n  \u2211 i in Finset.preimage s Sum.inl \u22ef, (fun x => g x \u2022 v x) (Sum.inl i) =\n    -\u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i)\nA : \u2211 i in Finset.preimage s Sum.inr \u22ef, (fun x => g x \u2022 v x) (Sum.inr i) = 0\ni : \u03b9'\nhi : Sum.inr i \u2208 s\n\u22a2 g (Sum.inr i) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.coe_pow", "start": [381, 11], "end": [382, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.nonempty_of_nonempty_subtype", "start": [524, 1], "end": [525, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Functor/EpiMono.lean", "full_name": "CategoryTheory.Functor.preservesEpimorphsisms_of_adjunction", "start": [175, 1], "end": [182, 41], "traced_tactics": [{"tactic": "intro Z g h H", "annotated_tactic": ["intro Z g h H", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX Y : C\nf : X \u27f6 Y\nhf : Epi f\n\u22a2 \u2200 {Z : D} (g h : F.obj Y \u27f6 Z), F.map f \u226b g = F.map f \u226b h \u2192 g = h", "state_after": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX Y : C\nf : X \u27f6 Y\nhf : Epi f\nZ : D\ng h : F.obj Y \u27f6 Z\nH : F.map f \u226b g = F.map f \u226b h\n\u22a2 g = h"}, {"tactic": "replace H := congr_arg (adj.homEquiv X Z) H", "annotated_tactic": ["replace H := <a>congr_arg</a> (adj.homEquiv X Z) H", [{"full_name": "congr_arg", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [72, 7], "def_end_pos": [72, 16]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX Y : C\nf : X \u27f6 Y\nhf : Epi f\nZ : D\ng h : F.obj Y \u27f6 Z\nH : F.map f \u226b g = F.map f \u226b h\n\u22a2 g = h", "state_after": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX Y : C\nf : X \u27f6 Y\nhf : Epi f\nZ : D\ng h : F.obj Y \u27f6 Z\nH : (adj.homEquiv X Z) (F.map f \u226b g) = (adj.homEquiv X Z) (F.map f \u226b h)\n\u22a2 g = h"}, {"tactic": "rwa [adj.homEquiv_naturality_left, adj.homEquiv_naturality_left, cancel_epi,\n  Equiv.apply_eq_iff_eq] at H", "annotated_tactic": ["rwa [adj.homEquiv_naturality_left, adj.homEquiv_naturality_left, <a>cancel_epi</a>,\n          <a>Equiv.apply_eq_iff_eq</a>] at H", [{"full_name": "CategoryTheory.cancel_epi", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [297, 9], "def_end_pos": [297, 19]}, {"full_name": "Equiv.apply_eq_iff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [320, 9], "def_end_pos": [320, 24]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b2 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\nE : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} E\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX Y : C\nf : X \u27f6 Y\nhf : Epi f\nZ : D\ng h : F.obj Y \u27f6 Z\nH : (adj.homEquiv X Z) (F.map f \u226b g) = (adj.homEquiv X Z) (F.map f \u226b h)\n\u22a2 g = h", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Lemmas.lean", "full_name": "Fintype.prod_dvd_of_coprime", "start": [113, 1], "end": [115, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.foldlAux_of_valid", "start": [697, 1], "end": [704, 95], "traced_tactics": [{"tactic": "unfold foldlAux", "annotated_tactic": ["unfold <a>foldlAux</a>", [{"full_name": "String.foldlAux", "def_path": ".lake/packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [435, 19], "def_end_pos": [435, 27]}]], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl r : List Char\na : \u03b1\n\u22a2 foldlAux f { data := l ++ [] ++ r } { byteIdx := utf8Len l + utf8Len [] } { byteIdx := utf8Len l } a =\n    List.foldl f a []", "state_after": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl r : List Char\na : \u03b1\n\u22a2 (if h : { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len [] } then\n      let_fun this := \u22ef;\n      foldlAux f { data := l ++ [] ++ r } { byteIdx := utf8Len l + utf8Len [] }\n        (next { data := l ++ [] ++ r } { byteIdx := utf8Len l })\n        (f a (get { data := l ++ [] ++ r } { byteIdx := utf8Len l }))\n    else a) =\n    List.foldl f a []"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl r : List Char\na : \u03b1\n\u22a2 (if h : { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len [] } then\n      let_fun this := \u22ef;\n      foldlAux f { data := l ++ [] ++ r } { byteIdx := utf8Len l + utf8Len [] }\n        (next { data := l ++ [] ++ r } { byteIdx := utf8Len l })\n        (f a (get { data := l ++ [] ++ r } { byteIdx := utf8Len l }))\n    else a) =\n    List.foldl f a []", "state_after": "no goals"}, {"tactic": "unfold foldlAux", "annotated_tactic": ["unfold <a>foldlAux</a>", [{"full_name": "String.foldlAux", "def_path": ".lake/packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [435, 19], "def_end_pos": [435, 27]}]], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl : List Char\nc : Char\nm r : List Char\na : \u03b1\n\u22a2 foldlAux f { data := l ++ c :: m ++ r } { byteIdx := utf8Len l + utf8Len (c :: m) } { byteIdx := utf8Len l } a =\n    List.foldl f a (c :: m)", "state_after": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl : List Char\nc : Char\nm r : List Char\na : \u03b1\n\u22a2 (if h : { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len (c :: m) } then\n      let_fun this := \u22ef;\n      foldlAux f { data := l ++ c :: m ++ r } { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })\n        (f a (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }))\n    else a) =\n    List.foldl f a (c :: m)"}, {"tactic": "rw [dif_pos (by exact Nat.lt_add_of_pos_right add_csize_pos)]", "annotated_tactic": ["rw [<a>dif_pos</a> (by exact <a>Nat.lt_add_of_pos_right</a> <a>add_csize_pos</a>)]", [{"full_name": "dif_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [944, 9], "def_end_pos": [944, 16]}, {"full_name": "Nat.lt_add_of_pos_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [200, 19], "def_end_pos": [200, 38]}, {"full_name": "_private.\u00ab.lake\u00bb.packages.std.Std.Data.String.Lemmas.0.String.add_csize_pos", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [44, 17], "def_end_pos": [44, 30]}]], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl : List Char\nc : Char\nm r : List Char\na : \u03b1\n\u22a2 (if h : { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len (c :: m) } then\n      let_fun this := \u22ef;\n      foldlAux f { data := l ++ c :: m ++ r } { byteIdx := utf8Len l + utf8Len (c :: m) }\n        (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })\n        (f a (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }))\n    else a) =\n    List.foldl f a (c :: m)", "state_after": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl : List Char\nc : Char\nm r : List Char\na : \u03b1\n\u22a2 (let_fun this := \u22ef;\n    foldlAux f { data := l ++ c :: m ++ r } { byteIdx := utf8Len l + utf8Len (c :: m) }\n      (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })\n      (f a (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }))) =\n    List.foldl f a (c :: m)"}, {"tactic": "simp [get_of_valid l (c::(m++r)), next_of_valid l c (m++r)]", "annotated_tactic": ["simp [<a>get_of_valid</a> l (c::(m++r)), <a>next_of_valid</a> l c (m++r)]", [{"full_name": "String.get_of_valid", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [223, 9], "def_end_pos": [223, 21]}, {"full_name": "String.next_of_valid", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [269, 9], "def_end_pos": [269, 22]}]], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl : List Char\nc : Char\nm r : List Char\na : \u03b1\n\u22a2 (let_fun this := \u22ef;\n    foldlAux f { data := l ++ c :: m ++ r } { byteIdx := utf8Len l + utf8Len (c :: m) }\n      (next { data := l ++ c :: m ++ r } { byteIdx := utf8Len l })\n      (f a (get { data := l ++ c :: m ++ r } { byteIdx := utf8Len l }))) =\n    List.foldl f a (c :: m)", "state_after": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl : List Char\nc : Char\nm r : List Char\na : \u03b1\n\u22a2 foldlAux f { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } (f a c) =\n    List.foldl f (f a c) m"}, {"tactic": "simpa [\u2190 Nat.add_assoc, Nat.add_right_comm] using foldlAux_of_valid f (l++[c]) m r (f a c)", "annotated_tactic": ["simpa [\u2190 <a>Nat.add_assoc</a>, <a>Nat.add_right_comm</a>] using foldlAux_of_valid f (l++[c]) m r (f a c)", [{"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}, {"full_name": "Nat.add_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}]], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl : List Char\nc : Char\nm r : List Char\na : \u03b1\n\u22a2 foldlAux f { data := l ++ c :: (m ++ r) } { byteIdx := utf8Len l + (utf8Len m + csize c) }\n      { byteIdx := utf8Len l + csize c } (f a c) =\n    List.foldl f (f a c) m", "state_after": "no goals"}, {"tactic": "exact Nat.lt_add_of_pos_right add_csize_pos", "annotated_tactic": ["exact <a>Nat.lt_add_of_pos_right</a> <a>add_csize_pos</a>", [{"full_name": "Nat.lt_add_of_pos_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [200, 19], "def_end_pos": [200, 38]}, {"full_name": "_private.\u00ab.lake\u00bb.packages.std.Std.Data.String.Lemmas.0.String.add_csize_pos", "def_path": ".lake/packages/std/Std/Data/String/Lemmas.lean", "def_pos": [44, 17], "def_end_pos": [44, 30]}]], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 Char \u2192 \u03b1\nl : List Char\nc : Char\nm r : List Char\na : \u03b1\n\u22a2 { byteIdx := utf8Len l } < { byteIdx := utf8Len l + utf8Len (c :: m) }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Trace.lean", "full_name": "LinearMap.trace_lie", "start": [123, 1], "end": [127, 19], "traced_tactics": [{"tactic": "rw [Ring.lie_def, map_sub, trace_mul_comm]", "annotated_tactic": ["rw [<a>Ring.lie_def</a>, <a>map_sub</a>, <a>trace_mul_comm</a>]", [{"full_name": "Ring.lie_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Commute.lean", "def_pos": [188, 9], "def_end_pos": [188, 16]}, {"full_name": "map_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [458, 3], "def_end_pos": [458, 14]}, {"full_name": "LinearMap.trace_mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Trace.lean", "def_pos": [99, 9], "def_end_pos": [99, 23]}]], "state_before": "R\u271d : Type u\ninst\u271d\u2079 : CommSemiring R\u271d\nM\u271d : Type v\ninst\u271d\u2078 : AddCommMonoid M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\n\u03b9 : Type w\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\n\u03ba : Type u_1\ninst\u271d\u2074 : DecidableEq \u03ba\ninst\u271d\u00b3 : Fintype \u03ba\nb : Basis \u03b9 R\u271d M\u271d\nc : Basis \u03ba R\u271d M\u271d\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf g : Module.End R M\n\u22a2 (trace R M) \u2045f, g\u2046 = 0", "state_after": "R\u271d : Type u\ninst\u271d\u2079 : CommSemiring R\u271d\nM\u271d : Type v\ninst\u271d\u2078 : AddCommMonoid M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\n\u03b9 : Type w\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\n\u03ba : Type u_1\ninst\u271d\u2074 : DecidableEq \u03ba\ninst\u271d\u00b3 : Fintype \u03ba\nb : Basis \u03b9 R\u271d M\u271d\nc : Basis \u03ba R\u271d M\u271d\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf g : Module.End R M\n\u22a2 (trace R M) (g * f) - (trace R M) (g * f) = 0"}, {"tactic": "exact sub_self _", "annotated_tactic": ["exact <a>sub_self</a> _", [{"full_name": "sub_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [813, 30], "def_end_pos": [813, 38]}]], "state_before": "R\u271d : Type u\ninst\u271d\u2079 : CommSemiring R\u271d\nM\u271d : Type v\ninst\u271d\u2078 : AddCommMonoid M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\n\u03b9 : Type w\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Fintype \u03b9\n\u03ba : Type u_1\ninst\u271d\u2074 : DecidableEq \u03ba\ninst\u271d\u00b3 : Fintype \u03ba\nb : Basis \u03b9 R\u271d M\u271d\nc : Basis \u03ba R\u271d M\u271d\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf g : Module.End R M\n\u22a2 (trace R M) (g * f) - (trace R M) (g * f) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Coeff.lean", "full_name": "Polynomial.coeff_C_mul", "start": [168, 1], "end": [171, 53], "traced_tactics": [{"tactic": "rcases p with \u27e8p\u27e9", "annotated_tactic": ["rcases p with \u27e8p\u27e9", []], "state_before": "R : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\n\u22a2 coeff (C a * p) n = a * coeff p n", "state_after": "case ofFinsupp\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r : R[X]\np : R[\u2115]\n\u22a2 coeff (C a * { toFinsupp := p }) n = a * coeff { toFinsupp := p } n"}, {"tactic": "simp_rw [\u2190 monomial_zero_left, \u2190 ofFinsupp_single, \u2190 ofFinsupp_mul, coeff]", "annotated_tactic": ["simp_rw [\u2190 <a>monomial_zero_left</a>, \u2190 <a>ofFinsupp_single</a>, \u2190 <a>ofFinsupp_mul</a>, <a>coeff</a>]", [{"full_name": "Polynomial.monomial_zero_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [507, 9], "def_end_pos": [507, 27]}, {"full_name": "Polynomial.ofFinsupp_single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [444, 9], "def_end_pos": [444, 25]}, {"full_name": "Polynomial.ofFinsupp_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [181, 9], "def_end_pos": [181, 22]}, {"full_name": "Polynomial.coeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [666, 5], "def_end_pos": [666, 10]}]], "state_before": "case ofFinsupp\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r : R[X]\np : R[\u2115]\n\u22a2 coeff (C a * { toFinsupp := p }) n = a * coeff { toFinsupp := p } n", "state_after": "case ofFinsupp\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r : R[X]\np : R[\u2115]\n\u22a2 (Finsupp.single 0 a * p) n = a * p n"}, {"tactic": "exact AddMonoidAlgebra.single_zero_mul_apply p a n", "annotated_tactic": ["exact <a>AddMonoidAlgebra.single_zero_mul_apply</a> p a n", [{"full_name": "AddMonoidAlgebra.single_zero_mul_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [1691, 9], "def_end_pos": [1691, 30]}]], "state_before": "case ofFinsupp\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r : R[X]\np : R[\u2115]\n\u22a2 (Finsupp.single 0 a * p) n = a * p n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "full_name": "Basis.card_le_card_of_linearIndependent", "start": [333, 1], "end": [337, 83], "traced_tactics": [{"tactic": "letI := nontrivial_of_invariantBasisNumber R", "annotated_tactic": ["letI := <a>nontrivial_of_invariantBasisNumber</a> R", [{"full_name": "nontrivial_of_invariantBasisNumber", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/InvariantBasisNumber.lean", "def_pos": [197, 9], "def_end_pos": [197, 43]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\n\u03b9\u271d : Type w\n\u03b9'\u271d : Type w'\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\nb : Basis \u03b9 R M\n\u03b9' : Type u_2\ninst\u271d : Fintype \u03b9'\nv : \u03b9' \u2192 M\nhv : LinearIndependent R v\n\u22a2 Fintype.card \u03b9' \u2264 Fintype.card \u03b9", "state_after": "R : Type u\nM : Type v\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\n\u03b9\u271d : Type w\n\u03b9'\u271d : Type w'\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\nb : Basis \u03b9 R M\n\u03b9' : Type u_2\ninst\u271d : Fintype \u03b9'\nv : \u03b9' \u2192 M\nhv : LinearIndependent R v\nthis : Nontrivial R := nontrivial_of_invariantBasisNumber R\n\u22a2 Fintype.card \u03b9' \u2264 Fintype.card \u03b9"}, {"tactic": "simpa [rank_eq_card_basis b, Cardinal.mk_fintype] using hv.cardinal_lift_le_rank", "annotated_tactic": ["simpa [<a>rank_eq_card_basis</a> b, <a>Cardinal.mk_fintype</a>] using hv.cardinal_lift_le_rank", [{"full_name": "rank_eq_card_basis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/StrongRankCondition.lean", "def_pos": [326, 9], "def_end_pos": [326, 27]}, {"full_name": "Cardinal.mk_fintype", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [461, 9], "def_end_pos": [461, 19]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\n\u03b9\u271d : Type w\n\u03b9'\u271d : Type w'\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\nb : Basis \u03b9 R M\n\u03b9' : Type u_2\ninst\u271d : Fintype \u03b9'\nv : \u03b9' \u2192 M\nhv : LinearIndependent R v\nthis : Nontrivial R := nontrivial_of_invariantBasisNumber R\n\u22a2 Fintype.card \u03b9' \u2264 Fintype.card \u03b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.lift_le", "start": [340, 1], "end": [343, 25], "traced_tactics": [{"tactic": "rw [\u2190 lift_umax]", "annotated_tactic": ["rw [\u2190 <a>lift_umax</a>]", [{"full_name": "Cardinal.lift_umax", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [202, 9], "def_end_pos": [202, 18]}]], "state_before": "\u03b1\u271d \u03b2\u271d : Type u\na b : Cardinal.{v}\n\u03b1 \u03b2 : Type v\n\u22a2 lift.{u, v} #\u03b1 \u2264 lift.{u, v} #\u03b2 \u2194 #\u03b1 \u2264 #\u03b2", "state_after": "\u03b1\u271d \u03b2\u271d : Type u\na b : Cardinal.{v}\n\u03b1 \u03b2 : Type v\n\u22a2 lift.{max v u, v} #\u03b1 \u2264 lift.{max v u, v} #\u03b2 \u2194 #\u03b1 \u2264 #\u03b2"}, {"tactic": "exact lift_mk_le.{u}", "annotated_tactic": ["exact <a>lift_mk_le</a>.{u}", [{"full_name": "Cardinal.lift_mk_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [310, 9], "def_end_pos": [310, 19]}]], "state_before": "\u03b1\u271d \u03b2\u271d : Type u\na b : Cardinal.{v}\n\u03b1 \u03b2 : Type v\n\u22a2 lift.{max v u, v} #\u03b1 \u2264 lift.{max v u, v} #\u03b2 \u2194 #\u03b1 \u2264 #\u03b2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "LinearIndependent.coe_range", "start": [249, 1], "end": [250, 100], "traced_tactics": [{"tactic": "simpa using i.comp _ (rangeSplitting_injective v)", "annotated_tactic": ["simpa using i.comp _ (<a>rangeSplitting_injective</a> v)", [{"full_name": "Set.rangeSplitting_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1143, 9], "def_end_pos": [1143, 33]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\ni : LinearIndependent R v\n\u22a2 LinearIndependent (\u03b9 := { x // x \u2208 range v }) R Subtype.val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.eval\u2082_X", "start": [73, 1], "end": [73, 60], "traced_tactics": [{"tactic": "simp [eval\u2082_eq_sum]", "annotated_tactic": ["simp [<a>eval\u2082_eq_sum</a>]", [{"full_name": "Polynomial.eval\u2082_eq_sum", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [48, 9], "def_end_pos": [48, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q r : R[X]\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\n\u22a2 eval\u2082 f x X = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Interval.lean", "full_name": "Nat.image_Ico_mod", "start": [299, 1], "end": [322, 59], "traced_tactics": [{"tactic": "obtain rfl | ha := eq_or_ne a 0", "annotated_tactic": ["obtain rfl | ha := <a>eq_or_ne</a> a 0", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "a\u271d b c n a : \u2115\n\u22a2 image (fun x => x % a) (Ico n (n + a)) = range a", "state_after": "case inl\na b c n : \u2115\n\u22a2 image (fun x => x % 0) (Ico n (n + 0)) = range 0\n\ncase inr\na\u271d b c n a : \u2115\nha : a \u2260 0\n\u22a2 image (fun x => x % a) (Ico n (n + a)) = range a"}, {"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "case inr\na\u271d b c n a : \u2115\nha : a \u2260 0\n\u22a2 image (fun x => x % a) (Ico n (n + a)) = range a", "state_after": "case inr.a\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\n\u22a2 i \u2208 image (fun x => x % a) (Ico n (n + a)) \u2194 i \u2208 range a"}, {"tactic": "simp only [mem_image, exists_prop, mem_range, mem_Ico]", "annotated_tactic": ["simp only [<a>mem_image</a>, <a>exists_prop</a>, <a>mem_range</a>, <a>mem_Ico</a>]", [{"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "Finset.mem_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3127, 9], "def_end_pos": [3127, 18]}, {"full_name": "Finset.mem_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [332, 9], "def_end_pos": [332, 16]}]], "state_before": "case inr.a\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\n\u22a2 i \u2208 image (fun x => x % a) (Ico n (n + a)) \u2194 i \u2208 range a", "state_after": "case inr.a\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\n\u22a2 (\u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i) \u2194 i < a"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case inr.a\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\n\u22a2 (\u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i) \u2194 i < a", "state_after": "case inr.a.mp\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\n\u22a2 (\u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i) \u2192 i < a\n\ncase inr.a.mpr\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\n\u22a2 i < a \u2192 \u2203 a_2, (n \u2264 a_2 \u2227 a_2 < n + a) \u2227 a_2 % a = i"}, {"tactic": "intro hia", "annotated_tactic": ["intro hia", []], "state_before": "case inr.a.mpr\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\n\u22a2 i < a \u2192 \u2203 a_2, (n \u2264 a_2 \u2227 a_2 < n + a) \u2227 a_2 % a = i", "state_after": "case inr.a.mpr\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\n\u22a2 \u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i"}, {"tactic": "have hn := Nat.mod_add_div n a", "annotated_tactic": ["have hn := <a>Nat.mod_add_div</a> n a", [{"full_name": "Nat.mod_add_div", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "case inr.a.mpr\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\n\u22a2 \u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i", "state_after": "case inr.a.mpr\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\n\u22a2 \u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i"}, {"tactic": "obtain hi | hi := lt_or_le i (n % a)", "annotated_tactic": ["obtain hi | hi := <a>lt_or_le</a> i (n % a)", [{"full_name": "lt_or_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [330, 9], "def_end_pos": [330, 17]}]], "state_before": "case inr.a.mpr\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\n\u22a2 \u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i", "state_after": "case inr.a.mpr.inl\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 \u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i\n\ncase inr.a.mpr.inr\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 \u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i"}, {"tactic": "rw [range_zero, add_zero, Ico_self, image_empty]", "annotated_tactic": ["rw [<a>range_zero</a>, <a>add_zero</a>, <a>Ico_self</a>, <a>image_empty</a>]", [{"full_name": "Finset.range_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3137, 9], "def_end_pos": [3137, 19]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "Finset.Ico_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/LocallyFinite/Basic.lean", "def_pos": [291, 9], "def_end_pos": [291, 17]}, {"full_name": "Finset.image_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [354, 9], "def_end_pos": [354, 20]}]], "state_before": "case inl\na b c n : \u2115\n\u22a2 image (fun x => x % 0) (Ico n (n + 0)) = range 0", "state_after": "no goals"}, {"tactic": "rintro \u27e8i, _, rfl\u27e9", "annotated_tactic": ["rintro \u27e8i, _, rfl\u27e9", []], "state_before": "case inr.a.mp\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\n\u22a2 (\u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i) \u2192 i < a", "state_after": "case inr.a.mp.intro.intro\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nleft\u271d : n \u2264 i \u2227 i < n + a\n\u22a2 i % a < a"}, {"tactic": "exact mod_lt i ha.bot_lt", "annotated_tactic": ["exact <a>mod_lt</a> i ha.bot_lt", [{"full_name": "Nat.mod_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [123, 9], "def_end_pos": [123, 15]}]], "state_before": "case inr.a.mp.intro.intro\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nleft\u271d : n \u2264 i \u2227 i < n + a\n\u22a2 i % a < a", "state_after": "no goals"}, {"tactic": "refine' \u27e8i + a * (n / a + 1), \u27e8_, _\u27e9, _\u27e9", "annotated_tactic": ["refine' \u27e8i + a * (n / a + 1), \u27e8_, _\u27e9, _\u27e9", []], "state_before": "case inr.a.mpr.inl\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 \u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i", "state_after": "case inr.a.mpr.inl.refine'_1\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 n \u2264 i + a * (n / a + 1)\n\ncase inr.a.mpr.inl.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 i + a * (n / a + 1) < n + a\n\ncase inr.a.mpr.inl.refine'_3\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 (i + a * (n / a + 1)) % a = i"}, {"tactic": "rw [add_comm (n / a), mul_add, mul_one, \u2190 add_assoc]", "annotated_tactic": ["rw [<a>add_comm</a> (n / a), <a>mul_add</a>, <a>mul_one</a>, \u2190 <a>add_assoc</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}]], "state_before": "case inr.a.mpr.inl.refine'_1\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 n \u2264 i + a * (n / a + 1)", "state_after": "case inr.a.mpr.inl.refine'_1\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 n \u2264 i + a + a * (n / a)"}, {"tactic": "refine' hn.symm.le.trans (add_le_add_right _ _)", "annotated_tactic": ["refine' hn.symm.le.trans (<a>add_le_add_right</a> _ _)", [{"full_name": "add_le_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [66, 32], "def_end_pos": [66, 48]}]], "state_before": "case inr.a.mpr.inl.refine'_1\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 n \u2264 i + a + a * (n / a)", "state_after": "case inr.a.mpr.inl.refine'_1\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 n % a \u2264 i + a"}, {"tactic": "simpa only [zero_add] using add_le_add (zero_le i) (Nat.mod_lt n ha.bot_lt).le", "annotated_tactic": ["simpa only [<a>zero_add</a>] using <a>add_le_add</a> (<a>zero_le</a> i) (<a>Nat.mod_lt</a> n ha.bot_lt).<a>le</a>", [{"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}, {"full_name": "Nat.add_le_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [434, 9], "def_end_pos": [434, 19]}, {"full_name": "Nat.zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1644, 9], "def_end_pos": [1644, 20]}, {"full_name": "Nat.mod_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [123, 9], "def_end_pos": [123, 15]}, {"full_name": "LT.lt.le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [139, 7], "def_end_pos": [139, 15]}]], "state_before": "case inr.a.mpr.inl.refine'_1\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 n % a \u2264 i + a", "state_after": "no goals"}, {"tactic": "refine' lt_of_lt_of_le (add_lt_add_right hi (a * (n / a + 1))) _", "annotated_tactic": ["refine' <a>lt_of_lt_of_le</a> (<a>add_lt_add_right</a> hi (a * (n / a + 1))) _", [{"full_name": "lt_of_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [109, 9], "def_end_pos": [109, 23]}, {"full_name": "add_lt_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [135, 32], "def_end_pos": [135, 48]}]], "state_before": "case inr.a.mpr.inl.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 i + a * (n / a + 1) < n + a", "state_after": "case inr.a.mpr.inl.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 n % a + a * (n / a + 1) \u2264 n + a"}, {"tactic": "rw [mul_add, mul_one, \u2190 add_assoc, hn]", "annotated_tactic": ["rw [<a>mul_add</a>, <a>mul_one</a>, \u2190 <a>add_assoc</a>, hn]", [{"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}]], "state_before": "case inr.a.mpr.inl.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 n % a + a * (n / a + 1) \u2264 n + a", "state_after": "no goals"}, {"tactic": "rw [Nat.add_mul_mod_self_left, Nat.mod_eq_of_lt hia]", "annotated_tactic": ["rw [<a>Nat.add_mul_mod_self_left</a>, <a>Nat.mod_eq_of_lt</a> hia]", [{"full_name": "Nat.add_mul_mod_self_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [235, 17], "def_end_pos": [235, 38]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}]], "state_before": "case inr.a.mpr.inl.refine'_3\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : i < n % a\n\u22a2 (i + a * (n / a + 1)) % a = i", "state_after": "no goals"}, {"tactic": "refine' \u27e8i + a * (n / a), \u27e8_, _\u27e9, _\u27e9", "annotated_tactic": ["refine' \u27e8i + a * (n / a), \u27e8_, _\u27e9, _\u27e9", []], "state_before": "case inr.a.mpr.inr\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 \u2203 a_1, (n \u2264 a_1 \u2227 a_1 < n + a) \u2227 a_1 % a = i", "state_after": "case inr.a.mpr.inr.refine'_1\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 n \u2264 i + a * (n / a)\n\ncase inr.a.mpr.inr.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 i + a * (n / a) < n + a\n\ncase inr.a.mpr.inr.refine'_3\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 (i + a * (n / a)) % a = i"}, {"tactic": "exact hn.symm.le.trans (add_le_add_right hi _)", "annotated_tactic": ["exact hn.symm.le.trans (<a>add_le_add_right</a> hi _)", [{"full_name": "add_le_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [66, 32], "def_end_pos": [66, 48]}]], "state_before": "case inr.a.mpr.inr.refine'_1\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 n \u2264 i + a * (n / a)", "state_after": "no goals"}, {"tactic": "rw [add_comm n a]", "annotated_tactic": ["rw [<a>add_comm</a> n a]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "case inr.a.mpr.inr.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 i + a * (n / a) < n + a", "state_after": "case inr.a.mpr.inr.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 i + a * (n / a) < a + n"}, {"tactic": "refine' add_lt_add_of_lt_of_le hia (le_trans _ hn.le)", "annotated_tactic": ["refine' <a>add_lt_add_of_lt_of_le</a> hia (<a>le_trans</a> _ hn.le)", [{"full_name": "add_lt_add_of_lt_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [178, 3], "def_end_pos": [178, 14]}, {"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}]], "state_before": "case inr.a.mpr.inr.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 i + a * (n / a) < a + n", "state_after": "case inr.a.mpr.inr.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 a * (n / a) \u2264 n % a + a * (n / a)"}, {"tactic": "simp only [zero_le, le_add_iff_nonneg_left]", "annotated_tactic": ["simp only [<a>zero_le</a>, <a>le_add_iff_nonneg_left</a>]", [{"full_name": "Nat.zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1644, 9], "def_end_pos": [1644, 20]}, {"full_name": "le_add_iff_nonneg_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [465, 30], "def_end_pos": [465, 52]}]], "state_before": "case inr.a.mpr.inr.refine'_2\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 a * (n / a) \u2264 n % a + a * (n / a)", "state_after": "no goals"}, {"tactic": "rw [Nat.add_mul_mod_self_left, Nat.mod_eq_of_lt hia]", "annotated_tactic": ["rw [<a>Nat.add_mul_mod_self_left</a>, <a>Nat.mod_eq_of_lt</a> hia]", [{"full_name": "Nat.add_mul_mod_self_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [235, 17], "def_end_pos": [235, 38]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}]], "state_before": "case inr.a.mpr.inr.refine'_3\na\u271d b c n a : \u2115\nha : a \u2260 0\ni : \u2115\nhia : i < a\nhn : n % a + a * (n / a) = n\nhi : n % a \u2264 i\n\u22a2 (i + a * (n / a)) % a = i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Powerset.lean", "full_name": "Finset.univ_filter_card_eq", "start": [49, 1], "end": [50, 97], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nk\u271d k : \u2115\n\u22a2 filter (fun s => s.card = k) univ = powersetCard k univ", "state_after": "case a\n\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nk\u271d k : \u2115\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 filter (fun s => s.card = k) univ \u2194 a\u271d \u2208 powersetCard k univ"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nk\u271d k : \u2115\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 filter (fun s => s.card = k) univ \u2194 a\u271d \u2208 powersetCard k univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean", "full_name": "sub_one_mul_padicValNat_choose_eq_sub_sum_digits'", "start": [722, 1], "end": [733, 88], "traced_tactics": [{"tactic": "have h : k \u2264 n + k := by exact Nat.le_add_left k n", "annotated_tactic": ["have h : k \u2264 n + k := by exact <a>Nat.le_add_left</a> k n", [{"full_name": "Nat.le_add_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [337, 9], "def_end_pos": [337, 20]}]], "state_before": "p k n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 (p - 1) * padicValNat p (choose (n + k) k) =\n    List.sum (digits p k) + List.sum (digits p n) - List.sum (digits p (n + k))", "state_after": "p k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n + k\n\u22a2 (p - 1) * padicValNat p (choose (n + k) k) =\n    List.sum (digits p k) + List.sum (digits p n) - List.sum (digits p (n + k))"}, {"tactic": "simp only [Nat.choose_eq_factorial_div_factorial h]", "annotated_tactic": ["simp only [<a>Nat.choose_eq_factorial_div_factorial</a> h]", [{"full_name": "Nat.choose_eq_factorial_div_factorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [168, 9], "def_end_pos": [168, 42]}]], "state_before": "p k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n + k\n\u22a2 (p - 1) * padicValNat p (choose (n + k) k) =\n    List.sum (digits p k) + List.sum (digits p n) - List.sum (digits p (n + k))", "state_after": "p k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n + k\n\u22a2 (p - 1) * padicValNat p ((n + k)! / (k ! * (n + k - k)!)) =\n    List.sum (digits p k) + List.sum (digits p n) - List.sum (digits p (n + k))"}, {"tactic": "rw [padicValNat.div_of_dvd <| factorial_mul_factorial_dvd_factorial h, Nat.mul_sub_left_distrib,\n    padicValNat.mul (factorial_ne_zero _) (factorial_ne_zero _), Nat.mul_add]", "annotated_tactic": ["rw [<a>padicValNat.div_of_dvd</a> <| <a>factorial_mul_factorial_dvd_factorial</a> h, <a>Nat.mul_sub_left_distrib</a>,\n      <a>padicValNat.mul</a> (<a>factorial_ne_zero</a> _) (<a>factorial_ne_zero</a> _), <a>Nat.mul_add</a>]", [{"full_name": "padicValNat.div_of_dvd", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [512, 19], "def_end_pos": [512, 29]}, {"full_name": "Nat.factorial_mul_factorial_dvd_factorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [184, 9], "def_end_pos": [184, 46]}, {"full_name": "Nat.mul_sub_left_distrib", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [808, 19], "def_end_pos": [808, 39]}, {"full_name": "padicValNat.mul", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [508, 19], "def_end_pos": [508, 22]}, {"full_name": "Nat.factorial_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [68, 9], "def_end_pos": [68, 26]}, {"full_name": "Nat.factorial_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [68, 9], "def_end_pos": [68, 26]}, {"full_name": "Nat.mul_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [199, 19], "def_end_pos": [199, 26]}]], "state_before": "p k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n + k\n\u22a2 (p - 1) * padicValNat p ((n + k)! / (k ! * (n + k - k)!)) =\n    List.sum (digits p k) + List.sum (digits p n) - List.sum (digits p (n + k))", "state_after": "p k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n + k\n\u22a2 (p - 1) * padicValNat p (n + k)! - ((p - 1) * padicValNat p k ! + (p - 1) * padicValNat p (n + k - k)!) =\n    List.sum (digits p k) + List.sum (digits p n) - List.sum (digits p (n + k))"}, {"tactic": "simp only [sub_one_mul_padicValNat_factorial]", "annotated_tactic": ["simp only [<a>sub_one_mul_padicValNat_factorial</a>]", [{"full_name": "sub_one_mul_padicValNat_factorial", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [691, 9], "def_end_pos": [691, 42]}]], "state_before": "p k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n + k\n\u22a2 (p - 1) * padicValNat p (n + k)! - ((p - 1) * padicValNat p k ! + (p - 1) * padicValNat p (n + k - k)!) =\n    List.sum (digits p k) + List.sum (digits p n) - List.sum (digits p (n + k))", "state_after": "p k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n + k\n\u22a2 n + k - List.sum (digits p (n + k)) - (k - List.sum (digits p k) + (n + k - k - List.sum (digits p (n + k - k)))) =\n    List.sum (digits p k) + List.sum (digits p n) - List.sum (digits p (n + k))"}, {"tactic": "rw [\u2190 Nat.sub_add_comm <| digit_sum_le p k, Nat.add_sub_cancel n k, \u2190 Nat.add_sub_assoc <|\n    digit_sum_le p n, Nat.sub_sub (k + n), \u2190 Nat.sub_right_comm, Nat.sub_sub, sub_add_eq,\n    add_comm, tsub_tsub_assoc (Nat.le_refl (k + n)) <| (add_comm k n) \u25b8 (Nat.add_le_add\n    (digit_sum_le p n) (digit_sum_le p k)), Nat.sub_self (k + n), zero_add, add_comm]", "annotated_tactic": ["rw [\u2190 <a>Nat.sub_add_comm</a> <| <a>digit_sum_le</a> p k, <a>Nat.add_sub_cancel</a> n k, \u2190 <a>Nat.add_sub_assoc</a> <|\n      <a>digit_sum_le</a> p n, <a>Nat.sub_sub</a> (k + n), \u2190 <a>Nat.sub_right_comm</a>, <a>Nat.sub_sub</a>, <a>sub_add_eq</a>,\n      <a>add_comm</a>, <a>tsub_tsub_assoc</a> (<a>Nat.le_refl</a> (k + n)) <| (<a>add_comm</a> k n) \u25b8 (<a>Nat.add_le_add</a>\n      (<a>digit_sum_le</a> p n) (<a>digit_sum_le</a> p k)), <a>Nat.sub_self</a> (k + n), <a>zero_add</a>, <a>add_comm</a>]", [{"full_name": "Nat.sub_add_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [255, 19], "def_end_pos": [255, 31]}, {"full_name": "Nat.digit_sum_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [473, 9], "def_end_pos": [473, 21]}, {"full_name": "Nat.add_sub_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [635, 27], "def_end_pos": [635, 41]}, {"full_name": "Nat.add_sub_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [643, 19], "def_end_pos": [643, 32]}, {"full_name": "Nat.digit_sum_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [473, 9], "def_end_pos": [473, 21]}, {"full_name": "Nat.sub_sub", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [740, 19], "def_end_pos": [740, 26]}, {"full_name": "Nat.sub_right_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [238, 19], "def_end_pos": [238, 33]}, {"full_name": "Nat.sub_sub", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [740, 19], "def_end_pos": [740, 26]}, {"full_name": "Nat.sub_add_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [257, 9], "def_end_pos": [257, 19]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "tsub_tsub_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [222, 9], "def_end_pos": [222, 24]}, {"full_name": "Nat.le_refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1671, 19], "def_end_pos": [1671, 30]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "Nat.add_le_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [434, 9], "def_end_pos": [434, 19]}, {"full_name": "Nat.digit_sum_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [473, 9], "def_end_pos": [473, 21]}, {"full_name": "Nat.digit_sum_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [473, 9], "def_end_pos": [473, 21]}, {"full_name": "Nat.sub_self", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [253, 27], "def_end_pos": [253, 35]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "p k n : \u2115\nhp : Fact (Nat.Prime p)\nh : k \u2264 n + k\n\u22a2 n + k - List.sum (digits p (n + k)) - (k - List.sum (digits p k) + (n + k - k - List.sum (digits p (n + k - k)))) =\n    List.sum (digits p k) + List.sum (digits p n) - List.sum (digits p (n + k))", "state_after": "no goals"}, {"tactic": "exact Nat.le_add_left k n", "annotated_tactic": ["exact <a>Nat.le_add_left</a> k n", [{"full_name": "Nat.le_add_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [337, 9], "def_end_pos": [337, 20]}]], "state_before": "p k n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 k \u2264 n + k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "SupHom.const_apply", "start": [476, 1], "end": [477, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/EditDistance/Defs.lean", "full_name": "Levenshtein.impl_cons", "start": [111, 1], "end": [115, 39], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\ninst\u271d\u00b9 : AddZeroClass \u03b4\ninst\u271d : Min \u03b4\nC : Cost \u03b1 \u03b2 \u03b4\nx : \u03b1\nxs : List \u03b1\ny : \u03b2\nd : \u03b4\nds : List \u03b4\nw\u271d : 0 < List.length (d :: ds)\nw' : 0 < List.length ds\nr : List \u03b4\nw : 0 < List.length r\n\u22a2 0 < List.length (min (C.delete x + r[0]) (min (C.insert y + d) (C.substitute x y + ds[0])) :: r)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.eq_div_of_mul_eq_right", "start": [496, 11], "end": [498, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.replicate_le_replicate", "start": [1005, 1], "end": [1006, 96], "traced_tactics": [{"tactic": "rw [\u2190 replicate_le_coe, coe_replicate]", "annotated_tactic": ["rw [\u2190 <a>replicate_le_coe</a>, <a>coe_replicate</a>]", [{"full_name": "Multiset.replicate_le_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [993, 9], "def_end_pos": [993, 25]}, {"full_name": "Multiset.coe_replicate", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [925, 9], "def_end_pos": [925, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\nk n : \u2115\n\u22a2 replicate k a \u2264 replicate n a \u2194 List.replicate k a <+ List.replicate n a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bases.lean", "full_name": "TopologicalSpace.IsTopologicalBasis.exists_subset_of_mem_open", "start": [176, 1], "end": [178, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Conformal/NormedSpace.lean", "full_name": "ConformalAt.comp", "start": [98, 1], "end": [102, 49], "traced_tactics": [{"tactic": "rcases hf with \u27e8f', hf\u2081, cf\u27e9", "annotated_tactic": ["rcases hf with \u27e8f', hf\u2081, cf\u27e9", []], "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup X\ninst\u271d\u2074 : NormedAddCommGroup Y\ninst\u271d\u00b3 : NormedAddCommGroup Z\ninst\u271d\u00b2 : NormedSpace \u211d X\ninst\u271d\u00b9 : NormedSpace \u211d Y\ninst\u271d : NormedSpace \u211d Z\nf : X \u2192 Y\ng : Y \u2192 Z\nx : X\nhg : ConformalAt g (f x)\nhf : ConformalAt f x\n\u22a2 ConformalAt (g \u2218 f) x", "state_after": "case intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup X\ninst\u271d\u2074 : NormedAddCommGroup Y\ninst\u271d\u00b3 : NormedAddCommGroup Z\ninst\u271d\u00b2 : NormedSpace \u211d X\ninst\u271d\u00b9 : NormedSpace \u211d Y\ninst\u271d : NormedSpace \u211d Z\nf : X \u2192 Y\ng : Y \u2192 Z\nx : X\nhg : ConformalAt g (f x)\nf' : X \u2192L[\u211d] Y\nhf\u2081 : HasFDerivAt f f' x\ncf : IsConformalMap f'\n\u22a2 ConformalAt (g \u2218 f) x"}, {"tactic": "rcases hg with \u27e8g', hg\u2081, cg\u27e9", "annotated_tactic": ["rcases hg with \u27e8g', hg\u2081, cg\u27e9", []], "state_before": "case intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup X\ninst\u271d\u2074 : NormedAddCommGroup Y\ninst\u271d\u00b3 : NormedAddCommGroup Z\ninst\u271d\u00b2 : NormedSpace \u211d X\ninst\u271d\u00b9 : NormedSpace \u211d Y\ninst\u271d : NormedSpace \u211d Z\nf : X \u2192 Y\ng : Y \u2192 Z\nx : X\nhg : ConformalAt g (f x)\nf' : X \u2192L[\u211d] Y\nhf\u2081 : HasFDerivAt f f' x\ncf : IsConformalMap f'\n\u22a2 ConformalAt (g \u2218 f) x", "state_after": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup X\ninst\u271d\u2074 : NormedAddCommGroup Y\ninst\u271d\u00b3 : NormedAddCommGroup Z\ninst\u271d\u00b2 : NormedSpace \u211d X\ninst\u271d\u00b9 : NormedSpace \u211d Y\ninst\u271d : NormedSpace \u211d Z\nf : X \u2192 Y\ng : Y \u2192 Z\nx : X\nf' : X \u2192L[\u211d] Y\nhf\u2081 : HasFDerivAt f f' x\ncf : IsConformalMap f'\ng' : Y \u2192L[\u211d] Z\nhg\u2081 : HasFDerivAt g g' (f x)\ncg : IsConformalMap g'\n\u22a2 ConformalAt (g \u2218 f) x"}, {"tactic": "exact \u27e8g'.comp f', hg\u2081.comp x hf\u2081, cg.comp cf\u27e9", "annotated_tactic": ["exact \u27e8g'.comp f', hg\u2081.comp x hf\u2081, cg.comp cf\u27e9", []], "state_before": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup X\ninst\u271d\u2074 : NormedAddCommGroup Y\ninst\u271d\u00b3 : NormedAddCommGroup Z\ninst\u271d\u00b2 : NormedSpace \u211d X\ninst\u271d\u00b9 : NormedSpace \u211d Y\ninst\u271d : NormedSpace \u211d Z\nf : X \u2192 Y\ng : Y \u2192 Z\nx : X\nf' : X \u2192L[\u211d] Y\nhf\u2081 : HasFDerivAt f f' x\ncf : IsConformalMap f'\ng' : Y \u2192L[\u211d] Z\nhg\u2081 : HasFDerivAt g g' (f x)\ncg : IsConformalMap g'\n\u22a2 ConformalAt (g \u2218 f) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.mem_iInf\u2082_iff", "start": [688, 1], "end": [689, 25], "traced_tactics": [{"tactic": "simp_rw [mem_iInf_iff]", "annotated_tactic": ["simp_rw [<a>mem_iInf_iff</a>]", [{"full_name": "UpperSet.mem_iInf_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/UpperLower/Basic.lean", "def_pos": [677, 9], "def_end_pos": [677, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nS : Set (UpperSet \u03b1)\ns t : UpperSet \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 UpperSet \u03b1\n\u22a2 a \u2208 \u2a05 i, \u2a05 j, f i j \u2194 \u2203 i j, a \u2208 f i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/NhdsSet.lean", "full_name": "nhdsSet_union", "start": [155, 1], "end": [156, 47], "traced_tactics": [{"tactic": "simp only [nhdsSet, image_union, sSup_union]", "annotated_tactic": ["simp only [<a>nhdsSet</a>, <a>image_union</a>, <a>sSup_union</a>]", [{"full_name": "nhdsSet", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [147, 5], "def_end_pos": [147, 12]}, {"full_name": "Set.image_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [302, 9], "def_end_pos": [302, 20]}, {"full_name": "sSup_union", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [406, 9], "def_end_pos": [406, 19]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : Filter X\ns\u271d t\u271d s\u2081 s\u2082 t\u2081 t\u2082 : Set X\nx : X\ns t : Set X\n\u22a2 \ud835\udcdd\u02e2 (s \u222a t) = \ud835\udcdd\u02e2 s \u2294 \ud835\udcdd\u02e2 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Bounded.lean", "full_name": "Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt", "start": [262, 1], "end": [273, 74], "traced_tactics": [{"tactic": "have : Disjoint (\ud835\udcdd\u02e2 k \u2293 \ud835\udcdf s) (comap f (cobounded \u03b1)) := by\n  rw [disjoint_assoc, inf_comm, hk.disjoint_nhdsSet_left]\n  exact fun x hx \u21a6 disjoint_left_comm.2 <|\n    tendsto_comap.disjoint (disjoint_cobounded_nhds _) (hf x hx)", "annotated_tactic": ["have : <a>Disjoint</a> (\ud835\udcdd\u02e2 k \u2293 \ud835\udcdf s) (<a>comap</a> f (<a>cobounded</a> \u03b1)) := by\n    rw [<a>disjoint_assoc</a>, <a>inf_comm</a>, hk.disjoint_nhdsSet_left]\n    exact fun x hx \u21a6 <a>disjoint_left_comm</a>.2 <|\n      tendsto_comap.disjoint (<a>disjoint_cobounded_nhds</a> _) (hf x hx)", [{"full_name": "Disjoint", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [42, 5], "def_end_pos": [42, 13]}, {"full_name": "Filter.comap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2013, 5], "def_end_pos": [2013, 10]}, {"full_name": "Bornology.cobounded", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bornology/Basic.lean", "def_pos": [64, 5], "def_end_pos": [64, 24]}, {"full_name": "disjoint_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [147, 9], "def_end_pos": [147, 23]}, {"full_name": "inf_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [465, 9], "def_end_pos": [465, 17]}, {"full_name": "disjoint_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [151, 9], "def_end_pos": [151, 27]}, {"full_name": "Metric.disjoint_cobounded_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Bounded.lean", "def_pos": [246, 9], "def_end_pos": [246, 32]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\n\u22a2 \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' (t \u2229 s))", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\nthis : Disjoint (\ud835\udcdd\u02e2 k \u2293 \ud835\udcdf s) (comap f (cobounded \u03b1))\n\u22a2 \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' (t \u2229 s))"}, {"tactic": "rcases ((((hasBasis_nhdsSet _).inf_principal _)).disjoint_iff ((basis_sets _).comap _)).1 this\n  with \u27e8U, \u27e8hUo, hkU\u27e9, t, ht, hd\u27e9", "annotated_tactic": ["rcases ((((<a>hasBasis_nhdsSet</a> _).<a>inf_principal</a> _)).<a>disjoint_iff</a> ((<a>basis_sets</a> _).<a>comap</a> _)).1 this\n    with \u27e8U, \u27e8hUo, hkU\u27e9, t, ht, hd\u27e9", [{"full_name": "hasBasis_nhdsSet", "def_path": ".lake/packages/mathlib/Mathlib/Topology/NhdsSet.lean", "def_pos": [78, 9], "def_end_pos": [78, 25]}, {"full_name": "Filter.HasBasis.inf_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [633, 9], "def_end_pos": [633, 31]}, {"full_name": "Filter.HasBasis.disjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [660, 9], "def_end_pos": [660, 30]}, {"full_name": "Filter.basis_sets", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [411, 9], "def_end_pos": [411, 19]}, {"full_name": "Filter.HasBasis.comap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [808, 9], "def_end_pos": [808, 23]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\nthis : Disjoint (\ud835\udcdd\u02e2 k \u2293 \ud835\udcdf s) (comap f (cobounded \u03b1))\n\u22a2 \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' (t \u2229 s))", "state_after": "case intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t\u271d : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\nthis : Disjoint (\ud835\udcdd\u02e2 k \u2293 \ud835\udcdf s) (comap f (cobounded \u03b1))\nU : Set \u03b2\nhUo : IsOpen U\nhkU : k \u2286 U\nt : Set \u03b1\nht : t \u2208 cobounded \u03b1\nhd : Disjoint (U \u2229 s) (f \u207b\u00b9' id t)\n\u22a2 \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' (t \u2229 s))"}, {"tactic": "refine \u27e8U, hkU, hUo, (isBounded_compl_iff.2 ht).subset ?_\u27e9", "annotated_tactic": ["refine \u27e8U, hkU, hUo, (<a>isBounded_compl_iff</a>.2 ht).<a>subset</a> ?_\u27e9", [{"full_name": "Bornology.isBounded_compl_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bornology/Basic.lean", "def_pos": [143, 9], "def_end_pos": [143, 28]}, {"full_name": "Bornology.IsBounded.subset", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Bornology/Basic.lean", "def_pos": [210, 9], "def_end_pos": [210, 25]}]], "state_before": "case intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t\u271d : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\nthis : Disjoint (\ud835\udcdd\u02e2 k \u2293 \ud835\udcdf s) (comap f (cobounded \u03b1))\nU : Set \u03b2\nhUo : IsOpen U\nhkU : k \u2286 U\nt : Set \u03b1\nht : t \u2208 cobounded \u03b1\nhd : Disjoint (U \u2229 s) (f \u207b\u00b9' id t)\n\u22a2 \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' (t \u2229 s))", "state_after": "case intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t\u271d : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\nthis : Disjoint (\ud835\udcdd\u02e2 k \u2293 \ud835\udcdf s) (comap f (cobounded \u03b1))\nU : Set \u03b2\nhUo : IsOpen U\nhkU : k \u2286 U\nt : Set \u03b1\nht : t \u2208 cobounded \u03b1\nhd : Disjoint (U \u2229 s) (f \u207b\u00b9' id t)\n\u22a2 f '' (U \u2229 s) \u2286 t\u1d9c"}, {"tactic": "rwa [image_subset_iff, preimage_compl, subset_compl_iff_disjoint_right]", "annotated_tactic": ["rwa [<a>image_subset_iff</a>, <a>preimage_compl</a>, <a>subset_compl_iff_disjoint_right</a>]", [{"full_name": "Set.image_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [480, 9], "def_end_pos": [480, 25]}, {"full_name": "Set.preimage_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [84, 9], "def_end_pos": [84, 23]}, {"full_name": "Set.subset_compl_iff_disjoint_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1747, 9], "def_end_pos": [1747, 40]}]], "state_before": "case intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t\u271d : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\nthis : Disjoint (\ud835\udcdd\u02e2 k \u2293 \ud835\udcdf s) (comap f (cobounded \u03b1))\nU : Set \u03b2\nhUo : IsOpen U\nhkU : k \u2286 U\nt : Set \u03b1\nht : t \u2208 cobounded \u03b1\nhd : Disjoint (U \u2229 s) (f \u207b\u00b9' id t)\n\u22a2 f '' (U \u2229 s) \u2286 t\u1d9c", "state_after": "no goals"}, {"tactic": "rw [disjoint_assoc, inf_comm, hk.disjoint_nhdsSet_left]", "annotated_tactic": ["rw [<a>disjoint_assoc</a>, <a>inf_comm</a>, hk.disjoint_nhdsSet_left]", [{"full_name": "disjoint_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [147, 9], "def_end_pos": [147, 23]}, {"full_name": "inf_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [465, 9], "def_end_pos": [465, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\n\u22a2 Disjoint (\ud835\udcdd\u02e2 k \u2293 \ud835\udcdf s) (comap f (cobounded \u03b1))", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\n\u22a2 \u2200 x \u2208 k, Disjoint (\ud835\udcdd x) (comap f (cobounded \u03b1) \u2293 \ud835\udcdf s)"}, {"tactic": "exact fun x hx \u21a6 disjoint_left_comm.2 <|\n  tendsto_comap.disjoint (disjoint_cobounded_nhds _) (hf x hx)", "annotated_tactic": ["exact fun x hx \u21a6 <a>disjoint_left_comm</a>.2 <|\n      tendsto_comap.disjoint (<a>disjoint_cobounded_nhds</a> _) (hf x hx)", [{"full_name": "disjoint_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [151, 9], "def_end_pos": [151, 27]}, {"full_name": "Metric.disjoint_cobounded_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Bounded.lean", "def_pos": [246, 9], "def_end_pos": [246, 32]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nx : \u03b1\ns\u271d t : Set \u03b1\nr : \u211d\ninst\u271d : TopologicalSpace \u03b2\nk s : Set \u03b2\nf : \u03b2 \u2192 \u03b1\nhk : IsCompact k\nhf : \u2200 x \u2208 k, ContinuousWithinAt f s x\n\u22a2 \u2200 x \u2208 k, Disjoint (\ud835\udcdd x) (comap f (cobounded \u03b1) \u2293 \ud835\udcdf s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Regular/SMul.lean", "full_name": "IsSMulRegular.mul_iff_right", "start": [109, 1], "end": [111, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "exists_or_eq_left'", "start": [800, 9], "end": [800, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.disjoint_supported_supported_iff", "start": [430, 1], "end": [436, 16], "traced_tactics": [{"tactic": "refine' \u27e8fun h => Set.disjoint_left.mpr fun x hx1 hx2 => _, disjoint_supported_supported\u27e9", "annotated_tactic": ["refine' \u27e8fun h => Set.disjoint_left.mpr fun x hx1 hx2 => _, <a>disjoint_supported_supported</a>\u27e9", [{"full_name": "Finsupp.disjoint_supported_supported", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [425, 9], "def_end_pos": [425, 37]}]], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : Nontrivial M\ns t : Set \u03b1\n\u22a2 Disjoint (supported M R s) (supported M R t) \u2194 Disjoint s t", "state_after": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : Nontrivial M\ns t : Set \u03b1\nh : Disjoint (supported M R s) (supported M R t)\nx : \u03b1\nhx1 : x \u2208 s\nhx2 : x \u2208 t\n\u22a2 False"}, {"tactic": "rcases exists_ne (0 : M) with \u27e8y, hy\u27e9", "annotated_tactic": ["rcases <a>exists_ne</a> (0 : M) with \u27e8y, hy\u27e9", [{"full_name": "exists_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [53, 9], "def_end_pos": [53, 18]}]], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : Nontrivial M\ns t : Set \u03b1\nh : Disjoint (supported M R s) (supported M R t)\nx : \u03b1\nhx1 : x \u2208 s\nhx2 : x \u2208 t\n\u22a2 False", "state_after": "case intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : Nontrivial M\ns t : Set \u03b1\nh : Disjoint (supported M R s) (supported M R t)\nx : \u03b1\nhx1 : x \u2208 s\nhx2 : x \u2208 t\ny : M\nhy : y \u2260 0\n\u22a2 False"}, {"tactic": "have := h.le_bot \u27e8single_mem_supported R y hx1, single_mem_supported R y hx2\u27e9", "annotated_tactic": ["have := h.le_bot \u27e8<a>single_mem_supported</a> R y hx1, <a>single_mem_supported</a> R y hx2\u27e9", [{"full_name": "Finsupp.single_mem_supported", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [325, 9], "def_end_pos": [325, 29]}, {"full_name": "Finsupp.single_mem_supported", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [325, 9], "def_end_pos": [325, 29]}]], "state_before": "case intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : Nontrivial M\ns t : Set \u03b1\nh : Disjoint (supported M R s) (supported M R t)\nx : \u03b1\nhx1 : x \u2208 s\nhx2 : x \u2208 t\ny : M\nhy : y \u2260 0\n\u22a2 False", "state_after": "case intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : Nontrivial M\ns t : Set \u03b1\nh : Disjoint (supported M R s) (supported M R t)\nx : \u03b1\nhx1 : x \u2208 s\nhx2 : x \u2208 t\ny : M\nhy : y \u2260 0\nthis : single x y \u2208 \u22a5\n\u22a2 False"}, {"tactic": "rw [mem_bot, single_eq_zero] at this", "annotated_tactic": ["rw [<a>mem_bot</a>, <a>single_eq_zero</a>] at this", [{"full_name": "Submodule.mem_bot", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [72, 9], "def_end_pos": [72, 16]}, {"full_name": "Finsupp.single_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [435, 9], "def_end_pos": [435, 23]}]], "state_before": "case intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : Nontrivial M\ns t : Set \u03b1\nh : Disjoint (supported M R s) (supported M R t)\nx : \u03b1\nhx1 : x \u2208 s\nhx2 : x \u2208 t\ny : M\nhy : y \u2260 0\nthis : single x y \u2208 \u22a5\n\u22a2 False", "state_after": "case intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : Nontrivial M\ns t : Set \u03b1\nh : Disjoint (supported M R s) (supported M R t)\nx : \u03b1\nhx1 : x \u2208 s\nhx2 : x \u2208 t\ny : M\nhy : y \u2260 0\nthis : y = 0\n\u22a2 False"}, {"tactic": "exact hy this", "annotated_tactic": ["exact hy this", []], "state_before": "case intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : Nontrivial M\ns t : Set \u03b1\nh : Disjoint (supported M R s) (supported M R t)\nx : \u03b1\nhx1 : x \u2208 s\nhx2 : x \u2208 t\ny : M\nhy : y \u2260 0\nthis : y = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "full_name": "Real.logb_nonpos_iff_of_base_lt_one", "start": [355, 1], "end": [356, 71], "traced_tactics": [{"tactic": "rw [\u2190 not_lt, logb_pos_iff_of_base_lt_one b_pos b_lt_one hx, not_lt]", "annotated_tactic": ["rw [\u2190 <a>not_lt</a>, <a>logb_pos_iff_of_base_lt_one</a> b_pos b_lt_one hx, <a>not_lt</a>]", [{"full_name": "not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 15]}, {"full_name": "Real.logb_pos_iff_of_base_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "def_pos": [329, 9], "def_end_pos": [329, 36]}, {"full_name": "not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 15]}]], "state_before": "b x y : \u211d\nb_pos : 0 < b\nb_lt_one : b < 1\nhx : 0 < x\n\u22a2 logb b x \u2264 0 \u2194 1 \u2264 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.filter_coe", "start": [1974, 1], "end": [1974, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/PartialHomeomorph.lean", "full_name": "PartialHomeomorph.mk_coe", "start": [109, 1], "end": [110, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "ContDiffAt.prod", "start": [547, 1], "end": [550, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/FiniteDimension.lean", "full_name": "LinearMap.coe_toContinuousLinearMap", "start": [298, 1], "end": [300, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "bit1_lt_bit1", "start": [963, 1], "end": [964, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "nhds_true", "start": [890, 1], "end": [891, 100], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image_image2_antidistrib_left", "start": [333, 1], "end": [336, 70], "traced_tactics": [{"tactic": "rw [image_id']", "annotated_tactic": ["rw [<a>image_id'</a>]", [{"full_name": "Set.image_id'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [371, 9], "def_end_pos": [371, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf f'\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g'\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\ng : \u03b3 \u2192 \u03b4\nf' : \u03b2' \u2192 \u03b1 \u2192 \u03b4\ng' : \u03b2 \u2192 \u03b2'\nh_antidistrib : \u2200 (a : \u03b1) (b : \u03b2), g (f a b) = f' (g' b) a\n\u22a2 image2 f' ((fun b => g' b) '' t) ((fun a => a) '' s) = image2 f' (g' '' t) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/Order.lean", "full_name": "Int.sub_right_lt_of_lt_add", "start": [276, 11], "end": [278, 38], "traced_tactics": [{"tactic": "have h := Int.add_lt_add_right h (-c)", "annotated_tactic": ["have h := <a>Int.add_lt_add_right</a> h (-c)", [{"full_name": "Int.add_lt_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [249, 19], "def_end_pos": [249, 35]}]], "state_before": "a b c : Int\nh : a < b + c\n\u22a2 a - c < b", "state_after": "a b c : Int\nh\u271d : a < b + c\nh : a + -c < b + c + -c\n\u22a2 a - c < b"}, {"tactic": "rwa [Int.add_neg_cancel_right] at h", "annotated_tactic": ["rwa [<a>Int.add_neg_cancel_right</a>] at h", [{"full_name": "Int.add_neg_cancel_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [241, 19], "def_end_pos": [241, 39]}]], "state_before": "a b c : Int\nh\u271d : a < b + c\nh : a + -c < b + c + -c\n\u22a2 a - c < b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Iso.lean", "full_name": "CategoryTheory.Iso.trans_symm", "start": [173, 1], "end": [174, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Shift.lean", "full_name": "HasDerivAt.comp_add_const", "start": [23, 1], "end": [28, 100], "traced_tactics": [{"tactic": "simpa [Function.comp_def] using HasDerivAt.scomp (\ud835\udd5c := \ud835\udd5c) x hh <| hasDerivAt_id' x |>.add_const a", "annotated_tactic": ["simpa [<a>Function.comp_def</a>] using <a>HasDerivAt.scomp</a> (\ud835\udd5c := \ud835\udd5c) x hh <| <a>hasDerivAt_id'</a> x |>.<a>add_const</a> a", [{"full_name": "Function.comp_def", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [37, 9], "def_end_pos": [37, 26]}, {"full_name": "HasDerivAt.scomp", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Comp.lean", "def_pos": [88, 16], "def_end_pos": [88, 32]}, {"full_name": "hasDerivAt_id'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "def_pos": [679, 9], "def_end_pos": [679, 23]}, {"full_name": "HasDerivAt.add_const", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Add.lean", "def_pos": [92, 16], "def_end_pos": [92, 36]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx a : \ud835\udd5c\n\ud835\udd5c' : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup \ud835\udd5c'\ninst\u271d : NormedSpace \ud835\udd5c \ud835\udd5c'\nh : \ud835\udd5c \u2192 \ud835\udd5c'\nh' : \ud835\udd5c'\nhh : HasDerivAt h h' (x + a)\n\u22a2 HasDerivAt (fun x => h (x + a)) h' x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.diff_erase", "start": [1788, 1], "end": [1789, 36], "traced_tactics": [{"tactic": "rw [\u2190 diff_cons_right, diff_cons]", "annotated_tactic": ["rw [\u2190 <a>diff_cons_right</a>, <a>diff_cons</a>]", [{"full_name": "List.diff_cons_right", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1785, 9], "def_end_pos": [1785, 24]}, {"full_name": "List.diff_cons", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1782, 17], "def_end_pos": [1782, 26]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\n\u22a2 List.erase (List.diff l\u2081 l\u2082) a = List.diff (List.erase l\u2081 a) l\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.prod_subset_prod_iff", "start": [382, 1], "end": [393, 28], "traced_tactics": [{"tactic": "rcases (s \u00d7\u02e2 t).eq_empty_or_nonempty with h | h", "annotated_tactic": ["rcases (s \u00d7\u02e2 t).<a>eq_empty_or_nonempty</a> with h | h", [{"full_name": "Set.eq_empty_or_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [609, 9], "def_end_pos": [609, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : s \u00d7\u02e2 t = \u2205\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205"}, {"tactic": "have st : s.Nonempty \u2227 t.Nonempty := by rwa [prod_nonempty_iff] at h", "annotated_tactic": ["have st : s.Nonempty \u2227 t.Nonempty := by rwa [<a>prod_nonempty_iff</a>] at h", [{"full_name": "Set.prod_nonempty_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [318, 9], "def_end_pos": [318, 26]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205", "state_after": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205"}, {"tactic": "refine' \u27e8fun H => Or.inl \u27e8_, _\u27e9, _\u27e9", "annotated_tactic": ["refine' \u27e8fun H => <a>Or.inl</a> \u27e8_, _\u27e9, _\u27e9", [{"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205", "state_after": "case inr.refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081\n\u22a2 s \u2286 s\u2081\n\ncase inr.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081\n\u22a2 t \u2286 t\u2081\n\ncase inr.refine'_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\n\u22a2 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 \u2192 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081"}, {"tactic": "simp [h, prod_eq_empty_iff.1 h]", "annotated_tactic": ["simp [h, <a>prod_eq_empty_iff</a>.1 h]", [{"full_name": "Set.prod_eq_empty_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [323, 9], "def_end_pos": [323, 26]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : s \u00d7\u02e2 t = \u2205\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205", "state_after": "no goals"}, {"tactic": "rwa [prod_nonempty_iff] at h", "annotated_tactic": ["rwa [<a>prod_nonempty_iff</a>] at h", [{"full_name": "Set.prod_nonempty_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [318, 9], "def_end_pos": [318, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\n\u22a2 Set.Nonempty s \u2227 Set.Nonempty t", "state_after": "no goals"}, {"tactic": "have := image_subset (Prod.fst : \u03b1 \u00d7 \u03b2 \u2192 \u03b1) H", "annotated_tactic": ["have := <a>image_subset</a> (<a>Prod.fst</a> : \u03b1 \u00d7 \u03b2 \u2192 \u03b1) H", [{"full_name": "Set.image_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [293, 9], "def_end_pos": [293, 21]}, {"full_name": "Prod.fst", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [481, 3], "def_end_pos": [481, 6]}]], "state_before": "case inr.refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081\n\u22a2 s \u2286 s\u2081", "state_after": "case inr.refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081\nthis : Prod.fst '' s \u00d7\u02e2 t \u2286 Prod.fst '' s\u2081 \u00d7\u02e2 t\u2081\n\u22a2 s \u2286 s\u2081"}, {"tactic": "rwa [fst_image_prod _ st.2, fst_image_prod _ (h.mono H).snd] at this", "annotated_tactic": ["rwa [<a>fst_image_prod</a> _ st.2, <a>fst_image_prod</a> _ (h.mono H).<a>snd</a>] at this", [{"full_name": "Set.fst_image_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [355, 9], "def_end_pos": [355, 23]}, {"full_name": "Set.fst_image_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [355, 9], "def_end_pos": [355, 23]}, {"full_name": "Set.Nonempty.snd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [314, 9], "def_end_pos": [314, 21]}]], "state_before": "case inr.refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081\nthis : Prod.fst '' s \u00d7\u02e2 t \u2286 Prod.fst '' s\u2081 \u00d7\u02e2 t\u2081\n\u22a2 s \u2286 s\u2081", "state_after": "no goals"}, {"tactic": "have := image_subset (Prod.snd : \u03b1 \u00d7 \u03b2 \u2192 \u03b2) H", "annotated_tactic": ["have := <a>image_subset</a> (<a>Prod.snd</a> : \u03b1 \u00d7 \u03b2 \u2192 \u03b2) H", [{"full_name": "Set.image_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [293, 9], "def_end_pos": [293, 21]}, {"full_name": "Prod.snd", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [483, 3], "def_end_pos": [483, 6]}]], "state_before": "case inr.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081\n\u22a2 t \u2286 t\u2081", "state_after": "case inr.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081\nthis : Prod.snd '' s \u00d7\u02e2 t \u2286 Prod.snd '' s\u2081 \u00d7\u02e2 t\u2081\n\u22a2 t \u2286 t\u2081"}, {"tactic": "rwa [snd_image_prod st.1, snd_image_prod (h.mono H).fst] at this", "annotated_tactic": ["rwa [<a>snd_image_prod</a> st.1, <a>snd_image_prod</a> (h.mono H).<a>fst</a>] at this", [{"full_name": "Set.snd_image_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [369, 9], "def_end_pos": [369, 23]}, {"full_name": "Set.snd_image_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [369, 9], "def_end_pos": [369, 23]}, {"full_name": "Set.Nonempty.fst", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [311, 9], "def_end_pos": [311, 21]}]], "state_before": "case inr.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081\nthis : Prod.snd '' s \u00d7\u02e2 t \u2286 Prod.snd '' s\u2081 \u00d7\u02e2 t\u2081\n\u22a2 t \u2286 t\u2081", "state_after": "no goals"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "case inr.refine'_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\n\u22a2 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205 \u2192 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081", "state_after": "case inr.refine'_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081"}, {"tactic": "simp only [st.1.ne_empty, st.2.ne_empty, or_false_iff] at H", "annotated_tactic": ["simp only [st.1.<a>ne_empty</a>, st.2.<a>ne_empty</a>, <a>or_false_iff</a>] at H", [{"full_name": "Set.Nonempty.ne_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [596, 8], "def_end_pos": [596, 25]}, {"full_name": "Set.Nonempty.ne_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [596, 8], "def_end_pos": [596, 25]}, {"full_name": "or_false_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [180, 9], "def_end_pos": [180, 21]}]], "state_before": "case inr.refine'_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081", "state_after": "case inr.refine'_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u2286 s\u2081 \u2227 t \u2286 t\u2081\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081"}, {"tactic": "exact prod_mono H.1 H.2", "annotated_tactic": ["exact <a>prod_mono</a> H.1 H.2", [{"full_name": "Set.prod_mono", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [46, 9], "def_end_pos": [46, 18]}]], "state_before": "case inr.refine'_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nh : Set.Nonempty (s \u00d7\u02e2 t)\nst : Set.Nonempty s \u2227 Set.Nonempty t\nH : s \u2286 s\u2081 \u2227 t \u2286 t\u2081\n\u22a2 s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finsupp.lean", "full_name": "Finsupp.sum_hom_add_index", "start": [419, 1], "end": [421, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "continuous_induced_rng", "start": [695, 1], "end": [697, 57], "traced_tactics": [{"tactic": "simp only [continuous_iff_le_induced, induced_compose]", "annotated_tactic": ["simp only [<a>continuous_iff_le_induced</a>, <a>induced_compose</a>]", [{"full_name": "continuous_iff_le_induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [678, 9], "def_end_pos": [678, 34]}, {"full_name": "induced_compose", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [468, 9], "def_end_pos": [468, 24]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_2\ng : \u03b3 \u2192 \u03b1\nt\u2082 : TopologicalSpace \u03b2\nt\u2081 : TopologicalSpace \u03b3\n\u22a2 Continuous g \u2194 Continuous (f \u2218 g)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "TopologicalSpace.ext_iff", "start": [96, 11], "end": [98, 55], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "X : Type u\nY : Type v\n\u03b9 : Sort w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : X\ns s\u2081 s\u2082 t\u271d : Set X\np p\u2081 p\u2082 : X \u2192 Prop\nt t' : TopologicalSpace X\nh : \u2200 (s : Set X), IsOpen s \u2194 IsOpen s\n\u22a2 t = t'", "state_after": "case a.h.a\nX : Type u\nY : Type v\n\u03b9 : Sort w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : X\ns s\u2081 s\u2082 t\u271d : Set X\np p\u2081 p\u2082 : X \u2192 Prop\nt t' : TopologicalSpace X\nh : \u2200 (s : Set X), IsOpen s \u2194 IsOpen s\nx\u271d : Set X\n\u22a2 IsOpen x\u271d \u2194 IsOpen x\u271d"}, {"tactic": "exact h _", "annotated_tactic": ["exact h _", []], "state_before": "case a.h.a\nX : Type u\nY : Type v\n\u03b9 : Sort w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : X\ns s\u2081 s\u2082 t\u271d : Set X\np p\u2081 p\u2082 : X \u2192 Prop\nt t' : TopologicalSpace X\nh : \u2200 (s : Set X), IsOpen s \u2194 IsOpen s\nx\u271d : Set X\n\u22a2 IsOpen x\u271d \u2194 IsOpen x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Basic.lean", "full_name": "Eq.ge", "start": [225, 11], "end": [226, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.eq_symm_comp", "start": [463, 1], "end": [465, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Lift.lean", "full_name": "Filter.lift'_pure", "start": [322, 1], "end": [323, 49], "traced_tactics": [{"tactic": "rw [\u2190 principal_singleton, lift'_principal hh]", "annotated_tactic": ["rw [\u2190 <a>principal_singleton</a>, <a>lift'_principal</a> hh]", [{"full_name": "Filter.principal_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2151, 9], "def_end_pos": [2151, 28]}, {"full_name": "Filter.lift'_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Lift.lean", "def_pos": [318, 9], "def_end_pos": [318, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\nf f\u2081 f\u2082 : Filter \u03b1\nh h\u2081 h\u2082 : Set \u03b1 \u2192 Set \u03b2\na : \u03b1\nhh : Monotone h\n\u22a2 Filter.lift' (pure a) h = \ud835\udcdf (h {a})", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.subset_one_iff_eq", "start": [131, 1], "end": [132, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Trace.lean", "full_name": "trace_eq_sum_roots", "start": [298, 1], "end": [303, 95], "traced_tactics": [{"tactic": "rw [trace_eq_trace_adjoin K x, Algebra.smul_def, RingHom.map_mul, \u2190 Algebra.smul_def,\n  IntermediateField.AdjoinSimple.trace_gen_eq_sum_roots _ hF, IsScalarTower.algebraMap_smul]", "annotated_tactic": ["rw [<a>trace_eq_trace_adjoin</a> K x, <a>Algebra.smul_def</a>, <a>RingHom.map_mul</a>, \u2190 <a>Algebra.smul_def</a>,\n    <a>IntermediateField.AdjoinSimple.trace_gen_eq_sum_roots</a> _ hF, <a>IsScalarTower.algebraMap_smul</a>]", [{"full_name": "trace_eq_trace_adjoin", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Trace.lean", "def_pos": [286, 9], "def_end_pos": [286, 30]}, {"full_name": "Algebra.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}, {"full_name": "RingHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "Algebra.smul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}, {"full_name": "IntermediateField.AdjoinSimple.trace_gen_eq_sum_roots", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Trace.lean", "def_pos": [268, 9], "def_end_pos": [268, 31]}, {"full_name": "IsScalarTower.algebraMap_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Tower.lean", "def_pos": [88, 9], "def_end_pos": [88, 24]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing S\ninst\u271d\u00b9\u2070 : CommRing T\ninst\u271d\u2079 : Algebra R S\ninst\u271d\u2078 : Algebra R T\nK : Type u_4\nL : Type u_5\ninst\u271d\u2077 : Field K\ninst\u271d\u2076 : Field L\ninst\u271d\u2075 : Algebra K L\n\u03b9 \u03ba : Type w\ninst\u271d\u2074 : Fintype \u03b9\nF : Type u_6\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Algebra K S\ninst\u271d\u00b9 : Algebra K F\ninst\u271d : FiniteDimensional K L\nx : L\nhF : Splits (algebraMap K F) (minpoly K x)\n\u22a2 (algebraMap K F) ((Algebra.trace K L) x) = finrank (\u21a5K\u27eex\u27ef) L \u2022 Multiset.sum (aroots (minpoly K x) F)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Basic.lean", "full_name": "smul_left_injective", "start": [708, 1], "end": [716, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.pentagon_hom_inv_inv_inv_inv", "start": [542, 1], "end": [545, 46], "traced_tactics": [{"tactic": "simp [\u2190 cancel_epi (W \u25c1 (\u03b1_ X Y Z).inv)]", "annotated_tactic": ["simp [\u2190 <a>cancel_epi</a> (W \u25c1 (\u03b1_ X Y Z).<a>inv</a>)]", [{"full_name": "CategoryTheory.cancel_epi", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [297, 9], "def_end_pos": [297, 19]}, {"full_name": "CategoryTheory.Iso.inv", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [55, 3], "def_end_pos": [55, 6]}]], "state_before": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b2 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nU V W X Y Z : C\n\u22a2 W \u25c1 (\u03b1_ X Y Z).hom \u226b (\u03b1_ W X (Y \u2297 Z)).inv \u226b (\u03b1_ (W \u2297 X) Y Z).inv = (\u03b1_ W (X \u2297 Y) Z).inv \u226b (\u03b1_ W X Y).inv \u25b7 Z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/SigmaCompact.lean", "full_name": "isCompact_compactCovering", "start": [201, 1], "end": [202, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/TensorProduct/Tower.lean", "full_name": "TensorProduct.AlgebraTensorModule.congr_refl", "start": [270, 1], "end": [271, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.nthLe_zero_scanl", "start": [2612, 1], "end": [2613, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "Cycle.next_reverse_eq_prev'", "start": [864, 1], "end": [866, 32], "traced_tactics": [{"tactic": "simp [\u2190 prev_reverse_eq_next]", "annotated_tactic": ["simp [\u2190 <a>prev_reverse_eq_next</a>]", [{"full_name": "Cycle.prev_reverse_eq_next", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [844, 16], "def_end_pos": [844, 36]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Cycle \u03b1\nhs : Nodup (reverse s)\nx : \u03b1\nhx : x \u2208 reverse s\n\u22a2 next (reverse s) hs x hx = prev s \u22ef x \u22ef", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Complex.norm_natCast_cpow_le_norm_natCast_cpow_of_pos", "start": [857, 1], "end": [861, 66], "traced_tactics": [{"tactic": "simp_rw [norm_natCast_cpow_of_pos hn]", "annotated_tactic": ["simp_rw [<a>norm_natCast_cpow_of_pos</a> hn]", [{"full_name": "Complex.norm_natCast_cpow_of_pos", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [342, 7], "def_end_pos": [342, 31]}]], "state_before": "n : \u2115\nhn : 0 < n\nw z : \u2102\nh : w.re \u2264 z.re\n\u22a2 \u2016\u2191n ^ w\u2016 \u2264 \u2016\u2191n ^ z\u2016", "state_after": "n : \u2115\nhn : 0 < n\nw z : \u2102\nh : w.re \u2264 z.re\n\u22a2 \u2191n ^ w.re \u2264 \u2191n ^ z.re"}, {"tactic": "exact Real.rpow_le_rpow_of_exponent_le (by exact_mod_cast hn) h", "annotated_tactic": ["exact <a>Real.rpow_le_rpow_of_exponent_le</a> (by exact_mod_cast hn) h", [{"full_name": "Real.rpow_le_rpow_of_exponent_le", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [610, 9], "def_end_pos": [610, 36]}]], "state_before": "n : \u2115\nhn : 0 < n\nw z : \u2102\nh : w.re \u2264 z.re\n\u22a2 \u2191n ^ w.re \u2264 \u2191n ^ z.re", "state_after": "no goals"}, {"tactic": "exact_mod_cast hn", "annotated_tactic": ["exact_mod_cast hn", []], "state_before": "n : \u2115\nhn : 0 < n\nw z : \u2102\nh : w.re \u2264 z.re\n\u22a2 1 \u2264 \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Abelianization.lean", "full_name": "Abelianization.lift.unique", "start": [152, 1], "end": [156, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "continuous_of_discreteTopology", "start": [296, 1], "end": [297, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/MinMax.lean", "full_name": "min_max_distrib_right", "start": [134, 1], "end": [135, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "isUpperSet_iInter\u2082", "start": [162, 1], "end": [164, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Hom/Instances.lean", "full_name": "AddMonoid.End.zero_apply", "start": [97, 1], "end": [98, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.Subset.refl", "start": [403, 1], "end": [403, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometry.coe_mul", "start": [437, 1], "end": [438, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Lattice.lean", "full_name": "ContinuousOn.finset_inf_apply", "start": [396, 1], "end": [398, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Lifts.lean", "full_name": "Polynomial.lifts_and_natDegree_eq_and_monic", "start": [233, 1], "end": [239, 51], "traced_tactics": [{"tactic": "cases' subsingleton_or_nontrivial S with hR hR", "annotated_tactic": ["cases' <a>subsingleton_or_nontrivial</a> S with hR hR", [{"full_name": "subsingleton_or_nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [99, 9], "def_end_pos": [99, 35]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\n\u22a2 \u2203 q, map f q = p \u2227 natDegree q = natDegree p \u2227 Monic q", "state_after": "case inl\nR : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Subsingleton S\n\u22a2 \u2203 q, map f q = p \u2227 natDegree q = natDegree p \u2227 Monic q\n\ncase inr\nR : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial S\n\u22a2 \u2203 q, map f q = p \u2227 natDegree q = natDegree p \u2227 Monic q"}, {"tactic": "obtain \u27e8p', h\u2081, h\u2082, h\u2083\u27e9 := lifts_and_degree_eq_and_monic hlifts hp", "annotated_tactic": ["obtain \u27e8p', h\u2081, h\u2082, h\u2083\u27e9 := <a>lifts_and_degree_eq_and_monic</a> hlifts hp", [{"full_name": "Polynomial.lifts_and_degree_eq_and_monic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Lifts.lean", "def_pos": [211, 9], "def_end_pos": [211, 38]}]], "state_before": "case inr\nR : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial S\n\u22a2 \u2203 q, map f q = p \u2227 natDegree q = natDegree p \u2227 Monic q", "state_after": "case inr.intro.intro.intro\nR : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial S\np' : R[X]\nh\u2081 : map f p' = p\nh\u2082 : degree p' = degree p\nh\u2083 : Monic p'\n\u22a2 \u2203 q, map f q = p \u2227 natDegree q = natDegree p \u2227 Monic q"}, {"tactic": "exact \u27e8p', h\u2081, natDegree_eq_of_degree_eq h\u2082, h\u2083\u27e9", "annotated_tactic": ["exact \u27e8p', h\u2081, <a>natDegree_eq_of_degree_eq</a> h\u2082, h\u2083\u27e9", [{"full_name": "Polynomial.natDegree_eq_of_degree_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [173, 9], "def_end_pos": [173, 34]}]], "state_before": "case inr.intro.intro.intro\nR : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial S\np' : R[X]\nh\u2081 : map f p' = p\nh\u2082 : degree p' = degree p\nh\u2083 : Monic p'\n\u22a2 \u2203 q, map f q = p \u2227 natDegree q = natDegree p \u2227 Monic q", "state_after": "no goals"}, {"tactic": "obtain rfl : p = 1 := Subsingleton.elim _ _", "annotated_tactic": ["obtain rfl : p = 1 := <a>Subsingleton.elim</a> _ _", [{"full_name": "Subsingleton.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1010, 19], "def_end_pos": [1010, 36]}]], "state_before": "case inl\nR : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Subsingleton S\n\u22a2 \u2203 q, map f q = p \u2227 natDegree q = natDegree p \u2227 Monic q", "state_after": "case inl\nR : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\nhR : Subsingleton S\nhlifts : 1 \u2208 lifts f\nhp : Monic 1\n\u22a2 \u2203 q, map f q = 1 \u2227 natDegree q = natDegree 1 \u2227 Monic q"}, {"tactic": "exact \u27e81, Subsingleton.elim _ _, by simp, by simp\u27e9", "annotated_tactic": ["exact \u27e81, <a>Subsingleton.elim</a> _ _, by simp, by simp\u27e9", [{"full_name": "Subsingleton.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1010, 19], "def_end_pos": [1010, 36]}]], "state_before": "case inl\nR : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\nhR : Subsingleton S\nhlifts : 1 \u2208 lifts f\nhp : Monic 1\n\u22a2 \u2203 q, map f q = 1 \u2227 natDegree q = natDegree 1 \u2227 Monic q", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\nhR : Subsingleton S\nhlifts : 1 \u2208 lifts f\nhp : Monic 1\n\u22a2 natDegree 1 = natDegree 1", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\ninst\u271d\u00b9 : Semiring R\nS : Type v\ninst\u271d : Semiring S\nf : R \u2192+* S\nhR : Subsingleton S\nhlifts : 1 \u2208 lifts f\nhp : Monic 1\n\u22a2 Monic 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounded.lean", "full_name": "Set.unbounded_lt_inter_lt", "start": [384, 1], "end": [387, 30], "traced_tactics": [{"tactic": "rw [\u2190 not_bounded_iff, \u2190 not_bounded_iff, not_iff_not]", "annotated_tactic": ["rw [\u2190 <a>not_bounded_iff</a>, \u2190 <a>not_bounded_iff</a>, <a>not_iff_not</a>]", [{"full_name": "Set.not_bounded_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [556, 9], "def_end_pos": [556, 24]}, {"full_name": "Set.not_bounded_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [556, 9], "def_end_pos": [556, 24]}, {"full_name": "not_iff_not", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [449, 9], "def_end_pos": [449, 20]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na : \u03b1\n\u22a2 Unbounded (fun x x_1 => x < x_1) (s \u2229 {b | a < b}) \u2194 Unbounded (fun x x_1 => x < x_1) s", "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na : \u03b1\n\u22a2 Bounded (fun x x_1 => x < x_1) (s \u2229 {b | a < b}) \u2194 Bounded (fun x x_1 => x < x_1) s"}, {"tactic": "exact bounded_lt_inter_lt a", "annotated_tactic": ["exact <a>bounded_lt_inter_lt</a> a", [{"full_name": "Set.bounded_lt_inter_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Bounded.lean", "def_pos": [378, 9], "def_end_pos": [378, 28]}]], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : NoMaxOrder \u03b1\na : \u03b1\n\u22a2 Bounded (fun x x_1 => x < x_1) (s \u2229 {b | a < b}) \u2194 Bounded (fun x x_1 => x < x_1) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Pointwise.lean", "full_name": "image_smul_set", "start": [44, 1], "end": [46, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.Subsingleton.eq_singleton_of_mem", "start": [2345, 1], "end": [2346, 100], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Invertible/Defs.lean", "full_name": "mul_right_eq_iff_eq_mul_invOf", "start": [261, 1], "end": [262, 74], "traced_tactics": [{"tactic": "rw [\u2190 mul_right_inj_of_invertible (c := \u215fc), mul_mul_invOf_self_cancel]", "annotated_tactic": ["rw [\u2190 <a>mul_right_inj_of_invertible</a> (c := \u215fc), <a>mul_mul_invOf_self_cancel</a>]", [{"full_name": "mul_right_inj_of_invertible", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Invertible/Defs.lean", "def_pos": [245, 9], "def_end_pos": [245, 36]}, {"full_name": "mul_mul_invOf_self_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Invertible/Defs.lean", "def_pos": [141, 9], "def_end_pos": [141, 34]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b9 : Monoid \u03b1\na b c : \u03b1\ninst\u271d : Invertible c\n\u22a2 a * c = b \u2194 a = b * \u215fc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "units_eq_one", "start": [724, 1], "end": [725, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Powerset.lean", "full_name": "Finset.powerset_insert", "start": [99, 1], "end": [113, 46], "traced_tactics": [{"tactic": "ext t", "annotated_tactic": ["ext t", []], "state_before": "\u03b1 : Type u_1\ns\u271d t : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\n\u22a2 powerset (insert a s) = powerset s \u222a image (insert a) (powerset s)", "state_after": "case a\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\n\u22a2 t \u2208 powerset (insert a s) \u2194 t \u2208 powerset s \u222a image (insert a) (powerset s)"}, {"tactic": "simp only [exists_prop, mem_powerset, mem_image, mem_union, subset_insert_iff]", "annotated_tactic": ["simp only [<a>exists_prop</a>, <a>mem_powerset</a>, <a>mem_image</a>, <a>mem_union</a>, <a>subset_insert_iff</a>]", [{"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "Finset.mem_powerset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Powerset.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}, {"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}, {"full_name": "Finset.mem_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1408, 9], "def_end_pos": [1408, 18]}, {"full_name": "Finset.subset_insert_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2068, 9], "def_end_pos": [2068, 26]}]], "state_before": "case a\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\n\u22a2 t \u2208 powerset (insert a s) \u2194 t \u2208 powerset s \u222a image (insert a) (powerset s)", "state_after": "case a\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\n\u22a2 erase t a \u2286 s \u2194 t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t"}, {"tactic": "by_cases h : a \u2208 t", "annotated_tactic": ["by_cases h : a \u2208 t", []], "state_before": "case a\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\n\u22a2 erase t a \u2286 s \u2194 t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t", "state_after": "case pos\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\n\u22a2 erase t a \u2286 s \u2194 t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t\n\ncase neg\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2209 t\n\u22a2 erase t a \u2286 s \u2194 t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case pos\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\n\u22a2 erase t a \u2286 s \u2194 t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t", "state_after": "case pos.mp\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\n\u22a2 erase t a \u2286 s \u2192 t \u2286 s \u2228 \u2203 a_2 \u2286 s, insert a a_2 = t\n\ncase pos.mpr\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\n\u22a2 (t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t) \u2192 erase t a \u2286 s"}, {"tactic": "exact fun H => Or.inr \u27e8_, H, insert_erase h\u27e9", "annotated_tactic": ["exact fun H => <a>Or.inr</a> \u27e8_, H, <a>insert_erase</a> h\u27e9", [{"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "Finset.insert_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2001, 17], "def_end_pos": [2001, 29]}]], "state_before": "case pos.mp\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\n\u22a2 erase t a \u2286 s \u2192 t \u2286 s \u2228 \u2203 a_2 \u2286 s, insert a a_2 = t", "state_after": "no goals"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "case pos.mpr\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\n\u22a2 (t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t) \u2192 erase t a \u2286 s", "state_after": "case pos.mpr\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nH : t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t\n\u22a2 erase t a \u2286 s"}, {"tactic": "cases' H with H H", "annotated_tactic": ["cases' H with H H", []], "state_before": "case pos.mpr\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nH : t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t\n\u22a2 erase t a \u2286 s", "state_after": "case pos.mpr.inl\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nH : t \u2286 s\n\u22a2 erase t a \u2286 s\n\ncase pos.mpr.inr\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nH : \u2203 a_1 \u2286 s, insert a a_1 = t\n\u22a2 erase t a \u2286 s"}, {"tactic": "exact Subset.trans (erase_subset a t) H", "annotated_tactic": ["exact <a>Subset.trans</a> (<a>erase_subset</a> a t) H", [{"full_name": "Finset.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [356, 9], "def_end_pos": [356, 21]}, {"full_name": "Finset.erase_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2020, 9], "def_end_pos": [2020, 21]}]], "state_before": "case pos.mpr.inl\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nH : t \u2286 s\n\u22a2 erase t a \u2286 s", "state_after": "no goals"}, {"tactic": "rcases H with \u27e8u, hu\u27e9", "annotated_tactic": ["rcases H with \u27e8u, hu\u27e9", []], "state_before": "case pos.mpr.inr\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nH : \u2203 a_1 \u2286 s, insert a a_1 = t\n\u22a2 erase t a \u2286 s", "state_after": "case pos.mpr.inr.intro\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nu : Finset \u03b1\nhu : u \u2286 s \u2227 insert a u = t\n\u22a2 erase t a \u2286 s"}, {"tactic": "rw [\u2190 hu.2]", "annotated_tactic": ["rw [\u2190 hu.2]", []], "state_before": "case pos.mpr.inr.intro\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nu : Finset \u03b1\nhu : u \u2286 s \u2227 insert a u = t\n\u22a2 erase t a \u2286 s", "state_after": "case pos.mpr.inr.intro\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nu : Finset \u03b1\nhu : u \u2286 s \u2227 insert a u = t\n\u22a2 erase (insert a u) a \u2286 s"}, {"tactic": "exact Subset.trans (erase_insert_subset a u) hu.1", "annotated_tactic": ["exact <a>Subset.trans</a> (<a>erase_insert_subset</a> a u) hu.1", [{"full_name": "Finset.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [356, 9], "def_end_pos": [356, 21]}, {"full_name": "Finset.erase_insert_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2073, 9], "def_end_pos": [2073, 28]}]], "state_before": "case pos.mpr.inr.intro\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2208 t\nu : Finset \u03b1\nhu : u \u2286 s \u2227 insert a u = t\n\u22a2 erase (insert a u) a \u2286 s", "state_after": "no goals"}, {"tactic": "have : \u00ac\u2203 u : Finset \u03b1, u \u2286 s \u2227 insert a u = t := by simp [Ne.symm (ne_insert_of_not_mem _ _ h)]", "annotated_tactic": ["have : \u00ac\u2203 u : <a>Finset</a> \u03b1, u \u2286 s \u2227 <a>insert</a> a u = t := by simp [<a>Ne.symm</a> (<a>ne_insert_of_not_mem</a> _ _ h)]", [{"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}, {"full_name": "Insert.insert", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [456, 3], "def_end_pos": [456, 9]}, {"full_name": "Ne.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [702, 9], "def_end_pos": [702, 16]}, {"full_name": "Finset.ne_insert_of_not_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1214, 9], "def_end_pos": [1214, 29]}]], "state_before": "case neg\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2209 t\n\u22a2 erase t a \u2286 s \u2194 t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t", "state_after": "case neg\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2209 t\nthis : \u00ac\u2203 u \u2286 s, insert a u = t\n\u22a2 erase t a \u2286 s \u2194 t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t"}, {"tactic": "simp [Finset.erase_eq_of_not_mem h, this]", "annotated_tactic": ["simp [<a>Finset.erase_eq_of_not_mem</a> h, this]", [{"full_name": "Finset.erase_eq_of_not_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1969, 9], "def_end_pos": [1969, 28]}]], "state_before": "case neg\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2209 t\nthis : \u00ac\u2203 u \u2286 s, insert a u = t\n\u22a2 erase t a \u2286 s \u2194 t \u2286 s \u2228 \u2203 a_1 \u2286 s, insert a a_1 = t", "state_after": "no goals"}, {"tactic": "simp [Ne.symm (ne_insert_of_not_mem _ _ h)]", "annotated_tactic": ["simp [<a>Ne.symm</a> (<a>ne_insert_of_not_mem</a> _ _ h)]", [{"full_name": "Ne.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [702, 9], "def_end_pos": [702, 16]}, {"full_name": "Finset.ne_insert_of_not_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1214, 9], "def_end_pos": [1214, 29]}]], "state_before": "\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\na : \u03b1\nt : Finset \u03b1\nh : a \u2209 t\n\u22a2 \u00ac\u2203 u \u2286 s, insert a u = t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/AEDisjoint.lean", "full_name": "MeasureTheory.AEDisjoint.mono_ae", "start": [80, 1], "end": [81, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.zipWith_def", "start": [1231, 1], "end": [1238, 22], "traced_tactics": [{"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "\u03b9\u271d : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9\u271d \u2192 Type v\n\u03b2\u2081\u271d : \u03b9\u271d \u2192 Type v\u2081\n\u03b2\u2082\u271d : \u03b9\u271d \u2192 Type v\u2082\ndec\u271d : DecidableEq \u03b9\u271d\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 Zero (\u03b2\u271d i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 (x : \u03b2\u271d i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u2078 : (i : \u03b9\u271d) \u2192 Zero (\u03b2\u2081\u271d i)\ninst\u271d\u2077 : (i : \u03b9\u271d) \u2192 Zero (\u03b2\u2082\u271d i)\ninst\u271d\u2076 : (i : \u03b9\u271d) \u2192 (x : \u03b2\u2081\u271d i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u2075 : (i : \u03b9\u271d) \u2192 (x : \u03b2\u2082\u271d i) \u2192 Decidable (x \u2260 0)\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u2074 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2\u2081 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2\u2082 i) \u2192 Decidable (x \u2260 0)\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i\nhf : \u2200 (i : \u03b9), f i 0 0 = 0\ng\u2081 : \u03a0\u2080 (i : \u03b9), \u03b2\u2081 i\ng\u2082 : \u03a0\u2080 (i : \u03b9), \u03b2\u2082 i\n\u22a2 zipWith f hf g\u2081 g\u2082 = mk (support g\u2081 \u222a support g\u2082) fun i => f (\u2191i) (g\u2081 \u2191i) (g\u2082 \u2191i)", "state_after": "case h\n\u03b9\u271d : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9\u271d \u2192 Type v\n\u03b2\u2081\u271d : \u03b9\u271d \u2192 Type v\u2081\n\u03b2\u2082\u271d : \u03b9\u271d \u2192 Type v\u2082\ndec\u271d : DecidableEq \u03b9\u271d\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 Zero (\u03b2\u271d i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 (x : \u03b2\u271d i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u2078 : (i : \u03b9\u271d) \u2192 Zero (\u03b2\u2081\u271d i)\ninst\u271d\u2077 : (i : \u03b9\u271d) \u2192 Zero (\u03b2\u2082\u271d i)\ninst\u271d\u2076 : (i : \u03b9\u271d) \u2192 (x : \u03b2\u2081\u271d i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u2075 : (i : \u03b9\u271d) \u2192 (x : \u03b2\u2082\u271d i) \u2192 Decidable (x \u2260 0)\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u2074 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2\u2081 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2\u2082 i) \u2192 Decidable (x \u2260 0)\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i\nhf : \u2200 (i : \u03b9), f i 0 0 = 0\ng\u2081 : \u03a0\u2080 (i : \u03b9), \u03b2\u2081 i\ng\u2082 : \u03a0\u2080 (i : \u03b9), \u03b2\u2082 i\ni : \u03b9\n\u22a2 (zipWith f hf g\u2081 g\u2082) i = (mk (support g\u2081 \u222a support g\u2082) fun i => f (\u2191i) (g\u2081 \u2191i) (g\u2082 \u2191i)) i"}, {"tactic": "by_cases h1 : g\u2081 i \u2260 0 <;> by_cases h2 : g\u2082 i \u2260 0 <;> simp only [not_not, Ne.def] at h1 h2 <;>\n  simp [h1, h2, hf]", "annotated_tactic": ["by_cases h1 : g\u2081 i \u2260 0 <;> by_cases h2 : g\u2082 i \u2260 0 <;> simp only [<a>not_not</a>, <a>Ne.def</a>] at h1 h2 <;>\n    simp [h1, h2, hf]", [{"full_name": "Classical.not_not", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [128, 24], "def_end_pos": [128, 31]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}]], "state_before": "case h\n\u03b9\u271d : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9\u271d \u2192 Type v\n\u03b2\u2081\u271d : \u03b9\u271d \u2192 Type v\u2081\n\u03b2\u2082\u271d : \u03b9\u271d \u2192 Type v\u2082\ndec\u271d : DecidableEq \u03b9\u271d\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 Zero (\u03b2\u271d i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 (x : \u03b2\u271d i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u2078 : (i : \u03b9\u271d) \u2192 Zero (\u03b2\u2081\u271d i)\ninst\u271d\u2077 : (i : \u03b9\u271d) \u2192 Zero (\u03b2\u2082\u271d i)\ninst\u271d\u2076 : (i : \u03b9\u271d) \u2192 (x : \u03b2\u2081\u271d i) \u2192 Decidable (x \u2260 0)\ninst\u271d\u2075 : (i : \u03b9\u271d) \u2192 (x : \u03b2\u2082\u271d i) \u2192 Decidable (x \u2260 0)\n\u03b9 : Type u\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u2074 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Zero (\u03b2\u2081 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2\u2082 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2\u2081 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : (i : \u03b9) \u2192 (x : \u03b2\u2082 i) \u2192 Decidable (x \u2260 0)\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i\nhf : \u2200 (i : \u03b9), f i 0 0 = 0\ng\u2081 : \u03a0\u2080 (i : \u03b9), \u03b2\u2081 i\ng\u2082 : \u03a0\u2080 (i : \u03b9), \u03b2\u2082 i\ni : \u03b9\n\u22a2 (zipWith f hf g\u2081 g\u2082) i = (mk (support g\u2081 \u222a support g\u2082) fun i => f (\u2191i) (g\u2081 \u2191i) (g\u2082 \u2191i)) i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.subset_singleton_iff", "start": [451, 1], "end": [452, 71], "traced_tactics": [{"tactic": "simp only [eq_replicate, subset_def, mem_singleton, exists_eq_left']", "annotated_tactic": ["simp only [<a>eq_replicate</a>, <a>subset_def</a>, <a>mem_singleton</a>, <a>exists_eq_left'</a>]", [{"full_name": "List.eq_replicate", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [472, 9], "def_end_pos": [472, 21]}, {"full_name": "List.subset_def", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [407, 9], "def_end_pos": [407, 19]}, {"full_name": "List.mem_singleton", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [82, 22], "def_end_pos": [82, 35]}, {"full_name": "exists_eq_left'", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [226, 17], "def_end_pos": [226, 32]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nL : List \u03b1\n\u22a2 L \u2286 [a] \u2194 \u2203 n, L = replicate n a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Countable/Defs.lean", "full_name": "not_injective_uncountable_countable", "start": [152, 1], "end": [153, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "Pi.top_apply", "start": [613, 1], "end": [614, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Group/Defs.lean", "full_name": "mul_inv_lt_mul_inv_iff'", "start": [559, 1], "end": [560, 52], "traced_tactics": [{"tactic": "rw [mul_comm c, mul_inv_lt_inv_mul_iff, mul_comm]", "annotated_tactic": ["rw [<a>mul_comm</a> c, <a>mul_inv_lt_inv_mul_iff</a>, <a>mul_comm</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "mul_inv_lt_inv_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [411, 9], "def_end_pos": [411, 31]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\na b c d : \u03b1\n\u22a2 a * b\u207b\u00b9 < c * d\u207b\u00b9 \u2194 a * d < c * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Prod.lean", "full_name": "RingHom.prod_comp_prodMap", "start": [271, 1], "end": [273, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearEquiv.ofTop_symm_apply", "start": [775, 1], "end": [776, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/IntermediateField.lean", "full_name": "IntermediateField.inclusion_inclusion", "start": [580, 1], "end": [582, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/OrderHom.lean", "full_name": "Fin.predAbove_of_le_castSucc", "start": [358, 1], "end": [360, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Summable.lean", "full_name": "HahnSeries.SummableFamily.coe_sub", "start": [274, 1], "end": [275, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Strict.lean", "full_name": "StrictConvex.vadd", "start": [271, 1], "end": [272, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.sigmaCongrRight_refl", "start": [764, 1], "end": [765, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Real.rpow_natCast_mul", "start": [501, 1], "end": [502, 34], "traced_tactics": [{"tactic": "rw [rpow_mul hx, rpow_nat_cast]", "annotated_tactic": ["rw [<a>rpow_mul</a> hx, <a>rpow_nat_cast</a>]", [{"full_name": "Real.rpow_mul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [393, 9], "def_end_pos": [393, 17]}, {"full_name": "Real.rpow_nat_cast", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [70, 9], "def_end_pos": [70, 22]}]], "state_before": "x y z\u271d : \u211d\nn\u271d : \u2115\nhx : 0 \u2264 x\nn : \u2115\nz : \u211d\n\u22a2 x ^ (\u2191n * z) = (x ^ n) ^ z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "Subgroup.isClosed_topologicalClosure", "start": [728, 1], "end": [729, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NatAntidiagonal.lean", "full_name": "Finset.Nat.antidiagonal_filter_fst_le_of_le", "start": [120, 1], "end": [130, 23], "traced_tactics": [{"tactic": "have aux\u2081 : fun a \u21a6 a.fst \u2264 k = (fun a \u21a6 a.snd \u2264 k) \u2218 (Equiv.prodComm \u2115 \u2115).symm := rfl", "annotated_tactic": ["have aux\u2081 : fun a \u21a6 a.fst \u2264 k = (fun a \u21a6 a.snd \u2264 k) \u2218 (<a>Equiv.prodComm</a> \u2115 \u2115).<a>symm</a> := <a>rfl</a>", [{"full_name": "Equiv.prodComm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [124, 5], "def_end_pos": [124, 13]}, {"full_name": "Equiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [166, 15], "def_end_pos": [166, 19]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "n k : \u2115\nh : k \u2264 n\n\u22a2 filter (fun a => a.1 \u2264 k) (antidiagonal n) =\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)", "state_after": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\n\u22a2 filter (fun a => a.1 \u2264 k) (antidiagonal n) =\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)"}, {"tactic": "have aux\u2082 : \u2200 i j, (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194\n                    \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j :=\n  fun i j \u21a6 by rw [exists_comm]; exact exists\u2082_congr (fun a b \u21a6 by rw [add_comm])", "annotated_tactic": ["have aux\u2082 : \u2200 i j, (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194\n                      \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j :=\n    fun i j \u21a6 by rw [<a>exists_comm</a>]; exact <a>exists\u2082_congr</a> (fun a b \u21a6 by rw [<a>add_comm</a>])", [{"full_name": "exists_comm", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [251, 9], "def_end_pos": [251, 20]}, {"full_name": "exists\u2082_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 22]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\n\u22a2 filter (fun a => a.1 \u2264 k) (antidiagonal n) =\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)", "state_after": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\naux\u2082 : \u2200 (i j : \u2115), (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j\n\u22a2 filter (fun a => a.1 \u2264 k) (antidiagonal n) =\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)"}, {"tactic": "rw [\u2190 map_prodComm_antidiagonal]", "annotated_tactic": ["rw [\u2190 <a>map_prodComm_antidiagonal</a>]", [{"full_name": "Finset.map_prodComm_antidiagonal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Antidiagonal.lean", "def_pos": [86, 17], "def_end_pos": [86, 42]}]], "state_before": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\naux\u2082 : \u2200 (i j : \u2115), (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j\n\u22a2 filter (fun a => a.1 \u2264 k) (antidiagonal n) =\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)", "state_after": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\naux\u2082 : \u2200 (i j : \u2115), (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j\n\u22a2 filter (fun a => a.1 \u2264 k) (map (Equiv.toEmbedding (Equiv.prodComm \u2115 \u2115)) (antidiagonal n)) =\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)"}, {"tactic": "simp_rw [aux\u2081, \u2190 map_filter, antidiagonal_filter_snd_le_of_le h, map_map]", "annotated_tactic": ["simp_rw [aux\u2081, \u2190 <a>map_filter</a>, <a>antidiagonal_filter_snd_le_of_le</a> h, <a>map_map</a>]", [{"full_name": "Finset.map_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [221, 9], "def_end_pos": [221, 19]}, {"full_name": "Finset.Nat.antidiagonal_filter_snd_le_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NatAntidiagonal.lean", "def_pos": [107, 15], "def_end_pos": [107, 47]}, {"full_name": "Finset.map_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [140, 9], "def_end_pos": [140, 16]}]], "state_before": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\naux\u2082 : \u2200 (i j : \u2115), (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j\n\u22a2 filter (fun a => a.1 \u2264 k) (map (Equiv.toEmbedding (Equiv.prodComm \u2115 \u2115)) (antidiagonal n)) =\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)", "state_after": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\naux\u2082 : \u2200 (i j : \u2115), (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j\n\u22a2 map\n      (Embedding.trans (Embedding.prodMap { toFun := fun x => x + (n - k), inj' := \u22ef } (Embedding.refl \u2115))\n        (Equiv.toEmbedding (Equiv.prodComm \u2115 \u2115)))\n      (antidiagonal k) =\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)"}, {"tactic": "ext \u27e8i, j\u27e9", "annotated_tactic": ["ext \u27e8i, j\u27e9", []], "state_before": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\naux\u2082 : \u2200 (i j : \u2115), (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j\n\u22a2 map\n      (Embedding.trans (Embedding.prodMap { toFun := fun x => x + (n - k), inj' := \u22ef } (Embedding.refl \u2115))\n        (Equiv.toEmbedding (Equiv.prodComm \u2115 \u2115)))\n      (antidiagonal k) =\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)", "state_after": "case a.mk\nn k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\naux\u2082 : \u2200 (i j : \u2115), (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j\ni j : \u2115\n\u22a2 (i, j) \u2208\n      map\n        (Embedding.trans (Embedding.prodMap { toFun := fun x => x + (n - k), inj' := \u22ef } (Embedding.refl \u2115))\n          (Equiv.toEmbedding (Equiv.prodComm \u2115 \u2115)))\n        (antidiagonal k) \u2194\n    (i, j) \u2208 map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)"}, {"tactic": "simpa using aux\u2082 i j", "annotated_tactic": ["simpa using aux\u2082 i j", []], "state_before": "case a.mk\nn k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\naux\u2082 : \u2200 (i j : \u2115), (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j\ni j : \u2115\n\u22a2 (i, j) \u2208\n      map\n        (Embedding.trans (Embedding.prodMap { toFun := fun x => x + (n - k), inj' := \u22ef } (Embedding.refl \u2115))\n          (Equiv.toEmbedding (Equiv.prodComm \u2115 \u2115)))\n        (antidiagonal k) \u2194\n    (i, j) \u2208 map (Embedding.prodMap (Embedding.refl \u2115) { toFun := fun x => x + (n - k), inj' := \u22ef }) (antidiagonal k)", "state_after": "no goals"}, {"tactic": "rw [exists_comm]", "annotated_tactic": ["rw [<a>exists_comm</a>]", [{"full_name": "exists_comm", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [251, 9], "def_end_pos": [251, 20]}]], "state_before": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\ni j : \u2115\n\u22a2 (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j", "state_after": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\ni j : \u2115\n\u22a2 (\u2203 b a, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j"}, {"tactic": "exact exists\u2082_congr (fun a b \u21a6 by rw [add_comm])", "annotated_tactic": ["exact <a>exists\u2082_congr</a> (fun a b \u21a6 by rw [<a>add_comm</a>])", [{"full_name": "exists\u2082_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 22]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\ni j : \u2115\n\u22a2 (\u2203 b a, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194 \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j", "state_after": "no goals"}, {"tactic": "rw [add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "n k : \u2115\nh : k \u2264 n\naux\u2081 : (fun a => a.1 \u2264 k) = (fun a => a.2 \u2264 k) \u2218 \u21d1(Equiv.prodComm \u2115 \u2115).symm\ni j a b : \u2115\n\u22a2 b + a = k \u2227 a = i \u2227 b + (n - k) = j \u2194 a + b = k \u2227 a = i \u2227 b + (n - k) = j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csSup_image2_eq_csInf_csSup", "start": [1566, 1], "end": [1569, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "map_dfinsupp_prod", "start": [1724, 1], "end": [1728, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.inter_vsub_union_subset_union", "start": [707, 1], "end": [708, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "toIocMod_eq_toIocMod", "start": [574, 1], "end": [581, 32], "traced_tactics": [{"tactic": "refine' \u27e8fun h => \u27e8toIocDiv hp a c - toIocDiv hp a b, _\u27e9, fun h => _\u27e9", "annotated_tactic": ["refine' \u27e8fun h => \u27e8<a>toIocDiv</a> hp a c - <a>toIocDiv</a> hp a b, _\u27e9, fun h => _\u27e9", [{"full_name": "toIocDiv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [60, 5], "def_end_pos": [60, 13]}, {"full_name": "toIocDiv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [60, 5], "def_end_pos": [60, 13]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\n\u22a2 toIocMod hp a b = toIocMod hp a c \u2194 \u2203 n, c - b = n \u2022 p", "state_after": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\nh : toIocMod hp a b = toIocMod hp a c\n\u22a2 c - b = (toIocDiv hp a c - toIocDiv hp a b) \u2022 p\n\ncase refine'_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\nh : \u2203 n, c - b = n \u2022 p\n\u22a2 toIocMod hp a b = toIocMod hp a c"}, {"tactic": "conv_lhs => rw [\u2190 toIocMod_add_toIocDiv_zsmul hp a b, \u2190 toIocMod_add_toIocDiv_zsmul hp a c]", "annotated_tactic": ["conv_lhs => rw [\u2190 <a>toIocMod_add_toIocDiv_zsmul</a> hp a b, \u2190 <a>toIocMod_add_toIocDiv_zsmul</a> hp a c]", [{"full_name": "toIocMod_add_toIocDiv_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [158, 9], "def_end_pos": [158, 36]}, {"full_name": "toIocMod_add_toIocDiv_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [158, 9], "def_end_pos": [158, 36]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\nh : toIocMod hp a b = toIocMod hp a c\n\u22a2 c - b = (toIocDiv hp a c - toIocDiv hp a b) \u2022 p", "state_after": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\nh : toIocMod hp a b = toIocMod hp a c\n\u22a2 toIocMod hp a c + toIocDiv hp a c \u2022 p - (toIocMod hp a b + toIocDiv hp a b \u2022 p) =\n    (toIocDiv hp a c - toIocDiv hp a b) \u2022 p"}, {"tactic": "rw [h, sub_smul]", "annotated_tactic": ["rw [h, <a>sub_smul</a>]", [{"full_name": "sub_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [274, 9], "def_end_pos": [274, 17]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\nh : toIocMod hp a b = toIocMod hp a c\n\u22a2 toIocMod hp a c + toIocDiv hp a c \u2022 p - (toIocMod hp a b + toIocDiv hp a b \u2022 p) =\n    (toIocDiv hp a c - toIocDiv hp a b) \u2022 p", "state_after": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\nh : toIocMod hp a b = toIocMod hp a c\n\u22a2 toIocMod hp a c + toIocDiv hp a c \u2022 p - (toIocMod hp a c + toIocDiv hp a b \u2022 p) =\n    toIocDiv hp a c \u2022 p - toIocDiv hp a b \u2022 p"}, {"tactic": "abel", "annotated_tactic": ["abel", []], "state_before": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\nh : toIocMod hp a b = toIocMod hp a c\n\u22a2 toIocMod hp a c + toIocDiv hp a c \u2022 p - (toIocMod hp a c + toIocDiv hp a b \u2022 p) =\n    toIocDiv hp a c \u2022 p - toIocDiv hp a b \u2022 p", "state_after": "no goals"}, {"tactic": "rcases h with \u27e8z, hz\u27e9", "annotated_tactic": ["rcases h with \u27e8z, hz\u27e9", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn : \u2124\nh : \u2203 n, c - b = n \u2022 p\n\u22a2 toIocMod hp a b = toIocMod hp a c", "state_after": "case refine'_2.intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn z : \u2124\nhz : c - b = z \u2022 p\n\u22a2 toIocMod hp a b = toIocMod hp a c"}, {"tactic": "rw [sub_eq_iff_eq_add] at hz", "annotated_tactic": ["rw [<a>sub_eq_iff_eq_add</a>] at hz", [{"full_name": "sub_eq_iff_eq_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [908, 3], "def_end_pos": [908, 14]}]], "state_before": "case refine'_2.intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn z : \u2124\nhz : c - b = z \u2022 p\n\u22a2 toIocMod hp a b = toIocMod hp a c", "state_after": "case refine'_2.intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn z : \u2124\nhz : c = z \u2022 p + b\n\u22a2 toIocMod hp a b = toIocMod hp a c"}, {"tactic": "rw [hz, toIocMod_zsmul_add]", "annotated_tactic": ["rw [hz, <a>toIocMod_zsmul_add</a>]", [{"full_name": "toIocMod_zsmul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [438, 9], "def_end_pos": [438, 27]}]], "state_before": "case refine'_2.intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b c : \u03b1\nn z : \u2124\nhz : c = z \u2022 p + b\n\u22a2 toIocMod hp a b = toIocMod hp a c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "full_name": "NonUnitalSubsemiring.mem_carrier", "start": [115, 1], "end": [116, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.diff_iUnion", "start": [532, 1], "end": [533, 48], "traced_tactics": [{"tactic": "rw [diff_eq, compl_iUnion, inter_iInter]", "annotated_tactic": ["rw [<a>diff_eq</a>, <a>compl_iUnion</a>, <a>inter_iInter</a>]", [{"full_name": "Set.diff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [90, 9], "def_end_pos": [90, 16]}, {"full_name": "Set.compl_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [454, 9], "def_end_pos": [454, 21]}, {"full_name": "Set.inter_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [511, 9], "def_end_pos": [511, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ninst\u271d : Nonempty \u03b9\ns : Set \u03b2\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 s \\ \u22c3 i, t i = \u22c2 i, s \\ t i", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ninst\u271d : Nonempty \u03b9\ns : Set \u03b2\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c2 i, s \u2229 (t i)\u1d9c = \u22c2 i, s \\ t i"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ninst\u271d : Nonempty \u03b9\ns : Set \u03b2\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c2 i, s \u2229 (t i)\u1d9c = \u22c2 i, s \\ t i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/MulOpposite.lean", "full_name": "Subgroup.unop_closure", "start": [157, 1], "end": [160, 41], "traced_tactics": [{"tactic": "simp_rw [closure, unop_sInf, Set.preimage_setOf_eq, Subgroup.op_coe]", "annotated_tactic": ["simp_rw [<a>closure</a>, <a>unop_sInf</a>, <a>Set.preimage_setOf_eq</a>, <a>Subgroup.op_coe</a>]", [{"full_name": "Subgroup.closure", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1072, 5], "def_end_pos": [1072, 12]}, {"full_name": "Subgroup.unop_sInf", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/MulOpposite.lean", "def_pos": [133, 9], "def_end_pos": [133, 18]}, {"full_name": "Set.preimage_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [106, 9], "def_end_pos": [106, 26]}, {"full_name": "Subgroup.op_coe", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/MulOpposite.lean", "def_pos": [26, 24], "def_end_pos": [26, 29]}]], "state_before": "\u03b9 : Sort u_1\nG : Type u_2\ninst\u271d : Group G\ns : Set G\u1d50\u1d52\u1d56\n\u22a2 Subgroup.unop (closure s) = closure (MulOpposite.op \u207b\u00b9' s)", "state_after": "\u03b9 : Sort u_1\nG : Type u_2\ninst\u271d : Group G\ns : Set G\u1d50\u1d52\u1d56\n\u22a2 sInf {a | s \u2286 MulOpposite.unop \u207b\u00b9' \u2191a} = sInf {K | MulOpposite.op \u207b\u00b9' s \u2286 \u2191K}"}, {"tactic": "congr with a", "annotated_tactic": ["congr with a", []], "state_before": "\u03b9 : Sort u_1\nG : Type u_2\ninst\u271d : Group G\ns : Set G\u1d50\u1d52\u1d56\n\u22a2 sInf {a | s \u2286 MulOpposite.unop \u207b\u00b9' \u2191a} = sInf {K | MulOpposite.op \u207b\u00b9' s \u2286 \u2191K}", "state_after": "case e_a.h\n\u03b9 : Sort u_1\nG : Type u_2\ninst\u271d : Group G\ns : Set G\u1d50\u1d52\u1d56\na : Subgroup G\n\u22a2 a \u2208 {a | s \u2286 MulOpposite.unop \u207b\u00b9' \u2191a} \u2194 a \u2208 {K | MulOpposite.op \u207b\u00b9' s \u2286 \u2191K}"}, {"tactic": "exact MulOpposite.op_surjective.forall", "annotated_tactic": ["exact MulOpposite.op_surjective.forall", []], "state_before": "case e_a.h\n\u03b9 : Sort u_1\nG : Type u_2\ninst\u271d : Group G\ns : Set G\u1d50\u1d52\u1d56\na : Subgroup G\n\u22a2 a \u2208 {a | s \u2286 MulOpposite.unop \u207b\u00b9' \u2191a} \u2194 a \u2208 {K | MulOpposite.op \u207b\u00b9' s \u2286 \u2191K}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/Order.lean", "full_name": "star_neg_iff", "start": [225, 1], "end": [227, 49], "traced_tactics": [{"tactic": "simpa using star_lt_star_iff (x := x) (y := 0)", "annotated_tactic": ["simpa using <a>star_lt_star_iff</a> (x := x) (y := 0)", [{"full_name": "star_lt_star_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Star/Order.lean", "def_pos": [204, 7], "def_end_pos": [204, 23]}]], "state_before": "R : Type u\ninst\u271d\u00b2 : NonUnitalSemiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : StarOrderedRing R\nx : R\n\u22a2 star x < 0 \u2194 x < 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.norm_sq_eq_def", "start": [476, 1], "end": [477, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "differentiableWithinAt_inv'", "start": [949, 1], "end": [951, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "full_name": "Polynomial.integralNormalization_coeff_degree", "start": [62, 1], "end": [63, 92], "traced_tactics": [{"tactic": "rw [integralNormalization_coeff, if_pos hi]", "annotated_tactic": ["rw [<a>integralNormalization_coeff</a>, <a>if_pos</a> hi]", [{"full_name": "Polynomial.integralNormalization_coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/IntegralNormalization.lean", "def_pos": [48, 9], "def_end_pos": [48, 36]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}]], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\nf : R[X]\ni : \u2115\nhi : degree f = \u2191i\n\u22a2 coeff (integralNormalization f) i = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Order.lean", "full_name": "Finset.prod_eq_one_iff'", "start": [413, 1], "end": [414, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/FiniteType.lean", "full_name": "RingHom.FiniteType.of_comp_finiteType", "start": [291, 1], "end": [298, 63], "traced_tactics": [{"tactic": "let _ := f.toAlgebra", "annotated_tactic": ["let _ := f.toAlgebra", []], "state_before": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\n\u22a2 FiniteType g", "state_after": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d : Algebra A B := toAlgebra f\n\u22a2 FiniteType g"}, {"tactic": "let _ := g.toAlgebra", "annotated_tactic": ["let _ := g.toAlgebra", []], "state_before": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d : Algebra A B := toAlgebra f\n\u22a2 FiniteType g", "state_after": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d\u00b9 : Algebra A B := toAlgebra f\nx\u271d : Algebra B C := toAlgebra g\n\u22a2 FiniteType g"}, {"tactic": "let _ := (g.comp f).toAlgebra", "annotated_tactic": ["let _ := (g.comp f).<a>toAlgebra</a>", [{"full_name": "RingHom.toAlgebra", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [260, 5], "def_end_pos": [260, 22]}]], "state_before": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d\u00b9 : Algebra A B := toAlgebra f\nx\u271d : Algebra B C := toAlgebra g\n\u22a2 FiniteType g", "state_after": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d\u00b2 : Algebra A B := toAlgebra f\nx\u271d\u00b9 : Algebra B C := toAlgebra g\nx\u271d : Algebra A C := toAlgebra (RingHom.comp g f)\n\u22a2 FiniteType g"}, {"tactic": "let _ : IsScalarTower A B C := RestrictScalars.isScalarTower A B C", "annotated_tactic": ["let _ : <a>IsScalarTower</a> A B C := <a>RestrictScalars.isScalarTower</a> A B C", [{"full_name": "IsScalarTower", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [258, 7], "def_end_pos": [258, 20]}, {"full_name": "RestrictScalars.isScalarTower", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/RestrictScalars.lean", "def_pos": [113, 10], "def_end_pos": [113, 39]}]], "state_before": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d\u00b2 : Algebra A B := toAlgebra f\nx\u271d\u00b9 : Algebra B C := toAlgebra g\nx\u271d : Algebra A C := toAlgebra (RingHom.comp g f)\n\u22a2 FiniteType g", "state_after": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d\u00b3 : Algebra A B := toAlgebra f\nx\u271d\u00b2 : Algebra B C := toAlgebra g\nx\u271d\u00b9 : Algebra A C := toAlgebra (RingHom.comp g f)\nx\u271d : IsScalarTower A B C := RestrictScalars.isScalarTower A B C\n\u22a2 FiniteType g"}, {"tactic": "let _ : Algebra.FiniteType A C := h", "annotated_tactic": ["let _ : <a>Algebra.FiniteType</a> A C := h", [{"full_name": "Algebra.FiniteType", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/FiniteType.lean", "def_pos": [41, 7], "def_end_pos": [41, 25]}]], "state_before": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d\u00b3 : Algebra A B := toAlgebra f\nx\u271d\u00b2 : Algebra B C := toAlgebra g\nx\u271d\u00b9 : Algebra A C := toAlgebra (RingHom.comp g f)\nx\u271d : IsScalarTower A B C := RestrictScalars.isScalarTower A B C\n\u22a2 FiniteType g", "state_after": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d\u2074 : Algebra A B := toAlgebra f\nx\u271d\u00b3 : Algebra B C := toAlgebra g\nx\u271d\u00b2 : Algebra A C := toAlgebra (RingHom.comp g f)\nx\u271d\u00b9 : IsScalarTower A B C := RestrictScalars.isScalarTower A B C\nx\u271d : Algebra.FiniteType A C := h\n\u22a2 FiniteType g"}, {"tactic": "exact Algebra.FiniteType.of_restrictScalars_finiteType A B C", "annotated_tactic": ["exact <a>Algebra.FiniteType.of_restrictScalars_finiteType</a> A B C", [{"full_name": "Algebra.FiniteType.of_restrictScalars_finiteType", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/FiniteType.lean", "def_pos": [105, 9], "def_end_pos": [105, 38]}]], "state_before": "A : Type u_1\nB : Type u_2\nC : Type u_3\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : CommRing B\ninst\u271d : CommRing C\nf : A \u2192+* B\ng : B \u2192+* C\nh : FiniteType (RingHom.comp g f)\nx\u271d\u2074 : Algebra A B := toAlgebra f\nx\u271d\u00b3 : Algebra B C := toAlgebra g\nx\u271d\u00b2 : Algebra A C := toAlgebra (RingHom.comp g f)\nx\u271d\u00b9 : IsScalarTower A B C := RestrictScalars.isScalarTower A B C\nx\u271d : Algebra.FiniteType A C := h\n\u22a2 FiniteType g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Real.abs_sin_eq_sqrt_one_sub_cos_sq", "start": [990, 1], "end": [991, 32], "traced_tactics": [{"tactic": "rw [\u2190 sin_sq, sqrt_sq_eq_abs]", "annotated_tactic": ["rw [\u2190 <a>sin_sq</a>, <a>sqrt_sq_eq_abs</a>]", [{"full_name": "Real.sin_sq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [983, 9], "def_end_pos": [983, 15]}, {"full_name": "Real.sqrt_sq_eq_abs", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Sqrt.lean", "def_pos": [243, 9], "def_end_pos": [243, 23]}]], "state_before": "x\u271d y x : \u211d\n\u22a2 |sin x| = sqrt (1 - cos x ^ 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.domRestrict_le", "start": [755, 1], "end": [756, 50], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\n\u22a2 (domRestrict f S).domain \u2264 f.domain", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Order/Basic.lean", "full_name": "Nat.mul_self_le_mul_self", "start": [250, 1], "end": [251, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Complex.tan_conj", "start": [668, 1], "end": [668, 99], "traced_tactics": [{"tactic": "rw [tan, sin_conj, cos_conj, \u2190 map_div\u2080, tan]", "annotated_tactic": ["rw [<a>tan</a>, <a>sin_conj</a>, <a>cos_conj</a>, \u2190 <a>map_div\u2080</a>, <a>tan</a>]", [{"full_name": "Complex.tan", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [72, 5], "def_end_pos": [72, 8]}, {"full_name": "Complex.sin_conj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [607, 9], "def_end_pos": [607, 17]}, {"full_name": "Complex.cos_conj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [630, 9], "def_end_pos": [630, 17]}, {"full_name": "map_div\u2080", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "def_pos": [71, 9], "def_end_pos": [71, 17]}, {"full_name": "Complex.tan", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [72, 5], "def_end_pos": [72, 8]}]], "state_before": "x y : \u2102\n\u22a2 tan ((starRingEnd \u2102) x) = (starRingEnd \u2102) (tan x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Powerset.lean", "full_name": "Finset.powersetCard_map", "start": [330, 1], "end": [348, 17], "traced_tactics": [{"tactic": "simp only [card_map, mem_powersetCard, le_eq_subset, gt_iff_lt, mem_map, mapEmbedding_apply]", "annotated_tactic": ["simp only [<a>card_map</a>, <a>mem_powersetCard</a>, <a>le_eq_subset</a>, <a>gt_iff_lt</a>, <a>mem_map</a>, <a>mapEmbedding_apply</a>]", [{"full_name": "Finset.card_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [295, 9], "def_end_pos": [295, 17]}, {"full_name": "Finset.mem_powersetCard", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Powerset.lean", "def_pos": [204, 15], "def_end_pos": [204, 31]}, {"full_name": "Finset.le_eq_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [398, 9], "def_end_pos": [398, 21]}, {"full_name": "gt_iff_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1937, 17], "def_end_pos": [1937, 26]}, {"full_name": "Finset.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Finset.mapEmbedding_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [193, 9], "def_end_pos": [193, 27]}]], "state_before": "\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 t \u2208 powersetCard n (map f s) \u2194 t \u2208 map (mapEmbedding f).toEmbedding (powersetCard n s)", "state_after": "\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 t \u2286 map f s \u2227 t.card = n \u2194 \u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 t \u2286 map f s \u2227 t.card = n \u2194 \u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t", "state_after": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 t \u2286 map f s \u2227 t.card = n \u2192 \u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t\n\ncase mpr\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 (\u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t) \u2192 t \u2286 map f s \u2227 t.card = n"}, {"tactic": "classical\nintro h\nhave : map f (filter (fun x => (f x \u2208 t)) s) = t := by\n  ext x\n  simp only [mem_map, mem_filter, decide_eq_true_eq]\n  exact \u27e8fun \u27e8_y, \u27e8_hy\u2081, hy\u2082\u27e9, hy\u2083\u27e9 => hy\u2083 \u25b8 hy\u2082,\n    fun hx => let \u27e8y, hy\u27e9 := mem_map.1 (h.1 hx); \u27e8y, \u27e8hy.1, hy.2 \u25b8 hx\u27e9, hy.2\u27e9\u27e9\nrefine' \u27e8_, _, this\u27e9\nrw [\u2190 card_map f, this, h.2]; simp", "annotated_tactic": ["classical\n      intro h\n      have : <a>map</a> f (<a>filter</a> (fun x => (f x \u2208 t)) s) = t := by\n        ext x\n        simp only [<a>mem_map</a>, <a>mem_filter</a>, <a>decide_eq_true_eq</a>]\n        exact \u27e8fun \u27e8_y, \u27e8_hy\u2081, hy\u2082\u27e9, hy\u2083\u27e9 => hy\u2083 \u25b8 hy\u2082,\n          fun hx => let \u27e8y, hy\u27e9 := <a>mem_map</a>.1 (h.1 hx); \u27e8y, \u27e8hy.1, hy.2 \u25b8 hx\u27e9, hy.2\u27e9\u27e9\n      refine' \u27e8_, _, this\u27e9\n      rw [\u2190 <a>card_map</a> f, this, h.2]; simp", [{"full_name": "Finset.map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [51, 5], "def_end_pos": [51, 8]}, {"full_name": "Finset.filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2772, 5], "def_end_pos": [2772, 11]}, {"full_name": "Finset.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "decide_eq_true_eq", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [215, 17], "def_end_pos": [215, 34]}, {"full_name": "Finset.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Finset.card_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [295, 9], "def_end_pos": [295, 17]}]], "state_before": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 t \u2286 map f s \u2227 t.card = n \u2192 \u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 t \u2286 map f s \u2227 t.card = n \u2192 \u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t", "state_after": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\n\u22a2 \u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t"}, {"tactic": "have : map f (filter (fun x => (f x \u2208 t)) s) = t := by\n  ext x\n  simp only [mem_map, mem_filter, decide_eq_true_eq]\n  exact \u27e8fun \u27e8_y, \u27e8_hy\u2081, hy\u2082\u27e9, hy\u2083\u27e9 => hy\u2083 \u25b8 hy\u2082,\n    fun hx => let \u27e8y, hy\u27e9 := mem_map.1 (h.1 hx); \u27e8y, \u27e8hy.1, hy.2 \u25b8 hx\u27e9, hy.2\u27e9\u27e9", "annotated_tactic": ["have : <a>map</a> f (<a>filter</a> (fun x => (f x \u2208 t)) s) = t := by\n        ext x\n        simp only [<a>mem_map</a>, <a>mem_filter</a>, <a>decide_eq_true_eq</a>]\n        exact \u27e8fun \u27e8_y, \u27e8_hy\u2081, hy\u2082\u27e9, hy\u2083\u27e9 => hy\u2083 \u25b8 hy\u2082,\n          fun hx => let \u27e8y, hy\u27e9 := <a>mem_map</a>.1 (h.1 hx); \u27e8y, \u27e8hy.1, hy.2 \u25b8 hx\u27e9, hy.2\u27e9\u27e9", [{"full_name": "Finset.map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [51, 5], "def_end_pos": [51, 8]}, {"full_name": "Finset.filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2772, 5], "def_end_pos": [2772, 11]}, {"full_name": "Finset.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "decide_eq_true_eq", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [215, 17], "def_end_pos": [215, 34]}, {"full_name": "Finset.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}]], "state_before": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\n\u22a2 \u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t", "state_after": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nthis : map f (filter (fun x => f x \u2208 t) s) = t\n\u22a2 \u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t"}, {"tactic": "refine' \u27e8_, _, this\u27e9", "annotated_tactic": ["refine' \u27e8_, _, this\u27e9", []], "state_before": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nthis : map f (filter (fun x => f x \u2208 t) s) = t\n\u22a2 \u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t", "state_after": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nthis : map f (filter (fun x => f x \u2208 t) s) = t\n\u22a2 filter (fun x => f x \u2208 t) s \u2286 s \u2227 (filter (fun x => f x \u2208 t) s).card = n"}, {"tactic": "rw [\u2190 card_map f, this, h.2]", "annotated_tactic": ["rw [\u2190 <a>card_map</a> f, this, h.2]", [{"full_name": "Finset.card_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [295, 9], "def_end_pos": [295, 17]}]], "state_before": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nthis : map f (filter (fun x => f x \u2208 t) s) = t\n\u22a2 filter (fun x => f x \u2208 t) s \u2286 s \u2227 (filter (fun x => f x \u2208 t) s).card = n", "state_after": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nthis : map f (filter (fun x => f x \u2208 t) s) = t\n\u22a2 filter (fun x => f x \u2208 t) s \u2286 s \u2227 n = n"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case mp\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nthis : map f (filter (fun x => f x \u2208 t) s) = t\n\u22a2 filter (fun x => f x \u2208 t) s \u2286 s \u2227 n = n", "state_after": "no goals"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\n\u22a2 map f (filter (fun x => f x \u2208 t) s) = t", "state_after": "case a\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nx : \u03b2\n\u22a2 x \u2208 map f (filter (fun x => f x \u2208 t) s) \u2194 x \u2208 t"}, {"tactic": "simp only [mem_map, mem_filter, decide_eq_true_eq]", "annotated_tactic": ["simp only [<a>mem_map</a>, <a>mem_filter</a>, <a>decide_eq_true_eq</a>]", [{"full_name": "Finset.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Finset.mem_filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 19]}, {"full_name": "decide_eq_true_eq", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [215, 17], "def_end_pos": [215, 34]}]], "state_before": "case a\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nx : \u03b2\n\u22a2 x \u2208 map f (filter (fun x => f x \u2208 t) s) \u2194 x \u2208 t", "state_after": "case a\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nx : \u03b2\n\u22a2 (\u2203 a, (a \u2208 s \u2227 f a \u2208 t) \u2227 f a = x) \u2194 x \u2208 t"}, {"tactic": "exact \u27e8fun \u27e8_y, \u27e8_hy\u2081, hy\u2082\u27e9, hy\u2083\u27e9 => hy\u2083 \u25b8 hy\u2082,\n  fun hx => let \u27e8y, hy\u27e9 := mem_map.1 (h.1 hx); \u27e8y, \u27e8hy.1, hy.2 \u25b8 hx\u27e9, hy.2\u27e9\u27e9", "annotated_tactic": ["exact \u27e8fun \u27e8_y, \u27e8_hy\u2081, hy\u2082\u27e9, hy\u2083\u27e9 => hy\u2083 \u25b8 hy\u2082,\n          fun hx => let \u27e8y, hy\u27e9 := <a>mem_map</a>.1 (h.1 hx); \u27e8y, \u27e8hy.1, hy.2 \u25b8 hx\u27e9, hy.2\u27e9\u27e9", [{"full_name": "Finset.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}]], "state_before": "case a\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\nh : t \u2286 map f s \u2227 t.card = n\nx : \u03b2\n\u22a2 (\u2203 a, (a \u2208 s \u2227 f a \u2208 t) \u2227 f a = x) \u2194 x \u2208 t", "state_after": "no goals"}, {"tactic": "rintro \u27e8a, \u27e8has, rfl\u27e9, rfl\u27e9", "annotated_tactic": ["rintro \u27e8a, \u27e8has, rfl\u27e9, rfl\u27e9", []], "state_before": "case mpr\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d\u00b9 : Finset \u03b1\nn\u271d : ?m.41071\ns\u271d t\u271d : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\nn : \u2115\ns : Finset \u03b1\nt : Finset \u03b2\n\u22a2 (\u2203 a, (a \u2286 s \u2227 a.card = n) \u2227 (mapEmbedding f).toEmbedding a = t) \u2192 t \u2286 map f s \u2227 t.card = n", "state_after": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d : Finset \u03b1\nn : ?m.41071\ns\u271d t : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\ns a : Finset \u03b1\nhas : a \u2286 s\n\u22a2 (mapEmbedding f).toEmbedding a \u2286 map f s \u2227 ((mapEmbedding f).toEmbedding a).card = a.card"}, {"tactic": "dsimp [RelEmbedding.coe_toEmbedding]", "annotated_tactic": ["dsimp [<a>RelEmbedding.coe_toEmbedding</a>]", [{"full_name": "RelEmbedding.coe_toEmbedding", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelIso/Basic.lean", "def_pos": [254, 9], "def_end_pos": [254, 24]}]], "state_before": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d : Finset \u03b1\nn : ?m.41071\ns\u271d t : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\ns a : Finset \u03b1\nhas : a \u2286 s\n\u22a2 (mapEmbedding f).toEmbedding a \u2286 map f s \u2227 ((mapEmbedding f).toEmbedding a).card = a.card", "state_after": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d : Finset \u03b1\nn : ?m.41071\ns\u271d t : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\ns a : Finset \u03b1\nhas : a \u2286 s\n\u22a2 (mapEmbedding f) a \u2286 map f s \u2227 ((mapEmbedding f) a).card = a.card"}, {"tactic": "rw [mapEmbedding_apply]", "annotated_tactic": ["rw [<a>mapEmbedding_apply</a>]", [{"full_name": "Finset.mapEmbedding_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [193, 9], "def_end_pos": [193, 27]}]], "state_before": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d : Finset \u03b1\nn : ?m.41071\ns\u271d t : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\ns a : Finset \u03b1\nhas : a \u2286 s\n\u22a2 (mapEmbedding f) a \u2286 map f s \u2227 ((mapEmbedding f) a).card = a.card", "state_after": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d : Finset \u03b1\nn : ?m.41071\ns\u271d t : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\ns a : Finset \u03b1\nhas : a \u2286 s\n\u22a2 map f a \u2286 map f s \u2227 (map f a).card = a.card"}, {"tactic": "simp [has]", "annotated_tactic": ["simp [has]", []], "state_before": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d : Finset \u03b1\nn : ?m.41071\ns\u271d t : Finset \u03b1\n\u03b2 : Type u_2\nf : \u03b1 \u21aa \u03b2\ns a : Finset \u03b1\nhas : a \u2286 s\n\u22a2 map f a \u2286 map f s \u2227 (map f a).card = a.card", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Finset.mem_compl", "start": [173, 1], "end": [173, 68], "traced_tactics": [{"tactic": "simp [compl_eq_univ_sdiff]", "annotated_tactic": ["simp [<a>compl_eq_univ_sdiff</a>]", [{"full_name": "Finset.compl_eq_univ_sdiff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [168, 9], "def_end_pos": [168, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ns t : Finset \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 a \u2208 s\u1d9c \u2194 a \u2209 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean", "full_name": "Localization.mk_eq_mk_iff", "start": [294, 1], "end": [294, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Bitwise.lean", "full_name": "Nat.lt_of_testBit", "start": [240, 1], "end": [268, 35], "traced_tactics": [{"tactic": "induction' n using Nat.binaryRec with b n hn' generalizing i m", "annotated_tactic": ["induction' n using <a>Nat.binaryRec</a> with b n hn' generalizing i m", [{"full_name": "Nat.binaryRec", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [213, 5], "def_end_pos": [213, 14]}]], "state_before": "n m i : \u2115\nhn : testBit n i = false\nhm : testBit m i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j\n\u22a2 n < m", "state_after": "case z\nm i : \u2115\nhn : testBit 0 i = false\nhm : testBit m i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit 0 j = testBit m j\n\u22a2 0 < m\n\ncase f\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit m i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j\n\u22a2 bit b n < m"}, {"tactic": "induction' m using Nat.binaryRec with b' m hm' generalizing i", "annotated_tactic": ["induction' m using <a>Nat.binaryRec</a> with b' m hm' generalizing i", [{"full_name": "Nat.binaryRec", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [213, 5], "def_end_pos": [213, 14]}]], "state_before": "case f\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit m i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j\n\u22a2 bit b n < m", "state_after": "case f.z\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\ni : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit 0 i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit 0 j\n\u22a2 bit b n < 0\n\ncase f.f\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit (bit b' m) i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\n\u22a2 bit b n < bit b' m"}, {"tactic": "by_cases hi : i = 0", "annotated_tactic": ["by_cases hi : i = 0", []], "state_before": "case f.f\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit (bit b' m) i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\n\u22a2 bit b n < bit b' m", "state_after": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit (bit b' m) i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : i = 0\n\u22a2 bit b n < bit b' m\n\ncase neg\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit (bit b' m) i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00aci = 0\n\u22a2 bit b n < bit b' m"}, {"tactic": "rw [pos_iff_ne_zero]", "annotated_tactic": ["rw [<a>pos_iff_ne_zero</a>]", [{"full_name": "pos_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [230, 3], "def_end_pos": [230, 14]}]], "state_before": "case z\nm i : \u2115\nhn : testBit 0 i = false\nhm : testBit m i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit 0 j = testBit m j\n\u22a2 0 < m", "state_after": "case z\nm i : \u2115\nhn : testBit 0 i = false\nhm : testBit m i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit 0 j = testBit m j\n\u22a2 m \u2260 0"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "case z\nm i : \u2115\nhn : testBit 0 i = false\nhm : testBit m i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit 0 j = testBit m j\n\u22a2 m \u2260 0", "state_after": "case z\ni : \u2115\nhn : testBit 0 i = false\nhm : testBit 0 i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit 0 j = testBit 0 j\n\u22a2 False"}, {"tactic": "simp at hm", "annotated_tactic": ["simp at hm", []], "state_before": "case z\ni : \u2115\nhn : testBit 0 i = false\nhm : testBit 0 i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit 0 j = testBit 0 j\n\u22a2 False", "state_after": "no goals"}, {"tactic": "exact False.elim (Bool.false_ne_true ((zero_testBit i).symm.trans hm))", "annotated_tactic": ["exact <a>False.elim</a> (<a>Bool.false_ne_true</a> ((<a>zero_testBit</a> i).symm.trans hm))", [{"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}, {"full_name": "Bool.false_ne_true", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Bool.lean", "def_pos": [41, 9], "def_end_pos": [41, 22]}, {"full_name": "Nat.zero_testBit", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Bitwise/Lemmas.lean", "def_pos": [71, 17], "def_end_pos": [71, 29]}]], "state_before": "case f.z\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\ni : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit 0 i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit 0 j\n\u22a2 bit b n < 0", "state_after": "no goals"}, {"tactic": "subst hi", "annotated_tactic": ["subst hi", []], "state_before": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit (bit b' m) i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : i = 0\n\u22a2 bit b n < bit b' m", "state_after": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\nhn : testBit (bit b n) 0 = false\nhm : testBit (bit b' m) 0 = true\nhnm : \u2200 (j : \u2115), 0 < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\n\u22a2 bit b n < bit b' m"}, {"tactic": "simp only [testBit_bit_zero] at hn hm", "annotated_tactic": ["simp only [<a>testBit_bit_zero</a>] at hn hm", [{"full_name": "Nat.testBit_bit_zero", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [294, 9], "def_end_pos": [294, 25]}]], "state_before": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\nhn : testBit (bit b n) 0 = false\nhm : testBit (bit b' m) 0 = true\nhnm : \u2200 (j : \u2115), 0 < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\n\u22a2 bit b n < bit b' m", "state_after": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\nhnm : \u2200 (j : \u2115), 0 < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhn : b = false\nhm : b' = true\n\u22a2 bit b n < bit b' m"}, {"tactic": "have : n = m :=\n  eq_of_testBit_eq fun i => by convert hnm (i + 1) (Nat.zero_lt_succ _) using 1\n  <;> rw [testBit_bit_succ]", "annotated_tactic": ["have : n = m :=\n      <a>eq_of_testBit_eq</a> fun i => by convert hnm (i + 1) (<a>Nat.zero_lt_succ</a> _) using 1\n      <;> rw [<a>testBit_bit_succ</a>]", [{"full_name": "Nat.eq_of_testBit_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Bitwise/Lemmas.lean", "def_pos": [134, 9], "def_end_pos": [134, 25]}, {"full_name": "Nat.zero_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1652, 9], "def_end_pos": [1652, 25]}, {"full_name": "Nat.testBit_bit_succ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [310, 9], "def_end_pos": [310, 25]}]], "state_before": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\nhnm : \u2200 (j : \u2115), 0 < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhn : b = false\nhm : b' = true\n\u22a2 bit b n < bit b' m", "state_after": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\nhnm : \u2200 (j : \u2115), 0 < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhn : b = false\nhm : b' = true\nthis : n = m\n\u22a2 bit b n < bit b' m"}, {"tactic": "rw [hn, hm, this, bit_false, bit_true, bit0_val, bit1_val]", "annotated_tactic": ["rw [hn, hm, this, <a>bit_false</a>, <a>bit_true</a>, <a>bit0_val</a>, <a>bit1_val</a>]", [{"full_name": "Nat.bit_false", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [150, 9], "def_end_pos": [150, 18]}, {"full_name": "Nat.bit_true", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [155, 9], "def_end_pos": [155, 17]}, {"full_name": "Nat.bit0_val", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [146, 9], "def_end_pos": [146, 17]}, {"full_name": "Nat.bit1_val", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [153, 9], "def_end_pos": [153, 17]}]], "state_before": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\nhnm : \u2200 (j : \u2115), 0 < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhn : b = false\nhm : b' = true\nthis : n = m\n\u22a2 bit b n < bit b' m", "state_after": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\nhnm : \u2200 (j : \u2115), 0 < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhn : b = false\nhm : b' = true\nthis : n = m\n\u22a2 2 * m < 2 * m + 1"}, {"tactic": "exact lt_add_one _", "annotated_tactic": ["exact <a>lt_add_one</a> _", [{"full_name": "lt_add_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [20, 7], "def_end_pos": [20, 17]}]], "state_before": "case pos\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\nhnm : \u2200 (j : \u2115), 0 < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhn : b = false\nhm : b' = true\nthis : n = m\n\u22a2 2 * m < 2 * m + 1", "state_after": "no goals"}, {"tactic": "convert hnm (i + 1) (Nat.zero_lt_succ _) using 1\n<;> rw [testBit_bit_succ]", "annotated_tactic": ["convert hnm (i + 1) (<a>Nat.zero_lt_succ</a> _) using 1\n      <;> rw [<a>testBit_bit_succ</a>]", [{"full_name": "Nat.zero_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1652, 9], "def_end_pos": [1652, 25]}, {"full_name": "Nat.testBit_bit_succ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [310, 9], "def_end_pos": [310, 25]}]], "state_before": "b : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\nhnm : \u2200 (j : \u2115), 0 < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhn : b = false\nhm : b' = true\ni : \u2115\n\u22a2 testBit n i = testBit m i", "state_after": "no goals"}, {"tactic": "obtain \u27e8i', rfl\u27e9 := exists_eq_succ_of_ne_zero hi", "annotated_tactic": ["obtain \u27e8i', rfl\u27e9 := <a>exists_eq_succ_of_ne_zero</a> hi", [{"full_name": "Nat.exists_eq_succ_of_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [144, 9], "def_end_pos": [144, 34]}]], "state_before": "case neg\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni : \u2115\nhn : testBit (bit b n) i = false\nhm : testBit (bit b' m) i = true\nhnm : \u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00aci = 0\n\u22a2 bit b n < bit b' m", "state_after": "case neg.intro\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni' : \u2115\nhn : testBit (bit b n) (succ i') = false\nhm : testBit (bit b' m) (succ i') = true\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00acsucc i' = 0\n\u22a2 bit b n < bit b' m"}, {"tactic": "simp only [testBit_bit_succ] at hn hm", "annotated_tactic": ["simp only [<a>testBit_bit_succ</a>] at hn hm", [{"full_name": "Nat.testBit_bit_succ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [310, 9], "def_end_pos": [310, 25]}]], "state_before": "case neg.intro\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni' : \u2115\nhn : testBit (bit b n) (succ i') = false\nhm : testBit (bit b' m) (succ i') = true\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00acsucc i' = 0\n\u22a2 bit b n < bit b' m", "state_after": "case neg.intro\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni' : \u2115\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\n\u22a2 bit b n < bit b' m"}, {"tactic": "have := hn' _ hn hm fun j hj => by\n  convert hnm j.succ (succ_lt_succ hj) using 1 <;> rw [testBit_bit_succ]", "annotated_tactic": ["have := hn' _ hn hm fun j hj => by\n      convert hnm j.succ (<a>succ_lt_succ</a> hj) using 1 <;> rw [<a>testBit_bit_succ</a>]", [{"full_name": "Nat.succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [216, 9], "def_end_pos": [216, 21]}, {"full_name": "Nat.testBit_bit_succ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [310, 9], "def_end_pos": [310, 25]}]], "state_before": "case neg.intro\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni' : \u2115\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\n\u22a2 bit b n < bit b' m", "state_after": "case neg.intro\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni' : \u2115\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\n\u22a2 bit b n < bit b' m"}, {"tactic": "have this' : 2 * n < 2 * m := Nat.mul_lt_mul' (le_refl _) this two_pos", "annotated_tactic": ["have this' : 2 * n < 2 * m := <a>Nat.mul_lt_mul'</a> (<a>le_refl</a> _) this <a>two_pos</a>", [{"full_name": "Nat.mul_lt_mul'", "def_path": ".lake/packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [241, 31], "def_end_pos": [241, 42]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}, {"full_name": "two_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [113, 7], "def_end_pos": [113, 14]}]], "state_before": "case neg.intro\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni' : \u2115\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\n\u22a2 bit b n < bit b' m", "state_after": "case neg.intro\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni' : \u2115\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\n\u22a2 bit b n < bit b' m"}, {"tactic": "cases b <;> cases b'\n<;> simp only [bit_false, bit_true, bit0_val n, bit1_val n, bit0_val m, bit1_val m]", "annotated_tactic": ["cases b <;> cases b'\n    <;> simp only [<a>bit_false</a>, <a>bit_true</a>, <a>bit0_val</a> n, <a>bit1_val</a> n, <a>bit0_val</a> m, <a>bit1_val</a> m]", [{"full_name": "Nat.bit_false", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [150, 9], "def_end_pos": [150, 18]}, {"full_name": "Nat.bit_true", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [155, 9], "def_end_pos": [155, 17]}, {"full_name": "Nat.bit0_val", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [146, 9], "def_end_pos": [146, 17]}, {"full_name": "Nat.bit1_val", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [153, 9], "def_end_pos": [153, 17]}, {"full_name": "Nat.bit0_val", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [146, 9], "def_end_pos": [146, 17]}, {"full_name": "Nat.bit1_val", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [153, 9], "def_end_pos": [153, 17]}]], "state_before": "case neg.intro\nb : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni' : \u2115\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\n\u22a2 bit b n < bit b' m", "state_after": "case neg.intro.false.false\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i' : \u2115\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit false n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit false n) j = testBit m j) \u2192 bit false n < m\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit false n) j = testBit (bit false m) j\n\u22a2 2 * n < 2 * m\n\ncase neg.intro.false.true\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i' : \u2115\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit false n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit false n) j = testBit m j) \u2192 bit false n < m\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit false n) j = testBit (bit true m) j\n\u22a2 2 * n < 2 * m + 1\n\ncase neg.intro.true.false\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i' : \u2115\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit true n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit true n) j = testBit m j) \u2192 bit true n < m\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit true n) j = testBit (bit false m) j\n\u22a2 2 * n + 1 < 2 * m\n\ncase neg.intro.true.true\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i' : \u2115\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit true n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit true n) j = testBit m j) \u2192 bit true n < m\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit true n) j = testBit (bit true m) j\n\u22a2 2 * n + 1 < 2 * m + 1"}, {"tactic": "convert hnm j.succ (succ_lt_succ hj) using 1 <;> rw [testBit_bit_succ]", "annotated_tactic": ["convert hnm j.succ (<a>succ_lt_succ</a> hj) using 1 <;> rw [<a>testBit_bit_succ</a>]", [{"full_name": "Nat.succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [216, 9], "def_end_pos": [216, 21]}, {"full_name": "Nat.testBit_bit_succ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [310, 9], "def_end_pos": [310, 25]}]], "state_before": "b : Bool\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nb' : Bool\nm : \u2115\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit b n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit b n) j = testBit m j) \u2192 bit b n < m\ni' : \u2115\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit b n) j = testBit (bit b' m) j\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nj : \u2115\nhj : i' < j\n\u22a2 testBit n j = testBit m j", "state_after": "no goals"}, {"tactic": "exact this'", "annotated_tactic": ["exact this'", []], "state_before": "case neg.intro.false.false\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i' : \u2115\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit false n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit false n) j = testBit m j) \u2192 bit false n < m\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit false n) j = testBit (bit false m) j\n\u22a2 2 * n < 2 * m", "state_after": "no goals"}, {"tactic": "exact Nat.lt_add_right 1 this'", "annotated_tactic": ["exact <a>Nat.lt_add_right</a> 1 this'", [{"full_name": "Nat.lt_add_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [197, 19], "def_end_pos": [197, 31]}]], "state_before": "case neg.intro.false.true\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i' : \u2115\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit false n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit false n) j = testBit m j) \u2192 bit false n < m\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit false n) j = testBit (bit true m) j\n\u22a2 2 * n < 2 * m + 1", "state_after": "no goals"}, {"tactic": "calc\n  2 * n + 1 < 2 * n + 2 := lt.base _\n  _ \u2264 2 * m := mul_le_mul_left 2 this", "annotated_tactic": ["calc\n        2 * n + 1 < 2 * n + 2 := <a>lt.base</a> _\n        _ \u2264 2 * m := <a>mul_le_mul_left</a> 2 this", [{"full_name": "Nat.lt.base", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [300, 9], "def_end_pos": [300, 16]}, {"full_name": "Nat.mul_le_mul_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [470, 9], "def_end_pos": [470, 24]}]], "state_before": "case neg.intro.true.false\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i' : \u2115\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit true n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit true n) j = testBit m j) \u2192 bit true n < m\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit true n) j = testBit (bit false m) j\n\u22a2 2 * n + 1 < 2 * m", "state_after": "no goals"}, {"tactic": "exact Nat.succ_lt_succ this'", "annotated_tactic": ["exact <a>Nat.succ_lt_succ</a> this'", [{"full_name": "Nat.succ_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [216, 9], "def_end_pos": [216, 21]}]], "state_before": "case neg.intro.true.true\nn : \u2115\nhn' :\n  \u2200 {m : \u2115} (i : \u2115), testBit n i = false \u2192 testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit n j = testBit m j) \u2192 n < m\nm i' : \u2115\nhi : \u00acsucc i' = 0\nhn : testBit n i' = false\nhm : testBit m i' = true\nthis : n < m\nthis' : 2 * n < 2 * m\nhm' :\n  \u2200 (i : \u2115),\n    testBit (bit true n) i = false \u2192\n      testBit m i = true \u2192 (\u2200 (j : \u2115), i < j \u2192 testBit (bit true n) j = testBit m j) \u2192 bit true n < m\nhnm : \u2200 (j : \u2115), succ i' < j \u2192 testBit (bit true n) j = testBit (bit true m) j\n\u22a2 2 * n + 1 < 2 * m + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dual.lean", "full_name": "Basis.linearEquiv_dual_iff_finiteDimensional", "start": [423, 1], "end": [430, 52], "traced_tactics": [{"tactic": "refine \u27e8fun \u27e8e\u27e9 \u21a6 ?_, fun h \u21a6 \u27e8(Module.Free.chooseBasis K V).toDualEquiv\u27e9\u27e9", "annotated_tactic": ["refine \u27e8fun \u27e8e\u27e9 \u21a6 ?_, fun h \u21a6 \u27e8(<a>Module.Free.chooseBasis</a> K V).<a>toDualEquiv</a>\u27e9\u27e9", [{"full_name": "Module.Free.chooseBasis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FreeModule/Basic.lean", "def_pos": [85, 19], "def_end_pos": [85, 30]}, {"full_name": "Basis.toDualEquiv", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dual.lean", "def_pos": [410, 5], "def_end_pos": [410, 16]}]], "state_before": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\n\u22a2 Nonempty (V \u2243\u2097[K] Dual K V) \u2194 FiniteDimensional K V", "state_after": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\n\u22a2 FiniteDimensional K V"}, {"tactic": "rw [FiniteDimensional, \u2190 Module.rank_lt_alpeh0_iff]", "annotated_tactic": ["rw [<a>FiniteDimensional</a>, \u2190 <a>Module.rank_lt_alpeh0_iff</a>]", [{"full_name": "FiniteDimensional", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FiniteDimensional.lean", "def_pos": [79, 5], "def_end_pos": [79, 22]}, {"full_name": "Module.rank_lt_alpeh0_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Free.lean", "def_pos": [181, 7], "def_end_pos": [181, 32]}]], "state_before": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\n\u22a2 FiniteDimensional K V", "state_after": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\n\u22a2 Module.rank K V < \u2135\u2080"}, {"tactic": "by_contra!", "annotated_tactic": ["by_contra!", []], "state_before": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\n\u22a2 Module.rank K V < \u2135\u2080", "state_after": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\nthis : \u2135\u2080 \u2264 Module.rank K V\n\u22a2 False"}, {"tactic": "apply (lift_rank_lt_rank_dual this).ne", "annotated_tactic": ["apply (<a>lift_rank_lt_rank_dual</a> this).<a>ne</a>", [{"full_name": "lift_rank_lt_rank_dual", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/DivisionRing.lean", "def_pos": [554, 9], "def_end_pos": [554, 31]}, {"full_name": "LT.lt.ne", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [149, 7], "def_end_pos": [149, 15]}]], "state_before": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\nthis : \u2135\u2080 \u2264 Module.rank K V\n\u22a2 False", "state_after": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\nthis : \u2135\u2080 \u2264 Module.rank K V\n\u22a2 lift.{uK, uV} (Module.rank K V) = Module.rank K (V \u2192\u2097[K] K)"}, {"tactic": "have := e.lift_rank_eq", "annotated_tactic": ["have := e.lift_rank_eq", []], "state_before": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\nthis : \u2135\u2080 \u2264 Module.rank K V\n\u22a2 lift.{uK, uV} (Module.rank K V) = Module.rank K (V \u2192\u2097[K] K)", "state_after": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\nthis\u271d : \u2135\u2080 \u2264 Module.rank K V\nthis : lift.{max uK uV, uV} (Module.rank K V) = lift.{uV, max uK uV} (Module.rank K (Dual K V))\n\u22a2 lift.{uK, uV} (Module.rank K V) = Module.rank K (V \u2192\u2097[K] K)"}, {"tactic": "rwa [lift_umax.{uV,uK}, lift_id'.{uV,uK}] at this", "annotated_tactic": ["rwa [<a>lift_umax</a>.{uV,uK}, <a>lift_id'</a>.{uV,uK}] at this", [{"full_name": "Cardinal.lift_umax", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [202, 9], "def_end_pos": [202, 18]}, {"full_name": "Cardinal.lift_id'", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [218, 9], "def_end_pos": [218, 17]}]], "state_before": "R : Type uR\nM : Type uM\nK : Type uK\nV : Type uV\n\u03b9 : Type u\u03b9\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : DecidableEq \u03b9\nb : Basis \u03b9 R M\ninst\u271d\u00b3 : _root_.Finite \u03b9\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx\u271d : Nonempty (V \u2243\u2097[K] Dual K V)\ne : V \u2243\u2097[K] Dual K V\nthis\u271d : \u2135\u2080 \u2264 Module.rank K V\nthis : lift.{max uK uV, uV} (Module.rank K V) = lift.{uV, max uK uV} (Module.rank K (Dual K V))\n\u22a2 lift.{uK, uV} (Module.rank K V) = Module.rank K (V \u2192\u2097[K] K)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Multiplicity.lean", "full_name": "multiplicity.pow_dvd_of_le_multiplicity", "start": [100, 1], "end": [108, 97], "traced_tactics": [{"tactic": "exact\n  Nat.casesOn k\n    (fun _ => by\n      rw [_root_.pow_zero]\n      exact one_dvd _)\n    fun k \u27e8_, h\u2082\u27e9 => by_contradiction fun hk => Nat.find_min _ (lt_of_succ_le (h\u2082 \u27e8k, hk\u27e9)) hk", "annotated_tactic": ["exact\n    <a>Nat.casesOn</a> k\n      (fun _ => by\n        rw [<a>_root_.pow_zero</a>]\n        exact <a>one_dvd</a> _)\n      fun k \u27e8_, h\u2082\u27e9 => <a>by_contradiction</a> fun hk => <a>Nat.find_min</a> _ (<a>lt_of_succ_le</a> (h\u2082 \u27e8k, hk\u27e9)) hk", [{"full_name": "Nat.casesOn", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1065, 11], "def_end_pos": [1065, 14]}, {"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}, {"full_name": "one_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [146, 9], "def_end_pos": [146, 16]}, {"full_name": "by_contradiction", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [214, 9], "def_end_pos": [214, 25]}, {"full_name": "Nat.find_min", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Nat/Lemmas.lean", "def_pos": [722, 19], "def_end_pos": [722, 27]}, {"full_name": "Nat.lt_of_succ_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [291, 9], "def_end_pos": [291, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\n\u22a2 \u2191k \u2264 multiplicity a b \u2192 a ^ k \u2223 b", "state_after": "no goals"}, {"tactic": "rw [_root_.pow_zero]", "annotated_tactic": ["rw [<a>_root_.pow_zero</a>]", [{"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\nx\u271d : \u2191zero \u2264 multiplicity a b\n\u22a2 a ^ zero \u2223 b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\nx\u271d : \u2191zero \u2264 multiplicity a b\n\u22a2 1 \u2223 b"}, {"tactic": "exact one_dvd _", "annotated_tactic": ["exact <a>one_dvd</a> _", [{"full_name": "one_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [146, 9], "def_end_pos": [146, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2223 x_1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\nx\u271d : \u2191zero \u2264 multiplicity a b\n\u22a2 1 \u2223 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.associator_naturality_left", "start": [457, 1], "end": [458, 74], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "C\u271d : Type u\n\ud835\udc9e : Category.{v, u} C\u271d\ninst\u271d\u00b2 : MonoidalCategory C\u271d\nC : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nU V W X\u271d Y\u271d Z\u271d X X' : C\nf : X \u27f6 X'\nY Z : C\n\u22a2 f \u25b7 Y \u25b7 Z \u226b (\u03b1_ X' Y Z).hom = (\u03b1_ X Y Z).hom \u226b f \u25b7 (Y \u2297 Z)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean", "full_name": "DifferentiableAt.cexp", "start": [145, 1], "end": [147, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Irrational.lean", "full_name": "Irrational.nat_div", "start": [447, 1], "end": [448, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.eval\u2082_eq_eval_map", "start": [1265, 1], "end": [1277, 36], "traced_tactics": [{"tactic": "unfold map eval", "annotated_tactic": ["unfold <a>map</a> <a>eval</a>", [{"full_name": "MvPolynomial.map", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1232, 5], "def_end_pos": [1232, 8]}, {"full_name": "MvPolynomial.eval", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1149, 5], "def_end_pos": [1149, 9]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\n\u22a2 eval\u2082 f g p = (eval g) ((map f) p)", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\n\u22a2 eval\u2082 f g p = (eval\u2082Hom (RingHom.id S\u2081) g) ((eval\u2082Hom (RingHom.comp C f) X) p)"}, {"tactic": "simp only [coe_eval\u2082Hom]", "annotated_tactic": ["simp only [<a>coe_eval\u2082Hom</a>]", [{"full_name": "MvPolynomial.coe_eval\u2082Hom", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1055, 9], "def_end_pos": [1055, 21]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\n\u22a2 eval\u2082 f g p = (eval\u2082Hom (RingHom.id S\u2081) g) ((eval\u2082Hom (RingHom.comp C f) X) p)", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\n\u22a2 eval\u2082 f g p = eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p)"}, {"tactic": "have h := eval\u2082_comp_left (eval\u2082Hom (RingHom.id S\u2081) g) (C.comp f) X p", "annotated_tactic": ["have h := <a>eval\u2082_comp_left</a> (<a>eval\u2082Hom</a> (<a>RingHom.id</a> S\u2081) g) (C.comp f) <a>X</a> p", [{"full_name": "MvPolynomial.eval\u2082_comp_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1100, 9], "def_end_pos": [1100, 24]}, {"full_name": "MvPolynomial.eval\u2082Hom", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1045, 5], "def_end_pos": [1045, 13]}, {"full_name": "RingHom.id", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [629, 5], "def_end_pos": [629, 7]}, {"full_name": "MvPolynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [190, 5], "def_end_pos": [190, 6]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\n\u22a2 eval\u2082 f g p = eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p)", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  (eval\u2082Hom (RingHom.id S\u2081) g) (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (\u21d1(eval\u2082Hom (RingHom.id S\u2081) g) \u2218 X) p\n\u22a2 eval\u2082 f g p = eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p)"}, {"tactic": "dsimp [-eval\u2082_id] at h", "annotated_tactic": ["dsimp [-eval\u2082_id] at h", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  (eval\u2082Hom (RingHom.id S\u2081) g) (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (\u21d1(eval\u2082Hom (RingHom.id S\u2081) g) \u2218 X) p\n\u22a2 eval\u2082 f g p = eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p)", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\n\u22a2 eval\u2082 f g p = eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p)"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\n\u22a2 eval\u2082 f g p = eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p)", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\n\u22a2 eval\u2082 f g p = eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\n\u22a2 eval\u2082 f g p = eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p", "state_after": "case e_f\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\n\u22a2 f = RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)\n\ncase e_g\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\n\u22a2 g = eval\u2082 (RingHom.id S\u2081) g \u2218 X"}, {"tactic": "ext1 a", "annotated_tactic": ["ext1 a", []], "state_before": "case e_f\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\n\u22a2 f = RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)", "state_after": "case e_f.a\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\na : R\n\u22a2 f a = (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) a"}, {"tactic": "simp only [coe_eval\u2082Hom, RingHom.id_apply, comp_apply, eval\u2082_C, RingHom.coe_comp]", "annotated_tactic": ["simp only [<a>coe_eval\u2082Hom</a>, <a>RingHom.id_apply</a>, <a>comp_apply</a>, <a>eval\u2082_C</a>, <a>RingHom.coe_comp</a>]", [{"full_name": "MvPolynomial.coe_eval\u2082Hom", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1055, 9], "def_end_pos": [1055, 21]}, {"full_name": "RingHom.id_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [637, 9], "def_end_pos": [637, 17]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "MvPolynomial.eval\u2082_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [992, 9], "def_end_pos": [992, 16]}, {"full_name": "RingHom.coe_comp", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [665, 9], "def_end_pos": [665, 17]}]], "state_before": "case e_f.a\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\na : R\n\u22a2 f a = (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) a", "state_after": "no goals"}, {"tactic": "ext1 n", "annotated_tactic": ["ext1 n", []], "state_before": "case e_g\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\n\u22a2 g = eval\u2082 (RingHom.id S\u2081) g \u2218 X", "state_after": "case e_g.h\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\nn : \u03c3\n\u22a2 g n = (eval\u2082 (RingHom.id S\u2081) g \u2218 X) n"}, {"tactic": "simp only [comp_apply, eval\u2082_X]", "annotated_tactic": ["simp only [<a>comp_apply</a>, <a>eval\u2082_X</a>]", [{"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "MvPolynomial.eval\u2082_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1002, 9], "def_end_pos": [1002, 16]}]], "state_before": "case e_g.h\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn\u271d m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\np : MvPolynomial \u03c3 R\nh :\n  eval\u2082 (RingHom.id S\u2081) g (eval\u2082 (RingHom.comp C f) X p) =\n    eval\u2082 (RingHom.comp (eval\u2082Hom (RingHom.id S\u2081) g) (RingHom.comp C f)) (eval\u2082 (RingHom.id S\u2081) g \u2218 X) p\nn : \u03c3\n\u22a2 g n = (eval\u2082 (RingHom.id S\u2081) g \u2218 X) n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.castPred_one", "start": [1331, 1], "end": [1334, 8], "traced_tactics": [{"tactic": "cases n", "annotated_tactic": ["cases n", []], "state_before": "n m : \u2115\ninst\u271d : NeZero n\nh : optParam (1 \u2260 last (n + 1)) \u22ef\n\u22a2 castPred 1 h = 1", "state_after": "case zero\nm : \u2115\ninst\u271d : NeZero zero\nh : optParam (1 \u2260 last (zero + 1)) \u22ef\n\u22a2 castPred 1 h = 1\n\ncase succ\nm n\u271d : \u2115\ninst\u271d : NeZero (Nat.succ n\u271d)\nh : optParam (1 \u2260 last (Nat.succ n\u271d + 1)) \u22ef\n\u22a2 castPred 1 h = 1"}, {"tactic": "exact subsingleton_one.elim _ 1", "annotated_tactic": ["exact subsingleton_one.elim _ 1", []], "state_before": "case zero\nm : \u2115\ninst\u271d : NeZero zero\nh : optParam (1 \u2260 last (zero + 1)) \u22ef\n\u22a2 castPred 1 h = 1", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case succ\nm n\u271d : \u2115\ninst\u271d : NeZero (Nat.succ n\u271d)\nh : optParam (1 \u2260 last (Nat.succ n\u271d + 1)) \u22ef\n\u22a2 castPred 1 h = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Functor.lean", "full_name": "CategoryTheory.MonoidalFunctor.\u03b5_hom_inv_id", "start": [328, 1], "end": [329, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Congruence.lean", "full_name": "Con.toSetoid_inj", "start": [195, 1], "end": [196, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.smul_empty", "start": [452, 1], "end": [453, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/MeanValue.lean", "full_name": "Convex.lipschitzOnWith_of_nnnorm_hasDerivWithin_le", "start": [657, 1], "end": [661, 53], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "E : Type u_1\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \u211d F\n\ud835\udd5c : Type u_3\nG : Type u_4\ninst\u271d\u00b3 : IsROrC \ud835\udd5c\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nf f' : \ud835\udd5c \u2192 G\ns : Set \ud835\udd5c\nx\u271d y : \ud835\udd5c\nC : \u211d\u22650\nhs : Convex \u211d s\nhf : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x\nbound : \u2200 x \u2208 s, \u2016f' x\u2016\u208a \u2264 C\nx : \ud835\udd5c\nhx : x \u2208 s\n\u22a2 \u2016smulRight 1 (f' x)\u2016\u208a \u2264 \u2016f' x\u2016\u208a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Matrix.lean", "full_name": "Continuous.matrix_reindex", "start": [171, 1], "end": [173, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pi.lean", "full_name": "Filter.mem_coprod\u1d62_iff", "start": [224, 1], "end": [225, 94], "traced_tactics": [{"tactic": "simp [Filter.coprod\u1d62]", "annotated_tactic": ["simp [<a>Filter.coprod\u1d62</a>]", [{"full_name": "Filter.coprod\u1d62", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Pi.lean", "def_pos": [220, 15], "def_end_pos": [220, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\nf f\u2081 f\u2082 : (i : \u03b9) \u2192 Filter (\u03b1 i)\ns\u271d : (i : \u03b9) \u2192 Set (\u03b1 i)\np : (i : \u03b9) \u2192 \u03b1 i \u2192 Prop\ns : Set ((i : \u03b9) \u2192 \u03b1 i)\n\u22a2 s \u2208 Filter.coprod\u1d62 f \u2194 \u2200 (i : \u03b9), \u2203 t\u2081 \u2208 f i, eval i \u207b\u00b9' t\u2081 \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Cast/Lemmas.lean", "full_name": "MonoidHom.ext_int", "start": [355, 1], "end": [361, 58], "traced_tactics": [{"tactic": "ext (x | x)", "annotated_tactic": ["ext (x | x)", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : f (-1) = g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\n\u22a2 f = g", "state_after": "case h.ofNat\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : f (-1) = g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 f (ofNat x) = g (ofNat x)\n\ncase h.negSucc\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : f (-1) = g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 f -[x+1] = g -[x+1]"}, {"tactic": "exact (DFunLike.congr_fun h_nat x : _)", "annotated_tactic": ["exact (<a>DFunLike.congr_fun</a> h_nat x : _)", [{"full_name": "DFunLike.congr_fun", "def_path": ".lake/packages/mathlib/Mathlib/Data/FunLike/Basic.lean", "def_pos": [213, 19], "def_end_pos": [213, 28]}]], "state_before": "case h.ofNat\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : f (-1) = g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 f (ofNat x) = g (ofNat x)", "state_after": "no goals"}, {"tactic": "rw [Int.negSucc_eq, \u2190 neg_one_mul, f.map_mul, g.map_mul]", "annotated_tactic": ["rw [<a>Int.negSucc_eq</a>, \u2190 <a>neg_one_mul</a>, f.map_mul, g.map_mul]", [{"full_name": "Int.negSucc_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [64, 9], "def_end_pos": [64, 19]}, {"full_name": "neg_one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [345, 9], "def_end_pos": [345, 20]}]], "state_before": "case h.negSucc\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : f (-1) = g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 f -[x+1] = g -[x+1]", "state_after": "case h.negSucc\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : f (-1) = g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 f (-1) * f (\u2191x + 1) = g (-1) * g (\u2191x + 1)"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "case h.negSucc\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : f (-1) = g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 f (-1) * f (\u2191x + 1) = g (-1) * g (\u2191x + 1)", "state_after": "case h.negSucc.e_a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : f (-1) = g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 f (\u2191x + 1) = g (\u2191x + 1)"}, {"tactic": "exact mod_cast (DFunLike.congr_fun h_nat (x + 1) : _)", "annotated_tactic": ["exact mod_cast (<a>DFunLike.congr_fun</a> h_nat (x + 1) : _)", [{"full_name": "DFunLike.congr_fun", "def_path": ".lake/packages/mathlib/Mathlib/Data/FunLike/Basic.lean", "def_pos": [213, 19], "def_end_pos": [213, 28]}]], "state_before": "case h.negSucc.e_a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : f (-1) = g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 f (\u2191x + 1) = g (\u2191x + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "le_one_of_mul_le_right", "start": [435, 1], "end": [437, 52], "traced_tactics": [{"tactic": "simpa only [mul_one]", "annotated_tactic": ["simpa only [<a>mul_one</a>]", [{"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : MulOneClass \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na b : \u03b1\nh : a * b \u2264 a\n\u22a2 ?m.21382 h * b \u2264 ?m.21382 h * 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.aroots_mul", "start": [1094, 1], "end": [1100, 51], "traced_tactics": [{"tactic": "suffices map (algebraMap T S) p * map (algebraMap T S) q \u2260 0 by\n  rw [aroots_def, Polynomial.map_mul, roots_mul this]", "annotated_tactic": ["suffices <a>map</a> (<a>algebraMap</a> T S) p * <a>map</a> (<a>algebraMap</a> T S) q \u2260 0 by\n    rw [<a>aroots_def</a>, <a>Polynomial.map_mul</a>, <a>roots_mul</a> this]", [{"full_name": "Polynomial.map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [710, 5], "def_end_pos": [710, 8]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "Polynomial.map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [710, 5], "def_end_pos": [710, 8]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "Polynomial.aroots_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1081, 9], "def_end_pos": [1081, 19]}, {"full_name": "Polynomial.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [746, 19], "def_end_pos": [746, 26]}, {"full_name": "Polynomial.roots_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [775, 9], "def_end_pos": [775, 18]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : IsDomain R\np\u271d q\u271d : R[X]\ninst\u271d\u2074 : CommRing T\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : Algebra T S\ninst\u271d : NoZeroSMulDivisors T S\np q : T[X]\nhpq : p * q \u2260 0\n\u22a2 aroots (p * q) S = aroots p S + aroots q S", "state_after": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : IsDomain R\np\u271d q\u271d : R[X]\ninst\u271d\u2074 : CommRing T\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : Algebra T S\ninst\u271d : NoZeroSMulDivisors T S\np q : T[X]\nhpq : p * q \u2260 0\n\u22a2 map (algebraMap T S) p * map (algebraMap T S) q \u2260 0"}, {"tactic": "rwa [\u2190 Polynomial.map_mul, Polynomial.map_ne_zero_iff\n  (NoZeroSMulDivisors.algebraMap_injective T S)]", "annotated_tactic": ["rwa [\u2190 <a>Polynomial.map_mul</a>, <a>Polynomial.map_ne_zero_iff</a>\n    (<a>NoZeroSMulDivisors.algebraMap_injective</a> T S)]", [{"full_name": "Polynomial.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [746, 19], "def_end_pos": [746, 26]}, {"full_name": "Polynomial.map_ne_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [884, 19], "def_end_pos": [884, 34]}, {"full_name": "NoZeroSMulDivisors.algebraMap_injective", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [789, 9], "def_end_pos": [789, 29]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : IsDomain R\np\u271d q\u271d : R[X]\ninst\u271d\u2074 : CommRing T\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : Algebra T S\ninst\u271d : NoZeroSMulDivisors T S\np q : T[X]\nhpq : p * q \u2260 0\n\u22a2 map (algebraMap T S) p * map (algebraMap T S) q \u2260 0", "state_after": "no goals"}, {"tactic": "rw [aroots_def, Polynomial.map_mul, roots_mul this]", "annotated_tactic": ["rw [<a>aroots_def</a>, <a>Polynomial.map_mul</a>, <a>roots_mul</a> this]", [{"full_name": "Polynomial.aroots_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1081, 9], "def_end_pos": [1081, 19]}, {"full_name": "Polynomial.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [746, 19], "def_end_pos": [746, 26]}, {"full_name": "Polynomial.roots_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [775, 9], "def_end_pos": [775, 18]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : IsDomain R\np\u271d q\u271d : R[X]\ninst\u271d\u2074 : CommRing T\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : Algebra T S\ninst\u271d : NoZeroSMulDivisors T S\np q : T[X]\nhpq : p * q \u2260 0\nthis : map (algebraMap T S) p * map (algebraMap T S) q \u2260 0\n\u22a2 aroots (p * q) S = aroots p S + aroots q S", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order.lean", "full_name": "continuous_le_dom", "start": [710, 1], "end": [713, 23], "traced_tactics": [{"tactic": "rw [continuous_iff_le_induced] at h\u2082 \u22a2", "annotated_tactic": ["rw [<a>continuous_iff_le_induced</a>] at h\u2082 \u22a2", [{"full_name": "continuous_iff_le_induced", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [678, 9], "def_end_pos": [678, 34]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_2\nt\u2081 t\u2082 : TopologicalSpace \u03b1\nt\u2083 : TopologicalSpace \u03b2\nh\u2081 : t\u2082 \u2264 t\u2081\nh\u2082 : Continuous f\n\u22a2 Continuous f", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_2\nt\u2081 t\u2082 : TopologicalSpace \u03b1\nt\u2083 : TopologicalSpace \u03b2\nh\u2081 : t\u2082 \u2264 t\u2081\nh\u2082 : t\u2081 \u2264 induced f t\u2083\n\u22a2 t\u2082 \u2264 induced f t\u2083"}, {"tactic": "exact le_trans h\u2081 h\u2082", "annotated_tactic": ["exact <a>le_trans</a> h\u2081 h\u2082", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_2\nt\u2081 t\u2082 : TopologicalSpace \u03b1\nt\u2083 : TopologicalSpace \u03b2\nh\u2081 : t\u2082 \u2264 t\u2081\nh\u2082 : t\u2081 \u2264 induced f t\u2083\n\u22a2 t\u2082 \u2264 induced f t\u2083", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "full_name": "SMul.comp.smulCommClass", "start": [392, 1], "end": [396, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Group.lean", "full_name": "Mathlib.Tactic.Group.zpow_trick_one", "start": [43, 1], "end": [44, 72], "traced_tactics": [{"tactic": "rw [mul_assoc, mul_self_zpow]", "annotated_tactic": ["rw [<a>mul_assoc</a>, <a>mul_self_zpow</a>]", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_self_zpow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [460, 7], "def_end_pos": [460, 20]}]], "state_before": "G : Type u_1\ninst\u271d : Group G\na b : G\nm : \u2124\n\u22a2 a * b * b ^ m = a * b ^ (m + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "Antitone.forall", "start": [535, 1], "end": [537, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "full_name": "Subsemigroup.map_map", "start": [252, 1], "end": [253, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Torsion.lean", "full_name": "Submodule.exists_isTorsionBy", "start": [809, 1], "end": [822, 80], "traced_tactics": [{"tactic": "let oj := List.argmax (fun i => pOrder hM <| s i) (List.finRange d)", "annotated_tactic": ["let oj := <a>List.argmax</a> (fun i => <a>pOrder</a> hM <| s i) (<a>List.finRange</a> d)", [{"full_name": "List.argmax", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/MinMax.lean", "def_pos": [101, 5], "def_end_pos": [101, 11]}, {"full_name": "Submodule.pOrder", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean", "def_pos": [794, 5], "def_end_pos": [794, 11]}, {"full_name": "List.finRange", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Range.lean", "def_pos": [131, 5], "def_end_pos": [131, 13]}]], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\n\u22a2 \u2203 j, IsTorsionBy R M (p ^ pOrder hM (s j))", "state_after": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\n\u22a2 \u2203 j, IsTorsionBy R M (p ^ pOrder hM (s j))"}, {"tactic": "have hoj : oj.isSome :=\n  Option.ne_none_iff_isSome.mp fun eq_none =>\n    hd <| List.finRange_eq_nil.mp <| List.argmax_eq_none.mp eq_none", "annotated_tactic": ["have hoj : oj.isSome :=\n    Option.ne_none_iff_isSome.mp fun eq_none =>\n      hd <| List.finRange_eq_nil.mp <| List.argmax_eq_none.mp eq_none", []], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\n\u22a2 \u2203 j, IsTorsionBy R M (p ^ pOrder hM (s j))", "state_after": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\n\u22a2 \u2203 j, IsTorsionBy R M (p ^ pOrder hM (s j))"}, {"tactic": "use Option.get _ hoj", "annotated_tactic": ["use <a>Option.get</a> _ hoj", [{"full_name": "Option.get", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [103, 15], "def_end_pos": [103, 18]}]], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\n\u22a2 \u2203 j, IsTorsionBy R M (p ^ pOrder hM (s j))", "state_after": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\n\u22a2 IsTorsionBy R M (p ^ pOrder hM (s (Option.get oj hoj)))"}, {"tactic": "rw [isTorsionBy_iff_torsionBy_eq_top, eq_top_iff, \u2190 hs, Submodule.span_le,\n  Set.range_subset_iff]", "annotated_tactic": ["rw [<a>isTorsionBy_iff_torsionBy_eq_top</a>, <a>eq_top_iff</a>, \u2190 hs, <a>Submodule.span_le</a>,\n    <a>Set.range_subset_iff</a>]", [{"full_name": "Module.isTorsionBy_iff_torsionBy_eq_top", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean", "def_pos": [338, 9], "def_end_pos": [338, 41]}, {"full_name": "eq_top_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [133, 9], "def_end_pos": [133, 19]}, {"full_name": "Submodule.span_le", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [79, 9], "def_end_pos": [79, 16]}, {"full_name": "Set.range_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [725, 9], "def_end_pos": [725, 25]}]], "state_before": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\n\u22a2 IsTorsionBy R M (p ^ pOrder hM (s (Option.get oj hoj)))", "state_after": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\n\u22a2 \u2200 (y : Fin d), s y \u2208 \u2191(torsionBy R M (p ^ pOrder hM (s (Option.get oj hoj))))"}, {"tactic": "intro i", "annotated_tactic": ["intro i", []], "state_before": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\n\u22a2 \u2200 (y : Fin d), s y \u2208 \u2191(torsionBy R M (p ^ pOrder hM (s (Option.get oj hoj))))", "state_after": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\ni : Fin d\n\u22a2 s i \u2208 \u2191(torsionBy R M (p ^ pOrder hM (s (Option.get oj hoj))))"}, {"tactic": "change (p ^ pOrder hM (s (Option.get oj hoj))) \u2022 s i = 0", "annotated_tactic": ["change (p ^ <a>pOrder</a> hM (s (<a>Option.get</a> oj hoj))) \u2022 s i = 0", [{"full_name": "Submodule.pOrder", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean", "def_pos": [794, 5], "def_end_pos": [794, 11]}, {"full_name": "Option.get", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [103, 15], "def_end_pos": [103, 18]}]], "state_before": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\ni : Fin d\n\u22a2 s i \u2208 \u2191(torsionBy R M (p ^ pOrder hM (s (Option.get oj hoj))))", "state_after": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\ni : Fin d\n\u22a2 p ^ pOrder hM (s (Option.get oj hoj)) \u2022 s i = 0"}, {"tactic": "have : pOrder hM (s i) \u2264 pOrder hM (s <| Option.get _ hoj) :=\n  List.le_of_mem_argmax (List.mem_finRange i) (Option.get_mem hoj)", "annotated_tactic": ["have : <a>pOrder</a> hM (s i) \u2264 <a>pOrder</a> hM (s <| <a>Option.get</a> _ hoj) :=\n    <a>List.le_of_mem_argmax</a> (<a>List.mem_finRange</a> i) (<a>Option.get_mem</a> hoj)", [{"full_name": "Submodule.pOrder", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean", "def_pos": [794, 5], "def_end_pos": [794, 11]}, {"full_name": "Submodule.pOrder", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean", "def_pos": [794, 5], "def_end_pos": [794, 11]}, {"full_name": "Option.get", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [103, 15], "def_end_pos": [103, 18]}, {"full_name": "List.le_of_mem_argmax", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/MinMax.lean", "def_pos": [178, 9], "def_end_pos": [178, 25]}, {"full_name": "List.mem_finRange", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Range.lean", "def_pos": [141, 9], "def_end_pos": [141, 21]}, {"full_name": "Option.get_mem", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean", "def_pos": [25, 9], "def_end_pos": [25, 16]}]], "state_before": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\ni : Fin d\n\u22a2 p ^ pOrder hM (s (Option.get oj hoj)) \u2022 s i = 0", "state_after": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\ni : Fin d\nthis : pOrder hM (s i) \u2264 pOrder hM (s (Option.get oj hoj))\n\u22a2 p ^ pOrder hM (s (Option.get oj hoj)) \u2022 s i = 0"}, {"tactic": "rw [\u2190 Nat.sub_add_cancel this, pow_add, mul_smul, pow_pOrder_smul, smul_zero]", "annotated_tactic": ["rw [\u2190 <a>Nat.sub_add_cancel</a> this, <a>pow_add</a>, <a>mul_smul</a>, <a>pow_pOrder_smul</a>, <a>smul_zero</a>]", [{"full_name": "Nat.sub_add_cancel", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [624, 27], "def_end_pos": [624, 41]}, {"full_name": "pow_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [103, 9], "def_end_pos": [103, 16]}, {"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}, {"full_name": "Submodule.pow_pOrder_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Torsion.lean", "def_pos": [800, 9], "def_end_pos": [800, 24]}, {"full_name": "smul_zero", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [760, 9], "def_end_pos": [760, 18]}]], "state_before": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : (x : M) \u2192 Decidable (x = 0)\np : R\nhM : IsTorsion' M \u21a5(Submonoid.powers p)\nd : \u2115\nhd : d \u2260 0\ns : Fin d \u2192 M\nhs : span R (Set.range s) = \u22a4\noj : Option (Fin d) := List.argmax (fun i => pOrder hM (s i)) (List.finRange d)\nhoj : Option.isSome oj = true\ni : Fin d\nthis : pOrder hM (s i) \u2264 pOrder hM (s (Option.get oj hoj))\n\u22a2 p ^ pOrder hM (s (Option.get oj hoj)) \u2022 s i = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/List.lean", "full_name": "List.formPerm_apply_mem_of_mem", "start": [87, 1], "end": [99, 51], "traced_tactics": [{"tactic": "cases' l with y l", "annotated_tactic": ["cases' l with y l", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d x : \u03b1\nl : List \u03b1\nh : x \u2208 l\n\u22a2 (formPerm l) x \u2208 l", "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x : \u03b1\nh : x \u2208 []\n\u22a2 (formPerm []) x \u2208 []\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d x y : \u03b1\nl : List \u03b1\nh : x \u2208 y :: l\n\u22a2 (formPerm (y :: l)) x \u2208 y :: l"}, {"tactic": "induction' l with z l IH generalizing x y", "annotated_tactic": ["induction' l with z l IH generalizing x y", []], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d x y : \u03b1\nl : List \u03b1\nh : x \u2208 y :: l\n\u22a2 (formPerm (y :: l)) x \u2208 y :: l", "state_after": "case cons.nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x y : \u03b1\nh : x \u2208 [y]\n\u22a2 (formPerm [y]) x \u2208 [y]\n\ncase cons.cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\n\u22a2 (formPerm (y :: z :: l)) x \u2208 y :: z :: l"}, {"tactic": "simp at h", "annotated_tactic": ["simp at h", []], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x : \u03b1\nh : x \u2208 []\n\u22a2 (formPerm []) x \u2208 []", "state_after": "no goals"}, {"tactic": "simpa using h", "annotated_tactic": ["simpa using h", []], "state_before": "case cons.nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x y : \u03b1\nh : x \u2208 [y]\n\u22a2 (formPerm [y]) x \u2208 [y]", "state_after": "no goals"}, {"tactic": "by_cases hx : x \u2208 z :: l", "annotated_tactic": ["by_cases hx : x \u2208 z :: l", []], "state_before": "case cons.cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\n\u22a2 (formPerm (y :: z :: l)) x \u2208 y :: z :: l", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\n\u22a2 (formPerm (y :: z :: l)) x \u2208 y :: z :: l\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2209 z :: l\n\u22a2 (formPerm (y :: z :: l)) x \u2208 y :: z :: l"}, {"tactic": "rw [formPerm_cons_cons, mul_apply, swap_apply_def]", "annotated_tactic": ["rw [<a>formPerm_cons_cons</a>, <a>mul_apply</a>, <a>swap_apply_def</a>]", [{"full_name": "List.formPerm_cons_cons", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/List.lean", "def_pos": [62, 9], "def_end_pos": [62, 27]}, {"full_name": "Equiv.Perm.mul_apply", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [67, 9], "def_end_pos": [67, 18]}, {"full_name": "Equiv.swap_apply_def", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [1632, 9], "def_end_pos": [1632, 23]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\n\u22a2 (formPerm (y :: z :: l)) x \u2208 y :: z :: l", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\n\u22a2 (if (formPerm (z :: l)) x = y then z else if (formPerm (z :: l)) x = z then y else (formPerm (z :: l)) x) \u2208\n    y :: z :: l"}, {"tactic": "split_ifs", "annotated_tactic": ["split_ifs", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\n\u22a2 (if (formPerm (z :: l)) x = y then z else if (formPerm (z :: l)) x = z then y else (formPerm (z :: l)) x) \u2208\n    y :: z :: l", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\nh\u271d : (formPerm (z :: l)) x = y\n\u22a2 z \u2208 y :: z :: l\n\ncase pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\nh\u271d\u00b9 : \u00ac(formPerm (z :: l)) x = y\nh\u271d : (formPerm (z :: l)) x = z\n\u22a2 y \u2208 y :: z :: l\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\nh\u271d\u00b9 : \u00ac(formPerm (z :: l)) x = y\nh\u271d : \u00ac(formPerm (z :: l)) x = z\n\u22a2 (formPerm (z :: l)) x \u2208 y :: z :: l"}, {"tactic": "simp [IH _ _ hx]", "annotated_tactic": ["simp [IH _ _ hx]", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\nh\u271d : (formPerm (z :: l)) x = y\n\u22a2 z \u2208 y :: z :: l", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\nh\u271d\u00b9 : \u00ac(formPerm (z :: l)) x = y\nh\u271d : (formPerm (z :: l)) x = z\n\u22a2 y \u2208 y :: z :: l", "state_after": "no goals"}, {"tactic": "simp [*]", "annotated_tactic": ["simp [*]", []], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2208 z :: l\nh\u271d\u00b9 : \u00ac(formPerm (z :: l)) x = y\nh\u271d : \u00ac(formPerm (z :: l)) x = z\n\u22a2 (formPerm (z :: l)) x \u2208 y :: z :: l", "state_after": "no goals"}, {"tactic": "replace h : x = y := Or.resolve_right (mem_cons.1 h) hx", "annotated_tactic": ["replace h : x = y := <a>Or.resolve_right</a> (<a>mem_cons</a>.1 h) hx", [{"full_name": "Or.resolve_right", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [552, 9], "def_end_pos": [552, 25]}, {"full_name": "List.mem_cons", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [63, 17], "def_end_pos": [63, 25]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nh : x \u2208 y :: z :: l\nhx : x \u2209 z :: l\n\u22a2 (formPerm (y :: z :: l)) x \u2208 y :: z :: l", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nhx : x \u2209 z :: l\nh : x = y\n\u22a2 (formPerm (y :: z :: l)) x \u2208 y :: z :: l"}, {"tactic": "simp [formPerm_apply_of_not_mem _ _ hx, \u2190 h]", "annotated_tactic": ["simp [<a>formPerm_apply_of_not_mem</a> _ _ hx, \u2190 h]", [{"full_name": "List.formPerm_apply_of_not_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/List.lean", "def_pos": [73, 9], "def_end_pos": [73, 34]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nx\u271d z : \u03b1\nl : List \u03b1\nIH : \u2200 (x y : \u03b1), x \u2208 y :: l \u2192 (formPerm (y :: l)) x \u2208 y :: l\nx y : \u03b1\nhx : x \u2209 z :: l\nh : x = y\n\u22a2 (formPerm (y :: z :: l)) x \u2208 y :: z :: l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_curry\u2083", "start": [1289, 1], "end": [1295, 11], "traced_tactics": [{"tactic": "rw [finprod_curry f h]", "annotated_tactic": ["rw [<a>finprod_curry</a> f h]", [{"full_name": "finprod_curry", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [1280, 9], "def_end_pos": [1280, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na b : \u03b1\ns t : Set \u03b1\n\u03b3 : Type u_7\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\nh : Set.Finite (mulSupport f)\n\u22a2 \u220f\u1da0 (abc : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3), f abc = \u220f\u1da0 (a : \u03b1) (b : \u03b2) (c : \u03b3), f (a, b, c)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na b : \u03b1\ns t : Set \u03b1\n\u03b3 : Type u_7\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\nh : Set.Finite (mulSupport f)\n\u22a2 \u220f\u1da0 (a : \u03b1) (b : \u03b2 \u00d7 \u03b3), f (a, b) = \u220f\u1da0 (a : \u03b1) (b : \u03b2) (c : \u03b3), f (a, b, c)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na b : \u03b1\ns t : Set \u03b1\n\u03b3 : Type u_7\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\nh : Set.Finite (mulSupport f)\n\u22a2 \u220f\u1da0 (a : \u03b1) (b : \u03b2 \u00d7 \u03b3), f (a, b) = \u220f\u1da0 (a : \u03b1) (b : \u03b2) (c : \u03b3), f (a, b, c)", "state_after": "case e_f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na b : \u03b1\ns t : Set \u03b1\n\u03b3 : Type u_7\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\nh : Set.Finite (mulSupport f)\n\u22a2 (fun a => \u220f\u1da0 (b : \u03b2 \u00d7 \u03b3), f (a, b)) = fun a => \u220f\u1da0 (b : \u03b2) (c : \u03b3), f (a, b, c)"}, {"tactic": "ext a", "annotated_tactic": ["ext a", []], "state_before": "case e_f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na b : \u03b1\ns t : Set \u03b1\n\u03b3 : Type u_7\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\nh : Set.Finite (mulSupport f)\n\u22a2 (fun a => \u220f\u1da0 (b : \u03b2 \u00d7 \u03b3), f (a, b)) = fun a => \u220f\u1da0 (b : \u03b2) (c : \u03b3), f (a, b, c)", "state_after": "case e_f.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\n\u03b3 : Type u_7\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\nh : Set.Finite (mulSupport f)\na : \u03b1\n\u22a2 \u220f\u1da0 (b : \u03b2 \u00d7 \u03b3), f (a, b) = \u220f\u1da0 (b : \u03b2) (c : \u03b3), f (a, b, c)"}, {"tactic": "rw [finprod_curry]", "annotated_tactic": ["rw [<a>finprod_curry</a>]", [{"full_name": "finprod_curry", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [1280, 9], "def_end_pos": [1280, 22]}]], "state_before": "case e_f.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\n\u03b3 : Type u_7\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\nh : Set.Finite (mulSupport f)\na : \u03b1\n\u22a2 \u220f\u1da0 (b : \u03b2 \u00d7 \u03b3), f (a, b) = \u220f\u1da0 (b : \u03b2) (c : \u03b3), f (a, b, c)", "state_after": "case e_f.h.hf\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\n\u03b3 : Type u_7\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\nh : Set.Finite (mulSupport f)\na : \u03b1\n\u22a2 Set.Finite (mulSupport fun b => f (a, b))"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case e_f.h.hf\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\n\u03b3 : Type u_7\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\nh : Set.Finite (mulSupport f)\na : \u03b1\n\u22a2 Set.Finite (mulSupport fun b => f (a, b))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.natDegree_pos_of_monic_of_not_isUnit", "start": [409, 1], "end": [411, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.map_equiv_normalizer_eq", "start": [3309, 1], "end": [3317, 35], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\n\u22a2 map (MulEquiv.toMonoidHom f) (normalizer H) = normalizer (map (MulEquiv.toMonoidHom f) H)", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\n\u22a2 x \u2208 map (MulEquiv.toMonoidHom f) (normalizer H) \u2194 x \u2208 normalizer (map (MulEquiv.toMonoidHom f) H)"}, {"tactic": "simp only [mem_normalizer_iff, mem_map_equiv]", "annotated_tactic": ["simp only [<a>mem_normalizer_iff</a>, <a>mem_map_equiv</a>]", [{"full_name": "Subgroup.mem_normalizer_iff", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [2183, 9], "def_end_pos": [2183, 27]}, {"full_name": "Subgroup.mem_map_equiv", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1449, 9], "def_end_pos": [1449, 22]}]], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\n\u22a2 x \u2208 map (MulEquiv.toMonoidHom f) (normalizer H) \u2194 x \u2208 normalizer (map (MulEquiv.toMonoidHom f) H)", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\n\u22a2 (\u2200 (h : G), h \u2208 H \u2194 (MulEquiv.symm f) x * h * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n    \u2200 (h : N), (MulEquiv.symm f) h \u2208 H \u2194 (MulEquiv.symm f) (x * h * x\u207b\u00b9) \u2208 H"}, {"tactic": "rw [f.toEquiv.forall_congr]", "annotated_tactic": ["rw [f.toEquiv.forall_congr]", []], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\n\u22a2 (\u2200 (h : G), h \u2208 H \u2194 (MulEquiv.symm f) x * h * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n    \u2200 (h : N), (MulEquiv.symm f) h \u2208 H \u2194 (MulEquiv.symm f) (x * h * x\u207b\u00b9) \u2208 H", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\n\u22a2 \u2200 {x_1 : G},\n    (x_1 \u2208 H \u2194 (MulEquiv.symm f) x * x_1 * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n      ((MulEquiv.symm f) (f.toEquiv x_1) \u2208 H \u2194 (MulEquiv.symm f) (x * f.toEquiv x_1 * x\u207b\u00b9) \u2208 H)"}, {"tactic": "intro", "annotated_tactic": ["intro", []], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\n\u22a2 \u2200 {x_1 : G},\n    (x_1 \u2208 H \u2194 (MulEquiv.symm f) x * x_1 * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n      ((MulEquiv.symm f) (f.toEquiv x_1) \u2208 H \u2194 (MulEquiv.symm f) (x * f.toEquiv x_1 * x\u207b\u00b9) \u2208 H)", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\nx\u271d : G\n\u22a2 (x\u271d \u2208 H \u2194 (MulEquiv.symm f) x * x\u271d * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n    ((MulEquiv.symm f) (f.toEquiv x\u271d) \u2208 H \u2194 (MulEquiv.symm f) (x * f.toEquiv x\u271d * x\u207b\u00b9) \u2208 H)"}, {"tactic": "erw [f.toEquiv.symm_apply_apply]", "annotated_tactic": ["erw [f.toEquiv.symm_apply_apply]", []], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\nx\u271d : G\n\u22a2 (x\u271d \u2208 H \u2194 (MulEquiv.symm f) x * x\u271d * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n    ((MulEquiv.symm f) (f.toEquiv x\u271d) \u2208 H \u2194 (MulEquiv.symm f) (x * f.toEquiv x\u271d * x\u207b\u00b9) \u2208 H)", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\nx\u271d : G\n\u22a2 (x\u271d \u2208 H \u2194 (MulEquiv.symm f) x * x\u271d * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n    (x\u271d \u2208 H \u2194 (MulEquiv.symm f) (x * f.toEquiv x\u271d * x\u207b\u00b9) \u2208 H)"}, {"tactic": "simp only [map_mul, map_inv]", "annotated_tactic": ["simp only [<a>map_mul</a>, <a>map_inv</a>]", [{"full_name": "map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [308, 9], "def_end_pos": [308, 16]}, {"full_name": "map_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [436, 9], "def_end_pos": [436, 16]}]], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\nx\u271d : G\n\u22a2 (x\u271d \u2208 H \u2194 (MulEquiv.symm f) x * x\u271d * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n    (x\u271d \u2208 H \u2194 (MulEquiv.symm f) (x * f.toEquiv x\u271d * x\u207b\u00b9) \u2208 H)", "state_after": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\nx\u271d : G\n\u22a2 (x\u271d \u2208 H \u2194 (MulEquiv.symm f) x * x\u271d * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n    (x\u271d \u2208 H \u2194 (MulEquiv.symm f) x * (MulEquiv.symm f) (f.toEquiv x\u271d) * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H)"}, {"tactic": "erw [f.toEquiv.symm_apply_apply]", "annotated_tactic": ["erw [f.toEquiv.symm_apply_apply]", []], "state_before": "case h\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d : G \u2192* N\nH : Subgroup G\nf : G \u2243* N\nx : N\nx\u271d : G\n\u22a2 (x\u271d \u2208 H \u2194 (MulEquiv.symm f) x * x\u271d * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H) \u2194\n    (x\u271d \u2208 H \u2194 (MulEquiv.symm f) x * (MulEquiv.symm f) (f.toEquiv x\u271d) * ((MulEquiv.symm f) x)\u207b\u00b9 \u2208 H)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "MonoidHom.comap_ker", "start": [2845, 1], "end": [2846, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean", "full_name": "MeasureTheory.sum_restrict_disjointed_spanningSets", "start": [662, 1], "end": [666, 59], "traced_tactics": [{"tactic": "rw [\u2190 restrict_iUnion (disjoint_disjointed _)\n    (MeasurableSet.disjointed (measurable_spanningSets _)),\n  iUnion_disjointed, iUnion_spanningSets, restrict_univ]", "annotated_tactic": ["rw [\u2190 <a>restrict_iUnion</a> (<a>disjoint_disjointed</a> _)\n      (<a>MeasurableSet.disjointed</a> (<a>measurable_spanningSets</a> _)),\n    <a>iUnion_disjointed</a>, <a>iUnion_spanningSets</a>, <a>restrict_univ</a>]", [{"full_name": "MeasureTheory.Measure.restrict_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [534, 9], "def_end_pos": [534, 24]}, {"full_name": "disjoint_disjointed", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjointed.lean", "def_pos": [74, 9], "def_end_pos": [74, 28]}, {"full_name": "MeasurableSet.disjointed", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [245, 19], "def_end_pos": [245, 43]}, {"full_name": "MeasureTheory.measurable_spanningSets", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Typeclasses.lean", "def_pos": [600, 9], "def_end_pos": [600, 32]}, {"full_name": "iUnion_disjointed", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjointed.lean", "def_pos": [169, 9], "def_end_pos": [169, 26]}, {"full_name": "MeasureTheory.iUnion_spanningSets", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Typeclasses.lean", "def_pos": [610, 9], "def_end_pos": [610, 28]}, {"full_name": "MeasureTheory.Measure.restrict_univ", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [241, 9], "def_end_pos": [241, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b4 : Type u_3\n\u03b9 : Type u_4\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\n\u03bc\u271d \u03bd \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns t : Set \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SigmaFinite \u03bc\n\u22a2 (sum fun n => Measure.restrict \u03bc (disjointed (spanningSets \u03bc) n)) = \u03bc", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Adjoin.lean", "full_name": "IntermediateField.sup_toSubalgebra_of_right", "start": [706, 1], "end": [708, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.spanExt_hom_app_zero", "start": [484, 1], "end": [485, 18], "traced_tactics": [{"tactic": "dsimp [spanExt]", "annotated_tactic": ["dsimp [<a>spanExt</a>]", [{"full_name": "CategoryTheory.Limits.spanExt", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "def_pos": [450, 5], "def_end_pos": [450, 12]}]], "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nX Y Z X' Y' Z' : C\niX : X \u2245 X'\niY : Y \u2245 Y'\niZ : Z \u2245 Z'\nf : X \u27f6 Y\ng : X \u27f6 Z\nf' : X' \u27f6 Y'\ng' : X' \u27f6 Z'\nwf : iX.hom \u226b f' = f \u226b iY.hom\nwg : iX.hom \u226b g' = g \u226b iZ.hom\n\u22a2 (spanExt iX iY iZ wf wg).hom.app WalkingSpan.zero = iX.hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Inseparable.lean", "full_name": "specializes_prod", "start": [189, 1], "end": [190, 54], "traced_tactics": [{"tactic": "simp only [Specializes, nhds_prod_eq, prod_le_prod]", "annotated_tactic": ["simp only [<a>Specializes</a>, <a>nhds_prod_eq</a>, <a>prod_le_prod</a>]", [{"full_name": "Specializes", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [187, 5], "def_end_pos": [187, 16]}, {"full_name": "nhds_prod_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [534, 9], "def_end_pos": [534, 21]}, {"full_name": "Filter.prod_le_prod", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [280, 9], "def_end_pos": [280, 21]}]], "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\n\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nx y z : X\ns : Set X\nf g : X \u2192 Y\nx\u2081 x\u2082 : X\ny\u2081 y\u2082 : Y\n\u22a2 (x\u2081, y\u2081) \u2933 (x\u2082, y\u2082) \u2194 x\u2081 \u2933 x\u2082 \u2227 y\u2081 \u2933 y\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/Compact.lean", "full_name": "isCompact_iff_finite_subfamily_closed", "start": [387, 1], "end": [390, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/HasLimits.lean", "full_name": "CategoryTheory.Limits.limit.hom_ext", "start": [266, 1], "end": [268, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Operations.lean", "full_name": "ENNReal.le_of_add_le_add_left", "start": [133, 11], "end": [134, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.mapRange.linearMap_toAddMonoidHom", "start": [962, 1], "end": [965, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Icc_inter_Icc", "start": [1781, 1], "end": [1782, 81], "traced_tactics": [{"tactic": "simp only [Ici_inter_Iic.symm, Ici_inter_Ici.symm, Iic_inter_Iic.symm]", "annotated_tactic": ["simp only [Ici_inter_Iic.symm, Ici_inter_Ici.symm, Iic_inter_Iic.symm]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Lattice \u03b1\na b c a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\n\u22a2 Icc a\u2081 b\u2081 \u2229 Icc a\u2082 b\u2082 = Icc (a\u2081 \u2294 a\u2082) (b\u2081 \u2293 b\u2082)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Lattice \u03b1\na b c a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\n\u22a2 Ici a\u2081 \u2229 Iic b\u2081 \u2229 (Ici a\u2082 \u2229 Iic b\u2082) = Ici a\u2081 \u2229 Ici a\u2082 \u2229 (Iic b\u2081 \u2229 Iic b\u2082)"}, {"tactic": "ac_rfl", "annotated_tactic": ["ac_rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Lattice \u03b1\na b c a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1\n\u22a2 Ici a\u2081 \u2229 Iic b\u2081 \u2229 (Ici a\u2082 \u2229 Iic b\u2082) = Ici a\u2081 \u2229 Ici a\u2082 \u2229 (Iic b\u2081 \u2229 Iic b\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/ViaEmbedding.lean", "full_name": "Equiv.Perm.viaEmbeddingHom_apply", "start": [44, 1], "end": [45, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Function.lean", "full_name": "StrictConcaveOn.comp", "start": [162, 1], "end": [168, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "ContDiff.comp_contDiff_on\u2083", "start": [883, 1], "end": [886, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "Char.length_toString", "start": [13, 9], "end": [13, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Extension.lean", "full_name": "IntermediateField.Lifts.exists_lift_of_splits", "start": [92, 1], "end": [95, 40], "traced_tactics": [{"tactic": "rwa [\u2190 x.emb.comp_algebraMap] at h2", "annotated_tactic": ["rwa [\u2190 x.emb.comp_algebraMap] at h2", []], "state_before": "F : Type u_1\nE : Type u_2\nK : Type u_3\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : Algebra F K\nS : Set E\nx : Lifts F E K\ns : E\nh1 : IsIntegral F s\nh2 : Splits (algebraMap F K) (minpoly F s)\n\u22a2 Splits (RingHom.comp x.emb.toRingHom (algebraMap F \u21a5x.carrier)) (minpoly F s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.one_def", "start": [700, 1], "end": [700, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iInf_ite", "start": [1338, 1], "end": [1340, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Bounded.lean", "full_name": "Metric.diam_le_of_subset_closedBall", "start": [515, 1], "end": [521, 47], "traced_tactics": [{"tactic": "simp [mul_two, mul_comm]", "annotated_tactic": ["simp [<a>mul_two</a>, <a>mul_comm</a>]", [{"full_name": "mul_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [190, 9], "def_end_pos": [190, 16]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx y z : \u03b1\nr : \u211d\nhr : 0 \u2264 r\nh : s \u2286 closedBall x r\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\n\u22a2 r + r = 2 * r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Accumulate.lean", "full_name": "Set.monotone_accumulate", "start": [41, 1], "end": [42, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.preimage_sub_const_Ioc", "start": [290, 1], "end": [291, 24], "traced_tactics": [{"tactic": "simp [sub_eq_add_neg]", "annotated_tactic": ["simp [<a>sub_eq_add_neg</a>]", [{"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedAddCommGroup \u03b1\na b c : \u03b1\n\u22a2 (fun x => x - a) \u207b\u00b9' Ioc b c = Ioc (b + a) (c + a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Restrict.lean", "full_name": "AffineMap.restrict.surjective", "start": [81, 1], "end": [87, 23], "traced_tactics": [{"tactic": "rintro \u27e8x, hx : x \u2208 F\u27e9", "annotated_tactic": ["rintro \u27e8x, hx : x \u2208 F\u27e9", []], "state_before": "k : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\ninst\u271d\u2078 : Ring k\ninst\u271d\u2077 : AddCommGroup V\u2081\ninst\u271d\u2076 : AddCommGroup V\u2082\ninst\u271d\u2075 : Module k V\u2081\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddTorsor V\u2082 P\u2082\n\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082\nE : AffineSubspace k P\u2081\nF : AffineSubspace k P\u2082\ninst\u271d\u00b9 : Nonempty \u21a5E\ninst\u271d : Nonempty \u21a5F\nh : AffineSubspace.map \u03c6 E = F\n\u22a2 Function.Surjective \u21d1(restrict \u03c6 \u22ef)", "state_after": "case mk\nk : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\ninst\u271d\u2078 : Ring k\ninst\u271d\u2077 : AddCommGroup V\u2081\ninst\u271d\u2076 : AddCommGroup V\u2082\ninst\u271d\u2075 : Module k V\u2081\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddTorsor V\u2082 P\u2082\n\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082\nE : AffineSubspace k P\u2081\nF : AffineSubspace k P\u2082\ninst\u271d\u00b9 : Nonempty \u21a5E\ninst\u271d : Nonempty \u21a5F\nh : AffineSubspace.map \u03c6 E = F\nx : P\u2082\nhx : x \u2208 F\n\u22a2 \u2203 a, (restrict \u03c6 \u22ef) a = { val := x, property := hx }"}, {"tactic": "rw [\u2190 h, AffineSubspace.mem_map] at hx", "annotated_tactic": ["rw [\u2190 h, <a>AffineSubspace.mem_map</a>] at hx", [{"full_name": "AffineSubspace.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [1551, 9], "def_end_pos": [1551, 16]}]], "state_before": "case mk\nk : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\ninst\u271d\u2078 : Ring k\ninst\u271d\u2077 : AddCommGroup V\u2081\ninst\u271d\u2076 : AddCommGroup V\u2082\ninst\u271d\u2075 : Module k V\u2081\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddTorsor V\u2082 P\u2082\n\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082\nE : AffineSubspace k P\u2081\nF : AffineSubspace k P\u2082\ninst\u271d\u00b9 : Nonempty \u21a5E\ninst\u271d : Nonempty \u21a5F\nh : AffineSubspace.map \u03c6 E = F\nx : P\u2082\nhx : x \u2208 F\n\u22a2 \u2203 a, (restrict \u03c6 \u22ef) a = { val := x, property := hx }", "state_after": "case mk\nk : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\ninst\u271d\u2078 : Ring k\ninst\u271d\u2077 : AddCommGroup V\u2081\ninst\u271d\u2076 : AddCommGroup V\u2082\ninst\u271d\u2075 : Module k V\u2081\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddTorsor V\u2082 P\u2082\n\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082\nE : AffineSubspace k P\u2081\nF : AffineSubspace k P\u2082\ninst\u271d\u00b9 : Nonempty \u21a5E\ninst\u271d : Nonempty \u21a5F\nh : AffineSubspace.map \u03c6 E = F\nx : P\u2082\nhx\u271d : x \u2208 F\nhx : \u2203 y \u2208 E, \u03c6 y = x\n\u22a2 \u2203 a, (restrict \u03c6 \u22ef) a = { val := x, property := hx\u271d }"}, {"tactic": "obtain \u27e8y, hy, rfl\u27e9 := hx", "annotated_tactic": ["obtain \u27e8y, hy, rfl\u27e9 := hx", []], "state_before": "case mk\nk : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\ninst\u271d\u2078 : Ring k\ninst\u271d\u2077 : AddCommGroup V\u2081\ninst\u271d\u2076 : AddCommGroup V\u2082\ninst\u271d\u2075 : Module k V\u2081\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddTorsor V\u2082 P\u2082\n\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082\nE : AffineSubspace k P\u2081\nF : AffineSubspace k P\u2082\ninst\u271d\u00b9 : Nonempty \u21a5E\ninst\u271d : Nonempty \u21a5F\nh : AffineSubspace.map \u03c6 E = F\nx : P\u2082\nhx\u271d : x \u2208 F\nhx : \u2203 y \u2208 E, \u03c6 y = x\n\u22a2 \u2203 a, (restrict \u03c6 \u22ef) a = { val := x, property := hx\u271d }", "state_after": "case mk.intro.intro\nk : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\ninst\u271d\u2078 : Ring k\ninst\u271d\u2077 : AddCommGroup V\u2081\ninst\u271d\u2076 : AddCommGroup V\u2082\ninst\u271d\u2075 : Module k V\u2081\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddTorsor V\u2082 P\u2082\n\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082\nE : AffineSubspace k P\u2081\nF : AffineSubspace k P\u2082\ninst\u271d\u00b9 : Nonempty \u21a5E\ninst\u271d : Nonempty \u21a5F\nh : AffineSubspace.map \u03c6 E = F\ny : P\u2081\nhy : y \u2208 E\nhx : \u03c6 y \u2208 F\n\u22a2 \u2203 a, (restrict \u03c6 \u22ef) a = { val := \u03c6 y, property := hx }"}, {"tactic": "exact \u27e8\u27e8y, hy\u27e9, rfl\u27e9", "annotated_tactic": ["exact \u27e8\u27e8y, hy\u27e9, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case mk.intro.intro\nk : Type u_1\nV\u2081 : Type u_2\nP\u2081 : Type u_3\nV\u2082 : Type u_4\nP\u2082 : Type u_5\ninst\u271d\u2078 : Ring k\ninst\u271d\u2077 : AddCommGroup V\u2081\ninst\u271d\u2076 : AddCommGroup V\u2082\ninst\u271d\u2075 : Module k V\u2081\ninst\u271d\u2074 : Module k V\u2082\ninst\u271d\u00b3 : AddTorsor V\u2081 P\u2081\ninst\u271d\u00b2 : AddTorsor V\u2082 P\u2082\n\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082\nE : AffineSubspace k P\u2081\nF : AffineSubspace k P\u2082\ninst\u271d\u00b9 : Nonempty \u21a5E\ninst\u271d : Nonempty \u21a5F\nh : AffineSubspace.map \u03c6 E = F\ny : P\u2081\nhy : y \u2208 E\nhx : \u03c6 y \u2208 F\n\u22a2 \u2203 a, (restrict \u03c6 \u22ef) a = { val := \u03c6 y, property := hx }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "comap_norm_nhdsWithin_Ioi_zero'", "start": [2184, 1], "end": [2186, 70], "traced_tactics": [{"tactic": "simp [nhdsWithin, comap_norm_nhds_one, Set.preimage, Set.compl_def]", "annotated_tactic": ["simp [<a>nhdsWithin</a>, <a>comap_norm_nhds_one</a>, <a>Set.preimage</a>, <a>Set.compl_def</a>]", [{"full_name": "nhdsWithin", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [123, 5], "def_end_pos": [123, 15]}, {"full_name": "comap_norm_nhds_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [1169, 9], "def_end_pos": [1169, 28]}, {"full_name": "Set.preimage", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [113, 5], "def_end_pos": [113, 13]}, {"full_name": "Set.compl_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1627, 9], "def_end_pos": [1627, 18]}]], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : NormedGroup E\ninst\u271d : NormedGroup F\na b : E\n\u22a2 comap norm (\ud835\udcdd[>] 0) = \ud835\udcdd[\u2260] 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearMap.lean", "full_name": "LinearMap.flip_apply", "start": [126, 1], "end": [126, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Linear.lean", "full_name": "ContinuousLinearMap.hasDerivWithinAt", "start": [56, 11], "end": [57, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Nondegenerate.lean", "full_name": "Matrix.Nondegenerate.eq_zero_of_ortho", "start": [33, 1], "end": [35, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "mul_lt_mul_left", "start": [253, 1], "end": [255, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Functor.lean", "full_name": "CategoryTheory.MonoidalFunctor.map_whiskerRight", "start": [265, 1], "end": [266, 75], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} C\ninst\u271d\u00b2 : MonoidalCategory C\nD : Type u\u2082\ninst\u271d\u00b9 : Category.{v\u2082, u\u2082} D\ninst\u271d : MonoidalCategory D\nF : MonoidalFunctor C D\nX Y : C\nf : X \u27f6 Y\nZ : C\n\u22a2 F.map (f \u25b7 Z) = inv (F.\u03bc X Z) \u226b F.map f \u25b7 F.obj Z \u226b F.\u03bc Y Z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousFunction/Basic.lean", "full_name": "ContinuousMap.continuous_set_coe", "start": [140, 1], "end": [141, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Parity.lean", "full_name": "Int.odd_sub'", "start": [196, 1], "end": [197, 75], "traced_tactics": [{"tactic": "rw [odd_iff_not_even, even_sub, not_iff, not_iff_comm, odd_iff_not_even]", "annotated_tactic": ["rw [<a>odd_iff_not_even</a>, <a>even_sub</a>, <a>not_iff</a>, <a>not_iff_comm</a>, <a>odd_iff_not_even</a>]", [{"full_name": "Int.odd_iff_not_even", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Parity.lean", "def_pos": [60, 9], "def_end_pos": [60, 25]}, {"full_name": "Int.even_sub", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Parity.lean", "def_pos": [126, 9], "def_end_pos": [126, 17]}, {"full_name": "not_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [455, 9], "def_end_pos": [455, 16]}, {"full_name": "not_iff_comm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [452, 9], "def_end_pos": [452, 21]}, {"full_name": "Int.odd_iff_not_even", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Parity.lean", "def_pos": [60, 9], "def_end_pos": [60, 25]}]], "state_before": "m n : \u2124\n\u22a2 Odd (m - n) \u2194 (Odd n \u2194 Even m)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Max.lean", "full_name": "noTopOrder_iff_noMaxOrder", "start": [162, 1], "end": [168, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "full_name": "Ordinal.typein_apply", "start": [463, 1], "end": [473, 61], "traced_tactics": [{"tactic": "rw [RelEmbedding.trans_apply]", "annotated_tactic": ["rw [<a>RelEmbedding.trans_apply</a>]", [{"full_name": "RelEmbedding.trans_apply", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelIso/Basic.lean", "def_pos": [307, 9], "def_end_pos": [307, 20]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3 : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b1 \u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u227ci s\na : \u03b1\nx\u271d : \u2191{b | r b a}\nx : \u03b1\nh : x \u2208 {b | r b a}\n\u22a2 (RelEmbedding.trans (Subrel.relEmbedding r {b | r b a}) f.toRelEmbedding) { val := x, property := h } \u2208\n    {b | s b (f a)}", "state_after": "\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3 : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b1 \u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u227ci s\na : \u03b1\nx\u271d : \u2191{b | r b a}\nx : \u03b1\nh : x \u2208 {b | r b a}\n\u22a2 f.toRelEmbedding ((Subrel.relEmbedding r {b | r b a}) { val := x, property := h }) \u2208 {b | s b (f a)}"}, {"tactic": "exact f.toRelEmbedding.map_rel_iff.2 h", "annotated_tactic": ["exact f.toRelEmbedding.map_rel_iff.2 h", []], "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3 : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b1 \u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u227ci s\na : \u03b1\nx\u271d : \u2191{b | r b a}\nx : \u03b1\nh : x \u2208 {b | r b a}\n\u22a2 f.toRelEmbedding ((Subrel.relEmbedding r {b | r b a}) { val := x, property := h }) \u2208 {b | s b (f a)}", "state_after": "no goals"}, {"tactic": "rcases f.init h with \u27e8a, rfl\u27e9", "annotated_tactic": ["rcases f.init h with \u27e8a, rfl\u27e9", []], "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3 : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b1 \u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u227ci s\na : \u03b1\nx\u271d : \u2191{b | s b (f a)}\ny : \u03b2\nh : y \u2208 {b | s b (f a)}\n\u22a2 \u2203 a_1,\n    (RelEmbedding.codRestrict {b | s b (f a)} (RelEmbedding.trans (Subrel.relEmbedding r {b | r b a}) f.toRelEmbedding)\n          \u22ef)\n        a_1 =\n      { val := y, property := h }", "state_after": "case intro\n\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3 : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b1 \u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u227ci s\na\u271d : \u03b1\nx\u271d : \u2191{b | s b (f a\u271d)}\na : \u03b1\nh : f a \u2208 {b | s b (f a\u271d)}\n\u22a2 \u2203 a_1,\n    (RelEmbedding.codRestrict {b | s b (f a\u271d)}\n          (RelEmbedding.trans (Subrel.relEmbedding r {b | r b a\u271d}) f.toRelEmbedding) \u22ef)\n        a_1 =\n      { val := f a, property := h }"}, {"tactic": "exact \u27e8\u27e8a, f.toRelEmbedding.map_rel_iff.1 h\u27e9,\n  Subtype.eq <| RelEmbedding.trans_apply _ _ _\u27e9", "annotated_tactic": ["exact \u27e8\u27e8a, f.toRelEmbedding.map_rel_iff.1 h\u27e9,\n              <a>Subtype.eq</a> <| <a>RelEmbedding.trans_apply</a> _ _ _\u27e9", [{"full_name": "Subtype.eq", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1105, 19], "def_end_pos": [1105, 21]}, {"full_name": "RelEmbedding.trans_apply", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelIso/Basic.lean", "def_pos": [307, 9], "def_end_pos": [307, 20]}]], "state_before": "case intro\n\u03b1\u271d : Type u\n\u03b2\u271d : Type u_1\n\u03b3 : Type u_2\nr\u271d : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Prop\ns\u271d : \u03b2\u271d \u2192 \u03b2\u271d \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b1 \u03b2 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b1 r\ninst\u271d : IsWellOrder \u03b2 s\nf : r \u227ci s\na\u271d : \u03b1\nx\u271d : \u2191{b | s b (f a\u271d)}\na : \u03b1\nh : f a \u2208 {b | s b (f a\u271d)}\n\u22a2 \u2203 a_1,\n    (RelEmbedding.codRestrict {b | s b (f a\u271d)}\n          (RelEmbedding.trans (Subrel.relEmbedding r {b | r b a\u271d}) f.toRelEmbedding) \u22ef)\n        a_1 =\n      { val := f a, property := h }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Commutator.lean", "full_name": "Subgroup.commutator_le_right", "start": [148, 1], "end": [149, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Int.lean", "full_name": "Int.cofinite_eq", "start": [84, 1], "end": [85, 57], "traced_tactics": [{"tactic": "rw [\u2190 cocompact_eq_cofinite, cocompact_eq_atBot_atTop]", "annotated_tactic": ["rw [\u2190 <a>cocompact_eq_cofinite</a>, <a>cocompact_eq_atBot_atTop</a>]", [{"full_name": "Filter.cocompact_eq_cofinite", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Compactness/Compact.lean", "def_pos": [584, 9], "def_end_pos": [584, 30]}, {"full_name": "cocompact_eq_atBot_atTop", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/Compact.lean", "def_pos": [247, 9], "def_end_pos": [247, 33]}]], "state_before": "\u22a2 cofinite = atBot \u2294 atTop", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/JordanHolder.lean", "full_name": "CompositionSeries.ext_fun", "start": [206, 1], "end": [212, 38], "traced_tactics": [{"tactic": "cases s\u2081", "annotated_tactic": ["cases s\u2081", []], "state_before": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2081 s\u2082 : CompositionSeries X\nhl : s\u2081.length = s\u2082.length\nh : \u2200 (i : Fin (s\u2081.length + 1)), s\u2081.series i = s\u2082.series (Fin.cast \u22ef i)\n\u22a2 s\u2081 = s\u2082", "state_after": "case mk\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2082 : CompositionSeries X\nlength\u271d : \u2115\nseries\u271d : Fin (length\u271d + 1) \u2192 X\nstep'\u271d : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d (Fin.castSucc i)) (series\u271d (Fin.succ i))\nhl : { length := length\u271d, series := series\u271d, step' := step'\u271d }.length = s\u2082.length\nh :\n  \u2200 (i : Fin ({ length := length\u271d, series := series\u271d, step' := step'\u271d }.length + 1)),\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }.series i = s\u2082.series (Fin.cast \u22ef i)\n\u22a2 { length := length\u271d, series := series\u271d, step' := step'\u271d } = s\u2082"}, {"tactic": "cases s\u2082", "annotated_tactic": ["cases s\u2082", []], "state_before": "case mk\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns\u2082 : CompositionSeries X\nlength\u271d : \u2115\nseries\u271d : Fin (length\u271d + 1) \u2192 X\nstep'\u271d : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d (Fin.castSucc i)) (series\u271d (Fin.succ i))\nhl : { length := length\u271d, series := series\u271d, step' := step'\u271d }.length = s\u2082.length\nh :\n  \u2200 (i : Fin ({ length := length\u271d, series := series\u271d, step' := step'\u271d }.length + 1)),\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }.series i = s\u2082.series (Fin.cast \u22ef i)\n\u22a2 { length := length\u271d, series := series\u271d, step' := step'\u271d } = s\u2082", "state_after": "case mk.mk\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nlength\u271d\u00b9 : \u2115\nseries\u271d\u00b9 : Fin (length\u271d\u00b9 + 1) \u2192 X\nstep'\u271d\u00b9 : \u2200 (i : Fin length\u271d\u00b9), IsMaximal (series\u271d\u00b9 (Fin.castSucc i)) (series\u271d\u00b9 (Fin.succ i))\nlength\u271d : \u2115\nseries\u271d : Fin (length\u271d + 1) \u2192 X\nstep'\u271d : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d (Fin.castSucc i)) (series\u271d (Fin.succ i))\nhl :\n  { length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 }.length =\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }.length\nh :\n  \u2200 (i : Fin ({ length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 }.length + 1)),\n    { length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 }.series i =\n      { length := length\u271d, series := series\u271d, step' := step'\u271d }.series (Fin.cast \u22ef i)\n\u22a2 { length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 } =\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }"}, {"tactic": "dsimp at hl h", "annotated_tactic": ["dsimp at hl h", []], "state_before": "case mk.mk\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nlength\u271d\u00b9 : \u2115\nseries\u271d\u00b9 : Fin (length\u271d\u00b9 + 1) \u2192 X\nstep'\u271d\u00b9 : \u2200 (i : Fin length\u271d\u00b9), IsMaximal (series\u271d\u00b9 (Fin.castSucc i)) (series\u271d\u00b9 (Fin.succ i))\nlength\u271d : \u2115\nseries\u271d : Fin (length\u271d + 1) \u2192 X\nstep'\u271d : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d (Fin.castSucc i)) (series\u271d (Fin.succ i))\nhl :\n  { length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 }.length =\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }.length\nh :\n  \u2200 (i : Fin ({ length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 }.length + 1)),\n    { length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 }.series i =\n      { length := length\u271d, series := series\u271d, step' := step'\u271d }.series (Fin.cast \u22ef i)\n\u22a2 { length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 } =\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }", "state_after": "case mk.mk\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nlength\u271d\u00b9 : \u2115\nseries\u271d\u00b9 : Fin (length\u271d\u00b9 + 1) \u2192 X\nstep'\u271d\u00b9 : \u2200 (i : Fin length\u271d\u00b9), IsMaximal (series\u271d\u00b9 (Fin.castSucc i)) (series\u271d\u00b9 (Fin.succ i))\nlength\u271d : \u2115\nseries\u271d : Fin (length\u271d + 1) \u2192 X\nstep'\u271d : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d (Fin.castSucc i)) (series\u271d (Fin.succ i))\nhl : length\u271d\u00b9 = length\u271d\nh : \u2200 (i : Fin (length\u271d\u00b9 + 1)), series\u271d\u00b9 i = series\u271d (Fin.cast \u22ef i)\n\u22a2 { length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 } =\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }"}, {"tactic": "subst hl", "annotated_tactic": ["subst hl", []], "state_before": "case mk.mk\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nlength\u271d\u00b9 : \u2115\nseries\u271d\u00b9 : Fin (length\u271d\u00b9 + 1) \u2192 X\nstep'\u271d\u00b9 : \u2200 (i : Fin length\u271d\u00b9), IsMaximal (series\u271d\u00b9 (Fin.castSucc i)) (series\u271d\u00b9 (Fin.succ i))\nlength\u271d : \u2115\nseries\u271d : Fin (length\u271d + 1) \u2192 X\nstep'\u271d : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d (Fin.castSucc i)) (series\u271d (Fin.succ i))\nhl : length\u271d\u00b9 = length\u271d\nh : \u2200 (i : Fin (length\u271d\u00b9 + 1)), series\u271d\u00b9 i = series\u271d (Fin.cast \u22ef i)\n\u22a2 { length := length\u271d\u00b9, series := series\u271d\u00b9, step' := step'\u271d\u00b9 } =\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }", "state_after": "case mk.mk\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nlength\u271d : \u2115\nseries\u271d\u00b9 : Fin (length\u271d + 1) \u2192 X\nstep'\u271d\u00b9 : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d\u00b9 (Fin.castSucc i)) (series\u271d\u00b9 (Fin.succ i))\nseries\u271d : Fin (length\u271d + 1) \u2192 X\nstep'\u271d : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d (Fin.castSucc i)) (series\u271d (Fin.succ i))\nh : \u2200 (i : Fin (length\u271d + 1)), series\u271d\u00b9 i = series\u271d (Fin.cast \u22ef i)\n\u22a2 { length := length\u271d, series := series\u271d\u00b9, step' := step'\u271d\u00b9 } =\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }"}, {"tactic": "simpa [Function.funext_iff] using h", "annotated_tactic": ["simpa [<a>Function.funext_iff</a>] using h", [{"full_name": "Function.funext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 19]}]], "state_before": "case mk.mk\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nlength\u271d : \u2115\nseries\u271d\u00b9 : Fin (length\u271d + 1) \u2192 X\nstep'\u271d\u00b9 : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d\u00b9 (Fin.castSucc i)) (series\u271d\u00b9 (Fin.succ i))\nseries\u271d : Fin (length\u271d + 1) \u2192 X\nstep'\u271d : \u2200 (i : Fin length\u271d), IsMaximal (series\u271d (Fin.castSucc i)) (series\u271d (Fin.succ i))\nh : \u2200 (i : Fin (length\u271d + 1)), series\u271d\u00b9 i = series\u271d (Fin.cast \u22ef i)\n\u22a2 { length := length\u271d, series := series\u271d\u00b9, step' := step'\u271d\u00b9 } =\n    { length := length\u271d, series := series\u271d, step' := step'\u271d }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units/Hom.lean", "full_name": "Units.mul_liftRight_inv", "start": [148, 1], "end": [150, 62], "traced_tactics": [{"tactic": "rw [Units.mul_inv_eq_iff_eq_mul, one_mul, coe_liftRight]", "annotated_tactic": ["rw [<a>Units.mul_inv_eq_iff_eq_mul</a>, <a>one_mul</a>, <a>coe_liftRight</a>]", [{"full_name": "Units.mul_inv_eq_iff_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [332, 9], "def_end_pos": [332, 30]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "Units.coe_liftRight", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units/Hom.lean", "def_pos": [142, 9], "def_end_pos": [142, 22]}]], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nP : Type w\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Monoid N\ninst\u271d : Monoid P\nf : M \u2192* N\ng : M \u2192 N\u02e3\nh : \u2200 (x : M), \u2191(g x) = f x\nx : M\n\u22a2 f x * \u2191((liftRight f g h) x)\u207b\u00b9 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Dilation.lean", "full_name": "Dilation.comp_continuousOn_iff", "start": [466, 1], "end": [468, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "full_name": "Real.logb_eq_zero", "start": [424, 1], "end": [426, 8], "traced_tactics": [{"tactic": "simp_rw [logb, div_eq_zero_iff, log_eq_zero]", "annotated_tactic": ["simp_rw [<a>logb</a>, <a>div_eq_zero_iff</a>, <a>log_eq_zero</a>]", [{"full_name": "Real.logb", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "def_pos": [40, 19], "def_end_pos": [40, 23]}, {"full_name": "div_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [286, 9], "def_end_pos": [286, 24]}, {"full_name": "Real.log_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "def_pos": [274, 9], "def_end_pos": [274, 20]}]], "state_before": "b x y : \u211d\n\u22a2 logb b x = 0 \u2194 b = 0 \u2228 b = 1 \u2228 b = -1 \u2228 x = 0 \u2228 x = 1 \u2228 x = -1", "state_after": "b x y : \u211d\n\u22a2 (x = 0 \u2228 x = 1 \u2228 x = -1) \u2228 b = 0 \u2228 b = 1 \u2228 b = -1 \u2194 b = 0 \u2228 b = 1 \u2228 b = -1 \u2228 x = 0 \u2228 x = 1 \u2228 x = -1"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "b x y : \u211d\n\u22a2 (x = 0 \u2228 x = 1 \u2228 x = -1) \u2228 b = 0 \u2228 b = 1 \u2228 b = -1 \u2194 b = 0 \u2228 b = 1 \u2228 b = -1 \u2228 x = 0 \u2228 x = 1 \u2228 x = -1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.countP_eq_card", "start": [2398, 1], "end": [2399, 63], "traced_tactics": [{"tactic": "simp [List.countP_eq_length]", "annotated_tactic": ["simp [<a>List.countP_eq_length</a>]", [{"full_name": "List.countP_eq_length", "def_path": ".lake/packages/std/Std/Data/List/Count.lean", "def_pos": [81, 9], "def_end_pos": [81, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\ns : Multiset \u03b1\n_l : List \u03b1\n\u22a2 countP p (Quot.mk Setoid.r _l) = card (Quot.mk Setoid.r _l) \u2194 \u2200 a \u2208 Quot.mk Setoid.r _l, p a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "full_name": "AffineBasis.coord_apply_combination_of_mem", "start": [187, 1], "end": [191, 38], "traced_tactics": [{"tactic": "classical simp only [coord_apply, hi, Finset.affineCombination_eq_linear_combination, if_true,\n    mul_boole, hw, Function.comp_apply, smul_eq_mul, s.sum_ite_eq,\n    s.map_affineCombination b w hw]", "annotated_tactic": ["classical simp only [<a>coord_apply</a>, hi, <a>Finset.affineCombination_eq_linear_combination</a>, <a>if_true</a>,\n      <a>mul_boole</a>, hw, <a>Function.comp_apply</a>, <a>smul_eq_mul</a>, s.sum_ite_eq,\n      s.map_affineCombination b w hw]", [{"full_name": "AffineBasis.coord_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Finset.affineCombination_eq_linear_combination", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [465, 9], "def_end_pos": [465, 48]}, {"full_name": "if_true", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [24, 17], "def_end_pos": [24, 24]}, {"full_name": "mul_boole", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [244, 9], "def_end_pos": [244, 18]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "smul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AffineSpace V P\ninst\u271d\u00b9 : Ring k\ninst\u271d : Module k V\nb : AffineBasis \u03b9 k P\ns : Finset \u03b9\ni j : \u03b9\ne : \u03b9 \u2243 \u03b9'\nhi : i \u2208 s\nw : \u03b9 \u2192 k\nhw : Finset.sum s w = 1\n\u22a2 (coord b i) ((Finset.affineCombination k s \u21d1b) w) = w i", "state_after": "no goals"}, {"tactic": "simp only [coord_apply, hi, Finset.affineCombination_eq_linear_combination, if_true,\nmul_boole, hw, Function.comp_apply, smul_eq_mul, s.sum_ite_eq,\ns.map_affineCombination b w hw]", "annotated_tactic": ["simp only [<a>coord_apply</a>, hi, <a>Finset.affineCombination_eq_linear_combination</a>, <a>if_true</a>,\n      <a>mul_boole</a>, hw, <a>Function.comp_apply</a>, <a>smul_eq_mul</a>, s.sum_ite_eq,\n      s.map_affineCombination b w hw]", [{"full_name": "AffineBasis.coord_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Finset.affineCombination_eq_linear_combination", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [465, 9], "def_end_pos": [465, 48]}, {"full_name": "if_true", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [24, 17], "def_end_pos": [24, 24]}, {"full_name": "mul_boole", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [244, 9], "def_end_pos": [244, 18]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "smul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nk : Type u_3\nV : Type u_4\nP : Type u_5\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AffineSpace V P\ninst\u271d\u00b9 : Ring k\ninst\u271d : Module k V\nb : AffineBasis \u03b9 k P\ns : Finset \u03b9\ni j : \u03b9\ne : \u03b9 \u2243 \u03b9'\nhi : i \u2208 s\nw : \u03b9 \u2192 k\nhw : Finset.sum s w = 1\n\u22a2 (coord b i) ((Finset.affineCombination k s \u21d1b) w) = w i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Quot.lean", "full_name": "Quotient.mk_out", "start": [387, 1], "end": [388, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.mul_union", "start": [495, 1], "end": [496, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "full_name": "smul_assoc", "start": [264, 1], "end": [266, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.eval_eq'", "start": [1158, 1], "end": [1160, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Finset.image_id'", "start": [457, 1], "end": [458, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/SetLike/Basic.lean", "full_name": "SetLike.coe_strictMono", "start": [227, 1], "end": [227, 96], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "full_name": "MulAction.exists_smul_eq", "start": [152, 1], "end": [153, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Group/Abs.lean", "full_name": "inf_sq_eq_mul_div_mabs_div", "start": [176, 1], "end": [179, 62], "traced_tactics": [{"tactic": "rw [\u2190 inf_mul_sup a b, \u2190 sup_div_inf_eq_mabs_div, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev,\n  inv_inv, mul_assoc, mul_inv_cancel_comm_assoc, \u2190 pow_two]", "annotated_tactic": ["rw [\u2190 <a>inf_mul_sup</a> a b, \u2190 <a>sup_div_inf_eq_mabs_div</a>, <a>div_eq_mul_inv</a>, <a>div_eq_mul_inv</a>, <a>mul_inv_rev</a>,\n    <a>inv_inv</a>, <a>mul_assoc</a>, <a>mul_inv_cancel_comm_assoc</a>, \u2190 <a>pow_two</a>]", [{"full_name": "inf_mul_sup", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Lattice.lean", "def_pos": [110, 7], "def_end_pos": [110, 18]}, {"full_name": "sup_div_inf_eq_mabs_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [162, 22], "def_end_pos": [162, 45]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "mul_inv_rev", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1070, 9], "def_end_pos": [1070, 20]}, {"full_name": "inv_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 16]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_inv_cancel_comm_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [288, 9], "def_end_pos": [288, 34]}, {"full_name": "pow_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [86, 32], "def_end_pos": [86, 39]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : CommGroup \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na\u271d b\u271d a b : \u03b1\n\u22a2 (a \u2293 b) ^ 2 = a * b / mabs (b / a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.antitoneOn_singleton", "start": [2702, 1], "end": [2703, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WellFounded.lean", "full_name": "Function.argminOn_le", "start": [231, 1], "end": [233, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Ideal.lean", "full_name": "IsLocalization.bot_lt_comap_prime", "start": [209, 1], "end": [214, 62], "traced_tactics": [{"tactic": "haveI : IsDomain S := isDomain_of_le_nonZeroDivisors _ hM", "annotated_tactic": ["haveI : <a>IsDomain</a> S := <a>isDomain_of_le_nonZeroDivisors</a> _ hM", [{"full_name": "IsDomain", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [480, 7], "def_end_pos": [480, 15]}, {"full_name": "IsLocalization.isDomain_of_le_nonZeroDivisors", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [1289, 9], "def_end_pos": [1289, 39]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : IsLocalization M S\ninst\u271d : IsDomain R\nhM : M \u2264 R\u2070\np : Ideal S\nhpp : Ideal.IsPrime p\nhp0 : p \u2260 \u22a5\n\u22a2 \u22a5 < Ideal.comap (algebraMap R S) p", "state_after": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : IsLocalization M S\ninst\u271d : IsDomain R\nhM : M \u2264 R\u2070\np : Ideal S\nhpp : Ideal.IsPrime p\nhp0 : p \u2260 \u22a5\nthis : IsDomain S\n\u22a2 \u22a5 < Ideal.comap (algebraMap R S) p"}, {"tactic": "rw [\u2190 Ideal.comap_bot_of_injective (algebraMap R S) (IsLocalization.injective _ hM)]", "annotated_tactic": ["rw [\u2190 <a>Ideal.comap_bot_of_injective</a> (<a>algebraMap</a> R S) (<a>IsLocalization.injective</a> _ hM)]", [{"full_name": "Ideal.comap_bot_of_injective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [1731, 9], "def_end_pos": [1731, 31]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "IsLocalization.injective", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [1235, 19], "def_end_pos": [1235, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : IsLocalization M S\ninst\u271d : IsDomain R\nhM : M \u2264 R\u2070\np : Ideal S\nhpp : Ideal.IsPrime p\nhp0 : p \u2260 \u22a5\nthis : IsDomain S\n\u22a2 \u22a5 < Ideal.comap (algebraMap R S) p", "state_after": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : IsLocalization M S\ninst\u271d : IsDomain R\nhM : M \u2264 R\u2070\np : Ideal S\nhpp : Ideal.IsPrime p\nhp0 : p \u2260 \u22a5\nthis : IsDomain S\n\u22a2 Ideal.comap (algebraMap R S) \u22a5 < Ideal.comap (algebraMap R S) p"}, {"tactic": "convert (orderIsoOfPrime M S).lt_iff_lt.mpr (show (\u27e8\u22a5, Ideal.bot_prime\u27e9 :\n  { p : Ideal S // p.IsPrime }) < \u27e8p, hpp\u27e9 from hp0.bot_lt)", "annotated_tactic": ["convert (<a>orderIsoOfPrime</a> M S).lt_iff_lt.mpr (show (\u27e8\u22a5, <a>Ideal.bot_prime</a>\u27e9 :\n    { p : <a>Ideal</a> S // p.IsPrime }) < \u27e8p, hpp\u27e9 from hp0.bot_lt)", [{"full_name": "IsLocalization.orderIsoOfPrime", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Ideal.lean", "def_pos": [147, 5], "def_end_pos": [147, 20]}, {"full_name": "Ideal.bot_prime", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [287, 9], "def_end_pos": [287, 18]}, {"full_name": "Ideal", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [40, 5], "def_end_pos": [40, 10]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : IsLocalization M S\ninst\u271d : IsDomain R\nhM : M \u2264 R\u2070\np : Ideal S\nhpp : Ideal.IsPrime p\nhp0 : p \u2260 \u22a5\nthis : IsDomain S\n\u22a2 Ideal.comap (algebraMap R S) \u22a5 < Ideal.comap (algebraMap R S) p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "LinearMap.fst_prod", "start": [104, 1], "end": [104, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Rat/Lemmas.lean", "full_name": "Rat.ofInt_den", "start": [179, 9], "end": [179, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "full_name": "exists_one_lt_mul_of_lt'", "start": [56, 1], "end": [58, 43], "traced_tactics": [{"tactic": "obtain \u27e8c, rfl\u27e9 := exists_mul_of_le h.le", "annotated_tactic": ["obtain \u27e8c, rfl\u27e9 := <a>exists_mul_of_le</a> h.le", [{"full_name": "ExistsMulOfLE.exists_mul_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [26, 3], "def_end_pos": [26, 19]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ContravariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\ninst\u271d : ExistsMulOfLE \u03b1\na b : \u03b1\nh : a < b\n\u22a2 \u2203 c, 1 < c \u2227 a * c = b", "state_after": "case intro\n\u03b1 : Type u\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ContravariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\ninst\u271d : ExistsMulOfLE \u03b1\na c : \u03b1\nh : a < a * c\n\u22a2 \u2203 c_1, 1 < c_1 \u2227 a * c_1 = a * c"}, {"tactic": "exact \u27e8c, one_lt_of_lt_mul_right h, rfl\u27e9", "annotated_tactic": ["exact \u27e8c, <a>one_lt_of_lt_mul_right</a> h, <a>rfl</a>\u27e9", [{"full_name": "one_lt_of_lt_mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [534, 9], "def_end_pos": [534, 31]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro\n\u03b1 : Type u\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ContravariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\ninst\u271d : ExistsMulOfLE \u03b1\na c : \u03b1\nh : a < a * c\n\u22a2 \u2203 c_1, 1 < c_1 \u2227 a * c_1 = a * c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "full_name": "ContinuousMultilinearMap.bounds_nonempty", "start": [333, 1], "end": [336, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_preimage_of_injective_of_subset_range", "start": [2167, 1], "end": [2169, 97], "traced_tactics": [{"tactic": "convert mk_preimage_of_injective_of_subset_range_lift.{u, u} f s h h2 using 1 <;> rw [lift_id]", "annotated_tactic": ["convert <a>mk_preimage_of_injective_of_subset_range_lift</a>.{u, u} f s h h2 using 1 <;> rw [<a>lift_id</a>]", [{"full_name": "Cardinal.mk_preimage_of_injective_of_subset_range_lift", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2162, 9], "def_end_pos": [2162, 54]}, {"full_name": "Cardinal.lift_id", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [224, 9], "def_end_pos": [224, 16]}]], "state_before": "\u03b1 \u03b2 : Type u\nc : Cardinal.{?u.247357}\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Injective f\nh2 : s \u2286 range f\n\u22a2 #\u2191(f \u207b\u00b9' s) = #\u2191s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "exists_pos_lt_mul", "start": [597, 1], "end": [599, 66], "traced_tactics": [{"tactic": "rwa [\u2190 div_eq_inv_mul, lt_div_iff hc\u2080]", "annotated_tactic": ["rwa [\u2190 <a>div_eq_inv_mul</a>, <a>lt_div_iff</a> hc\u2080]", [{"full_name": "div_eq_inv_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [567, 9], "def_end_pos": [567, 23]}, {"full_name": "lt_div_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [163, 9], "def_end_pos": [163, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na\u271d b\u271d c\u271d d e : \u03b1\nm n : \u2124\na : \u03b1\nh : 0 < a\nb c : \u03b1\nhc\u2080 : 0 < c\nhc : b * c < a\n\u22a2 b < c\u207b\u00b9 * a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AddTorsor.lean", "full_name": "nndist_lineMap_lineMap", "start": [80, 1], "end": [82, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.fract_one", "start": [980, 1], "end": [980, 57], "traced_tactics": [{"tactic": "simp [fract]", "annotated_tactic": ["simp [<a>fract</a>]", [{"full_name": "Int.fract", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [641, 5], "def_end_pos": [641, 10]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\n\u22a2 fract 1 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "full_name": "PartialEquiv.IsImage.symm_apply_mem_iff", "start": [372, 1], "end": [373, 66], "traced_tactics": [{"tactic": "rw [e.left_inv hx, h hx]", "annotated_tactic": ["rw [e.left_inv hx, h hx]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ne : PartialEquiv \u03b1 \u03b2\ne' : PartialEquiv \u03b2 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nx\u271d : \u03b1\ny : \u03b2\nh : IsImage e s t\nx : \u03b1\nhx : x \u2208 e.source\n\u22a2 \u2191(PartialEquiv.symm e) (\u2191e x) \u2208 s \u2194 \u2191e x \u2208 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.tensorLeftTensor_hom_app", "start": [920, 1], "end": [922, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Group.lean", "full_name": "Set.Finite.summable_compl_iff", "start": [112, 1], "end": [114, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "full_name": "ContinuousLinearEquiv.uniqueDiffOn_image_iff", "start": [528, 1], "end": [530, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Basic.lean", "full_name": "Complex.ofReal_re", "start": [95, 1], "end": [96, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "Units.commute_inv_coe", "start": [263, 1], "end": [263, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Dimension/Constructions.lean", "full_name": "FiniteDimensional.finrank_directSum", "start": [231, 1], "end": [236, 34], "traced_tactics": [{"tactic": "letI := nontrivial_of_invariantBasisNumber R", "annotated_tactic": ["letI := <a>nontrivial_of_invariantBasisNumber</a> R", [{"full_name": "nontrivial_of_invariantBasisNumber", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/InvariantBasisNumber.lean", "def_pos": [197, 9], "def_end_pos": [197, 43]}]], "state_before": "R S : Type u\nM\u271d : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9\u271d : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u2077 : Ring R\ninst\u271d\u00b9\u2076 : CommRing S\ninst\u271d\u00b9\u2075 : AddCommGroup M\u271d\ninst\u271d\u00b9\u2074 : AddCommGroup M'\ninst\u271d\u00b9\u00b3 : AddCommGroup M\u2081\ninst\u271d\u00b9\u00b2 : Module R M\u271d\ninst\u271d\u00b9\u00b9 : Module R M'\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Free R M\u271d\ninst\u271d\u2077 : Module.Free R M'\ninst\u271d\u2076 : Module.Finite R M\u271d\ninst\u271d\u2075 : Module.Finite R M'\n\u03b9 : Type v\ninst\u271d\u2074 : Fintype \u03b9\nM : \u03b9 \u2192 Type w\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommGroup (M i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Module.Free R (M i)\ninst\u271d : \u2200 (i : \u03b9), Module.Finite R (M i)\n\u22a2 finrank R (\u2a01 (i : \u03b9), M i) = \u2211 i : \u03b9, finrank R (M i)", "state_after": "R S : Type u\nM\u271d : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9\u271d : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u2077 : Ring R\ninst\u271d\u00b9\u2076 : CommRing S\ninst\u271d\u00b9\u2075 : AddCommGroup M\u271d\ninst\u271d\u00b9\u2074 : AddCommGroup M'\ninst\u271d\u00b9\u00b3 : AddCommGroup M\u2081\ninst\u271d\u00b9\u00b2 : Module R M\u271d\ninst\u271d\u00b9\u00b9 : Module R M'\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Free R M\u271d\ninst\u271d\u2077 : Module.Free R M'\ninst\u271d\u2076 : Module.Finite R M\u271d\ninst\u271d\u2075 : Module.Finite R M'\n\u03b9 : Type v\ninst\u271d\u2074 : Fintype \u03b9\nM : \u03b9 \u2192 Type w\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommGroup (M i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Module.Free R (M i)\ninst\u271d : \u2200 (i : \u03b9), Module.Finite R (M i)\nthis : Nontrivial R := nontrivial_of_invariantBasisNumber R\n\u22a2 finrank R (\u2a01 (i : \u03b9), M i) = \u2211 i : \u03b9, finrank R (M i)"}, {"tactic": "simp only [finrank, fun i => rank_eq_card_chooseBasisIndex R (M i), rank_directSum, \u2190 mk_sigma,\n  mk_toNat_eq_card, card_sigma]", "annotated_tactic": ["simp only [<a>finrank</a>, fun i => <a>rank_eq_card_chooseBasisIndex</a> R (M i), <a>rank_directSum</a>, \u2190 <a>mk_sigma</a>,\n    <a>mk_toNat_eq_card</a>, <a>card_sigma</a>]", [{"full_name": "FiniteDimensional.finrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Finrank.lean", "def_pos": [54, 19], "def_end_pos": [54, 26]}, {"full_name": "Module.Free.rank_eq_card_chooseBasisIndex", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Free.lean", "def_pos": [83, 9], "def_end_pos": [83, 38]}, {"full_name": "rank_directSum", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "def_pos": [178, 9], "def_end_pos": [178, 23]}, {"full_name": "Cardinal.mk_sigma", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [884, 9], "def_end_pos": [884, 17]}, {"full_name": "Cardinal.mk_toNat_eq_card", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/ToNat.lean", "def_pos": [135, 9], "def_end_pos": [135, 25]}, {"full_name": "Fintype.card_sigma", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/BigOperators.lean", "def_pos": [122, 16], "def_end_pos": [122, 34]}]], "state_before": "R S : Type u\nM\u271d : Type v\nM' : Type v'\nM\u2081 : Type v\n\u03b9\u271d : Type w\n\u03b9' : Type w'\n\u03b7 : Type u\u2081'\n\u03c6 : \u03b7 \u2192 Type u_1\ninst\u271d\u00b9\u2077 : Ring R\ninst\u271d\u00b9\u2076 : CommRing S\ninst\u271d\u00b9\u2075 : AddCommGroup M\u271d\ninst\u271d\u00b9\u2074 : AddCommGroup M'\ninst\u271d\u00b9\u00b3 : AddCommGroup M\u2081\ninst\u271d\u00b9\u00b2 : Module R M\u271d\ninst\u271d\u00b9\u00b9 : Module R M'\ninst\u271d\u00b9\u2070 : Module R M\u2081\ninst\u271d\u2079 : StrongRankCondition R\ninst\u271d\u2078 : Module.Free R M\u271d\ninst\u271d\u2077 : Module.Free R M'\ninst\u271d\u2076 : Module.Finite R M\u271d\ninst\u271d\u2075 : Module.Finite R M'\n\u03b9 : Type v\ninst\u271d\u2074 : Fintype \u03b9\nM : \u03b9 \u2192 Type w\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommGroup (M i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Module.Free R (M i)\ninst\u271d : \u2200 (i : \u03b9), Module.Finite R (M i)\nthis : Nontrivial R := nontrivial_of_invariantBasisNumber R\n\u22a2 finrank R (\u2a01 (i : \u03b9), M i) = \u2211 i : \u03b9, finrank R (M i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Prod.lean", "full_name": "Filter.sup_prod", "start": [117, 1], "end": [119, 75], "traced_tactics": [{"tactic": "dsimp only [SProd.sprod]", "annotated_tactic": ["dsimp only [<a>SProd.sprod</a>]", [{"full_name": "SProd.sprod", "def_path": ".lake/packages/mathlib/Mathlib/Data/SProd.lean", "def_pos": [29, 3], "def_end_pos": [29, 8]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng\u271d : Filter \u03b2\nf\u2081 f\u2082 : Filter \u03b1\ng : Filter \u03b2\n\u22a2 (f\u2081 \u2294 f\u2082) \u00d7\u02e2 g = f\u2081 \u00d7\u02e2 g \u2294 f\u2082 \u00d7\u02e2 g", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng\u271d : Filter \u03b2\nf\u2081 f\u2082 : Filter \u03b1\ng : Filter \u03b2\n\u22a2 Filter.prod (f\u2081 \u2294 f\u2082) g = Filter.prod f\u2081 g \u2294 Filter.prod f\u2082 g"}, {"tactic": "rw [Filter.prod, comap_sup, inf_sup_right, \u2190 Filter.prod, \u2190 Filter.prod]", "annotated_tactic": ["rw [<a>Filter.prod</a>, <a>comap_sup</a>, <a>inf_sup_right</a>, \u2190 <a>Filter.prod</a>, \u2190 <a>Filter.prod</a>]", [{"full_name": "Filter.prod", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [53, 15], "def_end_pos": [53, 19]}, {"full_name": "Filter.comap_sup", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2416, 9], "def_end_pos": [2416, 18]}, {"full_name": "inf_sup_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [743, 9], "def_end_pos": [743, 22]}, {"full_name": "Filter.prod", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [53, 15], "def_end_pos": [53, 19]}, {"full_name": "Filter.prod", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [53, 15], "def_end_pos": [53, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng\u271d : Filter \u03b2\nf\u2081 f\u2082 : Filter \u03b1\ng : Filter \u03b2\n\u22a2 Filter.prod (f\u2081 \u2294 f\u2082) g = Filter.prod f\u2081 g \u2294 Filter.prod f\u2082 g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/EqToHom.lean", "full_name": "CategoryTheory.Functor.conj_eqToHom_iff_heq", "start": [224, 1], "end": [228, 7], "traced_tactics": [{"tactic": "cases h", "annotated_tactic": ["cases h", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nW X Y Z : C\nf : W \u27f6 X\ng : Y \u27f6 Z\nh : W = Y\nh' : X = Z\n\u22a2 f = eqToHom h \u226b g \u226b eqToHom \u22ef \u2194 HEq f g", "state_after": "case refl\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nW X Z : C\nf : W \u27f6 X\nh' : X = Z\ng : W \u27f6 Z\n\u22a2 f = eqToHom \u22ef \u226b g \u226b eqToHom \u22ef \u2194 HEq f g"}, {"tactic": "cases h'", "annotated_tactic": ["cases h'", []], "state_before": "case refl\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nW X Z : C\nf : W \u27f6 X\nh' : X = Z\ng : W \u27f6 Z\n\u22a2 f = eqToHom \u22ef \u226b g \u226b eqToHom \u22ef \u2194 HEq f g", "state_after": "case refl.refl\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nW X : C\nf g : W \u27f6 X\n\u22a2 f = eqToHom \u22ef \u226b g \u226b eqToHom \u22ef \u2194 HEq f g"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case refl.refl\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nW X : C\nf g : W \u27f6 X\n\u22a2 f = eqToHom \u22ef \u226b g \u226b eqToHom \u22ef \u2194 HEq f g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.image_mul_left_Icc'", "start": [826, 1], "end": [828, 74], "traced_tactics": [{"tactic": "convert image_mul_right_Icc' b c h using 1 <;> simp only [mul_comm _ a]", "annotated_tactic": ["convert <a>image_mul_right_Icc'</a> b c h using 1 <;> simp only [<a>mul_comm</a> _ a]", [{"full_name": "Set.image_mul_right_Icc'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Interval.lean", "def_pos": [813, 9], "def_end_pos": [813, 29]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\na\u271d a : \u03b1\nh : 0 < a\nb c : \u03b1\n\u22a2 (fun x => a * x) '' Icc b c = Icc (a * b) (a * c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.exists_subset_or_subset_of_two_mul_lt_card", "start": [574, 1], "end": [582, 55], "traced_tactics": [{"tactic": "have h\u2081 : (X \u2229 (Y \\ X)).card = 0 := Finset.card_eq_zero.mpr (Finset.inter_sdiff_self X Y)", "annotated_tactic": ["have h\u2081 : (X \u2229 (Y \\ X)).<a>card</a> = 0 := Finset.card_eq_zero.mpr (<a>Finset.inter_sdiff_self</a> X Y)", [{"full_name": "Finset.card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [39, 15], "def_end_pos": [39, 19]}, {"full_name": "Finset.inter_sdiff_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2134, 9], "def_end_pos": [2134, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : 2 * n < (X \u222a Y).card\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : 2 * n < (X \u222a Y).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)"}, {"tactic": "have h\u2082 : (X \u222a Y).card = X.card + (Y \\ X).card := by\n  rw [\u2190 card_union_add_card_inter X (Y \\ X), Finset.union_sdiff_self_eq_union, h\u2081, add_zero]", "annotated_tactic": ["have h\u2082 : (X \u222a Y).<a>card</a> = X.card + (Y \\ X).<a>card</a> := by\n    rw [\u2190 <a>card_union_add_card_inter</a> X (Y \\ X), <a>Finset.union_sdiff_self_eq_union</a>, h\u2081, <a>add_zero</a>]", [{"full_name": "Finset.card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [39, 15], "def_end_pos": [39, 19]}, {"full_name": "Finset.card", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [39, 15], "def_end_pos": [39, 19]}, {"full_name": "Finset.card_union_add_card_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [452, 9], "def_end_pos": [452, 34]}, {"full_name": "Finset.union_sdiff_self_eq_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2207, 9], "def_end_pos": [2207, 34]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : 2 * n < (X \u222a Y).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : 2 * n < (X \u222a Y).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\nh\u2082 : (X \u222a Y).card = X.card + (Y \\ X).card\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)"}, {"tactic": "rw [h\u2082, two_mul] at hXY", "annotated_tactic": ["rw [h\u2082, <a>two_mul</a>] at hXY", [{"full_name": "two_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [179, 9], "def_end_pos": [179, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : 2 * n < (X \u222a Y).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\nh\u2082 : (X \u222a Y).card = X.card + (Y \\ X).card\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : n + n < X.card + (Y \\ X).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\nh\u2082 : (X \u222a Y).card = X.card + (Y \\ X).card\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)"}, {"tactic": "rcases lt_or_lt_of_add_lt_add hXY with (h | h)", "annotated_tactic": ["rcases <a>lt_or_lt_of_add_lt_add</a> hXY with (h | h)", [{"full_name": "lt_or_lt_of_add_lt_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/MinMax.lean", "def_pos": [90, 3], "def_end_pos": [90, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : n + n < X.card + (Y \\ X).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\nh\u2082 : (X \u222a Y).card = X.card + (Y \\ X).card\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : n + n < X.card + (Y \\ X).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\nh\u2082 : (X \u222a Y).card = X.card + (Y \\ X).card\nh : n < X.card\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : n + n < X.card + (Y \\ X).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\nh\u2082 : (X \u222a Y).card = X.card + (Y \\ X).card\nh : n < (Y \\ X).card\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)"}, {"tactic": "rw [\u2190 card_union_add_card_inter X (Y \\ X), Finset.union_sdiff_self_eq_union, h\u2081, add_zero]", "annotated_tactic": ["rw [\u2190 <a>card_union_add_card_inter</a> X (Y \\ X), <a>Finset.union_sdiff_self_eq_union</a>, h\u2081, <a>add_zero</a>]", [{"full_name": "Finset.card_union_add_card_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [452, 9], "def_end_pos": [452, 34]}, {"full_name": "Finset.union_sdiff_self_eq_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2207, 9], "def_end_pos": [2207, 34]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : 2 * n < (X \u222a Y).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\n\u22a2 (X \u222a Y).card = X.card + (Y \\ X).card", "state_after": "no goals"}, {"tactic": "exact \u27e8X, h, Or.inl (Finset.Subset.refl X)\u27e9", "annotated_tactic": ["exact \u27e8X, h, <a>Or.inl</a> (<a>Finset.Subset.refl</a> X)\u27e9", [{"full_name": "Or.inl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [530, 5], "def_end_pos": [530, 8]}, {"full_name": "Finset.Subset.refl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [344, 9], "def_end_pos": [344, 20]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : n + n < X.card + (Y \\ X).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\nh\u2082 : (X \u222a Y).card = X.card + (Y \\ X).card\nh : n < X.card\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)", "state_after": "no goals"}, {"tactic": "exact \u27e8Y \\ X, h, Or.inr (Finset.sdiff_subset Y X)\u27e9", "annotated_tactic": ["exact \u27e8Y \\ X, h, <a>Or.inr</a> (<a>Finset.sdiff_subset</a> Y X)\u27e9", [{"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}, {"full_name": "Finset.sdiff_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2297, 9], "def_end_pos": [2297, 21]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn\u271d : \u2115\ninst\u271d : DecidableEq \u03b1\nX Y : Finset \u03b1\nn : \u2115\nhXY : n + n < X.card + (Y \\ X).card\nh\u2081 : (X \u2229 (Y \\ X)).card = 0\nh\u2082 : (X \u222a Y).card = X.card + (Y \\ X).card\nh : n < (Y \\ X).card\n\u22a2 \u2203 C, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.support_monomial", "start": [539, 1], "end": [542, 6], "traced_tactics": [{"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nh : Decidable (a = 0)\n\u22a2 support ((monomial s) a) = if a = 0 then \u2205 else {s}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/PNat/Prime.lean", "full_name": "PNat.dvd_prime", "start": [143, 1], "end": [146, 7], "traced_tactics": [{"tactic": "rw [PNat.dvd_iff]", "annotated_tactic": ["rw [<a>PNat.dvd_iff</a>]", [{"full_name": "PNat.dvd_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/PNat/Basic.lean", "def_pos": [396, 9], "def_end_pos": [396, 16]}]], "state_before": "p m : \u2115+\npp : Prime p\n\u22a2 m \u2223 p \u2194 m = 1 \u2228 m = p", "state_after": "p m : \u2115+\npp : Prime p\n\u22a2 \u2191m \u2223 \u2191p \u2194 m = 1 \u2228 m = p"}, {"tactic": "rw [Nat.dvd_prime pp]", "annotated_tactic": ["rw [<a>Nat.dvd_prime</a> pp]", [{"full_name": "Nat.dvd_prime", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Prime.lean", "def_pos": [204, 9], "def_end_pos": [204, 18]}]], "state_before": "p m : \u2115+\npp : Prime p\n\u22a2 \u2191m \u2223 \u2191p \u2194 m = 1 \u2228 m = p", "state_after": "p m : \u2115+\npp : Prime p\n\u22a2 \u2191m = 1 \u2228 \u2191m = \u2191p \u2194 m = 1 \u2228 m = p"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "p m : \u2115+\npp : Prime p\n\u22a2 \u2191m = 1 \u2228 \u2191m = \u2191p \u2194 m = 1 \u2228 m = p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "isOpen_fold", "start": [101, 1], "end": [102, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.OrderIso.apply_bliminf", "start": [1063, 1], "end": [1065, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Pi/Basic.lean", "full_name": "Pi.mulSingle_op\u2082", "start": [437, 1], "end": [440, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Linear.lean", "full_name": "ContinuousLinearMap.hasStrictFDerivAt", "start": [54, 11], "end": [55, 78], "traced_tactics": [{"tactic": "simp only [e.map_sub, sub_self]", "annotated_tactic": ["simp only [e.map_sub, <a>sub_self</a>]", [{"full_name": "sub_self", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [813, 30], "def_end_pos": [813, 38]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf f\u2080 f\u2081 g : E \u2192 F\nf' f\u2080' f\u2081' g' e : E \u2192L[\ud835\udd5c] F\nx\u271d\u00b9 : E\ns t : Set E\nL L\u2081 L\u2082 : Filter E\nx\u271d : E\nx : E \u00d7 E\n\u22a2 0 = e x.1 - e x.2 - e (x.1 - x.2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Forall2.lean", "full_name": "List.rel_join", "start": [269, 1], "end": [271, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.Nonempty.exists_cons_eq", "start": [1318, 1], "end": [1319, 77], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t u v : Finset \u03b1\na\u271d b : \u03b1\nhs : s.Nonempty\na : \u03b1\n\u22a2 \u2203 (ha : a \u2209 \u2205), cons a \u2205 ha = {a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.sup_mul_right_self", "start": [533, 1], "end": [534, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "full_name": "PartialEquiv.IsImage.image_eq", "start": [410, 1], "end": [411, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.comap_comap", "start": [1503, 1], "end": [1505, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.prime_mul_iff", "start": [221, 1], "end": [222, 93], "traced_tactics": [{"tactic": "simp only [iff_self_iff, irreducible_mul_iff, \u2190 irreducible_iff_nat_prime, Nat.isUnit_iff]", "annotated_tactic": ["simp only [<a>iff_self_iff</a>, <a>irreducible_mul_iff</a>, \u2190 <a>irreducible_iff_nat_prime</a>, <a>Nat.isUnit_iff</a>]", [{"full_name": "iff_self_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [198, 9], "def_end_pos": [198, 21]}, {"full_name": "irreducible_mul_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [291, 9], "def_end_pos": [291, 28]}, {"full_name": "Nat.irreducible_iff_nat_prime", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Prime.lean", "def_pos": [51, 9], "def_end_pos": [51, 34]}, {"full_name": "Nat.isUnit_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Units.lean", "def_pos": [25, 19], "def_end_pos": [25, 29]}]], "state_before": "n a b : \u2115\n\u22a2 Prime (a * b) \u2194 Prime a \u2227 b = 1 \u2228 Prime b \u2227 a = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.groupSMul_span_eq_top", "start": [1187, 1], "end": [1197, 45], "traced_tactics": [{"tactic": "rw [eq_top_iff]", "annotated_tactic": ["rw [<a>eq_top_iff</a>]", [{"full_name": "eq_top_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [133, 9], "def_end_pos": [133, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\n\u22a2 span R (Set.range (w \u2022 v)) = \u22a4", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\n\u22a2 \u22a4 \u2264 span R (Set.range (w \u2022 v))"}, {"tactic": "intro j hj", "annotated_tactic": ["intro j hj", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\n\u22a2 \u22a4 \u2264 span R (Set.range (w \u2022 v))", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : j \u2208 \u22a4\n\u22a2 j \u2208 span R (Set.range (w \u2022 v))"}, {"tactic": "rw [\u2190 hv] at hj", "annotated_tactic": ["rw [\u2190 hv] at hj", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : j \u2208 \u22a4\n\u22a2 j \u2208 span R (Set.range (w \u2022 v))", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : j \u2208 span R (Set.range v)\n\u22a2 j \u2208 span R (Set.range (w \u2022 v))"}, {"tactic": "rw [Submodule.mem_span] at hj \u22a2", "annotated_tactic": ["rw [<a>Submodule.mem_span</a>] at hj \u22a2", [{"full_name": "Submodule.mem_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [71, 9], "def_end_pos": [71, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : j \u2208 span R (Set.range v)\n\u22a2 j \u2208 span R (Set.range (w \u2022 v))", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : \u2200 (p : Submodule R M), Set.range v \u2286 \u2191p \u2192 j \u2208 p\n\u22a2 \u2200 (p : Submodule R M), Set.range (w \u2022 v) \u2286 \u2191p \u2192 j \u2208 p"}, {"tactic": "refine' fun p hp => hj p fun u hu => _", "annotated_tactic": ["refine' fun p hp => hj p fun u hu => _", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : \u2200 (p : Submodule R M), Set.range v \u2286 \u2191p \u2192 j \u2208 p\n\u22a2 \u2200 (p : Submodule R M), Set.range (w \u2022 v) \u2286 \u2191p \u2192 j \u2208 p", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : \u2200 (p : Submodule R M), Set.range v \u2286 \u2191p \u2192 j \u2208 p\np : Submodule R M\nhp : Set.range (w \u2022 v) \u2286 \u2191p\nu : M\nhu : u \u2208 Set.range v\n\u22a2 u \u2208 \u2191p"}, {"tactic": "obtain \u27e8i, rfl\u27e9 := hu", "annotated_tactic": ["obtain \u27e8i, rfl\u27e9 := hu", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : \u2200 (p : Submodule R M), Set.range v \u2286 \u2191p \u2192 j \u2208 p\np : Submodule R M\nhp : Set.range (w \u2022 v) \u2286 \u2191p\nu : M\nhu : u \u2208 Set.range v\n\u22a2 u \u2208 \u2191p", "state_after": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : \u2200 (p : Submodule R M), Set.range v \u2286 \u2191p \u2192 j \u2208 p\np : Submodule R M\nhp : Set.range (w \u2022 v) \u2286 \u2191p\ni : \u03b9\n\u22a2 v i \u2208 \u2191p"}, {"tactic": "have : ((w i)\u207b\u00b9 \u2022 (1 : R)) \u2022 w i \u2022 v i \u2208 p := p.smul_mem ((w i)\u207b\u00b9 \u2022 (1 : R)) (hp \u27e8i, rfl\u27e9)", "annotated_tactic": ["have : ((w i)\u207b\u00b9 \u2022 (1 : R)) \u2022 w i \u2022 v i \u2208 p := p.smul_mem ((w i)\u207b\u00b9 \u2022 (1 : R)) (hp \u27e8i, <a>rfl</a>\u27e9)", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : \u2200 (p : Submodule R M), Set.range v \u2286 \u2191p \u2192 j \u2208 p\np : Submodule R M\nhp : Set.range (w \u2022 v) \u2286 \u2191p\ni : \u03b9\n\u22a2 v i \u2208 \u2191p", "state_after": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : \u2200 (p : Submodule R M), Set.range v \u2286 \u2191p \u2192 j \u2208 p\np : Submodule R M\nhp : Set.range (w \u2022 v) \u2286 \u2191p\ni : \u03b9\nthis : ((w i)\u207b\u00b9 \u2022 1) \u2022 w i \u2022 v i \u2208 p\n\u22a2 v i \u2208 \u2191p"}, {"tactic": "rwa [smul_one_smul, inv_smul_smul] at this", "annotated_tactic": ["rwa [<a>smul_one_smul</a>, <a>inv_smul_smul</a>] at this", [{"full_name": "smul_one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [683, 9], "def_end_pos": [683, 22]}, {"full_name": "inv_smul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [37, 9], "def_end_pos": [37, 22]}]], "state_before": "case intro\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv\u271d : \u03b9 \u2192 M\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : CommRing R\u2082\ninst\u271d\u00b9\u2070 : AddCommGroup M\ninst\u271d\u2079 : AddCommGroup M'\ninst\u271d\u2078 : AddCommGroup M''\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\ninst\u271d\u2075 : Module R M'\ninst\u271d\u2074 : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\nG : Type u_10\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : DistribMulAction G R\ninst\u271d\u00b9 : DistribMulAction G M\ninst\u271d : IsScalarTower G R M\nv : \u03b9 \u2192 M\nhv : span R (Set.range v) = \u22a4\nw : \u03b9 \u2192 G\nj : M\nhj : \u2200 (p : Submodule R M), Set.range v \u2286 \u2191p \u2192 j \u2208 p\np : Submodule R M\nhp : Set.range (w \u2022 v) \u2286 \u2191p\ni : \u03b9\nthis : ((w i)\u207b\u00b9 \u2022 1) \u2022 w i \u2022 v i \u2208 p\n\u22a2 v i \u2208 \u2191p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.MapsTo.surjOn_compl", "start": [935, 1], "end": [936, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Associated.mul_left", "start": [527, 1], "end": [528, 51], "traced_tactics": [{"tactic": "obtain \u27e8d, rfl\u27e9 := h", "annotated_tactic": ["obtain \u27e8d, rfl\u27e9 := h", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na b c : \u03b1\nh : b ~\u1d64 c\n\u22a2 a * b ~\u1d64 a * c", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na b : \u03b1\nd : \u03b1\u02e3\n\u22a2 a * b ~\u1d64 a * (b * \u2191d)"}, {"tactic": "exact \u27e8d, mul_assoc _ _ _\u27e9", "annotated_tactic": ["exact \u27e8d, <a>mul_assoc</a> _ _ _\u27e9", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na b : \u03b1\nd : \u03b1\u02e3\n\u22a2 a * b ~\u1d64 a * (b * \u2191d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "full_name": "Real.continuous_log", "start": [355, 1], "end": [356, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Semiconj.lean", "full_name": "SemiconjBy.inv_right_iff\u2080", "start": [57, 1], "end": [58, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Mul.lean", "full_name": "deriv_mul_const", "start": [235, 1], "end": [237, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.not_isRoot_C", "start": [528, 1], "end": [528, 83], "traced_tactics": [{"tactic": "simpa using hr", "annotated_tactic": ["simpa using hr", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na\u271d b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nx r a : R\nhr : r \u2260 0\n\u22a2 \u00acIsRoot (C r) a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "bex_imp", "start": [1077, 1], "end": [1077, 67], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Sort u_1\nr p q : \u03b1 \u2192 Prop\nP Q : (x : \u03b1) \u2192 p x \u2192 Prop\nb : Prop\n\u22a2 (\u2203 x h, P x h) \u2192 b \u2194 \u2200 (x : \u03b1) (h : p x), P x h \u2192 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/Basic.lean", "full_name": "map_coe_atBot_of_Ioo_subset", "start": [1729, 1], "end": [1734, 58], "traced_tactics": [{"tactic": "refine' (map_coe_atTop_of_Ioo_subset (show ofDual \u207b\u00b9' s \u2286 Iio (toDual a) from ha)\n  fun b' hb' => _ : _)", "annotated_tactic": ["refine' (<a>map_coe_atTop_of_Ioo_subset</a> (show <a>ofDual</a> \u207b\u00b9' s \u2286 <a>Iio</a> (<a>toDual</a> a) from ha)\n    fun b' hb' => _ : _)", [{"full_name": "map_coe_atTop_of_Ioo_subset", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order/Basic.lean", "def_pos": [1719, 9], "def_end_pos": [1719, 36]}, {"full_name": "OrderDual.ofDual", "def_path": ".lake/packages/mathlib/Mathlib/Order/Synonym.lean", "def_pos": [55, 5], "def_end_pos": [55, 11]}, {"full_name": "Set.Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [54, 5], "def_end_pos": [54, 8]}, {"full_name": "OrderDual.toDual", "def_path": ".lake/packages/mathlib/Mathlib/Order/Synonym.lean", "def_pos": [50, 5], "def_end_pos": [50, 11]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\ns : Set \u03b1\nha : s \u2286 Ioi a\nhs : \u2200 b' > a, \u2203 b > a, Ioo a b \u2286 s\n\u22a2 map Subtype.val atBot = \ud835\udcdd[>] a", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\ns : Set \u03b1\nha : s \u2286 Ioi a\nhs : \u2200 b' > a, \u2203 b > a, Ioo a b \u2286 s\nb' : \u03b1\u1d52\u1d48\nhb' : b' < toDual a\n\u22a2 \u2203 a_1 < toDual a, Ioo a_1 (toDual a) \u2286 \u21d1ofDual \u207b\u00b9' s"}, {"tactic": "simpa only [OrderDual.exists, dual_Ioo] using hs b' hb'", "annotated_tactic": ["simpa only [<a>OrderDual.exists</a>, <a>dual_Ioo</a>] using hs b' hb'", [{"full_name": "OrderDual.exists", "def_path": ".lake/packages/mathlib/Mathlib/Order/Synonym.lean", "def_pos": [137, 19], "def_end_pos": [137, 27]}, {"full_name": "Set.dual_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [261, 9], "def_end_pos": [261, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : DenselyOrdered \u03b1\na b : \u03b1\ns : Set \u03b1\nha : s \u2286 Ioi a\nhs : \u2200 b' > a, \u2203 b > a, Ioo a b \u2286 s\nb' : \u03b1\u1d52\u1d48\nhb' : b' < toDual a\n\u22a2 \u2203 a_1 < toDual a, Ioo a_1 (toDual a) \u2286 \u21d1ofDual \u207b\u00b9' s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "bihimp_right_involutive", "start": [656, 1], "end": [657, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Topology.lean", "full_name": "isClosed_stdSimplex", "start": [61, 1], "end": [64, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Order/Basic.lean", "full_name": "zpow_abs_eq_one", "start": [538, 1], "end": [540, 57], "traced_tactics": [{"tactic": "rw [\u2190 Int.coe_natAbs, zpow_coe_nat, pow_natAbs_eq_one]", "annotated_tactic": ["rw [\u2190 <a>Int.coe_natAbs</a>, <a>zpow_coe_nat</a>, <a>pow_natAbs_eq_one</a>]", [{"full_name": "Int.coe_natAbs", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Order/Basic.lean", "def_pos": [61, 26], "def_end_pos": [61, 36]}, {"full_name": "zpow_coe_nat", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [962, 9], "def_end_pos": [962, 21]}, {"full_name": "pow_natAbs_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [946, 7], "def_end_pos": [946, 24]}]], "state_before": "G : Type u_1\ninst\u271d : Group G\na : G\nn : \u2124\n\u22a2 a ^ |n| = 1 \u2194 a ^ n = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearForm/Properties.lean", "full_name": "BilinForm.isAdjointPair_iff_compLeft_eq_compRight", "start": [218, 1], "end": [226, 11], "traced_tactics": [{"tactic": "constructor <;> intro h", "annotated_tactic": ["constructor <;> intro h", []], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\n\u22a2 IsAdjointPair B F f g \u2194 compLeft F f = compRight B g", "state_after": "case mp\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : IsAdjointPair B F f g\n\u22a2 compLeft F f = compRight B g\n\ncase mpr\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : compLeft F f = compRight B g\n\u22a2 IsAdjointPair B F f g"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "case mp\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : IsAdjointPair B F f g\n\u22a2 compLeft F f = compRight B g", "state_after": "case mp.H\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : IsAdjointPair B F f g\nx y\u271d : M\n\u22a2 (compLeft F f).bilin x y\u271d = (compRight B g).bilin x y\u271d"}, {"tactic": "simp only [compLeft_apply, compRight_apply]", "annotated_tactic": ["simp only [<a>compLeft_apply</a>, <a>compRight_apply</a>]", [{"full_name": "BilinForm.compLeft_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/BilinearForm/Hom.lean", "def_pos": [268, 9], "def_end_pos": [268, 23]}, {"full_name": "BilinForm.compRight_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/BilinearForm/Hom.lean", "def_pos": [273, 9], "def_end_pos": [273, 24]}]], "state_before": "case mp.H\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : IsAdjointPair B F f g\nx y\u271d : M\n\u22a2 (compLeft F f).bilin x y\u271d = (compRight B g).bilin x y\u271d", "state_after": "case mp.H\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : IsAdjointPair B F f g\nx y\u271d : M\n\u22a2 F.bilin (f x) y\u271d = B.bilin x (g y\u271d)"}, {"tactic": "apply h", "annotated_tactic": ["apply h", []], "state_before": "case mp.H\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : IsAdjointPair B F f g\nx y\u271d : M\n\u22a2 F.bilin (f x) y\u271d = B.bilin x (g y\u271d)", "state_after": "no goals"}, {"tactic": "intro x y", "annotated_tactic": ["intro x y", []], "state_before": "case mpr\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : compLeft F f = compRight B g\n\u22a2 IsAdjointPair B F f g", "state_after": "case mpr\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : compLeft F f = compRight B g\nx y : M\n\u22a2 F.bilin (f x) y = B.bilin x (g y)"}, {"tactic": "rw [\u2190 compLeft_apply, \u2190 compRight_apply]", "annotated_tactic": ["rw [\u2190 <a>compLeft_apply</a>, \u2190 <a>compRight_apply</a>]", [{"full_name": "BilinForm.compLeft_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/BilinearForm/Hom.lean", "def_pos": [268, 9], "def_end_pos": [268, 23]}, {"full_name": "BilinForm.compRight_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/BilinearForm/Hom.lean", "def_pos": [273, 9], "def_end_pos": [273, 24]}]], "state_before": "case mpr\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : compLeft F f = compRight B g\nx y : M\n\u22a2 F.bilin (f x) y = B.bilin x (g y)", "state_after": "case mpr\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : compLeft F f = compRight B g\nx y : M\n\u22a2 (compLeft F f).bilin x y = (compRight B g).bilin x y"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "case mpr\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9\u2074 : CommSemiring R\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : Module R M\nR\u2081 : Type u_3\nM\u2081 : Type u_4\ninst\u271d\u00b9\u00b9 : CommRing R\u2081\ninst\u271d\u00b9\u2070 : AddCommGroup M\u2081\ninst\u271d\u2079 : Module R\u2081 M\u2081\nV : Type u_5\nK : Type u_6\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module K V\nM'\u271d : Type u_7\nM'' : Type u_8\ninst\u271d\u2075 : AddCommMonoid M'\u271d\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M'\u271d\ninst\u271d\u00b2 : Module R M''\nB : BilinForm R M\nB\u2081 : BilinForm R\u2081 M\u2081\nF : BilinForm R M\nM' : Type u_9\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nB' : BilinForm R M'\nf\u271d f' : M \u2192\u2097[R] M'\ng\u271d g' : M' \u2192\u2097[R] M\nf g : Module.End R M\nh : compLeft F f = compRight B g\nx y : M\n\u22a2 (compLeft F f).bilin x y = (compRight B g).bilin x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UnitInterval.lean", "full_name": "Set.Icc.addNSMul_zero", "start": [233, 1], "end": [234, 51], "traced_tactics": [{"tactic": "rw [addNSMul, zero_smul, add_zero, projIcc_left]", "annotated_tactic": ["rw [<a>addNSMul</a>, <a>zero_smul</a>, <a>add_zero</a>, <a>projIcc_left</a>]", [{"full_name": "Set.Icc.addNSMul", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UnitInterval.lean", "def_pos": [231, 5], "def_end_pos": [231, 13]}, {"full_name": "zero_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "Set.projIcc_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/ProjIcc.lean", "def_pos": [90, 9], "def_end_pos": [90, 21]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\na b c d : \u03b1\nh : a \u2264 b\n\u03b4 : \u03b1\n\u22a2 \u2191(addNSMul h \u03b4 0) = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.finite_image_fst_and_snd_iff", "start": [1133, 1], "end": [1136, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Tendsto.const_mul_atBot", "start": [1283, 1], "end": [1285, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.sup_succ_eq_lsub", "start": [1634, 1], "end": [1636, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "full_name": "Complex.log_I", "start": [116, 1], "end": [116, 51], "traced_tactics": [{"tactic": "simp [log]", "annotated_tactic": ["simp [<a>log</a>]", [{"full_name": "Complex.log", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "def_pos": [29, 19], "def_end_pos": [29, 22]}]], "state_before": "\u22a2 log I = \u2191\u03c0 / 2 * I", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Function/Support.lean", "full_name": "Function.mulSupport_binop_subset", "start": [163, 1], "end": [165, 62], "traced_tactics": [{"tactic": "simp only [hf, hg, op1]", "annotated_tactic": ["simp only [hf, hg, op1]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nA : Type u_3\nB : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\nR : Type u_8\nS : Type u_9\nG : Type u_10\nM\u2080 : Type u_11\nG\u2080 : Type u_12\n\u03b9 : Sort u_13\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : One N\ninst\u271d : One P\nop : M \u2192 N \u2192 P\nop1 : op 1 1 = 1\nf : \u03b1 \u2192 M\ng : \u03b1 \u2192 N\nx : \u03b1\nhx : x \u2208 mulSupport fun x => op (f x) (g x)\nhf : f x = 1\nhg : g x = 1\n\u22a2 (fun x => op (f x) (g x)) x = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Finite.exists_ne_map_eq_of_infinite", "start": [1179, 1], "end": [1181, 94], "traced_tactics": [{"tactic": "simpa only [Injective, not_forall, not_imp, and_comm] using not_injective_infinite_finite f", "annotated_tactic": ["simpa only [<a>Injective</a>, <a>not_forall</a>, <a>not_imp</a>, <a>and_comm</a>] using <a>not_injective_infinite_finite</a> f", [{"full_name": "Function.Injective", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [116, 5], "def_end_pos": [116, 14]}, {"full_name": "Classical.not_forall", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [130, 17], "def_end_pos": [130, 27]}, {"full_name": "not_imp", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [443, 9], "def_end_pos": [443, 16]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}, {"full_name": "not_injective_infinite_finite", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [1169, 9], "def_end_pos": [1169, 38]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\ninst\u271d\u00b9 : Infinite \u03b1\ninst\u271d : Finite \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2203 x y, x \u2260 y \u2227 f x = f y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "SupHom.comp_apply", "start": [433, 1], "end": [434, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.val_eq_ite_valMinAbs", "start": [1158, 1], "end": [1161, 48], "traced_tactics": [{"tactic": "rw [valMinAbs_def_pos]", "annotated_tactic": ["rw [<a>valMinAbs_def_pos</a>]", [{"full_name": "ZMod.valMinAbs_def_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [1033, 9], "def_end_pos": [1033, 26]}]], "state_before": "n : \u2115\ninst\u271d : NeZero n\na : ZMod n\n\u22a2 \u2191(val a) = valMinAbs a + \u2191(if val a \u2264 n / 2 then 0 else n)", "state_after": "n : \u2115\ninst\u271d : NeZero n\na : ZMod n\n\u22a2 \u2191(val a) = (if val a \u2264 n / 2 then \u2191(val a) else \u2191(val a) - \u2191n) + \u2191(if val a \u2264 n / 2 then 0 else n)"}, {"tactic": "split_ifs <;> simp [add_zero, sub_add_cancel]", "annotated_tactic": ["split_ifs <;> simp [<a>add_zero</a>, <a>sub_add_cancel</a>]", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "sub_add_cancel", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [807, 30], "def_end_pos": [807, 44]}]], "state_before": "n : \u2115\ninst\u271d : NeZero n\na : ZMod n\n\u22a2 \u2191(val a) = (if val a \u2264 n / 2 then \u2191(val a) else \u2191(val a) - \u2191n) + \u2191(if val a \u2264 n / 2 then 0 else n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "full_name": "Cardinal.mk_multiset_of_nonempty", "start": [1231, 1], "end": [1232, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_subtype", "start": [1067, 1], "end": [1072, 9], "traced_tactics": [{"tactic": "subst p", "annotated_tactic": ["subst p", []], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\np : \u03b1 \u2192 Prop\nF : Fintype (Subtype p)\ns : Finset \u03b1\nh : \u2200 (x : \u03b1), x \u2208 s \u2194 p x\nf : \u03b1 \u2192 \u03b2\nthis : (fun x => x \u2208 s) = p\n\u22a2 \u220f a in s, f a = \u220f a : Subtype p, f \u2191a", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nF : Fintype { x // x \u2208 s }\nh : \u2200 (x : \u03b1), x \u2208 s \u2194 (fun x => x \u2208 s) x\n\u22a2 \u220f a in s, f a = \u220f a : { x // x \u2208 s }, f \u2191a"}, {"tactic": "rw [\u2190 prod_coe_sort]", "annotated_tactic": ["rw [\u2190 <a>prod_coe_sort</a>]", [{"full_name": "Finset.prod_coe_sort", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1054, 9], "def_end_pos": [1054, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nF : Fintype { x // x \u2208 s }\nh : \u2200 (x : \u03b1), x \u2208 s \u2194 (fun x => x \u2208 s) x\n\u22a2 \u220f a in s, f a = \u220f a : { x // x \u2208 s }, f \u2191a", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nF : Fintype { x // x \u2208 s }\nh : \u2200 (x : \u03b1), x \u2208 s \u2194 (fun x => x \u2208 s) x\n\u22a2 \u220f i : { x // x \u2208 s }, f \u2191i = \u220f a : { x // x \u2208 s }, f \u2191a"}, {"tactic": "congr!", "annotated_tactic": ["congr!", []], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nF : Fintype { x // x \u2208 s }\nh : \u2200 (x : \u03b1), x \u2208 s \u2194 (fun x => x \u2208 s) x\n\u22a2 \u220f i : { x // x \u2208 s }, f \u2191i = \u220f a : { x // x \u2208 s }, f \u2191a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Module.lean", "full_name": "Basis.ofIsLocalizedModule_apply", "start": [99, 1], "end": [100, 56], "traced_tactics": [{"tactic": "rw [ofIsLocalizedModule, coe_mk, Function.comp_apply]", "annotated_tactic": ["rw [<a>ofIsLocalizedModule</a>, <a>coe_mk</a>, <a>Function.comp_apply</a>]", [{"full_name": "Basis.ofIsLocalizedModule", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Module.lean", "def_pos": [94, 19], "def_end_pos": [94, 44]}, {"full_name": "Basis.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [1123, 9], "def_end_pos": [1123, 15]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}]], "state_before": "R : Type u_1\nR\u209b : Type u_2\ninst\u271d\u00b9\u2070 : CommSemiring R\nS : Submonoid R\ninst\u271d\u2079 : CommRing R\u209b\ninst\u271d\u2078 : Algebra R R\u209b\nhT : IsLocalization S R\u209b\nM : Type u_3\nM\u209b : Type u_4\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup M\u209b\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 inst\u271d\u00b3 : Module R M\u209b\ninst\u271d\u00b2 : Module R\u209b M\u209b\nf : M \u2192\u2097[R] M\u209b\ninst\u271d\u00b9 : IsLocalizedModule S f\ninst\u271d : IsScalarTower R R\u209b M\u209b\n\u03b9 : Type u_5\nb : Basis \u03b9 R M\ni : \u03b9\n\u22a2 (ofIsLocalizedModule R\u209b S f b) i = f (b i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean", "full_name": "Nat.descFactorial_self", "start": [384, 1], "end": [386, 84], "traced_tactics": [{"tactic": "rw [descFactorial_zero, factorial_zero]", "annotated_tactic": ["rw [<a>descFactorial_zero</a>, <a>factorial_zero</a>]", [{"full_name": "Nat.descFactorial_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [353, 9], "def_end_pos": [353, 27]}, {"full_name": "Nat.factorial_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [42, 17], "def_end_pos": [42, 31]}]], "state_before": "\u22a2 descFactorial 0 0 = 0!", "state_after": "no goals"}, {"tactic": "rw [succ_descFactorial_succ, descFactorial_self n, factorial_succ]", "annotated_tactic": ["rw [<a>succ_descFactorial_succ</a>, descFactorial_self n, <a>factorial_succ</a>]", [{"full_name": "Nat.succ_descFactorial_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [369, 9], "def_end_pos": [369, 32]}, {"full_name": "Nat.factorial_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [46, 9], "def_end_pos": [46, 23]}]], "state_before": "n : \u2115\n\u22a2 descFactorial (succ n) (succ n) = (succ n)!", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Between.lean", "full_name": "Wbtw.trans_right_ne", "start": [511, 1], "end": [514, 34], "traced_tactics": [{"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2077 : OrderedRing R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 : AddCommGroup V'\ninst\u271d\u00b2 : Module R V'\ninst\u271d\u00b9 : AddTorsor V' P'\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Wbtw R x y z\nh : w \u2260 x\n\u22a2 w \u2260 y", "state_after": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2077 : OrderedRing R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 : AddCommGroup V'\ninst\u271d\u00b2 : Module R V'\ninst\u271d\u00b9 : AddTorsor V' P'\ninst\u271d : NoZeroSMulDivisors R V\nw x z : P\nh\u2081 : Wbtw R w x z\nh : w \u2260 x\nh\u2082 : Wbtw R x w z\n\u22a2 False"}, {"tactic": "exact h (h\u2081.swap_left_iff.1 h\u2082)", "annotated_tactic": ["exact h (h\u2081.swap_left_iff.1 h\u2082)", []], "state_before": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2077 : OrderedRing R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 : AddCommGroup V'\ninst\u271d\u00b2 : Module R V'\ninst\u271d\u00b9 : AddTorsor V' P'\ninst\u271d : NoZeroSMulDivisors R V\nw x z : P\nh\u2081 : Wbtw R w x z\nh : w \u2260 x\nh\u2082 : Wbtw R x w z\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NoncommProd.lean", "full_name": "Multiset.noncommProd_map", "start": [198, 1], "end": [201, 32], "traced_tactics": [{"tactic": "induction s using Quotient.inductionOn", "annotated_tactic": ["induction s using <a>Quotient.inductionOn</a>", [{"full_name": "Quotient.inductionOn", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1617, 19], "def_end_pos": [1617, 30]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\ns : Multiset \u03b1\ncomm : Set.Pairwise {x | x \u2208 s} Commute\nf : F\n\u22a2 f (noncommProd s comm) = noncommProd (map (\u21d1f) s) \u22ef", "state_after": "case h\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\na\u271d : List \u03b1\ncomm : Set.Pairwise {x | x \u2208 \u27e6a\u271d\u27e7} Commute\n\u22a2 f (noncommProd \u27e6a\u271d\u27e7 comm) = noncommProd (map \u21d1f \u27e6a\u271d\u27e7) \u22ef"}, {"tactic": "simpa using map_list_prod f _", "annotated_tactic": ["simpa using <a>map_list_prod</a> f _", [{"full_name": "map_list_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [712, 9], "def_end_pos": [712, 22]}]], "state_before": "case h\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b3 : Monoid \u03b1\ninst\u271d\u00b2 : Monoid \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\na\u271d : List \u03b1\ncomm : Set.Pairwise {x | x \u2208 \u27e6a\u271d\u27e7} Commute\n\u22a2 f (noncommProd \u27e6a\u271d\u27e7 comm) = noncommProd (map \u21d1f \u27e6a\u271d\u27e7) \u22ef", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Nat.even_mul_pred_self", "start": [223, 1], "end": [225, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Normal.lean", "full_name": "IntermediateField.splits_of_mem_adjoin", "start": [183, 1], "end": [193, 97], "traced_tactics": [{"tactic": "let E : IntermediateField F L := \u2a06 x : S, adjoin F ((minpoly F x.val).rootSet L)", "annotated_tactic": ["let E : <a>IntermediateField</a> F L := \u2a06 x : S, <a>adjoin</a> F ((<a>minpoly</a> F x.val).<a>rootSet</a> L)", [{"full_name": "IntermediateField", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/IntermediateField.lean", "def_pos": [47, 11], "def_end_pos": [47, 28]}, {"full_name": "IntermediateField.adjoin", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "minpoly", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Basic.lean", "def_pos": [38, 19], "def_end_pos": [38, 26]}, {"full_name": "Polynomial.rootSet", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1168, 5], "def_end_pos": [1168, 12]}]], "state_before": "F : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\n\u22a2 Splits (algebraMap F L) (minpoly F x)", "state_after": "F : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\n\u22a2 Splits (algebraMap F L) (minpoly F x)"}, {"tactic": "have normal : Normal F E := normal_iSup (h := fun x \u21a6\n  Normal.of_isSplittingField (hFEp := adjoin_rootSet_isSplittingField (splits x x.2).2))", "annotated_tactic": ["have normal : <a>Normal</a> F E := <a>normal_iSup</a> (h := fun x \u21a6\n    <a>Normal.of_isSplittingField</a> (hFEp := <a>adjoin_rootSet_isSplittingField</a> (splits x x.2).2))", [{"full_name": "Normal", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Normal.lean", "def_pos": [37, 7], "def_end_pos": [37, 13]}, {"full_name": "IntermediateField.normal_iSup", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Normal.lean", "def_pos": [160, 10], "def_end_pos": [160, 21]}, {"full_name": "Normal.of_isSplittingField", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Normal.lean", "def_pos": [126, 9], "def_end_pos": [126, 35]}, {"full_name": "IntermediateField.adjoin_rootSet_isSplittingField", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [662, 9], "def_end_pos": [662, 40]}]], "state_before": "F : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\n\u22a2 Splits (algebraMap F L) (minpoly F x)", "state_after": "F : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\nnormal : Normal F \u21a5E\n\u22a2 Splits (algebraMap F L) (minpoly F x)"}, {"tactic": "have : \u2200 x \u2208 S, (minpoly F x).Splits (algebraMap F E) := fun x hx \u21a6 splits_of_splits\n  (splits x hx).2 fun y hy \u21a6 (le_iSup _ \u27e8x, hx\u27e9 : _ \u2264 E) (subset_adjoin F _ <| by exact hy)", "annotated_tactic": ["have : \u2200 x \u2208 S, (<a>minpoly</a> F x).<a>Splits</a> (<a>algebraMap</a> F E) := fun x hx \u21a6 <a>splits_of_splits</a>\n    (splits x hx).2 fun y hy \u21a6 (<a>le_iSup</a> _ \u27e8x, hx\u27e9 : _ \u2264 E) (<a>subset_adjoin</a> F _ <| by exact hy)", [{"full_name": "minpoly", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Basic.lean", "def_pos": [38, 19], "def_end_pos": [38, 26]}, {"full_name": "Polynomial.Splits", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Splits.lean", "def_pos": [47, 5], "def_end_pos": [47, 11]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}, {"full_name": "IntermediateField.splits_of_splits", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/SplittingField/IsSplittingField.lean", "def_pos": [157, 9], "def_end_pos": [157, 43]}, {"full_name": "le_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [706, 9], "def_end_pos": [706, 16]}, {"full_name": "IntermediateField.subset_adjoin", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [360, 9], "def_end_pos": [360, 22]}]], "state_before": "F : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\nnormal : Normal F \u21a5E\n\u22a2 Splits (algebraMap F L) (minpoly F x)", "state_after": "F : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\nnormal : Normal F \u21a5E\nthis : \u2200 x \u2208 S, Splits (algebraMap F \u21a5E) (minpoly F x)\n\u22a2 Splits (algebraMap F L) (minpoly F x)"}, {"tactic": "obtain \u27e8\u03c6\u27e9 := nonempty_algHom_adjoin_of_splits fun x hx \u21a6 \u27e8(splits x hx).1, this x hx\u27e9", "annotated_tactic": ["obtain \u27e8\u03c6\u27e9 := <a>nonempty_algHom_adjoin_of_splits</a> fun x hx \u21a6 \u27e8(splits x hx).1, this x hx\u27e9", [{"full_name": "IntermediateField.nonempty_algHom_adjoin_of_splits", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Extension.lean", "def_pos": [157, 9], "def_end_pos": [157, 41]}]], "state_before": "F : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\nnormal : Normal F \u21a5E\nthis : \u2200 x \u2208 S, Splits (algebraMap F \u21a5E) (minpoly F x)\n\u22a2 Splits (algebraMap F L) (minpoly F x)", "state_after": "case intro\nF : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\nnormal : Normal F \u21a5E\nthis : \u2200 x \u2208 S, Splits (algebraMap F \u21a5E) (minpoly F x)\n\u03c6 : \u21a5(adjoin F S) \u2192\u2090[F] \u21a5E\n\u22a2 Splits (algebraMap F L) (minpoly F x)"}, {"tactic": "convert splits_comp_of_splits _ E.val.toRingHom (normal.splits <| \u03c6 \u27e8x, hx\u27e9)", "annotated_tactic": ["convert <a>splits_comp_of_splits</a> _ E.val.toRingHom (normal.splits <| \u03c6 \u27e8x, hx\u27e9)", [{"full_name": "Polynomial.splits_comp_of_splits", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Splits.lean", "def_pos": [440, 9], "def_end_pos": [440, 30]}]], "state_before": "case intro\nF : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\nnormal : Normal F \u21a5E\nthis : \u2200 x \u2208 S, Splits (algebraMap F \u21a5E) (minpoly F x)\n\u03c6 : \u21a5(adjoin F S) \u2192\u2090[F] \u21a5E\n\u22a2 Splits (algebraMap F L) (minpoly F x)", "state_after": "case h.e'_6\nF : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\nnormal : Normal F \u21a5E\nthis : \u2200 x \u2208 S, Splits (algebraMap F \u21a5E) (minpoly F x)\n\u03c6 : \u21a5(adjoin F S) \u2192\u2090[F] \u21a5E\n\u22a2 minpoly F x = minpoly F (\u03c6 { val := x, property := hx })"}, {"tactic": "rw [minpoly.algHom_eq _ \u03c6.injective, \u2190 minpoly.algHom_eq _ (adjoin F S).val.injective, val_mk]", "annotated_tactic": ["rw [<a>minpoly.algHom_eq</a> _ \u03c6.injective, \u2190 <a>minpoly.algHom_eq</a> _ (<a>adjoin</a> F S).val.injective, <a>val_mk</a>]", [{"full_name": "minpoly.algHom_eq", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Basic.lean", "def_pos": [67, 9], "def_end_pos": [67, 18]}, {"full_name": "minpoly.algHom_eq", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Basic.lean", "def_pos": [67, 9], "def_end_pos": [67, 18]}, {"full_name": "IntermediateField.adjoin", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "IntermediateField.val_mk", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/IntermediateField.lean", "def_pos": [522, 9], "def_end_pos": [522, 15]}]], "state_before": "case h.e'_6\nF : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx : K\nhx : x \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\nnormal : Normal F \u21a5E\nthis : \u2200 x \u2208 S, Splits (algebraMap F \u21a5E) (minpoly F x)\n\u03c6 : \u21a5(adjoin F S) \u2192\u2090[F] \u21a5E\n\u22a2 minpoly F x = minpoly F (\u03c6 { val := x, property := hx })", "state_after": "no goals"}, {"tactic": "exact hy", "annotated_tactic": ["exact hy", []], "state_before": "F : Type u_1\nK : Type u_2\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\nL : Type u_3\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nS : Set K\nsplits : \u2200 x \u2208 S, IsIntegral F x \u2227 Splits (algebraMap F L) (minpoly F x)\nx\u271d : K\nhx\u271d : x\u271d \u2208 adjoin F S\nE : IntermediateField F L := \u2a06 x, adjoin F (rootSet (minpoly F \u2191x) L)\nnormal : Normal F \u21a5E\nx : K\nhx : x \u2208 S\ny : L\nhy : y \u2208 rootSet (minpoly F x) L\n\u22a2 y \u2208 rootSet (minpoly F \u2191{ val := x, property := hx }) L", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Perm.lean", "full_name": "List.Perm.union_right", "start": [637, 1], "end": [642, 49], "traced_tactics": [{"tactic": "induction h with\n| nil => rfl\n| cons a _ ih => exact ih.insert a\n| swap => apply perm_insert_swap\n| trans _ _ ih_1 ih_2 => exact ih_1.trans ih_2", "annotated_tactic": ["induction h with\n  | <a>nil</a> => rfl\n  | <a>cons</a> a _ ih => exact ih.insert a\n  | <a>swap</a> => apply <a>perm_insert_swap</a>\n  | <a>trans</a> _ _ ih_1 ih_2 => exact ih_1.trans ih_2", [{"full_name": "List.Perm.nil", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1560, 5], "def_end_pos": [1560, 8]}, {"full_name": "List.Perm.cons", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1562, 5], "def_end_pos": [1562, 9]}, {"full_name": "List.Perm.swap", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1564, 5], "def_end_pos": [1564, 9]}, {"full_name": "List.perm_insert_swap", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [616, 9], "def_end_pos": [616, 25]}, {"full_name": "List.Perm.trans", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1566, 5], "def_end_pos": [1566, 10]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 t\u2081 : List \u03b1\nh : l\u2081 ~ l\u2082\n\u22a2 l\u2081 \u222a t\u2081 ~ l\u2082 \u222a t\u2081", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 t\u2081 : List \u03b1\n\u22a2 [] \u222a t\u2081 ~ [] \u222a t\u2081", "state_after": "no goals"}, {"tactic": "exact ih.insert a", "annotated_tactic": ["exact ih.insert a", []], "state_before": "case cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 t\u2081 : List \u03b1\na : \u03b1\nl\u2081\u271d l\u2082\u271d : List \u03b1\na\u271d : l\u2081\u271d ~ l\u2082\u271d\nih : l\u2081\u271d \u222a t\u2081 ~ l\u2082\u271d \u222a t\u2081\n\u22a2 a :: l\u2081\u271d \u222a t\u2081 ~ a :: l\u2082\u271d \u222a t\u2081", "state_after": "no goals"}, {"tactic": "apply perm_insert_swap", "annotated_tactic": ["apply <a>perm_insert_swap</a>", [{"full_name": "List.perm_insert_swap", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [616, 9], "def_end_pos": [616, 25]}]], "state_before": "case swap\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 t\u2081 : List \u03b1\nx\u271d y\u271d : \u03b1\nl\u271d : List \u03b1\n\u22a2 y\u271d :: x\u271d :: l\u271d \u222a t\u2081 ~ x\u271d :: y\u271d :: l\u271d \u222a t\u2081", "state_after": "no goals"}, {"tactic": "exact ih_1.trans ih_2", "annotated_tactic": ["exact ih_1.trans ih_2", []], "state_before": "case trans\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl\u2081 l\u2082 t\u2081 l\u2081\u271d l\u2082\u271d l\u2083\u271d : List \u03b1\na\u271d\u00b9 : l\u2081\u271d ~ l\u2082\u271d\na\u271d : l\u2082\u271d ~ l\u2083\u271d\nih_1 : l\u2081\u271d \u222a t\u2081 ~ l\u2082\u271d \u222a t\u2081\nih_2 : l\u2082\u271d \u222a t\u2081 ~ l\u2083\u271d \u222a t\u2081\n\u22a2 l\u2081\u271d \u222a t\u2081 ~ l\u2083\u271d \u222a t\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Chain.lean", "full_name": "IsMaxChain.not_superChain", "start": [151, 1], "end": [152, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "LipschitzWith.nnorm_le_mul'", "start": [1120, 1], "end": [1122, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Star.lean", "full_name": "starConvex_iff_segment_subset", "start": [75, 1], "end": [80, 40], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : SMul \ud835\udd5c F\nx : E\ns t : Set E\n\u22a2 StarConvex \ud835\udd5c x s \u2194 \u2200 \u2983y : E\u2984, y \u2208 s \u2192 [x-[\ud835\udd5c]y] \u2286 s", "state_after": "case mp\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : SMul \ud835\udd5c F\nx : E\ns t : Set E\n\u22a2 StarConvex \ud835\udd5c x s \u2192 \u2200 \u2983y : E\u2984, y \u2208 s \u2192 [x-[\ud835\udd5c]y] \u2286 s\n\ncase mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : SMul \ud835\udd5c F\nx : E\ns t : Set E\n\u22a2 (\u2200 \u2983y : E\u2984, y \u2208 s \u2192 [x-[\ud835\udd5c]y] \u2286 s) \u2192 StarConvex \ud835\udd5c x s"}, {"tactic": "rintro h y hy z \u27e8a, b, ha, hb, hab, rfl\u27e9", "annotated_tactic": ["rintro h y hy z \u27e8a, b, ha, hb, hab, rfl\u27e9", []], "state_before": "case mp\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : SMul \ud835\udd5c F\nx : E\ns t : Set E\n\u22a2 StarConvex \ud835\udd5c x s \u2192 \u2200 \u2983y : E\u2984, y \u2208 s \u2192 [x-[\ud835\udd5c]y] \u2286 s", "state_after": "case mp.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : SMul \ud835\udd5c F\nx : E\ns t : Set E\nh : StarConvex \ud835\udd5c x s\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 s"}, {"tactic": "exact h hy ha hb hab", "annotated_tactic": ["exact h hy ha hb hab", []], "state_before": "case mp.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : SMul \ud835\udd5c F\nx : E\ns t : Set E\nh : StarConvex \ud835\udd5c x s\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 s", "state_after": "no goals"}, {"tactic": "rintro h y hy a b ha hb hab", "annotated_tactic": ["rintro h y hy a b ha hb hab", []], "state_before": "case mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : SMul \ud835\udd5c F\nx : E\ns t : Set E\n\u22a2 (\u2200 \u2983y : E\u2984, y \u2208 s \u2192 [x-[\ud835\udd5c]y] \u2286 s) \u2192 StarConvex \ud835\udd5c x s", "state_after": "case mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : SMul \ud835\udd5c F\nx : E\ns t : Set E\nh : \u2200 \u2983y : E\u2984, y \u2208 s \u2192 [x-[\ud835\udd5c]y] \u2286 s\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 s"}, {"tactic": "exact h hy \u27e8a, b, ha, hb, hab, rfl\u27e9", "annotated_tactic": ["exact h hy \u27e8a, b, ha, hb, hab, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : OrderedSemiring \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : SMul \ud835\udd5c F\nx : E\ns t : Set E\nh : \u2200 \u2983y : E\u2984, y \u2208 s \u2192 [x-[\ud835\udd5c]y] \u2286 s\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/AdjoinRoot.lean", "full_name": "AdjoinRoot.algebraMap_eq'", "start": [153, 1], "end": [155, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.coe_subset_singleton", "start": [741, 1], "end": [742, 96], "traced_tactics": [{"tactic": "rw [\u2190 coe_subset, coe_singleton]", "annotated_tactic": ["rw [\u2190 <a>coe_subset</a>, <a>coe_singleton</a>]", [{"full_name": "Finset.coe_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [381, 9], "def_end_pos": [381, 19]}, {"full_name": "Finset.coe_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [731, 9], "def_end_pos": [731, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Finset \u03b1\na b : \u03b1\n\u22a2 \u2191s \u2286 {a} \u2194 s \u2286 {a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "minimal_nonempty_closed_subsingleton", "start": [269, 1], "end": [278, 36], "traced_tactics": [{"tactic": "clear Y", "annotated_tactic": ["clear Y", []], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\n\u22a2 Set.Subsingleton s", "state_after": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\n\u22a2 Set.Subsingleton s"}, {"tactic": "refine' fun x hx y hy => of_not_not fun hxy => _", "annotated_tactic": ["refine' fun x hx y hy => <a>of_not_not</a> fun hxy => _", [{"full_name": "of_not_not", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [249, 9], "def_end_pos": [249, 19]}]], "state_before": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\n\u22a2 Set.Subsingleton s", "state_after": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\n\u22a2 False"}, {"tactic": "rcases exists_isOpen_xor'_mem hxy with \u27e8U, hUo, hU\u27e9", "annotated_tactic": ["rcases <a>exists_isOpen_xor'_mem</a> hxy with \u27e8U, hUo, hU\u27e9", [{"full_name": "exists_isOpen_xor'_mem", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Separation.lean", "def_pos": [255, 9], "def_end_pos": [255, 31]}]], "state_before": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\n\u22a2 False", "state_after": "case intro.intro\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\n\u22a2 False"}, {"tactic": "wlog h : x \u2208 U \u2227 y \u2209 U", "annotated_tactic": ["wlog h : x \u2208 U \u2227 y \u2209 U", []], "state_before": "case intro.intro\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\n\u22a2 False", "state_after": "case intro.intro.inr\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\nthis :\n  \u2200 {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] {s : Set X},\n    IsClosed s \u2192\n      (\u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s) \u2192\n        \u2200 x \u2208 s, \u2200 y \u2208 s, \u00acx = y \u2192 \u2200 (U : Set X), IsOpen U \u2192 Xor' (x \u2208 U) (y \u2208 U) \u2192 x \u2208 U \u2227 y \u2209 U \u2192 False\nh : \u00ac(x \u2208 U \u2227 y \u2209 U)\n\u22a2 False\n\nX\u271d : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\u271d\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\nh : x \u2208 U \u2227 y \u2209 U\n\u22a2 False"}, {"tactic": "cases' h with hxU hyU", "annotated_tactic": ["cases' h with hxU hyU", []], "state_before": "X\u271d : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\u271d\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\nh : x \u2208 U \u2227 y \u2209 U\n\u22a2 False", "state_after": "case intro\nX\u271d : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\u271d\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\nhxU : x \u2208 U\nhyU : y \u2209 U\n\u22a2 False"}, {"tactic": "have : s \\ U = s := hmin (s \\ U) (diff_subset _ _) \u27e8y, hy, hyU\u27e9 (hs.sdiff hUo)", "annotated_tactic": ["have : s \\ U = s := hmin (s \\ U) (<a>diff_subset</a> _ _) \u27e8y, hy, hyU\u27e9 (hs.sdiff hUo)", [{"full_name": "Set.diff_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1812, 9], "def_end_pos": [1812, 20]}]], "state_before": "case intro\nX\u271d : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\u271d\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\nhxU : x \u2208 U\nhyU : y \u2209 U\n\u22a2 False", "state_after": "case intro\nX\u271d : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\u271d\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\nhxU : x \u2208 U\nhyU : y \u2209 U\nthis : s \\ U = s\n\u22a2 False"}, {"tactic": "exact (this.symm.subset hx).2 hxU", "annotated_tactic": ["exact (this.symm.subset hx).2 hxU", []], "state_before": "case intro\nX\u271d : Type u_1\ninst\u271d\u00b2 : TopologicalSpace X\u271d\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\nhxU : x \u2208 U\nhyU : y \u2209 U\nthis : s \\ U = s\n\u22a2 False", "state_after": "no goals"}, {"tactic": "refine this hs hmin y hy x hx (Ne.symm hxy) U hUo hU.symm (hU.resolve_left h)", "annotated_tactic": ["refine this hs hmin y hy x hx (<a>Ne.symm</a> hxy) U hUo hU.symm (hU.resolve_left h)", [{"full_name": "Ne.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [702, 9], "def_end_pos": [702, 16]}]], "state_before": "case intro.intro.inr\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\ns : Set X\nhs : IsClosed s\nhmin : \u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s\nx : X\nhx : x \u2208 s\ny : X\nhy : y \u2208 s\nhxy : \u00acx = y\nU : Set X\nhUo : IsOpen U\nhU : Xor' (x \u2208 U) (y \u2208 U)\nthis :\n  \u2200 {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] {s : Set X},\n    IsClosed s \u2192\n      (\u2200 t \u2286 s, Set.Nonempty t \u2192 IsClosed t \u2192 t = s) \u2192\n        \u2200 x \u2208 s, \u2200 y \u2208 s, \u00acx = y \u2192 \u2200 (U : Set X), IsOpen U \u2192 Xor' (x \u2208 U) (y \u2208 U) \u2192 x \u2208 U \u2227 y \u2209 U \u2192 False\nh : \u00ac(x \u2208 U \u2227 y \u2209 U)\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Nontrivial/Defs.lean", "full_name": "not_nontrivial_iff_subsingleton", "start": [83, 1], "end": [84, 86], "traced_tactics": [{"tactic": "simp only [nontrivial_iff, subsingleton_iff, not_exists, Ne.def, Classical.not_not]", "annotated_tactic": ["simp only [<a>nontrivial_iff</a>, <a>subsingleton_iff</a>, <a>not_exists</a>, <a>Ne.def</a>, <a>Classical.not_not</a>]", [{"full_name": "nontrivial_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [36, 9], "def_end_pos": [36, 23]}, {"full_name": "subsingleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [77, 9], "def_end_pos": [77, 25]}, {"full_name": "not_exists", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [187, 17], "def_end_pos": [187, 27]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Classical.not_not", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [128, 24], "def_end_pos": [128, 31]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 \u00acNontrivial \u03b1 \u2194 Subsingleton \u03b1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/OrderClosed.lean", "full_name": "IsClosed.isClosed_le", "start": [702, 1], "end": [704, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Thickening.lean", "full_name": "Metric.thickening_subset_cthickening", "start": [281, 1], "end": [284, 14], "traced_tactics": [{"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\n\u22a2 thickening \u03b4 E \u2286 cthickening \u03b4 E", "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nhx : x \u2208 thickening \u03b4 E\n\u22a2 x \u2208 cthickening \u03b4 E"}, {"tactic": "rw [thickening, mem_setOf_eq] at hx", "annotated_tactic": ["rw [<a>thickening</a>, <a>mem_setOf_eq</a>] at hx", [{"full_name": "Metric.thickening", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [51, 5], "def_end_pos": [51, 15]}, {"full_name": "Set.mem_setOf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [79, 29], "def_end_pos": [79, 41]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nhx : x \u2208 thickening \u03b4 E\n\u22a2 x \u2208 cthickening \u03b4 E", "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nhx : infEdist x E < ENNReal.ofReal \u03b4\n\u22a2 x \u2208 cthickening \u03b4 E"}, {"tactic": "exact hx.le", "annotated_tactic": ["exact hx.le", []], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nhx : infEdist x E < ENNReal.ofReal \u03b4\n\u22a2 x \u2208 cthickening \u03b4 E", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "LinearIsometryEquiv.norm_iteratedFDeriv_comp_right", "start": [473, 1], "end": [476, 86], "traced_tactics": [{"tactic": "simp only [\u2190 iteratedFDerivWithin_univ]", "annotated_tactic": ["simp only [\u2190 <a>iteratedFDerivWithin_univ</a>]", [{"full_name": "iteratedFDerivWithin_univ", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [1599, 9], "def_end_pos": [1599, 34]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf\u271d f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\ng : G \u2243\u2097\u1d62[\ud835\udd5c] E\nf : E \u2192 F\nx : G\ni : \u2115\n\u22a2 \u2016iteratedFDeriv \ud835\udd5c i (f \u2218 \u21d1g) x\u2016 = \u2016iteratedFDeriv \ud835\udd5c i f (g x)\u2016", "state_after": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf\u271d f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\ng : G \u2243\u2097\u1d62[\ud835\udd5c] E\nf : E \u2192 F\nx : G\ni : \u2115\n\u22a2 \u2016iteratedFDerivWithin \ud835\udd5c i (f \u2218 \u21d1g) univ x\u2016 = \u2016iteratedFDerivWithin \ud835\udd5c i f univ (g x)\u2016"}, {"tactic": "apply g.norm_iteratedFDerivWithin_comp_right f uniqueDiffOn_univ (mem_univ (g x)) i", "annotated_tactic": ["apply g.norm_iteratedFDerivWithin_comp_right f <a>uniqueDiffOn_univ</a> (<a>mem_univ</a> (g x)) i", [{"full_name": "uniqueDiffOn_univ", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/TangentCone.lean", "def_pos": [244, 9], "def_end_pos": [244, 26]}, {"full_name": "Set.mem_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [82, 29], "def_end_pos": [82, 37]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\nD : Type uD\ninst\u271d\u2079 : NormedAddCommGroup D\ninst\u271d\u2078 : NormedSpace \ud835\udd5c D\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf\u271d f\u2081 : E \u2192 F\ng\u271d : F \u2192 G\nx\u271d x\u2080 : E\nc : F\nb : E \u00d7 F \u2192 G\nm n : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\ng : G \u2243\u2097\u1d62[\ud835\udd5c] E\nf : E \u2192 F\nx : G\ni : \u2115\n\u22a2 \u2016iteratedFDerivWithin \ud835\udd5c i (f \u2218 \u21d1g) univ x\u2016 = \u2016iteratedFDerivWithin \ud835\udd5c i f univ (g x)\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.inf_sup_distrib_left", "start": [559, 1], "end": [561, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "full_name": "HasSum.update'", "start": [276, 1], "end": [286, 58], "traced_tactics": [{"tactic": "have h := hf.add (hasSum_ite_eq b x)", "annotated_tactic": ["have h := hf.add (<a>hasSum_ite_eq</a> b x)", [{"full_name": "hasSum_ite_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 22]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nthis : \u2200 (b' : \u03b2), (f b' + if b' = b then x else 0) = update f b x b' + if b' = b then f b else 0\n\u22a2 a + x = a' + f b", "state_after": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nthis : \u2200 (b' : \u03b2), (f b' + if b' = b then x else 0) = update f b x b' + if b' = b then f b else 0\nh : HasSum (fun b_1 => f b_1 + if b_1 = b then x else 0) (a + x)\n\u22a2 a + x = a' + f b"}, {"tactic": "simp_rw [this] at h", "annotated_tactic": ["simp_rw [this] at h", []], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nthis : \u2200 (b' : \u03b2), (f b' + if b' = b then x else 0) = update f b x b' + if b' = b then f b else 0\nh : HasSum (fun b_1 => f b_1 + if b_1 = b then x else 0) (a + x)\n\u22a2 a + x = a' + f b", "state_after": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nthis : \u2200 (b' : \u03b2), (f b' + if b' = b then x else 0) = update f b x b' + if b' = b then f b else 0\nh : HasSum (fun b_1 => update f b x b_1 + if b_1 = b then f b else 0) (a + x)\n\u22a2 a + x = a' + f b"}, {"tactic": "exact HasSum.unique h (hf'.add (hasSum_ite_eq b (f b)))", "annotated_tactic": ["exact <a>HasSum.unique</a> h (hf'.add (<a>hasSum_ite_eq</a> b (f b)))", [{"full_name": "HasSum.unique", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [129, 9], "def_end_pos": [129, 22]}, {"full_name": "hasSum_ite_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 22]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nthis : \u2200 (b' : \u03b2), (f b' + if b' = b then x else 0) = update f b x b' + if b' = b then f b else 0\nh : HasSum (fun b_1 => update f b x b_1 + if b_1 = b then f b else 0) (a + x)\n\u22a2 a + x = a' + f b", "state_after": "no goals"}, {"tactic": "intro b'", "annotated_tactic": ["intro b'", []], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\n\u22a2 \u2200 (b' : \u03b2), (f b' + if b' = b then x else 0) = update f b x b' + if b' = b then f b else 0", "state_after": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nb' : \u03b2\n\u22a2 (f b' + if b' = b then x else 0) = update f b x b' + if b' = b then f b else 0"}, {"tactic": "split_ifs with hb'", "annotated_tactic": ["split_ifs with hb'", []], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nb' : \u03b2\n\u22a2 (f b' + if b' = b then x else 0) = update f b x b' + if b' = b then f b else 0", "state_after": "case pos\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nb' : \u03b2\nhb' : b' = b\n\u22a2 f b' + x = update f b x b' + f b\n\ncase neg\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nb' : \u03b2\nhb' : \u00acb' = b\n\u22a2 f b' + 0 = update f b x b' + 0"}, {"tactic": "simpa only [Function.update_apply, hb', eq_self_iff_true] using add_comm (f b) x", "annotated_tactic": ["simpa only [<a>Function.update_apply</a>, hb', <a>eq_self_iff_true</a>] using <a>add_comm</a> (f b) x", [{"full_name": "Function.update_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [571, 9], "def_end_pos": [571, 21]}, {"full_name": "eq_self_iff_true", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1368, 9], "def_end_pos": [1368, 25]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "case pos\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nb' : \u03b2\nhb' : b' = b\n\u22a2 f b' + x = update f b x b' + f b", "state_after": "no goals"}, {"tactic": "simp only [Function.update_apply, hb', if_false]", "annotated_tactic": ["simp only [<a>Function.update_apply</a>, hb', <a>if_false</a>]", [{"full_name": "Function.update_apply", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [571, 9], "def_end_pos": [571, 21]}, {"full_name": "if_false", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [26, 17], "def_end_pos": [26, 25]}]], "state_before": "case neg\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2077 : AddCommMonoid \u03b1\u271d\ninst\u271d\u2076 : TopologicalSpace \u03b1\u271d\nf\u271d g : \u03b2\u271d \u2192 \u03b1\u271d\na\u271d b\u271d : \u03b1\u271d\ns : Finset \u03b2\u271d\ninst\u271d\u2075 : ContinuousAdd \u03b1\u271d\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b2 \u2192 \u03b1\na a' : \u03b1\nhf : HasSum f a\nb : \u03b2\nx : \u03b1\nhf' : HasSum (update f b x) a'\nb' : \u03b2\nhb' : \u00acb' = b\n\u22a2 f b' + 0 = update f b x b' + 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Exponent.lean", "full_name": "Commute.of_orderOf_dvd_two", "start": [684, 1], "end": [692, 57], "traced_tactics": [{"tactic": "simp_rw [orderOf_dvd_iff_pow_eq_one] at h", "annotated_tactic": ["simp_rw [<a>orderOf_dvd_iff_pow_eq_one</a>] at h", [{"full_name": "orderOf_dvd_iff_pow_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [272, 9], "def_end_pos": [272, 35]}]], "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\nh : \u2200 (g : G), orderOf g \u2223 2\na b : G\n\u22a2 Commute a b", "state_after": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 Commute a b"}, {"tactic": "rw [commute_iff_eq, \u2190 mul_right_inj a, \u2190 mul_left_inj b]", "annotated_tactic": ["rw [<a>commute_iff_eq</a>, \u2190 <a>mul_right_inj</a> a, \u2190 <a>mul_left_inj</a> b]", [{"full_name": "commute_iff_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [45, 9], "def_end_pos": [45, 23]}, {"full_name": "mul_right_inj", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [40, 9], "def_end_pos": [40, 22]}, {"full_name": "mul_left_inj", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [63, 9], "def_end_pos": [63, 21]}]], "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 Commute a b", "state_after": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 a * (a * b) * b = a * (b * a) * b"}, {"tactic": "calc\n  a * (a * b) * b = a ^ 2 * b ^ 2 := by simp only [pow_two]; group\n  _ = 1 := by rw [h, h, mul_one]\n  _ = (a * b) ^ 2 := by rw [h]\n  _ = a * (b * a) * b := by simp only [pow_two]; group", "annotated_tactic": ["calc\n    a * (a * b) * b = a ^ 2 * b ^ 2 := by simp only [<a>pow_two</a>]; group\n    _ = 1 := by rw [h, h, <a>mul_one</a>]\n    _ = (a * b) ^ 2 := by rw [h]\n    _ = a * (b * a) * b := by simp only [<a>pow_two</a>]; group", [{"full_name": "pow_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [86, 32], "def_end_pos": [86, 39]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}, {"full_name": "pow_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [86, 32], "def_end_pos": [86, 39]}]], "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 a * (a * b) * b = a * (b * a) * b", "state_after": "no goals"}, {"tactic": "simp only [pow_two]", "annotated_tactic": ["simp only [<a>pow_two</a>]", [{"full_name": "pow_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [86, 32], "def_end_pos": [86, 39]}]], "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 a * (a * b) * b = a ^ 2 * b ^ 2", "state_after": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 a * (a * b) * b = a * a * (b * b)"}, {"tactic": "group", "annotated_tactic": ["group", []], "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 a * (a * b) * b = a * a * (b * b)", "state_after": "no goals"}, {"tactic": "rw [h, h, mul_one]", "annotated_tactic": ["rw [h, h, <a>mul_one</a>]", [{"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 a ^ 2 * b ^ 2 = 1", "state_after": "no goals"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 1 = (a * b) ^ 2", "state_after": "no goals"}, {"tactic": "simp only [pow_two]", "annotated_tactic": ["simp only [<a>pow_two</a>]", [{"full_name": "pow_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [86, 32], "def_end_pos": [86, 39]}]], "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 (a * b) ^ 2 = a * (b * a) * b", "state_after": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 a * b * (a * b) = a * (b * a) * b"}, {"tactic": "group", "annotated_tactic": ["group", []], "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : IsCancelMul G\na b : G\nh : \u2200 (g : G), g ^ 2 = 1\n\u22a2 a * b * (a * b) = a * (b * a) * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "iteratedFDeriv_zero_apply", "start": [1531, 1], "end": [1533, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_X_le", "start": [476, 1], "end": [477, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Defs.lean", "full_name": "PosSMulMono.of_pos", "start": [529, 1], "end": [536, 26], "traced_tactics": [{"tactic": "obtain ha | ha := ha.eq_or_lt", "annotated_tactic": ["obtain ha | ha := ha.eq_or_lt", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2080 : \u2200 (a : \u03b1), 0 < a \u2192 \u2200 (b\u2081 b\u2082 : \u03b2), b\u2081 \u2264 b\u2082 \u2192 a \u2022 b\u2081 \u2264 a \u2022 b\u2082\na : \u03b1\nha : 0 \u2264 a\nb\u2081 b\u2082 : \u03b2\nh : b\u2081 \u2264 b\u2082\n\u22a2 a \u2022 b\u2081 \u2264 a \u2022 b\u2082", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2080 : \u2200 (a : \u03b1), 0 < a \u2192 \u2200 (b\u2081 b\u2082 : \u03b2), b\u2081 \u2264 b\u2082 \u2192 a \u2022 b\u2081 \u2264 a \u2022 b\u2082\na : \u03b1\nha\u271d : 0 \u2264 a\nb\u2081 b\u2082 : \u03b2\nh : b\u2081 \u2264 b\u2082\nha : 0 = a\n\u22a2 a \u2022 b\u2081 \u2264 a \u2022 b\u2082\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2080 : \u2200 (a : \u03b1), 0 < a \u2192 \u2200 (b\u2081 b\u2082 : \u03b2), b\u2081 \u2264 b\u2082 \u2192 a \u2022 b\u2081 \u2264 a \u2022 b\u2082\na : \u03b1\nha\u271d : 0 \u2264 a\nb\u2081 b\u2082 : \u03b2\nh : b\u2081 \u2264 b\u2082\nha : 0 < a\n\u22a2 a \u2022 b\u2081 \u2264 a \u2022 b\u2082"}, {"tactic": "simp [\u2190 ha]", "annotated_tactic": ["simp [\u2190 ha]", []], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2080 : \u2200 (a : \u03b1), 0 < a \u2192 \u2200 (b\u2081 b\u2082 : \u03b2), b\u2081 \u2264 b\u2082 \u2192 a \u2022 b\u2081 \u2264 a \u2022 b\u2082\na : \u03b1\nha\u271d : 0 \u2264 a\nb\u2081 b\u2082 : \u03b2\nh : b\u2081 \u2264 b\u2082\nha : 0 = a\n\u22a2 a \u2022 b\u2081 \u2264 a \u2022 b\u2082", "state_after": "no goals"}, {"tactic": "exact h\u2080 _ ha _ _ h", "annotated_tactic": ["exact h\u2080 _ ha _ _ h", []], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d a\u2081 a\u2082 : \u03b1\nb b\u2081\u271d b\u2082\u271d : \u03b2\ninst\u271d\u2074 : Zero \u03b1\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : SMulWithZero \u03b1 \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2080 : \u2200 (a : \u03b1), 0 < a \u2192 \u2200 (b\u2081 b\u2082 : \u03b2), b\u2081 \u2264 b\u2082 \u2192 a \u2022 b\u2081 \u2264 a \u2022 b\u2082\na : \u03b1\nha\u271d : 0 \u2264 a\nb\u2081 b\u2082 : \u03b2\nh : b\u2081 \u2264 b\u2082\nha : 0 < a\n\u22a2 a \u2022 b\u2081 \u2264 a \u2022 b\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean", "full_name": "PowerSeries.smul_eq_C_mul", "start": [343, 1], "end": [345, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R\u27e6X\u27e7\na : R\n\u22a2 a \u2022 f = (C R) a * f", "state_after": "case h\nR : Type u_1\ninst\u271d : Semiring R\nf : R\u27e6X\u27e7\na : R\nn\u271d : \u2115\n\u22a2 (coeff R n\u271d) (a \u2022 f) = (coeff R n\u271d) ((C R) a * f)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\nR : Type u_1\ninst\u271d : Semiring R\nf : R\u27e6X\u27e7\na : R\nn\u271d : \u2115\n\u22a2 (coeff R n\u271d) (a \u2022 f) = (coeff R n\u271d) ((C R) a * f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/Quiver/Symmetric.lean", "full_name": "Quiver.Push.of_reverse", "start": [252, 1], "end": [254, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Vector.lean", "full_name": "Vector.toList_mk", "start": [243, 1], "end": [244, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/ByteArray.lean", "full_name": "ByteArray.set_set", "start": [61, 1], "end": [63, 36], "traced_tactics": [{"tactic": "simp [i.2]", "annotated_tactic": ["simp [i.2]", []], "state_before": "a : ByteArray\ni : Fin (size a)\nv v' : UInt8\n\u22a2 \u2191i < size (set a i v)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Index.lean", "full_name": "Subgroup.index_inf_ne_zero", "start": [427, 1], "end": [429, 35], "traced_tactics": [{"tactic": "rw [\u2190 relindex_top_right] at hH hK \u22a2", "annotated_tactic": ["rw [\u2190 <a>relindex_top_right</a>] at hH hK \u22a2", [{"full_name": "Subgroup.relindex_top_right", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Index.lean", "def_pos": [246, 9], "def_end_pos": [246, 27]}]], "state_before": "G : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nhH : index H \u2260 0\nhK : index K \u2260 0\n\u22a2 index (H \u2293 K) \u2260 0", "state_after": "G : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nhH : relindex H \u22a4 \u2260 0\nhK : relindex K \u22a4 \u2260 0\n\u22a2 relindex (H \u2293 K) \u22a4 \u2260 0"}, {"tactic": "exact relindex_inf_ne_zero hH hK", "annotated_tactic": ["exact <a>relindex_inf_ne_zero</a> hH hK", [{"full_name": "Subgroup.relindex_inf_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Index.lean", "def_pos": [417, 9], "def_end_pos": [417, 29]}]], "state_before": "G : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nhH : relindex H \u22a4 \u2260 0\nhK : relindex K \u22a4 \u2260 0\n\u22a2 relindex (H \u2293 K) \u22a4 \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Mathlib.Meta.NormNum.isNat_rpow_pos", "start": [979, 1], "end": [982, 30], "traced_tactics": [{"tactic": "rwa [pb.out, rpow_nat_cast]", "annotated_tactic": ["rwa [pb.out, <a>rpow_nat_cast</a>]", [{"full_name": "Real.rpow_nat_cast", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [70, 9], "def_end_pos": [70, 22]}]], "state_before": "a b : \u211d\nnb ne : \u2115\npb : IsNat b nb\npe' : IsNat (a ^ nb) ne\n\u22a2 IsNat (a ^ b) ne", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "full_name": "Real.sinh_log", "start": [114, 1], "end": [115, 36], "traced_tactics": [{"tactic": "rw [sinh_eq, exp_neg, exp_log hx]", "annotated_tactic": ["rw [<a>sinh_eq</a>, <a>exp_neg</a>, <a>exp_log</a> hx]", [{"full_name": "Real.sinh_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [1026, 16], "def_end_pos": [1026, 23]}, {"full_name": "Real.exp_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [850, 16], "def_end_pos": [850, 23]}, {"full_name": "Real.exp_log", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 16]}]], "state_before": "x\u271d y x : \u211d\nhx : 0 < x\n\u22a2 sinh (log x) = (x - x\u207b\u00b9) / 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Basic.lean", "full_name": "LinearMap.comp_sub", "start": [968, 1], "end": [970, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Semicontinuous.lean", "full_name": "upperSemicontinuousOn_iInf", "start": [1183, 1], "end": [1185, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.rescale_to_shell", "start": [1326, 1], "end": [1333, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.le_limsInf_of_le", "start": [525, 1], "end": [528, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/Basic.lean", "full_name": "ConnectedComponents.range_coe", "start": [1297, 1], "end": [1298, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Real.continuous_sinh", "start": [109, 1], "end": [110, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.subtypePreimage_symm_apply_coe_neg", "start": [715, 1], "end": [717, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "DoubleQuot.coe_quotQuotEquivQuotOfLE\u2090", "start": [972, 1], "end": [974, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Block.lean", "full_name": "Matrix.det_toSquareBlock_id", "start": [181, 1], "end": [183, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Infinite.exists_superset_card_eq", "start": [1144, 1], "end": [1153, 18], "traced_tactics": [{"tactic": "induction' n with n IH generalizing s", "annotated_tactic": ["induction' n with n IH generalizing s", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\ns : Finset \u03b1\nn : \u2115\nhn : s.card \u2264 n\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = n", "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\ns : Finset \u03b1\nhn : s.card \u2264 zero\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = zero\n\ncase succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n"}, {"tactic": "exact \u27e8s, subset_refl _, Nat.eq_zero_of_le_zero hn\u27e9", "annotated_tactic": ["exact \u27e8s, <a>subset_refl</a> _, <a>Nat.eq_zero_of_le_zero</a> hn\u27e9", [{"full_name": "subset_refl", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [627, 7], "def_end_pos": [627, 18]}, {"full_name": "Nat.eq_zero_of_le_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [308, 9], "def_end_pos": [308, 27]}]], "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\ns : Finset \u03b1\nhn : s.card \u2264 zero\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = zero", "state_after": "no goals"}, {"tactic": "rcases hn.eq_or_lt with hn' | hn'", "annotated_tactic": ["rcases hn.eq_or_lt with hn' | hn'", []], "state_before": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n", "state_after": "case succ.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card = succ n\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n\n\ncase succ.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card < succ n\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n"}, {"tactic": "obtain \u27e8t, hs, ht\u27e9 := IH _ (Nat.le_of_lt_succ hn')", "annotated_tactic": ["obtain \u27e8t, hs, ht\u27e9 := IH _ (<a>Nat.le_of_lt_succ</a> hn')", [{"full_name": "Nat.le_of_lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1697, 9], "def_end_pos": [1697, 26]}]], "state_before": "case succ.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card < succ n\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n", "state_after": "case succ.inr.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card < succ n\nt : Finset \u03b1\nhs : s \u2286 t\nht : t.card = n\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n"}, {"tactic": "obtain \u27e8x, hx\u27e9 := exists_not_mem_finset t", "annotated_tactic": ["obtain \u27e8x, hx\u27e9 := <a>exists_not_mem_finset</a> t", [{"full_name": "Infinite.exists_not_mem_finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [1033, 9], "def_end_pos": [1033, 30]}]], "state_before": "case succ.inr.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card < succ n\nt : Finset \u03b1\nhs : s \u2286 t\nht : t.card = n\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n", "state_after": "case succ.inr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card < succ n\nt : Finset \u03b1\nhs : s \u2286 t\nht : t.card = n\nx : \u03b1\nhx : x \u2209 t\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n"}, {"tactic": "refine' \u27e8Finset.cons x t hx, hs.trans (Finset.subset_cons _), _\u27e9", "annotated_tactic": ["refine' \u27e8<a>Finset.cons</a> x t hx, hs.trans (<a>Finset.subset_cons</a> _), _\u27e9", [{"full_name": "Finset.cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [872, 5], "def_end_pos": [872, 9]}, {"full_name": "Finset.subset_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [931, 9], "def_end_pos": [931, 20]}]], "state_before": "case succ.inr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card < succ n\nt : Finset \u03b1\nhs : s \u2286 t\nht : t.card = n\nx : \u03b1\nhx : x \u2209 t\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n", "state_after": "case succ.inr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card < succ n\nt : Finset \u03b1\nhs : s \u2286 t\nht : t.card = n\nx : \u03b1\nhx : x \u2209 t\n\u22a2 (cons x t hx).card = succ n"}, {"tactic": "simp [hx, ht]", "annotated_tactic": ["simp [hx, ht]", []], "state_before": "case succ.inr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card < succ n\nt : Finset \u03b1\nhs : s \u2286 t\nht : t.card = n\nx : \u03b1\nhx : x \u2209 t\n\u22a2 (cons x t hx).card = succ n", "state_after": "no goals"}, {"tactic": "exact \u27e8s, subset_refl _, hn'\u27e9", "annotated_tactic": ["exact \u27e8s, <a>subset_refl</a> _, hn'\u27e9", [{"full_name": "subset_refl", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [627, 7], "def_end_pos": [627, 18]}]], "state_before": "case succ.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Infinite \u03b1\nn : \u2115\nIH : \u2200 (s : Finset \u03b1), s.card \u2264 n \u2192 \u2203 t, s \u2286 t \u2227 t.card = n\ns : Finset \u03b1\nhn : s.card \u2264 succ n\nhn' : s.card = succ n\n\u22a2 \u2203 t, s \u2286 t \u2227 t.card = succ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/NNRat/Defs.lean", "full_name": "NNRat.coe_inj", "start": [74, 1], "end": [75, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.choose_property", "start": [3916, 1], "end": [3917, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "Inducing.continuousInv", "start": [410, 1], "end": [413, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/NullMeasurable.lean", "full_name": "Finset.nullMeasurableSet_biInter", "start": [391, 1], "end": [393, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/ToDFinsupp.lean", "full_name": "Finsupp.toDFinsupp_zero", "start": [151, 1], "end": [152, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/EqToHom.lean", "full_name": "CategoryTheory.Functor.congr_map", "start": [254, 1], "end": [254, 99], "traced_tactics": [{"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nX Y : C\nf g : X \u27f6 Y\nh : f = g\n\u22a2 F.map f = F.map g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "IsSquare.pow", "start": [137, 1], "end": [139, 44], "traced_tactics": [{"tactic": "rintro \u27e8a, rfl\u27e9", "annotated_tactic": ["rintro \u27e8a, rfl\u27e9", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Monoid \u03b1\nn\u271d : \u2115\na : \u03b1\nn : \u2115\n\u22a2 IsSquare a \u2192 IsSquare (a ^ n)", "state_after": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Monoid \u03b1\nn\u271d n : \u2115\na : \u03b1\n\u22a2 IsSquare ((a * a) ^ n)"}, {"tactic": "exact \u27e8a ^ n, (Commute.refl _).mul_pow _\u27e9", "annotated_tactic": ["exact \u27e8a ^ n, (<a>Commute.refl</a> _).<a>mul_pow</a> _\u27e9", [{"full_name": "Commute.refl", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [62, 19], "def_end_pos": [62, 23]}, {"full_name": "Commute.mul_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [125, 9], "def_end_pos": [125, 24]}]], "state_before": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Monoid \u03b1\nn\u271d n : \u2115\na : \u03b1\n\u22a2 IsSquare ((a * a) ^ n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean", "full_name": "ArithmeticFunction.intCoe_int", "start": [194, 1], "end": [195, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/BilinearMap.lean", "full_name": "LinearMap.map_sub\u2082", "start": [150, 1], "end": [151, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Congruence.lean", "full_name": "Con.eq", "start": [353, 11], "end": [354, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean", "full_name": "Ordinal.opow_le_iff_le_log", "start": [331, 1], "end": [336, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iUnion_congr_Prop", "start": [165, 1], "end": [167, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Exp.lean", "full_name": "Filter.Tendsto.cexp", "start": [89, 1], "end": [91, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.rotate_eq_rotate'", "start": [108, 1], "end": [113, 20], "traced_tactics": [{"tactic": "simp_all [length_eq_zero]", "annotated_tactic": ["simp_all [<a>length_eq_zero</a>]", [{"full_name": "List.length_eq_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [56, 9], "def_end_pos": [56, 23]}]], "state_before": "\u03b1 : Type u\nl : List \u03b1\nn : \u2115\nh : length l = 0\n\u22a2 rotate l n = rotate' l n", "state_after": "no goals"}, {"tactic": "rw [\u2190 rotate'_mod,\n    rotate'_eq_drop_append_take (le_of_lt (Nat.mod_lt _ (Nat.pos_of_ne_zero h)))]", "annotated_tactic": ["rw [\u2190 <a>rotate'_mod</a>,\n        <a>rotate'_eq_drop_append_take</a> (<a>le_of_lt</a> (<a>Nat.mod_lt</a> _ (<a>Nat.pos_of_ne_zero</a> h)))]", [{"full_name": "List.rotate'_mod", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [100, 9], "def_end_pos": [100, 20]}, {"full_name": "List.rotate'_eq_drop_append_take", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [65, 9], "def_end_pos": [65, 36]}, {"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}, {"full_name": "Nat.mod_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [123, 9], "def_end_pos": [123, 15]}, {"full_name": "Nat.pos_of_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [298, 19], "def_end_pos": [298, 33]}]], "state_before": "\u03b1 : Type u\nl : List \u03b1\nn : \u2115\nh : \u00aclength l = 0\n\u22a2 rotate l n = rotate' l n", "state_after": "\u03b1 : Type u\nl : List \u03b1\nn : \u2115\nh : \u00aclength l = 0\n\u22a2 rotate l n = drop (n % length l) l ++ take (n % length l) l"}, {"tactic": "simp [rotate]", "annotated_tactic": ["simp [<a>rotate</a>]", [{"full_name": "List.rotate", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1156, 15], "def_end_pos": [1156, 21]}]], "state_before": "\u03b1 : Type u\nl : List \u03b1\nn : \u2115\nh : \u00aclength l = 0\n\u22a2 rotate l n = drop (n % length l) l ++ take (n % length l) l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "OneHom.comp_assoc", "start": [955, 1], "end": [957, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/WithZero.lean", "full_name": "le_mul_inv_of_mul_le", "start": [142, 1], "end": [143, 48], "traced_tactics": [{"tactic": "simpa [h] using hab", "annotated_tactic": ["simpa [h] using hab", []], "state_before": "\u03b1 : Type u_1\na b c d x y z : \u03b1\ninst\u271d : LinearOrderedCommGroupWithZero \u03b1\nm n : \u2115\nh : c \u2260 0\nhab : a * c \u2264 b\n\u22a2 a * c \u2264 b * c\u207b\u00b9 * c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/EqToHom.lean", "full_name": "CategoryTheory.eqToHom_refl", "start": [50, 1], "end": [51, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Fin.lean", "full_name": "finSuccEquiv'_above", "start": [152, 1], "end": [154, 69], "traced_tactics": [{"tactic": "rw [\u2190 Fin.succAbove_of_le_castSucc _ _ h, finSuccEquiv'_succAbove]", "annotated_tactic": ["rw [\u2190 <a>Fin.succAbove_of_le_castSucc</a> _ _ h, <a>finSuccEquiv'_succAbove</a>]", [{"full_name": "Fin.succAbove_of_le_castSucc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/OrderHom.lean", "def_pos": [43, 9], "def_end_pos": [43, 33]}, {"full_name": "finSuccEquiv'_succAbove", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Fin.lean", "def_pos": [142, 9], "def_end_pos": [142, 32]}]], "state_before": "m\u271d n : \u2115\ni : Fin (n + 1)\nm : Fin n\nh : i \u2264 Fin.castSucc m\n\u22a2 (finSuccEquiv' i) (Fin.succ m) = some m", "state_after": "no goals"}]}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Test.lean", "full_name": "amc12b_2002_p2", "start": [1062, 1], "end": [1065, 73], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "x : \u2124\nh\u2080 : x = 4\n\u22a2 (3 * x - 2) * (4 * x + 1) - (3 * x - 2) * (4 * x) + 1 = 11", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Polynomial.lean", "full_name": "Polynomial.continuousAt", "start": [61, 11], "end": [62, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.span.loop_eq_take_drop", "start": [3581, 1], "end": [3585, 90], "traced_tactics": [{"tactic": "simp [span.loop, takeWhile, dropWhile]", "annotated_tactic": ["simp [<a>span.loop</a>, <a>takeWhile</a>, <a>dropWhile</a>]", [{"full_name": "List.span.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [466, 17], "def_end_pos": [466, 21]}, {"full_name": "List.takeWhile", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [544, 5], "def_end_pos": [544, 14]}, {"full_name": "List.dropWhile", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [324, 5], "def_end_pos": [324, 14]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082\u271d : List \u03b1\np : \u03b1 \u2192 Bool\nl\u2082 : List \u03b1\n\u22a2 loop p [] l\u2082 = (reverse l\u2082 ++ takeWhile p [], dropWhile p [])", "state_after": "no goals"}, {"tactic": "cases hp : p a <;> simp [hp, span.loop, span.loop_eq_take_drop, takeWhile, dropWhile]", "annotated_tactic": ["cases hp : p a <;> simp [hp, <a>span.loop</a>, span.loop_eq_take_drop, <a>takeWhile</a>, <a>dropWhile</a>]", [{"full_name": "List.span.loop", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [466, 17], "def_end_pos": [466, 21]}, {"full_name": "List.takeWhile", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [544, 5], "def_end_pos": [544, 14]}, {"full_name": "List.dropWhile", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [324, 5], "def_end_pos": [324, 14]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082\u271d : List \u03b1\np : \u03b1 \u2192 Bool\na : \u03b1\nl l\u2082 : List \u03b1\n\u22a2 loop p (a :: l) l\u2082 = (reverse l\u2082 ++ takeWhile p (a :: l), dropWhile p (a :: l))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Strict.lean", "full_name": "IsOpen.strictConvex_iff", "start": [118, 1], "end": [119, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "sphere_prod", "start": [1659, 1], "end": [1669, 30], "traced_tactics": [{"tactic": "obtain hr | rfl | hr := lt_trichotomy r 0", "annotated_tactic": ["obtain hr | rfl | hr := <a>lt_trichotomy</a> r 0", [{"full_name": "lt_trichotomy", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [305, 9], "def_end_pos": [305, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\n\u22a2 sphere x r = sphere x.1 r \u00d7\u02e2 closedBall x.2 r \u222a closedBall x.1 r \u00d7\u02e2 sphere x.2 r", "state_after": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : r < 0\n\u22a2 sphere x r = sphere x.1 r \u00d7\u02e2 closedBall x.2 r \u222a closedBall x.1 r \u00d7\u02e2 sphere x.2 r\n\ncase inr.inl\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\n\u22a2 sphere x 0 = sphere x.1 0 \u00d7\u02e2 closedBall x.2 0 \u222a closedBall x.1 0 \u00d7\u02e2 sphere x.2 0\n\ncase inr.inr\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\n\u22a2 sphere x r = sphere x.1 r \u00d7\u02e2 closedBall x.2 r \u222a closedBall x.1 r \u00d7\u02e2 sphere x.2 r"}, {"tactic": "simp [hr]", "annotated_tactic": ["simp [hr]", []], "state_before": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : r < 0\n\u22a2 sphere x r = sphere x.1 r \u00d7\u02e2 closedBall x.2 r \u222a closedBall x.1 r \u00d7\u02e2 sphere x.2 r", "state_after": "no goals"}, {"tactic": "cases x", "annotated_tactic": ["cases x", []], "state_before": "case inr.inl\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\n\u22a2 sphere x 0 = sphere x.1 0 \u00d7\u02e2 closedBall x.2 0 \u222a closedBall x.1 0 \u00d7\u02e2 sphere x.2 0", "state_after": "case inr.inl.mk\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nfst\u271d : \u03b1\nsnd\u271d : \u03b2\n\u22a2 sphere (fst\u271d, snd\u271d) 0 =\n    sphere (fst\u271d, snd\u271d).1 0 \u00d7\u02e2 closedBall (fst\u271d, snd\u271d).2 0 \u222a closedBall (fst\u271d, snd\u271d).1 0 \u00d7\u02e2 sphere (fst\u271d, snd\u271d).2 0"}, {"tactic": "simp_rw [\u2190 closedBall_eq_sphere_of_nonpos le_rfl, union_self, closedBall_prod_same]", "annotated_tactic": ["simp_rw [\u2190 <a>closedBall_eq_sphere_of_nonpos</a> <a>le_rfl</a>, <a>union_self</a>, <a>closedBall_prod_same</a>]", [{"full_name": "Metric.closedBall_eq_sphere_of_nonpos", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [522, 9], "def_end_pos": [522, 39]}, {"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}, {"full_name": "Set.union_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [742, 9], "def_end_pos": [742, 19]}, {"full_name": "closedBall_prod_same", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1654, 9], "def_end_pos": [1654, 29]}]], "state_before": "case inr.inl.mk\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nfst\u271d : \u03b1\nsnd\u271d : \u03b2\n\u22a2 sphere (fst\u271d, snd\u271d) 0 =\n    sphere (fst\u271d, snd\u271d).1 0 \u00d7\u02e2 closedBall (fst\u271d, snd\u271d).2 0 \u222a closedBall (fst\u271d, snd\u271d).1 0 \u00d7\u02e2 sphere (fst\u271d, snd\u271d).2 0", "state_after": "no goals"}, {"tactic": "ext \u27e8x', y'\u27e9", "annotated_tactic": ["ext \u27e8x', y'\u27e9", []], "state_before": "case inr.inr\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\n\u22a2 sphere x r = sphere x.1 r \u00d7\u02e2 closedBall x.2 r \u222a closedBall x.1 r \u00d7\u02e2 sphere x.2 r", "state_after": "case inr.inr.h.mk\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\nx' : \u03b1\ny' : \u03b2\n\u22a2 (x', y') \u2208 sphere x r \u2194 (x', y') \u2208 sphere x.1 r \u00d7\u02e2 closedBall x.2 r \u222a closedBall x.1 r \u00d7\u02e2 sphere x.2 r"}, {"tactic": "simp_rw [Set.mem_union, Set.mem_prod, Metric.mem_closedBall, Metric.mem_sphere, Prod.dist_eq,\n  max_eq_iff]", "annotated_tactic": ["simp_rw [<a>Set.mem_union</a>, <a>Set.mem_prod</a>, <a>Metric.mem_closedBall</a>, <a>Metric.mem_sphere</a>, <a>Prod.dist_eq</a>,\n      <a>max_eq_iff</a>]", [{"full_name": "Set.mem_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 18]}, {"full_name": "Set.mem_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [207, 9], "def_end_pos": [207, 17]}, {"full_name": "Metric.mem_closedBall", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [470, 17], "def_end_pos": [470, 31]}, {"full_name": "Metric.mem_sphere", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [480, 17], "def_end_pos": [480, 27]}, {"full_name": "Prod.dist_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1637, 9], "def_end_pos": [1637, 21]}, {"full_name": "max_eq_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/MinMax.lean", "def_pos": [187, 9], "def_end_pos": [187, 19]}]], "state_before": "case inr.inr.h.mk\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\nx' : \u03b1\ny' : \u03b2\n\u22a2 (x', y') \u2208 sphere x r \u2194 (x', y') \u2208 sphere x.1 r \u00d7\u02e2 closedBall x.2 r \u222a closedBall x.1 r \u00d7\u02e2 sphere x.2 r", "state_after": "case inr.inr.h.mk\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\nx' : \u03b1\ny' : \u03b2\n\u22a2 dist x' x.1 = r \u2227 dist y' x.2 \u2264 dist x' x.1 \u2228 dist y' x.2 = r \u2227 dist x' x.1 \u2264 dist y' x.2 \u2194\n    dist x' x.1 = r \u2227 dist y' x.2 \u2264 r \u2228 dist x' x.1 \u2264 r \u2227 dist y' x.2 = r"}, {"tactic": "refine' or_congr (and_congr_right _) (and_comm.trans (and_congr_left _))", "annotated_tactic": ["refine' <a>or_congr</a> (<a>and_congr_right</a> _) (and_comm.trans (<a>and_congr_left</a> _))", [{"full_name": "or_congr", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [62, 9], "def_end_pos": [62, 17]}, {"full_name": "and_congr_right", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [130, 9], "def_end_pos": [130, 24]}, {"full_name": "and_congr_left", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [133, 9], "def_end_pos": [133, 23]}]], "state_before": "case inr.inr.h.mk\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\nx' : \u03b1\ny' : \u03b2\n\u22a2 dist x' x.1 = r \u2227 dist y' x.2 \u2264 dist x' x.1 \u2228 dist y' x.2 = r \u2227 dist x' x.1 \u2264 dist y' x.2 \u2194\n    dist x' x.1 = r \u2227 dist y' x.2 \u2264 r \u2228 dist x' x.1 \u2264 r \u2227 dist y' x.2 = r", "state_after": "case inr.inr.h.mk.refine'_1\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\nx' : \u03b1\ny' : \u03b2\n\u22a2 dist x' x.1 = r \u2192 (dist y' x.2 \u2264 dist x' x.1 \u2194 dist y' x.2 \u2264 r)\n\ncase inr.inr.h.mk.refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\nx' : \u03b1\ny' : \u03b2\n\u22a2 dist y' x.2 = r \u2192 (dist x' x.1 \u2264 dist y' x.2 \u2194 dist x' x.1 \u2264 r)"}, {"tactic": "all_goals rintro rfl; rfl", "annotated_tactic": ["all_goals rintro rfl; rfl", []], "state_before": "case inr.inr.h.mk.refine'_1\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\nx' : \u03b1\ny' : \u03b2\n\u22a2 dist x' x.1 = r \u2192 (dist y' x.2 \u2264 dist x' x.1 \u2194 dist y' x.2 \u2264 r)\n\ncase inr.inr.h.mk.refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\nx' : \u03b1\ny' : \u03b2\n\u22a2 dist y' x.2 = r \u2192 (dist x' x.1 \u2264 dist y' x.2 \u2194 dist x' x.1 \u2264 r)", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "case inr.inr.h.mk.refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nr : \u211d\nhr : 0 < r\nx' : \u03b1\ny' : \u03b2\n\u22a2 dist y' x.2 = r \u2192 (dist x' x.1 \u2264 dist y' x.2 \u2194 dist x' x.1 \u2264 r)", "state_after": "case inr.inr.h.mk.refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nx' : \u03b1\ny' : \u03b2\nhr : 0 < dist y' x.2\n\u22a2 dist x' x.1 \u2264 dist y' x.2 \u2194 dist x' x.1 \u2264 dist y' x.2"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case inr.inr.h.mk.refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx : \u03b1 \u00d7 \u03b2\nx' : \u03b1\ny' : \u03b2\nhr : 0 < dist y' x.2\n\u22a2 dist x' x.1 \u2264 dist y' x.2 \u2194 dist x' x.1 \u2264 dist y' x.2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "MonoidHom.map_neg_one", "start": [514, 1], "end": [515, 84], "traced_tactics": [{"tactic": "rw [\u2190 map_pow, neg_one_sq, map_one]", "annotated_tactic": ["rw [\u2190 <a>map_pow</a>, <a>neg_one_sq</a>, <a>map_one</a>]", [{"full_name": "map_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [469, 9], "def_end_pos": [469, 16]}, {"full_name": "neg_one_sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [145, 9], "def_end_pos": [145, 19]}, {"full_name": "map_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [203, 9], "def_end_pos": [203, 16]}]], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : LinearOrder M\ninst\u271d : CovariantClass M M (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nf : R \u2192* M\n\u22a2 f (-1) ^ Nat.succ 1 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Basic.lean", "full_name": "Real.cauchy_add", "start": [151, 1], "end": [152, 58], "traced_tactics": [{"tactic": "rw [add_def]", "annotated_tactic": ["rw [<a>add_def</a>]", [{"full_name": "_private.\u00ab.lake\u00bb.packages.mathlib.Mathlib.Data.Real.Basic.0.Real.add_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Basic.lean", "def_pos": [1, 1], "def_end_pos": [1, 1]}]], "state_before": "x y : \u211d\na b : Cauchy abs\n\u22a2 (Real.add { cauchy := a } { cauchy := b }).cauchy = { cauchy := a }.cauchy + { cauchy := b }.cauchy", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Bijective.existsUnique", "start": [256, 11], "end": [258, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Finite.lean", "full_name": "PartENat.one_lt_card_iff_nontrivial", "start": [312, 1], "end": [316, 42], "traced_tactics": [{"tactic": "rw [\u2190 Cardinal.one_lt_iff_nontrivial]", "annotated_tactic": ["rw [\u2190 <a>Cardinal.one_lt_iff_nontrivial</a>]", [{"full_name": "Cardinal.one_lt_iff_nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [749, 9], "def_end_pos": [749, 30]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\n\u22a2 1 < card \u03b1 \u2194 Nontrivial \u03b1", "state_after": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\n\u22a2 1 < card \u03b1 \u2194 1 < #\u03b1"}, {"tactic": "conv_rhs => rw [\u2190 Nat.cast_one]", "annotated_tactic": ["conv_rhs => rw [\u2190 <a>Nat.cast_one</a>]", [{"full_name": "Nat.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [150, 9], "def_end_pos": [150, 17]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\n\u22a2 1 < card \u03b1 \u2194 1 < #\u03b1", "state_after": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\n\u22a2 1 < card \u03b1 \u2194 \u21911 < #\u03b1"}, {"tactic": "rw [\u2190 natCast_lt_toPartENat_iff]", "annotated_tactic": ["rw [\u2190 <a>natCast_lt_toPartENat_iff</a>]", [{"full_name": "Cardinal.natCast_lt_toPartENat_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Finite.lean", "def_pos": [287, 9], "def_end_pos": [287, 50]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\n\u22a2 1 < card \u03b1 \u2194 \u21911 < #\u03b1", "state_after": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\n\u22a2 1 < card \u03b1 \u2194 \u21911 < toPartENat #\u03b1"}, {"tactic": "simp only [PartENat.card, Nat.cast_one]", "annotated_tactic": ["simp only [<a>PartENat.card</a>, <a>Nat.cast_one</a>]", [{"full_name": "PartENat.card", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Finite.lean", "def_pos": [220, 5], "def_end_pos": [220, 9]}, {"full_name": "Nat.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [150, 9], "def_end_pos": [150, 17]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b1 : Type u_3\n\u22a2 1 < card \u03b1 \u2194 \u21911 < toPartENat #\u03b1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/RBMap/WF.lean", "full_name": "Std.RBNode.balance2_All", "start": [75, 9], "end": [77, 61], "traced_tactics": [{"tactic": "unfold balance2", "annotated_tactic": ["unfold <a>balance2</a>", [{"full_name": "Std.RBNode.balance2", "def_path": ".lake/packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [265, 15], "def_end_pos": [265, 23]}]], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 All p (balance2 l v r) \u2194 p v \u2227 All p l \u2227 All p r", "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 All p\n      (match l, v, r with\n      | a, x, node red (node red b y c) z d => node red (node black a x b) y (node black c z d)\n      | a, x, node red b y (node red c z d) => node red (node black a x b) y (node black c z d)\n      | a, x, b => node black a x b) \u2194\n    p v \u2227 All p l \u2227 All p r"}, {"tactic": "split <;> simp [and_assoc, and_left_comm]", "annotated_tactic": ["split <;> simp [<a>and_assoc</a>, <a>and_left_comm</a>]", [{"full_name": "and_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [136, 9], "def_end_pos": [136, 18]}, {"full_name": "and_left_comm", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [41, 9], "def_end_pos": [41, 22]}]], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 All p\n      (match l, v, r with\n      | a, x, node red (node red b y c) z d => node red (node black a x b) y (node black c z d)\n      | a, x, node red b y (node red c z d) => node red (node black a x b) y (node black c z d)\n      | a, x, b => node black a x b) \u2194\n    p v \u2227 All p l \u2227 All p r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/EReal.lean", "full_name": "EReal.zero_ne_top", "start": [337, 1], "end": [338, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Archimedean.lean", "full_name": "exists_rat_near", "start": [341, 1], "end": [344, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/Pointwise.lean", "full_name": "Set.union_star", "start": [80, 1], "end": [80, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean", "full_name": "minpoly.IsIntegrallyClosed.degree_le_of_ne_zero", "start": [114, 1], "end": [118, 74], "traced_tactics": [{"tactic": "rw [degree_eq_natDegree (minpoly.ne_zero hs), degree_eq_natDegree hp0]", "annotated_tactic": ["rw [<a>degree_eq_natDegree</a> (<a>minpoly.ne_zero</a> hs), <a>degree_eq_natDegree</a> hp0]", [{"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}, {"full_name": "minpoly.ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 16]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}]], "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\ns : S\nhs : IsIntegral R s\np : R[X]\nhp0 : p \u2260 0\nhp : (Polynomial.aeval s) p = 0\n\u22a2 degree (minpoly R s) \u2264 degree p", "state_after": "R : Type u_1\nS : Type u_2\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\ns : S\nhs : IsIntegral R s\np : R[X]\nhp0 : p \u2260 0\nhp : (Polynomial.aeval s) p = 0\n\u22a2 \u2191(natDegree (minpoly R s)) \u2264 \u2191(natDegree p)"}, {"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\ns : S\nhs : IsIntegral R s\np : R[X]\nhp0 : p \u2260 0\nhp : (Polynomial.aeval s) p = 0\n\u22a2 \u2191(natDegree (minpoly R s)) \u2264 \u2191(natDegree p)", "state_after": "R : Type u_1\nS : Type u_2\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\ns : S\nhs : IsIntegral R s\np : R[X]\nhp0 : p \u2260 0\nhp : (Polynomial.aeval s) p = 0\n\u22a2 natDegree (minpoly R s) \u2264 natDegree p"}, {"tactic": "exact natDegree_le_of_dvd ((isIntegrallyClosed_dvd_iff hs _).mp hp) hp0", "annotated_tactic": ["exact <a>natDegree_le_of_dvd</a> ((<a>isIntegrallyClosed_dvd_iff</a> hs _).<a>mp</a> hp) hp0", [{"full_name": "Polynomial.natDegree_le_of_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [172, 9], "def_end_pos": [172, 28]}, {"full_name": "minpoly.isIntegrallyClosed_dvd_iff", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean", "def_pos": [95, 9], "def_end_pos": [95, 35]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing S\ninst\u271d\u2074 : IsDomain R\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\ns : S\nhs : IsIntegral R s\np : R[X]\nhp0 : p \u2260 0\nhp : (Polynomial.aeval s) p = 0\n\u22a2 natDegree (minpoly R s) \u2264 natDegree p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "MonoidHom.eqLocus_same", "start": [2965, 1], "end": [2966, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Sigma.lean", "full_name": "Set.sigma_diff_sigma", "start": [274, 1], "end": [276, 89], "traced_tactics": [{"tactic": "by_cases h\u2081 : x.1 \u2208 s\u2081 <;> by_cases h\u2082 : x.2 \u2208 t\u2081 x.1 <;> simp [*, \u2190 imp_iff_or_not]", "annotated_tactic": ["by_cases h\u2081 : x.1 \u2208 s\u2081 <;> by_cases h\u2082 : x.2 \u2208 t\u2081 x.1 <;> simp [*, \u2190 <a>imp_iff_or_not</a>]", [{"full_name": "imp_iff_or_not", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [390, 9], "def_end_pos": [390, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : \u03b9 \u2192 Type u_3\n\u03b2\u271d\u00b2 : \u03b9 \u2192 Type u_4\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\nu : Set ((i : \u03b9) \u00d7 \u03b1 i)\nx\u271d : (i : \u03b9) \u00d7 \u03b1 i\ni j : \u03b9\na : \u03b1 i\n\u03b2\u271d\u00b9 : Type u_5\ninst\u271d : CompleteLattice \u03b2\u271d\u00b9\n\u03b2\u271d : Type u_6\n\u03b2 : \u03b9 \u2192 Type u_7\nx : (i : \u03b9) \u00d7 \u03b1 i\n\u22a2 x \u2208 Set.sigma s\u2081 t\u2081 \\ Set.sigma s\u2082 t\u2082 \u2194 x \u2208 Set.sigma s\u2081 (t\u2081 \\ t\u2082) \u222a Set.sigma (s\u2081 \\ s\u2082) t\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.floor_nat_add", "start": [802, 1], "end": [803, 39], "traced_tactics": [{"tactic": "rw [\u2190 Int.cast_ofNat, floor_int_add]", "annotated_tactic": ["rw [\u2190 <a>Int.cast_ofNat</a>, <a>floor_int_add</a>]", [{"full_name": "Int.cast_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}, {"full_name": "Int.floor_int_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [787, 9], "def_end_pos": [787, 22]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na\u271d : \u03b1\nn : \u2115\na : \u03b1\n\u22a2 \u230a\u2191n + a\u230b = \u2191n + \u230aa\u230b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "List.finite_toSet", "start": [574, 1], "end": [575, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Relation.lean", "full_name": "Relation.TransGen.head'_iff", "start": [455, 1], "end": [461, 31], "traced_tactics": [{"tactic": "refine' \u27e8fun h \u21a6 _, fun \u27e8b, hab, hbc\u27e9 \u21a6 head' hab hbc\u27e9", "annotated_tactic": ["refine' \u27e8fun h \u21a6 _, fun \u27e8b, hab, hbc\u27e9 \u21a6 <a>head'</a> hab hbc\u27e9", [{"full_name": "Relation.TransGen.head'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Relation.lean", "def_pos": [402, 9], "def_end_pos": [402, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b c d : \u03b1\n\u22a2 TransGen r a c \u2194 \u2203 b, r a b \u2227 ReflTransGen r b c", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b c d : \u03b1\nh : TransGen r a c\n\u22a2 \u2203 b, r a b \u2227 ReflTransGen r b c"}, {"tactic": "induction h with\n| single hac => exact \u27e8_, hac, by rfl\u27e9\n| tail _ hbc IH =>\nrcases IH with \u27e8d, had, hdb\u27e9\nexact \u27e8_, had, hdb.tail hbc\u27e9", "annotated_tactic": ["induction h with\n  | <a>single</a> hac => exact \u27e8_, hac, by rfl\u27e9\n  | <a>tail</a> _ hbc IH =>\n  rcases IH with \u27e8d, had, hdb\u27e9\n  exact \u27e8_, had, hdb.tail hbc\u27e9", [{"full_name": "Relation.TransGen.single", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Relation.lean", "def_pos": [269, 5], "def_end_pos": [269, 11]}, {"full_name": "Relation.TransGen.tail", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Relation.lean", "def_pos": [270, 5], "def_end_pos": [270, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b c d : \u03b1\nh : TransGen r a c\n\u22a2 \u2203 b, r a b \u2227 ReflTransGen r b c", "state_after": "no goals"}, {"tactic": "exact \u27e8_, hac, by rfl\u27e9", "annotated_tactic": ["exact \u27e8_, hac, by rfl\u27e9", []], "state_before": "case single\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b c d b\u271d : \u03b1\nhac : r a b\u271d\n\u22a2 \u2203 b, r a b \u2227 ReflTransGen r b b\u271d", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b c d b\u271d : \u03b1\nhac : r a b\u271d\n\u22a2 ReflTransGen r b\u271d b\u271d", "state_after": "no goals"}, {"tactic": "rcases IH with \u27e8d, had, hdb\u27e9", "annotated_tactic": ["rcases IH with \u27e8d, had, hdb\u27e9", []], "state_before": "case tail\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b c d b\u271d c\u271d : \u03b1\na\u271d : TransGen r a b\u271d\nhbc : r b\u271d c\u271d\nIH : \u2203 b, r a b \u2227 ReflTransGen r b b\u271d\n\u22a2 \u2203 b, r a b \u2227 ReflTransGen r b c\u271d", "state_after": "case tail.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b c d\u271d b\u271d c\u271d : \u03b1\na\u271d : TransGen r a b\u271d\nhbc : r b\u271d c\u271d\nd : \u03b1\nhad : r a d\nhdb : ReflTransGen r d b\u271d\n\u22a2 \u2203 b, r a b \u2227 ReflTransGen r b c\u271d"}, {"tactic": "exact \u27e8_, had, hdb.tail hbc\u27e9", "annotated_tactic": ["exact \u27e8_, had, hdb.tail hbc\u27e9", []], "state_before": "case tail.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b c d\u271d b\u271d c\u271d : \u03b1\na\u271d : TransGen r a b\u271d\nhbc : r b\u271d c\u271d\nd : \u03b1\nhad : r a d\nhdb : ReflTransGen r d b\u271d\n\u22a2 \u2203 b, r a b \u2227 ReflTransGen r b c\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.disjoint_of_disjoint_cons_right", "start": [1654, 1], "end": [1655, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_sub_C", "start": [1385, 1], "end": [1386, 48], "traced_tactics": [{"tactic": "rw [sub_eq_add_neg, \u2190 C_neg, degree_add_C hp]", "annotated_tactic": ["rw [<a>sub_eq_add_neg</a>, \u2190 <a>C_neg</a>, <a>degree_add_C</a> hp]", [{"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}, {"full_name": "Polynomial.C_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1231, 9], "def_end_pos": [1231, 14]}, {"full_name": "Polynomial.degree_add_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [735, 9], "def_end_pos": [735, 21]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Ring R\np q : R[X]\nhp : 0 < degree p\n\u22a2 degree (p - C a) = degree p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/AdjoinRoot.lean", "full_name": "AdjoinRoot.lift_root", "start": [287, 1], "end": [287, 78], "traced_tactics": [{"tactic": "rw [root, lift_mk, eval\u2082_X]", "annotated_tactic": ["rw [<a>root</a>, <a>lift_mk</a>, <a>eval\u2082_X</a>]", [{"full_name": "AdjoinRoot.root", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/AdjoinRoot.lean", "def_pos": [169, 5], "def_end_pos": [169, 9]}, {"full_name": "AdjoinRoot.lift_mk", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/AdjoinRoot.lean", "def_pos": [282, 9], "def_end_pos": [282, 16]}, {"full_name": "Polynomial.eval\u2082_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [73, 9], "def_end_pos": [73, 16]}]], "state_before": "R : Type u\nS : Type v\nK : Type w\ninst\u271d\u00b9 : CommRing R\nf : R[X]\ninst\u271d : CommRing S\ni : R \u2192+* S\na : S\nh : eval\u2082 i a f = 0\n\u22a2 (lift i a h) (root f) = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.exists_maximal_wrt", "start": [1628, 1], "end": [1645, 27], "traced_tactics": [{"tactic": "exact absurd hs not_nonempty_empty", "annotated_tactic": ["exact <a>absurd</a> hs <a>not_nonempty_empty</a>", [{"full_name": "absurd", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [246, 21], "def_end_pos": [246, 27]}, {"full_name": "Set.not_nonempty_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [600, 9], "def_end_pos": [600, 27]}]], "state_before": "case H0\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nhs : Set.Nonempty \u2205\n\u22a2 \u2203 a \u2208 \u2205, \u2200 a' \u2208 \u2205, f a \u2264 f a' \u2192 f a = f a'", "state_after": "no goals"}, {"tactic": "rcases s.eq_empty_or_nonempty with h | h", "annotated_tactic": ["rcases s.eq_empty_or_nonempty with h | h", []], "state_before": "case H1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d : Set.Finite s\nih : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'", "state_after": "case H1.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d : Set.Finite s\nih : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh : s = \u2205\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'\n\ncase H1.inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d : Set.Finite s\nih : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh : Set.Nonempty s\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'"}, {"tactic": "rcases ih h with \u27e8b, hb, ih\u27e9", "annotated_tactic": ["rcases ih h with \u27e8b, hb, ih\u27e9", []], "state_before": "case H1.inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d : Set.Finite s\nih : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh : Set.Nonempty s\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'", "state_after": "case H1.inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'"}, {"tactic": "by_cases h : f b \u2264 f a", "annotated_tactic": ["by_cases h : f b \u2264 f a", []], "state_before": "case H1.inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'", "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : f b \u2264 f a\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'\n\ncase neg\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : \u00acf b \u2264 f a\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'"}, {"tactic": "use a", "annotated_tactic": ["use a", []], "state_before": "case H1.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d : Set.Finite s\nih : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh : s = \u2205\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d : Set.Finite s\nih : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh : s = \u2205\n\u22a2 a \u2208 insert a s \u2227 \u2200 a' \u2208 insert a s, f a \u2264 f a' \u2192 f a = f a'"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d : Set.Finite s\nih : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh : s = \u2205\n\u22a2 a \u2208 insert a s \u2227 \u2200 a' \u2208 insert a s, f a \u2264 f a' \u2192 f a = f a'", "state_after": "no goals"}, {"tactic": "refine' \u27e8a, Set.mem_insert _ _, fun c hc hac => le_antisymm hac _\u27e9", "annotated_tactic": ["refine' \u27e8a, <a>Set.mem_insert</a> _ _, fun c hc hac => <a>le_antisymm</a> hac _\u27e9", [{"full_name": "Set.mem_insert", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1096, 9], "def_end_pos": [1096, 19]}, {"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : f b \u2264 f a\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'", "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : f b \u2264 f a\nc : \u03b1\nhc : c \u2208 insert a s\nhac : f a \u2264 f c\n\u22a2 f c \u2264 f a"}, {"tactic": "rcases Set.mem_insert_iff.1 hc with (rfl | hcs)", "annotated_tactic": ["rcases <a>Set.mem_insert_iff</a>.1 hc with (rfl | hcs)", [{"full_name": "Set.mem_insert_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1117, 9], "def_end_pos": [1117, 23]}]], "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : f b \u2264 f a\nc : \u03b1\nhc : c \u2208 insert a s\nhac : f a \u2264 f c\n\u22a2 f c \u2264 f a", "state_after": "case pos.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d s : Set \u03b1\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nc : \u03b1\nhis : c \u2209 s\nhs : Set.Nonempty (insert c s)\nh : f b \u2264 f c\nhc : c \u2208 insert c s\nhac : f c \u2264 f c\n\u22a2 f c \u2264 f c\n\ncase pos.inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : f b \u2264 f a\nc : \u03b1\nhc : c \u2208 insert a s\nhac : f a \u2264 f c\nhcs : c \u2208 s\n\u22a2 f c \u2264 f a"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case pos.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d s : Set \u03b1\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nc : \u03b1\nhis : c \u2209 s\nhs : Set.Nonempty (insert c s)\nh : f b \u2264 f c\nhc : c \u2208 insert c s\nhac : f c \u2264 f c\n\u22a2 f c \u2264 f c", "state_after": "no goals"}, {"tactic": "rwa [\u2190 ih c hcs (le_trans h hac)]", "annotated_tactic": ["rwa [\u2190 ih c hcs (<a>le_trans</a> h hac)]", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}]], "state_before": "case pos.inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : f b \u2264 f a\nc : \u03b1\nhc : c \u2208 insert a s\nhac : f a \u2264 f c\nhcs : c \u2208 s\n\u22a2 f c \u2264 f a", "state_after": "no goals"}, {"tactic": "refine' \u27e8b, Set.mem_insert_of_mem _ hb, fun c hc hbc => _\u27e9", "annotated_tactic": ["refine' \u27e8b, <a>Set.mem_insert_of_mem</a> _ hb, fun c hc hbc => _\u27e9", [{"full_name": "Set.mem_insert_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1100, 9], "def_end_pos": [1100, 26]}]], "state_before": "case neg\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : \u00acf b \u2264 f a\n\u22a2 \u2203 a_1 \u2208 insert a s, \u2200 a' \u2208 insert a s, f a_1 \u2264 f a' \u2192 f a_1 = f a'", "state_after": "case neg\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : \u00acf b \u2264 f a\nc : \u03b1\nhc : c \u2208 insert a s\nhbc : f b \u2264 f c\n\u22a2 f b = f c"}, {"tactic": "rcases Set.mem_insert_iff.1 hc with (rfl | hcs)", "annotated_tactic": ["rcases <a>Set.mem_insert_iff</a>.1 hc with (rfl | hcs)", [{"full_name": "Set.mem_insert_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1117, 9], "def_end_pos": [1117, 23]}]], "state_before": "case neg\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : \u00acf b \u2264 f a\nc : \u03b1\nhc : c \u2208 insert a s\nhbc : f b \u2264 f c\n\u22a2 f b = f c", "state_after": "case neg.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d s : Set \u03b1\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nc : \u03b1\nhbc : f b \u2264 f c\nhis : c \u2209 s\nhs : Set.Nonempty (insert c s)\nh : \u00acf b \u2264 f c\nhc : c \u2208 insert c s\n\u22a2 f b = f c\n\ncase neg.inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : \u00acf b \u2264 f a\nc : \u03b1\nhc : c \u2208 insert a s\nhbc : f b \u2264 f c\nhcs : c \u2208 s\n\u22a2 f b = f c"}, {"tactic": "exact (h hbc).elim", "annotated_tactic": ["exact (h hbc).<a>elim</a>", [{"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}]], "state_before": "case neg.inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d s : Set \u03b1\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nc : \u03b1\nhbc : f b \u2264 f c\nhis : c \u2209 s\nhs : Set.Nonempty (insert c s)\nh : \u00acf b \u2264 f c\nhc : c \u2208 insert c s\n\u22a2 f b = f c", "state_after": "no goals"}, {"tactic": "exact ih c hcs hbc", "annotated_tactic": ["exact ih c hcs hbc", []], "state_before": "case neg.inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns\u271d\u00b9 t : Set \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns\u271d : Set \u03b1\na : \u03b1\ns : Set \u03b1\nhis : a \u2209 s\nh\u271d\u00b9 : Set.Finite s\nih\u271d : Set.Nonempty s \u2192 \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'\nhs : Set.Nonempty (insert a s)\nh\u271d : Set.Nonempty s\nb : \u03b1\nhb : b \u2208 s\nih : \u2200 a' \u2208 s, f b \u2264 f a' \u2192 f b = f a'\nh : \u00acf b \u2264 f a\nc : \u03b1\nhc : c \u2208 insert a s\nhbc : f b \u2264 f c\nhcs : c \u2208 s\n\u22a2 f b = f c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/OrdConnected.lean", "full_name": "Set.dual_ordConnected", "start": [278, 1], "end": [279, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/ModEq.lean", "full_name": "Nat.ModEq.add_left_cancel", "start": [161, 11], "end": [166, 23], "traced_tactics": [{"tactic": "simp only [modEq_iff_dvd, Int.ofNat_add] at *", "annotated_tactic": ["simp only [<a>modEq_iff_dvd</a>, <a>Int.ofNat_add</a>] at *", [{"full_name": "Nat.modEq_iff_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/ModEq.lean", "def_pos": [89, 9], "def_end_pos": [89, 22]}, {"full_name": "Int.ofNat_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean", "def_pos": [25, 22], "def_end_pos": [25, 31]}]], "state_before": "m n a b c d : \u2115\nh\u2081 : a \u2261 b [MOD n]\nh\u2082 : a + c \u2261 b + d [MOD n]\n\u22a2 c \u2261 d [MOD n]", "state_after": "m n a b c d : \u2115\nh\u2081 : \u2191n \u2223 \u2191b - \u2191a\nh\u2082 : \u2191n \u2223 \u2191b + \u2191d - (\u2191a + \u2191c)\n\u22a2 \u2191n \u2223 \u2191d - \u2191c"}, {"tactic": "rw [add_sub_add_comm] at h\u2082", "annotated_tactic": ["rw [<a>add_sub_add_comm</a>] at h\u2082", [{"full_name": "add_sub_add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [661, 3], "def_end_pos": [661, 14]}]], "state_before": "m n a b c d : \u2115\nh\u2081 : \u2191n \u2223 \u2191b - \u2191a\nh\u2082 : \u2191n \u2223 \u2191b + \u2191d - (\u2191a + \u2191c)\n\u22a2 \u2191n \u2223 \u2191d - \u2191c", "state_after": "m n a b c d : \u2115\nh\u2081 : \u2191n \u2223 \u2191b - \u2191a\nh\u2082 : \u2191n \u2223 \u2191b - \u2191a + (\u2191d - \u2191c)\n\u22a2 \u2191n \u2223 \u2191d - \u2191c"}, {"tactic": "convert _root_.dvd_sub h\u2082 h\u2081 using 1", "annotated_tactic": ["convert <a>_root_.dvd_sub</a> h\u2082 h\u2081 using 1", [{"full_name": "dvd_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Divisibility/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 16]}]], "state_before": "m n a b c d : \u2115\nh\u2081 : \u2191n \u2223 \u2191b - \u2191a\nh\u2082 : \u2191n \u2223 \u2191b - \u2191a + (\u2191d - \u2191c)\n\u22a2 \u2191n \u2223 \u2191d - \u2191c", "state_after": "case h.e'_4\nm n a b c d : \u2115\nh\u2081 : \u2191n \u2223 \u2191b - \u2191a\nh\u2082 : \u2191n \u2223 \u2191b - \u2191a + (\u2191d - \u2191c)\n\u22a2 \u2191d - \u2191c = \u2191b - \u2191a + (\u2191d - \u2191c) - (\u2191b - \u2191a)"}, {"tactic": "rw [add_sub_cancel']", "annotated_tactic": ["rw [<a>add_sub_cancel'</a>]", [{"full_name": "add_sub_cancel'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1026, 30], "def_end_pos": [1026, 45]}]], "state_before": "case h.e'_4\nm n a b c d : \u2115\nh\u2081 : \u2191n \u2223 \u2191b - \u2191a\nh\u2082 : \u2191n \u2223 \u2191b - \u2191a + (\u2191d - \u2191c)\n\u22a2 \u2191d - \u2191c = \u2191b - \u2191a + (\u2191d - \u2191c) - (\u2191b - \u2191a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "compl_eq_top", "start": [691, 1], "end": [692, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pointwise.lean", "full_name": "Filter.div_eq_bot_iff", "start": [480, 1], "end": [481, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.OuterMeasure.biInf_apply", "start": [1197, 1], "end": [1200, 43], "traced_tactics": [{"tactic": "haveI := hI.to_subtype", "annotated_tactic": ["haveI := hI.to_subtype", []], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\nI : Set \u03b9\nhI : Set.Nonempty I\nm : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\n\u22a2 \u2191(\u2a05 i \u2208 I, m i) s = \u2a05 t, \u2a05 (_ : s \u2286 iUnion t), \u2211' (n : \u2115), \u2a05 i \u2208 I, \u2191(m i) (t n)", "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\nI : Set \u03b9\nhI : Set.Nonempty I\nm : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nthis : Nonempty \u2191I\n\u22a2 \u2191(\u2a05 i \u2208 I, m i) s = \u2a05 t, \u2a05 (_ : s \u2286 iUnion t), \u2211' (n : \u2115), \u2a05 i \u2208 I, \u2191(m i) (t n)"}, {"tactic": "simp only [\u2190 iInf_subtype'', iInf_apply]", "annotated_tactic": ["simp only [\u2190 <a>iInf_subtype''</a>, <a>iInf_apply</a>]", [{"full_name": "iInf_subtype''", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1167, 9], "def_end_pos": [1167, 23]}, {"full_name": "MeasureTheory.OuterMeasure.iInf_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1179, 9], "def_end_pos": [1179, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\nI : Set \u03b9\nhI : Set.Nonempty I\nm : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nthis : Nonempty \u2191I\n\u22a2 \u2191(\u2a05 i \u2208 I, m i) s = \u2a05 t, \u2a05 (_ : s \u2286 iUnion t), \u2211' (n : \u2115), \u2a05 i \u2208 I, \u2191(m i) (t n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Function.RightInverse.leftInverse_of_card_le", "start": [714, 1], "end": [716, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.coe_sigmaUnique", "start": [249, 1], "end": [251, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "full_name": "Cardinal.mul_eq_max_of_aleph0_le_left", "start": [609, 1], "end": [617, 15], "traced_tactics": [{"tactic": "rcases le_or_lt \u2135\u2080 b with hb | hb", "annotated_tactic": ["rcases <a>le_or_lt</a> \u2135\u2080 b with hb | hb", [{"full_name": "le_or_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [334, 9], "def_end_pos": [334, 17]}]], "state_before": "a b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\n\u22a2 a * b = max a b", "state_after": "case inl\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : \u2135\u2080 \u2264 b\n\u22a2 a * b = max a b\n\ncase inr\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\n\u22a2 a * b = max a b"}, {"tactic": "refine' (mul_le_max_of_aleph0_le_left h).antisymm _", "annotated_tactic": ["refine' (<a>mul_le_max_of_aleph0_le_left</a> h).<a>antisymm</a> _", [{"full_name": "Cardinal.mul_le_max_of_aleph0_le_left", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [603, 9], "def_end_pos": [603, 37]}, {"full_name": "LE.le.antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [125, 7], "def_end_pos": [125, 21]}]], "state_before": "case inr\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\n\u22a2 a * b = max a b", "state_after": "case inr\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\n\u22a2 max a b \u2264 a * b"}, {"tactic": "have : b \u2264 a := hb.le.trans h", "annotated_tactic": ["have : b \u2264 a := hb.le.trans h", []], "state_before": "case inr\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\n\u22a2 max a b \u2264 a * b", "state_after": "case inr\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\nthis : b \u2264 a\n\u22a2 max a b \u2264 a * b"}, {"tactic": "rw [max_eq_left this]", "annotated_tactic": ["rw [<a>max_eq_left</a> this]", [{"full_name": "max_eq_left", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [133, 9], "def_end_pos": [133, 20]}]], "state_before": "case inr\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\nthis : b \u2264 a\n\u22a2 max a b \u2264 a * b", "state_after": "case inr\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\nthis : b \u2264 a\n\u22a2 a \u2264 a * b"}, {"tactic": "convert mul_le_mul_left' (one_le_iff_ne_zero.mpr h') a", "annotated_tactic": ["convert <a>mul_le_mul_left'</a> (one_le_iff_ne_zero.mpr h') a", [{"full_name": "mul_le_mul_left'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [50, 9], "def_end_pos": [50, 25]}]], "state_before": "case inr\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\nthis : b \u2264 a\n\u22a2 a \u2264 a * b", "state_after": "case h.e'_3\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\nthis : b \u2264 a\n\u22a2 a = a * 1"}, {"tactic": "rw [mul_one]", "annotated_tactic": ["rw [<a>mul_one</a>]", [{"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "case h.e'_3\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : b < \u2135\u2080\nthis : b \u2264 a\n\u22a2 a = a * 1", "state_after": "no goals"}, {"tactic": "exact mul_eq_max h hb", "annotated_tactic": ["exact <a>mul_eq_max</a> h hb", [{"full_name": "Cardinal.mul_eq_max", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [548, 9], "def_end_pos": [548, 19]}]], "state_before": "case inl\na b : Cardinal.{u_1}\nh : \u2135\u2080 \u2264 a\nh' : b \u2260 0\nhb : \u2135\u2080 \u2264 b\n\u22a2 a * b = max a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.mul_add", "start": [1033, 11], "end": [1036, 23], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n\nL : Matrix m n \u03b1\nM N : Matrix n o \u03b1\n\u22a2 L * (M + N) = L * M + L * N", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n\nL : Matrix m n \u03b1\nM N : Matrix n o \u03b1\ni\u271d : m\nx\u271d : o\n\u22a2 (L * (M + N)) i\u271d x\u271d = (L * M + L * N) i\u271d x\u271d"}, {"tactic": "apply dotProduct_add", "annotated_tactic": ["apply <a>dotProduct_add</a>", [{"full_name": "Matrix.dotProduct_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [815, 9], "def_end_pos": [815, 23]}]], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype n\nL : Matrix m n \u03b1\nM N : Matrix n o \u03b1\ni\u271d : m\nx\u271d : o\n\u22a2 (L * (M + N)) i\u271d x\u271d = (L * M + L * N) i\u271d x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/TensorProduct/Basic.lean", "full_name": "Algebra.TensorProduct.lmul'_toLinearMap", "start": [985, 1], "end": [986, 6], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "induction_sum_1oktkp1", "start": [179, 1], "end": [181, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "n : \u2115\n\u22a2 \u2211 k in Finset.range n, 1 / ((\u2191k + 1) * (\u2191k + 2)) = \u2191n / (\u2191n + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Projection.lean", "full_name": "LinearMap.equivProdOfSurjectiveOfIsCompl_apply", "start": [334, 1], "end": [336, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Functor.lean", "full_name": "Functor.mapEquiv_symm_apply", "start": [51, 1], "end": [53, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "himp_bihimp_eq_inf", "start": [302, 1], "end": [303, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean", "full_name": "HahnSeries.mul_coeff_right'", "start": [185, 1], "end": [189, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "OrderHomClass.to_lattice_hom_apply", "start": [1194, 1], "end": [1195, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Sum/Lemmas.lean", "full_name": "Sum.inl.inj_iff", "start": [88, 1], "end": [88, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "full_name": "CategoryTheory.Limits.WalkingPair.equivBool_symm_apply_false", "start": [108, 1], "end": [109, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "full_name": "Cardinal.beth_ne_zero", "start": [481, 1], "end": [482, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Forall2.lean", "full_name": "List.rel_bind", "start": [274, 1], "end": [275, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WellFoundedSet.lean", "full_name": "WellFounded.isWF", "start": [835, 1], "end": [836, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean", "full_name": "MeasureTheory.Measure.restrict_biUnion_congr", "start": [406, 1], "end": [410, 71], "traced_tactics": [{"tactic": "haveI := hc.toEncodable", "annotated_tactic": ["haveI := hc.toEncodable", []], "state_before": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t\u271d : Set \u03b1\ns : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nhc : Set.Countable s\n\u22a2 restrict \u03bc (\u22c3 i \u2208 s, t i) = restrict \u03bd (\u22c3 i \u2208 s, t i) \u2194 \u2200 i \u2208 s, restrict \u03bc (t i) = restrict \u03bd (t i)", "state_after": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t\u271d : Set \u03b1\ns : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nhc : Set.Countable s\nthis : Encodable \u2191s\n\u22a2 restrict \u03bc (\u22c3 i \u2208 s, t i) = restrict \u03bd (\u22c3 i \u2208 s, t i) \u2194 \u2200 i \u2208 s, restrict \u03bc (t i) = restrict \u03bd (t i)"}, {"tactic": "simp only [biUnion_eq_iUnion, SetCoe.forall', restrict_iUnion_congr]", "annotated_tactic": ["simp only [<a>biUnion_eq_iUnion</a>, <a>SetCoe.forall'</a>, <a>restrict_iUnion_congr</a>]", [{"full_name": "Set.biUnion_eq_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [874, 9], "def_end_pos": [874, 26]}, {"full_name": "SetCoe.forall'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [181, 9], "def_end_pos": [181, 23]}, {"full_name": "MeasureTheory.Measure.restrict_iUnion_congr", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [396, 9], "def_end_pos": [396, 30]}]], "state_before": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : MeasurableSpace \u03b3\n\u03bc \u03bc\u2081 \u03bc\u2082 \u03bc\u2083 \u03bd \u03bd' \u03bd\u2081 \u03bd\u2082 : Measure \u03b1\ns\u271d s' t\u271d : Set \u03b1\ns : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nhc : Set.Countable s\nthis : Encodable \u2191s\n\u22a2 restrict \u03bc (\u22c3 i \u2208 s, t i) = restrict \u03bd (\u22c3 i \u2208 s, t i) \u2194 \u2200 i \u2208 s, restrict \u03bc (t i) = restrict \u03bd (t i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithBot.unbot'_coe", "start": [128, 1], "end": [129, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.bijective_iff_existsUnique", "start": [248, 1], "end": [252, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Mul.lean", "full_name": "derivWithin_finset_prod", "start": [319, 1], "end": [323, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/NAry.lean", "full_name": "Filter.map\u2082_right_comm", "start": [223, 1], "end": [227, 51], "traced_tactics": [{"tactic": "rw [map\u2082_swap n, map\u2082_swap n']", "annotated_tactic": ["rw [<a>map\u2082_swap</a> n, <a>map\u2082_swap</a> n']", [{"full_name": "Filter.map\u2082_swap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/NAry.lean", "def_pos": [149, 9], "def_end_pos": [149, 18]}, {"full_name": "Filter.map\u2082_swap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/NAry.lean", "def_pos": [149, 9], "def_end_pos": [149, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nm\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nh h\u2081 h\u2082 : Filter \u03b3\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\nu : Set \u03b3\nv : Set \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\nn' : \u03b4' \u2192 \u03b2 \u2192 \u03b5\nh_right_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m' a c) b\n\u22a2 map\u2082 m (map\u2082 n f g) h = map\u2082 n' (map\u2082 m' f h) g", "state_after": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nm\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nh h\u2081 h\u2082 : Filter \u03b3\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\nu : Set \u03b3\nv : Set \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\nn' : \u03b4' \u2192 \u03b2 \u2192 \u03b5\nh_right_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m' a c) b\n\u22a2 map\u2082 m (map\u2082 (fun a b => n b a) g f) h = map\u2082 (fun a b => n' b a) g (map\u2082 m' f h)"}, {"tactic": "exact map\u2082_assoc fun _ _ _ => h_right_comm _ _ _", "annotated_tactic": ["exact <a>map\u2082_assoc</a> fun _ _ _ => h_right_comm _ _ _", [{"full_name": "Filter.map\u2082_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/NAry.lean", "def_pos": [204, 9], "def_end_pos": [204, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\nm\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nh h\u2081 h\u2082 : Filter \u03b3\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\nu : Set \u03b3\nv : Set \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nm : \u03b4 \u2192 \u03b3 \u2192 \u03b5\nn : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nm' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'\nn' : \u03b4' \u2192 \u03b2 \u2192 \u03b5\nh_right_comm : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), m (n a b) c = n' (m' a c) b\n\u22a2 map\u2082 m (map\u2082 (fun a b => n b a) g f) h = map\u2082 (fun a b => n' b a) g (map\u2082 m' f h)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Isometry.lean", "full_name": "LinearIsometry.re_apply_eq_re", "start": [119, 1], "end": [122, 40], "traced_tactics": [{"tactic": "apply LinearIsometry.re_apply_eq_re_of_add_conj_eq", "annotated_tactic": ["apply <a>LinearIsometry.re_apply_eq_re_of_add_conj_eq</a>", [{"full_name": "LinearIsometry.re_apply_eq_re_of_add_conj_eq", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean", "def_pos": [90, 9], "def_end_pos": [90, 53]}]], "state_before": "f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 (f z).re = z.re", "state_after": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 \u2200 (z : \u2102), z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)"}, {"tactic": "intro z", "annotated_tactic": ["intro z", []], "state_before": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 \u2200 (z : \u2102), z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)", "state_after": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz\u271d z : \u2102\n\u22a2 z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)"}, {"tactic": "apply LinearIsometry.im_apply_eq_im h", "annotated_tactic": ["apply <a>LinearIsometry.im_apply_eq_im</a> h", [{"full_name": "LinearIsometry.im_apply_eq_im", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Complex/Isometry.lean", "def_pos": [104, 9], "def_end_pos": [104, 38]}]], "state_before": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz\u271d z : \u2102\n\u22a2 z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Operations.lean", "full_name": "ENNReal.lt_top_of_mul_ne_top_right", "start": [242, 1], "end": [243, 51], "traced_tactics": [{"tactic": "rwa [mul_comm]", "annotated_tactic": ["rwa [<a>mul_comm</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u03b1 : Type u_1\nh : a * b \u2260 \u22a4\nha : a \u2260 0\n\u22a2 b * a \u2260 \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "Metric.emetric_closedBall", "start": [1215, 1], "end": [1217, 34], "traced_tactics": [{"tactic": "ext y", "annotated_tactic": ["ext y", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : \u211d\nh : 0 \u2264 \u03b5\n\u22a2 EMetric.closedBall x (ENNReal.ofReal \u03b5) = closedBall x \u03b5", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : \u211d\nh : 0 \u2264 \u03b5\ny : \u03b1\n\u22a2 y \u2208 EMetric.closedBall x (ENNReal.ofReal \u03b5) \u2194 y \u2208 closedBall x \u03b5"}, {"tactic": "simp [edist_le_ofReal h]", "annotated_tactic": ["simp [<a>edist_le_ofReal</a> h]", [{"full_name": "edist_le_ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [364, 9], "def_end_pos": [364, 24]}]], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx : \u03b1\n\u03b5 : \u211d\nh : 0 \u2264 \u03b5\ny : \u03b1\n\u22a2 y \u2208 EMetric.closedBall x (ENNReal.ofReal \u03b5) \u2194 y \u2208 closedBall x \u03b5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.cyclicPermutations_eq_singleton_iff", "start": [647, 1], "end": [650, 91], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, fun h => by simp [cyclicPermutations, h, dropLast_eq_take]\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, fun h => by simp [<a>cyclicPermutations</a>, h, <a>dropLast_eq_take</a>]\u27e9", [{"full_name": "List.cyclicPermutations", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [566, 5], "def_end_pos": [566, 23]}, {"full_name": "List.dropLast_eq_take", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [2072, 9], "def_end_pos": [2072, 25]}]], "state_before": "\u03b1 : Type u\nl\u271d l' l : List \u03b1\nx : \u03b1\n\u22a2 cyclicPermutations l = [[x]] \u2194 l = [x]", "state_after": "\u03b1 : Type u\nl\u271d l' l : List \u03b1\nx : \u03b1\nh : cyclicPermutations l = [[x]]\n\u22a2 l = [x]"}, {"tactic": "rw [eq_comm, \u2190 isRotated_singleton_iff', \u2190 mem_cyclicPermutations_iff, h, mem_singleton]", "annotated_tactic": ["rw [<a>eq_comm</a>, \u2190 <a>isRotated_singleton_iff'</a>, \u2190 <a>mem_cyclicPermutations_iff</a>, h, <a>mem_singleton</a>]", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "List.isRotated_singleton_iff'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [503, 9], "def_end_pos": [503, 33]}, {"full_name": "List.mem_cyclicPermutations_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [625, 9], "def_end_pos": [625, 35]}, {"full_name": "List.mem_singleton", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [82, 22], "def_end_pos": [82, 35]}]], "state_before": "\u03b1 : Type u\nl\u271d l' l : List \u03b1\nx : \u03b1\nh : cyclicPermutations l = [[x]]\n\u22a2 l = [x]", "state_after": "no goals"}, {"tactic": "simp [cyclicPermutations, h, dropLast_eq_take]", "annotated_tactic": ["simp [<a>cyclicPermutations</a>, h, <a>dropLast_eq_take</a>]", [{"full_name": "List.cyclicPermutations", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [566, 5], "def_end_pos": [566, 23]}, {"full_name": "List.dropLast_eq_take", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [2072, 9], "def_end_pos": [2072, 25]}]], "state_before": "\u03b1 : Type u\nl\u271d l' l : List \u03b1\nx : \u03b1\nh : l = [x]\n\u22a2 cyclicPermutations l = [[x]]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean", "full_name": "MeasureTheory.ae_restrict_iUnion_eq", "start": [547, 1], "end": [550, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Sigma.lean", "full_name": "Set.sigma_univ", "start": [95, 1], "end": [96, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.emod_eq_of_lt", "start": [241, 1], "end": [244, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Complex/Basic.lean", "full_name": "Complex.nndist_of_re_eq", "start": [117, 1], "end": [118, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subsemigroup/Centralizer.lean", "full_name": "Subsemigroup.mem_centralizer_iff", "start": [178, 1], "end": [179, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Algebraic.lean", "full_name": "Algebra.IsAlgebraic.algHom_bijective", "start": [322, 1], "end": [330, 34], "traced_tactics": [{"tactic": "refine' \u27e8f.injective, fun b \u21a6 _\u27e9", "annotated_tactic": ["refine' \u27e8f.injective, fun b \u21a6 _\u27e9", []], "state_before": "K : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha : IsAlgebraic K L\nf : L \u2192\u2090[K] L\n\u22a2 Function.Bijective \u21d1f", "state_after": "K : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\n\u22a2 \u2203 a, f a = b"}, {"tactic": "obtain \u27e8p, hp, he\u27e9 := ha b", "annotated_tactic": ["obtain \u27e8p, hp, he\u27e9 := ha b", []], "state_before": "K : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\n\u22a2 \u2203 a, f a = b", "state_after": "case intro.intro\nK : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\np : K[X]\nhp : p \u2260 0\nhe : (aeval b) p = 0\n\u22a2 \u2203 a, f a = b"}, {"tactic": "let f' : p.rootSet L \u2192 p.rootSet L := (rootSet_maps_to' (fun x \u21a6 x) f).restrict f _ _", "annotated_tactic": ["let f' : p.rootSet L \u2192 p.rootSet L := (<a>rootSet_maps_to'</a> (fun x \u21a6 x) f).<a>restrict</a> f _ _", [{"full_name": "Polynomial.rootSet_maps_to'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1244, 9], "def_end_pos": [1244, 25]}, {"full_name": "Set.MapsTo.restrict", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [278, 5], "def_end_pos": [278, 20]}]], "state_before": "case intro.intro\nK : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\np : K[X]\nhp : p \u2260 0\nhe : (aeval b) p = 0\n\u22a2 \u2203 a, f a = b", "state_after": "case intro.intro\nK : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\np : K[X]\nhp : p \u2260 0\nhe : (aeval b) p = 0\nf' : \u2191(rootSet p L) \u2192 \u2191(rootSet p L) := Set.MapsTo.restrict (\u21d1f) (rootSet p L) (rootSet p L) \u22ef\n\u22a2 \u2203 a, f a = b"}, {"tactic": "have : f'.Surjective := Finite.injective_iff_surjective.1\n  fun _ _ h \u21a6 Subtype.eq <| f.injective <| Subtype.ext_iff.1 h", "annotated_tactic": ["have : f'.Surjective := <a>Finite.injective_iff_surjective</a>.1\n    fun _ _ h \u21a6 <a>Subtype.eq</a> <| f.injective <| <a>Subtype.ext_iff</a>.1 h", [{"full_name": "Finite.injective_iff_surjective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [652, 9], "def_end_pos": [652, 33]}, {"full_name": "Subtype.eq", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1105, 19], "def_end_pos": [1105, 21]}, {"full_name": "Subtype.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [69, 9], "def_end_pos": [69, 16]}]], "state_before": "case intro.intro\nK : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\np : K[X]\nhp : p \u2260 0\nhe : (aeval b) p = 0\nf' : \u2191(rootSet p L) \u2192 \u2191(rootSet p L) := Set.MapsTo.restrict (\u21d1f) (rootSet p L) (rootSet p L) \u22ef\n\u22a2 \u2203 a, f a = b", "state_after": "case intro.intro\nK : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\np : K[X]\nhp : p \u2260 0\nhe : (aeval b) p = 0\nf' : \u2191(rootSet p L) \u2192 \u2191(rootSet p L) := Set.MapsTo.restrict (\u21d1f) (rootSet p L) (rootSet p L) \u22ef\nthis : Function.Surjective f'\n\u22a2 \u2203 a, f a = b"}, {"tactic": "obtain \u27e8a, ha\u27e9 := this \u27e8b, mem_rootSet.2 \u27e8hp, he\u27e9\u27e9", "annotated_tactic": ["obtain \u27e8a, ha\u27e9 := this \u27e8b, <a>mem_rootSet</a>.2 \u27e8hp, he\u27e9\u27e9", [{"full_name": "Polynomial.mem_rootSet", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1234, 9], "def_end_pos": [1234, 20]}]], "state_before": "case intro.intro\nK : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\np : K[X]\nhp : p \u2260 0\nhe : (aeval b) p = 0\nf' : \u2191(rootSet p L) \u2192 \u2191(rootSet p L) := Set.MapsTo.restrict (\u21d1f) (rootSet p L) (rootSet p L) \u22ef\nthis : Function.Surjective f'\n\u22a2 \u2203 a, f a = b", "state_after": "case intro.intro.intro\nK : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha\u271d : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\np : K[X]\nhp : p \u2260 0\nhe : (aeval b) p = 0\nf' : \u2191(rootSet p L) \u2192 \u2191(rootSet p L) := Set.MapsTo.restrict (\u21d1f) (rootSet p L) (rootSet p L) \u22ef\nthis : Function.Surjective f'\na : \u2191(rootSet p L)\nha : f' a = { val := b, property := \u22ef }\n\u22a2 \u2203 a, f a = b"}, {"tactic": "exact \u27e8a, Subtype.ext_iff.1 ha\u27e9", "annotated_tactic": ["exact \u27e8a, <a>Subtype.ext_iff</a>.1 ha\u27e9", [{"full_name": "Subtype.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [69, 9], "def_end_pos": [69, 16]}]], "state_before": "case intro.intro.intro\nK : Type u_1\nL : Type u_2\nR : Type u_3\nS : Type u_4\nA : Type u_5\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : NoZeroSMulDivisors K L\nha\u271d : IsAlgebraic K L\nf : L \u2192\u2090[K] L\nb : L\np : K[X]\nhp : p \u2260 0\nhe : (aeval b) p = 0\nf' : \u2191(rootSet p L) \u2192 \u2191(rootSet p L) := Set.MapsTo.restrict (\u21d1f) (rootSet p L) (rootSet p L) \u22ef\nthis : Function.Surjective f'\na : \u2191(rootSet p L)\nha : f' a = { val := b, property := \u22ef }\n\u22a2 \u2203 a, f a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Basic.lean", "full_name": "map_inv_nat_cast_smul", "start": [440, 1], "end": [455, 81], "traced_tactics": [{"tactic": "by_cases hR : (n : R) = 0 <;> by_cases hS : (n : S) = 0", "annotated_tactic": ["by_cases hR : (n : R) = 0 <;> by_cases hS : (n : S) = 0", []], "state_before": "\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x", "state_after": "case pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u2191n = 0\nhS : \u2191n = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x\n\ncase neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x\n\ncase pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u00ac\u2191n = 0\nhS : \u2191n = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x\n\ncase neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u00ac\u2191n = 0\nhS : \u00ac\u2191n = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x"}, {"tactic": "simp [hR, hS, map_zero f]", "annotated_tactic": ["simp [hR, hS, <a>map_zero</a> f]", [{"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}]], "state_before": "case pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u2191n = 0\nhS : \u2191n = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x", "state_after": "no goals"}, {"tactic": "suffices \u2200 y, f y = 0 by rw [this, this, smul_zero]", "annotated_tactic": ["suffices \u2200 y, f y = 0 by rw [this, this, <a>smul_zero</a>]", [{"full_name": "smul_zero", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [760, 9], "def_end_pos": [760, 18]}]], "state_before": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x", "state_after": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\n\u22a2 \u2200 (y : M), f y = 0"}, {"tactic": "clear x", "annotated_tactic": ["clear x", []], "state_before": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\n\u22a2 \u2200 (y : M), f y = 0", "state_after": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\n\u22a2 \u2200 (y : M), f y = 0"}, {"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\n\u22a2 \u2200 (y : M), f y = 0", "state_after": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\nx : M\n\u22a2 f x = 0"}, {"tactic": "rw [\u2190 inv_smul_smul\u2080 hS (f x), \u2190 map_nat_cast_smul f R S]", "annotated_tactic": ["rw [\u2190 <a>inv_smul_smul\u2080</a> hS (f x), \u2190 <a>map_nat_cast_smul</a> f R S]", [{"full_name": "inv_smul_smul\u2080", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [214, 9], "def_end_pos": [214, 23]}, {"full_name": "map_nat_cast_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [434, 9], "def_end_pos": [434, 26]}]], "state_before": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\nx : M\n\u22a2 f x = 0", "state_after": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\nx : M\n\u22a2 (\u2191n)\u207b\u00b9 \u2022 f (\u2191n \u2022 x) = 0"}, {"tactic": "simp [hR, map_zero f]", "annotated_tactic": ["simp [hR, <a>map_zero</a> f]", [{"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}]], "state_before": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\nx : M\n\u22a2 (\u2191n)\u207b\u00b9 \u2022 f (\u2191n \u2022 x) = 0", "state_after": "no goals"}, {"tactic": "rw [this, this, smul_zero]", "annotated_tactic": ["rw [this, this, <a>smul_zero</a>]", [{"full_name": "smul_zero", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [760, 9], "def_end_pos": [760, 18]}]], "state_before": "\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u2191n = 0\nhS : \u00ac\u2191n = 0\nthis : \u2200 (y : M), f y = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x", "state_after": "no goals"}, {"tactic": "suffices \u2200 y, f y = 0 by simp [this]", "annotated_tactic": ["suffices \u2200 y, f y = 0 by simp [this]", []], "state_before": "case pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u00ac\u2191n = 0\nhS : \u2191n = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x", "state_after": "case pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u00ac\u2191n = 0\nhS : \u2191n = 0\n\u22a2 \u2200 (y : M), f y = 0"}, {"tactic": "clear x", "annotated_tactic": ["clear x", []], "state_before": "case pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u00ac\u2191n = 0\nhS : \u2191n = 0\n\u22a2 \u2200 (y : M), f y = 0", "state_after": "case pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u00ac\u2191n = 0\nhS : \u2191n = 0\n\u22a2 \u2200 (y : M), f y = 0"}, {"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "case pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u00ac\u2191n = 0\nhS : \u2191n = 0\n\u22a2 \u2200 (y : M), f y = 0", "state_after": "case pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u00ac\u2191n = 0\nhS : \u2191n = 0\nx : M\n\u22a2 f x = 0"}, {"tactic": "rw [\u2190 smul_inv_smul\u2080 hR x, map_nat_cast_smul f R S, hS, zero_smul]", "annotated_tactic": ["rw [\u2190 <a>smul_inv_smul\u2080</a> hR x, <a>map_nat_cast_smul</a> f R S, hS, <a>zero_smul</a>]", [{"full_name": "smul_inv_smul\u2080", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [219, 9], "def_end_pos": [219, 23]}, {"full_name": "map_nat_cast_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [434, 9], "def_end_pos": [434, 26]}, {"full_name": "zero_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}]], "state_before": "case pos\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nhR : \u00ac\u2191n = 0\nhS : \u2191n = 0\nx : M\n\u22a2 f x = 0", "state_after": "no goals"}, {"tactic": "simp [this]", "annotated_tactic": ["simp [this]", []], "state_before": "\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u00ac\u2191n = 0\nhS : \u2191n = 0\nthis : \u2200 (y : M), f y = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x", "state_after": "no goals"}, {"tactic": "rw [\u2190 inv_smul_smul\u2080 hS (f _), \u2190 map_nat_cast_smul f R S, smul_inv_smul\u2080 hR]", "annotated_tactic": ["rw [\u2190 <a>inv_smul_smul\u2080</a> hS (f _), \u2190 <a>map_nat_cast_smul</a> f R S, <a>smul_inv_smul\u2080</a> hR]", [{"full_name": "inv_smul_smul\u2080", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [214, 9], "def_end_pos": [214, 23]}, {"full_name": "map_nat_cast_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [434, 9], "def_end_pos": [434, 26]}, {"full_name": "smul_inv_smul\u2080", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [219, 9], "def_end_pos": [219, 23]}]], "state_before": "case neg\n\u03b1 : Type u_1\nR\u271d : Type u_2\nk : Type u_3\nS\u271d : Type u_4\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\n\u03b9 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\nF : Type u_9\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_10\nS : Type u_11\ninst\u271d\u00b3 : DivisionSemiring R\ninst\u271d\u00b2 : DivisionSemiring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nn : \u2115\nx : M\nhR : \u00ac\u2191n = 0\nhS : \u00ac\u2191n = 0\n\u22a2 f ((\u2191n)\u207b\u00b9 \u2022 x) = (\u2191n)\u207b\u00b9 \u2022 f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.induction_to_univ", "start": [1213, 1], "end": [1215, 80], "traced_tactics": [{"tactic": "simpa [ssubset_univ_iff]", "annotated_tactic": ["simpa [<a>ssubset_univ_iff</a>]", [{"full_name": "Set.ssubset_univ_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [704, 9], "def_end_pos": [704, 25]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ninst\u271d : Finite \u03b1\nC : Set \u03b1 \u2192 Prop\nS0 : Set \u03b1\nH0 : C S0\nH1 : \u2200 (S : Set \u03b1), S \u2260 univ \u2192 C S \u2192 \u2203 a \u2209 S, C (insert a S)\n\u22a2 \u2200 s \u2282 univ, C s \u2192 \u2203 a \u2208 univ \\ s, C (insert a s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Pi/Basic.lean", "full_name": "Function.extend_mul", "start": [491, 1], "end": [495, 87], "traced_tactics": [{"tactic": "classical\nfunext x\nsimp only [not_exists, extend_def, Pi.mul_apply, apply_dite\u2082, dite_eq_ite, ite_self]", "annotated_tactic": ["classical\n  funext x\n  simp only [<a>not_exists</a>, <a>extend_def</a>, <a>Pi.mul_apply</a>, <a>apply_dite\u2082</a>, <a>dite_eq_ite</a>, <a>ite_self</a>]", [{"full_name": "not_exists", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [187, 17], "def_end_pos": [187, 27]}, {"full_name": "Function.extend_def", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [729, 9], "def_end_pos": [729, 19]}, {"full_name": "Pi.mul_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [90, 9], "def_end_pos": [90, 18]}, {"full_name": "apply_dite\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [1215, 9], "def_end_pos": [1215, 20]}, {"full_name": "dite_eq_ite", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [64, 17], "def_end_pos": [64, 28]}, {"full_name": "ite_self", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [99, 17], "def_end_pos": [99, 25]}]], "state_before": "I : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf\u271d : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx y : (i : I) \u2192 f\u271d i\ni : I\ninst\u271d : Mul \u03b3\nf : \u03b1 \u2192 \u03b2\ng\u2081 g\u2082 : \u03b1 \u2192 \u03b3\ne\u2081 e\u2082 : \u03b2 \u2192 \u03b3\n\u22a2 extend f (g\u2081 * g\u2082) (e\u2081 * e\u2082) = extend f g\u2081 e\u2081 * extend f g\u2082 e\u2082", "state_after": "no goals"}, {"tactic": "funext x", "annotated_tactic": ["funext x", []], "state_before": "I : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf\u271d : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx y : (i : I) \u2192 f\u271d i\ni : I\ninst\u271d : Mul \u03b3\nf : \u03b1 \u2192 \u03b2\ng\u2081 g\u2082 : \u03b1 \u2192 \u03b3\ne\u2081 e\u2082 : \u03b2 \u2192 \u03b3\n\u22a2 extend f (g\u2081 * g\u2082) (e\u2081 * e\u2082) = extend f g\u2081 e\u2081 * extend f g\u2082 e\u2082", "state_after": "case h\nI : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf\u271d : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx\u271d y : (i : I) \u2192 f\u271d i\ni : I\ninst\u271d : Mul \u03b3\nf : \u03b1 \u2192 \u03b2\ng\u2081 g\u2082 : \u03b1 \u2192 \u03b3\ne\u2081 e\u2082 : \u03b2 \u2192 \u03b3\nx : \u03b2\n\u22a2 extend f (g\u2081 * g\u2082) (e\u2081 * e\u2082) x = (extend f g\u2081 e\u2081 * extend f g\u2082 e\u2082) x"}, {"tactic": "simp only [not_exists, extend_def, Pi.mul_apply, apply_dite\u2082, dite_eq_ite, ite_self]", "annotated_tactic": ["simp only [<a>not_exists</a>, <a>extend_def</a>, <a>Pi.mul_apply</a>, <a>apply_dite\u2082</a>, <a>dite_eq_ite</a>, <a>ite_self</a>]", [{"full_name": "not_exists", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [187, 17], "def_end_pos": [187, 27]}, {"full_name": "Function.extend_def", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [729, 9], "def_end_pos": [729, 19]}, {"full_name": "Pi.mul_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [90, 9], "def_end_pos": [90, 18]}, {"full_name": "apply_dite\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [1215, 9], "def_end_pos": [1215, 20]}, {"full_name": "dite_eq_ite", "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean", "def_pos": [64, 17], "def_end_pos": [64, 28]}, {"full_name": "ite_self", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [99, 17], "def_end_pos": [99, 25]}]], "state_before": "case h\nI : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf\u271d : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx\u271d y : (i : I) \u2192 f\u271d i\ni : I\ninst\u271d : Mul \u03b3\nf : \u03b1 \u2192 \u03b2\ng\u2081 g\u2082 : \u03b1 \u2192 \u03b3\ne\u2081 e\u2082 : \u03b2 \u2192 \u03b3\nx : \u03b2\n\u22a2 extend f (g\u2081 * g\u2082) (e\u2081 * e\u2082) x = (extend f g\u2081 e\u2081 * extend f g\u2082 e\u2082) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.subsingleton_Icc_of_ge", "start": [774, 1], "end": [776, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.inducedOuterMeasure_exists_set", "start": [1485, 1], "end": [1496, 98], "traced_tactics": [{"tactic": "have h := ENNReal.lt_add_right hs h\u03b5", "annotated_tactic": ["have h := <a>ENNReal.lt_add_right</a> hs h\u03b5", [{"full_name": "ENNReal.lt_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Operations.lean", "def_pos": [177, 9], "def_end_pos": [177, 21]}]], "state_before": "\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nhs : \u2191(inducedOuterMeasure m P0 m0) s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\n\u22a2 \u2203 t, P t \u2227 s \u2286 t \u2227 \u2191(inducedOuterMeasure m P0 m0) t \u2264 \u2191(inducedOuterMeasure m P0 m0) s + \u03b5", "state_after": "\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nhs : \u2191(inducedOuterMeasure m P0 m0) s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh : \u2191(inducedOuterMeasure m P0 m0) s < \u2191(inducedOuterMeasure m P0 m0) s + \u03b5\n\u22a2 \u2203 t, P t \u2227 s \u2286 t \u2227 \u2191(inducedOuterMeasure m P0 m0) t \u2264 \u2191(inducedOuterMeasure m P0 m0) s + \u03b5"}, {"tactic": "conv at h =>\n  lhs\n  rw [inducedOuterMeasure_eq_iInf _ msU m_mono]", "annotated_tactic": ["conv at h =>\n    lhs\n    rw [<a>inducedOuterMeasure_eq_iInf</a> _ msU m_mono]", [{"full_name": "MeasureTheory.inducedOuterMeasure_eq_iInf", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1458, 9], "def_end_pos": [1458, 36]}]], "state_before": "\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nhs : \u2191(inducedOuterMeasure m P0 m0) s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh : \u2191(inducedOuterMeasure m P0 m0) s < \u2191(inducedOuterMeasure m P0 m0) s + \u03b5\n\u22a2 \u2203 t, P t \u2227 s \u2286 t \u2227 \u2191(inducedOuterMeasure m P0 m0) t \u2264 \u2191(inducedOuterMeasure m P0 m0) s + \u03b5", "state_after": "\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nhs : \u2191(inducedOuterMeasure m P0 m0) s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh : \u2a05 t, \u2a05 (ht : P t), \u2a05 (_ : s \u2286 t), m t ht < \u2191(inducedOuterMeasure m P0 m0) s + \u03b5\n\u22a2 \u2203 t, P t \u2227 s \u2286 t \u2227 \u2191(inducedOuterMeasure m P0 m0) t \u2264 \u2191(inducedOuterMeasure m P0 m0) s + \u03b5"}, {"tactic": "simp only [iInf_lt_iff] at h", "annotated_tactic": ["simp only [<a>iInf_lt_iff</a>] at h", [{"full_name": "iInf_lt_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [552, 9], "def_end_pos": [552, 20]}]], "state_before": "\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nhs : \u2191(inducedOuterMeasure m P0 m0) s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh : \u2a05 t, \u2a05 (ht : P t), \u2a05 (_ : s \u2286 t), m t ht < \u2191(inducedOuterMeasure m P0 m0) s + \u03b5\n\u22a2 \u2203 t, P t \u2227 s \u2286 t \u2227 \u2191(inducedOuterMeasure m P0 m0) t \u2264 \u2191(inducedOuterMeasure m P0 m0) s + \u03b5", "state_after": "\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nhs : \u2191(inducedOuterMeasure m P0 m0) s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh : \u2203 i, \u2203 (h : P i) (_ : s \u2286 i), m i \u22ef < \u2191(inducedOuterMeasure m P0 m0) s + \u03b5\n\u22a2 \u2203 t, P t \u2227 s \u2286 t \u2227 \u2191(inducedOuterMeasure m P0 m0) t \u2264 \u2191(inducedOuterMeasure m P0 m0) s + \u03b5"}, {"tactic": "rcases h with \u27e8t, h1t, h2t, h3t\u27e9", "annotated_tactic": ["rcases h with \u27e8t, h1t, h2t, h3t\u27e9", []], "state_before": "\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nhs : \u2191(inducedOuterMeasure m P0 m0) s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nh : \u2203 i, \u2203 (h : P i) (_ : s \u2286 i), m i \u22ef < \u2191(inducedOuterMeasure m P0 m0) s + \u03b5\n\u22a2 \u2203 t, P t \u2227 s \u2286 t \u2227 \u2191(inducedOuterMeasure m P0 m0) t \u2264 \u2191(inducedOuterMeasure m P0 m0) s + \u03b5", "state_after": "case intro.intro.intro\n\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nhs : \u2191(inducedOuterMeasure m P0 m0) s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nt : Set \u03b1\nh1t : P t\nh2t : s \u2286 t\nh3t : m t \u22ef < \u2191(inducedOuterMeasure m P0 m0) s + \u03b5\n\u22a2 \u2203 t, P t \u2227 s \u2286 t \u2227 \u2191(inducedOuterMeasure m P0 m0) t \u2264 \u2191(inducedOuterMeasure m P0 m0) s + \u03b5"}, {"tactic": "exact\n  \u27e8t, h1t, h2t, le_trans (le_of_eq <| inducedOuterMeasure_eq' _ msU m_mono h1t) (le_of_lt h3t)\u27e9", "annotated_tactic": ["exact\n    \u27e8t, h1t, h2t, <a>le_trans</a> (<a>le_of_eq</a> <| <a>inducedOuterMeasure_eq'</a> _ msU m_mono h1t) (<a>le_of_lt</a> h3t)\u27e9", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "le_of_eq", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [66, 9], "def_end_pos": [66, 17]}, {"full_name": "MeasureTheory.inducedOuterMeasure_eq'", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1454, 9], "def_end_pos": [1454, 32]}, {"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}]], "state_before": "case intro.intro.intro\n\u03b1 : Type u_1\nP : Set \u03b1 \u2192 Prop\nm : (s : Set \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\nP0 : P \u2205\nm0 : m \u2205 P0 = 0\nPU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 i, f i)\nmU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) \u22ef = \u2211' (i : \u2115), m (f i) \u22ef\nmsU : \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (hm : \u2200 (i : \u2115), P (f i)), m (\u22c3 i, f i) \u22ef \u2264 \u2211' (i : \u2115), m (f i) \u22ef\nm_mono : \u2200 \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (hs\u2081 : P s\u2081) (hs\u2082 : P s\u2082), s\u2081 \u2286 s\u2082 \u2192 m s\u2081 hs\u2081 \u2264 m s\u2082 hs\u2082\ns : Set \u03b1\nhs : \u2191(inducedOuterMeasure m P0 m0) s \u2260 \u22a4\n\u03b5 : \u211d\u22650\u221e\nh\u03b5 : \u03b5 \u2260 0\nt : Set \u03b1\nh1t : P t\nh2t : s \u2286 t\nh3t : m t \u22ef < \u2191(inducedOuterMeasure m P0 m0) s + \u03b5\n\u22a2 \u2203 t, P t \u2227 s \u2286 t \u2227 \u2191(inducedOuterMeasure m P0 m0) t \u2264 \u2191(inducedOuterMeasure m P0 m0) s + \u03b5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.EqOn.union", "start": [237, 1], "end": [238, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/NNReal.lean", "full_name": "NNReal.coe_zpow", "start": [307, 1], "end": [307, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "ENNReal.aemeasurable_of_tendsto", "start": [2211, 1], "end": [2215, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Basic.lean", "full_name": "derivWithin_of_mem_nhds", "start": [528, 1], "end": [529, 61], "traced_tactics": [{"tactic": "simp only [derivWithin, deriv, fderivWithin_of_mem_nhds h]", "annotated_tactic": ["simp only [<a>derivWithin</a>, <a>deriv</a>, <a>fderivWithin_of_mem_nhds</a> h]", [{"full_name": "derivWithin", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "def_pos": [140, 5], "def_end_pos": [140, 16]}, {"full_name": "deriv", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "def_pos": [149, 5], "def_end_pos": [149, 10]}, {"full_name": "fderivWithin_of_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "def_pos": [709, 9], "def_end_pos": [709, 33]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf f\u2080 f\u2081 g : \ud835\udd5c \u2192 F\nf' f\u2080' f\u2081' g' : F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nL L\u2081 L\u2082 : Filter \ud835\udd5c\nh : s \u2208 \ud835\udcdd x\n\u22a2 derivWithin f s x = deriv f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/UniqueProds.lean", "full_name": "UniqueProds.of_mulHom", "start": [324, 16], "end": [332, 63], "traced_tactics": [{"tactic": "classical\nobtain \u27e8a0, ha0, b0, hb0, h\u27e9 := uniqueMul_of_nonempty (A0.image f) (B0.image f)\nobtain \u27e8a', ha', rfl\u27e9 := mem_image.mp ha0\nobtain \u27e8b', hb', rfl\u27e9 := mem_image.mp hb0\nexact \u27e8a', ha', b', hb', UniqueMul.of_mulHom_image f hf h\u27e9", "annotated_tactic": ["classical\n    obtain \u27e8a0, ha0, b0, hb0, h\u27e9 := <a>uniqueMul_of_nonempty</a> (A0.image f) (B0.image f)\n    obtain \u27e8a', ha', rfl\u27e9 := mem_image.mp ha0\n    obtain \u27e8b', hb', rfl\u27e9 := mem_image.mp hb0\n    exact \u27e8a', ha', b', hb', <a>UniqueMul.of_mulHom_image</a> f hf h\u27e9", [{"full_name": "UniqueProds.uniqueMul_of_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/UniqueProds.lean", "def_pos": [243, 3], "def_end_pos": [243, 24]}, {"full_name": "UniqueMul.of_mulHom_image", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/UniqueProds.lean", "def_pos": [155, 24], "def_end_pos": [155, 39]}]], "state_before": "G : Type u\nH : Type v\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Mul H\nf : H \u2192\u2099* G\nhf : \u2200 \u2983a b c d : H\u2984, a * b = c * d \u2192 f a = f c \u2227 f b = f d \u2192 a = c \u2227 b = d\ninst\u271d : UniqueProds G\nA B : Finset H\nA0 : A.Nonempty\nB0 : B.Nonempty\n\u22a2 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0", "state_after": "no goals"}, {"tactic": "obtain \u27e8a0, ha0, b0, hb0, h\u27e9 := uniqueMul_of_nonempty (A0.image f) (B0.image f)", "annotated_tactic": ["obtain \u27e8a0, ha0, b0, hb0, h\u27e9 := <a>uniqueMul_of_nonempty</a> (A0.image f) (B0.image f)", [{"full_name": "UniqueProds.uniqueMul_of_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/UniqueProds.lean", "def_pos": [243, 3], "def_end_pos": [243, 24]}]], "state_before": "G : Type u\nH : Type v\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Mul H\nf : H \u2192\u2099* G\nhf : \u2200 \u2983a b c d : H\u2984, a * b = c * d \u2192 f a = f c \u2227 f b = f d \u2192 a = c \u2227 b = d\ninst\u271d : UniqueProds G\nA B : Finset H\nA0 : A.Nonempty\nB0 : B.Nonempty\n\u22a2 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0", "state_after": "case intro.intro.intro.intro\nG : Type u\nH : Type v\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Mul H\nf : H \u2192\u2099* G\nhf : \u2200 \u2983a b c d : H\u2984, a * b = c * d \u2192 f a = f c \u2227 f b = f d \u2192 a = c \u2227 b = d\ninst\u271d : UniqueProds G\nA B : Finset H\nA0 : A.Nonempty\nB0 : B.Nonempty\na0 : G\nha0 : a0 \u2208 image (\u21d1f) A\nb0 : G\nhb0 : b0 \u2208 image (\u21d1f) B\nh : UniqueMul (image (\u21d1f) A) (image (\u21d1f) B) a0 b0\n\u22a2 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0"}, {"tactic": "obtain \u27e8a', ha', rfl\u27e9 := mem_image.mp ha0", "annotated_tactic": ["obtain \u27e8a', ha', rfl\u27e9 := mem_image.mp ha0", []], "state_before": "case intro.intro.intro.intro\nG : Type u\nH : Type v\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Mul H\nf : H \u2192\u2099* G\nhf : \u2200 \u2983a b c d : H\u2984, a * b = c * d \u2192 f a = f c \u2227 f b = f d \u2192 a = c \u2227 b = d\ninst\u271d : UniqueProds G\nA B : Finset H\nA0 : A.Nonempty\nB0 : B.Nonempty\na0 : G\nha0 : a0 \u2208 image (\u21d1f) A\nb0 : G\nhb0 : b0 \u2208 image (\u21d1f) B\nh : UniqueMul (image (\u21d1f) A) (image (\u21d1f) B) a0 b0\n\u22a2 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0", "state_after": "case intro.intro.intro.intro.intro.intro\nG : Type u\nH : Type v\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Mul H\nf : H \u2192\u2099* G\nhf : \u2200 \u2983a b c d : H\u2984, a * b = c * d \u2192 f a = f c \u2227 f b = f d \u2192 a = c \u2227 b = d\ninst\u271d : UniqueProds G\nA B : Finset H\nA0 : A.Nonempty\nB0 : B.Nonempty\nb0 : G\nhb0 : b0 \u2208 image (\u21d1f) B\na' : H\nha' : a' \u2208 A\nha0 : f a' \u2208 image (\u21d1f) A\nh : UniqueMul (image (\u21d1f) A) (image (\u21d1f) B) (f a') b0\n\u22a2 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0"}, {"tactic": "obtain \u27e8b', hb', rfl\u27e9 := mem_image.mp hb0", "annotated_tactic": ["obtain \u27e8b', hb', rfl\u27e9 := mem_image.mp hb0", []], "state_before": "case intro.intro.intro.intro.intro.intro\nG : Type u\nH : Type v\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Mul H\nf : H \u2192\u2099* G\nhf : \u2200 \u2983a b c d : H\u2984, a * b = c * d \u2192 f a = f c \u2227 f b = f d \u2192 a = c \u2227 b = d\ninst\u271d : UniqueProds G\nA B : Finset H\nA0 : A.Nonempty\nB0 : B.Nonempty\nb0 : G\nhb0 : b0 \u2208 image (\u21d1f) B\na' : H\nha' : a' \u2208 A\nha0 : f a' \u2208 image (\u21d1f) A\nh : UniqueMul (image (\u21d1f) A) (image (\u21d1f) B) (f a') b0\n\u22a2 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0", "state_after": "case intro.intro.intro.intro.intro.intro.intro.intro\nG : Type u\nH : Type v\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Mul H\nf : H \u2192\u2099* G\nhf : \u2200 \u2983a b c d : H\u2984, a * b = c * d \u2192 f a = f c \u2227 f b = f d \u2192 a = c \u2227 b = d\ninst\u271d : UniqueProds G\nA B : Finset H\nA0 : A.Nonempty\nB0 : B.Nonempty\na' : H\nha' : a' \u2208 A\nha0 : f a' \u2208 image (\u21d1f) A\nb' : H\nhb' : b' \u2208 B\nhb0 : f b' \u2208 image (\u21d1f) B\nh : UniqueMul (image (\u21d1f) A) (image (\u21d1f) B) (f a') (f b')\n\u22a2 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0"}, {"tactic": "exact \u27e8a', ha', b', hb', UniqueMul.of_mulHom_image f hf h\u27e9", "annotated_tactic": ["exact \u27e8a', ha', b', hb', <a>UniqueMul.of_mulHom_image</a> f hf h\u27e9", [{"full_name": "UniqueMul.of_mulHom_image", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/UniqueProds.lean", "def_pos": [155, 24], "def_end_pos": [155, 39]}]], "state_before": "case intro.intro.intro.intro.intro.intro.intro.intro\nG : Type u\nH : Type v\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Mul H\nf : H \u2192\u2099* G\nhf : \u2200 \u2983a b c d : H\u2984, a * b = c * d \u2192 f a = f c \u2227 f b = f d \u2192 a = c \u2227 b = d\ninst\u271d : UniqueProds G\nA B : Finset H\nA0 : A.Nonempty\nB0 : B.Nonempty\na' : H\nha' : a' \u2208 A\nha0 : f a' \u2208 image (\u21d1f) A\nb' : H\nhb' : b' \u2208 B\nhb0 : f b' \u2208 image (\u21d1f) B\nh : UniqueMul (image (\u21d1f) A) (image (\u21d1f) B) (f a') (f b')\n\u22a2 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean", "full_name": "linearIndependent_of_ne_zero_of_inner_eq_zero", "start": [714, 1], "end": [726, 26], "traced_tactics": [{"tactic": "rw [linearIndependent_iff']", "annotated_tactic": ["rw [<a>linearIndependent_iff'</a>]", [{"full_name": "linearIndependent_iff'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [130, 9], "def_end_pos": [130, 31]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\n\u22a2 LinearIndependent \ud835\udd5c v", "state_after": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\n\u22a2 \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 \ud835\udd5c), \u2211 i in s, g i \u2022 v i = 0 \u2192 \u2200 i \u2208 s, g i = 0"}, {"tactic": "intro s g hg i hi", "annotated_tactic": ["intro s g hg i hi", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\n\u22a2 \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 \ud835\udd5c), \u2211 i in s, g i \u2022 v i = 0 \u2192 \u2200 i \u2208 s, g i = 0", "state_after": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 g i = 0"}, {"tactic": "simpa [hg, hz] using h'", "annotated_tactic": ["simpa [hg, hz] using h'", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\nh' : g i * \u27eav i, v i\u27eb_\ud835\udd5c = \u27eav i, \u2211 j in s, g j \u2022 v j\u27eb_\ud835\udd5c\n\u22a2 g i = 0", "state_after": "no goals"}, {"tactic": "rw [inner_sum]", "annotated_tactic": ["rw [<a>inner_sum</a>]", [{"full_name": "inner_sum", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [515, 9], "def_end_pos": [515, 18]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 g i * \u27eav i, v i\u27eb_\ud835\udd5c = \u27eav i, \u2211 j in s, g j \u2022 v j\u27eb_\ud835\udd5c", "state_after": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 g i * \u27eav i, v i\u27eb_\ud835\udd5c = \u2211 i_1 in s, \u27eav i, g i_1 \u2022 v i_1\u27eb_\ud835\udd5c"}, {"tactic": "symm", "annotated_tactic": ["symm", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 g i * \u27eav i, v i\u27eb_\ud835\udd5c = \u2211 i_1 in s, \u27eav i, g i_1 \u2022 v i_1\u27eb_\ud835\udd5c", "state_after": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 \u2211 i_1 in s, \u27eav i, g i_1 \u2022 v i_1\u27eb_\ud835\udd5c = g i * \u27eav i, v i\u27eb_\ud835\udd5c"}, {"tactic": "convert Finset.sum_eq_single (\u03b2 := \ud835\udd5c) i ?_ ?_", "annotated_tactic": ["convert <a>Finset.sum_eq_single</a> (\u03b2 := \ud835\udd5c) i ?_ ?_", [{"full_name": "Finset.sum_eq_single", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [946, 3], "def_end_pos": [946, 14]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 \u2211 i_1 in s, \u27eav i, g i_1 \u2022 v i_1\u27eb_\ud835\udd5c = g i * \u27eav i, v i\u27eb_\ud835\udd5c", "state_after": "case h.e'_3\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 g i * \u27eav i, v i\u27eb_\ud835\udd5c = \u27eav i, g i \u2022 v i\u27eb_\ud835\udd5c\n\ncase convert_3\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 \u2200 b \u2208 s, b \u2260 i \u2192 \u27eav i, g b \u2022 v b\u27eb_\ud835\udd5c = 0\n\ncase convert_4\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 i \u2209 s \u2192 \u27eav i, g i \u2022 v i\u27eb_\ud835\udd5c = 0"}, {"tactic": "rw [inner_smul_right]", "annotated_tactic": ["rw [<a>inner_smul_right</a>]", [{"full_name": "inner_smul_right", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [478, 9], "def_end_pos": [478, 25]}]], "state_before": "case h.e'_3\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 g i * \u27eav i, v i\u27eb_\ud835\udd5c = \u27eav i, g i \u2022 v i\u27eb_\ud835\udd5c", "state_after": "no goals"}, {"tactic": "intro j _hj hji", "annotated_tactic": ["intro j _hj hji", []], "state_before": "case convert_3\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 \u2200 b \u2208 s, b \u2260 i \u2192 \u27eav i, g b \u2022 v b\u27eb_\ud835\udd5c = 0", "state_after": "case convert_3\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\nj : \u03b9\n_hj : j \u2208 s\nhji : j \u2260 i\n\u22a2 \u27eav i, g j \u2022 v j\u27eb_\ud835\udd5c = 0"}, {"tactic": "rw [inner_smul_right, ho hji.symm, mul_zero]", "annotated_tactic": ["rw [<a>inner_smul_right</a>, ho hji.symm, <a>mul_zero</a>]", [{"full_name": "inner_smul_right", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [478, 9], "def_end_pos": [478, 25]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}]], "state_before": "case convert_3\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\nj : \u03b9\n_hj : j \u2208 s\nhji : j \u2260 i\n\u22a2 \u27eav i, g j \u2022 v j\u27eb_\ud835\udd5c = 0", "state_after": "no goals"}, {"tactic": "exact fun h => False.elim (h hi)", "annotated_tactic": ["exact fun h => <a>False.elim</a> (h hi)", [{"full_name": "False.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [236, 21], "def_end_pos": [236, 31]}]], "state_before": "case convert_4\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : IsROrC \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhz : \u2200 (i : \u03b9), v i \u2260 0\nho : Pairwise fun i j => \u27eav i, v j\u27eb_\ud835\udd5c = 0\ns : Finset \u03b9\ng : \u03b9 \u2192 \ud835\udd5c\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhi : i \u2208 s\n\u22a2 i \u2209 s \u2192 \u27eav i, g i \u2022 v i\u27eb_\ud835\udd5c = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/LiminfLimsup.lean", "full_name": "Filter.isBounded_bot", "start": [77, 1], "end": [77, 100], "traced_tactics": [{"tactic": "simp [IsBounded, exists_true_iff_nonempty]", "annotated_tactic": ["simp [<a>IsBounded</a>, <a>exists_true_iff_nonempty</a>]", [{"full_name": "Filter.IsBounded", "def_path": ".lake/packages/mathlib/Mathlib/Order/LiminfLimsup.lean", "def_pos": [53, 5], "def_end_pos": [53, 14]}, {"full_name": "exists_true_iff_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nonempty.lean", "def_pos": [44, 9], "def_end_pos": [44, 33]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : Filter \u03b1\n\u22a2 IsBounded r \u22a5 \u2194 Nonempty \u03b1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Bornology/Absorbs.lean", "full_name": "Absorbs.zero", "start": [144, 1], "end": [145, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "norm_iteratedFDeriv_fderiv", "start": [1647, 1], "end": [1650, 83], "traced_tactics": [{"tactic": "rw [iteratedFDeriv_succ_eq_comp_right, comp_apply, LinearIsometryEquiv.norm_map]", "annotated_tactic": ["rw [<a>iteratedFDeriv_succ_eq_comp_right</a>, <a>comp_apply</a>, <a>LinearIsometryEquiv.norm_map</a>]", [{"full_name": "iteratedFDeriv_succ_eq_comp_right", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "def_pos": [1640, 9], "def_end_pos": [1640, 42]}, {"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}, {"full_name": "LinearIsometryEquiv.norm_map", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "def_pos": [614, 9], "def_end_pos": [614, 17]}]], "state_before": "\ud835\udd5c : Type u\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type uF\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type uG\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nX : Type uX\ninst\u271d\u00b9 : NormedAddCommGroup X\ninst\u271d : NormedSpace \ud835\udd5c X\ns s\u2081 t u : Set E\nf f\u2081 : E \u2192 F\ng : F \u2192 G\nx x\u2080 : E\nc : F\nm n\u271d : \u2115\u221e\np : E \u2192 FormalMultilinearSeries \ud835\udd5c E F\nn : \u2115\n\u22a2 \u2016iteratedFDeriv \ud835\udd5c n (fderiv \ud835\udd5c f) x\u2016 = \u2016iteratedFDeriv \ud835\udd5c (n + 1) f x\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "measurableSet_quotient", "start": [541, 1], "end": [543, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units/Equiv.lean", "full_name": "Equiv.divRight_eq_mulRight_inv", "start": [221, 1], "end": [222, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENat/Basic.lean", "full_name": "ENat.toNat_top", "start": [118, 1], "end": [119, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Irrational.lean", "full_name": "irrational_rat_add_iff", "start": [526, 1], "end": [527, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.union_distrib_iInter\u2082_right", "start": [1416, 1], "end": [1417, 93], "traced_tactics": [{"tactic": "simp_rw [union_distrib_iInter_right]", "annotated_tactic": ["simp_rw [<a>union_distrib_iInter_right</a>]", [{"full_name": "Set.union_distrib_iInter_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1410, 9], "def_end_pos": [1410, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\nt : Set \u03b1\n\u22a2 (\u22c2 i, \u22c2 j, s i j) \u222a t = \u22c2 i, \u22c2 j, s i j \u222a t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.map_comp_map", "start": [86, 1], "end": [88, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "WithTop.pred_coe", "start": [1109, 1], "end": [1110, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/UniformGroup.lean", "full_name": "Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped", "start": [370, 1], "end": [374, 18], "traced_tactics": [{"tactic": "rw [uniformity_eq_comap_inv_mul_nhds_one_swapped]", "annotated_tactic": ["rw [<a>uniformity_eq_comap_inv_mul_nhds_one_swapped</a>]", [{"full_name": "uniformity_eq_comap_inv_mul_nhds_one_swapped", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/UniformGroup.lean", "def_pos": [333, 9], "def_end_pos": [333, 53]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : UniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : HasBasis (\ud835\udcdd 1) p U\n\u22a2 HasBasis (\ud835\udce4 \u03b1) p fun i => {x | x.2\u207b\u00b9 * x.1 \u2208 U i}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : UniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : HasBasis (\ud835\udcdd 1) p U\n\u22a2 HasBasis (Filter.comap (fun x => x.2\u207b\u00b9 * x.1) (\ud835\udcdd 1)) p fun i => {x | x.2\u207b\u00b9 * x.1 \u2208 U i}"}, {"tactic": "exact h.comap _", "annotated_tactic": ["exact h.comap _", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : UniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : HasBasis (\ud835\udcdd 1) p U\n\u22a2 HasBasis (Filter.comap (fun x => x.2\u207b\u00b9 * x.1) (\ud835\udcdd 1)) p fun i => {x | x.2\u207b\u00b9 * x.1 \u2208 U i}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Algebraic.lean", "full_name": "Algebra.IsAlgebraic.of_injective", "start": [161, 1], "end": [163, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/T5.lean", "full_name": "Set.compl_section_ordSeparatingSet_mem_nhds", "start": [74, 1], "end": [79, 63], "traced_tactics": [{"tactic": "rw [\u2190 nhds_left_sup_nhds_right, mem_sup]", "annotated_tactic": ["rw [\u2190 <a>nhds_left_sup_nhds_right</a>, <a>mem_sup</a>]", [{"full_name": "nhds_left_sup_nhds_right", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/LeftRight.lean", "def_pos": [111, 9], "def_end_pos": [111, 33]}, {"full_name": "Filter.mem_sup", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [582, 9], "def_end_pos": [582, 16]}]], "state_before": "X : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na b c : X\ns t : Set X\nhd : Disjoint s (closure t)\nha : a \u2208 s\n\u22a2 (ordConnectedSection (ordSeparatingSet s t))\u1d9c \u2208 \ud835\udcdd a", "state_after": "X : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na b c : X\ns t : Set X\nhd : Disjoint s (closure t)\nha : a \u2208 s\n\u22a2 (ordConnectedSection (ordSeparatingSet s t))\u1d9c \u2208 \ud835\udcdd[\u2264] a \u2227 (ordConnectedSection (ordSeparatingSet s t))\u1d9c \u2208 \ud835\udcdd[\u2265] a"}, {"tactic": "exact\n  \u27e8compl_section_ordSeparatingSet_mem_nhdsWithin_Iic hd ha,\n    compl_section_ordSeparatingSet_mem_nhdsWithin_Ici hd ha\u27e9", "annotated_tactic": ["exact\n    \u27e8<a>compl_section_ordSeparatingSet_mem_nhdsWithin_Iic</a> hd ha,\n      <a>compl_section_ordSeparatingSet_mem_nhdsWithin_Ici</a> hd ha\u27e9", [{"full_name": "Set.compl_section_ordSeparatingSet_mem_nhdsWithin_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/T5.lean", "def_pos": [66, 9], "def_end_pos": [66, 58]}, {"full_name": "Set.compl_section_ordSeparatingSet_mem_nhdsWithin_Ici", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Order/T5.lean", "def_pos": [33, 9], "def_end_pos": [33, 58]}]], "state_before": "X : Type u_1\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : OrderTopology X\na b c : X\ns t : Set X\nhd : Disjoint s (closure t)\nha : a \u2208 s\n\u22a2 (ordConnectedSection (ordSeparatingSet s t))\u1d9c \u2208 \ud835\udcdd[\u2264] a \u2227 (ordConnectedSection (ordSeparatingSet s t))\u1d9c \u2208 \ud835\udcdd[\u2265] a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Cast/Lemmas.lean", "full_name": "Int.toNat_lt'", "start": [48, 1], "end": [49, 70], "traced_tactics": [{"tactic": "rw [\u2190 toNat_lt_toNat, toNat_coe_nat]", "annotated_tactic": ["rw [\u2190 <a>toNat_lt_toNat</a>, <a>toNat_coe_nat</a>]", [{"full_name": "Int.toNat_lt_toNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Order/Basic.lean", "def_pos": [499, 9], "def_end_pos": [499, 23]}, {"full_name": "Int.toNat_coe_nat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Defs.lean", "def_pos": [234, 15], "def_end_pos": [234, 28]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\na : \u2124\nb : \u2115\nhb : b \u2260 0\n\u22a2 toNat a < b \u2194 a < \u2191b", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\na : \u2124\nb : \u2115\nhb : b \u2260 0\n\u22a2 0 < \u2191b"}, {"tactic": "exact coe_nat_pos.2 hb.bot_lt", "annotated_tactic": ["exact <a>coe_nat_pos</a>.2 hb.bot_lt", [{"full_name": "Int.coe_nat_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [40, 9], "def_end_pos": [40, 20]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\na : \u2124\nb : \u2115\nhb : b \u2260 0\n\u22a2 0 < \u2191b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Basic.lean", "full_name": "norm_algebraMap_nnreal", "start": [321, 1], "end": [322, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Antilipschitz.lean", "full_name": "antilipschitzWith_iff_le_mul_dist", "start": [64, 1], "end": [67, 12], "traced_tactics": [{"tactic": "simp only [antilipschitzWith_iff_le_mul_nndist, dist_nndist]", "annotated_tactic": ["simp only [<a>antilipschitzWith_iff_le_mul_nndist</a>, <a>dist_nndist</a>]", [{"full_name": "antilipschitzWith_iff_le_mul_nndist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Antilipschitz.lean", "def_pos": [53, 9], "def_end_pos": [53, 44]}, {"full_name": "dist_nndist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [300, 9], "def_end_pos": [300, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b2\n\u22a2 AntilipschitzWith K f \u2194 \u2200 (x y : \u03b1), dist x y \u2264 \u2191K * dist (f x) (f y)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), nndist x y \u2264 K * nndist (f x) (f y)) \u2194 \u2200 (x y : \u03b1), \u2191(nndist x y) \u2264 \u2191K * \u2191(nndist (f x) (f y))"}, {"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (x y : \u03b1), nndist x y \u2264 K * nndist (f x) (f y)) \u2194 \u2200 (x y : \u03b1), \u2191(nndist x y) \u2264 \u2191K * \u2191(nndist (f x) (f y))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Digits.lean", "full_name": "Nat.digits_of_lt", "start": [140, 1], "end": [143, 79], "traced_tactics": [{"tactic": "rcases exists_eq_succ_of_ne_zero hx with \u27e8x, rfl\u27e9", "annotated_tactic": ["rcases <a>exists_eq_succ_of_ne_zero</a> hx with \u27e8x, rfl\u27e9", [{"full_name": "Nat.exists_eq_succ_of_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [144, 9], "def_end_pos": [144, 34]}]], "state_before": "n b x : \u2115\nhx : x \u2260 0\nhxb : x < b\n\u22a2 digits b x = [x]", "state_after": "case intro\nn b x : \u2115\nhx : succ x \u2260 0\nhxb : succ x < b\n\u22a2 digits b (succ x) = [succ x]"}, {"tactic": "rcases Nat.exists_eq_add_of_le' ((Nat.le_add_left 1 x).trans_lt hxb) with \u27e8b, rfl\u27e9", "annotated_tactic": ["rcases <a>Nat.exists_eq_add_of_le'</a> ((<a>Nat.le_add_left</a> 1 x).<a>trans_lt</a> hxb) with \u27e8b, rfl\u27e9", [{"full_name": "Nat.exists_eq_add_of_le'", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [325, 19], "def_end_pos": [325, 39]}, {"full_name": "Nat.le_add_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [337, 9], "def_end_pos": [337, 20]}, {"full_name": "LE.le.trans_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [121, 7], "def_end_pos": [121, 21]}]], "state_before": "case intro\nn b x : \u2115\nhx : succ x \u2260 0\nhxb : succ x < b\n\u22a2 digits b (succ x) = [succ x]", "state_after": "case intro.intro\nn x : \u2115\nhx : succ x \u2260 0\nb : \u2115\nhxb : succ x < b + succ 1\n\u22a2 digits (b + succ 1) (succ x) = [succ x]"}, {"tactic": "rw [digits_add_two_add_one, div_eq_of_lt hxb, digits_zero, mod_eq_of_lt hxb]", "annotated_tactic": ["rw [<a>digits_add_two_add_one</a>, <a>div_eq_of_lt</a> hxb, <a>digits_zero</a>, <a>mod_eq_of_lt</a> hxb]", [{"full_name": "Nat.digits_add_two_add_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [122, 9], "def_end_pos": [122, 31]}, {"full_name": "Nat.div_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [305, 9], "def_end_pos": [305, 21]}, {"full_name": "Nat.digits_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [112, 9], "def_end_pos": [112, 21]}]], "state_before": "case intro.intro\nn x : \u2115\nhx : succ x \u2260 0\nb : \u2115\nhxb : succ x < b + succ 1\n\u22a2 digits (b + succ 1) (succ x) = [succ x]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "codisjoint_self", "start": [272, 1], "end": [273, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.image_add_right_Ioo", "start": [1164, 1], "end": [1165, 80], "traced_tactics": [{"tactic": "rw [\u2190 map_add_right_Ioo, map_eq_image, addRightEmbedding, Embedding.coeFn_mk]", "annotated_tactic": ["rw [\u2190 <a>map_add_right_Ioo</a>, <a>map_eq_image</a>, <a>addRightEmbedding</a>, <a>Embedding.coeFn_mk</a>]", [{"full_name": "Finset.map_add_right_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/LocallyFinite/Basic.lean", "def_pos": [1123, 9], "def_end_pos": [1123, 26]}, {"full_name": "Finset.map_eq_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [373, 9], "def_end_pos": [373, 21]}, {"full_name": "addRightEmbedding", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Embedding.lean", "def_pos": [35, 3], "def_end_pos": [35, 14]}, {"full_name": "Function.Embedding.coeFn_mk", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b2 : ExistsAddOfLE \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : DecidableEq \u03b1\na b c : \u03b1\n\u22a2 image (fun x => x + c) (Ioo a b) = Ioo (a + c) (b + c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "isCompl_top_bot", "start": [644, 1], "end": [645, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Basic.lean", "full_name": "LinearMap.isLinear", "start": [308, 1], "end": [309, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupIndep.lean", "full_name": "Finset.SupIndep.pairwiseDisjoint", "start": [87, 1], "end": [89, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_pow", "start": [1690, 1], "end": [1691, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometryEquiv.ext", "start": [594, 1], "end": [595, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.set_lintegral_eq_const", "start": [807, 1], "end": [812, 39], "traced_tactics": [{"tactic": "have : \u2200\u1d50 x \u2202\u03bc, x \u2208 { x | f x = r } \u2192 f x = r := ae_of_all \u03bc fun _ hx => hx", "annotated_tactic": ["have : \u2200\u1d50 x \u2202\u03bc, x \u2208 { x | f x = r } \u2192 f x = r := <a>ae_of_all</a> \u03bc fun _ hx => hx", [{"full_name": "MeasureTheory.ae_of_all", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [407, 9], "def_end_pos": [407, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\nr : \u211d\u22650\u221e\n\u22a2 \u222b\u207b (x : \u03b1) in {x | f x = r}, f x \u2202\u03bc = r * \u2191\u2191\u03bc {x | f x = r}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\nr : \u211d\u22650\u221e\nthis : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 {x | f x = r} \u2192 f x = r\n\u22a2 \u222b\u207b (x : \u03b1) in {x | f x = r}, f x \u2202\u03bc = r * \u2191\u2191\u03bc {x | f x = r}"}, {"tactic": "rw [set_lintegral_congr_fun _ this]", "annotated_tactic": ["rw [<a>set_lintegral_congr_fun</a> _ this]", [{"full_name": "MeasureTheory.set_lintegral_congr_fun", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [317, 9], "def_end_pos": [317, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\nr : \u211d\u22650\u221e\nthis : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 {x | f x = r} \u2192 f x = r\n\u22a2 \u222b\u207b (x : \u03b1) in {x | f x = r}, f x \u2202\u03bc = r * \u2191\u2191\u03bc {x | f x = r}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\nr : \u211d\u22650\u221e\nthis : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 {x | f x = r} \u2192 f x = r\n\u22a2 \u222b\u207b (x : \u03b1) in {x | f x = r}, r \u2202\u03bc = r * \u2191\u2191\u03bc {x | f x = r}\n\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\nr : \u211d\u22650\u221e\nthis : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 {x | f x = r} \u2192 f x = r\n\u22a2 MeasurableSet {x | f x = r}"}, {"tactic": "rw [lintegral_const, Measure.restrict_apply MeasurableSet.univ, Set.univ_inter]", "annotated_tactic": ["rw [<a>lintegral_const</a>, <a>Measure.restrict_apply</a> <a>MeasurableSet.univ</a>, <a>Set.univ_inter</a>]", [{"full_name": "MeasureTheory.lintegral_const", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [138, 9], "def_end_pos": [138, 24]}, {"full_name": "MeasureTheory.Measure.restrict_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [74, 9], "def_end_pos": [74, 23]}, {"full_name": "MeasurableSet.univ", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [102, 19], "def_end_pos": [102, 37]}, {"full_name": "Set.univ_inter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [988, 9], "def_end_pos": [988, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\nr : \u211d\u22650\u221e\nthis : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 {x | f x = r} \u2192 f x = r\n\u22a2 \u222b\u207b (x : \u03b1) in {x | f x = r}, r \u2202\u03bc = r * \u2191\u2191\u03bc {x | f x = r}\n\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\nr : \u211d\u22650\u221e\nthis : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 {x | f x = r} \u2192 f x = r\n\u22a2 MeasurableSet {x | f x = r}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\nr : \u211d\u22650\u221e\nthis : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 {x | f x = r} \u2192 f x = r\n\u22a2 MeasurableSet {x | f x = r}"}, {"tactic": "exact hf (measurableSet_singleton r)", "annotated_tactic": ["exact hf (<a>measurableSet_singleton</a> r)", [{"full_name": "MeasurableSingletonClass.measurableSet_singleton", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [278, 3], "def_end_pos": [278, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : Measurable f\nr : \u211d\u22650\u221e\nthis : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 {x | f x = r} \u2192 f x = r\n\u22a2 MeasurableSet {x | f x = r}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "full_name": "Summable.sigma_factor", "start": [144, 1], "end": [146, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sign.lean", "full_name": "SignType.lt_one_iff", "start": [178, 1], "end": [178, 75], "traced_tactics": [{"tactic": "cases a <;> decide", "annotated_tactic": ["cases a <;> decide", []], "state_before": "a : SignType\n\u22a2 a < 1 \u2194 a \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.eq_bot_of_subsingleton", "start": [879, 1], "end": [882, 85], "traced_tactics": [{"tactic": "rw [Subgroup.eq_bot_iff_forall]", "annotated_tactic": ["rw [<a>Subgroup.eq_bot_iff_forall</a>]", [{"full_name": "Subgroup.eq_bot_iff_forall", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [873, 9], "def_end_pos": [873, 26]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\ninst\u271d : Subsingleton \u21a5H\n\u22a2 H = \u22a5", "state_after": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\ninst\u271d : Subsingleton \u21a5H\n\u22a2 \u2200 x \u2208 H, x = 1"}, {"tactic": "intro y hy", "annotated_tactic": ["intro y hy", []], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\ninst\u271d : Subsingleton \u21a5H\n\u22a2 \u2200 x \u2208 H, x = 1", "state_after": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\ninst\u271d : Subsingleton \u21a5H\ny : G\nhy : y \u2208 H\n\u22a2 y = 1"}, {"tactic": "rw [\u2190 Subgroup.coe_mk H y hy, Subsingleton.elim (\u27e8y, hy\u27e9 : H) 1, Subgroup.coe_one]", "annotated_tactic": ["rw [\u2190 <a>Subgroup.coe_mk</a> H y hy, <a>Subsingleton.elim</a> (\u27e8y, hy\u27e9 : H) 1, <a>Subgroup.coe_one</a>]", [{"full_name": "Subgroup.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [719, 9], "def_end_pos": [719, 15]}, {"full_name": "Subsingleton.elim", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1010, 19], "def_end_pos": [1010, 36]}, {"full_name": "Subgroup.coe_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [700, 9], "def_end_pos": [700, 16]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\ninst\u271d : Subsingleton \u21a5H\ny : G\nhy : y \u2208 H\n\u22a2 y = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean", "full_name": "PowerSeries.isUnit_constantCoeff", "start": [470, 1], "end": [471, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Ultrafilter.lean", "full_name": "Ultrafilter.eq_of_le", "start": [84, 1], "end": [85, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Inseparable.lean", "full_name": "Inseparable.refl", "start": [314, 1], "end": [315, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "continuous_sigma", "start": [1655, 1], "end": [1657, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Iso.lean", "full_name": "CategoryTheory.Iso.cancel_iso_hom_left", "start": [532, 1], "end": [534, 25], "traced_tactics": [{"tactic": "simp only [cancel_epi]", "annotated_tactic": ["simp only [<a>cancel_epi</a>]", [{"full_name": "CategoryTheory.cancel_epi", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [297, 9], "def_end_pos": [297, 19]}]], "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX\u271d Y\u271d Z\u271d X Y Z : C\nf : X \u2245 Y\ng g' : Y \u27f6 Z\n\u22a2 f.hom \u226b g = f.hom \u226b g' \u2194 g = g'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/Bilinear.lean", "full_name": "ContinuousLinearMap.opNorm_le_bound\u2082", "start": [65, 1], "end": [67, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/RootsOfUnity/Basic.lean", "full_name": "IsPrimitiveRoot.pow", "start": [493, 1], "end": [501, 33], "traced_tactics": [{"tactic": "subst n", "annotated_tactic": ["subst n", []], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\nn a b : \u2115\nhn : 0 < n\nh : IsPrimitiveRoot \u03b6 n\nhprod : n = a * b\n\u22a2 IsPrimitiveRoot (\u03b6 ^ a) b", "state_after": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\n\u22a2 IsPrimitiveRoot (\u03b6 ^ a) b"}, {"tactic": "simp only [iff_def, \u2190 pow_mul, h.pow_eq_one, eq_self_iff_true, true_and_iff]", "annotated_tactic": ["simp only [<a>iff_def</a>, \u2190 <a>pow_mul</a>, h.pow_eq_one, <a>eq_self_iff_true</a>, <a>true_and_iff</a>]", [{"full_name": "IsPrimitiveRoot.iff_def", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/RootsOfUnity/Basic.lean", "def_pos": [288, 10], "def_end_pos": [288, 33]}, {"full_name": "pow_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [110, 9], "def_end_pos": [110, 16]}, {"full_name": "eq_self_iff_true", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1368, 9], "def_end_pos": [1368, 25]}, {"full_name": "true_and_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [140, 9], "def_end_pos": [140, 21]}]], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\n\u22a2 IsPrimitiveRoot (\u03b6 ^ a) b", "state_after": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\n\u22a2 \u2200 (l : \u2115), \u03b6 ^ (a * l) = 1 \u2192 b \u2223 l"}, {"tactic": "intro l hl", "annotated_tactic": ["intro l hl", []], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\n\u22a2 \u2200 (l : \u2115), \u03b6 ^ (a * l) = 1 \u2192 b \u2223 l", "state_after": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l\u271d : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\nl : \u2115\nhl : \u03b6 ^ (a * l) = 1\n\u22a2 b \u2223 l"}, {"tactic": "have ha0 : a \u2260 0 := left_ne_zero_of_mul hn.ne'", "annotated_tactic": ["have ha0 : a \u2260 0 := <a>left_ne_zero_of_mul</a> hn.ne'", [{"full_name": "left_ne_zero_of_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [51, 9], "def_end_pos": [51, 28]}]], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l\u271d : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\nl : \u2115\nhl : \u03b6 ^ (a * l) = 1\n\u22a2 b \u2223 l", "state_after": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l\u271d : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\nl : \u2115\nhl : \u03b6 ^ (a * l) = 1\nha0 : a \u2260 0\n\u22a2 b \u2223 l"}, {"tactic": "rw [\u2190 mul_dvd_mul_iff_left ha0]", "annotated_tactic": ["rw [\u2190 <a>mul_dvd_mul_iff_left</a> ha0]", [{"full_name": "mul_dvd_mul_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean", "def_pos": [48, 9], "def_end_pos": [48, 29]}]], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l\u271d : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\nl : \u2115\nhl : \u03b6 ^ (a * l) = 1\nha0 : a \u2260 0\n\u22a2 b \u2223 l", "state_after": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l\u271d : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\nl : \u2115\nhl : \u03b6 ^ (a * l) = 1\nha0 : a \u2260 0\n\u22a2 a * b \u2223 a * l"}, {"tactic": "exact h.dvd_of_pow_eq_one _ hl", "annotated_tactic": ["exact h.dvd_of_pow_eq_one _ hl", []], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nR : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\ninst\u271d : DivisionCommMonoid G\nk l\u271d : \u2115\n\u03b6 : M\nf : F\nh\u271d : IsPrimitiveRoot \u03b6 k\na b : \u2115\nhn : 0 < a * b\nh : IsPrimitiveRoot \u03b6 (a * b)\nl : \u2115\nhl : \u03b6 ^ (a * l) = 1\nha0 : a \u2260 0\n\u22a2 a * b \u2223 a * l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Group/Abs.lean", "full_name": "mabs_le_one", "start": [298, 1], "end": [299, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Bilinear.lean", "full_name": "IsBoundedBilinearMap.hasFDerivAt", "start": [78, 1], "end": [80, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "Antitone.comp_monotoneOn", "start": [705, 1], "end": [706, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.normal_subgroupOf_iff", "start": [3629, 1], "end": [3632, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Injective2.uncurry", "start": [955, 11], "end": [957, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "contDiffWithinAt_prod'", "start": [1503, 1], "end": [1506, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "full_name": "Matrix.cramerMap_is_linear", "start": [77, 1], "end": [79, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Basic.lean", "full_name": "SymmetricRel.mk_mem_comm", "start": [228, 1], "end": [230, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.sumAddHom_apply", "start": [1957, 1], "end": [1966, 43], "traced_tactics": [{"tactic": "rcases f with \u27e8f, s, hf\u27e9", "annotated_tactic": ["rcases f with \u27e8f, s, hf\u27e9", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 (sumAddHom \u03c6) f = sum f fun x => \u21d1(\u03c6 x)", "state_after": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\n\u22a2 (sumAddHom \u03c6) { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } =\n    sum { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } fun x => \u21d1(\u03c6 x)"}, {"tactic": "change (\u2211 i in _, _) = \u2211 i in Finset.filter _ _, _", "annotated_tactic": ["change (\u2211 i in _, _) = \u2211 i in <a>Finset.filter</a> _ _, _", [{"full_name": "Finset.filter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2772, 5], "def_end_pos": [2772, 11]}]], "state_before": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\n\u22a2 (sumAddHom \u03c6) { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } =\n    sum { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } fun x => \u21d1(\u03c6 x)", "state_after": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\n\u22a2 \u2211 i in Multiset.toFinset \u2191{ val := s, property := hf },\n      (\u03c6 i) ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i) =\n    \u2211 i in\n      Finset.filter (fun i => { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i \u2260 0)\n        (Multiset.toFinset \u2191{ val := s, property := hf }),\n      (fun x => \u21d1(\u03c6 x)) i ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i)"}, {"tactic": "rw [Finset.sum_filter, Finset.sum_congr rfl]", "annotated_tactic": ["rw [<a>Finset.sum_filter</a>, <a>Finset.sum_congr</a> <a>rfl</a>]", [{"full_name": "Finset.sum_filter", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [919, 3], "def_end_pos": [919, 14]}, {"full_name": "Finset.sum_congr", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [381, 3], "def_end_pos": [381, 14]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\n\u22a2 \u2211 i in Multiset.toFinset \u2191{ val := s, property := hf },\n      (\u03c6 i) ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i) =\n    \u2211 i in\n      Finset.filter (fun i => { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i \u2260 0)\n        (Multiset.toFinset \u2191{ val := s, property := hf }),\n      (fun x => \u21d1(\u03c6 x)) i ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i)", "state_after": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\n\u22a2 \u2200 x \u2208 Multiset.toFinset \u2191{ val := s, property := hf },\n    (\u03c6 x) ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } x) =\n      if { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } x \u2260 0 then\n        (fun x => \u21d1(\u03c6 x)) x ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } x)\n      else 0"}, {"tactic": "intro i _", "annotated_tactic": ["intro i _", []], "state_before": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\n\u22a2 \u2200 x \u2208 Multiset.toFinset \u2191{ val := s, property := hf },\n    (\u03c6 x) ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } x) =\n      if { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } x \u2260 0 then\n        (fun x => \u21d1(\u03c6 x)) x ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } x)\n      else 0", "state_after": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset \u2191{ val := s, property := hf }\n\u22a2 (\u03c6 i) ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i) =\n    if { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i \u2260 0 then\n      (fun x => \u21d1(\u03c6 x)) i ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i)\n    else 0"}, {"tactic": "dsimp only [coe_mk', Subtype.coe_mk] at *", "annotated_tactic": ["dsimp only [<a>coe_mk'</a>, <a>Subtype.coe_mk</a>] at *", [{"full_name": "DFinsupp.coe_mk'", "def_path": ".lake/packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [124, 26], "def_end_pos": [124, 33]}, {"full_name": "Subtype.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [99, 9], "def_end_pos": [99, 15]}]], "state_before": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset \u2191{ val := s, property := hf }\n\u22a2 (\u03c6 i) ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i) =\n    if { toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i \u2260 0 then\n      (fun x => \u21d1(\u03c6 x)) i ({ toFun := f, support' := Quot.mk Setoid.r { val := s, property := hf } } i)\n    else 0", "state_after": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset s\n\u22a2 (\u03c6 i) (f i) = if f i \u2260 0 then (\u03c6 i) (f i) else 0"}, {"tactic": "split_ifs with h", "annotated_tactic": ["split_ifs with h", []], "state_before": "case mk'.mk.mk\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset s\n\u22a2 (\u03c6 i) (f i) = if f i \u2260 0 then (\u03c6 i) (f i) else 0", "state_after": "case pos\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset s\nh : f i \u2260 0\n\u22a2 (\u03c6 i) (f i) = (\u03c6 i) (f i)\n\ncase neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset s\nh : \u00acf i \u2260 0\n\u22a2 (\u03c6 i) (f i) = 0"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case pos\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset s\nh : f i \u2260 0\n\u22a2 (\u03c6 i) (f i) = (\u03c6 i) (f i)\n\ncase neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset s\nh : \u00acf i \u2260 0\n\u22a2 (\u03c6 i) (f i) = 0", "state_after": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset s\nh : \u00acf i \u2260 0\n\u22a2 (\u03c6 i) (f i) = 0"}, {"tactic": "rw [not_not.mp h, AddMonoidHom.map_zero]", "annotated_tactic": ["rw [not_not.mp h, <a>AddMonoidHom.map_zero</a>]", [{"full_name": "AddMonoidHom.map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [812, 3], "def_end_pos": [812, 14]}]], "state_before": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddZeroClass (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9) \u2192 \u03b2 i \u2192+ \u03b3\nf : (i : \u03b9) \u2192 \u03b2 i\nsupport'\u271d : Trunc { s // \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0 }\ns : Multiset \u03b9\nhf : \u2200 (i : \u03b9), i \u2208 s \u2228 f i = 0\ni : \u03b9\na\u271d : i \u2208 Multiset.toFinset s\nh : \u00acf i \u2260 0\n\u22a2 (\u03c6 i) (f i) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ici_inj", "start": [986, 1], "end": [987, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearMap.neg_apply", "start": [1438, 1], "end": [1439, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Basic.lean", "full_name": "zpow_bit0", "start": [366, 1], "end": [368, 76], "traced_tactics": [{"tactic": "rw [bit0, \u2190 Int.two_mul, zpow_mul', \u2190 pow_two, \u2190 zpow_coe_nat]", "annotated_tactic": ["rw [<a>bit0</a>, \u2190 <a>Int.two_mul</a>, <a>zpow_mul'</a>, \u2190 <a>pow_two</a>, \u2190 <a>zpow_coe_nat</a>]", [{"full_name": "bit0", "def_path": ".lake/packages/mathlib/Mathlib/Init/ZeroOne.lean", "def_pos": [36, 34], "def_end_pos": [36, 38]}, {"full_name": "Int.two_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Defs.lean", "def_pos": [60, 17], "def_end_pos": [60, 24]}, {"full_name": "zpow_mul'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [360, 7], "def_end_pos": [360, 16]}, {"full_name": "pow_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [86, 32], "def_end_pos": [86, 39]}, {"full_name": "zpow_coe_nat", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [962, 9], "def_end_pos": [962, 21]}]], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : DivisionMonoid \u03b1\na\u271d b a : \u03b1\nn : \u2124\n\u22a2 a ^ bit0 n = a ^ n * a ^ n", "state_after": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : DivisionMonoid \u03b1\na\u271d b a : \u03b1\nn : \u2124\n\u22a2 (a ^ n) ^ 2 = (a ^ n) ^ \u21912"}, {"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : DivisionMonoid \u03b1\na\u271d b a : \u03b1\nn : \u2124\n\u22a2 (a ^ n) ^ 2 = (a ^ n) ^ \u21912", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "full_name": "Subgroup.forall_mem_zpowers", "start": [74, 1], "end": [75, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Rat.lean", "full_name": "Int.dist_cast_rat", "start": [70, 1], "end": [71, 52], "traced_tactics": [{"tactic": "rw [\u2190 Int.dist_cast_real, \u2190 Rat.dist_cast]", "annotated_tactic": ["rw [\u2190 <a>Int.dist_cast_real</a>, \u2190 <a>Rat.dist_cast</a>]", [{"full_name": "Int.dist_cast_real", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/Int.lean", "def_pos": [37, 9], "def_end_pos": [37, 23]}, {"full_name": "Rat.dist_cast", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/Rat.lean", "def_pos": [30, 9], "def_end_pos": [30, 18]}]], "state_before": "x y : \u2124\n\u22a2 dist \u2191x \u2191y = dist x y", "state_after": "x y : \u2124\n\u22a2 dist \u2191\u2191x \u2191\u2191y = dist \u2191x \u2191y"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "x y : \u2124\n\u22a2 dist \u2191\u2191x \u2191\u2191y = dist \u2191x \u2191y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "full_name": "HasFDerivWithinAt.congr", "start": [969, 1], "end": [971, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Prod.lean", "full_name": "Filter.EventuallyLE.prod_map", "start": [172, 1], "end": [175, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "full_name": "Real.log_zpow", "start": [300, 1], "end": [303, 94], "traced_tactics": [{"tactic": "induction n", "annotated_tactic": ["induction n", []], "state_before": "x\u271d y x : \u211d\nn : \u2124\n\u22a2 log (x ^ n) = \u2191n * log x", "state_after": "case ofNat\nx\u271d y x : \u211d\na\u271d : \u2115\n\u22a2 log (x ^ Int.ofNat a\u271d) = \u2191(Int.ofNat a\u271d) * log x\n\ncase negSucc\nx\u271d y x : \u211d\na\u271d : \u2115\n\u22a2 log (x ^ Int.negSucc a\u271d) = \u2191(Int.negSucc a\u271d) * log x"}, {"tactic": "rw [zpow_negSucc, log_inv, log_pow, Int.cast_negSucc, Nat.cast_add_one, neg_mul_eq_neg_mul]", "annotated_tactic": ["rw [<a>zpow_negSucc</a>, <a>log_inv</a>, <a>log_pow</a>, <a>Int.cast_negSucc</a>, <a>Nat.cast_add_one</a>, <a>neg_mul_eq_neg_mul</a>]", [{"full_name": "zpow_negSucc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [978, 9], "def_end_pos": [978, 21]}, {"full_name": "Real.log_inv", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "def_pos": [137, 9], "def_end_pos": [137, 16]}, {"full_name": "Real.log_pow", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "def_pos": [291, 9], "def_end_pos": [291, 16]}, {"full_name": "Int.cast_negSucc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [53, 9], "def_end_pos": [53, 21]}, {"full_name": "Nat.cast_add_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [135, 9], "def_end_pos": [135, 21]}, {"full_name": "neg_mul_eq_neg_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [318, 9], "def_end_pos": [318, 27]}]], "state_before": "case negSucc\nx\u271d y x : \u211d\na\u271d : \u2115\n\u22a2 log (x ^ Int.negSucc a\u271d) = \u2191(Int.negSucc a\u271d) * log x", "state_after": "no goals"}, {"tactic": "rw [Int.ofNat_eq_coe, zpow_coe_nat, log_pow, Int.cast_ofNat]", "annotated_tactic": ["rw [<a>Int.ofNat_eq_coe</a>, <a>zpow_coe_nat</a>, <a>log_pow</a>, <a>Int.cast_ofNat</a>]", [{"full_name": "Int.ofNat_eq_coe", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [71, 17], "def_end_pos": [71, 29]}, {"full_name": "zpow_coe_nat", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [962, 9], "def_end_pos": [962, 21]}, {"full_name": "Real.log_pow", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "def_pos": [291, 9], "def_end_pos": [291, 16]}, {"full_name": "Int.cast_ofNat", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}]], "state_before": "case ofNat\nx\u271d y x : \u211d\na\u271d : \u2115\n\u22a2 log (x ^ Int.ofNat a\u271d) = \u2191(Int.ofNat a\u271d) * log x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Iic_erase", "start": [723, 1], "end": [725, 75], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d : DecidableEq \u03b1\nb : \u03b1\n\u22a2 erase (Iic b) b = Iio b", "state_after": "case a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d : DecidableEq \u03b1\nb a\u271d : \u03b1\n\u22a2 a\u271d \u2208 erase (Iic b) b \u2194 a\u271d \u2208 Iio b"}, {"tactic": "simp_rw [Finset.mem_erase, mem_Iic, mem_Iio, lt_iff_le_and_ne, and_comm]", "annotated_tactic": ["simp_rw [<a>Finset.mem_erase</a>, <a>mem_Iic</a>, <a>mem_Iio</a>, <a>lt_iff_le_and_ne</a>, <a>and_comm</a>]", [{"full_name": "Finset.mem_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1922, 9], "def_end_pos": [1922, 18]}, {"full_name": "Finset.mem_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [419, 9], "def_end_pos": [419, 16]}, {"full_name": "Finset.mem_Iio", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [424, 9], "def_end_pos": [424, 16]}, {"full_name": "lt_iff_le_and_ne", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [368, 9], "def_end_pos": [368, 25]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}]], "state_before": "case a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b1\ninst\u271d : DecidableEq \u03b1\nb a\u271d : \u03b1\n\u22a2 a\u271d \u2208 erase (Iic b) b \u2194 a\u271d \u2208 Iio b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Derivative.lean", "full_name": "Polynomial.derivative_ofNat", "start": [239, 1], "end": [241, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rel.lean", "full_name": "Rel.preimage_union", "start": [239, 1], "end": [240, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.sup_union", "start": [118, 1], "end": [119, 60], "traced_tactics": [{"tactic": "simp [or_imp, forall_and]", "annotated_tactic": ["simp [<a>or_imp</a>, <a>forall_and</a>]", [{"full_name": "or_imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 15]}, {"full_name": "forall_and", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [189, 9], "def_end_pos": [189, 19]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns s\u2081 s\u2082 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b2\nc : \u03b1\n\u22a2 sup (s\u2081 \u222a s\u2082) f \u2264 c \u2194 sup s\u2081 f \u2294 sup s\u2082 f \u2264 c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "Filter.Tendsto.div_const'", "start": [1113, 1], "end": [1115, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Set.Finite.toFinset_image2", "start": [672, 1], "end": [674, 34], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d : DecidableEq \u03b3\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nhs : Set.Finite s\nht : Set.Finite t\nhf : optParam (Set.Finite (image2 f s t)) \u22ef\n\u22a2 \u2191(Finite.toFinset hf) = \u2191(image\u2082 f (Finite.toFinset hs) (Finite.toFinset ht))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Sort.lean", "full_name": "List.mergeSort_singleton", "start": [524, 1], "end": [524, 86], "traced_tactics": [{"tactic": "rw [List.mergeSort]", "annotated_tactic": ["rw [<a>List.mergeSort</a>]", [{"full_name": "List.mergeSort", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sort.lean", "def_pos": [418, 5], "def_end_pos": [418, 14]}]], "state_before": "\u03b1 : Type uu\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel r\na : \u03b1\n\u22a2 mergeSort r [a] = [a]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/SelfAdjoint.lean", "full_name": "IsSelfAdjoint.sub", "start": [145, 1], "end": [146, 66], "traced_tactics": [{"tactic": "simp only [isSelfAdjoint_iff, star_sub, hx.star_eq, hy.star_eq]", "annotated_tactic": ["simp only [<a>isSelfAdjoint_iff</a>, <a>star_sub</a>, hx.star_eq, hy.star_eq]", [{"full_name": "isSelfAdjoint_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Star/SelfAdjoint.lean", "def_pos": [77, 9], "def_end_pos": [77, 33]}, {"full_name": "star_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Star/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 17]}]], "state_before": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b9 : AddGroup R\ninst\u271d : StarAddMonoid R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\n\u22a2 IsSelfAdjoint (x - y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.offDiag_insert", "start": [691, 1], "end": [695, 14], "traced_tactics": [{"tactic": "rw [insert_eq, union_comm, offDiag_union, offDiag_singleton, union_empty, union_right_comm]", "annotated_tactic": ["rw [<a>insert_eq</a>, <a>union_comm</a>, <a>offDiag_union</a>, <a>offDiag_singleton</a>, <a>union_empty</a>, <a>union_right_comm</a>]", [{"full_name": "Set.insert_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1280, 9], "def_end_pos": [1280, 18]}, {"full_name": "Set.union_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [756, 9], "def_end_pos": [756, 19]}, {"full_name": "Set.offDiag_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [676, 9], "def_end_pos": [676, 22]}, {"full_name": "Set.offDiag_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [650, 9], "def_end_pos": [650, 26]}, {"full_name": "Set.union_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [747, 9], "def_end_pos": [747, 20]}, {"full_name": "Set.union_right_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [776, 9], "def_end_pos": [776, 25]}]], "state_before": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 offDiag (insert a s) = offDiag s \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}", "state_after": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 Disjoint s {a}"}, {"tactic": "rw [disjoint_left]", "annotated_tactic": ["rw [<a>disjoint_left</a>]", [{"full_name": "Set.disjoint_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1530, 9], "def_end_pos": [1530, 22]}]], "state_before": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 Disjoint s {a}", "state_after": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 s \u2192 a_1 \u2209 {a}"}, {"tactic": "rintro b hb (rfl : b = a)", "annotated_tactic": ["rintro b hb (rfl : b = a)", []], "state_before": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 s \u2192 a_1 \u2209 {a}", "state_after": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\nb : \u03b1\nhb : b \u2208 s\nha : b \u2209 s\n\u22a2 False"}, {"tactic": "exact ha hb", "annotated_tactic": ["exact ha hb", []], "state_before": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\nb : \u03b1\nhb : b \u2208 s\nha : b \u2209 s\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Multilinear/Basic.lean", "full_name": "ContinuousMultilinearMap.pi_apply", "start": [266, 1], "end": [269, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Dilation.lean", "full_name": "Dilation.mk_coe_of_nndist_eq", "start": [238, 1], "end": [240, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "InfHom.top_apply", "start": [716, 1], "end": [717, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.suffix_append", "start": [1854, 9], "end": [1854, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LocalizedModule.lean", "full_name": "IsLocalizedModule.iso_symm_comp", "start": [882, 1], "end": [885, 21], "traced_tactics": [{"tactic": "ext m", "annotated_tactic": ["ext m", []], "state_before": "R : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\ninst\u271d\u2079 : AddCommMonoid M''\nA : Type u_5\ninst\u271d\u2078 : CommSemiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Module A M'\ninst\u271d\u2075 : IsLocalization S A\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R M'\ninst\u271d\u00b2 : Module R M''\ninst\u271d\u00b9 : IsScalarTower R A M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\ninst\u271d : IsLocalizedModule S f\n\u22a2 \u2191(LinearEquiv.symm (iso S f)) \u2218\u2097 f = LocalizedModule.mkLinearMap S M", "state_after": "case h\nR : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\ninst\u271d\u2079 : AddCommMonoid M''\nA : Type u_5\ninst\u271d\u2078 : CommSemiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Module A M'\ninst\u271d\u2075 : IsLocalization S A\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R M'\ninst\u271d\u00b2 : Module R M''\ninst\u271d\u00b9 : IsScalarTower R A M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\ninst\u271d : IsLocalizedModule S f\nm : M\n\u22a2 (\u2191(LinearEquiv.symm (iso S f)) \u2218\u2097 f) m = (LocalizedModule.mkLinearMap S M) m"}, {"tactic": "rw [LinearMap.comp_apply, LocalizedModule.mkLinearMap_apply, LinearEquiv.coe_coe, iso_symm_apply']", "annotated_tactic": ["rw [<a>LinearMap.comp_apply</a>, <a>LocalizedModule.mkLinearMap_apply</a>, <a>LinearEquiv.coe_coe</a>, <a>iso_symm_apply'</a>]", [{"full_name": "LinearMap.comp_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 19]}, {"full_name": "LocalizedModule.mkLinearMap_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LocalizedModule.lean", "def_pos": [489, 3], "def_end_pos": [489, 8]}, {"full_name": "LinearEquiv.coe_coe", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [210, 9], "def_end_pos": [210, 16]}, {"full_name": "IsLocalizedModule.iso_symm_apply'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LocalizedModule.lean", "def_pos": [872, 9], "def_end_pos": [872, 24]}]], "state_before": "case h\nR : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\ninst\u271d\u2079 : AddCommMonoid M''\nA : Type u_5\ninst\u271d\u2078 : CommSemiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Module A M'\ninst\u271d\u2075 : IsLocalization S A\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R M'\ninst\u271d\u00b2 : Module R M''\ninst\u271d\u00b9 : IsScalarTower R A M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\ninst\u271d : IsLocalizedModule S f\nm : M\n\u22a2 (\u2191(LinearEquiv.symm (iso S f)) \u2218\u2097 f) m = (LocalizedModule.mkLinearMap S M) m", "state_after": "case h.eq1\nR : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\ninst\u271d\u2079 : AddCommMonoid M''\nA : Type u_5\ninst\u271d\u2078 : CommSemiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Module A M'\ninst\u271d\u2075 : IsLocalization S A\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R M'\ninst\u271d\u00b2 : Module R M''\ninst\u271d\u00b9 : IsScalarTower R A M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\ninst\u271d : IsLocalizedModule S f\nm : M\n\u22a2 1 \u2022 f m = f m"}, {"tactic": "exact one_smul _ _", "annotated_tactic": ["exact <a>one_smul</a> _ _", [{"full_name": "one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [481, 9], "def_end_pos": [481, 17]}]], "state_before": "case h.eq1\nR : Type u_1\ninst\u271d\u00b9\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M'\ninst\u271d\u2079 : AddCommMonoid M''\nA : Type u_5\ninst\u271d\u2078 : CommSemiring A\ninst\u271d\u2077 : Algebra R A\ninst\u271d\u2076 : Module A M'\ninst\u271d\u2075 : IsLocalization S A\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : Module R M'\ninst\u271d\u00b2 : Module R M''\ninst\u271d\u00b9 : IsScalarTower R A M'\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\ninst\u271d : IsLocalizedModule S f\nm : M\n\u22a2 1 \u2022 f m = f m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/WithTop.lean", "full_name": "WithTop.zero_lt_coe", "start": [434, 1], "end": [435, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Combination.lean", "full_name": "AffineBasis.convexHull_eq_nonneg_coord", "start": [539, 1], "end": [557, 13], "traced_tactics": [{"tactic": "rw [convexHull_range_eq_exists_affineCombination]", "annotated_tactic": ["rw [<a>convexHull_range_eq_exists_affineCombination</a>]", [{"full_name": "convexHull_range_eq_exists_affineCombination", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Convex/Combination.lean", "def_pos": [293, 9], "def_end_pos": [293, 53]}]], "state_before": "R : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\n\u22a2 (convexHull R) (Set.range \u21d1b) = {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}", "state_after": "R : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\n\u22a2 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x} =\n    {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "R : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\n\u22a2 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x} =\n    {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}", "state_after": "case h\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\n\u22a2 x \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x} \u2194\n    x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}"}, {"tactic": "refine' \u27e8_, fun hx => _\u27e9", "annotated_tactic": ["refine' \u27e8_, fun hx => _\u27e9", []], "state_before": "case h\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\n\u22a2 x \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x} \u2194\n    x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}", "state_after": "case h.refine'_1\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\n\u22a2 x \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x} \u2192\n    x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\n\ncase h.refine'_2\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\nhx : x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\n\u22a2 x \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x}"}, {"tactic": "rintro \u27e8s, w, hw\u2080, hw\u2081, rfl\u27e9 i", "annotated_tactic": ["rintro \u27e8s, w, hw\u2080, hw\u2081, rfl\u27e9 i", []], "state_before": "case h.refine'_1\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\n\u22a2 x \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x} \u2192\n    x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}", "state_after": "case h.refine'_1.intro.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i\nhw\u2081 : Finset.sum s w = 1\ni : \u03b9\n\u22a2 0 \u2264 (coord b i) ((affineCombination R s \u21d1b) w)"}, {"tactic": "by_cases hi : i \u2208 s", "annotated_tactic": ["by_cases hi : i \u2208 s", []], "state_before": "case h.refine'_1.intro.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i\nhw\u2081 : Finset.sum s w = 1\ni : \u03b9\n\u22a2 0 \u2264 (coord b i) ((affineCombination R s \u21d1b) w)", "state_after": "case pos\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i\nhw\u2081 : Finset.sum s w = 1\ni : \u03b9\nhi : i \u2208 s\n\u22a2 0 \u2264 (coord b i) ((affineCombination R s \u21d1b) w)\n\ncase neg\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i\nhw\u2081 : Finset.sum s w = 1\ni : \u03b9\nhi : i \u2209 s\n\u22a2 0 \u2264 (coord b i) ((affineCombination R s \u21d1b) w)"}, {"tactic": "rw [b.coord_apply_combination_of_mem hi hw\u2081]", "annotated_tactic": ["rw [b.coord_apply_combination_of_mem hi hw\u2081]", []], "state_before": "case pos\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i\nhw\u2081 : Finset.sum s w = 1\ni : \u03b9\nhi : i \u2208 s\n\u22a2 0 \u2264 (coord b i) ((affineCombination R s \u21d1b) w)", "state_after": "case pos\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i\nhw\u2081 : Finset.sum s w = 1\ni : \u03b9\nhi : i \u2208 s\n\u22a2 0 \u2264 w i"}, {"tactic": "exact hw\u2080 i hi", "annotated_tactic": ["exact hw\u2080 i hi", []], "state_before": "case pos\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i\nhw\u2081 : Finset.sum s w = 1\ni : \u03b9\nhi : i \u2208 s\n\u22a2 0 \u2264 w i", "state_after": "no goals"}, {"tactic": "rw [b.coord_apply_combination_of_not_mem hi hw\u2081]", "annotated_tactic": ["rw [b.coord_apply_combination_of_not_mem hi hw\u2081]", []], "state_before": "case neg\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2080 : \u2200 i \u2208 s, 0 \u2264 w i\nhw\u2081 : Finset.sum s w = 1\ni : \u03b9\nhi : i \u2209 s\n\u22a2 0 \u2264 (coord b i) ((affineCombination R s \u21d1b) w)", "state_after": "no goals"}, {"tactic": "have hx' : x \u2208 affineSpan R (range b) := by\n  rw [b.tot]\n  exact AffineSubspace.mem_top R E x", "annotated_tactic": ["have hx' : x \u2208 <a>affineSpan</a> R (<a>range</a> b) := by\n      rw [b.tot]\n      exact <a>AffineSubspace.mem_top</a> R E x", [{"full_name": "affineSpan", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [540, 5], "def_end_pos": [540, 15]}, {"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}, {"full_name": "AffineSubspace.mem_top", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [751, 9], "def_end_pos": [751, 16]}]], "state_before": "case h.refine'_2\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\nhx : x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\n\u22a2 x \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x}", "state_after": "case h.refine'_2\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\nhx : x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\nhx' : x \u2208 affineSpan R (Set.range \u21d1b)\n\u22a2 x \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x}"}, {"tactic": "obtain \u27e8s, w, hw\u2081, rfl\u27e9 := (mem_affineSpan_iff_eq_affineCombination R E).mp hx'", "annotated_tactic": ["obtain \u27e8s, w, hw\u2081, rfl\u27e9 := (<a>mem_affineSpan_iff_eq_affineCombination</a> R E).<a>mp</a> hx'", [{"full_name": "mem_affineSpan_iff_eq_affineCombination", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [1132, 9], "def_end_pos": [1132, 48]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}]], "state_before": "case h.refine'_2\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\nhx : x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\nhx' : x \u2208 affineSpan R (Set.range \u21d1b)\n\u22a2 x \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x}", "state_after": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx : (affineCombination R s \u21d1b) w \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\n\u22a2 (affineCombination R s \u21d1b) w \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x}"}, {"tactic": "refine' \u27e8s, w, _, hw\u2081, rfl\u27e9", "annotated_tactic": ["refine' \u27e8s, w, _, hw\u2081, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx : (affineCombination R s \u21d1b) w \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\n\u22a2 (affineCombination R s \u21d1b) w \u2208 {x | \u2203 s w, (\u2200 i \u2208 s, 0 \u2264 w i) \u2227 Finset.sum s w = 1 \u2227 (affineCombination R s \u21d1b) w = x}", "state_after": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx : (affineCombination R s \u21d1b) w \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\n\u22a2 \u2200 i \u2208 s, 0 \u2264 w i"}, {"tactic": "intro i hi", "annotated_tactic": ["intro i hi", []], "state_before": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx : (affineCombination R s \u21d1b) w \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\n\u22a2 \u2200 i \u2208 s, 0 \u2264 w i", "state_after": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx : (affineCombination R s \u21d1b) w \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\ni : \u03b9\nhi : i \u2208 s\n\u22a2 0 \u2264 w i"}, {"tactic": "specialize hx i", "annotated_tactic": ["specialize hx i", []], "state_before": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx : (affineCombination R s \u21d1b) w \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\ni : \u03b9\nhi : i \u2208 s\n\u22a2 0 \u2264 w i", "state_after": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\ni : \u03b9\nhi : i \u2208 s\nhx : 0 \u2264 (coord b i) ((affineCombination R s \u21d1b) w)\n\u22a2 0 \u2264 w i"}, {"tactic": "rw [b.coord_apply_combination_of_mem hi hw\u2081] at hx", "annotated_tactic": ["rw [b.coord_apply_combination_of_mem hi hw\u2081] at hx", []], "state_before": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\ni : \u03b9\nhi : i \u2208 s\nhx : 0 \u2264 (coord b i) ((affineCombination R s \u21d1b) w)\n\u22a2 0 \u2264 w i", "state_after": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\ni : \u03b9\nhi : i \u2208 s\nhx : 0 \u2264 w i\n\u22a2 0 \u2264 w i"}, {"tactic": "exact hx", "annotated_tactic": ["exact hx", []], "state_before": "case h.refine'_2.intro.intro.intro\nR : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns\u271d : Set E\ni\u271d j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw\u271d : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\ns : Finset \u03b9\nw : \u03b9 \u2192 R\nhw\u2081 : \u2211 i in s, w i = 1\nhx' : (affineCombination R s \u21d1b) w \u2208 affineSpan R (Set.range \u21d1b)\ni : \u03b9\nhi : i \u2208 s\nhx : 0 \u2264 w i\n\u22a2 0 \u2264 w i", "state_after": "no goals"}, {"tactic": "rw [b.tot]", "annotated_tactic": ["rw [b.tot]", []], "state_before": "R : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\nhx : x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\n\u22a2 x \u2208 affineSpan R (Set.range \u21d1b)", "state_after": "R : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\nhx : x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\n\u22a2 x \u2208 \u22a4"}, {"tactic": "exact AffineSubspace.mem_top R E x", "annotated_tactic": ["exact <a>AffineSubspace.mem_top</a> R E x", [{"full_name": "AffineSubspace.mem_top", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [751, 9], "def_end_pos": [751, 16]}]], "state_before": "R : Type u_1\nR' : Type u_2\nE : Type u_3\nF : Type u_4\n\u03b9\u271d : Type u_5\n\u03b9' : Type u_6\n\u03b1 : Type u_7\ninst\u271d\u2079 : LinearOrderedField R\ninst\u271d\u2078 : LinearOrderedField R'\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : LinearOrderedAddCommGroup \u03b1\ninst\u271d\u2074 : Module R E\ninst\u271d\u00b3 : Module R F\ninst\u271d\u00b2 : Module R \u03b1\ninst\u271d\u00b9 : OrderedSMul R \u03b1\ns : Set E\ni j : \u03b9\u271d\nc : R\nt : Finset \u03b9\u271d\nw : \u03b9\u271d \u2192 R\nz : \u03b9\u271d \u2192 E\ninst\u271d : Fintype \u03b9\u271d\nf : \u03b9\u271d \u2192 R\n\u03b9 : Type u_8\nb : AffineBasis \u03b9 R E\nx : E\nhx : x \u2208 {x | \u2200 (i : \u03b9), 0 \u2264 (coord b i) x}\n\u22a2 x \u2208 \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.insert_subset_insert", "start": [1146, 1], "end": [1146, 99], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.foldl_cons", "start": [1421, 1], "end": [1422, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.mem_union", "start": [737, 1], "end": [738, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "full_name": "MeasureTheory.OuterMeasure.exists_measurable_superset_forall_eq_trim", "start": [1706, 1], "end": [1712, 93], "traced_tactics": [{"tactic": "choose t hst ht h\u03bct using fun i => (\u03bc i).exists_measurable_superset_eq_trim s", "annotated_tactic": ["choose t hst ht h\u03bct using fun i => (\u03bc i).<a>exists_measurable_superset_eq_trim</a> s", [{"full_name": "MeasureTheory.OuterMeasure.exists_measurable_superset_eq_trim", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1670, 9], "def_end_pos": [1670, 43]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\n\u22a2 \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 (i : \u03b9), \u2191(\u03bc i) t = \u2191(trim (\u03bc i)) s", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nhst : \u2200 (i : \u03b9), s \u2286 t i\nht : \u2200 (i : \u03b9), MeasurableSet (t i)\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\n\u22a2 \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 (i : \u03b9), \u2191(\u03bc i) t = \u2191(trim (\u03bc i)) s"}, {"tactic": "replace hst := subset_iInter hst", "annotated_tactic": ["replace hst := <a>subset_iInter</a> hst", [{"full_name": "Set.subset_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [250, 9], "def_end_pos": [250, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nhst : \u2200 (i : \u03b9), s \u2286 t i\nht : \u2200 (i : \u03b9), MeasurableSet (t i)\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\n\u22a2 \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 (i : \u03b9), \u2191(\u03bc i) t = \u2191(trim (\u03bc i)) s", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nht : \u2200 (i : \u03b9), MeasurableSet (t i)\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\nhst : s \u2286 \u22c2 i, t i\n\u22a2 \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 (i : \u03b9), \u2191(\u03bc i) t = \u2191(trim (\u03bc i)) s"}, {"tactic": "replace ht := MeasurableSet.iInter ht", "annotated_tactic": ["replace ht := <a>MeasurableSet.iInter</a> ht", [{"full_name": "MeasurableSet.iInter", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [160, 9], "def_end_pos": [160, 29]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nht : \u2200 (i : \u03b9), MeasurableSet (t i)\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\nhst : s \u2286 \u22c2 i, t i\n\u22a2 \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 (i : \u03b9), \u2191(\u03bc i) t = \u2191(trim (\u03bc i)) s", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\nhst : s \u2286 \u22c2 i, t i\nht : MeasurableSet (\u22c2 b, t b)\n\u22a2 \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 (i : \u03b9), \u2191(\u03bc i) t = \u2191(trim (\u03bc i)) s"}, {"tactic": "refine' \u27e8\u22c2 i, t i, hst, ht, fun i => le_antisymm _ _\u27e9", "annotated_tactic": ["refine' \u27e8\u22c2 i, t i, hst, ht, fun i => <a>le_antisymm</a> _ _\u27e9", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\nhst : s \u2286 \u22c2 i, t i\nht : MeasurableSet (\u22c2 b, t b)\n\u22a2 \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 (i : \u03b9), \u2191(\u03bc i) t = \u2191(trim (\u03bc i)) s", "state_after": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\nhst : s \u2286 \u22c2 i, t i\nht : MeasurableSet (\u22c2 b, t b)\ni : \u03b9\n\u22a2 \u2191(\u03bc i) (\u22c2 i, t i) \u2264 \u2191(trim (\u03bc i)) s\n\ncase refine'_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\nhst : s \u2286 \u22c2 i, t i\nht : MeasurableSet (\u22c2 b, t b)\ni : \u03b9\n\u22a2 \u2191(trim (\u03bc i)) s \u2264 \u2191(\u03bc i) (\u22c2 i, t i)"}, {"tactic": "exacts [h\u03bct i \u25b8 (\u03bc i).mono (iInter_subset _ _), (mono' _ hst).trans_eq ((\u03bc i).trim_eq ht)]", "annotated_tactic": ["exacts [h\u03bct i \u25b8 (\u03bc i).<a>mono</a> (<a>iInter_subset</a> _ _), (<a>mono'</a> _ hst).<a>trans_eq</a> ((\u03bc i).<a>trim_eq</a> ht)]", [{"full_name": "MeasureTheory.OuterMeasure.mono", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [68, 3], "def_end_pos": [68, 7]}, {"full_name": "Set.iInter_subset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [285, 9], "def_end_pos": [285, 22]}, {"full_name": "MeasureTheory.OuterMeasure.mono'", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [96, 9], "def_end_pos": [96, 14]}, {"full_name": "LE.le.trans_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [197, 7], "def_end_pos": [197, 21]}, {"full_name": "MeasureTheory.OuterMeasure.trim_eq", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1595, 9], "def_end_pos": [1595, 16]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\nhst : s \u2286 \u22c2 i, t i\nht : MeasurableSet (\u22c2 b, t b)\ni : \u03b9\n\u22a2 \u2191(\u03bc i) (\u22c2 i, t i) \u2264 \u2191(trim (\u03bc i)) s\n\ncase refine'_2\n\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nm : OuterMeasure \u03b1\n\u03b9 : Sort u_2\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 OuterMeasure \u03b1\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b1\nh\u03bct : \u2200 (i : \u03b9), \u2191(\u03bc i) (t i) = \u2191(trim (\u03bc i)) s\nhst : s \u2286 \u22c2 i, t i\nht : MeasurableSet (\u22c2 b, t b)\ni : \u03b9\n\u22a2 \u2191(trim (\u03bc i)) s \u2264 \u2191(\u03bc i) (\u22c2 i, t i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Add.lean", "full_name": "HasDerivAt.add", "start": [60, 8], "end": [62, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Order/Basic.lean", "full_name": "Nat.pred_le_iff", "start": [200, 1], "end": [204, 30], "traced_tactics": [{"tactic": "cases m", "annotated_tactic": ["cases m", []], "state_before": "m n k l : \u2115\n\u22a2 m \u2264 succ n \u2192 pred m \u2264 n", "state_after": "case zero\nn k l : \u2115\n\u22a2 zero \u2264 succ n \u2192 pred zero \u2264 n\n\ncase succ\nn k l n\u271d : \u2115\n\u22a2 succ n\u271d \u2264 succ n \u2192 pred (succ n\u271d) \u2264 n"}, {"tactic": "exact le_of_succ_le_succ", "annotated_tactic": ["exact <a>le_of_succ_le_succ</a>", [{"full_name": "Nat.le_of_succ_le_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1694, 9], "def_end_pos": [1694, 31]}]], "state_before": "case succ\nn k l n\u271d : \u2115\n\u22a2 succ n\u271d \u2264 succ n \u2192 pred (succ n\u271d) \u2264 n", "state_after": "no goals"}, {"tactic": "exact fun _ => zero_le n", "annotated_tactic": ["exact fun _ => <a>zero_le</a> n", [{"full_name": "Nat.zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1644, 9], "def_end_pos": [1644, 20]}]], "state_before": "case zero\nn k l : \u2115\n\u22a2 zero \u2264 succ n \u2192 pred zero \u2264 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "full_name": "ContinuousMultilinearMap.le_opNorm_mul_pow_card_of_le", "start": [392, 1], "end": [394, 99], "traced_tactics": [{"tactic": "simpa only [prod_const] using f.le_opNorm_mul_prod_of_le fun i => (norm_le_pi_norm m i).trans hm", "annotated_tactic": ["simpa only [<a>prod_const</a>] using f.le_opNorm_mul_prod_of_le fun i => (<a>norm_le_pi_norm</a> m i).<a>trans</a> hm", [{"full_name": "Finset.prod_const", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1665, 9], "def_end_pos": [1665, 19]}, {"full_name": "norm_le_pi_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2643, 15], "def_end_pos": [2643, 30]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}]], "state_before": "\ud835\udd5c : Type u\n\u03b9 : Type v\n\u03b9' : Type v'\nn : \u2115\nE : \u03b9 \u2192 Type wE\nE\u2081 : \u03b9 \u2192 Type wE\u2081\nE' : \u03b9' \u2192 Type wE'\nEi : Fin (Nat.succ n) \u2192 Type wEi\nG : Type wG\nG' : Type wG'\ninst\u271d\u00b9\u2074 : Fintype \u03b9\ninst\u271d\u00b9\u00b3 : Fintype \u03b9'\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d\u00b9\u2070 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E i)\ninst\u271d\u2079 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E\u2081 i)\ninst\u271d\u2078 : (i : \u03b9) \u2192 NormedSpace \ud835\udd5c (E\u2081 i)\ninst\u271d\u2077 : (i : \u03b9') \u2192 SeminormedAddCommGroup (E' i)\ninst\u271d\u2076 : (i : \u03b9') \u2192 NormedSpace \ud835\udd5c (E' i)\ninst\u271d\u2075 : (i : Fin (Nat.succ n)) \u2192 SeminormedAddCommGroup (Ei i)\ninst\u271d\u2074 : (i : Fin (Nat.succ n)) \u2192 NormedSpace \ud835\udd5c (Ei i)\ninst\u271d\u00b3 : SeminormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\ninst\u271d\u00b9 : SeminormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nc : \ud835\udd5c\nf g : ContinuousMultilinearMap \ud835\udd5c E G\nm : (i : \u03b9) \u2192 E i\nb : \u211d\nhm : \u2016m\u2016 \u2264 b\n\u22a2 \u2016f m\u2016 \u2264 \u2016f\u2016 * b ^ Fintype.card \u03b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "full_name": "Real.cosh_log", "start": [118, 1], "end": [119, 36], "traced_tactics": [{"tactic": "rw [cosh_eq, exp_neg, exp_log hx]", "annotated_tactic": ["rw [<a>cosh_eq</a>, <a>exp_neg</a>, <a>exp_log</a> hx]", [{"full_name": "Real.cosh_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [1043, 9], "def_end_pos": [1043, 16]}, {"full_name": "Real.exp_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [850, 16], "def_end_pos": [850, 23]}, {"full_name": "Real.exp_log", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 16]}]], "state_before": "x\u271d y x : \u211d\nhx : 0 < x\n\u22a2 cosh (log x) = (x + x\u207b\u00b9) / 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rat/Lemmas.lean", "full_name": "Rat.inv_def''", "start": [175, 1], "end": [177, 36], "traced_tactics": [{"tactic": "conv_lhs => rw [\u2190 @num_den q]", "annotated_tactic": ["conv_lhs => rw [\u2190 @<a>num_den</a> q]", [{"full_name": "Rat.num_den", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [113, 9], "def_end_pos": [113, 16]}]], "state_before": "q : \u211a\n\u22a2 q\u207b\u00b9 = \u2191q.den / \u2191q.num", "state_after": "q : \u211a\n\u22a2 (q.num /. \u2191q.den)\u207b\u00b9 = \u2191q.den / \u2191q.num"}, {"tactic": "rw [inv_def', divInt_eq_div]", "annotated_tactic": ["rw [<a>inv_def'</a>, <a>divInt_eq_div</a>]", [{"full_name": "Rat.inv_def'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [200, 9], "def_end_pos": [200, 17]}, {"full_name": "Rat.divInt_eq_div", "def_path": ".lake/packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [488, 9], "def_end_pos": [488, 22]}]], "state_before": "q : \u211a\n\u22a2 (q.num /. \u2191q.den)\u207b\u00b9 = \u2191q.den / \u2191q.num", "state_after": "q : \u211a\n\u22a2 \u2191\u2191q.den / \u2191q.num = \u2191q.den / \u2191q.num"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "q : \u211a\n\u22a2 \u2191\u2191q.den / \u2191q.num = \u2191q.den / \u2191q.num", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/Ring/Basic.lean", "full_name": "Mathlib.Tactic.Ring.div_pf", "start": [955, 1], "end": [956, 86], "traced_tactics": [{"tactic": "subst_vars", "annotated_tactic": ["subst_vars", []], "state_before": "u : Lean.Level\nR\u271d : Type ?u.204218\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d\u00b9 : CommSemiring R\u271d\nR : Type u_1\ninst\u271d : DivisionRing R\na b c d : R\nx\u271d\u00b9 : b\u207b\u00b9 = c\nx\u271d : a * c = d\n\u22a2 a / b = d", "state_after": "u : Lean.Level\nR\u271d : Type ?u.204218\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d\u00b9 : CommSemiring R\u271d\nR : Type u_1\ninst\u271d : DivisionRing R\na b : R\n\u22a2 a / b = a * b\u207b\u00b9"}, {"tactic": "simp [div_eq_mul_inv]", "annotated_tactic": ["simp [<a>div_eq_mul_inv</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}]], "state_before": "u : Lean.Level\nR\u271d : Type ?u.204218\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d\u00b9 : CommSemiring R\u271d\nR : Type u_1\ninst\u271d : DivisionRing R\na b : R\n\u22a2 a / b = a * b\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.map_sub_range'", "start": [2134, 1], "end": [2138, 42], "traced_tactics": [{"tactic": "conv => lhs; rw [\u2190 Nat.add_sub_cancel' h]", "annotated_tactic": ["conv => lhs; rw [\u2190 <a>Nat.add_sub_cancel'</a> h]", [{"full_name": "Nat.add_sub_cancel'", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [243, 27], "def_end_pos": [243, 42]}]], "state_before": "step a s n : Nat\nh : a \u2264 s\n\u22a2 map (fun x => x - a) (range' s n step) = range' (s - a) n step", "state_after": "step a s n : Nat\nh : a \u2264 s\n\u22a2 map (fun x => x - a) (range' (a + (s - a)) n step) = range' (s - a) n step"}, {"tactic": "rw [\u2190 map_add_range', map_map, (?_ : _\u2218_ = _), map_id]", "annotated_tactic": ["rw [\u2190 <a>map_add_range'</a>, <a>map_map</a>, (?_ : _\u2218_ = _), <a>map_id</a>]", [{"full_name": "List.map_add_range'", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2130, 9], "def_end_pos": [2130, 23]}, {"full_name": "List.map_map", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [133, 17], "def_end_pos": [133, 24]}, {"full_name": "List.map_id", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [123, 17], "def_end_pos": [123, 23]}]], "state_before": "step a s n : Nat\nh : a \u2264 s\n\u22a2 map (fun x => x - a) (range' (a + (s - a)) n step) = range' (s - a) n step", "state_after": "step a s n : Nat\nh : a \u2264 s\n\u22a2 ((fun x => x - a) \u2218 fun x => a + x) = id"}, {"tactic": "funext x", "annotated_tactic": ["funext x", []], "state_before": "step a s n : Nat\nh : a \u2264 s\n\u22a2 ((fun x => x - a) \u2218 fun x => a + x) = id", "state_after": "case h\nstep a s n : Nat\nh : a \u2264 s\nx : Nat\n\u22a2 ((fun x => x - a) \u2218 fun x => a + x) x = id x"}, {"tactic": "apply Nat.add_sub_cancel_left", "annotated_tactic": ["apply <a>Nat.add_sub_cancel_left</a>", [{"full_name": "Nat.add_sub_cancel_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [639, 19], "def_end_pos": [639, 38]}]], "state_before": "case h\nstep a s n : Nat\nh : a \u2264 s\nx : Nat\n\u22a2 ((fun x => x - a) \u2218 fun x => a + x) x = id x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Basic.lean", "full_name": "ENNReal.ofReal_ne_top", "start": [339, 9], "end": [339, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/AddTorsor.lean", "full_name": "vadd_eq_vadd_iff_neg_add_eq_vsub", "start": [182, 1], "end": [184, 97], "traced_tactics": [{"tactic": "rw [eq_vadd_iff_vsub_eq, vadd_vsub_assoc, \u2190 add_right_inj (-v\u2081), neg_add_cancel_left, eq_comm]", "annotated_tactic": ["rw [<a>eq_vadd_iff_vsub_eq</a>, <a>vadd_vsub_assoc</a>, \u2190 <a>add_right_inj</a> (-v\u2081), <a>neg_add_cancel_left</a>, <a>eq_comm</a>]", [{"full_name": "eq_vadd_iff_vsub_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [178, 9], "def_end_pos": [178, 28]}, {"full_name": "vadd_vsub_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [116, 9], "def_end_pos": [116, 24]}, {"full_name": "add_right_inj", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [39, 3], "def_end_pos": [39, 14]}, {"full_name": "neg_add_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1166, 3], "def_end_pos": [1166, 14]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\nv\u2081 v\u2082 : G\np\u2081 p\u2082 : P\n\u22a2 v\u2081 +\u1d65 p\u2081 = v\u2082 +\u1d65 p\u2082 \u2194 -v\u2081 + v\u2082 = p\u2081 -\u1d65 p\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.inter_subset_ite", "start": [1883, 1], "end": [1884, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupIndep.lean", "full_name": "Finset.SupIndep.le_sup_iff", "start": [92, 1], "end": [96, 63], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, le_sup\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, <a>le_sup</a>\u27e9", [{"full_name": "Finset.le_sup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [111, 9], "def_end_pos": [111, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\nhs : SupIndep s f\nhts : t \u2286 s\nhi : i \u2208 s\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a5\n\u22a2 f i \u2264 sup t f \u2194 i \u2208 t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\nhs : SupIndep s f\nhts : t \u2286 s\nhi : i \u2208 s\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a5\nh : f i \u2264 sup t f\n\u22a2 i \u2208 t"}, {"tactic": "by_contra hit", "annotated_tactic": ["by_contra hit", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\nhs : SupIndep s f\nhts : t \u2286 s\nhi : i \u2208 s\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a5\nh : f i \u2264 sup t f\n\u22a2 i \u2208 t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\nhs : SupIndep s f\nhts : t \u2286 s\nhi : i \u2208 s\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a5\nh : f i \u2264 sup t f\nhit : i \u2209 t\n\u22a2 False"}, {"tactic": "exact hf i (disjoint_self.1 <| (hs hts hi hit).mono_right h)", "annotated_tactic": ["exact hf i (<a>disjoint_self</a>.1 <| (hs hts hi hit).<a>mono_right</a> h)", [{"full_name": "disjoint_self", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [84, 9], "def_end_pos": [84, 22]}, {"full_name": "Disjoint.mono_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [79, 9], "def_end_pos": [79, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns t : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\nhs : SupIndep s f\nhts : t \u2286 s\nhi : i \u2208 s\nhf : \u2200 (i : \u03b9), f i \u2260 \u22a5\nh : f i \u2264 sup t f\nhit : i \u2209 t\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Int/Order.lean", "full_name": "Int.add_neg", "start": [77, 11], "end": [78, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.exists_mem_empty_iff", "start": [3216, 1], "end": [3217, 57], "traced_tactics": [{"tactic": "simp only [not_mem_empty, false_and_iff, exists_false]", "annotated_tactic": ["simp only [<a>not_mem_empty</a>, <a>false_and_iff</a>, <a>exists_false</a>]", [{"full_name": "Finset.not_mem_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [554, 9], "def_end_pos": [554, 22]}, {"full_name": "false_and_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [144, 9], "def_end_pos": [144, 22]}, {"full_name": "exists_false", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [196, 17], "def_end_pos": [196, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : \u03b1 \u2192 Prop\n\u22a2 (\u2203 x \u2208 \u2205, p x) \u2194 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Intervals.lean", "full_name": "List.Ico.filter_lt_of_ge", "start": [168, 1], "end": [173, 51], "traced_tactics": [{"tactic": "rcases le_total n l with hnl | hln", "annotated_tactic": ["rcases <a>le_total</a> n l with hnl | hln", [{"full_name": "le_total", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [289, 9], "def_end_pos": [289, 17]}]], "state_before": "n m l : \u2115\nhlm : l \u2264 m\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n l", "state_after": "case inl\nn m l : \u2115\nhlm : l \u2264 m\nhnl : n \u2264 l\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n l\n\ncase inr\nn m l : \u2115\nhlm : l \u2264 m\nhln : l \u2264 n\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n l"}, {"tactic": "rw [\u2190 append_consecutive hnl hlm, filter_append, filter_lt_of_top_le (le_refl l),\n  filter_lt_of_le_bot (le_refl l), append_nil]", "annotated_tactic": ["rw [\u2190 <a>append_consecutive</a> hnl hlm, <a>filter_append</a>, <a>filter_lt_of_top_le</a> (<a>le_refl</a> l),\n      <a>filter_lt_of_le_bot</a> (<a>le_refl</a> l), <a>append_nil</a>]", [{"full_name": "List.Ico.append_consecutive", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Intervals.lean", "def_pos": [95, 9], "def_end_pos": [95, 27]}, {"full_name": "List.filter_append", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1296, 17], "def_end_pos": [1296, 30]}, {"full_name": "List.Ico.filter_lt_of_top_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Intervals.lean", "def_pos": [155, 9], "def_end_pos": [155, 28]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}, {"full_name": "List.Ico.filter_lt_of_le_bot", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Intervals.lean", "def_pos": [161, 9], "def_end_pos": [161, 28]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}, {"full_name": "List.append_nil", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [133, 17], "def_end_pos": [133, 27]}]], "state_before": "case inl\nn m l : \u2115\nhlm : l \u2264 m\nhnl : n \u2264 l\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n l", "state_after": "no goals"}, {"tactic": "rw [eq_nil_of_le hln, filter_lt_of_le_bot hln]", "annotated_tactic": ["rw [<a>eq_nil_of_le</a> hln, <a>filter_lt_of_le_bot</a> hln]", [{"full_name": "List.Ico.eq_nil_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Intervals.lean", "def_pos": [72, 9], "def_end_pos": [72, 21]}, {"full_name": "List.Ico.filter_lt_of_le_bot", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Intervals.lean", "def_pos": [161, 9], "def_end_pos": [161, 28]}]], "state_before": "case inr\nn m l : \u2115\nhlm : l \u2264 m\nhln : l \u2264 n\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iSup_pos", "start": [1030, 1], "end": [1031, 54], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "amc12a_2019_p9", "start": [61, 1], "end": [64, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "a : \u2115 \u2192 \u211a\nh\u2080 : a 1 = 1\nh\u2081 : a 2 = 3 / 7\nh\u2082 : \u2200 (n : \u2115), a (n + 2) = a n * a (n + 1) / (2 * a n - a (n + 1))\n\u22a2 \u2191(a 2019).den + (a 2019).num = 8078", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Multiset.lean", "full_name": "Finsupp.toMultiset_map", "start": [73, 1], "end": [81, 8], "traced_tactics": [{"tactic": "refine' f.induction _ _", "annotated_tactic": ["refine' f.induction _ _", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nf : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map g (toMultiset f) = toMultiset (mapDomain g f)", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nf : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map g (toMultiset 0) = toMultiset (mapDomain g 0)\n\ncase refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nf : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (a : \u03b1) (b : \u2115) (f : \u03b1 \u2192\u2080 \u2115),\n    a \u2209 f.support \u2192\n      b \u2260 0 \u2192\n        Multiset.map g (toMultiset f) = toMultiset (mapDomain g f) \u2192\n          Multiset.map g (toMultiset (single a b + f)) = toMultiset (mapDomain g (single a b + f))"}, {"tactic": "rw [toMultiset_zero, Multiset.map_zero, mapDomain_zero, toMultiset_zero]", "annotated_tactic": ["rw [<a>toMultiset_zero</a>, <a>Multiset.map_zero</a>, <a>mapDomain_zero</a>, <a>toMultiset_zero</a>]", [{"full_name": "Finsupp.toMultiset_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [41, 9], "def_end_pos": [41, 24]}, {"full_name": "Multiset.map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1212, 9], "def_end_pos": [1212, 17]}, {"full_name": "Finsupp.mapDomain_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [493, 9], "def_end_pos": [493, 23]}, {"full_name": "Finsupp.toMultiset_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [41, 9], "def_end_pos": [41, 24]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nf : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map g (toMultiset 0) = toMultiset (mapDomain g 0)", "state_after": "no goals"}, {"tactic": "intro a n f _ _ ih", "annotated_tactic": ["intro a n f _ _ ih", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nf : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (a : \u03b1) (b : \u2115) (f : \u03b1 \u2192\u2080 \u2115),\n    a \u2209 f.support \u2192\n      b \u2260 0 \u2192\n        Multiset.map g (toMultiset f) = toMultiset (mapDomain g f) \u2192\n          Multiset.map g (toMultiset (single a b + f)) = toMultiset (mapDomain g (single a b + f))", "state_after": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nf\u271d : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\na : \u03b1\nn : \u2115\nf : \u03b1 \u2192\u2080 \u2115\na\u271d\u00b9 : a \u2209 f.support\na\u271d : n \u2260 0\nih : Multiset.map g (toMultiset f) = toMultiset (mapDomain g f)\n\u22a2 Multiset.map g (toMultiset (single a n + f)) = toMultiset (mapDomain g (single a n + f))"}, {"tactic": "rw [toMultiset_add, Multiset.map_add, ih, mapDomain_add, mapDomain_single,\n  toMultiset_single, toMultiset_add, toMultiset_single, \u2190 Multiset.coe_mapAddMonoidHom,\n  (Multiset.mapAddMonoidHom g).map_nsmul]", "annotated_tactic": ["rw [<a>toMultiset_add</a>, <a>Multiset.map_add</a>, ih, <a>mapDomain_add</a>, <a>mapDomain_single</a>,\n      <a>toMultiset_single</a>, <a>toMultiset_add</a>, <a>toMultiset_single</a>, \u2190 <a>Multiset.coe_mapAddMonoidHom</a>,\n      (<a>Multiset.mapAddMonoidHom</a> g).<a>map_nsmul</a>]", [{"full_name": "Finsupp.toMultiset_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [45, 9], "def_end_pos": [45, 23]}, {"full_name": "Multiset.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1237, 9], "def_end_pos": [1237, 16]}, {"full_name": "Finsupp.mapDomain_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [502, 9], "def_end_pos": [502, 22]}, {"full_name": "Finsupp.mapDomain_single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [488, 9], "def_end_pos": [488, 25]}, {"full_name": "Finsupp.toMultiset_single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [54, 9], "def_end_pos": [54, 26]}, {"full_name": "Finsupp.toMultiset_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [45, 9], "def_end_pos": [45, 23]}, {"full_name": "Finsupp.toMultiset_single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [54, 9], "def_end_pos": [54, 26]}, {"full_name": "Multiset.coe_mapAddMonoidHom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1259, 9], "def_end_pos": [1259, 28]}, {"full_name": "Multiset.mapAddMonoidHom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1252, 5], "def_end_pos": [1252, 20]}, {"full_name": "AddMonoidHom.map_nsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [1075, 3], "def_end_pos": [1075, 14]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nf\u271d : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\na : \u03b1\nn : \u2115\nf : \u03b1 \u2192\u2080 \u2115\na\u271d\u00b9 : a \u2209 f.support\na\u271d : n \u2260 0\nih : Multiset.map g (toMultiset f) = toMultiset (mapDomain g f)\n\u22a2 Multiset.map g (toMultiset (single a n + f)) = toMultiset (mapDomain g (single a n + f))", "state_after": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nf\u271d : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\na : \u03b1\nn : \u2115\nf : \u03b1 \u2192\u2080 \u2115\na\u271d\u00b9 : a \u2209 f.support\na\u271d : n \u2260 0\nih : Multiset.map g (toMultiset f) = toMultiset (mapDomain g f)\n\u22a2 n \u2022 (Multiset.mapAddMonoidHom g) {a} + toMultiset (mapDomain g f) = n \u2022 {g a} + toMultiset (mapDomain g f)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nf\u271d : \u03b1 \u2192\u2080 \u2115\ng : \u03b1 \u2192 \u03b2\na : \u03b1\nn : \u2115\nf : \u03b1 \u2192\u2080 \u2115\na\u271d\u00b9 : a \u2209 f.support\na\u271d : n \u2260 0\nih : Multiset.map g (toMultiset f) = toMultiset (mapDomain g f)\n\u22a2 n \u2022 (Multiset.mapAddMonoidHom g) {a} + toMultiset (mapDomain g f) = n \u2022 {g a} + toMultiset (mapDomain g f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.list_prod_mem", "start": [335, 11], "end": [336, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/PEquiv.lean", "full_name": "PEquiv.symm_bot", "start": [308, 1], "end": [309, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.map_iSup", "start": [1577, 1], "end": [1578, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "iteratedFDerivWithin_inter", "start": [958, 1], "end": [960, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Whiskering.lean", "full_name": "CategoryTheory.whiskerRight_id'", "start": [135, 1], "end": [136, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.Disjoint.symm", "start": [50, 1], "end": [50, 98], "traced_tactics": [{"tactic": "simp only [Disjoint, or_comm, imp_self]", "annotated_tactic": ["simp only [<a>Disjoint</a>, <a>or_comm</a>, <a>imp_self</a>]", [{"full_name": "Equiv.Perm.Disjoint", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [43, 5], "def_end_pos": [43, 13]}, {"full_name": "or_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [818, 9], "def_end_pos": [818, 16]}, {"full_name": "imp_self", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1406, 17], "def_end_pos": [1406, 25]}]], "state_before": "\u03b1 : Type u_1\nf g h : Perm \u03b1\n\u22a2 Disjoint f g \u2192 Disjoint g f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/PathConnected.lean", "full_name": "Path.extend_of_le_zero", "start": [290, 1], "end": [292, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Bicategory/Basic.lean", "full_name": "CategoryTheory.Bicategory.rightUnitor_comp_inv", "start": [476, 1], "end": [477, 70], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "B : Type u\ninst\u271d : Bicategory B\na b c d e : B\nf : a \u27f6 b\ng : b \u27f6 c\n\u22a2 (\u03c1_ (f \u226b g)).inv = f \u25c1 (\u03c1_ g).inv \u226b (\u03b1_ f g (\ud835\udfd9 c)).inv", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Basic.lean", "full_name": "Filter.HasBasis.lift'_closure_eq_self", "start": [565, 1], "end": [568, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "NonUnitalRingHom.coe_toAddMonoidHom", "start": [139, 1], "end": [139, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Real.rpow_neg", "start": [243, 1], "end": [244, 70], "traced_tactics": [{"tactic": "simp only [rpow_def_of_nonneg hx]", "annotated_tactic": ["simp only [<a>rpow_def_of_nonneg</a> hx]", [{"full_name": "Real.rpow_def_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [49, 9], "def_end_pos": [49, 27]}]], "state_before": "x\u271d\u00b9 y\u271d\u00b9 z\u271d w x\u271d y\u271d z x : \u211d\nhx : 0 \u2264 x\ny : \u211d\n\u22a2 x ^ (-y) = (x ^ y)\u207b\u00b9", "state_after": "x\u271d\u00b9 y\u271d\u00b9 z\u271d w x\u271d y\u271d z x : \u211d\nhx : 0 \u2264 x\ny : \u211d\n\u22a2 (if x = 0 then if -y = 0 then 1 else 0 else rexp (log x * -y)) =\n    (if x = 0 then if y = 0 then 1 else 0 else rexp (log x * y))\u207b\u00b9"}, {"tactic": "split_ifs <;> simp_all [exp_neg]", "annotated_tactic": ["split_ifs <;> simp_all [<a>exp_neg</a>]", [{"full_name": "Real.exp_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [850, 16], "def_end_pos": [850, 23]}]], "state_before": "x\u271d\u00b9 y\u271d\u00b9 z\u271d w x\u271d y\u271d z x : \u211d\nhx : 0 \u2264 x\ny : \u211d\n\u22a2 (if x = 0 then if -y = 0 then 1 else 0 else rexp (log x * -y)) =\n    (if x = 0 then if y = 0 then 1 else 0 else rexp (log x * y))\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "disjoint_sdiff_self_left", "start": [210, 1], "end": [211, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Basic.lean", "full_name": "Complex.re_ofReal_mul", "start": [282, 1], "end": [282, 83], "traced_tactics": [{"tactic": "simp [ofReal']", "annotated_tactic": ["simp [<a>ofReal'</a>]", [{"full_name": "Complex.ofReal'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [89, 5], "def_end_pos": [89, 12]}]], "state_before": "r : \u211d\nz : \u2102\n\u22a2 (\u2191r * z).re = r * z.re", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.sup_const_le", "start": [107, 1], "end": [108, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/PrimeFin.lean", "full_name": "Nat.primeFactors_mono", "start": [43, 1], "end": [45, 49], "traced_tactics": [{"tactic": "simp only [subset_iff, mem_primeFactors, and_imp]", "annotated_tactic": ["simp only [<a>subset_iff</a>, <a>mem_primeFactors</a>, <a>and_imp</a>]", [{"full_name": "Finset.subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [376, 9], "def_end_pos": [376, 19]}, {"full_name": "Nat.mem_primeFactors", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/PrimeFin.lean", "def_pos": [37, 15], "def_end_pos": [37, 31]}, {"full_name": "and_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [108, 17], "def_end_pos": [108, 24]}]], "state_before": "a b k m n p : \u2115\nhmn : m \u2223 n\nhn : n \u2260 0\n\u22a2 m.primeFactors \u2286 n.primeFactors", "state_after": "a b k m n p : \u2115\nhmn : m \u2223 n\nhn : n \u2260 0\n\u22a2 \u2200 \u2983x : \u2115\u2984, Prime x \u2192 x \u2223 m \u2192 m \u2260 0 \u2192 Prime x \u2227 x \u2223 n \u2227 n \u2260 0"}, {"tactic": "exact fun p hp hpm _ \u21a6 \u27e8hp, hpm.trans hmn, hn\u27e9", "annotated_tactic": ["exact fun p hp hpm _ \u21a6 \u27e8hp, hpm.trans hmn, hn\u27e9", []], "state_before": "a b k m n p : \u2115\nhmn : m \u2223 n\nhn : n \u2260 0\n\u22a2 \u2200 \u2983x : \u2115\u2984, Prime x \u2192 x \u2223 m \u2192 m \u2260 0 \u2192 Prime x \u2227 x \u2223 n \u2227 n \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "normalize_lcm", "start": [754, 1], "end": [755, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.equivMapDomain_eq_mapDomain", "start": [676, 1], "end": [677, 81], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b9 : AddCommMonoid M\u271d\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\u271d\nM : Type u_13\ninst\u271d : AddCommMonoid M\nf : \u03b1 \u2243 \u03b2\nl : \u03b1 \u2192\u2080 M\n\u22a2 equivMapDomain f l = mapDomain (\u21d1f) l", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b9 : AddCommMonoid M\u271d\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\u271d\nM : Type u_13\ninst\u271d : AddCommMonoid M\nf : \u03b1 \u2243 \u03b2\nl : \u03b1 \u2192\u2080 M\nx : \u03b2\n\u22a2 (equivMapDomain f l) x = (mapDomain (\u21d1f) l) x"}, {"tactic": "simp [mapDomain_equiv_apply]", "annotated_tactic": ["simp [<a>mapDomain_equiv_apply</a>]", [{"full_name": "Finsupp.mapDomain_equiv_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [507, 9], "def_end_pos": [507, 30]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM\u271d : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b9 : AddCommMonoid M\u271d\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\u271d\nM : Type u_13\ninst\u271d : AddCommMonoid M\nf : \u03b1 \u2243 \u03b2\nl : \u03b1 \u2192\u2080 M\nx : \u03b2\n\u22a2 (equivMapDomain f l) x = (mapDomain (\u21d1f) l) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean", "full_name": "Polynomial.degreeLTEquiv_eq_zero_iff_eq_zero", "start": [174, 1], "end": [176, 57], "traced_tactics": [{"tactic": "rw [LinearEquiv.map_eq_zero_iff, Submodule.mk_eq_zero]", "annotated_tactic": ["rw [<a>LinearEquiv.map_eq_zero_iff</a>, <a>Submodule.mk_eq_zero</a>]", [{"full_name": "LinearEquiv.map_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [496, 9], "def_end_pos": [496, 24]}, {"full_name": "Submodule.mk_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [284, 9], "def_end_pos": [284, 19]}]], "state_before": "R : Type u\nS : Type u_1\ninst\u271d : Semiring R\nn : \u2115\np : R[X]\nhp : p \u2208 degreeLT R n\n\u22a2 (degreeLTEquiv R n) { val := p, property := hp } = 0 \u2194 p = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/LocalExtr.lean", "full_name": "isLocalMin_const", "start": [200, 1], "end": [201, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.diff_singleton_sSubset", "start": [2043, 1], "end": [2044, 65], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na\u271d b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\na : \u03b1\n\u22a2 \u00acDisjoint s {a} \u2194 a \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/CauSeq/Basic.lean", "full_name": "CauSeq.neg_limZero", "start": [446, 1], "end": [448, 31], "traced_tactics": [{"tactic": "rw [\u2190 neg_one_mul f]", "annotated_tactic": ["rw [\u2190 <a>neg_one_mul</a> f]", [{"full_name": "neg_one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [345, 9], "def_end_pos": [345, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf : CauSeq \u03b2 abv\nhf : LimZero f\n\u22a2 LimZero (-f)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf : CauSeq \u03b2 abv\nhf : LimZero f\n\u22a2 LimZero (-1 * f)"}, {"tactic": "exact mul_limZero_right _ hf", "annotated_tactic": ["exact <a>mul_limZero_right</a> _ hf", [{"full_name": "CauSeq.mul_limZero_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/Basic.lean", "def_pos": [430, 9], "def_end_pos": [430, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf : CauSeq \u03b2 abv\nhf : LimZero f\n\u22a2 LimZero (-1 * f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Range.lean", "full_name": "Multiset.range_add", "start": [61, 1], "end": [62, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/ConstMulAction.lean", "full_name": "IsUnit.continuousOn_const_smul_iff", "start": [422, 8], "end": [425, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/FixedPoints.lean", "full_name": "MulAction.movedBy_mem_fixedBy_of_commute", "start": [214, 1], "end": [216, 76], "traced_tactics": [{"tactic": "rw [mem_fixedBy, Set.smul_set_compl, fixedBy_mem_fixedBy_of_commute comm]", "annotated_tactic": ["rw [<a>mem_fixedBy</a>, <a>Set.smul_set_compl</a>, <a>fixedBy_mem_fixedBy_of_commute</a> comm]", [{"full_name": "MulAction.mem_fixedBy", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Basic.lean", "def_pos": [155, 9], "def_end_pos": [155, 20]}, {"full_name": "Set.smul_set_compl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [976, 9], "def_end_pos": [976, 23]}, {"full_name": "MulAction.fixedBy_mem_fixedBy_of_commute", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/FixedPoints.lean", "def_pos": [194, 9], "def_end_pos": [194, 39]}]], "state_before": "\u03b1 : Type u_1\nG : Type u_2\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : MulAction G \u03b1\nM : Type u_3\ninst\u271d\u00b9 : Monoid M\ninst\u271d : MulAction M \u03b1\ng h : G\ncomm : Commute g h\n\u22a2 (fixedBy \u03b1 g)\u1d9c \u2208 fixedBy (Set \u03b1) h", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Algebra.smul_leftMulMatrix_algebraMap_eq", "start": [975, 1], "end": [977, 61], "traced_tactics": [{"tactic": "rw [smul_leftMulMatrix_algebraMap, blockDiagonal_apply_eq]", "annotated_tactic": ["rw [<a>smul_leftMulMatrix_algebraMap</a>, <a>blockDiagonal_apply_eq</a>]", [{"full_name": "Algebra.smul_leftMulMatrix_algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "def_pos": [968, 9], "def_end_pos": [968, 38]}, {"full_name": "Matrix.blockDiagonal_apply_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Block.lean", "def_pos": [380, 9], "def_end_pos": [380, 31]}]], "state_before": "R : Type u_1\nS : Type u_2\nT : Type u_3\ninst\u271d\u00b9\u2070 : CommRing R\ninst\u271d\u2079 : CommRing S\ninst\u271d\u2078 : Ring T\ninst\u271d\u2077 : Algebra R S\ninst\u271d\u2076 : Algebra S T\ninst\u271d\u2075 : Algebra R T\ninst\u271d\u2074 : IsScalarTower R S T\nm : Type u_4\nn : Type u_5\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq n\nb : Basis m R S\nc : Basis n S T\nx : S\ni j : m\nk : n\n\u22a2 (leftMulMatrix (Basis.smul b c)) ((algebraMap S T) x) (i, k) (j, k) = (leftMulMatrix b) x i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean", "full_name": "ContinuousLinearMap.map_neg\u2082", "start": [313, 1], "end": [314, 28], "traced_tactics": [{"tactic": "rw [f.map_neg, neg_apply]", "annotated_tactic": ["rw [f.map_neg, <a>neg_apply</a>]", [{"full_name": "ContinuousLinearMap.neg_apply", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Module/Basic.lean", "def_pos": [1438, 9], "def_end_pos": [1438, 18]}]], "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9\u2075 : NormedAddCommGroup E\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9\u00b9 : NormedAddCommGroup G\ninst\u271d\u00b9\u2070 : NormedSpace \ud835\udd5c G\nR : Type u_5\n\ud835\udd5c\u2082 : Type u_6\n\ud835\udd5c' : Type u_7\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\u2082\nM : Type u_8\ninst\u271d\u2077 : TopologicalSpace M\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\nG' : Type u_9\ninst\u271d\u2076 : NormedAddCommGroup G'\ninst\u271d\u2075 : NormedSpace \ud835\udd5c\u2082 G'\ninst\u271d\u2074 : NormedSpace \ud835\udd5c' G'\ninst\u271d\u00b3 : SMulCommClass \ud835\udd5c\u2082 \ud835\udd5c' G'\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u03c1\u2081\u2082 : R \u2192+* \ud835\udd5c'\nf : M \u2192SL[\u03c1\u2081\u2082] F \u2192SL[\u03c3\u2081\u2082] G'\nx : M\ny : F\n\u22a2 (f (-x)) y = -(f x) y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sum/Order.lean", "full_name": "Sum.Lex.inr_top", "start": [457, 1], "end": [458, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecificLimits/Normed.lean", "full_name": "hasSum_coe_mul_geometric_of_norm_lt_one", "start": [363, 1], "end": [381, 95], "traced_tactics": [{"tactic": "have A : Summable (fun n \u21a6 (n : \ud835\udd5c) * r ^ n : \u2115 \u2192 \ud835\udd5c) := by\n  simpa only [pow_one] using summable_pow_mul_geometric_of_norm_lt_one 1 hr", "annotated_tactic": ["have A : <a>Summable</a> (fun n \u21a6 (n : \ud835\udd5c) * r ^ n : \u2115 \u2192 \ud835\udd5c) := by\n    simpa only [<a>pow_one</a>] using <a>summable_pow_mul_geometric_of_norm_lt_one</a> 1 hr", [{"full_name": "Summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [64, 5], "def_end_pos": [64, 13]}, {"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}, {"full_name": "summable_pow_mul_geometric_of_norm_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecificLimits/Normed.lean", "def_pos": [355, 9], "def_end_pos": [355, 50]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\n\u22a2 HasSum (fun n => \u2191n * r ^ n) (r / (1 - r) ^ 2)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\n\u22a2 HasSum (fun n => \u2191n * r ^ n) (r / (1 - r) ^ 2)"}, {"tactic": "refine' A.hasSum_iff.2 _", "annotated_tactic": ["refine' A.hasSum_iff.2 _", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\n\u22a2 HasSum (fun n => \u2191n * r ^ n) (r / (1 - r) ^ 2)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\n\u22a2 \u2211' (b : \u2115), \u2191b * r ^ b = r / (1 - r) ^ 2"}, {"tactic": "have hr' : r \u2260 1 := by\n  rintro rfl\n  simp [lt_irrefl] at hr", "annotated_tactic": ["have hr' : r \u2260 1 := by\n    rintro rfl\n    simp [<a>lt_irrefl</a>] at hr", [{"full_name": "lt_irrefl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [73, 9], "def_end_pos": [73, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\n\u22a2 \u2211' (b : \u2115), \u2191b * r ^ b = r / (1 - r) ^ 2", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\nhr' : r \u2260 1\n\u22a2 \u2211' (b : \u2115), \u2191b * r ^ b = r / (1 - r) ^ 2"}, {"tactic": "set s : \ud835\udd5c := \u2211' n : \u2115, n * r ^ n", "annotated_tactic": ["set s : \ud835\udd5c := \u2211' n : \u2115, n * r ^ n", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\nhr' : r \u2260 1\n\u22a2 \u2211' (b : \u2115), \u2191b * r ^ b = r / (1 - r) ^ 2", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\nhr' : r \u2260 1\ns : \ud835\udd5c := \u2211' (n : \u2115), \u2191n * r ^ n\n\u22a2 s = r / (1 - r) ^ 2"}, {"tactic": "calc\n  s = (1 - r) * s / (1 - r) := (mul_div_cancel_left _ (sub_ne_zero.2 hr'.symm)).symm\n  _ = (s - r * s) / (1 - r) := by rw [_root_.sub_mul, one_mul]\n  _ = (((0 : \u2115) * r ^ 0 + \u2211' n : \u2115, (n + 1 : \u2115) * r ^ (n + 1)) - r * s) / (1 - r) := by\n    rw [\u2190 tsum_eq_zero_add A]\n  _ = ((r * \u2211' n : \u2115, (n + 1) * r ^ n) - r * s) / (1 - r) := by\n    simp [_root_.pow_succ, mul_left_comm _ r, _root_.tsum_mul_left]\n  _ = r / (1 - r) ^ 2 := by\n    simp [add_mul, tsum_add A B.summable, mul_add, B.tsum_eq, \u2190 div_eq_mul_inv, sq, div_div]", "annotated_tactic": ["calc\n    s = (1 - r) * s / (1 - r) := (<a>mul_div_cancel_left</a> _ (<a>sub_ne_zero</a>.2 hr'.symm)).<a>symm</a>\n    _ = (s - r * s) / (1 - r) := by rw [<a>_root_.sub_mul</a>, <a>one_mul</a>]\n    _ = (((0 : \u2115) * r ^ 0 + \u2211' n : \u2115, (n + 1 : \u2115) * r ^ (n + 1)) - r * s) / (1 - r) := by\n      rw [\u2190 <a>tsum_eq_zero_add</a> A]\n    _ = ((r * \u2211' n : \u2115, (n + 1) * r ^ n) - r * s) / (1 - r) := by\n      simp [<a>_root_.pow_succ</a>, <a>mul_left_comm</a> _ r, <a>_root_.tsum_mul_left</a>]\n    _ = r / (1 - r) ^ 2 := by\n      simp [<a>add_mul</a>, <a>tsum_add</a> A B.summable, <a>mul_add</a>, B.tsum_eq, \u2190 <a>div_eq_mul_inv</a>, <a>sq</a>, <a>div_div</a>]", [{"full_name": "mul_div_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [446, 7], "def_end_pos": [446, 26]}, {"full_name": "sub_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [892, 3], "def_end_pos": [892, 14]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}, {"full_name": "sub_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [389, 7], "def_end_pos": [389, 14]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "tsum_eq_zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean", "def_pos": [212, 9], "def_end_pos": [212, 25]}, {"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}, {"full_name": "mul_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [156, 9], "def_end_pos": [156, 22]}, {"full_name": "tsum_mul_left", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Ring.lean", "def_pos": [114, 9], "def_end_pos": [114, 22]}, {"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "tsum_add", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "def_pos": [506, 9], "def_end_pos": [506, 17]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [91, 41], "def_end_pos": [91, 43]}, {"full_name": "div_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [602, 9], "def_end_pos": [602, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\nhr' : r \u2260 1\ns : \ud835\udd5c := \u2211' (n : \u2115), \u2191n * r ^ n\n\u22a2 s = r / (1 - r) ^ 2", "state_after": "no goals"}, {"tactic": "simpa only [pow_one] using summable_pow_mul_geometric_of_norm_lt_one 1 hr", "annotated_tactic": ["simpa only [<a>pow_one</a>] using <a>summable_pow_mul_geometric_of_norm_lt_one</a> 1 hr", [{"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}, {"full_name": "summable_pow_mul_geometric_of_norm_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecificLimits/Normed.lean", "def_pos": [355, 9], "def_end_pos": [355, 50]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\n\u22a2 Summable fun n => \u2191n * r ^ n", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\n\u22a2 r \u2260 1", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nhr : \u20161\u2016 < 1\nA : Summable fun n => \u2191n * 1 ^ n\nB : HasSum (fun x => 1 ^ x) (1 - 1)\u207b\u00b9\n\u22a2 False"}, {"tactic": "simp [lt_irrefl] at hr", "annotated_tactic": ["simp [<a>lt_irrefl</a>] at hr", [{"full_name": "lt_irrefl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [73, 9], "def_end_pos": [73, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nhr : \u20161\u2016 < 1\nA : Summable fun n => \u2191n * 1 ^ n\nB : HasSum (fun x => 1 ^ x) (1 - 1)\u207b\u00b9\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [_root_.sub_mul, one_mul]", "annotated_tactic": ["rw [<a>_root_.sub_mul</a>, <a>one_mul</a>]", [{"full_name": "sub_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [389, 7], "def_end_pos": [389, 14]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\nhr' : r \u2260 1\ns : \ud835\udd5c := \u2211' (n : \u2115), \u2191n * r ^ n\n\u22a2 (1 - r) * s / (1 - r) = (s - r * s) / (1 - r)", "state_after": "no goals"}, {"tactic": "rw [\u2190 tsum_eq_zero_add A]", "annotated_tactic": ["rw [\u2190 <a>tsum_eq_zero_add</a> A]", [{"full_name": "tsum_eq_zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean", "def_pos": [212, 9], "def_end_pos": [212, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\nhr' : r \u2260 1\ns : \ud835\udd5c := \u2211' (n : \u2115), \u2191n * r ^ n\n\u22a2 (s - r * s) / (1 - r) = (\u21910 * r ^ 0 + \u2211' (n : \u2115), \u2191(n + 1) * r ^ (n + 1) - r * s) / (1 - r)", "state_after": "no goals"}, {"tactic": "simp [_root_.pow_succ, mul_left_comm _ r, _root_.tsum_mul_left]", "annotated_tactic": ["simp [<a>_root_.pow_succ</a>, <a>mul_left_comm</a> _ r, <a>_root_.tsum_mul_left</a>]", [{"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}, {"full_name": "mul_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [156, 9], "def_end_pos": [156, 22]}, {"full_name": "tsum_mul_left", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Ring.lean", "def_pos": [114, 9], "def_end_pos": [114, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\nhr' : r \u2260 1\ns : \ud835\udd5c := \u2211' (n : \u2115), \u2191n * r ^ n\n\u22a2 (\u21910 * r ^ 0 + \u2211' (n : \u2115), \u2191(n + 1) * r ^ (n + 1) - r * s) / (1 - r) =\n    (r * \u2211' (n : \u2115), (\u2191n + 1) * r ^ n - r * s) / (1 - r)", "state_after": "no goals"}, {"tactic": "simp [add_mul, tsum_add A B.summable, mul_add, B.tsum_eq, \u2190 div_eq_mul_inv, sq, div_div]", "annotated_tactic": ["simp [<a>add_mul</a>, <a>tsum_add</a> A B.summable, <a>mul_add</a>, B.tsum_eq, \u2190 <a>div_eq_mul_inv</a>, <a>sq</a>, <a>div_div</a>]", [{"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "tsum_add", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "def_pos": [506, 9], "def_end_pos": [506, 17]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [91, 41], "def_end_pos": [91, 43]}, {"full_name": "div_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [602, 9], "def_end_pos": [602, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9 : NormedField \ud835\udd5c\ninst\u271d : CompleteSpace \ud835\udd5c\nr : \ud835\udd5c\nhr : \u2016r\u2016 < 1\nA : Summable fun n => \u2191n * r ^ n\nB : HasSum (fun x => r ^ x) (1 - r)\u207b\u00b9\nhr' : r \u2260 1\ns : \ud835\udd5c := \u2211' (n : \u2115), \u2191n * r ^ n\n\u22a2 (r * \u2211' (n : \u2115), (\u2191n + 1) * r ^ n - r * s) / (1 - r) = r / (1 - r) ^ 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/MonotoneContinuity.lean", "full_name": "StrictMonoOn.continuousWithinAt_left_of_image_mem_nhdsWithin", "start": [194, 1], "end": [197, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.Ioo_ae_eq_Ico'", "start": [2074, 1], "end": [2075, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Option.lean", "full_name": "Finset.mem_eraseNone", "start": [98, 1], "end": [99, 19], "traced_tactics": [{"tactic": "simp [eraseNone]", "annotated_tactic": ["simp [<a>eraseNone</a>]", [{"full_name": "Finset.eraseNone", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Option.lean", "def_pos": [92, 5], "def_end_pos": [92, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset (Option \u03b1)\nx : \u03b1\n\u22a2 x \u2208 eraseNone s \u2194 some x \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "discreteTopology_subtype_iff", "start": [253, 1], "end": [255, 85], "traced_tactics": [{"tactic": "simp_rw [discreteTopology_iff_nhds_ne, SetCoe.forall', nhds_ne_subtype_eq_bot_iff]", "annotated_tactic": ["simp_rw [<a>discreteTopology_iff_nhds_ne</a>, <a>SetCoe.forall'</a>, <a>nhds_ne_subtype_eq_bot_iff</a>]", [{"full_name": "discreteTopology_iff_nhds_ne", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Order.lean", "def_pos": [359, 9], "def_end_pos": [359, 37]}, {"full_name": "SetCoe.forall'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [181, 9], "def_end_pos": [181, 23]}, {"full_name": "nhds_ne_subtype_eq_bot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Constructions.lean", "def_pos": [242, 9], "def_end_pos": [242, 35]}]], "state_before": "X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 DiscreteTopology \u2191S \u2194 \u2200 x \u2208 S, \ud835\udcdd[\u2260] x \u2293 \ud835\udcdf S = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Noetherian.lean", "full_name": "monotone_stabilizes_iff_noetherian", "start": [355, 1], "end": [357, 74], "traced_tactics": [{"tactic": "rw [isNoetherian_iff_wellFounded, WellFounded.monotone_chain_condition]", "annotated_tactic": ["rw [<a>isNoetherian_iff_wellFounded</a>, <a>WellFounded.monotone_chain_condition</a>]", [{"full_name": "isNoetherian_iff_wellFounded", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Noetherian.lean", "def_pos": [303, 9], "def_end_pos": [303, 37]}, {"full_name": "WellFounded.monotone_chain_condition", "def_path": ".lake/packages/mathlib/Mathlib/Order/OrderIsoNat.lean", "def_pos": [229, 9], "def_end_pos": [229, 45]}]], "state_before": "R : Type u_1\nM : Type u_2\nP : Type u_3\nN : Type w\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : AddCommMonoid N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : AddCommMonoid P\ninst\u271d : Module R P\n\u22a2 (\u2200 (f : \u2115 \u2192o Submodule R M), \u2203 n, \u2200 (m : \u2115), n \u2264 m \u2192 f n = f m) \u2194 IsNoetherian R M", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Relation.lean", "full_name": "Equivalence.eqvGen_eq", "start": [763, 1], "end": [764, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.symm_trans_apply", "start": [929, 1], "end": [931, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Vector/Basic.lean", "full_name": "Vector.tail_ofFn", "start": [199, 1], "end": [204, 8], "traced_tactics": [{"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "n\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nf : Fin (Nat.succ n) \u2192 \u03b1\n\u22a2 ofFn (get (tail (ofFn f))) = ofFn fun i => f (Fin.succ i)", "state_after": "case e_a\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nf : Fin (Nat.succ n) \u2192 \u03b1\n\u22a2 get (tail (ofFn f)) = fun i => f (Fin.succ i)"}, {"tactic": "funext i", "annotated_tactic": ["funext i", []], "state_before": "case e_a\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nf : Fin (Nat.succ n) \u2192 \u03b1\n\u22a2 get (tail (ofFn f)) = fun i => f (Fin.succ i)", "state_after": "case e_a.h\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nf : Fin (Nat.succ n) \u2192 \u03b1\ni : Fin (Nat.succ n - 1)\n\u22a2 get (tail (ofFn f)) i = f (Fin.succ i)"}, {"tactic": "rw [get_tail, get_ofFn]", "annotated_tactic": ["rw [<a>get_tail</a>, <a>get_ofFn</a>]", [{"full_name": "Vector.get_tail", "def_path": ".lake/packages/mathlib/Mathlib/Data/Vector/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 17]}, {"full_name": "Vector.get_ofFn", "def_path": ".lake/packages/mathlib/Mathlib/Data/Vector/Basic.lean", "def_pos": [148, 9], "def_end_pos": [148, 17]}]], "state_before": "case e_a.h\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nf : Fin (Nat.succ n) \u2192 \u03b1\ni : Fin (Nat.succ n - 1)\n\u22a2 get (tail (ofFn f)) i = f (Fin.succ i)", "state_after": "case e_a.h\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nf : Fin (Nat.succ n) \u2192 \u03b1\ni : Fin (Nat.succ n - 1)\n\u22a2 f { val := \u2191i + 1, isLt := \u22ef } = f (Fin.succ i)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case e_a.h\nn\u271d : \u2115\n\u03b1 : Type u_1\nn : \u2115\nf : Fin (Nat.succ n) \u2192 \u03b1\ni : Fin (Nat.succ n - 1)\n\u22a2 f { val := \u2191i + 1, isLt := \u22ef } = f (Fin.succ i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/FilterBasis.lean", "full_name": "ModuleFilterBasis.smul", "start": [346, 1], "end": [347, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Block.lean", "full_name": "Matrix.blockDiag_neg", "start": [610, 1], "end": [611, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/InitialSeg.lean", "full_name": "InitialSeg.Antisymm.aux", "start": [153, 1], "end": [154, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.ball_smul_ball", "start": [938, 1], "end": [943, 37], "traced_tactics": [{"tactic": "rcases eq_or_ne r\u2082 0 with rfl | hr\u2082", "annotated_tactic": ["rcases <a>eq_or_ne</a> r\u2082 0 with rfl | hr\u2082", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup E\u2082\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 E\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np\u271d p : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\n\u22a2 Metric.ball 0 r\u2081 \u2022 ball p 0 r\u2082 \u2286 ball p 0 (r\u2081 * r\u2082)", "state_after": "case inl\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup E\u2082\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 E\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np\u271d p : Seminorm \ud835\udd5c E\nr\u2081 : \u211d\n\u22a2 Metric.ball 0 r\u2081 \u2022 ball p 0 0 \u2286 ball p 0 (r\u2081 * 0)\n\ncase inr\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup E\u2082\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 E\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np\u271d p : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nhr\u2082 : r\u2082 \u2260 0\n\u22a2 Metric.ball 0 r\u2081 \u2022 ball p 0 r\u2082 \u2286 ball p 0 (r\u2081 * r\u2082)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inl\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup E\u2082\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 E\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np\u271d p : Seminorm \ud835\udd5c E\nr\u2081 : \u211d\n\u22a2 Metric.ball 0 r\u2081 \u2022 ball p 0 0 \u2286 ball p 0 (r\u2081 * 0)", "state_after": "no goals"}, {"tactic": "exact (smul_subset_smul_left (ball_subset_closedBall _ _ _)).trans\n  (ball_smul_closedBall _ _ hr\u2082)", "annotated_tactic": ["exact (<a>smul_subset_smul_left</a> (<a>ball_subset_closedBall</a> _ _ _)).<a>trans</a>\n      (<a>ball_smul_closedBall</a> _ _ hr\u2082)", [{"full_name": "Set.smul_subset_smul_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [170, 9], "def_end_pos": [170, 30]}, {"full_name": "Seminorm.ball_subset_closedBall", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [704, 9], "def_end_pos": [704, 31]}, {"full_name": "HasSubset.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [667, 7], "def_end_pos": [667, 29]}, {"full_name": "Seminorm.ball_smul_closedBall", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [929, 9], "def_end_pos": [929, 29]}]], "state_before": "case inr\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u2076 : SeminormedRing \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\u2082\ninst\u271d\u00b2 : AddCommGroup E\u2082\ninst\u271d\u00b9 : Module \ud835\udd5c\u2082 E\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\np\u271d p : Seminorm \ud835\udd5c E\nr\u2081 r\u2082 : \u211d\nhr\u2082 : r\u2082 \u2260 0\n\u22a2 Metric.ball 0 r\u2081 \u2022 ball p 0 r\u2082 \u2286 ball p 0 (r\u2081 * r\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "full_name": "MultilinearMap.curryFinFinset_apply_const", "start": [1775, 1], "end": [1781, 36], "traced_tactics": [{"tactic": "refine' (curryFinFinset_symm_apply_piecewise_const hk hl _ _ _).symm.trans _", "annotated_tactic": ["refine' (<a>curryFinFinset_symm_apply_piecewise_const</a> hk hl _ _ _).symm.trans _", [{"full_name": "MultilinearMap.curryFinFinset_symm_apply_piecewise_const", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Multilinear/Basic.lean", "def_pos": [1739, 9], "def_end_pos": [1739, 50]}]], "state_before": "R : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : s.card = k\nhl : s\u1d9c.card = l\nf : MultilinearMap R (fun x => M') M\u2082\nx y : M'\n\u22a2 ((((curryFinFinset R M\u2082 M' hk hl) f) fun x_1 => x) fun x => y) = f (Finset.piecewise s (fun x_1 => x) fun x => y)", "state_after": "R : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : s.card = k\nhl : s\u1d9c.card = l\nf : MultilinearMap R (fun x => M') M\u2082\nx y : M'\n\u22a2 ((LinearEquiv.symm (curryFinFinset R M\u2082 M' hk hl)) ((curryFinFinset R M\u2082 M' hk hl) f))\n      (Finset.piecewise s (fun x_1 => x) fun x => y) =\n    f (Finset.piecewise s (fun x_1 => x) fun x => y)"}, {"tactic": "rw [LinearEquiv.symm_apply_apply]", "annotated_tactic": ["rw [<a>LinearEquiv.symm_apply_apply</a>]", [{"full_name": "LinearEquiv.symm_apply_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [369, 9], "def_end_pos": [369, 25]}]], "state_before": "R : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : s.card = k\nhl : s\u1d9c.card = l\nf : MultilinearMap R (fun x => M') M\u2082\nx y : M'\n\u22a2 ((LinearEquiv.symm (curryFinFinset R M\u2082 M' hk hl)) ((curryFinFinset R M\u2082 M' hk hl) f))\n      (Finset.piecewise s (fun x_1 => x) fun x => y) =\n    f (Finset.piecewise s (fun x_1 => x) fun x => y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Abs.lean", "full_name": "Complex.abs_two", "start": [124, 1], "end": [124, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Archimedean.lean", "full_name": "Real.add_neg_lt_sSup", "start": [153, 1], "end": [155, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iSup_iInf_ge_nat_add", "start": [1637, 1], "end": [1641, 55], "traced_tactics": [{"tactic": "have hf : Monotone fun n => \u2a05 i \u2265 n, f i := fun n m h => biInf_mono fun i => h.trans", "annotated_tactic": ["have hf : <a>Monotone</a> fun n => \u2a05 i \u2265 n, f i := fun n m h => <a>biInf_mono</a> fun i => h.trans", [{"full_name": "Monotone", "def_path": ".lake/packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [77, 5], "def_end_pos": [77, 13]}, {"full_name": "biInf_mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [847, 9], "def_end_pos": [847, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g s t : \u03b9 \u2192 \u03b1\na b : \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\n\u22a2 \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n), f (i + k) = \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n), f i", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g s t : \u03b9 \u2192 \u03b1\na b : \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\nhf : Monotone fun n => \u2a05 i, \u2a05 (_ : i \u2265 n), f i\n\u22a2 \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n), f (i + k) = \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n), f i"}, {"tactic": "rw [\u2190 Monotone.iSup_nat_add hf k]", "annotated_tactic": ["rw [\u2190 <a>Monotone.iSup_nat_add</a> hf k]", [{"full_name": "Monotone.iSup_nat_add", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1623, 9], "def_end_pos": [1623, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g s t : \u03b9 \u2192 \u03b1\na b : \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\nhf : Monotone fun n => \u2a05 i, \u2a05 (_ : i \u2265 n), f i\n\u22a2 \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n), f (i + k) = \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n), f i", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g s t : \u03b9 \u2192 \u03b1\na b : \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\nhf : Monotone fun n => \u2a05 i, \u2a05 (_ : i \u2265 n), f i\n\u22a2 \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n), f (i + k) = \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n + k), f i"}, {"tactic": "simp_rw [iInf_ge_eq_iInf_nat_add, \u2190 Nat.add_assoc]", "annotated_tactic": ["simp_rw [<a>iInf_ge_eq_iInf_nat_add</a>, \u2190 <a>Nat.add_assoc</a>]", [{"full_name": "iInf_ge_eq_iInf_nat_add", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1619, 9], "def_end_pos": [1619, 32]}, {"full_name": "Nat.add_assoc", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g s t : \u03b9 \u2192 \u03b1\na b : \u03b1\nf : \u2115 \u2192 \u03b1\nk : \u2115\nhf : Monotone fun n => \u2a05 i, \u2a05 (_ : i \u2265 n), f i\n\u22a2 \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n), f (i + k) = \u2a06 n, \u2a05 i, \u2a05 (_ : i \u2265 n + k), f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean", "full_name": "Ordinal.derivFamily_eq_enumOrd", "start": [229, 1], "end": [239, 31], "traced_tactics": [{"tactic": "rw [\u2190 eq_enumOrd _ (fp_family_unbounded.{u, v} H)]", "annotated_tactic": ["rw [\u2190 <a>eq_enumOrd</a> _ (<a>fp_family_unbounded</a>.{u, v} H)]", [{"full_name": "Ordinal.eq_enumOrd", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [2292, 9], "def_end_pos": [2292, 19]}, {"full_name": "Ordinal.fp_family_unbounded", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/FixedPoint.lean", "def_pos": [145, 9], "def_end_pos": [145, 28]}]], "state_before": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 derivFamily f = enumOrd (\u22c2 i, fixedPoints (f i))", "state_after": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 StrictMono (derivFamily f) \u2227 Set.range (derivFamily f) = \u22c2 i, fixedPoints (f i)"}, {"tactic": "use (derivFamily_isNormal f).strictMono", "annotated_tactic": ["use (<a>derivFamily_isNormal</a> f).<a>strictMono</a>", [{"full_name": "Ordinal.derivFamily_isNormal", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/FixedPoint.lean", "def_pos": [178, 9], "def_end_pos": [178, 29]}, {"full_name": "Ordinal.IsNormal.strictMono", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [412, 9], "def_end_pos": [412, 28]}]], "state_before": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 StrictMono (derivFamily f) \u2227 Set.range (derivFamily f) = \u22c2 i, fixedPoints (f i)", "state_after": "case right\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 Set.range (derivFamily f) = \u22c2 i, fixedPoints (f i)"}, {"tactic": "rw [Set.range_eq_iff]", "annotated_tactic": ["rw [<a>Set.range_eq_iff</a>]", [{"full_name": "Set.range_eq_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [733, 9], "def_end_pos": [733, 21]}]], "state_before": "case right\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 Set.range (derivFamily f) = \u22c2 i, fixedPoints (f i)", "state_after": "case right\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 (\u2200 (a : Ordinal.{max u v}), derivFamily f a \u2208 \u22c2 i, fixedPoints (f i)) \u2227\n    \u2200 b \u2208 \u22c2 i, fixedPoints (f i), \u2203 a, derivFamily f a = b"}, {"tactic": "refine' \u27e8_, fun a ha => _\u27e9", "annotated_tactic": ["refine' \u27e8_, fun a ha => _\u27e9", []], "state_before": "case right\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 (\u2200 (a : Ordinal.{max u v}), derivFamily f a \u2208 \u22c2 i, fixedPoints (f i)) \u2227\n    \u2200 b \u2208 \u22c2 i, fixedPoints (f i), \u2203 a, derivFamily f a = b", "state_after": "case right.refine'_1\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 \u2200 (a : Ordinal.{max u v}), derivFamily f a \u2208 \u22c2 i, fixedPoints (f i)\n\ncase right.refine'_2\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{max u v}\nha : a \u2208 \u22c2 i, fixedPoints (f i)\n\u22a2 \u2203 a_1, derivFamily f a_1 = a"}, {"tactic": "rw [Set.mem_iInter] at ha", "annotated_tactic": ["rw [<a>Set.mem_iInter</a>] at ha", [{"full_name": "Set.mem_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [278, 9], "def_end_pos": [278, 19]}]], "state_before": "case right.refine'_2\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{max u v}\nha : a \u2208 \u22c2 i, fixedPoints (f i)\n\u22a2 \u2203 a_1, derivFamily f a_1 = a", "state_after": "case right.refine'_2\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{max u v}\nha : \u2200 (i : \u03b9), a \u2208 fixedPoints (f i)\n\u22a2 \u2203 a_1, derivFamily f a_1 = a"}, {"tactic": "rwa [\u2190 fp_iff_derivFamily H]", "annotated_tactic": ["rwa [\u2190 <a>fp_iff_derivFamily</a> H]", [{"full_name": "Ordinal.fp_iff_derivFamily", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/FixedPoint.lean", "def_pos": [223, 9], "def_end_pos": [223, 27]}]], "state_before": "case right.refine'_2\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{max u v}\nha : \u2200 (i : \u03b9), a \u2208 fixedPoints (f i)\n\u22a2 \u2203 a_1, derivFamily f a_1 = a", "state_after": "no goals"}, {"tactic": "rintro a S \u27e8i, hi\u27e9", "annotated_tactic": ["rintro a S \u27e8i, hi\u27e9", []], "state_before": "case right.refine'_1\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\n\u22a2 \u2200 (a : Ordinal.{max u v}), derivFamily f a \u2208 \u22c2 i, fixedPoints (f i)", "state_after": "case right.refine'_1.intro\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{max u v}\nS : Set Ordinal.{max u v}\ni : \u03b9\nhi : (fun i => fixedPoints (f i)) i = S\n\u22a2 derivFamily f a \u2208 S"}, {"tactic": "rw [\u2190 hi]", "annotated_tactic": ["rw [\u2190 hi]", []], "state_before": "case right.refine'_1.intro\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{max u v}\nS : Set Ordinal.{max u v}\ni : \u03b9\nhi : (fun i => fixedPoints (f i)) i = S\n\u22a2 derivFamily f a \u2208 S", "state_after": "case right.refine'_1.intro\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{max u v}\nS : Set Ordinal.{max u v}\ni : \u03b9\nhi : (fun i => fixedPoints (f i)) i = S\n\u22a2 derivFamily f a \u2208 (fun i => fixedPoints (f i)) i"}, {"tactic": "exact derivFamily_fp (H i) a", "annotated_tactic": ["exact <a>derivFamily_fp</a> (H i) a", [{"full_name": "Ordinal.derivFamily_fp", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/FixedPoint.lean", "def_pos": [183, 9], "def_end_pos": [183, 23]}]], "state_before": "case right.refine'_1.intro\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), IsNormal (f i)\na : Ordinal.{max u v}\nS : Set Ordinal.{max u v}\ni : \u03b9\nhi : (fun i => fixedPoints (f i)) i = S\n\u22a2 derivFamily f a \u2208 (fun i => fixedPoints (f i)) i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.eventually_imp_distrib_left", "start": [1222, 1], "end": [1224, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Adjoin.lean", "full_name": "AlgEquiv.fieldRange_eq_top", "start": [311, 1], "end": [313, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "full_name": "FreeMonoid.toList_comp_ofList", "start": [67, 1], "end": [67, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.take_all_of_le", "start": [1925, 1], "end": [1931, 47], "traced_tactics": [{"tactic": "change a :: take n l = a :: l", "annotated_tactic": ["change a :: <a>take</a> n l = a :: l", [{"full_name": "List.take", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [534, 5], "def_end_pos": [534, 9]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nn : \u2115\na : \u03b1\nl : List \u03b1\nh : length (a :: l) \u2264 n + 1\n\u22a2 take (n + 1) (a :: l) = a :: l", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nn : \u2115\na : \u03b1\nl : List \u03b1\nh : length (a :: l) \u2264 n + 1\n\u22a2 a :: take n l = a :: l"}, {"tactic": "rw [take_all_of_le (le_of_succ_le_succ h)]", "annotated_tactic": ["rw [take_all_of_le (<a>le_of_succ_le_succ</a> h)]", [{"full_name": "Nat.le_of_succ_le_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1694, 9], "def_end_pos": [1694, 31]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nn : \u2115\na : \u03b1\nl : List \u03b1\nh : length (a :: l) \u2264 n + 1\n\u22a2 a :: take n l = a :: l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Exp.lean", "full_name": "Real.isLittleO_exp_comp_exp_comp", "start": [389, 1], "end": [392, 55], "traced_tactics": [{"tactic": "simp only [isLittleO_iff_tendsto, exp_ne_zero, \u2190 exp_sub, \u2190 tendsto_neg_atTop_iff, false_imp_iff,\n  imp_true_iff, tendsto_exp_comp_nhds_zero, neg_sub]", "annotated_tactic": ["simp only [<a>isLittleO_iff_tendsto</a>, <a>exp_ne_zero</a>, \u2190 <a>exp_sub</a>, \u2190 <a>tendsto_neg_atTop_iff</a>, <a>false_imp_iff</a>,\n    <a>imp_true_iff</a>, <a>tendsto_exp_comp_nhds_zero</a>, <a>neg_sub</a>]", [{"full_name": "Asymptotics.isLittleO_iff_tendsto", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Asymptotics/Asymptotics.lean", "def_pos": [1882, 9], "def_end_pos": [1882, 30]}, {"full_name": "Real.exp_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [846, 16], "def_end_pos": [846, 27]}, {"full_name": "Real.exp_sub", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [854, 9], "def_end_pos": [854, 16]}, {"full_name": "Filter.tendsto_neg_atTop_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [919, 9], "def_end_pos": [919, 30]}, {"full_name": "false_imp_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1402, 9], "def_end_pos": [1402, 22]}, {"full_name": "imp_true_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1400, 9], "def_end_pos": [1400, 21]}, {"full_name": "Real.tendsto_exp_comp_nhds_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Exp.lean", "def_pos": [347, 9], "def_end_pos": [347, 35]}, {"full_name": "neg_sub", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [471, 3], "def_end_pos": [471, 14]}]], "state_before": "\u03b1 : Type u_1\nx y z : \u211d\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u211d\n\u22a2 ((fun x => rexp (f x)) =o[l] fun x => rexp (g x)) \u2194 Tendsto (fun x => g x - f x) l atTop", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Sigma.lean", "full_name": "Set.mk_mem_sigma", "start": [64, 1], "end": [64, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/MeanValue.lean", "full_name": "Convex.lipschitzOnWith_of_nnnorm_fderivWithin_le", "start": [532, 1], "end": [534, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Small/Defs.lean", "full_name": "small_lift", "start": [81, 1], "end": [83, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/FreeGroup/Basic.lean", "full_name": "FreeGroup.Red.invRev", "start": [621, 1], "end": [622, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "toMul_sum", "start": [2647, 1], "end": [2649, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.mulVec_injective_iff", "start": [303, 1], "end": [306, 55], "traced_tactics": [{"tactic": "change Function.Injective (fun x \u21a6 _) \u2194 _", "annotated_tactic": ["change <a>Function.Injective</a> (fun x \u21a6 _) \u2194 _", [{"full_name": "Function.Injective", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [116, 5], "def_end_pos": [116, 14]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u00b2 : CommSemiring R\u271d\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d\u00b9 : Fintype n\nR : Type u_6\ninst\u271d : CommRing R\nM : Matrix m n R\n\u22a2 Function.Injective (mulVec M) \u2194 LinearIndependent R fun i => M\u1d40 i", "state_after": "R\u271d : Type u_1\ninst\u271d\u00b2 : CommSemiring R\u271d\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d\u00b9 : Fintype n\nR : Type u_6\ninst\u271d : CommRing R\nM : Matrix m n R\n\u22a2 (Function.Injective fun x => M *\u1d65 x) \u2194 LinearIndependent R fun i => M\u1d40 i"}, {"tactic": "simp_rw [\u2190 M.vecMul_transpose, vecMul_injective_iff]", "annotated_tactic": ["simp_rw [\u2190 M.vecMul_transpose, <a>vecMul_injective_iff</a>]", [{"full_name": "Matrix.vecMul_injective_iff", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "def_pos": [121, 9], "def_end_pos": [121, 36]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u00b2 : CommSemiring R\u271d\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst\u271d\u00b9 : Fintype n\nR : Type u_6\ninst\u271d : CommRing R\nM : Matrix m n R\n\u22a2 (Function.Injective fun x => M *\u1d65 x) \u2194 LinearIndependent R fun i => M\u1d40 i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Multiset.lean", "full_name": "Multiset.toFinsupp_sum_eq", "start": [197, 1], "end": [198, 55], "traced_tactics": [{"tactic": "rw [\u2190 Finsupp.card_toMultiset, toFinsupp_toMultiset]", "annotated_tactic": ["rw [\u2190 <a>Finsupp.card_toMultiset</a>, <a>toFinsupp_toMultiset</a>]", [{"full_name": "Finsupp.card_toMultiset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [69, 9], "def_end_pos": [69, 24]}, {"full_name": "Multiset.toFinsupp_toMultiset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [179, 9], "def_end_pos": [179, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\n\u22a2 (Finsupp.sum (toFinsupp s) fun x => id) = card s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Tower.lean", "full_name": "IsScalarTower.coe_toAlgHom'", "start": [156, 1], "end": [156, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Between.lean", "full_name": "sbtw_vsub_const_iff", "start": [233, 1], "end": [236, 36], "traced_tactics": [{"tactic": "rw [Sbtw, Sbtw, wbtw_vsub_const_iff, (vsub_left_injective p).ne_iff,\n  (vsub_left_injective p).ne_iff]", "annotated_tactic": ["rw [<a>Sbtw</a>, <a>Sbtw</a>, <a>wbtw_vsub_const_iff</a>, (<a>vsub_left_injective</a> p).<a>ne_iff</a>,\n    (<a>vsub_left_injective</a> p).<a>ne_iff</a>]", [{"full_name": "Sbtw", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Convex/Between.lean", "def_pos": [148, 5], "def_end_pos": [148, 9]}, {"full_name": "Sbtw", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Convex/Between.lean", "def_pos": [148, 5], "def_end_pos": [148, 9]}, {"full_name": "wbtw_vsub_const_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Convex/Between.lean", "def_pos": [206, 9], "def_end_pos": [206, 28]}, {"full_name": "vsub_left_injective", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [218, 9], "def_end_pos": [218, 28]}, {"full_name": "Function.Injective.ne_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 25]}, {"full_name": "vsub_left_injective", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [218, 9], "def_end_pos": [218, 28]}, {"full_name": "Function.Injective.ne_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [107, 9], "def_end_pos": [107, 25]}]], "state_before": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2076 : OrderedRing R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module R V'\ninst\u271d : AddTorsor V' P'\nx y z p : P\n\u22a2 Sbtw R (x -\u1d65 p) (y -\u1d65 p) (z -\u1d65 p) \u2194 Sbtw R x y z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Cardinal.sup_lt_ord_lift_of_isRegular", "start": [1065, 1], "end": [1067, 39], "traced_tactics": [{"tactic": "rwa [hc.cof_eq]", "annotated_tactic": ["rwa [hc.cof_eq]", []], "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nc : Cardinal.{max u v}\nhc : IsRegular c\nh\u03b9 : lift.{v, u} #\u03b9 < c\n\u22a2 lift.{v, u} #\u03b9 < Ordinal.cof (ord c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean", "full_name": "Nat.Prime.factorization_self", "start": [253, 1], "end": [253, 96], "traced_tactics": [{"tactic": "simp [hp]", "annotated_tactic": ["simp [hp]", []], "state_before": "a b m n p\u271d p : \u2115\nhp : Prime p\n\u22a2 (factorization p) p = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/MeanValue.lean", "full_name": "strictConcaveOn_of_deriv2_neg", "start": [1313, 1], "end": [1320, 10], "traced_tactics": [{"tactic": "rwa [interior_interior]", "annotated_tactic": ["rwa [<a>interior_interior</a>]", [{"full_name": "interior_interior", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 26]}]], "state_before": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf'' : \u2200 x \u2208 interior D, deriv^[2] f x < 0\n\u22a2 \u2200 x \u2208 interior (interior D), deriv (deriv f) x < 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.inf'_prodMap", "start": [1073, 1], "end": [1077, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Add.lean", "full_name": "DifferentiableOn.const_add", "start": [306, 1], "end": [307, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "full_name": "AffineIsometry.isometry", "start": [157, 11], "end": [158, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Field/IsField.lean", "full_name": "not_isField_of_subsingleton", "start": [57, 1], "end": [60, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Star/SelfAdjoint.lean", "full_name": "isSelfAdjoint_natCast", "start": [215, 1], "end": [216, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.mulVec_stdBasis", "start": [287, 1], "end": [289, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.transpose_apply", "start": [180, 1], "end": [181, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/NhdsSet.lean", "full_name": "eventually_nhdsSet_iUnion", "start": [220, 1], "end": [222, 46], "traced_tactics": [{"tactic": "simp only [nhdsSet_iUnion, eventually_iSup]", "annotated_tactic": ["simp only [<a>nhdsSet_iUnion</a>, <a>eventually_iSup</a>]", [{"full_name": "nhdsSet_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Topology/NhdsSet.lean", "def_pos": [213, 9], "def_end_pos": [213, 23]}, {"full_name": "Filter.eventually_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1250, 9], "def_end_pos": [1250, 24]}]], "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : Filter X\ns\u271d t s\u2081 s\u2082 t\u2081 t\u2082 : Set X\nx : X\n\u03b9 : Sort u_3\ns : \u03b9 \u2192 Set X\nP : X \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : X) in \ud835\udcdd\u02e2 (\u22c3 i, s i), P x) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (x : X) in \ud835\udcdd\u02e2 (s i), P x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Quotient.lean", "full_name": "image_norm_nonempty", "start": [127, 1], "end": [129, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "full_name": "HasSum.sigma_of_hasSum", "start": [115, 1], "end": [117, 78], "traced_tactics": [{"tactic": "simpa [(hf'.hasSum.sigma hf).unique ha] using hf'.hasSum", "annotated_tactic": ["simpa [(hf'.hasSum.sigma hf).<a>unique</a> ha] using hf'.hasSum", [{"full_name": "HasSum.unique", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [129, 9], "def_end_pos": [129, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ContinuousAdd \u03b1\ninst\u271d : T3Space \u03b1\n\u03b3 : \u03b2 \u2192 Type u_5\nf : (b : \u03b2) \u00d7 \u03b3 b \u2192 \u03b1\ng : \u03b2 \u2192 \u03b1\na : \u03b1\nha : HasSum g a\nhf : \u2200 (b : \u03b2), HasSum (fun c => f { fst := b, snd := c }) (g b)\nhf' : Summable f\n\u22a2 HasSum f a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Lemmas.lean", "full_name": "Polynomial.coeff_sub_eq_neg_right_of_lt", "start": [346, 1], "end": [347, 60], "traced_tactics": [{"tactic": "rwa [sub_eq_add_neg, coeff_add_eq_right_of_lt, coeff_neg]", "annotated_tactic": ["rwa [<a>sub_eq_add_neg</a>, <a>coeff_add_eq_right_of_lt</a>, <a>coeff_neg</a>]", [{"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}, {"full_name": "Polynomial.coeff_add_eq_right_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Lemmas.lean", "def_pos": [194, 9], "def_end_pos": [194, 33]}, {"full_name": "Polynomial.coeff_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1198, 9], "def_end_pos": [1198, 18]}]], "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Ring R\np q : R[X]\ndf : natDegree p < n\n\u22a2 coeff (p - q) n = -coeff q n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Content.lean", "full_name": "Polynomial.dvd_content_iff_C_dvd", "start": [215, 1], "end": [223, 14], "traced_tactics": [{"tactic": "rw [C_dvd_iff_dvd_coeff]", "annotated_tactic": ["rw [<a>C_dvd_iff_dvd_coeff</a>]", [{"full_name": "Polynomial.C_dvd_iff_dvd_coeff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [349, 9], "def_end_pos": [349, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\n\u22a2 r \u2223 content p \u2194 C r \u2223 p", "state_after": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\n\u22a2 r \u2223 content p \u2194 \u2200 (i : \u2115), r \u2223 coeff p i"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\n\u22a2 r \u2223 content p \u2194 \u2200 (i : \u2115), r \u2223 coeff p i", "state_after": "case mp\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\n\u22a2 r \u2223 content p \u2192 \u2200 (i : \u2115), r \u2223 coeff p i\n\ncase mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\n\u22a2 (\u2200 (i : \u2115), r \u2223 coeff p i) \u2192 r \u2223 content p"}, {"tactic": "intro h i", "annotated_tactic": ["intro h i", []], "state_before": "case mp\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\n\u22a2 r \u2223 content p \u2192 \u2200 (i : \u2115), r \u2223 coeff p i", "state_after": "case mp\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\nh : r \u2223 content p\ni : \u2115\n\u22a2 r \u2223 coeff p i"}, {"tactic": "apply h.trans (content_dvd_coeff _)", "annotated_tactic": ["apply h.trans (<a>content_dvd_coeff</a> _)", [{"full_name": "Polynomial.content_dvd_coeff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [83, 9], "def_end_pos": [83, 26]}]], "state_before": "case mp\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\nh : r \u2223 content p\ni : \u2115\n\u22a2 r \u2223 coeff p i", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\n\u22a2 (\u2200 (i : \u2115), r \u2223 coeff p i) \u2192 r \u2223 content p", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\nh : \u2200 (i : \u2115), r \u2223 coeff p i\n\u22a2 r \u2223 content p"}, {"tactic": "rw [content, Finset.dvd_gcd_iff]", "annotated_tactic": ["rw [<a>content</a>, <a>Finset.dvd_gcd_iff</a>]", [{"full_name": "Polynomial.content", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [79, 5], "def_end_pos": [79, 12]}, {"full_name": "Finset.dvd_gcd_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Finset.lean", "def_pos": [150, 9], "def_end_pos": [150, 20]}]], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\nh : \u2200 (i : \u2115), r \u2223 coeff p i\n\u22a2 r \u2223 content p", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\nh : \u2200 (i : \u2115), r \u2223 coeff p i\n\u22a2 \u2200 b \u2208 support p, r \u2223 coeff p b"}, {"tactic": "intro i _", "annotated_tactic": ["intro i _", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\nh : \u2200 (i : \u2115), r \u2223 coeff p i\n\u22a2 \u2200 b \u2208 support p, r \u2223 coeff p b", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\nh : \u2200 (i : \u2115), r \u2223 coeff p i\ni : \u2115\na\u271d : i \u2208 support p\n\u22a2 r \u2223 coeff p i"}, {"tactic": "apply h i", "annotated_tactic": ["apply h i", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nr : R\nh : \u2200 (i : \u2115), r \u2223 coeff p i\ni : \u2115\na\u271d : i \u2208 support p\n\u22a2 r \u2223 coeff p i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Archimedean.lean", "full_name": "archimedean_iff_int_le", "start": [375, 1], "end": [379, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "lt_mul_of_one_lt_of_le_of_pos", "start": [930, 1], "end": [932, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Finiteness.lean", "full_name": "Submodule.FG.map", "start": [204, 1], "end": [206, 60], "traced_tactics": [{"tactic": "rw [span_image, ht.2]", "annotated_tactic": ["rw [<a>span_image</a>, ht.2]", [{"full_name": "Submodule.span_image", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [632, 9], "def_end_pos": [632, 19]}]], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nP : Type u_3\ninst\u271d\u00b9 : AddCommMonoid P\ninst\u271d : Module R P\nf : M \u2192\u2097[R] P\nN : Submodule R M\nhs : FG N\nt : Set M\nht : Set.Finite t \u2227 span R t = N\n\u22a2 span R (\u21d1f '' t) = Submodule.map f N", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "full_name": "Order.le_cof", "start": [80, 1], "end": [85, 12], "traced_tactics": [{"tactic": "rw [cof, le_csInf_iff'' (cof_nonempty r)]", "annotated_tactic": ["rw [<a>cof</a>, <a>le_csInf_iff''</a> (<a>cof_nonempty</a> r)]", [{"full_name": "Order.cof", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Cofinality.lean", "def_pos": [66, 5], "def_end_pos": [66, 8]}, {"full_name": "le_csInf_iff''", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [1225, 9], "def_end_pos": [1225, 23]}, {"full_name": "Order.cof_nonempty", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Cofinality.lean", "def_pos": [71, 9], "def_end_pos": [71, 21]}]], "state_before": "\u03b1 : Type u_1\nr\u271d r : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsRefl \u03b1 r\nc : Cardinal.{u_1}\n\u22a2 c \u2264 cof r \u2194 \u2200 {S : Set \u03b1}, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2192 c \u2264 #\u2191S", "state_after": "\u03b1 : Type u_1\nr\u271d r : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsRefl \u03b1 r\nc : Cardinal.{u_1}\n\u22a2 (\u2200 b \u2208 {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 #\u2191S = c}, c \u2264 b) \u2194 \u2200 {S : Set \u03b1}, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2192 c \u2264 #\u2191S"}, {"tactic": "use fun H S h => H _ \u27e8S, h, rfl\u27e9", "annotated_tactic": ["use fun H S h => H _ \u27e8S, h, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "\u03b1 : Type u_1\nr\u271d r : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsRefl \u03b1 r\nc : Cardinal.{u_1}\n\u22a2 (\u2200 b \u2208 {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 #\u2191S = c}, c \u2264 b) \u2194 \u2200 {S : Set \u03b1}, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2192 c \u2264 #\u2191S", "state_after": "case mpr\n\u03b1 : Type u_1\nr\u271d r : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsRefl \u03b1 r\nc : Cardinal.{u_1}\n\u22a2 (\u2200 {S : Set \u03b1}, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2192 c \u2264 #\u2191S) \u2192 \u2200 b \u2208 {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 #\u2191S = c}, c \u2264 b"}, {"tactic": "rintro H d \u27e8S, h, rfl\u27e9", "annotated_tactic": ["rintro H d \u27e8S, h, rfl\u27e9", []], "state_before": "case mpr\n\u03b1 : Type u_1\nr\u271d r : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsRefl \u03b1 r\nc : Cardinal.{u_1}\n\u22a2 (\u2200 {S : Set \u03b1}, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2192 c \u2264 #\u2191S) \u2192 \u2200 b \u2208 {c | \u2203 S, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2227 #\u2191S = c}, c \u2264 b", "state_after": "case mpr.intro.intro\n\u03b1 : Type u_1\nr\u271d r : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsRefl \u03b1 r\nc : Cardinal.{u_1}\nH : \u2200 {S : Set \u03b1}, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2192 c \u2264 #\u2191S\nS : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 S, r a b\n\u22a2 c \u2264 #\u2191S"}, {"tactic": "exact H h", "annotated_tactic": ["exact H h", []], "state_before": "case mpr.intro.intro\n\u03b1 : Type u_1\nr\u271d r : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsRefl \u03b1 r\nc : Cardinal.{u_1}\nH : \u2200 {S : Set \u03b1}, (\u2200 (a : \u03b1), \u2203 b \u2208 S, r a b) \u2192 c \u2264 #\u2191S\nS : Set \u03b1\nh : \u2200 (a : \u03b1), \u2203 b \u2208 S, r a b\n\u22a2 c \u2264 #\u2191S", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Field/Basic.lean", "full_name": "one_div_neg_one_eq_neg_one", "start": [92, 1], "end": [94, 48], "traced_tactics": [{"tactic": "rw [neg_mul_neg, one_mul]", "annotated_tactic": ["rw [<a>neg_mul_neg</a>, <a>one_mul</a>]", [{"full_name": "neg_mul_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [315, 9], "def_end_pos": [315, 20]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nK : Type u_3\ninst\u271d\u00b9 : DivisionMonoid K\ninst\u271d : HasDistribNeg K\na b : K\n\u22a2 -1 * -1 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Interval.lean", "full_name": "Fin.card_fintypeIoo", "start": [149, 1], "end": [150, 41], "traced_tactics": [{"tactic": "rw [\u2190 card_Ioo, Fintype.card_ofFinset]", "annotated_tactic": ["rw [\u2190 <a>card_Ioo</a>, <a>Fintype.card_ofFinset</a>]", [{"full_name": "Fin.card_Ioo", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Interval.lean", "def_pos": [120, 9], "def_end_pos": [120, 17]}, {"full_name": "Fintype.card_ofFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [132, 9], "def_end_pos": [132, 22]}]], "state_before": "n : \u2115\na b : Fin n\n\u22a2 Fintype.card \u2191(Set.Ioo a b) = \u2191b - \u2191a - 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "sup_eq_bot_iff", "start": [432, 1], "end": [432, 91], "traced_tactics": [{"tactic": "rw [eq_bot_iff, sup_le_iff]", "annotated_tactic": ["rw [<a>eq_bot_iff</a>, <a>sup_le_iff</a>]", [{"full_name": "eq_bot_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [331, 9], "def_end_pos": [331, 19]}, {"full_name": "sup_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [150, 9], "def_end_pos": [150, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\n\u03b4 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\na b : \u03b1\n\u22a2 a \u2294 b = \u22a5 \u2194 a = \u22a5 \u2227 b = \u22a5", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\n\u03b4 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\na b : \u03b1\n\u22a2 a \u2264 \u22a5 \u2227 b \u2264 \u22a5 \u2194 a = \u22a5 \u2227 b = \u22a5"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\n\u03b4 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : OrderBot \u03b1\na b : \u03b1\n\u22a2 a \u2264 \u22a5 \u2227 b \u2264 \u22a5 \u2194 a = \u22a5 \u2227 b = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "full_name": "Finset.hasSum", "start": [107, 11], "end": [110, 25], "traced_tactics": [{"tactic": "rw [\u2190 sum_attach]", "annotated_tactic": ["rw [\u2190 <a>sum_attach</a>]", [{"full_name": "Finset.sum_attach", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [375, 3], "def_end_pos": [375, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf\u271d g : \u03b2 \u2192 \u03b1\na b : \u03b1\ns\u271d s : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 HasSum (f \u2218 Subtype.val) (\u2211 b in s, f b)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf\u271d g : \u03b2 \u2192 \u03b1\na b : \u03b1\ns\u271d s : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 HasSum (f \u2218 Subtype.val) (\u2211 x in attach s, f \u2191x)"}, {"tactic": "exact hasSum_fintype _", "annotated_tactic": ["exact <a>hasSum_fintype</a> _", [{"full_name": "hasSum_fintype", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "def_pos": [103, 9], "def_end_pos": [103, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf\u271d g : \u03b2 \u2192 \u03b1\na b : \u03b1\ns\u271d s : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 HasSum (f \u2218 Subtype.val) (\u2211 x in attach s, f \u2191x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Lift.lean", "full_name": "Filter.comap_lift_eq2", "start": [121, 1], "end": [124, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "orderOf_eq_prime", "start": [521, 1], "end": [523, 34], "traced_tactics": [{"tactic": "rwa [IsFixedPt, mul_one]", "annotated_tactic": ["rwa [<a>IsFixedPt</a>, <a>mul_one</a>]", [{"full_name": "Function.IsFixedPt", "def_path": ".lake/packages/mathlib/Mathlib/Dynamics/FixedPoints/Basic.lean", "def_pos": [39, 5], "def_end_pos": [39, 14]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : Monoid G\na b x y : G\nn m p : \u2115\nhp : Fact (Nat.Prime p)\nhg : x ^ p = 1\nhg1 : x \u2260 1\n\u22a2 \u00acIsFixedPt (fun x_1 => x * x_1) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Cover.lean", "full_name": "WCovBy.covBy_of_not_le", "start": [291, 1], "end": [292, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/IntervalCases.lean", "full_name": "Mathlib.Tactic.IntervalCases.of_not_lt_left", "start": [126, 1], "end": [126, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.restrictDom_comp_subtype", "start": [366, 1], "end": [370, 48], "traced_tactics": [{"tactic": "ext l a", "annotated_tactic": ["ext l a", []], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 restrictDom M R s \u2218\u2097 Submodule.subtype (supported M R s) = LinearMap.id", "state_after": "case h.a.h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nl : \u21a5(supported M R s)\na : \u03b1\n\u22a2 \u2191((restrictDom M R s \u2218\u2097 Submodule.subtype (supported M R s)) l) a = \u2191(LinearMap.id l) a"}, {"tactic": "by_cases h : a \u2208 s <;> simp [h]", "annotated_tactic": ["by_cases h : a \u2208 s <;> simp [h]", []], "state_before": "case h.a.h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nl : \u21a5(supported M R s)\na : \u03b1\n\u22a2 \u2191((restrictDom M R s \u2218\u2097 Submodule.subtype (supported M R s)) l) a = \u2191(LinearMap.id l) a", "state_after": "case neg\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nl : \u21a5(supported M R s)\na : \u03b1\nh : a \u2209 s\n\u22a2 0 = \u2191l a"}, {"tactic": "exact ((mem_supported' R l.1).1 l.2 a h).symm", "annotated_tactic": ["exact ((<a>mem_supported'</a> R l.1).1 l.2 a h).<a>symm</a>", [{"full_name": "Finsupp.mem_supported'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [316, 9], "def_end_pos": [316, 23]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case neg\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring S\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nl : \u21a5(supported M R s)\na : \u03b1\nh : a \u2209 s\n\u22a2 0 = \u2191l a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "one_div_le_one_div_of_le", "start": [471, 1], "end": [472, 36], "traced_tactics": [{"tactic": "simpa using inv_le_inv_of_le ha h", "annotated_tactic": ["simpa using <a>inv_le_inv_of_le</a> ha h", [{"full_name": "inv_le_inv_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [258, 9], "def_end_pos": [258, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 < a\nh : a \u2264 b\n\u22a2 1 / b \u2264 1 / a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.Nonempty.of_vsub_left", "start": [647, 1], "end": [648, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Order/Basic.lean", "full_name": "Int.cast_mul_eq_zsmul_cast", "start": [117, 1], "end": [121, 101], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : AddCommGroupWithOne \u03b1\nm : \u2124\n\u22a2 \u2200 (n : \u2124), \u2191(0 * n) = 0 \u2022 \u2191n", "state_after": "no goals"}, {"tactic": "simp [add_mul, add_zsmul, ih]", "annotated_tactic": ["simp [<a>add_mul</a>, <a>add_zsmul</a>, ih]", [{"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "add_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [445, 15], "def_end_pos": [445, 24]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : AddCommGroupWithOne \u03b1\nm : \u2124\nx\u271d : \u2115\nih : \u2200 (n : \u2124), \u2191(\u2191x\u271d * n) = \u2191x\u271d \u2022 \u2191n\n\u22a2 \u2200 (n : \u2124), \u2191((\u2191x\u271d + 1) * n) = (\u2191x\u271d + 1) \u2022 \u2191n", "state_after": "no goals"}, {"tactic": "simp only [sub_mul, one_mul, cast_sub, ih, sub_zsmul, one_zsmul, \u2190 sub_eq_add_neg, forall_const]", "annotated_tactic": ["simp only [<a>sub_mul</a>, <a>one_mul</a>, <a>cast_sub</a>, ih, <a>sub_zsmul</a>, <a>one_zsmul</a>, \u2190 <a>sub_eq_add_neg</a>, <a>forall_const</a>]", [{"full_name": "sub_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [389, 7], "def_end_pos": [389, 14]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "Int.cast_sub", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [123, 9], "def_end_pos": [123, 17]}, {"full_name": "sub_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [470, 15], "def_end_pos": [470, 24]}, {"full_name": "one_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [245, 30], "def_end_pos": [245, 39]}, {"full_name": "sub_eq_add_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [995, 3], "def_end_pos": [995, 14]}, {"full_name": "forall_const", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [198, 17], "def_end_pos": [198, 29]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : AddCommGroupWithOne \u03b1\nm : \u2124\nx\u271d : \u2115\nih : \u2200 (n : \u2124), \u2191(-\u2191x\u271d * n) = -\u2191x\u271d \u2022 \u2191n\n\u22a2 \u2200 (n : \u2124), \u2191((-\u2191x\u271d - 1) * n) = (-\u2191x\u271d - 1) \u2022 \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "dist_triangle", "start": [187, 1], "end": [188, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Pointwise.lean", "full_name": "Real.iInf_mul_of_nonpos", "start": [140, 1], "end": [141, 51], "traced_tactics": [{"tactic": "simp only [Real.mul_iInf_of_nonpos ha, mul_comm]", "annotated_tactic": ["simp only [<a>Real.mul_iInf_of_nonpos</a> ha, <a>mul_comm</a>]", [{"full_name": "Real.mul_iInf_of_nonpos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Pointwise.lean", "def_pos": [124, 9], "def_end_pos": [124, 32]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\ninst\u271d : LinearOrderedField \u03b1\nr : \u211d\nha : r \u2264 0\nf : \u03b9 \u2192 \u211d\n\u22a2 (\u2a05 i, f i) * r = \u2a06 i, f i * r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Trace.lean", "full_name": "Matrix.trace_mul_comm", "start": [169, 1], "end": [170, 101], "traced_tactics": [{"tactic": "rw [\u2190 trace_transpose, \u2190 trace_transpose_mul, transpose_mul]", "annotated_tactic": ["rw [\u2190 <a>trace_transpose</a>, \u2190 <a>trace_transpose_mul</a>, <a>transpose_mul</a>]", [{"full_name": "Matrix.trace_transpose", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Trace.lean", "def_pos": [74, 9], "def_end_pos": [74, 24]}, {"full_name": "Matrix.trace_transpose_mul", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Trace.lean", "def_pos": [164, 9], "def_end_pos": [164, 28]}, {"full_name": "Matrix.transpose_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [2040, 9], "def_end_pos": [2040, 22]}]], "state_before": "\u03b9 : Type u_1\nm : Type u_2\nn : Type u_3\np : Type u_4\n\u03b1 : Type u_5\nR : Type u_6\nS : Type u_7\ninst\u271d\u2074 : Fintype m\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : Fintype p\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : CommSemigroup R\nA : Matrix m n R\nB : Matrix n m R\n\u22a2 trace (A * B) = trace (B * A)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Membership.lean", "full_name": "Submonoid.mem_sup_left", "start": [235, 1], "end": [237, 20], "traced_tactics": [{"tactic": "rw [\u2190 SetLike.le_def]", "annotated_tactic": ["rw [\u2190 <a>SetLike.le_def</a>]", [{"full_name": "SetLike.le_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 15]}]], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : MulOneClass M\nS T : Submonoid M\n\u22a2 \u2200 {x : M}, x \u2208 S \u2192 x \u2208 S \u2294 T", "state_after": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : MulOneClass M\nS T : Submonoid M\n\u22a2 S \u2264 S \u2294 T"}, {"tactic": "exact le_sup_left", "annotated_tactic": ["exact <a>le_sup_left</a>", [{"full_name": "le_sup_left", "def_path": ".lake/packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [112, 9], "def_end_pos": [112, 20]}]], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : MulOneClass M\nS T : Submonoid M\n\u22a2 S \u2264 S \u2294 T", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.lift_of", "start": [926, 1], "end": [926, 76], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2076 : CommSemiring k\ninst\u271d\u2075 : Monoid G\ninst\u271d\u2074 : Monoid H\nA : Type u\u2083\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra k A\nB : Type u_3\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra k B\nF : G \u2192* A\nx : G\n\u22a2 ((lift k G A) F) ((of k G) x) = F x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/UniformGroup.lean", "full_name": "uniformity_eq_comap_nhds_one'", "start": [579, 1], "end": [580, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/IntermediateField.lean", "full_name": "IntermediateField.sub_mem", "start": [181, 11], "end": [182, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "image2_upperBounds_upperBounds_subset", "start": [1382, 1], "end": [1384, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Membership.lean", "full_name": "IsScalarTower.of_mclosure_eq_top", "start": [608, 1], "end": [616, 42], "traced_tactics": [{"tactic": "refine' \u27e8fun x => Submonoid.induction_of_closure_eq_top_left htop x _ _\u27e9", "annotated_tactic": ["refine' \u27e8fun x => <a>Submonoid.induction_of_closure_eq_top_left</a> htop x _ _\u27e9", [{"full_name": "Submonoid.induction_of_closure_eq_top_left", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [432, 9], "def_end_pos": [432, 41]}]], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\n\u22a2 IsScalarTower M N \u03b1", "state_after": "case refine'_1\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\nx : M\n\u22a2 \u2200 (y : N) (z : \u03b1), (1 \u2022 y) \u2022 z = 1 \u2022 y \u2022 z\n\ncase refine'_2\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\nx : M\n\u22a2 \u2200 x \u2208 s,\n    \u2200 (y : M),\n      (\u2200 (y_1 : N) (z : \u03b1), (y \u2022 y_1) \u2022 z = y \u2022 y_1 \u2022 z) \u2192 \u2200 (y_1 : N) (z : \u03b1), ((x * y) \u2022 y_1) \u2022 z = (x * y) \u2022 y_1 \u2022 z"}, {"tactic": "intro y z", "annotated_tactic": ["intro y z", []], "state_before": "case refine'_1\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\nx : M\n\u22a2 \u2200 (y : N) (z : \u03b1), (1 \u2022 y) \u2022 z = 1 \u2022 y \u2022 z", "state_after": "case refine'_1\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\nx : M\ny : N\nz : \u03b1\n\u22a2 (1 \u2022 y) \u2022 z = 1 \u2022 y \u2022 z"}, {"tactic": "rw [one_smul, one_smul]", "annotated_tactic": ["rw [<a>one_smul</a>, <a>one_smul</a>]", [{"full_name": "one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [481, 9], "def_end_pos": [481, 17]}, {"full_name": "one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [481, 9], "def_end_pos": [481, 17]}]], "state_before": "case refine'_1\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\nx : M\ny : N\nz : \u03b1\n\u22a2 (1 \u2022 y) \u2022 z = 1 \u2022 y \u2022 z", "state_after": "no goals"}, {"tactic": "clear x", "annotated_tactic": ["clear x", []], "state_before": "case refine'_2\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\nx : M\n\u22a2 \u2200 x \u2208 s,\n    \u2200 (y : M),\n      (\u2200 (y_1 : N) (z : \u03b1), (y \u2022 y_1) \u2022 z = y \u2022 y_1 \u2022 z) \u2192 \u2200 (y_1 : N) (z : \u03b1), ((x * y) \u2022 y_1) \u2022 z = (x * y) \u2022 y_1 \u2022 z", "state_after": "case refine'_2\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\n\u22a2 \u2200 x \u2208 s,\n    \u2200 (y : M),\n      (\u2200 (y_1 : N) (z : \u03b1), (y \u2022 y_1) \u2022 z = y \u2022 y_1 \u2022 z) \u2192 \u2200 (y_1 : N) (z : \u03b1), ((x * y) \u2022 y_1) \u2022 z = (x * y) \u2022 y_1 \u2022 z"}, {"tactic": "intro x hx x' hx' y z", "annotated_tactic": ["intro x hx x' hx' y z", []], "state_before": "case refine'_2\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\n\u22a2 \u2200 x \u2208 s,\n    \u2200 (y : M),\n      (\u2200 (y_1 : N) (z : \u03b1), (y \u2022 y_1) \u2022 z = y \u2022 y_1 \u2022 z) \u2192 \u2200 (y_1 : N) (z : \u03b1), ((x * y) \u2022 y_1) \u2022 z = (x * y) \u2022 y_1 \u2022 z", "state_after": "case refine'_2\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\nx : M\nhx : x \u2208 s\nx' : M\nhx' : \u2200 (y : N) (z : \u03b1), (x' \u2022 y) \u2022 z = x' \u2022 y \u2022 z\ny : N\nz : \u03b1\n\u22a2 ((x * x') \u2022 y) \u2022 z = (x * x') \u2022 y \u2022 z"}, {"tactic": "rw [mul_smul, mul_smul, hs x hx, hx']", "annotated_tactic": ["rw [<a>mul_smul</a>, <a>mul_smul</a>, hs x hx, hx']", [{"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}, {"full_name": "MulAction.mul_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}]], "state_before": "case refine'_2\nM : Type u_1\nA : Type u_2\nB : Type u_3\nN : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M N\ninst\u271d\u00b9 : SMul N \u03b1\ninst\u271d : MulAction M \u03b1\ns : Set M\nhtop : Submonoid.closure s = \u22a4\nhs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z\nx : M\nhx : x \u2208 s\nx' : M\nhx' : \u2200 (y : N) (z : \u03b1), (x' \u2022 y) \u2022 z = x' \u2022 y \u2022 z\ny : N\nz : \u03b1\n\u22a2 ((x * x') \u2022 y) \u2022 z = (x * x') \u2022 y \u2022 z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "full_name": "AffineEquiv.constVAdd_symm", "start": [494, 1], "end": [495, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.sUnion_mem_empty_univ", "start": [1113, 1], "end": [1118, 53], "traced_tactics": [{"tactic": "simp only [mem_insert_iff, mem_singleton_iff, or_iff_not_imp_left, sUnion_eq_empty, not_forall]", "annotated_tactic": ["simp only [<a>mem_insert_iff</a>, <a>mem_singleton_iff</a>, <a>or_iff_not_imp_left</a>, <a>sUnion_eq_empty</a>, <a>not_forall</a>]", [{"full_name": "Set.mem_insert_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1117, 9], "def_end_pos": [1117, 23]}, {"full_name": "Set.mem_singleton_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1243, 9], "def_end_pos": [1243, 26]}, {"full_name": "Classical.or_iff_not_imp_left", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [141, 9], "def_end_pos": [141, 28]}, {"full_name": "Set.sUnion_eq_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1090, 9], "def_end_pos": [1090, 24]}, {"full_name": "Classical.not_forall", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [130, 17], "def_end_pos": [130, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\n\u22a2 \u22c3\u2080 S \u2208 {\u2205, univ}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\n\u22a2 (\u2203 x, \u2203 (_ : x \u2208 S), \u00acx = \u2205) \u2192 \u22c3\u2080 S = univ"}, {"tactic": "rintro \u27e8s, hs, hne\u27e9", "annotated_tactic": ["rintro \u27e8s, hs, hne\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\n\u22a2 (\u2203 x, \u2203 (_ : x \u2208 S), \u00acx = \u2205) \u2192 \u22c3\u2080 S = univ", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\ns : Set \u03b1\nhs : s \u2208 S\nhne : \u00acs = \u2205\n\u22a2 \u22c3\u2080 S = univ"}, {"tactic": "obtain rfl : s = univ := (h hs).resolve_left hne", "annotated_tactic": ["obtain rfl : s = <a>univ</a> := (h hs).<a>resolve_left</a> hne", [{"full_name": "Set.univ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [153, 5], "def_end_pos": [153, 9]}, {"full_name": "Or.resolve_left", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [551, 9], "def_end_pos": [551, 24]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\ns : Set \u03b1\nhs : s \u2208 S\nhne : \u00acs = \u2205\n\u22a2 \u22c3\u2080 S = univ", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\nhs : univ \u2208 S\nhne : \u00acuniv = \u2205\n\u22a2 \u22c3\u2080 S = univ"}, {"tactic": "exact univ_subset_iff.1 <| subset_sUnion_of_mem hs", "annotated_tactic": ["exact <a>univ_subset_iff</a>.1 <| <a>subset_sUnion_of_mem</a> hs", [{"full_name": "Set.univ_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [664, 9], "def_end_pos": [664, 24]}, {"full_name": "Set.subset_sUnion_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1021, 9], "def_end_pos": [1021, 29]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\nhs : univ \u2208 S\nhne : \u00acuniv = \u2205\n\u22a2 \u22c3\u2080 S = univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.finsuppTotal_apply", "start": [2009, 1], "end": [2013, 31], "traced_tactics": [{"tactic": "dsimp [finsuppTotal]", "annotated_tactic": ["dsimp [<a>finsuppTotal</a>]", [{"full_name": "Ideal.finsuppTotal", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [2003, 19], "def_end_pos": [2003, 31]}]], "state_before": "\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Module R M\nI : Ideal R\nv : \u03b9 \u2192 M\nhv : Submodule.span R (Set.range v) = \u22a4\nf : \u03b9 \u2192\u2080 \u21a5I\n\u22a2 (finsuppTotal \u03b9 M I v) f = Finsupp.sum f fun i x => \u2191x \u2022 v i", "state_after": "\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Module R M\nI : Ideal R\nv : \u03b9 \u2192 M\nhv : Submodule.span R (Set.range v) = \u22a4\nf : \u03b9 \u2192\u2080 \u21a5I\n\u22a2 (Finsupp.total \u03b9 M R v) (Finsupp.mapRange Subtype.val \u22ef f) = Finsupp.sum f fun i x => \u2191x \u2022 v i"}, {"tactic": "rw [Finsupp.total_apply, Finsupp.sum_mapRange_index]", "annotated_tactic": ["rw [<a>Finsupp.total_apply</a>, <a>Finsupp.sum_mapRange_index</a>]", [{"full_name": "Finsupp.total_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [666, 9], "def_end_pos": [666, 20]}, {"full_name": "Finsupp.sum_mapRange_index", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [81, 3], "def_end_pos": [81, 14]}]], "state_before": "\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Module R M\nI : Ideal R\nv : \u03b9 \u2192 M\nhv : Submodule.span R (Set.range v) = \u22a4\nf : \u03b9 \u2192\u2080 \u21a5I\n\u22a2 (Finsupp.total \u03b9 M R v) (Finsupp.mapRange Subtype.val \u22ef f) = Finsupp.sum f fun i x => \u2191x \u2022 v i", "state_after": "\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Module R M\nI : Ideal R\nv : \u03b9 \u2192 M\nhv : Submodule.span R (Set.range v) = \u22a4\nf : \u03b9 \u2192\u2080 \u21a5I\n\u22a2 \u2200 (a : \u03b9), 0 \u2022 v a = 0"}, {"tactic": "exact fun _ => zero_smul _ _", "annotated_tactic": ["exact fun _ => <a>zero_smul</a> _ _", [{"full_name": "zero_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}]], "state_before": "\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\nR : Type u_3\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Module R M\nI : Ideal R\nv : \u03b9 \u2192 M\nhv : Submodule.span R (Set.range v) = \u22a4\nf : \u03b9 \u2192\u2080 \u21a5I\n\u22a2 \u2200 (a : \u03b9), 0 \u2022 v a = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Multilinear/Basic.lean", "full_name": "ContinuousMultilinearMap.add_apply", "start": [201, 1], "end": [202, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Function.lean", "full_name": "LinearMap.convexOn", "start": [359, 1], "end": [360, 75], "traced_tactics": [{"tactic": "rw [f.map_add, f.map_smul, f.map_smul]", "annotated_tactic": ["rw [f.map_add, f.map_smul, f.map_smul]", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u2076 : OrderedSemiring \ud835\udd5c\ninst\u271d\u2075 : AddCommMonoid E\ninst\u271d\u2074 : AddCommMonoid F\ninst\u271d\u00b3 : OrderedAddCommMonoid \u03b1\ninst\u271d\u00b2 : OrderedAddCommMonoid \u03b2\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c \u03b2\nf : E \u2192\u2097[\ud835\udd5c] \u03b2\ns : Set E\nhs : Convex \ud835\udd5c s\nx\u271d\u2078 : E\nx\u271d\u2077 : x\u271d\u2078 \u2208 s\nx\u271d\u2076 : E\nx\u271d\u2075 : x\u271d\u2076 \u2208 s\nx\u271d\u2074 x\u271d\u00b3 : \ud835\udd5c\nx\u271d\u00b2 : 0 \u2264 x\u271d\u2074\nx\u271d\u00b9 : 0 \u2264 x\u271d\u00b3\nx\u271d : x\u271d\u2074 + x\u271d\u00b3 = 1\n\u22a2 f (x\u271d\u2074 \u2022 x\u271d\u2078 + x\u271d\u00b3 \u2022 x\u271d\u2076) \u2264 x\u271d\u2074 \u2022 f x\u271d\u2078 + x\u271d\u00b3 \u2022 f x\u271d\u2076", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.cons_induction_on", "start": [1266, 1], "end": [1268, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.dropSlice_eq_dropSliceTR", "start": [1226, 10], "end": [1235, 30], "traced_tactics": [{"tactic": "funext \u03b1 n m l", "annotated_tactic": ["funext \u03b1 n m l", []], "state_before": "\u22a2 @dropSlice = @dropSliceTR", "state_after": "case h.h.h.h\n\u03b1 : Type u_1\nn m : Nat\nl : List \u03b1\n\u22a2 dropSlice n m l = dropSliceTR n m l"}, {"tactic": "simp [dropSliceTR]", "annotated_tactic": ["simp [<a>dropSliceTR</a>]", [{"full_name": "List.dropSliceTR", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1210, 15], "def_end_pos": [1210, 26]}]], "state_before": "case h.h.h.h\n\u03b1 : Type u_1\nn m : Nat\nl : List \u03b1\n\u22a2 dropSlice n m l = dropSliceTR n m l", "state_after": "case h.h.h.h\n\u03b1 : Type u_1\nn m : Nat\nl : List \u03b1\n\u22a2 dropSlice n m l =\n    match m with\n    | 0 => l\n    | succ m => dropSliceTR.go l m l n #[]"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "case h.h.h.h\n\u03b1 : Type u_1\nn m : Nat\nl : List \u03b1\n\u22a2 dropSlice n m l =\n    match m with\n    | 0 => l\n    | succ m => dropSliceTR.go l m l n #[]", "state_after": "case h.h.h.h.h_1\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d : Nat\n\u22a2 dropSlice n 0 l = l\n\ncase h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d\u00b9 m\u271d : Nat\n\u22a2 dropSlice n (succ m\u271d) l = dropSliceTR.go l m\u271d l n #[]"}, {"tactic": "{ rw [dropSlice_zero\u2082] }", "annotated_tactic": ["{ rw [<a>dropSlice_zero\u2082</a>] }", [{"full_name": "List.dropSlice_zero\u2082", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1222, 9], "def_end_pos": [1222, 24]}]], "state_before": "case h.h.h.h.h_1\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d : Nat\n\u22a2 dropSlice n 0 l = l\n\ncase h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d\u00b9 m\u271d : Nat\n\u22a2 dropSlice n (succ m\u271d) l = dropSliceTR.go l m\u271d l n #[]", "state_after": "case h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d\u00b9 m\u271d : Nat\n\u22a2 dropSlice n (succ m\u271d) l = dropSliceTR.go l m\u271d l n #[]"}, {"tactic": "rename_i m", "annotated_tactic": ["rename_i m", []], "state_before": "case h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d\u00b9 m\u271d : Nat\n\u22a2 dropSlice n (succ m\u271d) l = dropSliceTR.go l m\u271d l n #[]", "state_after": "case h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d m : Nat\n\u22a2 dropSlice n (succ m) l = dropSliceTR.go l m l n #[]"}, {"tactic": "exact (go #[] _ _ rfl).symm", "annotated_tactic": ["exact (go #[] _ _ <a>rfl</a>).<a>symm</a>", [{"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d m : Nat\n\u22a2 dropSlice n (succ m) l = dropSliceTR.go l m l n #[]", "state_after": "no goals"}, {"tactic": "rw [dropSlice_zero\u2082]", "annotated_tactic": ["rw [<a>dropSlice_zero\u2082</a>]", [{"full_name": "List.dropSlice_zero\u2082", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1222, 9], "def_end_pos": [1222, 24]}]], "state_before": "case h.h.h.h.h_1\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d : Nat\n\u22a2 dropSlice n 0 l = l", "state_after": "no goals"}, {"tactic": "simp [dropSliceTR.go, dropSlice, h]", "annotated_tactic": ["simp [<a>dropSliceTR.go</a>, <a>dropSlice</a>, h]", [{"full_name": "List.dropSliceTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1217, 3], "def_end_pos": [1217, 5]}, {"full_name": "List.dropSlice", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1204, 13], "def_end_pos": [1204, 22]}]], "state_before": "\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nhead\u271d : \u03b1\nxs : List \u03b1\nh : l = acc.data ++ head\u271d :: xs\n\u22a2 dropSliceTR.go l m (head\u271d :: xs) 0 acc = acc.data ++ dropSlice 0 (m + 1) (head\u271d :: xs)", "state_after": "no goals"}, {"tactic": "simp [dropSliceTR.go, dropSlice]", "annotated_tactic": ["simp [<a>dropSliceTR.go</a>, <a>dropSlice</a>]", [{"full_name": "List.dropSliceTR.go", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1217, 3], "def_end_pos": [1217, 5]}, {"full_name": "List.dropSlice", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [1204, 13], "def_end_pos": [1204, 22]}]], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\n\u22a2 l = acc.data ++ x :: xs \u2192 dropSliceTR.go l m (x :: xs) (n + 1) acc = acc.data ++ dropSlice (n + 1) (m + 1) (x :: xs)", "state_after": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\n\u22a2 l = acc.data ++ x :: xs \u2192 dropSliceTR.go l m xs n (Array.push acc x) = acc.data ++ x :: dropSlice n (m + 1) xs"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\n\u22a2 l = acc.data ++ x :: xs \u2192 dropSliceTR.go l m xs n (Array.push acc x) = acc.data ++ x :: dropSlice n (m + 1) xs", "state_after": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 dropSliceTR.go l m xs n (Array.push acc x) = acc.data ++ x :: dropSlice n (m + 1) xs"}, {"tactic": "rw [go _ xs]", "annotated_tactic": ["rw [go _ xs]", []], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 dropSliceTR.go l m xs n (Array.push acc x) = acc.data ++ x :: dropSlice n (m + 1) xs", "state_after": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 (Array.push acc x).data ++ dropSlice n (m + 1) xs = acc.data ++ x :: dropSlice n (m + 1) xs\n\ncase a\n\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 l = (Array.push acc x).data ++ xs"}, {"tactic": "{simp}", "annotated_tactic": ["{simp}", []], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 (Array.push acc x).data ++ dropSlice n (m + 1) xs = acc.data ++ x :: dropSlice n (m + 1) xs\n\ncase a\n\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 l = (Array.push acc x).data ++ xs", "state_after": "case a\n\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 l = (Array.push acc x).data ++ xs"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case a\n\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 l = (Array.push acc x).data ++ xs", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 (Array.push acc x).data ++ dropSlice n (m + 1) xs = acc.data ++ x :: dropSlice n (m + 1) xs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.div_add_mod", "start": [1046, 1], "end": [1047, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Group/Arithmetic.lean", "full_name": "Measurable.mul_const", "start": [119, 1], "end": [121, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "full_name": "IsUnit.ne_zero", "start": [50, 1], "end": [52, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Adjoin.lean", "full_name": "IntermediateField.exists_finset_of_mem_iSup", "start": [883, 1], "end": [887, 16], "traced_tactics": [{"tactic": "have := (adjoin_simple_isCompactElement x).exists_finset_of_le_iSup (IntermediateField F E) f", "annotated_tactic": ["have := (<a>adjoin_simple_isCompactElement</a> x).<a>exists_finset_of_le_iSup</a> (<a>IntermediateField</a> F E) f", [{"full_name": "IntermediateField.adjoin_simple_isCompactElement", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [853, 9], "def_end_pos": [853, 39]}, {"full_name": "CompleteLattice.IsCompactElement.exists_finset_of_le_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompactlyGenerated/Basic.lean", "def_pos": [152, 9], "def_end_pos": [152, 50]}, {"full_name": "IntermediateField", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/IntermediateField.lean", "def_pos": [47, 11], "def_end_pos": [47, 28]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS : Set E\n\u03b1 : E\n\u03b9 : Type u_3\nf : \u03b9 \u2192 IntermediateField F E\nx : E\nhx : x \u2208 \u2a06 i, f i\n\u22a2 \u2203 s, x \u2208 \u2a06 i \u2208 s, f i", "state_after": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS : Set E\n\u03b1 : E\n\u03b9 : Type u_3\nf : \u03b9 \u2192 IntermediateField F E\nx : E\nhx : x \u2208 \u2a06 i, f i\nthis : F\u27eex\u27ef \u2264 \u2a06 i, f i \u2192 \u2203 s, F\u27eex\u27ef \u2264 \u2a06 i \u2208 s, f i\n\u22a2 \u2203 s, x \u2208 \u2a06 i \u2208 s, f i"}, {"tactic": "simp only [adjoin_simple_le_iff] at this", "annotated_tactic": ["simp only [<a>adjoin_simple_le_iff</a>] at this", [{"full_name": "IntermediateField.adjoin_simple_le_iff", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [846, 9], "def_end_pos": [846, 29]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS : Set E\n\u03b1 : E\n\u03b9 : Type u_3\nf : \u03b9 \u2192 IntermediateField F E\nx : E\nhx : x \u2208 \u2a06 i, f i\nthis : F\u27eex\u27ef \u2264 \u2a06 i, f i \u2192 \u2203 s, F\u27eex\u27ef \u2264 \u2a06 i \u2208 s, f i\n\u22a2 \u2203 s, x \u2208 \u2a06 i \u2208 s, f i", "state_after": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS : Set E\n\u03b1 : E\n\u03b9 : Type u_3\nf : \u03b9 \u2192 IntermediateField F E\nx : E\nhx : x \u2208 \u2a06 i, f i\nthis : x \u2208 \u2a06 i, f i \u2192 \u2203 s, x \u2208 \u2a06 i \u2208 s, f i\n\u22a2 \u2203 s, x \u2208 \u2a06 i \u2208 s, f i"}, {"tactic": "exact this hx", "annotated_tactic": ["exact this hx", []], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS : Set E\n\u03b1 : E\n\u03b9 : Type u_3\nf : \u03b9 \u2192 IntermediateField F E\nx : E\nhx : x \u2208 \u2a06 i, f i\nthis : x \u2208 \u2a06 i, f i \u2192 \u2203 s, x \u2208 \u2a06 i \u2208 s, f i\n\u22a2 \u2203 s, x \u2208 \u2a06 i \u2208 s, f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Associated.dvd_iff_dvd_right", "start": [582, 1], "end": [584, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "full_name": "MeasureTheory.exists_measurable_superset_forall_eq", "start": [221, 1], "end": [224, 93], "traced_tactics": [{"tactic": "simpa only [\u2190 measure_eq_trim] using\n  OuterMeasure.exists_measurable_superset_forall_eq_trim (fun i => (\u03bc i).toOuterMeasure) s", "annotated_tactic": ["simpa only [\u2190 <a>measure_eq_trim</a>] using\n    <a>OuterMeasure.exists_measurable_superset_forall_eq_trim</a> (fun i => (\u03bc i).toOuterMeasure) s", [{"full_name": "MeasureTheory.measure_eq_trim", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "def_pos": [155, 9], "def_end_pos": [155, 24]}, {"full_name": "MeasureTheory.OuterMeasure.exists_measurable_superset_forall_eq_trim", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/OuterMeasure/Basic.lean", "def_pos": [1706, 9], "def_end_pos": [1706, 50]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc\u271d \u03bc\u2081 \u03bc\u2082 : Measure \u03b1\ns\u271d s\u2081 s\u2082 t : Set \u03b1\ninst\u271d : Countable \u03b9\n\u03bc : \u03b9 \u2192 Measure \u03b1\ns : Set \u03b1\n\u22a2 \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 (i : \u03b9), \u2191\u2191(\u03bc i) t = \u2191\u2191(\u03bc i) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.isLittleO_const_mul_right_iff", "start": [1598, 1], "end": [1600, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Char.lean", "full_name": "String.csize_eq", "start": [12, 9], "end": [16, 71], "traced_tactics": [{"tactic": "simp only [csize, Char.utf8Size]", "annotated_tactic": ["simp only [<a>csize</a>, <a>Char.utf8Size</a>]", [{"full_name": "String.csize", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2422, 5], "def_end_pos": [2422, 17]}, {"full_name": "Char.utf8Size", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2184, 5], "def_end_pos": [2184, 18]}]], "state_before": "c : Char\n\u22a2 csize c = 1 \u2228 csize c = 2 \u2228 csize c = 3 \u2228 csize c = 4", "state_after": "c : Char\n\u22a2 UInt32.toNat\n        (if c.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1 then UInt32.ofNatCore 1 Char.utf8Size.proof_2\n        else\n          if c.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3 then UInt32.ofNatCore 2 Char.utf8Size.proof_4\n          else\n            if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n            else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n      1 \u2228\n    UInt32.toNat\n          (if c.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1 then UInt32.ofNatCore 1 Char.utf8Size.proof_2\n          else\n            if c.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3 then UInt32.ofNatCore 2 Char.utf8Size.proof_4\n            else\n              if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n              else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n        2 \u2228\n      UInt32.toNat\n            (if c.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1 then UInt32.ofNatCore 1 Char.utf8Size.proof_2\n            else\n              if c.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3 then UInt32.ofNatCore 2 Char.utf8Size.proof_4\n              else\n                if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n                else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n          3 \u2228\n        UInt32.toNat\n            (if c.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1 then UInt32.ofNatCore 1 Char.utf8Size.proof_2\n            else\n              if c.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3 then UInt32.ofNatCore 2 Char.utf8Size.proof_4\n              else\n                if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n                else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n          4"}, {"tactic": "repeat (first | split | (solve | simp (config := {decide := true})))", "annotated_tactic": ["repeat (first | split | (solve | simp (config := {decide := <a>true</a>})))", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "c : Char\n\u22a2 UInt32.toNat\n        (if c.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1 then UInt32.ofNatCore 1 Char.utf8Size.proof_2\n        else\n          if c.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3 then UInt32.ofNatCore 2 Char.utf8Size.proof_4\n          else\n            if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n            else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n      1 \u2228\n    UInt32.toNat\n          (if c.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1 then UInt32.ofNatCore 1 Char.utf8Size.proof_2\n          else\n            if c.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3 then UInt32.ofNatCore 2 Char.utf8Size.proof_4\n            else\n              if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n              else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n        2 \u2228\n      UInt32.toNat\n            (if c.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1 then UInt32.ofNatCore 1 Char.utf8Size.proof_2\n            else\n              if c.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3 then UInt32.ofNatCore 2 Char.utf8Size.proof_4\n              else\n                if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n                else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n          3 \u2228\n        UInt32.toNat\n            (if c.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1 then UInt32.ofNatCore 1 Char.utf8Size.proof_2\n            else\n              if c.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3 then UInt32.ofNatCore 2 Char.utf8Size.proof_4\n              else\n                if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n                else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n          4", "state_after": "no goals"}, {"tactic": "(first | split | (solve | simp (config := {decide := true})))", "annotated_tactic": ["(first | split | (solve | simp (config := {decide := <a>true</a>})))", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "case inr.inr.inr\nc : Char\nh\u271d\u00b2 : \u00acc.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1\nh\u271d\u00b9 : \u00acc.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3\nh\u271d : \u00acc.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5\n\u22a2 UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 1 \u2228\n    UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 2 \u2228\n      UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 3 \u2228\n        UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 4", "state_after": "no goals"}, {"tactic": "first | split | (solve | simp (config := {decide := true}))", "annotated_tactic": ["first | split | (solve | simp (config := {decide := <a>true</a>}))", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "case inr.inr.inr\nc : Char\nh\u271d\u00b2 : \u00acc.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1\nh\u271d\u00b9 : \u00acc.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3\nh\u271d : \u00acc.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5\n\u22a2 UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 1 \u2228\n    UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 2 \u2228\n      UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 3 \u2228\n        UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 4", "state_after": "no goals"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "case inr.inr\nc : Char\nh\u271d\u00b9 : \u00acc.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1\nh\u271d : \u00acc.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3\n\u22a2 UInt32.toNat\n        (if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n        else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n      1 \u2228\n    UInt32.toNat\n          (if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n          else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n        2 \u2228\n      UInt32.toNat\n            (if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n            else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n          3 \u2228\n        UInt32.toNat\n            (if c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5 then UInt32.ofNatCore 3 Char.utf8Size.proof_6\n            else UInt32.ofNatCore 4 Char.utf8Size.proof_7) =\n          4", "state_after": "case inr.inr.inl\nc : Char\nh\u271d\u00b2 : \u00acc.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1\nh\u271d\u00b9 : \u00acc.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3\nh\u271d : c.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5\n\u22a2 UInt32.toNat (UInt32.ofNatCore 3 Char.utf8Size.proof_6) = 1 \u2228\n    UInt32.toNat (UInt32.ofNatCore 3 Char.utf8Size.proof_6) = 2 \u2228\n      UInt32.toNat (UInt32.ofNatCore 3 Char.utf8Size.proof_6) = 3 \u2228\n        UInt32.toNat (UInt32.ofNatCore 3 Char.utf8Size.proof_6) = 4\n\ncase inr.inr.inr\nc : Char\nh\u271d\u00b2 : \u00acc.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1\nh\u271d\u00b9 : \u00acc.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3\nh\u271d : \u00acc.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5\n\u22a2 UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 1 \u2228\n    UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 2 \u2228\n      UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 3 \u2228\n        UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 4"}, {"tactic": "(solve | simp (config := {decide := true}))", "annotated_tactic": ["(solve | simp (config := {decide := <a>true</a>}))", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "case inr.inr.inr\nc : Char\nh\u271d\u00b2 : \u00acc.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1\nh\u271d\u00b9 : \u00acc.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3\nh\u271d : \u00acc.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5\n\u22a2 UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 1 \u2228\n    UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 2 \u2228\n      UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 3 \u2228\n        UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 4", "state_after": "no goals"}, {"tactic": "solve | simp (config := {decide := true})", "annotated_tactic": ["solve | simp (config := {decide := <a>true</a>})", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "case inr.inr.inr\nc : Char\nh\u271d\u00b2 : \u00acc.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1\nh\u271d\u00b9 : \u00acc.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3\nh\u271d : \u00acc.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5\n\u22a2 UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 1 \u2228\n    UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 2 \u2228\n      UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 3 \u2228\n        UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 4", "state_after": "no goals"}, {"tactic": "simp (config := {decide := true})", "annotated_tactic": ["simp (config := {decide := <a>true</a>})", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}]], "state_before": "case inr.inr.inr\nc : Char\nh\u271d\u00b2 : \u00acc.val \u2264 UInt32.ofNatCore 127 Char.utf8Size.proof_1\nh\u271d\u00b9 : \u00acc.val \u2264 UInt32.ofNatCore 2047 Char.utf8Size.proof_3\nh\u271d : \u00acc.val \u2264 UInt32.ofNatCore 65535 Char.utf8Size.proof_5\n\u22a2 UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 1 \u2228\n    UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 2 \u2228\n      UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 3 \u2228\n        UInt32.toNat (UInt32.ofNatCore 4 Char.utf8Size.proof_7) = 4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Free/Basic.lean", "full_name": "CategoryTheory.FreeMonoidalCategory.mk_id", "start": [216, 1], "end": [217, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "full_name": "MeasureTheory.SimpleFunc.coe_zpow", "start": [620, 1], "end": [621, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "full_name": "map_zpow\u2080", "start": [119, 1], "end": [121, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Function/Indicator.lean", "full_name": "Set.indicator_eq_one_iff_mem", "start": [609, 1], "end": [610, 46], "traced_tactics": [{"tactic": "classical simp [indicator_apply, imp_false]", "annotated_tactic": ["classical simp [<a>indicator_apply</a>, <a>imp_false</a>]", [{"full_name": "Set.indicator_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [58, 3], "def_end_pos": [58, 14]}, {"full_name": "imp_false", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1408, 9], "def_end_pos": [1408, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : MulZeroOneClass M\ninst\u271d : Nontrivial M\nU : Set \u03b1\nx : \u03b1\n\u22a2 indicator U 1 x = 1 \u2194 x \u2208 U", "state_after": "no goals"}, {"tactic": "simp [indicator_apply, imp_false]", "annotated_tactic": ["simp [<a>indicator_apply</a>, <a>imp_false</a>]", [{"full_name": "Set.indicator_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [58, 3], "def_end_pos": [58, 14]}, {"full_name": "imp_false", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1408, 9], "def_end_pos": [1408, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : MulZeroOneClass M\ninst\u271d : Nontrivial M\nU : Set \u03b1\nx : \u03b1\n\u22a2 indicator U 1 x = 1 \u2194 x \u2208 U", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.ker_int_castAddHom", "start": [594, 1], "end": [598, 35], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "n : \u2115\n\u22a2 AddMonoidHom.ker (Int.castAddHom (ZMod n)) = AddSubgroup.zmultiples \u2191n", "state_after": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 AddMonoidHom.ker (Int.castAddHom (ZMod n)) \u2194 x\u271d \u2208 AddSubgroup.zmultiples \u2191n"}, {"tactic": "rw [Int.mem_zmultiples_iff, AddMonoidHom.mem_ker, Int.coe_castAddHom,\n  int_cast_zmod_eq_zero_iff_dvd]", "annotated_tactic": ["rw [<a>Int.mem_zmultiples_iff</a>, <a>AddMonoidHom.mem_ker</a>, <a>Int.coe_castAddHom</a>,\n    <a>int_cast_zmod_eq_zero_iff_dvd</a>]", [{"full_name": "Int.mem_zmultiples_iff", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/ZPowers.lean", "def_pos": [171, 9], "def_end_pos": [171, 31]}, {"full_name": "AddMonoidHom.mem_ker", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [2811, 3], "def_end_pos": [2811, 14]}, {"full_name": "Int.coe_castAddHom", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [72, 9], "def_end_pos": [72, 23]}, {"full_name": "ZMod.int_cast_zmod_eq_zero_iff_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/ZMod/Basic.lean", "def_pos": [511, 9], "def_end_pos": [511, 38]}]], "state_before": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 AddMonoidHom.ker (Int.castAddHom (ZMod n)) \u2194 x\u271d \u2208 AddSubgroup.zmultiples \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Complex.exp_int_mul_two_pi_mul_I", "start": [1362, 1], "end": [1363, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/IterateHom.lean", "full_name": "RingHom.iterate_map_zero", "start": [134, 1], "end": [135, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Bits.lean", "full_name": "Nat.bit0_eq_zero", "start": [152, 11], "end": [153, 58], "traced_tactics": [{"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "n\u271d n : \u2115\nh : n = 0\n\u22a2 bit0 n = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Equivalence.lean", "full_name": "CategoryTheory.Equivalence.adjointify_\u03b7_\u03b5", "start": [257, 1], "end": [265, 83], "traced_tactics": [{"tactic": "dsimp [adjointify\u03b7,Trans.trans]", "annotated_tactic": ["dsimp [<a>adjointify\u03b7</a>,<a>Trans.trans</a>]", [{"full_name": "CategoryTheory.Equivalence.adjointify\u03b7", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Equivalence.lean", "def_pos": [245, 5], "def_end_pos": [245, 16]}, {"full_name": "Trans.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1151, 3], "def_end_pos": [1151, 8]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map ((adjointify\u03b7 \u03b7 \u03b5).hom.app X) \u226b \u03b5.hom.app (F.obj X) = \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map\n        ((((((\u03b7.hom.app X \u226b \ud835\udfd9 (G.obj (F.obj X))) \u226b G.map (\u03b5.inv.app (F.obj X))) \u226b \ud835\udfd9 (G.obj (F.obj (G.obj (F.obj X))))) \u226b\n              \ud835\udfd9 (G.obj (F.obj (G.obj (F.obj X))))) \u226b\n            G.map (F.map (\u03b7.inv.app X))) \u226b\n          \ud835\udfd9 (G.obj (F.obj X))) \u226b\n      \u03b5.hom.app (F.obj X) =\n    \ud835\udfd9 (F.obj X)"}, {"tactic": "simp only [comp_id, assoc, map_comp]", "annotated_tactic": ["simp only [<a>comp_id</a>, <a>assoc</a>, <a>map_comp</a>]", [{"full_name": "CategoryTheory.Category.comp_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [166, 3], "def_end_pos": [166, 10]}, {"full_name": "CategoryTheory.Category.assoc", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [168, 3], "def_end_pos": [168, 8]}, {"full_name": "CategoryTheory.Functor.map_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Functor/Basic.lean", "def_pos": [43, 3], "def_end_pos": [43, 11]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map\n        ((((((\u03b7.hom.app X \u226b \ud835\udfd9 (G.obj (F.obj X))) \u226b G.map (\u03b5.inv.app (F.obj X))) \u226b \ud835\udfd9 (G.obj (F.obj (G.obj (F.obj X))))) \u226b\n              \ud835\udfd9 (G.obj (F.obj (G.obj (F.obj X))))) \u226b\n            G.map (F.map (\u03b7.inv.app X))) \u226b\n          \ud835\udfd9 (G.obj (F.obj X))) \u226b\n      \u03b5.hom.app (F.obj X) =\n    \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) =\n    \ud835\udfd9 (F.obj X)"}, {"tactic": "have := \u03b5.hom.naturality (F.map (\u03b7.inv.app X))", "annotated_tactic": ["have := \u03b5.hom.naturality (F.map (\u03b7.inv.app X))", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) =\n    \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  (G \u22d9 F).map (F.map (\u03b7.inv.app X)) \u226b \u03b5.hom.app (F.obj ((\ud835\udfed C).obj X)) =\n    \u03b5.hom.app (F.obj ((F \u22d9 G).obj X)) \u226b (\ud835\udfed D).map (F.map (\u03b7.inv.app X))\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) =\n    \ud835\udfd9 (F.obj X)"}, {"tactic": "dsimp at this", "annotated_tactic": ["dsimp at this", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  (G \u22d9 F).map (F.map (\u03b7.inv.app X)) \u226b \u03b5.hom.app (F.obj ((\ud835\udfed C).obj X)) =\n    \u03b5.hom.app (F.obj ((F \u22d9 G).obj X)) \u226b (\ud835\udfed D).map (F.map (\u03b7.inv.app X))\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) =\n    \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) = \u03b5.hom.app (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) =\n    \ud835\udfd9 (F.obj X)"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) = \u03b5.hom.app (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) =\n    \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) = \u03b5.hom.app (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)"}, {"tactic": "clear this", "annotated_tactic": ["clear this", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  F.map (G.map (F.map (\u03b7.inv.app X))) \u226b \u03b5.hom.app (F.obj X) = \u03b5.hom.app (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)"}, {"tactic": "rw [\u2190 assoc _ _ (F.map _)]", "annotated_tactic": ["rw [\u2190 <a>assoc</a> _ _ (F.map _)]", [{"full_name": "CategoryTheory.Category.assoc", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [168, 3], "def_end_pos": [168, 8]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      (F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X)))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)"}, {"tactic": "have := \u03b5.hom.naturality (\u03b5.inv.app <| F.obj X)", "annotated_tactic": ["have := \u03b5.hom.naturality (\u03b5.inv.app <| F.obj X)", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      (F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X)))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  (G \u22d9 F).map (\u03b5.inv.app (F.obj X)) \u226b \u03b5.hom.app ((G \u22d9 F).obj (F.obj X)) =\n    \u03b5.hom.app ((\ud835\udfed D).obj (F.obj X)) \u226b (\ud835\udfed D).map (\u03b5.inv.app (F.obj X))\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      (F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X)))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)"}, {"tactic": "dsimp at this", "annotated_tactic": ["dsimp at this", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  (G \u22d9 F).map (\u03b5.inv.app (F.obj X)) \u226b \u03b5.hom.app ((G \u22d9 F).obj (F.obj X)) =\n    \u03b5.hom.app ((\ud835\udfed D).obj (F.obj X)) \u226b (\ud835\udfed D).map (\u03b5.inv.app (F.obj X))\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      (F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X)))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X))) = \u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      (F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X)))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X))) = \u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b\n      (F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X)))) \u226b F.map (\u03b7.inv.app X) =\n    \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X))) = \u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b (\u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)"}, {"tactic": "clear this", "annotated_tactic": ["clear this", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis :\n  F.map (G.map (\u03b5.inv.app (F.obj X))) \u226b \u03b5.hom.app (F.obj (G.obj (F.obj X))) = \u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b (\u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b (\u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)"}, {"tactic": "have := (\u03b5.app <| F.obj X).hom_inv_id", "annotated_tactic": ["have := (\u03b5.app <| F.obj X).<a>hom_inv_id</a>", [{"full_name": "CategoryTheory.Iso.hom_inv_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [57, 3], "def_end_pos": [57, 13]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b (\u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : (\u03b5.app (F.obj X)).hom \u226b (\u03b5.app (F.obj X)).inv = \ud835\udfd9 ((G \u22d9 F).obj (F.obj X))\n\u22a2 F.map (\u03b7.hom.app X) \u226b (\u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)"}, {"tactic": "dsimp at this", "annotated_tactic": ["dsimp at this", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : (\u03b5.app (F.obj X)).hom \u226b (\u03b5.app (F.obj X)).inv = \ud835\udfd9 ((G \u22d9 F).obj (F.obj X))\n\u22a2 F.map (\u03b7.hom.app X) \u226b (\u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : \u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X) = \ud835\udfd9 (F.obj (G.obj (F.obj X)))\n\u22a2 F.map (\u03b7.hom.app X) \u226b (\u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : \u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X) = \ud835\udfd9 (F.obj (G.obj (F.obj X)))\n\u22a2 F.map (\u03b7.hom.app X) \u226b (\u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X)) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : \u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X) = \ud835\udfd9 (F.obj (G.obj (F.obj X)))\n\u22a2 F.map (\u03b7.hom.app X) \u226b \ud835\udfd9 (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)"}, {"tactic": "clear this", "annotated_tactic": ["clear this", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : \u03b5.hom.app (F.obj X) \u226b \u03b5.inv.app (F.obj X) = \ud835\udfd9 (F.obj (G.obj (F.obj X)))\n\u22a2 F.map (\u03b7.hom.app X) \u226b \ud835\udfd9 (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b \ud835\udfd9 (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)"}, {"tactic": "rw [id_comp]", "annotated_tactic": ["rw [<a>id_comp</a>]", [{"full_name": "CategoryTheory.Category.id_comp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [164, 3], "def_end_pos": [164, 10]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b \ud835\udfd9 (F.obj (G.obj (F.obj X))) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)"}, {"tactic": "have := (F.mapIso <| \u03b7.app X).hom_inv_id", "annotated_tactic": ["have := (F.mapIso <| \u03b7.app X).<a>hom_inv_id</a>", [{"full_name": "CategoryTheory.Iso.hom_inv_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Iso.lean", "def_pos": [57, 3], "def_end_pos": [57, 13]}]], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\n\u22a2 F.map (\u03b7.hom.app X) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : (F.mapIso (\u03b7.app X)).hom \u226b (F.mapIso (\u03b7.app X)).inv = \ud835\udfd9 (F.obj ((\ud835\udfed C).obj X))\n\u22a2 F.map (\u03b7.hom.app X) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)"}, {"tactic": "dsimp at this", "annotated_tactic": ["dsimp at this", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : (F.mapIso (\u03b7.app X)).hom \u226b (F.mapIso (\u03b7.app X)).inv = \ud835\udfd9 (F.obj ((\ud835\udfed C).obj X))\n\u22a2 F.map (\u03b7.hom.app X) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : F.map (\u03b7.hom.app X) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\n\u03b7 : \ud835\udfed C \u2245 F \u22d9 G\n\u03b5 : G \u22d9 F \u2245 \ud835\udfed D\nX : C\nthis : F.map (\u03b7.hom.app X) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)\n\u22a2 F.map (\u03b7.hom.app X) \u226b F.map (\u03b7.inv.app X) = \ud835\udfd9 (F.obj X)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "StrictMono.maximal_of_maximal_image", "start": [888, 1], "end": [890, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "mul_lt_of_mul_lt_left", "start": [223, 1], "end": [226, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "Differentiable.clm_comp", "start": [92, 1], "end": [93, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Cones.lean", "full_name": "CategoryTheory.Limits.coconeOfConeLeftOp_\u03b9_app", "start": [937, 1], "end": [940, 7], "traced_tactics": [{"tactic": "dsimp only [coconeOfConeLeftOp]", "annotated_tactic": ["dsimp only [<a>coconeOfConeLeftOp</a>]", [{"full_name": "CategoryTheory.Limits.coconeOfConeLeftOp", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/Cones.lean", "def_pos": [931, 5], "def_end_pos": [931, 23]}]], "state_before": "J : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\u1d52\u1d56\nc : Cone F.leftOp\nj : J\n\u22a2 (coconeOfConeLeftOp c).\u03b9.app j = (c.\u03c0.app (op j)).op", "state_after": "J : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\u1d52\u1d56\nc : Cone F.leftOp\nj : J\n\u22a2 (NatTrans.removeLeftOp c.\u03c0).app j = (c.\u03c0.app (op j)).op"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "J : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\u1d52\u1d56\nc : Cone F.leftOp\nj : J\n\u22a2 (NatTrans.removeLeftOp c.\u03c0).app j = (c.\u03c0.app (op j)).op", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "full_name": "AffineIsometryEquiv.pointReflection_self", "start": [788, 1], "end": [789, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Solvable.lean", "full_name": "map_derivedSeries_eq", "start": [92, 1], "end": [94, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Divisors.lean", "full_name": "Nat.divisors_inj", "start": [384, 1], "end": [385, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "full_name": "Matrix.adjugate_one", "start": [336, 1], "end": [338, 66], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\n\u22a2 adjugate 1 = 1", "state_after": "case a.h\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\ni\u271d x\u271d : n\n\u22a2 adjugate 1 i\u271d x\u271d = 1 i\u271d x\u271d"}, {"tactic": "simp [adjugate_def, Matrix.one_apply, Pi.single_apply, eq_comm]", "annotated_tactic": ["simp [<a>adjugate_def</a>, <a>Matrix.one_apply</a>, <a>Pi.single_apply</a>, <a>eq_comm</a>]", [{"full_name": "Matrix.adjugate_def", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "def_pos": [209, 9], "def_end_pos": [209, 21]}, {"full_name": "Matrix.one_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [554, 9], "def_end_pos": [554, 18]}, {"full_name": "Pi.single_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [394, 3], "def_end_pos": [394, 14]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "case a.h\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\ni\u271d x\u271d : n\n\u22a2 adjugate 1 i\u271d x\u271d = 1 i\u271d x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "LatticeHom.coe_comp_inf_hom'", "start": [1126, 1], "end": [1128, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Compare.lean", "full_name": "cmp_eq_cmp_symm", "start": [246, 1], "end": [248, 58], "traced_tactics": [{"tactic": "rwa [\u2190 cmp_swap x', \u2190 cmp_swap, swap_inj]", "annotated_tactic": ["rwa [\u2190 <a>cmp_swap</a> x', \u2190 <a>cmp_swap</a>, <a>swap_inj</a>]", [{"full_name": "cmp_swap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Compare.lean", "def_pos": [177, 9], "def_end_pos": [177, 17]}, {"full_name": "cmp_swap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Compare.lean", "def_pos": [177, 9], "def_end_pos": [177, 17]}, {"full_name": "Ordering.swap_inj", "def_path": ".lake/packages/std/Std/Classes/Order.lean", "def_pos": [11, 17], "def_end_pos": [11, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\nx y : \u03b1\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nx' y' : \u03b2\nh : cmp x y = cmp x' y'\n\u22a2 cmp y x = cmp y' x'", "state_after": "no goals"}, {"tactic": "rwa [\u2190 cmp_swap y', \u2190 cmp_swap, swap_inj]", "annotated_tactic": ["rwa [\u2190 <a>cmp_swap</a> y', \u2190 <a>cmp_swap</a>, <a>swap_inj</a>]", [{"full_name": "cmp_swap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Compare.lean", "def_pos": [177, 9], "def_end_pos": [177, 17]}, {"full_name": "cmp_swap", "def_path": ".lake/packages/mathlib/Mathlib/Order/Compare.lean", "def_pos": [177, 9], "def_end_pos": [177, 17]}, {"full_name": "Ordering.swap_inj", "def_path": ".lake/packages/std/Std/Classes/Order.lean", "def_pos": [11, 17], "def_end_pos": [11, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2\u271d : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\nx y : \u03b1\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nx' y' : \u03b2\nh : cmp y x = cmp y' x'\n\u22a2 cmp x y = cmp x' y'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.toFinsupp_X", "start": [582, 1], "end": [583, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousOn.lean", "full_name": "ContinuousWithinAt.mem_closure_image", "start": [778, 1], "end": [781, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometryEquiv.symm_neg", "start": [1139, 1], "end": [1140, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "mul_lt_mul_of_neg_right", "start": [672, 1], "end": [678, 71], "traced_tactics": [{"tactic": "obtain \u27e8d, hcd\u27e9 := exists_add_of_le hc.le", "annotated_tactic": ["obtain \u27e8d, hcd\u27e9 := <a>exists_add_of_le</a> hc.le", [{"full_name": "ExistsAddOfLE.exists_add_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [34, 3], "def_end_pos": [34, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na b c d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nh : b < a\nhc : c < 0\n\u22a2 a * c < b * c", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nh : b < a\nhc : c < 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c < b * c"}, {"tactic": "refine (add_lt_add_iff_right (b * d + a * d)).1 ?_", "annotated_tactic": ["refine (<a>add_lt_add_iff_right</a> (b * d + a * d)).1 ?_", [{"full_name": "add_lt_add_iff_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [112, 3], "def_end_pos": [112, 14]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nh : b < a\nhc : c < 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c < b * c", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nh : b < a\nhc : c < 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c + (b * d + a * d) < b * c + (b * d + a * d)"}, {"tactic": "calc\n  _ = b * d := by rw [add_left_comm, \u2190 mul_add, \u2190 hcd, mul_zero, add_zero]\n  _ < a * d := mul_lt_mul_of_pos_right h <| hcd.trans_lt <| add_lt_of_neg_left _ hc\n  _ = _ := by rw [\u2190 add_assoc, \u2190 mul_add, \u2190 hcd, mul_zero, zero_add]", "annotated_tactic": ["calc\n    _ = b * d := by rw [<a>add_left_comm</a>, \u2190 <a>mul_add</a>, \u2190 hcd, <a>mul_zero</a>, <a>add_zero</a>]\n    _ < a * d := <a>mul_lt_mul_of_pos_right</a> h <| hcd.trans_lt <| <a>add_lt_of_neg_left</a> _ hc\n    _ = _ := by rw [\u2190 <a>add_assoc</a>, \u2190 <a>mul_add</a>, \u2190 hcd, <a>mul_zero</a>, <a>zero_add</a>]", [{"full_name": "add_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [155, 3], "def_end_pos": [155, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "mul_lt_mul_of_pos_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [220, 9], "def_end_pos": [220, 32]}, {"full_name": "add_lt_of_neg_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [523, 15], "def_end_pos": [523, 33]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nh : b < a\nhc : c < 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c + (b * d + a * d) < b * c + (b * d + a * d)", "state_after": "no goals"}, {"tactic": "rw [add_left_comm, \u2190 mul_add, \u2190 hcd, mul_zero, add_zero]", "annotated_tactic": ["rw [<a>add_left_comm</a>, \u2190 <a>mul_add</a>, \u2190 hcd, <a>mul_zero</a>, <a>add_zero</a>]", [{"full_name": "add_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [155, 3], "def_end_pos": [155, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nh : b < a\nhc : c < 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * c + (b * d + a * d) = b * d", "state_after": "no goals"}, {"tactic": "rw [\u2190 add_assoc, \u2190 mul_add, \u2190 hcd, mul_zero, zero_add]", "annotated_tactic": ["rw [\u2190 <a>add_assoc</a>, \u2190 <a>mul_add</a>, \u2190 hcd, <a>mul_zero</a>, <a>zero_add</a>]", [{"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : StrictOrderedSemiring \u03b1\na b c d\u271d : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nh : b < a\nhc : c < 0\nd : \u03b1\nhcd : 0 = c + d\n\u22a2 a * d = b * c + (b * d + a * d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "gc_lowerClosure_coe", "start": [1502, 1], "end": [1503, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/PartialEquiv.lean", "full_name": "PartialEquiv.mapsTo", "start": [226, 11], "end": [226, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Defs.lean", "full_name": "Finsupp.erase_update_of_ne", "start": [701, 1], "end": [703, 68], "traced_tactics": [{"tactic": "rw [erase_eq_update_zero, erase_eq_update_zero, update_comm _ ha]", "annotated_tactic": ["rw [<a>erase_eq_update_zero</a>, <a>erase_eq_update_zero</a>, <a>update_comm</a> _ ha]", [{"full_name": "Finsupp.erase_eq_update_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [696, 9], "def_end_pos": [696, 29]}, {"full_name": "Finsupp.erase_eq_update_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [696, 9], "def_end_pos": [696, 29]}, {"full_name": "Finsupp.update_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [608, 9], "def_end_pos": [608, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d : Zero M\nf : \u03b1 \u2192\u2080 M\na a' : \u03b1\nha : a \u2260 a'\nb : M\n\u22a2 erase a (update f a' b) = update (erase a f) a' b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Determinant.lean", "full_name": "is_basis_iff_det", "start": [542, 1], "end": [558, 45], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4 \u2194 IsUnit ((Basis.det e) v)", "state_after": "case mp\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4 \u2192 IsUnit ((Basis.det e) v)\n\ncase mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\n\u22a2 IsUnit ((Basis.det e) v) \u2192 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4"}, {"tactic": "rintro \u27e8hli, hspan\u27e9", "annotated_tactic": ["rintro \u27e8hli, hspan\u27e9", []], "state_before": "case mp\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4 \u2192 IsUnit ((Basis.det e) v)", "state_after": "case mp.intro\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\n\u22a2 IsUnit ((Basis.det e) v)"}, {"tactic": "set v' := Basis.mk hli hspan.ge", "annotated_tactic": ["set v' := <a>Basis.mk</a> hli hspan.ge", [{"full_name": "Basis.mk", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [1105, 29], "def_end_pos": [1105, 31]}]], "state_before": "case mp.intro\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\n\u22a2 IsUnit ((Basis.det e) v)", "state_after": "case mp.intro\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\nv' : Basis \u03b9 R M := Basis.mk hli \u22ef\n\u22a2 IsUnit ((Basis.det e) v)"}, {"tactic": "rw [e.det_apply]", "annotated_tactic": ["rw [e.det_apply]", []], "state_before": "case mp.intro\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\nv' : Basis \u03b9 R M := Basis.mk hli \u22ef\n\u22a2 IsUnit ((Basis.det e) v)", "state_after": "case mp.intro\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\nv' : Basis \u03b9 R M := Basis.mk hli \u22ef\n\u22a2 IsUnit (det (Basis.toMatrix e v))"}, {"tactic": "convert LinearEquiv.isUnit_det (LinearEquiv.refl R M) v' e using 2", "annotated_tactic": ["convert <a>LinearEquiv.isUnit_det</a> (<a>LinearEquiv.refl</a> R M) v' e using 2", [{"full_name": "LinearEquiv.isUnit_det", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [421, 9], "def_end_pos": [421, 31]}, {"full_name": "LinearEquiv.refl", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [257, 5], "def_end_pos": [257, 9]}]], "state_before": "case mp.intro\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\nv' : Basis \u03b9 R M := Basis.mk hli \u22ef\n\u22a2 IsUnit (det (Basis.toMatrix e v))", "state_after": "case h.e'_3.h.e'_6\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\nv' : Basis \u03b9 R M := Basis.mk hli \u22ef\n\u22a2 Basis.toMatrix e v = (toMatrix v' e) \u2191(LinearEquiv.refl R M)"}, {"tactic": "ext i j", "annotated_tactic": ["ext i j", []], "state_before": "case h.e'_3.h.e'_6\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\nv' : Basis \u03b9 R M := Basis.mk hli \u22ef\n\u22a2 Basis.toMatrix e v = (toMatrix v' e) \u2191(LinearEquiv.refl R M)", "state_after": "case h.e'_3.h.e'_6.a.h\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\nv' : Basis \u03b9 R M := Basis.mk hli \u22ef\ni j : \u03b9\n\u22a2 Basis.toMatrix e v i j = (toMatrix v' e) (\u2191(LinearEquiv.refl R M)) i j"}, {"tactic": "simp [v']", "annotated_tactic": ["simp [v']", []], "state_before": "case h.e'_3.h.e'_6.a.h\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nhli : LinearIndependent R v\nhspan : span R (Set.range v) = \u22a4\nv' : Basis \u03b9 R M := Basis.mk hli \u22ef\ni j : \u03b9\n\u22a2 Basis.toMatrix e v i j = (toMatrix v' e) (\u2191(LinearEquiv.refl R M)) i j", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\n\u22a2 IsUnit ((Basis.det e) v) \u2192 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit ((Basis.det e) v)\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4"}, {"tactic": "rw [Basis.det_apply, Basis.toMatrix_eq_toMatrix_constr] at h", "annotated_tactic": ["rw [<a>Basis.det_apply</a>, <a>Basis.toMatrix_eq_toMatrix_constr</a>] at h", [{"full_name": "Basis.det_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [525, 9], "def_end_pos": [525, 24]}, {"full_name": "Basis.toMatrix_eq_toMatrix_constr", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Basis.lean", "def_pos": [68, 9], "def_end_pos": [68, 36]}]], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit ((Basis.det e) v)\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4"}, {"tactic": "set v' := Basis.map e (LinearEquiv.ofIsUnitDet h) with v'_def", "annotated_tactic": ["set v' := <a>Basis.map</a> e (<a>LinearEquiv.ofIsUnitDet</a> h) with v'_def", [{"full_name": "Basis.map", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [349, 15], "def_end_pos": [349, 18]}, {"full_name": "LinearEquiv.ofIsUnitDet", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [441, 5], "def_end_pos": [441, 28]}]], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\nv' : Basis \u03b9 R M := Basis.map e (LinearEquiv.ofIsUnitDet h)\nv'_def : v' = Basis.map e (LinearEquiv.ofIsUnitDet h)\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4"}, {"tactic": "have : \u21d1v' = v := by\n  ext i\n  rw [v'_def, Basis.map_apply, LinearEquiv.ofIsUnitDet_apply, e.constr_basis]", "annotated_tactic": ["have : \u21d1v' = v := by\n      ext i\n      rw [v'_def, <a>Basis.map_apply</a>, <a>LinearEquiv.ofIsUnitDet_apply</a>, e.constr_basis]", [{"full_name": "Basis.map_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [354, 9], "def_end_pos": [354, 18]}, {"full_name": "LinearEquiv.ofIsUnitDet_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [440, 3], "def_end_pos": [440, 8]}]], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\nv' : Basis \u03b9 R M := Basis.map e (LinearEquiv.ofIsUnitDet h)\nv'_def : v' = Basis.map e (LinearEquiv.ofIsUnitDet h)\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\nv' : Basis \u03b9 R M := Basis.map e (LinearEquiv.ofIsUnitDet h)\nv'_def : v' = Basis.map e (LinearEquiv.ofIsUnitDet h)\nthis : \u21d1v' = v\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4"}, {"tactic": "rw [\u2190 this]", "annotated_tactic": ["rw [\u2190 this]", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\nv' : Basis \u03b9 R M := Basis.map e (LinearEquiv.ofIsUnitDet h)\nv'_def : v' = Basis.map e (LinearEquiv.ofIsUnitDet h)\nthis : \u21d1v' = v\n\u22a2 LinearIndependent R v \u2227 span R (Set.range v) = \u22a4", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\nv' : Basis \u03b9 R M := Basis.map e (LinearEquiv.ofIsUnitDet h)\nv'_def : v' = Basis.map e (LinearEquiv.ofIsUnitDet h)\nthis : \u21d1v' = v\n\u22a2 LinearIndependent R \u21d1v' \u2227 span R (Set.range \u21d1v') = \u22a4"}, {"tactic": "exact \u27e8v'.linearIndependent, v'.span_eq\u27e9", "annotated_tactic": ["exact \u27e8v'.linearIndependent, v'.span_eq\u27e9", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\nv' : Basis \u03b9 R M := Basis.map e (LinearEquiv.ofIsUnitDet h)\nv'_def : v' = Basis.map e (LinearEquiv.ofIsUnitDet h)\nthis : \u21d1v' = v\n\u22a2 LinearIndependent R \u21d1v' \u2227 span R (Set.range \u21d1v') = \u22a4", "state_after": "no goals"}, {"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\nv' : Basis \u03b9 R M := Basis.map e (LinearEquiv.ofIsUnitDet h)\nv'_def : v' = Basis.map e (LinearEquiv.ofIsUnitDet h)\n\u22a2 \u21d1v' = v", "state_after": "case h\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\nv' : Basis \u03b9 R M := Basis.map e (LinearEquiv.ofIsUnitDet h)\nv'_def : v' = Basis.map e (LinearEquiv.ofIsUnitDet h)\ni : \u03b9\n\u22a2 v' i = v i"}, {"tactic": "rw [v'_def, Basis.map_apply, LinearEquiv.ofIsUnitDet_apply, e.constr_basis]", "annotated_tactic": ["rw [v'_def, <a>Basis.map_apply</a>, <a>LinearEquiv.ofIsUnitDet_apply</a>, e.constr_basis]", [{"full_name": "Basis.map_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [354, 9], "def_end_pos": [354, 18]}, {"full_name": "LinearEquiv.ofIsUnitDet_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Determinant.lean", "def_pos": [440, 3], "def_end_pos": [440, 8]}]], "state_before": "case h\nR : Type u_1\ninst\u271d\u2076 : CommRing R\nM : Type u_2\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\nM' : Type u_3\ninst\u271d\u00b3 : AddCommGroup M'\ninst\u271d\u00b2 : Module R M'\n\u03b9 : Type u_4\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\ne : Basis \u03b9 R M\nv : \u03b9 \u2192 M\nh : IsUnit (det ((toMatrix e e) ((Basis.constr e \u2115) v)))\nv' : Basis \u03b9 R M := Basis.map e (LinearEquiv.ofIsUnitDet h)\nv'_def : v' = Basis.map e (LinearEquiv.ofIsUnitDet h)\ni : \u03b9\n\u22a2 v' i = v i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "Homeomorph.mulLeft_symm", "start": [71, 1], "end": [73, 6], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : ContinuousMul G\na : G\n\u22a2 Homeomorph.symm (Homeomorph.mulLeft a) = Homeomorph.mulLeft a\u207b\u00b9", "state_after": "case H\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : ContinuousMul G\na x\u271d : G\n\u22a2 (Homeomorph.symm (Homeomorph.mulLeft a)) x\u271d = (Homeomorph.mulLeft a\u207b\u00b9) x\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case H\nG : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : ContinuousMul G\na x\u271d : G\n\u22a2 (Homeomorph.symm (Homeomorph.mulLeft a)) x\u271d = (Homeomorph.mulLeft a\u207b\u00b9) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Alternating/Basic.lean", "full_name": "AlternatingMap.curryLeft_smul", "start": [1021, 1], "end": [1023, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "HasCompactSupport.iteratedFDeriv", "start": [1588, 1], "end": [1590, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "one_half_lt_one", "start": [551, 1], "end": [552, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Projection.lean", "full_name": "LinearMap.coe_equivProdOfSurjectiveOfIsCompl", "start": [328, 1], "end": [330, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units/Equiv.lean", "full_name": "MulEquiv.map_isUnit_iff", "start": [254, 1], "end": [257, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "full_name": "AffineIsometry.map_eq_iff", "start": [166, 1], "end": [167, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Field/Basic.lean", "full_name": "NormedField.denseRange_nnnorm", "start": [1014, 1], "end": [1017, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.sublist_append_of_sublist_left", "start": [533, 1], "end": [534, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Hom/Monoid.lean", "full_name": "OrderMonoidHom.toMonoidHom_injective", "start": [308, 1], "end": [309, 49], "traced_tactics": [{"tactic": "convert DFunLike.ext_iff.1 h using 0", "annotated_tactic": ["convert <a>DFunLike.ext_iff</a>.1 h using 0", [{"full_name": "DFunLike.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/FunLike/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 16]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b3\ninst\u271d\u2074 : Preorder \u03b4\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : MulOneClass \u03b2\ninst\u271d\u00b9 : MulOneClass \u03b3\ninst\u271d : MulOneClass \u03b4\nf\u271d g\u271d f g : \u03b1 \u2192*o \u03b2\nh : f.toMonoidHom = g.toMonoidHom\n\u22a2 \u2200 (a : \u03b1), f a = g a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.mapRange.zeroHom_id", "start": [190, 1], "end": [191, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Basic.lean", "full_name": "UniformContinuous.prod_mk", "start": [1603, 1], "end": [1606, 71], "traced_tactics": [{"tactic": "rw [UniformContinuous, uniformity_prod]", "annotated_tactic": ["rw [<a>UniformContinuous</a>, <a>uniformity_prod</a>]", [{"full_name": "UniformContinuous", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [1064, 5], "def_end_pos": [1064, 22]}, {"full_name": "uniformity_prod", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Basic.lean", "def_pos": [1543, 9], "def_end_pos": [1543, 24]}]], "state_before": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\n\u03b4 : Type ud\n\u03b9 : Sort u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf\u2081 : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nh\u2081 : UniformContinuous f\u2081\nh\u2082 : UniformContinuous f\u2082\n\u22a2 UniformContinuous fun a => (f\u2081 a, f\u2082 a)", "state_after": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\n\u03b4 : Type ud\n\u03b9 : Sort u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf\u2081 : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nh\u2081 : UniformContinuous f\u2081\nh\u2082 : UniformContinuous f\u2082\n\u22a2 Tendsto (fun x => ((f\u2081 x.1, f\u2082 x.1), f\u2081 x.2, f\u2082 x.2)) (\ud835\udce4 \u03b1)\n    (comap (fun p => (p.1.1, p.2.1)) (\ud835\udce4 \u03b2) \u2293 comap (fun p => (p.1.2, p.2.2)) (\ud835\udce4 \u03b3))"}, {"tactic": "exact tendsto_inf.2 \u27e8tendsto_comap_iff.2 h\u2081, tendsto_comap_iff.2 h\u2082\u27e9", "annotated_tactic": ["exact <a>tendsto_inf</a>.2 \u27e8<a>tendsto_comap_iff</a>.2 h\u2081, <a>tendsto_comap_iff</a>.2 h\u2082\u27e9", [{"full_name": "Filter.tendsto_inf", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3142, 9], "def_end_pos": [3142, 20]}, {"full_name": "Filter.tendsto_comap_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3111, 9], "def_end_pos": [3111, 26]}, {"full_name": "Filter.tendsto_comap_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3111, 9], "def_end_pos": [3111, 26]}]], "state_before": "\u03b1 : Type ua\n\u03b2 : Type ub\n\u03b3 : Type uc\n\u03b4 : Type ud\n\u03b9 : Sort u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf\u2081 : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nh\u2081 : UniformContinuous f\u2081\nh\u2082 : UniformContinuous f\u2082\n\u22a2 Tendsto (fun x => ((f\u2081 x.1, f\u2082 x.1), f\u2081 x.2, f\u2082 x.2)) (\ud835\udce4 \u03b1)\n    (comap (fun p => (p.1.1, p.2.1)) (\ud835\udce4 \u03b2) \u2293 comap (fun p => (p.1.2, p.2.2)) (\ud835\udce4 \u03b3))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/IntermediateField.lean", "full_name": "IntermediateField.extendScalars_le_iff", "start": [715, 1], "end": [716, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.image_iInter\u2082", "start": [1577, 1], "end": [1578, 84], "traced_tactics": [{"tactic": "simp_rw [image_iInter hf]", "annotated_tactic": ["simp_rw [<a>image_iInter</a> hf]", [{"full_name": "Set.image_iInter", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1568, 9], "def_end_pos": [1568, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2\nhf : Bijective f\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 f '' \u22c2 i, \u22c2 j, s i j = \u22c2 i, \u22c2 j, f '' s i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.prod_mapDomain_index_inj", "start": [612, 1], "end": [614, 84], "traced_tactics": [{"tactic": "rw [\u2190 Function.Embedding.coeFn_mk f hf, \u2190 embDomain_eq_mapDomain, prod_embDomain]", "annotated_tactic": ["rw [\u2190 <a>Function.Embedding.coeFn_mk</a> f hf, \u2190 <a>embDomain_eq_mapDomain</a>, <a>prod_embDomain</a>]", [{"full_name": "Function.Embedding.coeFn_mk", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 17]}, {"full_name": "Finsupp.embDomain_eq_mapDomain", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [603, 9], "def_end_pos": [603, 31]}, {"full_name": "Finsupp.prod_embDomain", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [544, 9], "def_end_pos": [544, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b9 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d : CommMonoid N\nf : \u03b1 \u2192 \u03b2\ns : \u03b1 \u2192\u2080 M\nh : \u03b2 \u2192 M \u2192 N\nhf : Injective f\n\u22a2 prod (mapDomain f s) h = prod s fun a b => h (f a) b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Interval.lean", "full_name": "Nat.card_Iio", "start": [136, 1], "end": [136, 92], "traced_tactics": [{"tactic": "rw [Iio_eq_Ico, card_Ico, bot_eq_zero, tsub_zero]", "annotated_tactic": ["rw [<a>Iio_eq_Ico</a>, <a>card_Ico</a>, <a>bot_eq_zero</a>, <a>tsub_zero</a>]", [{"full_name": "Finset.Iio_eq_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [480, 9], "def_end_pos": [480, 19]}, {"full_name": "Nat.card_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Interval.lean", "def_pos": [103, 9], "def_end_pos": [103, 17]}, {"full_name": "bot_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [210, 3], "def_end_pos": [210, 14]}, {"full_name": "tsub_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [449, 9], "def_end_pos": [449, 18]}]], "state_before": "a b c : \u2115\n\u22a2 (Iio b).card = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "transitive_ge", "start": [937, 1], "end": [938, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Irrational.lean", "full_name": "irrational_sqrt_two", "start": [104, 1], "end": [105, 44], "traced_tactics": [{"tactic": "simpa using Nat.prime_two.irrational_sqrt", "annotated_tactic": ["simpa using Nat.prime_two.irrational_sqrt", []], "state_before": "\u22a2 Irrational (Real.sqrt 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.support_ofFinsupp", "start": [410, 1], "end": [410, 84], "traced_tactics": [{"tactic": "rw [support]", "annotated_tactic": ["rw [<a>support</a>]", [{"full_name": "Polynomial.support", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [405, 5], "def_end_pos": [405, 12]}]], "state_before": "R : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np\u271d q : R[X]\np : R[\u2115]\n\u22a2 support { toFinsupp := p } = p.support", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Subtype.exists_set_subtype", "start": [1445, 1], "end": [1447, 48], "traced_tactics": [{"tactic": "rw [\u2190 exists_subset_range_and_iff, range_coe]", "annotated_tactic": ["rw [\u2190 <a>exists_subset_range_and_iff</a>, <a>range_coe</a>]", [{"full_name": "Set.exists_subset_range_and_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [802, 9], "def_end_pos": [802, 36]}, {"full_name": "Subtype.range_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1369, 9], "def_end_pos": [1369, 18]}]], "state_before": "\u03b1 : Type u_1\nt : Set \u03b1\np : Set \u03b1 \u2192 Prop\n\u22a2 (\u2203 s, p (val '' s)) \u2194 \u2203 s \u2286 t, p s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Comma/StructuredArrow.lean", "full_name": "CategoryTheory.StructuredArrow.w", "start": [89, 1], "end": [90, 25], "traced_tactics": [{"tactic": "have := f.w", "annotated_tactic": ["have := f.w", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nS S' S'' : D\nY Y' Y'' : C\nT T' : C \u2964 D\nA B : StructuredArrow S T\nf : A \u27f6 B\n\u22a2 A.hom \u226b T.map f.right = B.hom", "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nS S' S'' : D\nY Y' Y'' : C\nT T' : C \u2964 D\nA B : StructuredArrow S T\nf : A \u27f6 B\nthis : (Functor.fromPUnit S).map f.left \u226b B.hom = A.hom \u226b T.map f.right\n\u22a2 A.hom \u226b T.map f.right = B.hom"}, {"tactic": "aesop_cat", "annotated_tactic": ["aesop_cat", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nS S' S'' : D\nY Y' Y'' : C\nT T' : C \u2964 D\nA B : StructuredArrow S T\nf : A \u27f6 B\nthis : (Functor.fromPUnit S).map f.left \u226b B.hom = A.hom \u226b T.map f.right\n\u22a2 A.hom \u226b T.map f.right = B.hom", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Index.lean", "full_name": "Subgroup.relindex_le_of_le_right", "start": [402, 1], "end": [404, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Order.lean", "full_name": "Finset.prod_pos", "start": [648, 1], "end": [649, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "PUnit.sdiff_eq", "start": [1335, 1], "end": [1336, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Topology.lean", "full_name": "Convex.subset_interior_image_homothety_of_one_lt", "start": [345, 1], "end": [347, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.exists_or_eq_self_of_eraseP", "start": [1146, 1], "end": [1153, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.liftNC_single", "start": [153, 1], "end": [155, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Image.lean", "full_name": "Antitone.mapsTo_Iic", "start": [82, 1], "end": [83, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.mul_bot", "start": [208, 1], "end": [209, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/MvPowerSeries/Basic.lean", "full_name": "MvPowerSeries.coeff_zero_mul_X", "start": [439, 1], "end": [441, 49], "traced_tactics": [{"tactic": "have : \u00acsingle s 1 \u2264 0 := fun h => by simpa using h s", "annotated_tactic": ["have : \u00ac<a>single</a> s 1 \u2264 0 := fun h => by simpa using h s", [{"full_name": "Finsupp.single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [286, 5], "def_end_pos": [286, 11]}]], "state_before": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Semiring R\n\u03c6 : MvPowerSeries \u03c3 R\ns : \u03c3\n\u22a2 (coeff R 0) (\u03c6 * X s) = 0", "state_after": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Semiring R\n\u03c6 : MvPowerSeries \u03c3 R\ns : \u03c3\nthis : \u00acsingle s 1 \u2264 0\n\u22a2 (coeff R 0) (\u03c6 * X s) = 0"}, {"tactic": "simp only [X, coeff_mul_monomial, if_neg this]", "annotated_tactic": ["simp only [<a>X</a>, <a>coeff_mul_monomial</a>, <a>if_neg</a> this]", [{"full_name": "MvPowerSeries.X", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/MvPowerSeries/Basic.lean", "def_pos": [373, 5], "def_end_pos": [373, 6]}, {"full_name": "MvPowerSeries.coeff_mul_monomial", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/MvPowerSeries/Basic.lean", "def_pos": [228, 9], "def_end_pos": [228, 27]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}]], "state_before": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Semiring R\n\u03c6 : MvPowerSeries \u03c3 R\ns : \u03c3\nthis : \u00acsingle s 1 \u2264 0\n\u22a2 (coeff R 0) (\u03c6 * X s) = 0", "state_after": "no goals"}, {"tactic": "simpa using h s", "annotated_tactic": ["simpa using h s", []], "state_before": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Semiring R\n\u03c6 : MvPowerSeries \u03c3 R\ns : \u03c3\nh : single s 1 \u2264 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupClosed.lean", "full_name": "supClosed_univ", "start": [47, 1], "end": [47, 79], "traced_tactics": [{"tactic": "simp [SupClosed]", "annotated_tactic": ["simp [<a>SupClosed</a>]", [{"full_name": "SupClosed", "def_path": ".lake/packages/mathlib/Mathlib/Order/SupClosed.lean", "def_pos": [42, 5], "def_end_pos": [42, 14]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeSup \u03b2\n\u03b9 : Sort u_4\nS : Set (Set \u03b1)\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b1\na : \u03b1\n\u22a2 SupClosed univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "nonneg_of_mul_nonneg_right", "start": [878, 1], "end": [879, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Separation.lean", "full_name": "TopologicalSpace.IsTopologicalBasis.eq_iff", "start": [245, 1], "end": [247, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/ModEq.lean", "full_name": "Nat.coprime_of_mul_modEq_one", "start": [406, 1], "end": [412, 30], "traced_tactics": [{"tactic": "obtain \u27e8g, hh\u27e9 := Nat.gcd_dvd_right a n", "annotated_tactic": ["obtain \u27e8g, hh\u27e9 := <a>Nat.gcd_dvd_right</a> a n", [{"full_name": "Nat.gcd_dvd_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [61, 9], "def_end_pos": [61, 22]}]], "state_before": "m n\u271d a\u271d b\u271d c d b a n : \u2115\nh : a * b \u2261 1 [MOD n]\n\u22a2 Coprime a n", "state_after": "case intro\nm n\u271d a\u271d b\u271d c d b a n : \u2115\nh : a * b \u2261 1 [MOD n]\ng : \u2115\nhh : n = gcd a n * g\n\u22a2 Coprime a n"}, {"tactic": "rw [Nat.coprime_iff_gcd_eq_one, \u2190 Nat.dvd_one, \u2190 Nat.modEq_zero_iff_dvd]", "annotated_tactic": ["rw [<a>Nat.coprime_iff_gcd_eq_one</a>, \u2190 <a>Nat.dvd_one</a>, \u2190 <a>Nat.modEq_zero_iff_dvd</a>]", [{"full_name": "Nat.coprime_iff_gcd_eq_one", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [220, 9], "def_end_pos": [220, 31]}, {"full_name": "Nat.dvd_one", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [899, 17], "def_end_pos": [899, 24]}, {"full_name": "Nat.modEq_zero_iff_dvd", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/ModEq.lean", "def_pos": [78, 9], "def_end_pos": [78, 27]}]], "state_before": "case intro\nm n\u271d a\u271d b\u271d c d b a n : \u2115\nh : a * b \u2261 1 [MOD n]\ng : \u2115\nhh : n = gcd a n * g\n\u22a2 Coprime a n", "state_after": "case intro\nm n\u271d a\u271d b\u271d c d b a n : \u2115\nh : a * b \u2261 1 [MOD n]\ng : \u2115\nhh : n = gcd a n * g\n\u22a2 1 \u2261 0 [MOD gcd a n]"}, {"tactic": "calc\n  1 \u2261 a * b [MOD a.gcd n] := (hh \u25b8 h).symm.of_mul_right g\n  _ \u2261 0 * b [MOD a.gcd n] := (Nat.modEq_zero_iff_dvd.mpr (Nat.gcd_dvd_left _ _)).mul_right b\n  _ = 0 := by rw [zero_mul]", "annotated_tactic": ["calc\n    1 \u2261 a * b [MOD a.gcd n] := (hh \u25b8 h).symm.of_mul_right g\n    _ \u2261 0 * b [MOD a.gcd n] := (Nat.modEq_zero_iff_dvd.mpr (<a>Nat.gcd_dvd_left</a> _ _)).<a>mul_right</a> b\n    _ = 0 := by rw [<a>zero_mul</a>]", [{"full_name": "Nat.gcd_dvd_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [59, 9], "def_end_pos": [59, 21]}, {"full_name": "Nat.ModEq.mul_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/ModEq.lean", "def_pos": [127, 19], "def_end_pos": [127, 28]}, {"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}]], "state_before": "case intro\nm n\u271d a\u271d b\u271d c d b a n : \u2115\nh : a * b \u2261 1 [MOD n]\ng : \u2115\nhh : n = gcd a n * g\n\u22a2 1 \u2261 0 [MOD gcd a n]", "state_after": "no goals"}, {"tactic": "rw [zero_mul]", "annotated_tactic": ["rw [<a>zero_mul</a>]", [{"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}]], "state_before": "m n\u271d a\u271d b\u271d c d b a n : \u2115\nh : a * b \u2261 1 [MOD n]\ng : \u2115\nhh : n = gcd a n * g\n\u22a2 0 * b = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Divisibility/Units.lean", "full_name": "isRelPrime_comm", "start": [162, 1], "end": [163, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Fintype.coe_finsetEquivSet", "start": [1091, 1], "end": [1091, 96], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Units.lean", "full_name": "Units.smul_isUnit", "start": [48, 1], "end": [50, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/SesquilinearForm.lean", "full_name": "LinearMap.IsAdjointPair.mul", "start": [482, 1], "end": [484, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "monotoneOn_iff_forall_lt", "start": [478, 1], "end": [481, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.factors_eq_none_iff_zero", "start": [1489, 1], "end": [1492, 98], "traced_tactics": [{"tactic": "nontriviality \u03b1", "annotated_tactic": ["nontriviality \u03b1", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na : Associates \u03b1\n\u22a2 factors a = none \u2194 a = 0", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na : Associates \u03b1\na\u271d : Nontrivial \u03b1\n\u22a2 factors a = none \u2194 a = 0"}, {"tactic": "exact\n  \u27e8fun h => by rwa [\u2190 factors_prod a, FactorSet.prod_eq_zero_iff], fun h => h.symm \u25b8 factors_0\u27e9", "annotated_tactic": ["exact\n    \u27e8fun h => by rwa [\u2190 <a>factors_prod</a> a, <a>FactorSet.prod_eq_zero_iff</a>], fun h => h.symm \u25b8 <a>factors_0</a>\u27e9", [{"full_name": "Associates.factors_prod", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1469, 9], "def_end_pos": [1469, 21]}, {"full_name": "Associates.FactorSet.prod_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1290, 9], "def_end_pos": [1290, 35]}, {"full_name": "Associates.factors_0", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1457, 9], "def_end_pos": [1457, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na : Associates \u03b1\na\u271d : Nontrivial \u03b1\n\u22a2 factors a = none \u2194 a = 0", "state_after": "no goals"}, {"tactic": "rwa [\u2190 factors_prod a, FactorSet.prod_eq_zero_iff]", "annotated_tactic": ["rwa [\u2190 <a>factors_prod</a> a, <a>FactorSet.prod_eq_zero_iff</a>]", [{"full_name": "Associates.factors_prod", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1469, 9], "def_end_pos": [1469, 21]}, {"full_name": "Associates.FactorSet.prod_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1290, 9], "def_end_pos": [1290, 35]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na : Associates \u03b1\na\u271d : Nontrivial \u03b1\nh : factors a = none\n\u22a2 a = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.tendsto_inv_iff", "start": [543, 11], "end": [545, 70], "traced_tactics": [{"tactic": "simpa only [inv_inv] using Tendsto.inv h", "annotated_tactic": ["simpa only [<a>inv_inv</a>] using <a>Tendsto.inv</a> h", [{"full_name": "inv_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 16]}, {"full_name": "Filter.Tendsto.inv", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [229, 9], "def_end_pos": [229, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na\u271d b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nf : Filter \u03b1\nm : \u03b1 \u2192 \u211d\u22650\u221e\na : \u211d\u22650\u221e\nh : Tendsto (fun x => (m x)\u207b\u00b9) f (\ud835\udcdd a\u207b\u00b9)\n\u22a2 Tendsto m f (\ud835\udcdd a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Field/IsField.lean", "full_name": "Field.toIsField", "start": [47, 1], "end": [48, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/Basic.lean", "full_name": "ConnectedComponents.surjective_coe", "start": [1283, 1], "end": [1284, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Bounds.lean", "full_name": "BddBelow.range_mul", "start": [154, 1], "end": [157, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.hasPushout_assoc", "start": [2566, 1], "end": [2567, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Restrict.lean", "full_name": "indicator_ae_eq_zero_of_restrict_ae_eq_zero", "start": [1079, 1], "end": [1085, 19], "traced_tactics": [{"tactic": "rw [Filter.EventuallyEq, ae_restrict_iff' hs] at hf", "annotated_tactic": ["rw [<a>Filter.EventuallyEq</a>, <a>ae_restrict_iff'</a> hs] at hf", [{"full_name": "Filter.EventuallyEq", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1462, 5], "def_end_pos": [1462, 17]}, {"full_name": "MeasureTheory.ae_restrict_iff'", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Restrict.lean", "def_pos": [638, 9], "def_end_pos": [638, 25]}]], "state_before": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\nhs : MeasurableSet s\nhf : f =\u1da0[ae (Measure.restrict \u03bc s)] 0\n\u22a2 indicator s f =\u1da0[ae \u03bc] 0", "state_after": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\nhs : MeasurableSet s\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 f x = 0 x\n\u22a2 indicator s f =\u1da0[ae \u03bc] 0"}, {"tactic": "filter_upwards [hf] with x hx", "annotated_tactic": ["filter_upwards [hf] with x hx", []], "state_before": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\nhs : MeasurableSet s\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 f x = 0 x\n\u22a2 indicator s f =\u1da0[ae \u03bc] 0", "state_after": "case h\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\nhs : MeasurableSet s\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 f x = 0 x\nx : \u03b1\nhx : x \u2208 s \u2192 f x = 0 x\n\u22a2 indicator s f x = 0 x"}, {"tactic": "by_cases hxs : x \u2208 s", "annotated_tactic": ["by_cases hxs : x \u2208 s", []], "state_before": "case h\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\nhs : MeasurableSet s\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 f x = 0 x\nx : \u03b1\nhx : x \u2208 s \u2192 f x = 0 x\n\u22a2 indicator s f x = 0 x", "state_after": "case pos\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\nhs : MeasurableSet s\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 f x = 0 x\nx : \u03b1\nhx : x \u2208 s \u2192 f x = 0 x\nhxs : x \u2208 s\n\u22a2 indicator s f x = 0 x\n\ncase neg\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\nhs : MeasurableSet s\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 f x = 0 x\nx : \u03b1\nhx : x \u2208 s \u2192 f x = 0 x\nhxs : x \u2209 s\n\u22a2 indicator s f x = 0 x"}, {"tactic": "simp only [hxs, hx hxs, Set.indicator_of_mem]", "annotated_tactic": ["simp only [hxs, hx hxs, <a>Set.indicator_of_mem</a>]", [{"full_name": "Set.indicator_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Indicator.lean", "def_pos": [66, 3], "def_end_pos": [66, 14]}]], "state_before": "case pos\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\nhs : MeasurableSet s\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 f x = 0 x\nx : \u03b1\nhx : x \u2208 s \u2192 f x = 0 x\nhxs : x \u2208 s\n\u22a2 indicator s f x = 0 x", "state_after": "no goals"}, {"tactic": "simp [hx, hxs]", "annotated_tactic": ["simp [hx, hxs]", []], "state_before": "case neg\nR : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b4 : Type u_4\n\u03b3 : Type u_5\n\u03b9 : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Zero \u03b2\nhs : MeasurableSet s\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 f x = 0 x\nx : \u03b1\nhx : x \u2208 s \u2192 f x = 0 x\nhxs : x \u2209 s\n\u22a2 indicator s f x = 0 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.mem_compl_iff", "start": [875, 1], "end": [876, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearEquiv.unitsEquivAut_symm_apply", "start": [2498, 1], "end": [2499, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Max.lean", "full_name": "NoMaxOrder.not_acc", "start": [175, 1], "end": [176, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.one_lt_card_iff_nontrivial", "start": [661, 1], "end": [663, 78], "traced_tactics": [{"tactic": "rw [\u2190 not_iff_not, not_lt, Finset.Nontrivial, \u2190 Set.nontrivial_coe_sort,\n    not_nontrivial_iff_subsingleton, card_le_one_iff_subsingleton_coe]", "annotated_tactic": ["rw [\u2190 <a>not_iff_not</a>, <a>not_lt</a>, <a>Finset.Nontrivial</a>, \u2190 <a>Set.nontrivial_coe_sort</a>,\n      <a>not_nontrivial_iff_subsingleton</a>, <a>card_le_one_iff_subsingleton_coe</a>]", [{"full_name": "not_iff_not", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [449, 9], "def_end_pos": [449, 20]}, {"full_name": "not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 15]}, {"full_name": "Finset.Nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [816, 15], "def_end_pos": [816, 25]}, {"full_name": "Set.nontrivial_coe_sort", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2583, 9], "def_end_pos": [2583, 28]}, {"full_name": "not_nontrivial_iff_subsingleton", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [83, 9], "def_end_pos": [83, 40]}, {"full_name": "Finset.card_le_one_iff_subsingleton_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [626, 9], "def_end_pos": [626, 41]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 1 < s.card \u2194 Finset.Nontrivial s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 Subsingleton { x // x \u2208 s } \u2194 Subsingleton \u2191\u2191s"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 Subsingleton { x // x \u2208 s } \u2194 Subsingleton \u2191\u2191s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/EReal.lean", "full_name": "EReal.nhds_top_basis", "start": [135, 8], "end": [138, 44], "traced_tactics": [{"tactic": "refine nhds_top_basis.to_hasBasis (fun x hx => ?_) fun _ _ \u21a6 \u27e8_, coe_lt_top _, Subset.rfl\u27e9", "annotated_tactic": ["refine nhds_top_basis.to_hasBasis (fun x hx => ?_) fun _ _ \u21a6 \u27e8_, <a>coe_lt_top</a> _, <a>Subset.rfl</a>\u27e9", [{"full_name": "EReal.coe_lt_top", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/EReal.lean", "def_pos": [302, 9], "def_end_pos": [302, 19]}, {"full_name": "Set.Subset.rfl", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [338, 9], "def_end_pos": [338, 19]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 HasBasis (\ud835\udcdd \u22a4) (fun x => True) fun x => Ioi \u2191x", "state_after": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : EReal\nhx : x < \u22a4\n\u22a2 \u2203 i', True \u2227 Ioi \u2191i' \u2286 Ioi x"}, {"tactic": "rcases exists_rat_btwn_of_lt hx with \u27e8y, hxy, -\u27e9", "annotated_tactic": ["rcases <a>exists_rat_btwn_of_lt</a> hx with \u27e8y, hxy, -\u27e9", [{"full_name": "EReal.exists_rat_btwn_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/EReal.lean", "def_pos": [736, 9], "def_end_pos": [736, 30]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : EReal\nhx : x < \u22a4\n\u22a2 \u2203 i', True \u2227 Ioi \u2191i' \u2286 Ioi x", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : EReal\nhx : x < \u22a4\ny : \u211a\nhxy : x < \u2191\u2191y\n\u22a2 \u2203 i', True \u2227 Ioi \u2191i' \u2286 Ioi x"}, {"tactic": "exact \u27e8_, trivial, Ioi_subset_Ioi hxy.le\u27e9", "annotated_tactic": ["exact \u27e8_, <a>trivial</a>, <a>Ioi_subset_Ioi</a> hxy.le\u27e9", [{"full_name": "trivial", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [643, 31], "def_end_pos": [643, 38]}, {"full_name": "Set.Ioi_subset_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [598, 9], "def_end_pos": [598, 23]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : EReal\nhx : x < \u22a4\ny : \u211a\nhxy : x < \u2191\u2191y\n\u22a2 \u2203 i', True \u2227 Ioi \u2191i' \u2286 Ioi x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.toLinAlgEquiv_toMatrixAlgEquiv", "start": [767, 1], "end": [769, 62], "traced_tactics": [{"tactic": "rw [\u2190 Matrix.toLinAlgEquiv_symm, AlgEquiv.apply_symm_apply]", "annotated_tactic": ["rw [\u2190 <a>Matrix.toLinAlgEquiv_symm</a>, <a>AlgEquiv.apply_symm_apply</a>]", [{"full_name": "Matrix.toLinAlgEquiv_symm", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "def_pos": [761, 9], "def_end_pos": [761, 34]}, {"full_name": "AlgEquiv.apply_symm_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Equiv.lean", "def_pos": [397, 9], "def_end_pos": [397, 25]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM\u2083 : Type u_7\ninst\u271d\u00b9 : AddCommMonoid M\u2083\ninst\u271d : Module R M\u2083\nv\u2083 : Basis l R M\u2083\nf : M\u2081 \u2192\u2097[R] M\u2081\n\u22a2 (toLinAlgEquiv v\u2081) ((toMatrixAlgEquiv v\u2081) f) = f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "InfTopHom.ext", "start": [910, 1], "end": [911, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "DifferentiableAt.smul", "start": [279, 1], "end": [281, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "AddLECancellable.tsub_lt_self", "start": [451, 11], "end": [454, 91], "traced_tactics": [{"tactic": "refine' tsub_le_self.lt_of_ne fun h => _", "annotated_tactic": ["refine' tsub_le_self.lt_of_ne fun h => _", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nha : AddLECancellable a\nh\u2081 : 0 < a\nh\u2082 : 0 < b\n\u22a2 a - b < a", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nha : AddLECancellable a\nh\u2081 : 0 < a\nh\u2082 : 0 < b\nh : a - b = a\n\u22a2 False"}, {"tactic": "rw [\u2190 h, tsub_pos_iff_lt] at h\u2081", "annotated_tactic": ["rw [\u2190 h, <a>tsub_pos_iff_lt</a>] at h\u2081", [{"full_name": "tsub_pos_iff_lt", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [428, 9], "def_end_pos": [428, 24]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nha : AddLECancellable a\nh\u2081 : 0 < a\nh\u2082 : 0 < b\nh : a - b = a\n\u22a2 False", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nha : AddLECancellable a\nh\u2081 : b < a\nh\u2082 : 0 < b\nh : a - b = a\n\u22a2 False"}, {"tactic": "exact h\u2082.not_le (ha.add_le_iff_nonpos_left.1 <| add_le_of_le_tsub_left_of_le h\u2081.le h.ge)", "annotated_tactic": ["exact h\u2082.not_le (ha.add_le_iff_nonpos_left.1 <| <a>add_le_of_le_tsub_left_of_le</a> h\u2081.le h.ge)", [{"full_name": "add_le_of_le_tsub_left_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [39, 9], "def_end_pos": [39, 37]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nha : AddLECancellable a\nh\u2081 : b < a\nh\u2082 : 0 < b\nh : a - b = a\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.C_mul_X_eq_monomial", "start": [344, 1], "end": [345, 42], "traced_tactics": [{"tactic": "rw [\u2190 C_mul_X_pow_eq_monomial, pow_one]", "annotated_tactic": ["rw [\u2190 <a>C_mul_X_pow_eq_monomial</a>, <a>pow_one</a>]", [{"full_name": "MvPolynomial.C_mul_X_pow_eq_monomial", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [339, 9], "def_end_pos": [339, 32]}, {"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na\u271d a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\ns : \u03c3\na : R\n\u22a2 C a * X s = (monomial (Finsupp.single s 1)) a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "symmDiff_right_comm", "start": [485, 1], "end": [485, 98], "traced_tactics": [{"tactic": "simp_rw [symmDiff_assoc, symmDiff_comm]", "annotated_tactic": ["simp_rw [<a>symmDiff_assoc</a>, <a>symmDiff_comm</a>]", [{"full_name": "symmDiff_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [473, 9], "def_end_pos": [473, 23]}, {"full_name": "symmDiff_comm", "def_path": ".lake/packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [113, 9], "def_end_pos": [113, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\n\u22a2 a \u2206 b \u2206 c = a \u2206 c \u2206 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Submodule.coe_toSubalgebra", "start": [530, 1], "end": [531, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Rename.lean", "full_name": "MvPolynomial.constantCoeff_rename", "start": [334, 1], "end": [342, 79], "traced_tactics": [{"tactic": "apply \u03c6.induction_on", "annotated_tactic": ["apply \u03c6.induction_on", []], "state_before": "\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 constantCoeff ((rename f) \u03c6) = constantCoeff \u03c6", "state_after": "case h_C\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 \u2200 (a : R), constantCoeff ((rename f) (C a)) = constantCoeff (C a)\n\ncase h_add\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 \u2200 (p q : MvPolynomial \u03c3 R),\n    constantCoeff ((rename f) p) = constantCoeff p \u2192\n      constantCoeff ((rename f) q) = constantCoeff q \u2192 constantCoeff ((rename f) (p + q)) = constantCoeff (p + q)\n\ncase h_X\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 \u2200 (p : MvPolynomial \u03c3 R) (n : \u03c3),\n    constantCoeff ((rename f) p) = constantCoeff p \u2192 constantCoeff ((rename f) (p * X n)) = constantCoeff (p * X n)"}, {"tactic": "intro a", "annotated_tactic": ["intro a", []], "state_before": "case h_C\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 \u2200 (a : R), constantCoeff ((rename f) (C a)) = constantCoeff (C a)", "state_after": "case h_C\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\na : R\n\u22a2 constantCoeff ((rename f) (C a)) = constantCoeff (C a)"}, {"tactic": "simp only [constantCoeff_C, rename_C]", "annotated_tactic": ["simp only [<a>constantCoeff_C</a>, <a>rename_C</a>]", [{"full_name": "MvPolynomial.constantCoeff_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [897, 9], "def_end_pos": [897, 24]}, {"full_name": "MvPolynomial.rename_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Rename.lean", "def_pos": [61, 9], "def_end_pos": [61, 17]}]], "state_before": "case h_C\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\na : R\n\u22a2 constantCoeff ((rename f) (C a)) = constantCoeff (C a)", "state_after": "no goals"}, {"tactic": "intro p q hp hq", "annotated_tactic": ["intro p q hp hq", []], "state_before": "case h_add\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 \u2200 (p q : MvPolynomial \u03c3 R),\n    constantCoeff ((rename f) p) = constantCoeff p \u2192\n      constantCoeff ((rename f) q) = constantCoeff q \u2192 constantCoeff ((rename f) (p + q)) = constantCoeff (p + q)", "state_after": "case h_add\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 p q : MvPolynomial \u03c3 R\nhp : constantCoeff ((rename f) p) = constantCoeff p\nhq : constantCoeff ((rename f) q) = constantCoeff q\n\u22a2 constantCoeff ((rename f) (p + q)) = constantCoeff (p + q)"}, {"tactic": "simp only [hp, hq, RingHom.map_add, AlgHom.map_add]", "annotated_tactic": ["simp only [hp, hq, <a>RingHom.map_add</a>, <a>AlgHom.map_add</a>]", [{"full_name": "RingHom.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [559, 19], "def_end_pos": [559, 26]}, {"full_name": "AlgHom.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [240, 19], "def_end_pos": [240, 26]}]], "state_before": "case h_add\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 p q : MvPolynomial \u03c3 R\nhp : constantCoeff ((rename f) p) = constantCoeff p\nhq : constantCoeff ((rename f) q) = constantCoeff q\n\u22a2 constantCoeff ((rename f) (p + q)) = constantCoeff (p + q)", "state_after": "no goals"}, {"tactic": "intro p n hp", "annotated_tactic": ["intro p n hp", []], "state_before": "case h_X\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 \u2200 (p : MvPolynomial \u03c3 R) (n : \u03c3),\n    constantCoeff ((rename f) p) = constantCoeff p \u2192 constantCoeff ((rename f) (p * X n)) = constantCoeff (p * X n)", "state_after": "case h_X\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 p : MvPolynomial \u03c3 R\nn : \u03c3\nhp : constantCoeff ((rename f) p) = constantCoeff p\n\u22a2 constantCoeff ((rename f) (p * X n)) = constantCoeff (p * X n)"}, {"tactic": "simp only [hp, rename_X, constantCoeff_X, RingHom.map_mul, AlgHom.map_mul]", "annotated_tactic": ["simp only [hp, <a>rename_X</a>, <a>constantCoeff_X</a>, <a>RingHom.map_mul</a>, <a>AlgHom.map_mul</a>]", [{"full_name": "MvPolynomial.rename_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Rename.lean", "def_pos": [67, 9], "def_end_pos": [67, 17]}, {"full_name": "MvPolynomial.constantCoeff_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [905, 9], "def_end_pos": [905, 24]}, {"full_name": "RingHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "AlgHom.map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [248, 19], "def_end_pos": [248, 26]}]], "state_before": "case h_X\n\u03c3 : Type u_1\n\u03c4\u271d : Type u_2\n\u03b1 : Type u_3\nR : Type u_4\nS : Type u_5\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\n\u03c4 : Type u_6\nf : \u03c3 \u2192 \u03c4\n\u03c6 p : MvPolynomial \u03c3 R\nn : \u03c3\nhp : constantCoeff ((rename f) p) = constantCoeff p\n\u22a2 constantCoeff ((rename f) (p * X n)) = constantCoeff (p * X n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.reverse_surjective", "start": [566, 1], "end": [567, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Cast/Lemmas.lean", "full_name": "Int.cast_commute", "start": [92, 1], "end": [96, 32], "traced_tactics": [{"tactic": "simpa using n.cast_commute x", "annotated_tactic": ["simpa using n.cast_commute x", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : NonAssocRing \u03b1\na b : \u03b1\nn\u271d : \u2124\nn : \u2115\nx : \u03b1\n\u22a2 Commute (\u2191\u2191n) x", "state_after": "no goals"}, {"tactic": "simpa only [cast_negSucc, Commute.neg_left_iff, Commute.neg_right_iff] using\n  (n + 1).cast_commute (-x)", "annotated_tactic": ["simpa only [<a>cast_negSucc</a>, <a>Commute.neg_left_iff</a>, <a>Commute.neg_right_iff</a>] using\n      (n + 1).<a>cast_commute</a> (-x)", [{"full_name": "Int.cast_negSucc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [53, 9], "def_end_pos": [53, 21]}, {"full_name": "Commute.neg_left_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Commute.lean", "def_pos": [106, 9], "def_end_pos": [106, 21]}, {"full_name": "Commute.neg_right_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Commute.lean", "def_pos": [97, 9], "def_end_pos": [97, 22]}, {"full_name": "Nat.cast_commute", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Commute.lean", "def_pos": [24, 9], "def_end_pos": [24, 21]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : NonAssocRing \u03b1\na b : \u03b1\nn\u271d : \u2124\nn : \u2115\nx : \u03b1\n\u22a2 Commute (\u2191-[n+1]) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/OrderHom.lean", "full_name": "Fin.predAbove_right_zero", "start": [426, 1], "end": [429, 65], "traced_tactics": [{"tactic": "cases n", "annotated_tactic": ["cases n", []], "state_before": "n : \u2115\ninst\u271d : NeZero n\ni : Fin n\n\u22a2 predAbove i 0 = 0", "state_after": "case zero\ninst\u271d : NeZero zero\ni : Fin zero\n\u22a2 predAbove i 0 = 0\n\ncase succ\nn\u271d : \u2115\ninst\u271d : NeZero (Nat.succ n\u271d)\ni : Fin (Nat.succ n\u271d)\n\u22a2 predAbove i 0 = 0"}, {"tactic": "exact i.elim0", "annotated_tactic": ["exact i.elim0", []], "state_before": "case zero\ninst\u271d : NeZero zero\ni : Fin zero\n\u22a2 predAbove i 0 = 0", "state_after": "no goals"}, {"tactic": "rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero]", "annotated_tactic": ["rw [<a>predAbove_of_le_castSucc</a> _ _ (<a>zero_le</a> _), <a>castPred_zero</a>]", [{"full_name": "Fin.predAbove_of_le_castSucc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/OrderHom.lean", "def_pos": [358, 9], "def_end_pos": [358, 33]}, {"full_name": "Fin.zero_le", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean", "def_pos": [117, 17], "def_end_pos": [117, 24]}, {"full_name": "Fin.castPred_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [1326, 9], "def_end_pos": [1326, 22]}]], "state_before": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (Nat.succ n\u271d)\ni : Fin (Nat.succ n\u271d)\n\u22a2 predAbove i 0 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "full_name": "Finset.Nonempty.csSup_mem", "start": [33, 1], "end": [35, 21], "traced_tactics": [{"tactic": "rw [h.csSup_eq_max']", "annotated_tactic": ["rw [h.csSup_eq_max']", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns\u271d t : Set \u03b1\na b : \u03b1\ns : Finset \u03b1\nh : s.Nonempty\n\u22a2 sSup \u2191s \u2208 s", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns\u271d t : Set \u03b1\na b : \u03b1\ns : Finset \u03b1\nh : s.Nonempty\n\u22a2 max' s h \u2208 s"}, {"tactic": "exact s.max'_mem _", "annotated_tactic": ["exact s.max'_mem _", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : ConditionallyCompleteLinearOrder \u03b1\ns\u271d t : Set \u03b1\na b : \u03b1\ns : Finset \u03b1\nh : s.Nonempty\n\u22a2 max' s h \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Pow.lean", "full_name": "Nat.pow_left_injective", "start": [118, 1], "end": [119, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.IsCycleOn.subtypePerm", "start": [864, 11], "end": [871, 67], "traced_tactics": [{"tactic": "obtain hs | hs := s.subsingleton_or_nontrivial", "annotated_tactic": ["obtain hs | hs := s.subsingleton_or_nontrivial", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\n\u22a2 IsCycleOn (subtypePerm f \u22ef) _root_.Set.univ", "state_after": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Subsingleton s\n\u22a2 IsCycleOn (subtypePerm f \u22ef) _root_.Set.univ\n\ncase inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Nontrivial s\n\u22a2 IsCycleOn (subtypePerm f \u22ef) _root_.Set.univ"}, {"tactic": "convert (hf.isCycle_subtypePerm hs).isCycleOn", "annotated_tactic": ["convert (hf.isCycle_subtypePerm hs).<a>isCycleOn</a>", [{"full_name": "Equiv.Perm.IsCycle.isCycleOn", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "def_pos": [832, 19], "def_end_pos": [832, 36]}]], "state_before": "case inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Nontrivial s\n\u22a2 IsCycleOn (subtypePerm f \u22ef) _root_.Set.univ", "state_after": "case h.e'_3\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Nontrivial s\n\u22a2 _root_.Set.univ = {x | (subtypePerm f \u22ef) x \u2260 x}"}, {"tactic": "rw [eq_comm, Set.eq_univ_iff_forall]", "annotated_tactic": ["rw [<a>eq_comm</a>, <a>Set.eq_univ_iff_forall</a>]", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "Set.eq_univ_iff_forall", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [671, 9], "def_end_pos": [671, 27]}]], "state_before": "case h.e'_3\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Nontrivial s\n\u22a2 _root_.Set.univ = {x | (subtypePerm f \u22ef) x \u2260 x}", "state_after": "case h.e'_3\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Nontrivial s\n\u22a2 \u2200 (x : { x // x \u2208 s }), x \u2208 {x | (subtypePerm f \u22ef) x \u2260 x}"}, {"tactic": "exact fun x => ne_of_apply_ne ((\u2191) : s \u2192 \u03b1) (hf.apply_ne hs x.2)", "annotated_tactic": ["exact fun x => <a>ne_of_apply_ne</a> ((\u2191) : s \u2192 \u03b1) (hf.apply_ne hs x.2)", [{"full_name": "ne_of_apply_ne", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [62, 9], "def_end_pos": [62, 23]}]], "state_before": "case h.e'_3\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Nontrivial s\n\u22a2 \u2200 (x : { x // x \u2208 s }), x \u2208 {x | (subtypePerm f \u22ef) x \u2260 x}", "state_after": "no goals"}, {"tactic": "haveI := hs.coe_sort", "annotated_tactic": ["haveI := hs.coe_sort", []], "state_before": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Subsingleton s\n\u22a2 IsCycleOn (subtypePerm f \u22ef) _root_.Set.univ", "state_after": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Subsingleton s\nthis : Subsingleton \u2191s\n\u22a2 IsCycleOn (subtypePerm f \u22ef) _root_.Set.univ"}, {"tactic": "exact isCycleOn_of_subsingleton _ _", "annotated_tactic": ["exact <a>isCycleOn_of_subsingleton</a> _ _", [{"full_name": "Equiv.Perm.isCycleOn_of_subsingleton", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "def_pos": [795, 9], "def_end_pos": [795, 34]}]], "state_before": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x y : \u03b1\nhf : IsCycleOn f s\nhs : Set.Subsingleton s\nthis : Subsingleton \u2191s\n\u22a2 IsCycleOn (subtypePerm f \u22ef) _root_.Set.univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "full_name": "Ordinal.card_eq_nat", "start": [1620, 1], "end": [1621, 56], "traced_tactics": [{"tactic": "simp only [le_antisymm_iff, card_le_nat, nat_le_card]", "annotated_tactic": ["simp only [<a>le_antisymm_iff</a>, <a>card_le_nat</a>, <a>nat_le_card</a>]", [{"full_name": "le_antisymm_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [186, 9], "def_end_pos": [186, 24]}, {"full_name": "Ordinal.card_le_nat", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1605, 9], "def_end_pos": [1605, 20]}, {"full_name": "Ordinal.nat_le_card", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Basic.lean", "def_pos": [1559, 9], "def_end_pos": [1559, 20]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\no : Ordinal.{u_3}\nn : \u2115\n\u22a2 card o = \u2191n \u2194 o = \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Pointwise.lean", "full_name": "thickening_thickening", "start": [279, 1], "end": [286, 33], "traced_tactics": [{"tactic": "simp_rw [mem_thickening_iff]", "annotated_tactic": ["simp_rw [<a>mem_thickening_iff</a>]", [{"full_name": "Metric.mem_thickening_iff", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Thickening.lean", "def_pos": [134, 9], "def_end_pos": [134, 27]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y z : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\ns : Set E\nx : E\n\u22a2 x \u2208 thickening (\u03b5 + \u03b4) s \u2192 x \u2208 thickening \u03b5 (thickening \u03b4 s)", "state_after": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y z : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\ns : Set E\nx : E\n\u22a2 (\u2203 z \u2208 s, dist x z < \u03b5 + \u03b4) \u2192 \u2203 z, (\u2203 z_1 \u2208 s, dist z z_1 < \u03b4) \u2227 dist x z < \u03b5"}, {"tactic": "rintro \u27e8z, hz, hxz\u27e9", "annotated_tactic": ["rintro \u27e8z, hz, hxz\u27e9", []], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y z : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\ns : Set E\nx : E\n\u22a2 (\u2203 z \u2208 s, dist x z < \u03b5 + \u03b4) \u2192 \u2203 z, (\u2203 z_1 \u2208 s, dist z z_1 < \u03b4) \u2227 dist x z < \u03b5", "state_after": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y z\u271d : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\ns : Set E\nx z : E\nhz : z \u2208 s\nhxz : dist x z < \u03b5 + \u03b4\n\u22a2 \u2203 z, (\u2203 z_1 \u2208 s, dist z z_1 < \u03b4) \u2227 dist x z < \u03b5"}, {"tactic": "rw [add_comm] at hxz", "annotated_tactic": ["rw [<a>add_comm</a>] at hxz", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y z\u271d : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\ns : Set E\nx z : E\nhz : z \u2208 s\nhxz : dist x z < \u03b5 + \u03b4\n\u22a2 \u2203 z, (\u2203 z_1 \u2208 s, dist z z_1 < \u03b4) \u2227 dist x z < \u03b5", "state_after": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y z\u271d : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\ns : Set E\nx z : E\nhz : z \u2208 s\nhxz : dist x z < \u03b4 + \u03b5\n\u22a2 \u2203 z, (\u2203 z_1 \u2208 s, dist z z_1 < \u03b4) \u2227 dist x z < \u03b5"}, {"tactic": "obtain \u27e8y, hxy, hyz\u27e9 := exists_dist_lt_lt h\u03b5 h\u03b4 hxz", "annotated_tactic": ["obtain \u27e8y, hxy, hyz\u27e9 := <a>exists_dist_lt_lt</a> h\u03b5 h\u03b4 hxz", [{"full_name": "exists_dist_lt_lt", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Pointwise.lean", "def_pos": [205, 9], "def_end_pos": [205, 26]}]], "state_before": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y z\u271d : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\ns : Set E\nx z : E\nhz : z \u2208 s\nhxz : dist x z < \u03b4 + \u03b5\n\u22a2 \u2203 z, (\u2203 z_1 \u2208 s, dist z z_1 < \u03b4) \u2227 dist x z < \u03b5", "state_after": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y\u271d z\u271d : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\ns : Set E\nx z : E\nhz : z \u2208 s\nhxz : dist x z < \u03b4 + \u03b5\ny : E\nhxy : dist x y < \u03b5\nhyz : dist y z < \u03b4\n\u22a2 \u2203 z, (\u2203 z_1 \u2208 s, dist z z_1 < \u03b4) \u2227 dist x z < \u03b5"}, {"tactic": "exact \u27e8y, \u27e8_, hz, hyz\u27e9, hxy\u27e9", "annotated_tactic": ["exact \u27e8y, \u27e8_, hz, hyz\u27e9, hxy\u27e9", []], "state_before": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nx\u271d y\u271d z\u271d : E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\ns : Set E\nx z : E\nhz : z \u2208 s\nhxz : dist x z < \u03b4 + \u03b5\ny : E\nhxy : dist x y < \u03b5\nhyz : dist y z < \u03b4\n\u22a2 \u2203 z, (\u2203 z_1 \u2208 s, dist z z_1 < \u03b4) \u2227 dist x z < \u03b5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "Ideal.injective_lift_iff", "start": [163, 1], "end": [168, 20], "traced_tactics": [{"tactic": "rw [injective_iff_ker_eq_bot, ker_quotient_lift, map_eq_bot_iff_le_ker, mk_ker]", "annotated_tactic": ["rw [<a>injective_iff_ker_eq_bot</a>, <a>ker_quotient_lift</a>, <a>map_eq_bot_iff_le_ker</a>, <a>mk_ker</a>]", [{"full_name": "RingHom.injective_iff_ker_eq_bot", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [2169, 9], "def_end_pos": [2169, 33]}, {"full_name": "Ideal.ker_quotient_lift", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [145, 9], "def_end_pos": [145, 26]}, {"full_name": "Ideal.map_eq_bot_iff_le_ker", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [2239, 9], "def_end_pos": [2239, 30]}, {"full_name": "Ideal.mk_ker", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [134, 9], "def_end_pos": [134, 15]}]], "state_before": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI : Ideal R\nf : R \u2192+* S\nH : \u2200 a \u2208 I, f a = 0\n\u22a2 Injective \u21d1(Quotient.lift I f H) \u2194 ker f = I", "state_after": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI : Ideal R\nf : R \u2192+* S\nH : \u2200 a \u2208 I, f a = 0\n\u22a2 ker f \u2264 I \u2194 ker f = I"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI : Ideal R\nf : R \u2192+* S\nH : \u2200 a \u2208 I, f a = 0\n\u22a2 ker f \u2264 I \u2194 ker f = I", "state_after": "case mp\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI : Ideal R\nf : R \u2192+* S\nH : \u2200 a \u2208 I, f a = 0\n\u22a2 ker f \u2264 I \u2192 ker f = I\n\ncase mpr\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI : Ideal R\nf : R \u2192+* S\nH : \u2200 a \u2208 I, f a = 0\n\u22a2 ker f = I \u2192 ker f \u2264 I"}, {"tactic": "exact fun h \u21a6 le_antisymm h H", "annotated_tactic": ["exact fun h \u21a6 <a>le_antisymm</a> h H", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "case mp\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI : Ideal R\nf : R \u2192+* S\nH : \u2200 a \u2208 I, f a = 0\n\u22a2 ker f \u2264 I \u2192 ker f = I", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "case mpr\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI : Ideal R\nf : R \u2192+* S\nH : \u2200 a \u2208 I, f a = 0\n\u22a2 ker f = I \u2192 ker f \u2264 I", "state_after": "case mpr\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nf : R \u2192+* S\nH : \u2200 a \u2208 ker f, f a = 0\n\u22a2 ker f \u2264 ker f"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mpr\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nf : R \u2192+* S\nH : \u2200 a \u2208 ker f, f a = 0\n\u22a2 ker f \u2264 ker f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Tactic/IntervalCases.lean", "full_name": "Mathlib.Tactic.IntervalCases.of_le_left", "start": [132, 1], "end": [132, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "full_name": "hasSum_subtype_iff_of_support_subset", "start": [98, 1], "end": [100, 78], "traced_tactics": [{"tactic": "simpa using support_subset_iff'.1 hf", "annotated_tactic": ["simpa using <a>support_subset_iff'</a>.1 hf", [{"full_name": "Function.support_subset_iff'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Function/Support.lean", "def_pos": [70, 3], "def_end_pos": [70, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na b : \u03b1\ns\u271d : Finset \u03b2\ns : Set \u03b2\nhf : support f \u2286 s\n\u22a2 \u2200 x \u2209 Set.range fun a => \u2191a, f x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Adjoin.lean", "full_name": "IntermediateField.algHomAdjoinIntegralEquiv_symm_apply_gen", "start": [1254, 1], "end": [1258, 73], "traced_tactics": [{"tactic": "rw [adjoin.powerBasis_gen, minpoly_gen]", "annotated_tactic": ["rw [<a>adjoin.powerBasis_gen</a>, <a>minpoly_gen</a>]", [{"full_name": "IntermediateField.adjoin.powerBasis_gen", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [1126, 3], "def_end_pos": [1126, 8]}, {"full_name": "IntermediateField.minpoly_gen", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [1066, 9], "def_end_pos": [1066, 20]}]], "state_before": "F : Type u_1\ninst\u271d\u2074 : Field F\nE : Type u_2\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra F K\nh : IsIntegral F \u03b1\nx : { x // x \u2208 aroots (minpoly F \u03b1) K }\n\u22a2 (aeval \u2191x) (minpoly F (adjoin.powerBasis h).gen) = 0", "state_after": "F : Type u_1\ninst\u271d\u2074 : Field F\nE : Type u_2\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra F K\nh : IsIntegral F \u03b1\nx : { x // x \u2208 aroots (minpoly F \u03b1) K }\n\u22a2 (aeval \u2191x) (minpoly F \u03b1) = 0"}, {"tactic": "exact (mem_aroots.mp x.2).2", "annotated_tactic": ["exact (mem_aroots.mp x.2).2", []], "state_before": "F : Type u_1\ninst\u271d\u2074 : Field F\nE : Type u_2\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\n\u03b1 : E\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra F K\nh : IsIntegral F \u03b1\nx : { x // x \u2208 aroots (minpoly F \u03b1) K }\n\u22a2 (aeval \u2191x) (minpoly F \u03b1) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "full_name": "Finset.sum_centroidWeightsIndicator_eq_one_of_card_ne_zero", "start": [907, 1], "end": [910, 57], "traced_tactics": [{"tactic": "rw [sum_centroidWeightsIndicator]", "annotated_tactic": ["rw [<a>sum_centroidWeightsIndicator</a>]", [{"full_name": "Finset.sum_centroidWeightsIndicator", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [899, 9], "def_end_pos": [899, 37]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2075 : DivisionRing k\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module k V\ninst\u271d\u00b2 : AffineSpace V P\n\u03b9 : Type u_4\ns : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\ninst\u271d\u00b9 : CharZero k\ninst\u271d : Fintype \u03b9\nh : s.card \u2260 0\n\u22a2 \u2211 i : \u03b9, centroidWeightsIndicator k s i = 1", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2075 : DivisionRing k\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module k V\ninst\u271d\u00b2 : AffineSpace V P\n\u03b9 : Type u_4\ns : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\ninst\u271d\u00b9 : CharZero k\ninst\u271d : Fintype \u03b9\nh : s.card \u2260 0\n\u22a2 \u2211 i in s, centroidWeights k s i = 1"}, {"tactic": "exact s.sum_centroidWeights_eq_one_of_card_ne_zero k h", "annotated_tactic": ["exact s.sum_centroidWeights_eq_one_of_card_ne_zero k h", []], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u2075 : DivisionRing k\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module k V\ninst\u271d\u00b2 : AffineSpace V P\n\u03b9 : Type u_4\ns : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\ninst\u271d\u00b9 : CharZero k\ninst\u271d : Fintype \u03b9\nh : s.card \u2260 0\n\u22a2 \u2211 i in s, centroidWeights k s i = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean", "full_name": "CategoryTheory.MonoidalCategory.whiskerRight_id", "start": [257, 1], "end": [259, 62], "traced_tactics": [{"tactic": "rw [\u2190 assoc, \u2190 rightUnitor_naturality]", "annotated_tactic": ["rw [\u2190 <a>assoc</a>, \u2190 <a>rightUnitor_naturality</a>]", [{"full_name": "CategoryTheory.Category.assoc", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Category/Basic.lean", "def_pos": [168, 3], "def_end_pos": [168, 8]}, {"full_name": "CategoryTheory.MonoidalCategory.rightUnitor_naturality", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Monoidal/Category.lean", "def_pos": [189, 3], "def_end_pos": [189, 25]}]], "state_before": "C : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y : C\nf : X \u27f6 Y\n\u22a2 f \u25b7 \ud835\udfd9_ C = (\u03c1_ X).hom \u226b f \u226b (\u03c1_ Y).inv", "state_after": "C : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y : C\nf : X \u27f6 Y\n\u22a2 f \u25b7 \ud835\udfd9_ C = (f \u25b7 \ud835\udfd9_ C \u226b (\u03c1_ Y).hom) \u226b (\u03c1_ Y).inv"}, {"tactic": "simp [tensorHom_id]", "annotated_tactic": ["simp [<a>tensorHom_id</a>]", [{"full_name": "CategoryTheory.MonoidalCategory.tensorHom_id", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Monoidal/Category.lean", "def_pos": [229, 9], "def_end_pos": [229, 21]}]], "state_before": "C : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y : C\nf : X \u27f6 Y\n\u22a2 f \u25b7 \ud835\udfd9_ C = (f \u25b7 \ud835\udfd9_ C \u226b (\u03c1_ Y).hom) \u226b (\u03c1_ Y).inv", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "full_name": "Real.cos_two_pi_sub", "start": [356, 1], "end": [357, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Field/Basic.lean", "full_name": "nnnorm_pow", "start": [717, 1], "end": [718, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.indexOf_cons_self", "start": [1123, 1], "end": [1124, 53], "traced_tactics": [{"tactic": "rw [indexOf, findIdx_cons, beq_self_eq_true, cond]", "annotated_tactic": ["rw [<a>indexOf</a>, <a>findIdx_cons</a>, <a>beq_self_eq_true</a>, <a>cond</a>]", [{"full_name": "List.indexOf", "def_path": ".lake/packages/std/Std/Data/List/Basic.lean", "def_pos": [336, 5], "def_end_pos": [336, 12]}, {"full_name": "List.findIdx_cons", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1459, 9], "def_end_pos": [1459, 21]}, {"full_name": "beq_self_eq_true", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [224, 17], "def_end_pos": [224, 33]}, {"full_name": "cond", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [998, 21], "def_end_pos": [998, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\n\u22a2 indexOf a (a :: l) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/EssentialImage.lean", "full_name": "CategoryTheory.Iso.map_essSurj", "start": [175, 1], "end": [176, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.floor_pos", "start": [215, 1], "end": [217, 80], "traced_tactics": [{"tactic": "rw [Nat.lt_iff_add_one_le, zero_add, le_floor_iff' Nat.one_ne_zero, cast_one]", "annotated_tactic": ["rw [<a>Nat.lt_iff_add_one_le</a>, <a>zero_add</a>, <a>le_floor_iff'</a> <a>Nat.one_ne_zero</a>, <a>cast_one</a>]", [{"full_name": "Nat.lt_iff_add_one_le", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [105, 7], "def_end_pos": [105, 24]}, {"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}, {"full_name": "Nat.le_floor_iff'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [197, 9], "def_end_pos": [197, 22]}, {"full_name": "Nat.one_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [459, 19], "def_end_pos": [459, 30]}, {"full_name": "Nat.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [150, 9], "def_end_pos": [150, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na : \u03b1\nn : \u2115\n\u22a2 0 < \u230aa\u230b\u208a \u2194 1 \u2264 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Basic.lean", "full_name": "Int.cast_Nat_cast", "start": [71, 1], "end": [73, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Laurent.lean", "full_name": "LaurentPolynomial.T_pow", "start": [197, 1], "end": [198, 49], "traced_tactics": [{"tactic": "rw [T, T, single_pow n, one_pow, nsmul_eq_mul]", "annotated_tactic": ["rw [<a>T</a>, <a>T</a>, <a>single_pow</a> n, <a>one_pow</a>, <a>nsmul_eq_mul</a>]", [{"full_name": "LaurentPolynomial.T", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Laurent.lean", "def_pos": [172, 5], "def_end_pos": [172, 6]}, {"full_name": "LaurentPolynomial.T", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Laurent.lean", "def_pos": [172, 5], "def_end_pos": [172, 6]}, {"full_name": "AddMonoidAlgebra.single_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [1578, 9], "def_end_pos": [1578, 19]}, {"full_name": "one_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [75, 9], "def_end_pos": [75, 16]}, {"full_name": "nsmul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [71, 15], "def_end_pos": [71, 34]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nm : \u2124\nn : \u2115\n\u22a2 T m ^ n = T (\u2191n * m)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "full_name": "fderiv_smul", "start": [301, 1], "end": [303, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SupClosed.lean", "full_name": "supClosure_min", "start": [305, 1], "end": [305, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Combinatorics/Quiver/Path.lean", "full_name": "Quiver.Path.obj_eq_of_cons_eq_cons", "start": [50, 1], "end": [51, 83], "traced_tactics": [{"tactic": "injection h", "annotated_tactic": ["injection h", []], "state_before": "V : Type u\ninst\u271d : Quiver V\na b c d : V\np : Path a b\np' : Path a c\ne : b \u27f6 d\ne' : c \u27f6 d\nh : cons p e = cons p' e'\n\u22a2 b = c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "LinearMap.toMatrix_toLin", "start": [596, 1], "end": [598, 57], "traced_tactics": [{"tactic": "rw [\u2190 Matrix.toLin_symm, LinearEquiv.symm_apply_apply]", "annotated_tactic": ["rw [\u2190 <a>Matrix.toLin_symm</a>, <a>LinearEquiv.symm_apply_apply</a>]", [{"full_name": "Matrix.toLin_symm", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "def_pos": [585, 9], "def_end_pos": [585, 26]}, {"full_name": "LinearEquiv.symm_apply_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [369, 9], "def_end_pos": [369, 25]}]], "state_before": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\n\u22a2 (toMatrix v\u2081 v\u2082) ((toLin v\u2081 v\u2082) M) = M", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "Prod.snd_inf", "start": [1294, 1], "end": [1295, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "bex_congr", "start": [1039, 1], "end": [1040, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "Real.nnnorm_two", "start": [1872, 1], "end": [1873, 23], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : SeminormedCommGroup F\na a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\n\u22a2 \u2191\u20162\u2016\u208a = \u21912", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "AddLECancellable.add_tsub_tsub_cancel", "start": [182, 11], "end": [184, 80], "traced_tactics": [{"tactic": "rw [add_assoc, add_tsub_cancel_of_le h, add_comm]", "annotated_tactic": ["rw [<a>add_assoc</a>, <a>add_tsub_cancel_of_le</a> h, <a>add_comm</a>]", [{"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}, {"full_name": "add_tsub_cancel_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [24, 9], "def_end_pos": [24, 30]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : AddCommSemigroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nhac : AddLECancellable (a - c)\nh : c \u2264 a\n\u22a2 a + b = b + c + (a - c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Defs.lean", "full_name": "Finsupp.coe_sub", "start": [1320, 1], "end": [1320, 101], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/NormedSpace.lean", "full_name": "ContinuousLinearMap.opNorm_comp_linearIsometryEquiv", "start": [199, 1], "end": [212, 62], "traced_tactics": [{"tactic": "cases subsingleton_or_nontrivial F'", "annotated_tactic": ["cases <a>subsingleton_or_nontrivial</a> F'", [{"full_name": "subsingleton_or_nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [99, 9], "def_end_pos": [99, 35]}]], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 = \u2016f\u2016", "state_after": "case inl\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Subsingleton F'\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 = \u2016f\u2016\n\ncase inr\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 = \u2016f\u2016"}, {"tactic": "refine' le_antisymm _ _", "annotated_tactic": ["refine' <a>le_antisymm</a> _ _", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}]], "state_before": "case inr\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 = \u2016f\u2016", "state_after": "case inr.refine'_1\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 \u2264 \u2016f\u2016\n\ncase inr.refine'_2\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016f\u2016 \u2264 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016"}, {"tactic": "haveI := g.symm.toLinearEquiv.toEquiv.subsingleton", "annotated_tactic": ["haveI := g.symm.toLinearEquiv.toEquiv.subsingleton", []], "state_before": "case inl\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Subsingleton F'\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 = \u2016f\u2016", "state_after": "case inl\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Subsingleton F'\nthis : Subsingleton F\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 = \u2016f\u2016"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inl\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Subsingleton F'\nthis : Subsingleton F\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 = \u2016f\u2016", "state_after": "no goals"}, {"tactic": "convert f.opNorm_comp_le g.toLinearIsometry.toContinuousLinearMap", "annotated_tactic": ["convert f.opNorm_comp_le g.toLinearIsometry.toContinuousLinearMap", []], "state_before": "case inr.refine'_1\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 \u2264 \u2016f\u2016", "state_after": "case h.e'_4\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016f\u2016 = \u2016f\u2016 * \u2016LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g)\u2016"}, {"tactic": "simp [g.toLinearIsometry.norm_toContinuousLinearMap]", "annotated_tactic": ["simp [g.toLinearIsometry.norm_toContinuousLinearMap]", []], "state_before": "case h.e'_4\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016f\u2016 = \u2016f\u2016 * \u2016LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g)\u2016", "state_after": "no goals"}, {"tactic": "convert (f.comp g.toLinearIsometry.toContinuousLinearMap).opNorm_comp_le\n    g.symm.toLinearIsometry.toContinuousLinearMap", "annotated_tactic": ["convert (f.comp g.toLinearIsometry.toContinuousLinearMap).<a>opNorm_comp_le</a>\n        g.symm.toLinearIsometry.toContinuousLinearMap", [{"full_name": "ContinuousLinearMap.opNorm_comp_le", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean", "def_pos": [443, 9], "def_end_pos": [443, 23]}]], "state_before": "case inr.refine'_2\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016f\u2016 \u2264 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016", "state_after": "case h.e'_3.h.e'_3\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 f =\n    comp (comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g)))\n      (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry (LinearIsometryEquiv.symm g)))\n\ncase h.e'_4\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 =\n    \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 *\n      \u2016LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry (LinearIsometryEquiv.symm g))\u2016"}, {"tactic": "haveI := g.symm.surjective.nontrivial", "annotated_tactic": ["haveI := g.symm.surjective.nontrivial", []], "state_before": "case h.e'_4\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 =\n    \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 *\n      \u2016LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry (LinearIsometryEquiv.symm g))\u2016", "state_after": "case h.e'_4\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\nthis : Nontrivial F\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 =\n    \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 *\n      \u2016LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry (LinearIsometryEquiv.symm g))\u2016"}, {"tactic": "simp [g.symm.toLinearIsometry.norm_toContinuousLinearMap]", "annotated_tactic": ["simp [g.symm.toLinearIsometry.norm_toContinuousLinearMap]", []], "state_before": "case h.e'_4\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\nthis : Nontrivial F\n\u22a2 \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 =\n    \u2016comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g))\u2016 *\n      \u2016LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry (LinearIsometryEquiv.symm g))\u2016", "state_after": "no goals"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "case h.e'_3.h.e'_3\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\n\u22a2 f =\n    comp (comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g)))\n      (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry (LinearIsometryEquiv.symm g)))", "state_after": "case h.e'_3.h.e'_3.h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\nx\u271d : F\n\u22a2 f x\u271d =\n    (comp (comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g)))\n        (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry (LinearIsometryEquiv.symm g))))\n      x\u271d"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.e'_3.h.e'_3.h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE : Type u_4\nE\u2097 : Type u_5\nF : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b2\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup F\ninst\u271d\u00b9\u2079 : NormedAddCommGroup G\ninst\u271d\u00b9\u2078 : NormedAddCommGroup F\u2097\ninst\u271d\u00b9\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\u2082\ninst\u271d\u00b9\u2075 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u00b9\u2074 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9\u00b3 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d\u00b9\u00b2 : NormedSpace \ud835\udd5c\u2083 G\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c F\u2097\nc : \ud835\udd5c\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083\n\ud835\udd5c\u2082' : Type u_11\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2082'\nF' : Type u_12\ninst\u271d\u2079 : NormedAddCommGroup F'\ninst\u271d\u2078 : NormedSpace \ud835\udd5c\u2082' F'\n\u03c3\u2082' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2082\n\u03c3\u2082'' : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2082'\n\u03c3\u2082\u2083' : \ud835\udd5c\u2082' \u2192+* \ud835\udd5c\u2083\ninst\u271d\u2077 : RingHomInvPair \u03c3\u2082' \u03c3\u2082''\ninst\u271d\u2076 : RingHomInvPair \u03c3\u2082'' \u03c3\u2082'\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2082' \u03c3\u2082\u2083 \u03c3\u2082\u2083'\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082'' \u03c3\u2082\u2083' \u03c3\u2082\u2083\ninst\u271d\u00b3 : RingHomIsometric \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomIsometric \u03c3\u2082'\ninst\u271d\u00b9 : RingHomIsometric \u03c3\u2082''\ninst\u271d : RingHomIsometric \u03c3\u2082\u2083'\nf : F \u2192SL[\u03c3\u2082\u2083] G\ng : F' \u2243\u209b\u2097\u1d62[\u03c3\u2082'] F\nh\u271d : Nontrivial F'\nx\u271d : F\n\u22a2 f x\u271d =\n    (comp (comp f (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry g)))\n        (LinearIsometry.toContinuousLinearMap (LinearIsometryEquiv.toLinearIsometry (LinearIsometryEquiv.symm g))))\n      x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Reindex.lean", "full_name": "Matrix.reindexLinearEquiv_one", "start": [87, 1], "end": [89, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.tsum_sub", "start": [999, 1], "end": [1002, 73], "traced_tactics": [{"tactic": "simp only [\u2190 ENNReal.tsum_add, this]", "annotated_tactic": ["simp only [\u2190 <a>ENNReal.tsum_add</a>, this]", [{"full_name": "ENNReal.tsum_add", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [847, 19], "def_end_pos": [847, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nf\u271d g\u271d : \u03b1 \u2192 \u211d\u22650\u221e\nf g : \u2115 \u2192 \u211d\u22650\u221e\nh\u2081 : \u2211' (i : \u2115), g i \u2260 \u22a4\nh\u2082 : g \u2264 f\nthis : \u2200 (i : \u2115), f i - g i + g i = f i\n\u22a2 \u2211' (i : \u2115), (f i - g i) + \u2211' (i : \u2115), g i = \u2211' (i : \u2115), f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.Nonempty.to_subtype", "start": [522, 1], "end": [523, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/LocalExtr.lean", "full_name": "IsLocalMinOn.comp_mono", "start": [244, 8], "end": [246, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Variables.lean", "full_name": "MvPolynomial.vars_rename", "start": [329, 1], "end": [334, 60], "traced_tactics": [{"tactic": "classical\nintro i hi\nsimp only [vars_def, exists_prop, Multiset.mem_toFinset, Finset.mem_image] at hi \u22a2\nsimpa only [Multiset.mem_map] using degrees_rename _ _ hi", "annotated_tactic": ["classical\n  intro i hi\n  simp only [<a>vars_def</a>, <a>exists_prop</a>, <a>Multiset.mem_toFinset</a>, <a>Finset.mem_image</a>] at hi \u22a2\n  simpa only [<a>Multiset.mem_map</a>] using <a>degrees_rename</a> _ _ hi", [{"full_name": "MvPolynomial.vars_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Variables.lean", "def_pos": [73, 9], "def_end_pos": [73, 17]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "Multiset.mem_toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3292, 9], "def_end_pos": [3292, 21]}, {"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}, {"full_name": "Multiset.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1269, 9], "def_end_pos": [1269, 16]}, {"full_name": "MvPolynomial.degrees_rename", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [199, 9], "def_end_pos": [199, 23]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b2 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : DecidableEq \u03c4\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 vars ((rename f) \u03c6) \u2286 Finset.image f (vars \u03c6)", "state_after": "no goals"}, {"tactic": "intro i hi", "annotated_tactic": ["intro i hi", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b2 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : DecidableEq \u03c4\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 vars ((rename f) \u03c6) \u2286 Finset.image f (vars \u03c6)", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b2 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : DecidableEq \u03c4\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\ni : \u03c4\nhi : i \u2208 vars ((rename f) \u03c6)\n\u22a2 i \u2208 Finset.image f (vars \u03c6)"}, {"tactic": "simp only [vars_def, exists_prop, Multiset.mem_toFinset, Finset.mem_image] at hi \u22a2", "annotated_tactic": ["simp only [<a>vars_def</a>, <a>exists_prop</a>, <a>Multiset.mem_toFinset</a>, <a>Finset.mem_image</a>] at hi \u22a2", [{"full_name": "MvPolynomial.vars_def", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Variables.lean", "def_pos": [73, 9], "def_end_pos": [73, 17]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "Multiset.mem_toFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3292, 9], "def_end_pos": [3292, 21]}, {"full_name": "Finset.mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [361, 9], "def_end_pos": [361, 18]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b2 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : DecidableEq \u03c4\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\ni : \u03c4\nhi : i \u2208 vars ((rename f) \u03c6)\n\u22a2 i \u2208 Finset.image f (vars \u03c6)", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b2 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : DecidableEq \u03c4\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\ni : \u03c4\nhi : i \u2208 degrees ((rename f) \u03c6)\n\u22a2 \u2203 a \u2208 degrees \u03c6, f a = i"}, {"tactic": "simpa only [Multiset.mem_map] using degrees_rename _ _ hi", "annotated_tactic": ["simpa only [<a>Multiset.mem_map</a>] using <a>degrees_rename</a> _ _ hi", [{"full_name": "Multiset.mem_map", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1269, 9], "def_end_pos": [1269, 16]}, {"full_name": "MvPolynomial.degrees_rename", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Degrees.lean", "def_pos": [199, 9], "def_end_pos": [199, 23]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b2 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : DecidableEq \u03c4\nf : \u03c3 \u2192 \u03c4\n\u03c6 : MvPolynomial \u03c3 R\ni : \u03c4\nhi : i \u2208 degrees ((rename f) \u03c6)\n\u22a2 \u2203 a \u2208 degrees \u03c6, f a = i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean", "full_name": "Fin.snoc_rev", "start": [888, 1], "end": [890, 43], "traced_tactics": [{"tactic": "simpa using insertNth_rev (last n) a f i", "annotated_tactic": ["simpa using <a>insertNth_rev</a> (<a>last</a> n) a f i", [{"full_name": "Fin.insertNth_rev", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fin/Tuple/Basic.lean", "def_pos": [868, 7], "def_end_pos": [868, 20]}, {"full_name": "Fin.last", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Basic.lean", "def_pos": [124, 15], "def_end_pos": [124, 19]}]], "state_before": "m n\u271d : \u2115\n\u03b1\u271d : Fin (n\u271d + 1) \u2192 Type u\n\u03b2 : Type v\n\u03b1 : Type u_1\nn : \u2115\na : \u03b1\nf : Fin n \u2192 \u03b1\ni : Fin (n + 1)\n\u22a2 snoc f a (rev i) = cons a (f \u2218 rev) i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "tsub_tsub_assoc", "start": [222, 1], "end": [223, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Fin.lean", "full_name": "Finsupp.tail_cons", "start": [55, 1], "end": [56, 52], "traced_tactics": [{"tactic": "simp only [tail_apply, cons_succ]", "annotated_tactic": ["simp only [<a>tail_apply</a>, <a>cons_succ</a>]", [{"full_name": "Finsupp.tail_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Fin.lean", "def_pos": [39, 9], "def_end_pos": [39, 19]}, {"full_name": "Finsupp.cons_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Fin.lean", "def_pos": [49, 9], "def_end_pos": [49, 18]}]], "state_before": "n : \u2115\ni : Fin n\nM : Type u_1\ninst\u271d : Zero M\ny : M\nt : Fin (n + 1) \u2192\u2080 M\ns : Fin n \u2192\u2080 M\nk : Fin n\n\u22a2 (tail (cons y s)) k = s k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean", "full_name": "Ordinal.IsNormal.nfp_fp", "start": [483, 1], "end": [484, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.mem_iInf_of_iInter", "start": [613, 1], "end": [617, 39], "traced_tactics": [{"tactic": "haveI := I_fin.fintype", "annotated_tactic": ["haveI := I_fin.fintype", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf g : Filter \u03b1\ns\u271d t : Set \u03b1\n\u03b9 : Type u_2\ns : \u03b9 \u2192 Filter \u03b1\nU : Set \u03b1\nI : Set \u03b9\nI_fin : Set.Finite I\nV : \u2191I \u2192 Set \u03b1\nhV : \u2200 (i : \u2191I), V i \u2208 s \u2191i\nhU : \u22c2 i, V i \u2286 U\n\u22a2 U \u2208 \u2a05 i, s i", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf g : Filter \u03b1\ns\u271d t : Set \u03b1\n\u03b9 : Type u_2\ns : \u03b9 \u2192 Filter \u03b1\nU : Set \u03b1\nI : Set \u03b9\nI_fin : Set.Finite I\nV : \u2191I \u2192 Set \u03b1\nhV : \u2200 (i : \u2191I), V i \u2208 s \u2191i\nhU : \u22c2 i, V i \u2286 U\nthis : Fintype \u2191I\n\u22a2 U \u2208 \u2a05 i, s i"}, {"tactic": "refine' mem_of_superset (iInter_mem.2 fun i => _) hU", "annotated_tactic": ["refine' <a>mem_of_superset</a> (<a>iInter_mem</a>.2 fun i => _) hU", [{"full_name": "Filter.mem_of_superset", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [152, 9], "def_end_pos": [152, 24]}, {"full_name": "Filter.iInter_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [220, 9], "def_end_pos": [220, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf g : Filter \u03b1\ns\u271d t : Set \u03b1\n\u03b9 : Type u_2\ns : \u03b9 \u2192 Filter \u03b1\nU : Set \u03b1\nI : Set \u03b9\nI_fin : Set.Finite I\nV : \u2191I \u2192 Set \u03b1\nhV : \u2200 (i : \u2191I), V i \u2208 s \u2191i\nhU : \u22c2 i, V i \u2286 U\nthis : Fintype \u2191I\n\u22a2 U \u2208 \u2a05 i, s i", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf g : Filter \u03b1\ns\u271d t : Set \u03b1\n\u03b9 : Type u_2\ns : \u03b9 \u2192 Filter \u03b1\nU : Set \u03b1\nI : Set \u03b9\nI_fin : Set.Finite I\nV : \u2191I \u2192 Set \u03b1\nhV : \u2200 (i : \u2191I), V i \u2208 s \u2191i\nhU : \u22c2 i, V i \u2286 U\nthis : Fintype \u2191I\ni : \u2191I\n\u22a2 V i \u2208 \u2a05 i, s i"}, {"tactic": "exact mem_iInf_of_mem (i : \u03b9) (hV _)", "annotated_tactic": ["exact <a>mem_iInf_of_mem</a> (i : \u03b9) (hV _)", [{"full_name": "Filter.mem_iInf_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [609, 9], "def_end_pos": [609, 24]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf g : Filter \u03b1\ns\u271d t : Set \u03b1\n\u03b9 : Type u_2\ns : \u03b9 \u2192 Filter \u03b1\nU : Set \u03b1\nI : Set \u03b9\nI_fin : Set.Finite I\nV : \u2191I \u2192 Set \u03b1\nhV : \u2200 (i : \u2191I), V i \u2208 s \u2191i\nhU : \u22c2 i, V i \u2286 U\nthis : Fintype \u2191I\ni : \u2191I\n\u22a2 V i \u2208 \u2a05 i, s i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Pointwise.lean", "full_name": "smul_closedUnitBall_of_nonneg", "start": [416, 1], "end": [418, 51], "traced_tactics": [{"tactic": "rw [smul_closedUnitBall, Real.norm_of_nonneg hr]", "annotated_tactic": ["rw [<a>smul_closedUnitBall</a>, <a>Real.norm_of_nonneg</a> hr]", [{"full_name": "smul_closedUnitBall", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Pointwise.lean", "def_pos": [408, 9], "def_end_pos": [408, 28]}, {"full_name": "Real.norm_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [1844, 9], "def_end_pos": [1844, 23]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : NormedSpace \u211d E\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 r \u2022 closedBall 0 1 = closedBall 0 r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Cast/Field.lean", "full_name": "Int.cast_neg_natCast", "start": [35, 1], "end": [35, 87], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d : DivisionRing R\nn : \u2115\n\u22a2 \u2191(-\u2191n) = -\u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.conjTranspose_add", "start": [2206, 1], "end": [2208, 24], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : StarAddMonoid \u03b1\nM N : Matrix m n \u03b1\n\u22a2 \u2200 (i : n) (j : m), (M + N)\u1d34 i j = (M\u1d34 + N\u1d34) i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.map_equivMapOfInjective_symm_apply", "start": [170, 1], "end": [173, 44], "traced_tactics": [{"tactic": "rw [\u2190 LinearEquiv.apply_symm_apply (equivMapOfInjective f i p) x, coe_equivMapOfInjective_apply,\n  i.eq_iff, LinearEquiv.apply_symm_apply]", "annotated_tactic": ["rw [\u2190 <a>LinearEquiv.apply_symm_apply</a> (<a>equivMapOfInjective</a> f i p) x, <a>coe_equivMapOfInjective_apply</a>,\n    i.eq_iff, <a>LinearEquiv.apply_symm_apply</a>]", [{"full_name": "LinearEquiv.apply_symm_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [364, 9], "def_end_pos": [364, 25]}, {"full_name": "Submodule.equivMapOfInjective", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [149, 19], "def_end_pos": [149, 38]}, {"full_name": "Submodule.coe_equivMapOfInjective_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [164, 9], "def_end_pos": [164, 38]}, {"full_name": "LinearEquiv.apply_symm_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [364, 9], "def_end_pos": [364, 25]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : Semiring R\u2082\ninst\u271d\u00b9\u00b9 : Semiring R\u2083\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2082\ninst\u271d\u2078 : AddCommMonoid M\u2083\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module R\u2082 M\u2082\ninst\u271d\u2075 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\np\u271d p' : Submodule R M\nq q' : Submodule R\u2082 M\u2082\nx\u271d : M\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b3 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nF : Type u_9\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\nf : F\ni : Injective \u21d1f\np : Submodule R M\nx : \u21a5(map f p)\n\u22a2 f \u2191((LinearEquiv.symm (equivMapOfInjective f i p)) x) = \u2191x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Defs.lean", "full_name": "Int.toNat_coe_nat", "start": [234, 1], "end": [234, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Bool/Basic.lean", "full_name": "Bool.forall_bool", "start": [101, 1], "end": [102, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_neg_le_of_le", "start": [541, 1], "end": [542, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Int.lean", "full_name": "Int.dist_eq'", "start": [34, 1], "end": [34, 78], "traced_tactics": [{"tactic": "rw [dist_eq]", "annotated_tactic": ["rw [<a>dist_eq</a>]", [{"full_name": "Int.dist_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/Int.lean", "def_pos": [31, 9], "def_end_pos": [31, 16]}]], "state_before": "m n : \u2124\n\u22a2 dist m n = \u2191|m - n|", "state_after": "m n : \u2124\n\u22a2 |\u2191m - \u2191n| = \u2191|m - n|"}, {"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "m n : \u2124\n\u22a2 |\u2191m - \u2191n| = \u2191|m - n|", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "Classical.some_spec\u2082", "start": [989, 1], "end": [990, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.graph_zero", "start": [116, 1], "end": [116, 63], "traced_tactics": [{"tactic": "simp [graph]", "annotated_tactic": ["simp [<a>graph</a>]", [{"full_name": "Finsupp.graph", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [65, 5], "def_end_pos": [65, 10]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d : Zero M\n\u22a2 graph 0 = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Basic.lean", "full_name": "one_nsmul", "start": [64, 1], "end": [64, 82], "traced_tactics": [{"tactic": "rw [succ_nsmul, zero_nsmul, add_zero]", "annotated_tactic": ["rw [<a>succ_nsmul</a>, <a>zero_nsmul</a>, <a>add_zero</a>]", [{"full_name": "succ_nsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [655, 15], "def_end_pos": [655, 25]}, {"full_name": "zero_nsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [649, 15], "def_end_pos": [649, 25]}, {"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : A\n\u22a2 1 \u2022 a = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Divisors.lean", "full_name": "Nat.divisors_prime_pow", "start": [373, 1], "end": [377, 30], "traced_tactics": [{"tactic": "ext a", "annotated_tactic": ["ext a", []], "state_before": "n p : \u2115\npp : Prime p\nk : \u2115\n\u22a2 divisors (p ^ k) = map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))", "state_after": "case a\nn p : \u2115\npp : Prime p\nk a : \u2115\n\u22a2 a \u2208 divisors (p ^ k) \u2194 a \u2208 map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))"}, {"tactic": "rw [mem_divisors_prime_pow pp]", "annotated_tactic": ["rw [<a>mem_divisors_prime_pow</a> pp]", [{"full_name": "Nat.mem_divisors_prime_pow", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Divisors.lean", "def_pos": [358, 9], "def_end_pos": [358, 31]}]], "state_before": "case a\nn p : \u2115\npp : Prime p\nk a : \u2115\n\u22a2 a \u2208 divisors (p ^ k) \u2194 a \u2208 map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))", "state_after": "case a\nn p : \u2115\npp : Prime p\nk a : \u2115\n\u22a2 (\u2203 j \u2264 k, a = p ^ j) \u2194 a \u2208 map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))"}, {"tactic": "simp [Nat.lt_succ, eq_comm]", "annotated_tactic": ["simp [<a>Nat.lt_succ</a>, <a>eq_comm</a>]", [{"full_name": "Nat.lt_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [91, 9], "def_end_pos": [91, 16]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "case a\nn p : \u2115\npp : Prime p\nk a : \u2115\n\u22a2 (\u2203 j \u2264 k, a = p ^ j) \u2194 a \u2208 map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "full_name": "Set.monotone_or_antitone_iff_uIcc", "start": [256, 1], "end": [265, 89], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d x : \u03b1\n\u22a2 Monotone f \u2228 Antitone f \u2194 \u2200 (a b c : \u03b1), c \u2208 [[a, b]] \u2192 f c \u2208 [[f a, f b]]", "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d x : \u03b1\n\u22a2 Monotone f \u2228 Antitone f \u2192 \u2200 (a b c : \u03b1), c \u2208 [[a, b]] \u2192 f c \u2208 [[f a, f b]]\n\ncase mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d x : \u03b1\n\u22a2 (\u2200 (a b c : \u03b1), c \u2208 [[a, b]] \u2192 f c \u2208 [[f a, f b]]) \u2192 Monotone f \u2228 Antitone f"}, {"tactic": "contrapose!", "annotated_tactic": ["contrapose!", []], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d x : \u03b1\n\u22a2 (\u2200 (a b c : \u03b1), c \u2208 [[a, b]] \u2192 f c \u2208 [[f a, f b]]) \u2192 Monotone f \u2228 Antitone f", "state_after": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d x : \u03b1\n\u22a2 \u00acMonotone f \u2227 \u00acAntitone f \u2192 \u2203 a b, \u2203 c \u2208 [[a, b]], f c \u2209 [[f a, f b]]"}, {"tactic": "rw [not_monotone_not_antitone_iff_exists_le_le]", "annotated_tactic": ["rw [<a>not_monotone_not_antitone_iff_exists_le_le</a>]", [{"full_name": "not_monotone_not_antitone_iff_exists_le_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [928, 7], "def_end_pos": [928, 49]}]], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d x : \u03b1\n\u22a2 \u00acMonotone f \u2227 \u00acAntitone f \u2192 \u2203 a b, \u2203 c \u2208 [[a, b]], f c \u2209 [[f a, f b]]", "state_after": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d x : \u03b1\n\u22a2 (\u2203 a b c, a \u2264 b \u2227 b \u2264 c \u2227 (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c)) \u2192 \u2203 a b, \u2203 c \u2208 [[a, b]], f c \u2209 [[f a, f b]]"}, {"tactic": "rintro \u27e8a, b, c, hab, hbc, \u27e8hfab, hfcb\u27e9 | \u27e8hfba, hfbc\u27e9\u27e9", "annotated_tactic": ["rintro \u27e8a, b, c, hab, hbc, \u27e8hfab, hfcb\u27e9 | \u27e8hfba, hfbc\u27e9\u27e9", []], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d x : \u03b1\n\u22a2 (\u2203 a b c, a \u2264 b \u2227 b \u2264 c \u2227 (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c)) \u2192 \u2203 a b, \u2203 c \u2208 [[a, b]], f c \u2209 [[f a, f b]]", "state_after": "case mpr.intro.intro.intro.intro.intro.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na\u271d a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d d x a b c : \u03b1\nhab : a \u2264 b\nhbc : b \u2264 c\nhfab : f a < f b\nhfcb : f c < f b\n\u22a2 \u2203 a b, \u2203 c \u2208 [[a, b]], f c \u2209 [[f a, f b]]\n\ncase mpr.intro.intro.intro.intro.intro.inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na\u271d a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d d x a b c : \u03b1\nhab : a \u2264 b\nhbc : b \u2264 c\nhfba : f b < f a\nhfbc : f b < f c\n\u22a2 \u2203 a b, \u2203 c \u2208 [[a, b]], f c \u2209 [[f a, f b]]"}, {"tactic": "rintro (hf | hf) a b c <;> simp_rw [\u2190 Icc_min_max, \u2190 hf.map_min, \u2190 hf.map_max]", "annotated_tactic": ["rintro (hf | hf) a b c <;> simp_rw [\u2190 <a>Icc_min_max</a>, \u2190 hf.map_min, \u2190 hf.map_max]", [{"full_name": "Set.Icc_min_max", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "def_pos": [222, 9], "def_end_pos": [222, 20]}]], "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d x : \u03b1\n\u22a2 Monotone f \u2228 Antitone f \u2192 \u2200 (a b c : \u03b1), c \u2208 [[a, b]] \u2192 f c \u2208 [[f a, f b]]", "state_after": "case mp.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na\u271d a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d d x : \u03b1\nhf : Monotone f\na b c : \u03b1\n\u22a2 c \u2208 Icc (min a b) (max a b) \u2192 f c \u2208 Icc (f (min a b)) (f (max a b))\n\ncase mp.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na\u271d a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d d x : \u03b1\nhf : Antitone f\na b c : \u03b1\n\u22a2 c \u2208 Icc (min a b) (max a b) \u2192 f c \u2208 Icc (f (max a b)) (f (min a b))"}, {"tactic": "exacts [fun hc => \u27e8hf hc.1, hf hc.2\u27e9, fun hc => \u27e8hf hc.2, hf hc.1\u27e9]", "annotated_tactic": ["exacts [fun hc => \u27e8hf hc.1, hf hc.2\u27e9, fun hc => \u27e8hf hc.2, hf hc.1\u27e9]", []], "state_before": "case mp.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na\u271d a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d d x : \u03b1\nhf : Monotone f\na b c : \u03b1\n\u22a2 c \u2208 Icc (min a b) (max a b) \u2192 f c \u2208 Icc (f (min a b)) (f (max a b))\n\ncase mp.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na\u271d a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d d x : \u03b1\nhf : Antitone f\na b c : \u03b1\n\u22a2 c \u2208 Icc (min a b) (max a b) \u2192 f c \u2208 Icc (f (max a b)) (f (min a b))", "state_after": "no goals"}, {"tactic": "exact \u27e8a, c, b, Icc_subset_uIcc \u27e8hab, hbc\u27e9, fun h => h.2.not_lt <| max_lt hfab hfcb\u27e9", "annotated_tactic": ["exact \u27e8a, c, b, <a>Icc_subset_uIcc</a> \u27e8hab, hbc\u27e9, fun h => h.2.<a>not_lt</a> <| <a>max_lt</a> hfab hfcb\u27e9", [{"full_name": "Set.Icc_subset_uIcc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "def_pos": [94, 7], "def_end_pos": [94, 22]}, {"full_name": "LE.le.not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [353, 7], "def_end_pos": [353, 19]}, {"full_name": "max_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [166, 9], "def_end_pos": [166, 15]}]], "state_before": "case mpr.intro.intro.intro.intro.intro.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na\u271d a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d d x a b c : \u03b1\nhab : a \u2264 b\nhbc : b \u2264 c\nhfab : f a < f b\nhfcb : f c < f b\n\u22a2 \u2203 a b, \u2203 c \u2208 [[a, b]], f c \u2209 [[f a, f b]]", "state_after": "no goals"}, {"tactic": "exact \u27e8a, c, b, Icc_subset_uIcc \u27e8hab, hbc\u27e9, fun h => h.1.not_lt <| lt_min hfba hfbc\u27e9", "annotated_tactic": ["exact \u27e8a, c, b, <a>Icc_subset_uIcc</a> \u27e8hab, hbc\u27e9, fun h => h.1.<a>not_lt</a> <| <a>lt_min</a> hfba hfbc\u27e9", [{"full_name": "Set.Icc_subset_uIcc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "def_pos": [94, 7], "def_end_pos": [94, 22]}, {"full_name": "LE.le.not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [353, 7], "def_end_pos": [353, 19]}, {"full_name": "lt_min", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [159, 9], "def_end_pos": [159, 15]}]], "state_before": "case mpr.intro.intro.intro.intro.intro.inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na\u271d a\u2081 a\u2082 b\u271d b\u2081 b\u2082 c\u271d d x a b c : \u03b1\nhab : a \u2264 b\nhbc : b \u2264 c\nhfba : f b < f a\nhfbc : f b < f c\n\u22a2 \u2203 a b, \u2203 c \u2208 [[a, b]], f c \u2209 [[f a, f b]]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.symm_apply_eq", "start": [437, 1], "end": [438, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Finset.apply_coe_mem_map", "start": [102, 1], "end": [103, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.MapsTo.restrict_inj", "start": [700, 1], "end": [701, 77], "traced_tactics": [{"tactic": "rw [h.restrict_eq_codRestrict, injective_codRestrict, injOn_iff_injective]", "annotated_tactic": ["rw [h.restrict_eq_codRestrict, <a>injective_codRestrict</a>, <a>injOn_iff_injective</a>]", [{"full_name": "Set.injective_codRestrict", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [164, 9], "def_end_pos": [164, 30]}, {"full_name": "Set.injOn_iff_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [692, 9], "def_end_pos": [692, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nh : MapsTo f s t\n\u22a2 Injective (restrict f s t h) \u2194 InjOn f s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean", "full_name": "padicValRat.neg", "start": [217, 11], "end": [218, 34], "traced_tactics": [{"tactic": "simp [padicValRat, padicValInt]", "annotated_tactic": ["simp [<a>padicValRat</a>, <a>padicValInt</a>]", [{"full_name": "padicValRat", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [201, 5], "def_end_pos": [201, 16]}, {"full_name": "padicValInt", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/Padics/PadicVal.lean", "def_pos": [153, 5], "def_end_pos": [153, 16]}]], "state_before": "p : \u2115\nq : \u211a\n\u22a2 padicValRat p (-q) = padicValRat p q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Set.toFinset_image2", "start": [667, 1], "end": [669, 34], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u00b3 : DecidableEq \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\ninst\u271d\u00b2 : Fintype \u2191s\ninst\u271d\u00b9 : Fintype \u2191t\ninst\u271d : Fintype \u2191(image2 f s t)\n\u22a2 \u2191(toFinset (image2 f s t)) = \u2191(image\u2082 f (toFinset s) (toFinset t))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "full_name": "MeasureTheory.Measure.AbsolutelyContinuous.ae_eq", "start": [1668, 1], "end": [1669, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Nodup.lean", "full_name": "Multiset.Pairwise.forall", "start": [114, 1], "end": [117, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Polynomial.lean", "full_name": "Polynomial.tendsto_abv_eval\u2082_atTop", "start": [105, 1], "end": [120, 23], "traced_tactics": [{"tactic": "revert hf", "annotated_tactic": ["revert hf", []], "state_before": "R : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\np : R[X]\nhd : 0 < degree p\nhf : f (leadingCoeff p) \u2260 0\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) p)) l atTop", "state_after": "R : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\np : R[X]\nhd : 0 < degree p\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\n\u22a2 f (leadingCoeff p) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p)) l atTop"}, {"tactic": "refine' degree_pos_induction_on p hd _ _ _ <;> clear hd p", "annotated_tactic": ["refine' <a>degree_pos_induction_on</a> p hd _ _ _ <;> clear hd p", [{"full_name": "Polynomial.degree_pos_induction_on", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Inductions.lean", "def_pos": [179, 9], "def_end_pos": [179, 32]}]], "state_before": "R : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\np : R[X]\nhd : 0 < degree p\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\n\u22a2 f (leadingCoeff p) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p)) l atTop", "state_after": "case refine'_1\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\n\u22a2 \u2200 {a : R}, a \u2260 0 \u2192 f (leadingCoeff (C a * X)) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) (C a * X))) l atTop\n\ncase refine'_2\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\n\u22a2 \u2200 {p : R[X]},\n    0 < degree p \u2192\n      (f (leadingCoeff p) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p)) l atTop) \u2192\n        f (leadingCoeff (p * X)) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) (p * X))) l atTop\n\ncase refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\n\u22a2 \u2200 {p : R[X]} {a : R},\n    0 < degree p \u2192\n      (f (leadingCoeff p) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p)) l atTop) \u2192\n        f (leadingCoeff (p + C a)) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) (p + C a))) l atTop"}, {"tactic": "rintro _ - hc", "annotated_tactic": ["rintro _ - hc", []], "state_before": "case refine'_1\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\n\u22a2 \u2200 {a : R}, a \u2260 0 \u2192 f (leadingCoeff (C a * X)) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) (C a * X))) l atTop", "state_after": "case refine'_1\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\na\u271d : R\nhc : f (leadingCoeff (C a\u271d * X)) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (C a\u271d * X))) l atTop"}, {"tactic": "rw [leadingCoeff_mul_X, leadingCoeff_C] at hc", "annotated_tactic": ["rw [<a>leadingCoeff_mul_X</a>, <a>leadingCoeff_C</a>] at hc", [{"full_name": "Polynomial.leadingCoeff_mul_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1082, 9], "def_end_pos": [1082, 27]}, {"full_name": "Polynomial.leadingCoeff_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [865, 9], "def_end_pos": [865, 23]}]], "state_before": "case refine'_1\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\na\u271d : R\nhc : f (leadingCoeff (C a\u271d * X)) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (C a\u271d * X))) l atTop", "state_after": "case refine'_1\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\na\u271d : R\nhc : f a\u271d \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (C a\u271d * X))) l atTop"}, {"tactic": "simpa [abv_mul abv] using hz.const_mul_atTop ((abv_pos abv).2 hc)", "annotated_tactic": ["simpa [<a>abv_mul</a> abv] using hz.const_mul_atTop ((<a>abv_pos</a> abv).2 hc)", [{"full_name": "IsAbsoluteValue.abv_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/AbsoluteValue.lean", "def_pos": [331, 7], "def_end_pos": [331, 14]}, {"full_name": "IsAbsoluteValue.abv_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/AbsoluteValue.lean", "def_pos": [358, 9], "def_end_pos": [358, 16]}]], "state_before": "case refine'_1\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\na\u271d : R\nhc : f a\u271d \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (C a\u271d * X))) l atTop", "state_after": "no goals"}, {"tactic": "intro _ _ ihp hf", "annotated_tactic": ["intro _ _ ihp hf", []], "state_before": "case refine'_2\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\n\u22a2 \u2200 {p : R[X]},\n    0 < degree p \u2192\n      (f (leadingCoeff p) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p)) l atTop) \u2192\n        f (leadingCoeff (p * X)) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) (p * X))) l atTop", "state_after": "case refine'_2\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na\u271d : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff (p\u271d * X)) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d * X))) l atTop"}, {"tactic": "rw [leadingCoeff_mul_X] at hf", "annotated_tactic": ["rw [<a>leadingCoeff_mul_X</a>] at hf", [{"full_name": "Polynomial.leadingCoeff_mul_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1082, 9], "def_end_pos": [1082, 27]}]], "state_before": "case refine'_2\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na\u271d : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff (p\u271d * X)) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d * X))) l atTop", "state_after": "case refine'_2\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na\u271d : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff p\u271d) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d * X))) l atTop"}, {"tactic": "simpa [abv_mul abv] using (ihp hf).atTop_mul_atTop hz", "annotated_tactic": ["simpa [<a>abv_mul</a> abv] using (ihp hf).<a>atTop_mul_atTop</a> hz", [{"full_name": "IsAbsoluteValue.abv_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/AbsoluteValue.lean", "def_pos": [331, 7], "def_end_pos": [331, 14]}, {"full_name": "Filter.Tendsto.atTop_mul_atTop", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [939, 9], "def_end_pos": [939, 32]}]], "state_before": "case refine'_2\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na\u271d : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff p\u271d) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d * X))) l atTop", "state_after": "no goals"}, {"tactic": "intro _ a hd ihp hf", "annotated_tactic": ["intro _ a hd ihp hf", []], "state_before": "case refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\n\u22a2 \u2200 {p : R[X]} {a : R},\n    0 < degree p \u2192\n      (f (leadingCoeff p) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p)) l atTop) \u2192\n        f (leadingCoeff (p + C a)) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) (p + C a))) l atTop", "state_after": "case refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na : R\nhd : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff (p\u271d + C a)) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d + C a))) l atTop"}, {"tactic": "rw [add_comm, leadingCoeff_add_of_degree_lt (degree_C_le.trans_lt hd)] at hf", "annotated_tactic": ["rw [<a>add_comm</a>, <a>leadingCoeff_add_of_degree_lt</a> (degree_C_le.trans_lt hd)] at hf", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "Polynomial.leadingCoeff_add_of_degree_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [928, 9], "def_end_pos": [928, 38]}]], "state_before": "case refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na : R\nhd : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff (p\u271d + C a)) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d + C a))) l atTop", "state_after": "case refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na : R\nhd : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff p\u271d) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d + C a))) l atTop"}, {"tactic": "refine' tendsto_atTop_of_add_const_right (abv (-f a)) _", "annotated_tactic": ["refine' <a>tendsto_atTop_of_add_const_right</a> (abv (-f a)) _", [{"full_name": "Filter.tendsto_atTop_of_add_const_right", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [765, 9], "def_end_pos": [765, 41]}]], "state_before": "case refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na : R\nhd : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff p\u271d) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d + C a))) l atTop", "state_after": "case refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na : R\nhd : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff p\u271d) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d + C a)) + abv (-f a)) l atTop"}, {"tactic": "refine' tendsto_atTop_mono (fun _ => abv_add abv _ _) _", "annotated_tactic": ["refine' <a>tendsto_atTop_mono</a> (fun _ => <a>abv_add</a> abv _ _) _", [{"full_name": "Filter.tendsto_atTop_mono", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [426, 9], "def_end_pos": [426, 27]}, {"full_name": "IsAbsoluteValue.abv_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/AbsoluteValue.lean", "def_pos": [328, 7], "def_end_pos": [328, 14]}]], "state_before": "case refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na : R\nhd : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff p\u271d) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d + C a)) + abv (-f a)) l atTop", "state_after": "case refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na : R\nhd : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff p\u271d) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d + C a) + -f a)) l atTop"}, {"tactic": "simpa using ihp hf", "annotated_tactic": ["simpa using ihp hf", []], "state_before": "case refine'_3\nR : Type u_1\nS : Type u_2\nk : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : LinearOrderedField k\nf : R \u2192+* S\nabv : S \u2192 k\ninst\u271d : IsAbsoluteValue abv\nl : Filter \u03b1\nz : \u03b1 \u2192 S\nhz : Tendsto (abv \u2218 z) l atTop\np\u271d : R[X]\na : R\nhd : 0 < degree p\u271d\nihp : f (leadingCoeff p\u271d) \u2260 0 \u2192 Tendsto (fun x => abv (eval\u2082 f (z x) p\u271d)) l atTop\nhf : f (leadingCoeff p\u271d) \u2260 0\n\u22a2 Tendsto (fun x => abv (eval\u2082 f (z x) (p\u271d + C a) + -f a)) l atTop", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "full_name": "Equiv.Perm.cycleType_ofSubtype", "start": [285, 1], "end": [287, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "full_name": "Matrix.adjugate_fin_two", "start": [408, 1], "end": [412, 39], "traced_tactics": [{"tactic": "ext i j", "annotated_tactic": ["ext i j", []], "state_before": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\n\u22a2 adjugate A = of ![![A 1 1, -A 0 1], ![-A 1 0, A 0 0]]", "state_after": "case a.h\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\ni j : Fin 2\n\u22a2 adjugate A i j = of ![![A 1 1, -A 0 1], ![-A 1 0, A 0 0]] i j"}, {"tactic": "rw [adjugate_fin_succ_eq_det_submatrix]", "annotated_tactic": ["rw [<a>adjugate_fin_succ_eq_det_submatrix</a>]", [{"full_name": "Matrix.adjugate_fin_succ_eq_det_submatrix", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "def_pos": [401, 9], "def_end_pos": [401, 43]}]], "state_before": "case a.h\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\ni j : Fin 2\n\u22a2 adjugate A i j = of ![![A 1 1, -A 0 1], ![-A 1 0, A 0 0]] i j", "state_after": "case a.h\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\ni j : Fin 2\n\u22a2 (-1) ^ (\u2191j + \u2191i) * det (submatrix A (Fin.succAbove j) (Fin.succAbove i)) =\n    of ![![A 1 1, -A 0 1], ![-A 1 0, A 0 0]] i j"}, {"tactic": "fin_cases i <;> fin_cases j <;> simp", "annotated_tactic": ["fin_cases i <;> fin_cases j <;> simp", []], "state_before": "case a.h\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix (Fin 2) (Fin 2) \u03b1\ni j : Fin 2\n\u22a2 (-1) ^ (\u2191j + \u2191i) * det (submatrix A (Fin.succAbove j) (Fin.succAbove i)) =\n    of ![![A 1 1, -A 0 1], ![-A 1 0, A 0 0]] i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Sqrt.lean", "full_name": "Nat.sqrt_eq_zero", "start": [112, 1], "end": [115, 25], "traced_tactics": [{"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "n : \u2115\nh : sqrt n = 0\n\u22a2 sqrt n < 1", "state_after": "n : \u2115\nh : sqrt n = 0\n\u22a2 0 < 1"}, {"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "n : \u2115\nh : sqrt n = 0\n\u22a2 0 < 1", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "n : \u2115\n\u22a2 n = 0 \u2192 sqrt n = 0", "state_after": "\u22a2 sqrt 0 = 0"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u22a2 sqrt 0 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "RingHom.ker_eq_comap_bot", "start": [2136, 1], "end": [2137, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Seminorm.lean", "full_name": "Seminorm.bound_of_shell", "start": [1335, 1], "end": [1344, 31], "traced_tactics": [{"tactic": "rcases p.rescale_to_shell hc \u03b5_pos hx with \u27e8\u03b4, h\u03b4, \u03b4xle, le\u03b4x, -\u27e9", "annotated_tactic": ["rcases p.rescale_to_shell hc \u03b5_pos hx with \u27e8\u03b4, h\u03b4, \u03b4xle, le\u03b4x, -\u27e9", []], "state_before": "R : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np q : Seminorm \ud835\udd5c E\n\u03b5 C : \u211d\n\u03b5_pos : 0 < \u03b5\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nhf : \u2200 (x : E), \u03b5 / \u2016c\u2016 \u2264 p x \u2192 p x < \u03b5 \u2192 q x \u2264 C * p x\nx : E\nhx : p x \u2260 0\n\u22a2 q x \u2264 C * p x", "state_after": "case intro.intro.intro.intro\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np q : Seminorm \ud835\udd5c E\n\u03b5 C : \u211d\n\u03b5_pos : 0 < \u03b5\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nhf : \u2200 (x : E), \u03b5 / \u2016c\u2016 \u2264 p x \u2192 p x < \u03b5 \u2192 q x \u2264 C * p x\nx : E\nhx : p x \u2260 0\n\u03b4 : \ud835\udd5c\nh\u03b4 : \u03b4 \u2260 0\n\u03b4xle : p (\u03b4 \u2022 x) < \u03b5\nle\u03b4x : \u03b5 / \u2016c\u2016 \u2264 p (\u03b4 \u2022 x)\n\u22a2 q x \u2264 C * p x"}, {"tactic": "simpa only [map_smul_eq_mul, mul_left_comm C, mul_le_mul_left (norm_pos_iff.2 h\u03b4)]\n  using hf (\u03b4 \u2022 x) le\u03b4x \u03b4xle", "annotated_tactic": ["simpa only [<a>map_smul_eq_mul</a>, <a>mul_left_comm</a> C, <a>mul_le_mul_left</a> (<a>norm_pos_iff</a>.2 h\u03b4)]\n    using hf (\u03b4 \u2022 x) le\u03b4x \u03b4xle", [{"full_name": "SeminormClass.map_smul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [62, 3], "def_end_pos": [62, 18]}, {"full_name": "mul_left_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [156, 9], "def_end_pos": [156, 22]}, {"full_name": "mul_le_mul_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [265, 9], "def_end_pos": [265, 24]}, {"full_name": "norm_pos_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2106, 30], "def_end_pos": [2106, 42]}]], "state_before": "case intro.intro.intro.intro\nR : Type u_1\nR' : Type u_2\n\ud835\udd5c : Type u_3\n\ud835\udd5c\u2082 : Type u_4\n\ud835\udd5c\u2083 : Type u_5\n\ud835\udd5d : Type u_6\nE : Type u_7\nE\u2082 : Type u_8\nE\u2083 : Type u_9\nF : Type u_10\nG : Type u_11\n\u03b9 : Type u_12\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np q : Seminorm \ud835\udd5c E\n\u03b5 C : \u211d\n\u03b5_pos : 0 < \u03b5\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nhf : \u2200 (x : E), \u03b5 / \u2016c\u2016 \u2264 p x \u2192 p x < \u03b5 \u2192 q x \u2264 C * p x\nx : E\nhx : p x \u2260 0\n\u03b4 : \ud835\udd5c\nh\u03b4 : \u03b4 \u2260 0\n\u03b4xle : p (\u03b4 \u2022 x) < \u03b5\nle\u03b4x : \u03b5 / \u2016c\u2016 \u2264 p (\u03b4 \u2022 x)\n\u22a2 q x \u2264 C * p x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/Matrix.lean", "full_name": "Summable.matrix_blockDiag'", "start": [449, 1], "end": [451, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "forall\u2083_true_iff", "start": [721, 1], "end": [722, 54], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Sort ?u.11788\n\u03b1 : Sort ?u.11793\n\u03ba : \u03b9 \u2192 Sort u_1\np q : \u03b1 \u2192 Prop\n\u03b2 : \u03b1 \u2192 Sort u_2\n\u03b3 : (a : \u03b1) \u2192 \u03b2 a \u2192 Sort u_3\n\u22a2 (\u2200 (a : \u03b1) (b : \u03b2 a), \u03b3 a b \u2192 True) \u2194 True", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Basic.lean", "full_name": "Ordinal.induction", "start": [590, 1], "end": [592, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.bsup_eq_blsub_of_lt_succ_limit", "start": [1870, 1], "end": [1874, 55], "traced_tactics": [{"tactic": "rw [bsup_eq_blsub_iff_lt_bsup]", "annotated_tactic": ["rw [<a>bsup_eq_blsub_iff_lt_bsup</a>]", [{"full_name": "Ordinal.bsup_eq_blsub_iff_lt_bsup", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1863, 9], "def_end_pos": [1863, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\no : Ordinal.{u}\nho : IsLimit o\nf : (a : Ordinal.{u}) \u2192 a < o \u2192 Ordinal.{max u v}\nhf : \u2200 (a : Ordinal.{u}) (ha : a < o), f a ha < f (succ a) \u22ef\n\u22a2 bsup o f = blsub o f", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\no : Ordinal.{u}\nho : IsLimit o\nf : (a : Ordinal.{u}) \u2192 a < o \u2192 Ordinal.{max u v}\nhf : \u2200 (a : Ordinal.{u}) (ha : a < o), f a ha < f (succ a) \u22ef\n\u22a2 \u2200 (i : Ordinal.{u}) (hi : i < o), f i hi < bsup o f"}, {"tactic": "exact fun i hi => (hf i hi).trans_le (le_bsup f _ _)", "annotated_tactic": ["exact fun i hi => (hf i hi).<a>trans_le</a> (<a>le_bsup</a> f _ _)", [{"full_name": "LT.lt.trans_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [145, 7], "def_end_pos": [145, 21]}, {"full_name": "Ordinal.le_bsup", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1500, 9], "def_end_pos": [1500, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\no : Ordinal.{u}\nho : IsLimit o\nf : (a : Ordinal.{u}) \u2192 a < o \u2192 Ordinal.{max u v}\nhf : \u2200 (a : Ordinal.{u}) (ha : a < o), f a ha < f (succ a) \u22ef\n\u22a2 \u2200 (i : Ordinal.{u}) (hi : i < o), f i hi < bsup o f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousOn.lean", "full_name": "Filter.EventuallyEq.congr_continuousWithinAt", "start": [1033, 1], "end": [1036, 68], "traced_tactics": [{"tactic": "rw [ContinuousWithinAt, hx, tendsto_congr' h, ContinuousWithinAt]", "annotated_tactic": ["rw [<a>ContinuousWithinAt</a>, hx, <a>tendsto_congr'</a> h, <a>ContinuousWithinAt</a>]", [{"full_name": "ContinuousWithinAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [163, 5], "def_end_pos": [163, 23]}, {"full_name": "Filter.tendsto_congr'", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [3042, 9], "def_end_pos": [3042, 23]}, {"full_name": "ContinuousWithinAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Defs/Filter.lean", "def_pos": [163, 5], "def_end_pos": [163, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx : \u03b1\nh : f =\u1da0[\ud835\udcdd[s] x] g\nhx : f x = g x\n\u22a2 ContinuousWithinAt f s x \u2194 ContinuousWithinAt g s x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Pointwise.lean", "full_name": "Filter.NeBot.zero_div_nonneg", "start": [952, 1], "end": [955, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Equivalence.lean", "full_name": "CategoryTheory.Functor.asEquivalence_unit", "start": [546, 1], "end": [548, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "full_name": "Real.log_nonpos_iff", "start": [207, 1], "end": [207, 100], "traced_tactics": [{"tactic": "rw [\u2190 not_lt, log_pos_iff hx, not_lt]", "annotated_tactic": ["rw [\u2190 <a>not_lt</a>, <a>log_pos_iff</a> hx, <a>not_lt</a>]", [{"full_name": "not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 15]}, {"full_name": "Real.log_pos_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "def_pos": [171, 9], "def_end_pos": [171, 20]}, {"full_name": "not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 15]}]], "state_before": "x y : \u211d\nhx : 0 < x\n\u22a2 log x \u2264 0 \u2194 x \u2264 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/RootsOfUnity/Basic.lean", "full_name": "IsPrimitiveRoot.ne_zero", "start": [559, 11], "end": [560, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "full_name": "le_mul_left", "start": [257, 1], "end": [260, 42], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\ninst\u271d : CanonicallyOrderedCommMonoid \u03b1\na b c d : \u03b1\nh : a \u2264 c\n\u22a2 a = 1 * a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.smul_def", "start": [1384, 1], "end": [1385, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ico_subset_Icc_self", "start": [510, 1], "end": [510, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Order/Basic.lean", "full_name": "Nat.set_induction_bounded", "start": [331, 1], "end": [333, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Ray.lean", "full_name": "norm_injOn_ray_left", "start": [59, 1], "end": [65, 9], "traced_tactics": [{"tactic": "rintro y hy z hz h", "annotated_tactic": ["rintro y hy z hz h", []], "state_before": "E : Type u_1\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx y : F\nhx : x \u2260 0\n\u22a2 Set.InjOn Norm.norm {y | SameRay \u211d x y}", "state_after": "E : Type u_1\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx y\u271d : F\nhx : x \u2260 0\ny : F\nhy : y \u2208 {y | SameRay \u211d x y}\nz : F\nhz : z \u2208 {y | SameRay \u211d x y}\nh : \u2016y\u2016 = \u2016z\u2016\n\u22a2 y = z"}, {"tactic": "rcases hy.exists_nonneg_left hx with \u27e8r, hr, rfl\u27e9", "annotated_tactic": ["rcases hy.exists_nonneg_left hx with \u27e8r, hr, rfl\u27e9", []], "state_before": "E : Type u_1\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx y\u271d : F\nhx : x \u2260 0\ny : F\nhy : y \u2208 {y | SameRay \u211d x y}\nz : F\nhz : z \u2208 {y | SameRay \u211d x y}\nh : \u2016y\u2016 = \u2016z\u2016\n\u22a2 y = z", "state_after": "case intro.intro\nE : Type u_1\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx y : F\nhx : x \u2260 0\nz : F\nhz : z \u2208 {y | SameRay \u211d x y}\nr : \u211d\nhr : 0 \u2264 r\nhy : r \u2022 x \u2208 {y | SameRay \u211d x y}\nh : \u2016r \u2022 x\u2016 = \u2016z\u2016\n\u22a2 r \u2022 x = z"}, {"tactic": "rcases hz.exists_nonneg_left hx with \u27e8s, hs, rfl\u27e9", "annotated_tactic": ["rcases hz.exists_nonneg_left hx with \u27e8s, hs, rfl\u27e9", []], "state_before": "case intro.intro\nE : Type u_1\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx y : F\nhx : x \u2260 0\nz : F\nhz : z \u2208 {y | SameRay \u211d x y}\nr : \u211d\nhr : 0 \u2264 r\nhy : r \u2022 x \u2208 {y | SameRay \u211d x y}\nh : \u2016r \u2022 x\u2016 = \u2016z\u2016\n\u22a2 r \u2022 x = z", "state_after": "case intro.intro.intro.intro\nE : Type u_1\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx y : F\nhx : x \u2260 0\nr : \u211d\nhr : 0 \u2264 r\nhy : r \u2022 x \u2208 {y | SameRay \u211d x y}\ns : \u211d\nhs : 0 \u2264 s\nhz : s \u2022 x \u2208 {y | SameRay \u211d x y}\nh : \u2016r \u2022 x\u2016 = \u2016s \u2022 x\u2016\n\u22a2 r \u2022 x = s \u2022 x"}, {"tactic": "rw [norm_smul, norm_smul, mul_left_inj' (norm_ne_zero_iff.2 hx), norm_of_nonneg hr,\n  norm_of_nonneg hs] at h", "annotated_tactic": ["rw [<a>norm_smul</a>, <a>norm_smul</a>, <a>mul_left_inj'</a> (<a>norm_ne_zero_iff</a>.2 hx), <a>norm_of_nonneg</a> hr,\n    <a>norm_of_nonneg</a> hs] at h", [{"full_name": "norm_smul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/MulAction.lean", "def_pos": [90, 9], "def_end_pos": [90, 18]}, {"full_name": "norm_smul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/MulAction.lean", "def_pos": [90, 9], "def_end_pos": [90, 18]}, {"full_name": "mul_left_inj'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [126, 9], "def_end_pos": [126, 22]}, {"full_name": "norm_ne_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2100, 15], "def_end_pos": [2100, 31]}, {"full_name": "Real.norm_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [1844, 9], "def_end_pos": [1844, 23]}, {"full_name": "Real.norm_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [1844, 9], "def_end_pos": [1844, 23]}]], "state_before": "case intro.intro.intro.intro\nE : Type u_1\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx y : F\nhx : x \u2260 0\nr : \u211d\nhr : 0 \u2264 r\nhy : r \u2022 x \u2208 {y | SameRay \u211d x y}\ns : \u211d\nhs : 0 \u2264 s\nhz : s \u2022 x \u2208 {y | SameRay \u211d x y}\nh : \u2016r \u2022 x\u2016 = \u2016s \u2022 x\u2016\n\u22a2 r \u2022 x = s \u2022 x", "state_after": "case intro.intro.intro.intro\nE : Type u_1\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx y : F\nhx : x \u2260 0\nr : \u211d\nhr : 0 \u2264 r\nhy : r \u2022 x \u2208 {y | SameRay \u211d x y}\ns : \u211d\nhs : 0 \u2264 s\nhz : s \u2022 x \u2208 {y | SameRay \u211d x y}\nh : r = s\n\u22a2 r \u2022 x = s \u2022 x"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "case intro.intro.intro.intro\nE : Type u_1\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx y : F\nhx : x \u2260 0\nr : \u211d\nhr : 0 \u2264 r\nhy : r \u2022 x \u2208 {y | SameRay \u211d x y}\ns : \u211d\nhs : 0 \u2264 s\nhz : s \u2022 x \u2208 {y | SameRay \u211d x y}\nh : r = s\n\u22a2 r \u2022 x = s \u2022 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Exp.lean", "full_name": "Complex.comap_exp_cobounded", "start": [441, 1], "end": [445, 55], "traced_tactics": [{"tactic": "rw [Real.comap_exp_atTop]", "annotated_tactic": ["rw [<a>Real.comap_exp_atTop</a>]", [{"full_name": "Real.comap_exp_atTop", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Exp.lean", "def_pos": [310, 9], "def_end_pos": [310, 24]}]], "state_before": "\u22a2 comap re (comap Real.exp atTop) = comap re atTop", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "ContinuousLinearMap.comp_add", "start": [830, 1], "end": [833, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b9\u2079 : Semiring R\u2081\ninst\u271d\u00b9\u2078 : Semiring R\u2082\ninst\u271d\u00b9\u2077 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\nM\u2081 : Type u_4\ninst\u271d\u00b9\u2076 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u2074 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u00b3 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u00b9\u00b2 : TopologicalSpace M\u2082\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u00b9\u2070 : TopologicalSpace M\u2083\ninst\u271d\u2079 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2078 : TopologicalSpace M\u2084\ninst\u271d\u2077 : AddCommMonoid M\u2084\ninst\u271d\u2076 : Module R\u2081 M\u2081\ninst\u271d\u2075 : Module R\u2081 M'\u2081\ninst\u271d\u2074 : Module R\u2082 M\u2082\ninst\u271d\u00b3 : Module R\u2083 M\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : ContinuousAdd M\u2082\ninst\u271d : ContinuousAdd M\u2083\ng : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083\nf\u2081 f\u2082 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\n\u22a2 comp g (f\u2081 + f\u2082) = comp g f\u2081 + comp g f\u2082", "state_after": "case h\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b9\u2079 : Semiring R\u2081\ninst\u271d\u00b9\u2078 : Semiring R\u2082\ninst\u271d\u00b9\u2077 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\nM\u2081 : Type u_4\ninst\u271d\u00b9\u2076 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u2074 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u00b3 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u00b9\u00b2 : TopologicalSpace M\u2082\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u00b9\u2070 : TopologicalSpace M\u2083\ninst\u271d\u2079 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2078 : TopologicalSpace M\u2084\ninst\u271d\u2077 : AddCommMonoid M\u2084\ninst\u271d\u2076 : Module R\u2081 M\u2081\ninst\u271d\u2075 : Module R\u2081 M'\u2081\ninst\u271d\u2074 : Module R\u2082 M\u2082\ninst\u271d\u00b3 : Module R\u2083 M\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : ContinuousAdd M\u2082\ninst\u271d : ContinuousAdd M\u2083\ng : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083\nf\u2081 f\u2082 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nx\u271d : M\u2081\n\u22a2 (comp g (f\u2081 + f\u2082)) x\u271d = (comp g f\u2081 + comp g f\u2082) x\u271d"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\ninst\u271d\u00b9\u2079 : Semiring R\u2081\ninst\u271d\u00b9\u2078 : Semiring R\u2082\ninst\u271d\u00b9\u2077 : Semiring R\u2083\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\nM\u2081 : Type u_4\ninst\u271d\u00b9\u2076 : TopologicalSpace M\u2081\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2081\nM'\u2081 : Type u_5\ninst\u271d\u00b9\u2074 : TopologicalSpace M'\u2081\ninst\u271d\u00b9\u00b3 : AddCommMonoid M'\u2081\nM\u2082 : Type u_6\ninst\u271d\u00b9\u00b2 : TopologicalSpace M\u2082\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2082\nM\u2083 : Type u_7\ninst\u271d\u00b9\u2070 : TopologicalSpace M\u2083\ninst\u271d\u2079 : AddCommMonoid M\u2083\nM\u2084 : Type u_8\ninst\u271d\u2078 : TopologicalSpace M\u2084\ninst\u271d\u2077 : AddCommMonoid M\u2084\ninst\u271d\u2076 : Module R\u2081 M\u2081\ninst\u271d\u2075 : Module R\u2081 M'\u2081\ninst\u271d\u2074 : Module R\u2082 M\u2082\ninst\u271d\u00b3 : Module R\u2083 M\u2083\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u00b9 : ContinuousAdd M\u2082\ninst\u271d : ContinuousAdd M\u2083\ng : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083\nf\u2081 f\u2082 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082\nx\u271d : M\u2081\n\u22a2 (comp g (f\u2081 + f\u2082)) x\u271d = (comp g f\u2081 + comp g f\u2082) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/Deriv/Comp.lean", "full_name": "fderivWithin.comp_derivWithin", "start": [258, 1], "end": [261, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Subfield.lean", "full_name": "Subfield.coe_sub", "start": [359, 1], "end": [360, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.range_ite_subset", "start": [1084, 1], "end": [1088, 45], "traced_tactics": [{"tactic": "rw [range_subset_iff]", "annotated_tactic": ["rw [<a>range_subset_iff</a>]", [{"full_name": "Set.range_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [725, 9], "def_end_pos": [725, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\n\u22a2 (range fun x => if p x then f x else g x) \u2286 range f \u222a range g", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (y : \u03b1), (if p y then f y else g y) \u2208 range f \u222a range g"}, {"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (y : \u03b1), (if p y then f y else g y) \u2208 range f \u222a range g", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 (if p x then f x else g x) \u2208 range f \u222a range g"}, {"tactic": "by_cases h : p x", "annotated_tactic": ["by_cases h : p x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 (if p x then f x else g x) \u2208 range f \u222a range g", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\nx : \u03b1\nh : p x\n\u22a2 (if p x then f x else g x) \u2208 range f \u222a range g\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\nx : \u03b1\nh : \u00acp x\n\u22a2 (if p x then f x else g x) \u2208 range f \u222a range g"}, {"tactic": "simp only [if_pos h, mem_union, mem_range, exists_apply_eq_apply, true_or]", "annotated_tactic": ["simp only [<a>if_pos</a> h, <a>mem_union</a>, <a>mem_range</a>, <a>exists_apply_eq_apply</a>, <a>true_or</a>]", [{"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "Set.mem_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 18]}, {"full_name": "Set.mem_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [160, 17], "def_end_pos": [160, 26]}, {"full_name": "exists_apply_eq_apply", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [243, 17], "def_end_pos": [243, 38]}, {"full_name": "true_or", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [112, 17], "def_end_pos": [112, 24]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\nx : \u03b1\nh : p x\n\u22a2 (if p x then f x else g x) \u2208 range f \u222a range g\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\nx : \u03b1\nh : \u00acp x\n\u22a2 (if p x then f x else g x) \u2208 range f \u222a range g", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\nx : \u03b1\nh : \u00acp x\n\u22a2 (if p x then f x else g x) \u2208 range f \u222a range g"}, {"tactic": "simp [if_neg h, mem_union, mem_range_self]", "annotated_tactic": ["simp [<a>if_neg</a> h, <a>mem_union</a>, <a>mem_range_self</a>]", [{"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "Set.mem_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 18]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nf g : \u03b1 \u2192 \u03b2\nx : \u03b1\nh : \u00acp x\n\u22a2 (if p x then f x else g x) \u2208 range f \u222a range g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Splits.lean", "full_name": "Polynomial.eq_X_sub_C_of_splits_of_single_root", "start": [363, 1], "end": [367, 7], "traced_tactics": [{"tactic": "apply Polynomial.map_injective _ i.injective", "annotated_tactic": ["apply <a>Polynomial.map_injective</a> _ i.injective", [{"full_name": "Polynomial.map_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [853, 9], "def_end_pos": [853, 22]}]], "state_before": "R : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni : K \u2192+* L\nx : K\nh : K[X]\nh_splits : Splits i h\nh_roots : roots (map i h) = {i x}\n\u22a2 h = C (leadingCoeff h) * (X - C x)", "state_after": "case a\nR : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni : K \u2192+* L\nx : K\nh : K[X]\nh_splits : Splits i h\nh_roots : roots (map i h) = {i x}\n\u22a2 map i h = map i (C (leadingCoeff h) * (X - C x))"}, {"tactic": "rw [eq_prod_roots_of_splits h_splits, h_roots]", "annotated_tactic": ["rw [<a>eq_prod_roots_of_splits</a> h_splits, h_roots]", [{"full_name": "Polynomial.eq_prod_roots_of_splits", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Splits.lean", "def_pos": [345, 9], "def_end_pos": [345, 32]}]], "state_before": "case a\nR : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni : K \u2192+* L\nx : K\nh : K[X]\nh_splits : Splits i h\nh_roots : roots (map i h) = {i x}\n\u22a2 map i h = map i (C (leadingCoeff h) * (X - C x))", "state_after": "case a\nR : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni : K \u2192+* L\nx : K\nh : K[X]\nh_splits : Splits i h\nh_roots : roots (map i h) = {i x}\n\u22a2 C (i (leadingCoeff h)) * Multiset.prod (Multiset.map (fun a => X - C a) {i x}) =\n    map i (C (leadingCoeff h) * (X - C x))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\nR : Type u_1\nF : Type u\nK : Type v\nL : Type w\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Field F\ni : K \u2192+* L\nx : K\nh : K[X]\nh_splits : Splits i h\nh_roots : roots (map i h) = {i x}\n\u22a2 C (i (leadingCoeff h)) * Multiset.prod (Multiset.map (fun a => X - C a) {i x}) =\n    map i (C (leadingCoeff h) * (X - C x))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Bitwise.lean", "full_name": "Int.testBit_lnot", "start": [360, 1], "end": [362, 41], "traced_tactics": [{"tactic": "simp [lnot, testBit]", "annotated_tactic": ["simp [<a>lnot</a>, <a>testBit</a>]", [{"full_name": "Int.lnot", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Int/Bitwise.lean", "def_pos": [64, 5], "def_end_pos": [64, 9]}, {"full_name": "Int.testBit", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Int/Bitwise.lean", "def_pos": [44, 5], "def_end_pos": [44, 12]}]], "state_before": "n k : \u2115\n\u22a2 testBit (lnot \u2191n) k = !testBit (\u2191n) k", "state_after": "no goals"}, {"tactic": "simp [lnot, testBit]", "annotated_tactic": ["simp [<a>lnot</a>, <a>testBit</a>]", [{"full_name": "Int.lnot", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Int/Bitwise.lean", "def_pos": [64, 5], "def_end_pos": [64, 9]}, {"full_name": "Int.testBit", "def_path": ".lake/packages/mathlib/Mathlib/Init/Data/Int/Bitwise.lean", "def_pos": [44, 5], "def_end_pos": [44, 12]}]], "state_before": "n k : \u2115\n\u22a2 testBit (lnot -[n+1]) k = !testBit -[n+1] k", "state_after": "no goals"}]}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "amc12a_2008_p8", "start": [20, 1], "end": [22, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "x y : \u211d\nh\u2080 : 0 < x \u2227 0 < y\nh\u2081 : y ^ 3 = 1\nh\u2082 : 6 * x ^ 2 = 2 * (6 * y ^ 2)\n\u22a2 x ^ 3 = 2 * Real.sqrt 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "full_name": "CstarRing.star_mul_self_eq_zero_iff", "start": [135, 1], "end": [137, 44], "traced_tactics": [{"tactic": "rw [\u2190 norm_eq_zero, norm_star_mul_self]", "annotated_tactic": ["rw [\u2190 <a>norm_eq_zero</a>, <a>norm_star_mul_self</a>]", [{"full_name": "norm_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2094, 30], "def_end_pos": [2094, 42]}, {"full_name": "CstarRing.norm_star_mul_self", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/NormedSpace/Star/Basic.lean", "def_pos": [86, 3], "def_end_pos": [86, 21]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b2 : NonUnitalNormedRing E\ninst\u271d\u00b9 : StarRing E\ninst\u271d : CstarRing E\nx : E\n\u22a2 x\u22c6 * x = 0 \u2194 x = 0", "state_after": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b2 : NonUnitalNormedRing E\ninst\u271d\u00b9 : StarRing E\ninst\u271d : CstarRing E\nx : E\n\u22a2 \u2016x\u2016 * \u2016x\u2016 = 0 \u2194 x = 0"}, {"tactic": "exact mul_self_eq_zero.trans norm_eq_zero", "annotated_tactic": ["exact mul_self_eq_zero.trans <a>norm_eq_zero</a>", [{"full_name": "norm_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [2094, 30], "def_end_pos": [2094, 42]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b2 : NonUnitalNormedRing E\ninst\u271d\u00b9 : StarRing E\ninst\u271d : CstarRing E\nx : E\n\u22a2 \u2016x\u2016 * \u2016x\u2016 = 0 \u2194 x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "mul_le_mul_of_nonneg_right", "start": [210, 1], "end": [211, 72], "traced_tactics": []}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "mathd_numbertheory_232", "start": [776, 1], "end": [780, 16], "traced_tactics": [{"tactic": "aesop_subst [h\u2082, h\u2081, h\u2080]", "annotated_tactic": ["aesop_subst [h\u2082, h\u2081, h\u2080]", []], "state_before": "x y z : ZMod 31\nh\u2080 : x = 3\u207b\u00b9\nh\u2081 : y = 5\u207b\u00b9\nh\u2082 : z = (x + y)\u207b\u00b9\n\u22a2 z = 29", "state_after": "\u22a2 (3\u207b\u00b9 + 5\u207b\u00b9)\u207b\u00b9 = 29"}, {"tactic": "apply Eq.refl", "annotated_tactic": ["apply <a>Eq.refl</a>", [{"full_name": "Eq.refl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [279, 5], "def_end_pos": [279, 9]}]], "state_before": "\u22a2 (3\u207b\u00b9 + 5\u207b\u00b9)\u207b\u00b9 = 29", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/IntermediateField.lean", "full_name": "IntermediateField.isIntegral_iff", "start": [822, 1], "end": [823, 81], "traced_tactics": [{"tactic": "rw [\u2190 isAlgebraic_iff_isIntegral, isAlgebraic_iff, isAlgebraic_iff_isIntegral]", "annotated_tactic": ["rw [\u2190 <a>isAlgebraic_iff_isIntegral</a>, <a>isAlgebraic_iff</a>, <a>isAlgebraic_iff_isIntegral</a>]", [{"full_name": "isAlgebraic_iff_isIntegral", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Algebraic.lean", "def_pos": [220, 9], "def_end_pos": [220, 35]}, {"full_name": "IntermediateField.isAlgebraic_iff", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/IntermediateField.lean", "def_pos": [818, 9], "def_end_pos": [818, 24]}, {"full_name": "isAlgebraic_iff_isIntegral", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Algebraic.lean", "def_pos": [220, 9], "def_end_pos": [220, 35]}]], "state_before": "K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Field L'\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : Algebra K L'\nS : IntermediateField K L\nx : \u21a5S\n\u22a2 IsIntegral K x \u2194 IsIntegral K \u2191x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.aeval_zero'", "start": [1551, 1], "end": [1553, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.mem_factors'_iff_dvd", "start": [1640, 1], "end": [1646, 37], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na p : \u03b1\nha0 : a \u2260 0\nhp : Irreducible p\n\u22a2 { val := Associates.mk p, property := \u22ef } \u2208 factors' a \u2194 p \u2223 a", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na p : \u03b1\nha0 : a \u2260 0\nhp : Irreducible p\n\u22a2 { val := Associates.mk p, property := \u22ef } \u2208 factors' a \u2192 p \u2223 a\n\ncase mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na p : \u03b1\nha0 : a \u2260 0\nhp : Irreducible p\n\u22a2 p \u2223 a \u2192 { val := Associates.mk p, property := \u22ef } \u2208 factors' a"}, {"tactic": "rw [\u2190 mk_dvd_mk]", "annotated_tactic": ["rw [\u2190 <a>mk_dvd_mk</a>]", [{"full_name": "Associates.mk_dvd_mk", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [1008, 9], "def_end_pos": [1008, 18]}]], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na p : \u03b1\nha0 : a \u2260 0\nhp : Irreducible p\n\u22a2 { val := Associates.mk p, property := \u22ef } \u2208 factors' a \u2192 p \u2223 a", "state_after": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na p : \u03b1\nha0 : a \u2260 0\nhp : Irreducible p\n\u22a2 { val := Associates.mk p, property := \u22ef } \u2208 factors' a \u2192 Associates.mk p \u2223 Associates.mk a"}, {"tactic": "apply dvd_of_mem_factors'", "annotated_tactic": ["apply <a>dvd_of_mem_factors'</a>", [{"full_name": "Associates.dvd_of_mem_factors'", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1625, 9], "def_end_pos": [1625, 28]}]], "state_before": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na p : \u03b1\nha0 : a \u2260 0\nhp : Irreducible p\n\u22a2 { val := Associates.mk p, property := \u22ef } \u2208 factors' a \u2192 Associates.mk p \u2223 Associates.mk a", "state_after": "case mp.hz\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na p : \u03b1\nha0 : a \u2260 0\nhp : Irreducible p\n\u22a2 a \u2260 0"}, {"tactic": "apply ha0", "annotated_tactic": ["apply ha0", []], "state_before": "case mp.hz\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na p : \u03b1\nha0 : a \u2260 0\nhp : Irreducible p\n\u22a2 a \u2260 0", "state_after": "no goals"}, {"tactic": "apply mem_factors'_of_dvd ha0 hp", "annotated_tactic": ["apply <a>mem_factors'_of_dvd</a> ha0 hp", [{"full_name": "Associates.mem_factors'_of_dvd", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1633, 9], "def_end_pos": [1633, 28]}]], "state_before": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d : UniqueFactorizationMonoid \u03b1\na p : \u03b1\nha0 : a \u2260 0\nhp : Irreducible p\n\u22a2 p \u2223 a \u2192 { val := Associates.mk p, property := \u22ef } \u2208 factors' a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Iterate.lean", "full_name": "Function.comp_iterate_pred_of_pos", "start": [199, 1], "end": [200, 51], "traced_tactics": [{"tactic": "rw [\u2190 iterate_succ', Nat.succ_pred_eq_of_pos hn]", "annotated_tactic": ["rw [\u2190 <a>iterate_succ'</a>, <a>Nat.succ_pred_eq_of_pos</a> hn]", [{"full_name": "Function.iterate_succ'", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [186, 9], "def_end_pos": [186, 22]}, {"full_name": "Nat.succ_pred_eq_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [573, 9], "def_end_pos": [573, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b1\nn : \u2115\nhn : 0 < n\n\u22a2 f \u2218 f^[Nat.pred n] = f^[n]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_finset_coe", "start": [1059, 1], "end": [1060, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.sdiff_erase", "start": [2427, 1], "end": [2429, 16], "traced_tactics": [{"tactic": "rw [\u2190 sdiff_singleton_eq_erase, sdiff_sdiff_eq_sdiff_union (singleton_subset_iff.2 h), insert_eq,\n  union_comm]", "annotated_tactic": ["rw [\u2190 <a>sdiff_singleton_eq_erase</a>, <a>sdiff_sdiff_eq_sdiff_union</a> (<a>singleton_subset_iff</a>.2 h), <a>insert_eq</a>,\n    <a>union_comm</a>]", [{"full_name": "Finset.sdiff_singleton_eq_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2319, 9], "def_end_pos": [2319, 33]}, {"full_name": "Finset.sdiff_sdiff_eq_sdiff_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2413, 9], "def_end_pos": [2413, 35]}, {"full_name": "Finset.singleton_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [784, 9], "def_end_pos": [784, 29]}, {"full_name": "Finset.insert_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1521, 9], "def_end_pos": [1521, 18]}, {"full_name": "Finset.union_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1463, 9], "def_end_pos": [1463, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t u v : Finset \u03b1\na b : \u03b1\nh : a \u2208 s\n\u22a2 s \\ erase t a = insert a (s \\ t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Defs.lean", "full_name": "left_distrib", "start": [78, 1], "end": [80, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Isometry.lean", "full_name": "IsometryEquiv.toEquiv_inj", "start": [311, 9], "end": [312, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/FieldDivision.lean", "full_name": "Polynomial.monic_normalize", "start": [514, 1], "end": [517, 12], "traced_tactics": [{"tactic": "rw [Ne.def, \u2190 leadingCoeff_eq_zero, \u2190 Ne.def, \u2190 isUnit_iff_ne_zero] at hp0", "annotated_tactic": ["rw [<a>Ne.def</a>, \u2190 <a>leadingCoeff_eq_zero</a>, \u2190 <a>Ne.def</a>, \u2190 <a>isUnit_iff_ne_zero</a>] at hp0", [{"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [678, 9], "def_end_pos": [678, 29]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "isUnit_iff_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [252, 9], "def_end_pos": [252, 27]}]], "state_before": "R : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Field R\np q : R[X]\ninst\u271d : DecidableEq R\nhp0 : p \u2260 0\n\u22a2 Monic (normalize p)", "state_after": "R : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Field R\np q : R[X]\ninst\u271d : DecidableEq R\nhp0 : IsUnit (leadingCoeff p)\n\u22a2 Monic (normalize p)"}, {"tactic": "rw [Monic, leadingCoeff_normalize, normalize_eq_one]", "annotated_tactic": ["rw [<a>Monic</a>, <a>leadingCoeff_normalize</a>, <a>normalize_eq_one</a>]", [{"full_name": "Polynomial.Monic", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [79, 5], "def_end_pos": [79, 10]}, {"full_name": "Polynomial.leadingCoeff_normalize", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/FieldDivision.lean", "def_pos": [201, 9], "def_end_pos": [201, 31]}, {"full_name": "normalize_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [156, 9], "def_end_pos": [156, 25]}]], "state_before": "R : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Field R\np q : R[X]\ninst\u271d : DecidableEq R\nhp0 : IsUnit (leadingCoeff p)\n\u22a2 Monic (normalize p)", "state_after": "R : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Field R\np q : R[X]\ninst\u271d : DecidableEq R\nhp0 : IsUnit (leadingCoeff p)\n\u22a2 IsUnit (leadingCoeff p)"}, {"tactic": "apply hp0", "annotated_tactic": ["apply hp0", []], "state_before": "R : Type u\nS : Type v\nk : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Field R\np q : R[X]\ninst\u271d : DecidableEq R\nhp0 : IsUnit (leadingCoeff p)\n\u22a2 IsUnit (leadingCoeff p)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "full_name": "Matrix.det_conj", "start": [766, 1], "end": [767, 57], "traced_tactics": [{"tactic": "rw [\u2190 h.unit_spec, \u2190 coe_units_inv, det_units_conj]", "annotated_tactic": ["rw [\u2190 h.unit_spec, \u2190 <a>coe_units_inv</a>, <a>det_units_conj</a>]", [{"full_name": "Matrix.coe_units_inv", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "def_pos": [233, 9], "def_end_pos": [233, 22]}, {"full_name": "Matrix.det_units_conj", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [215, 9], "def_end_pos": [215, 23]}]], "state_before": "l : Type u_1\nm : Type u\nn : Type u'\n\u03b1 : Type v\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : CommRing \u03b1\nA B : Matrix n n \u03b1\ninst\u271d\u00b9 : Fintype m\ninst\u271d : DecidableEq m\nM : Matrix m m \u03b1\nh : IsUnit M\nN : Matrix m m \u03b1\n\u22a2 det (M * N * M\u207b\u00b9) = det N", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "LowerSet.coe_iInf\u2082", "start": [790, 1], "end": [791, 24], "traced_tactics": [{"tactic": "simp_rw [coe_iInf]", "annotated_tactic": ["simp_rw [<a>coe_iInf</a>]", [{"full_name": "LowerSet.coe_iInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/UpperLower/Basic.lean", "def_pos": [780, 9], "def_end_pos": [780, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nS : Set (LowerSet \u03b1)\ns t : LowerSet \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 LowerSet \u03b1\n\u22a2 \u2191(\u2a05 i, \u2a05 j, f i j) = \u22c2 i, \u22c2 j, \u2191(f i j)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.id_prod", "start": [133, 1], "end": [134, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.Prime.pow_eq_iff", "start": [608, 1], "end": [611, 70], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, fun h => by rw [h.1, h.2, pow_one]\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, fun h => by rw [h.1, h.2, <a>pow_one</a>]\u27e9", [{"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}]], "state_before": "n p a k : \u2115\nhp : Prime p\n\u22a2 a ^ k = p \u2194 a = p \u2227 k = 1", "state_after": "n p a k : \u2115\nhp : Prime p\nh : a ^ k = p\n\u22a2 a = p \u2227 k = 1"}, {"tactic": "rw [\u2190 h] at hp", "annotated_tactic": ["rw [\u2190 h] at hp", []], "state_before": "n p a k : \u2115\nhp : Prime p\nh : a ^ k = p\n\u22a2 a = p \u2227 k = 1", "state_after": "n p a k : \u2115\nhp : Prime (a ^ k)\nh : a ^ k = p\n\u22a2 a = p \u2227 k = 1"}, {"tactic": "rw [\u2190 h, hp.eq_one_of_pow, eq_self_iff_true, and_true_iff, pow_one]", "annotated_tactic": ["rw [\u2190 h, hp.eq_one_of_pow, <a>eq_self_iff_true</a>, <a>and_true_iff</a>, <a>pow_one</a>]", [{"full_name": "eq_self_iff_true", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1368, 9], "def_end_pos": [1368, 25]}, {"full_name": "and_true_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [138, 9], "def_end_pos": [138, 21]}, {"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}]], "state_before": "n p a k : \u2115\nhp : Prime (a ^ k)\nh : a ^ k = p\n\u22a2 a = p \u2227 k = 1", "state_after": "no goals"}, {"tactic": "rw [h.1, h.2, pow_one]", "annotated_tactic": ["rw [h.1, h.2, <a>pow_one</a>]", [{"full_name": "pow_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 16]}]], "state_before": "n p a k : \u2115\nhp : Prime p\nh : a = p \u2227 k = 1\n\u22a2 a ^ k = p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/BinomialHeap/Basic.lean", "full_name": "Std.BinomialHeap.Imp.HeapNode.WF.rank_eq", "start": [410, 1], "end": [412, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/RatFunc.lean", "full_name": "RatFunc.eval_mul", "start": [1537, 1], "end": [1548, 22], "traced_tactics": [{"tactic": "unfold eval", "annotated_tactic": ["unfold <a>eval</a>", [{"full_name": "RatFunc.eval", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1469, 5], "def_end_pos": [1469, 9]}]], "state_before": "K : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\n\u22a2 eval f a (x * y) = eval f a x * eval f a y", "state_after": "K : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))"}, {"tactic": "by_cases hxy : Polynomial.eval\u2082 f a (denom (x * y)) = 0", "annotated_tactic": ["by_cases hxy : <a>Polynomial.eval\u2082</a> f a (<a>denom</a> (x * y)) = 0", [{"full_name": "Polynomial.eval\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [44, 17], "def_end_pos": [44, 22]}, {"full_name": "RatFunc.denom", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1178, 5], "def_end_pos": [1178, 10]}]], "state_before": "K : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))", "state_after": "case pos\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : Polynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))\n\ncase neg\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : \u00acPolynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))"}, {"tactic": "rw [div_mul_div_comm, eq_div_iff (mul_ne_zero hx hy), div_eq_mul_inv, mul_right_comm, \u2190\n  div_eq_mul_inv, div_eq_iff hxy]", "annotated_tactic": ["rw [<a>div_mul_div_comm</a>, <a>eq_div_iff</a> (<a>mul_ne_zero</a> hx hy), <a>div_eq_mul_inv</a>, <a>mul_right_comm</a>, \u2190\n    <a>div_eq_mul_inv</a>, <a>div_eq_iff</a> hxy]", [{"full_name": "div_mul_div_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [657, 9], "def_end_pos": [657, 25]}, {"full_name": "eq_div_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [358, 22], "def_end_pos": [358, 32]}, {"full_name": "mul_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [88, 9], "def_end_pos": [88, 20]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "mul_right_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [162, 9], "def_end_pos": [162, 23]}, {"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "div_eq_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [355, 22], "def_end_pos": [355, 32]}]], "state_before": "case neg\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : \u00acPolynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))", "state_after": "case neg\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : \u00acPolynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) * (Polynomial.eval\u2082 f a (denom x) * Polynomial.eval\u2082 f a (denom y)) =\n    Polynomial.eval\u2082 f a (num x) * Polynomial.eval\u2082 f a (num y) * Polynomial.eval\u2082 f a (denom (x * y))"}, {"tactic": "simp only [\u2190 Polynomial.eval\u2082_mul]", "annotated_tactic": ["simp only [\u2190 <a>Polynomial.eval\u2082_mul</a>]", [{"full_name": "Polynomial.eval\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [263, 9], "def_end_pos": [263, 18]}]], "state_before": "case neg\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : \u00acPolynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) * (Polynomial.eval\u2082 f a (denom x) * Polynomial.eval\u2082 f a (denom y)) =\n    Polynomial.eval\u2082 f a (num x) * Polynomial.eval\u2082 f a (num y) * Polynomial.eval\u2082 f a (denom (x * y))", "state_after": "case neg\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : \u00acPolynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y) * (denom x * denom y)) = Polynomial.eval\u2082 f a (num x * num y * denom (x * y))"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "case neg\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : \u00acPolynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y) * (denom x * denom y)) = Polynomial.eval\u2082 f a (num x * num y * denom (x * y))", "state_after": "case neg.e_p\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : \u00acPolynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 num (x * y) * (denom x * denom y) = num x * num y * denom (x * y)"}, {"tactic": "apply num_denom_mul", "annotated_tactic": ["apply <a>num_denom_mul</a>", [{"full_name": "RatFunc.num_denom_mul", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1279, 9], "def_end_pos": [1279, 22]}]], "state_before": "case neg.e_p\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : \u00acPolynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 num (x * y) * (denom x * denom y) = num x * num y * denom (x * y)", "state_after": "no goals"}, {"tactic": "have := Polynomial.eval\u2082_eq_zero_of_dvd_of_eval\u2082_eq_zero f a (denom_mul_dvd x y) hxy", "annotated_tactic": ["have := <a>Polynomial.eval\u2082_eq_zero_of_dvd_of_eval\u2082_eq_zero</a> f a (<a>denom_mul_dvd</a> x y) hxy", [{"full_name": "Polynomial.eval\u2082_eq_zero_of_dvd_of_eval\u2082_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [297, 9], "def_end_pos": [297, 46]}, {"full_name": "RatFunc.denom_mul_dvd", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/RatFunc.lean", "def_pos": [1322, 9], "def_end_pos": [1322, 22]}]], "state_before": "case pos\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : Polynomial.eval\u2082 f a (denom (x * y)) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))", "state_after": "case pos\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : Polynomial.eval\u2082 f a (denom (x * y)) = 0\nthis : Polynomial.eval\u2082 f a (denom x * denom y) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))"}, {"tactic": "rw [Polynomial.eval\u2082_mul] at this", "annotated_tactic": ["rw [<a>Polynomial.eval\u2082_mul</a>] at this", [{"full_name": "Polynomial.eval\u2082_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [263, 9], "def_end_pos": [263, 18]}]], "state_before": "case pos\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : Polynomial.eval\u2082 f a (denom (x * y)) = 0\nthis : Polynomial.eval\u2082 f a (denom x * denom y) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))", "state_after": "case pos\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : Polynomial.eval\u2082 f a (denom (x * y)) = 0\nthis : Polynomial.eval\u2082 f a (denom x) * Polynomial.eval\u2082 f a (denom y) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))"}, {"tactic": "cases mul_eq_zero.mp this <;> contradiction", "annotated_tactic": ["cases mul_eq_zero.mp this <;> contradiction", []], "state_before": "case pos\nK : Type u\ninst\u271d\u00b9 : Field K\nL : Type u_1\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nx y : RatFunc K\nhx : Polynomial.eval\u2082 f a (denom x) \u2260 0\nhy : Polynomial.eval\u2082 f a (denom y) \u2260 0\nhxy : Polynomial.eval\u2082 f a (denom (x * y)) = 0\nthis : Polynomial.eval\u2082 f a (denom x) * Polynomial.eval\u2082 f a (denom y) = 0\n\u22a2 Polynomial.eval\u2082 f a (num (x * y)) / Polynomial.eval\u2082 f a (denom (x * y)) =\n    Polynomial.eval\u2082 f a (num x) / Polynomial.eval\u2082 f a (denom x) *\n      (Polynomial.eval\u2082 f a (num y) / Polynomial.eval\u2082 f a (denom y))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "LinearIndependent.eq_zero_of_pair'", "start": [642, 1], "end": [645, 41], "traced_tactics": [{"tactic": "suffices H : s = 0 \u2227 0 = t from \u27e8H.1, H.2.symm\u27e9", "annotated_tactic": ["suffices H : s = 0 \u2227 0 = t from \u27e8H.1, H.2.<a>symm</a>\u27e9", [{"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y\u271d x y : M\nh : LinearIndependent R ![x, y]\ns t : R\nh' : s \u2022 x = t \u2022 y\n\u22a2 s = 0 \u2227 t = 0", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y\u271d x y : M\nh : LinearIndependent R ![x, y]\ns t : R\nh' : s \u2022 x = t \u2022 y\n\u22a2 s = 0 \u2227 0 = t"}, {"tactic": "exact h.eq_of_pair (by simpa using h')", "annotated_tactic": ["exact h.eq_of_pair (by simpa using h')", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y\u271d x y : M\nh : LinearIndependent R ![x, y]\ns t : R\nh' : s \u2022 x = t \u2022 y\n\u22a2 s = 0 \u2227 0 = t", "state_after": "no goals"}, {"tactic": "simpa using h'", "annotated_tactic": ["simpa using h'", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup M'\ninst\u271d\u00b3 : AddCommGroup M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y\u271d x y : M\nh : LinearIndependent R ![x, y]\ns t : R\nh' : s \u2022 x = t \u2022 y\n\u22a2 s \u2022 x + 0 \u2022 y = 0 \u2022 x + t \u2022 y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Adjoin/Basic.lean", "full_name": "Algebra.adjoin_algebraMap", "start": [297, 1], "end": [299, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Localization/Basic.lean", "full_name": "IsLocalization.mk'_add", "start": [470, 1], "end": [479, 14], "traced_tactics": [{"tactic": "rw [mul_comm (_ + _), mul_add, mul_mk'_eq_mk'_of_mul, mk'_add_eq_iff_add_mul_eq_mul,\n  mul_comm (_ * _), \u2190 mul_assoc, add_comm, \u2190 map_mul, mul_mk'_eq_mk'_of_mul,\n  mk'_add_eq_iff_add_mul_eq_mul]", "annotated_tactic": ["rw [<a>mul_comm</a> (_ + _), <a>mul_add</a>, <a>mul_mk'_eq_mk'_of_mul</a>, <a>mk'_add_eq_iff_add_mul_eq_mul</a>,\n          <a>mul_comm</a> (_ * _), \u2190 <a>mul_assoc</a>, <a>add_comm</a>, \u2190 <a>map_mul</a>, <a>mul_mk'_eq_mk'_of_mul</a>,\n          <a>mk'_add_eq_iff_add_mul_eq_mul</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "IsLocalization.mul_mk'_eq_mk'_of_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [409, 9], "def_end_pos": [409, 30]}, {"full_name": "IsLocalization.mk'_add_eq_iff_add_mul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [297, 9], "def_end_pos": [297, 38]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}, {"full_name": "map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [308, 9], "def_end_pos": [308, 16]}, {"full_name": "IsLocalization.mul_mk'_eq_mk'_of_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [409, 9], "def_end_pos": [409, 30]}, {"full_name": "IsLocalization.mk'_add_eq_iff_add_mul_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [297, 9], "def_end_pos": [297, 38]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nx\u2081 x\u2082 : R\ny\u2081 y\u2082 : \u21a5M\n\u22a2 (mk' S x\u2081 y\u2081 + mk' S x\u2082 y\u2082) * (algebraMap R S) \u2191(y\u2081 * y\u2082) = (algebraMap R S) (x\u2081 * \u2191y\u2082 + x\u2082 * \u2191y\u2081)", "state_after": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nx\u2081 x\u2082 : R\ny\u2081 y\u2082 : \u21a5M\n\u22a2 (algebraMap R S) (\u2191y\u2081 * \u2191(y\u2081 * y\u2082) * x\u2082) + (algebraMap R S) (\u2191(y\u2081 * y\u2082) * x\u2081) * (algebraMap R S) \u2191y\u2082 =\n    (algebraMap R S) (x\u2081 * \u2191y\u2082 + x\u2082 * \u2191y\u2081) * (algebraMap R S) \u2191y\u2081 * (algebraMap R S) \u2191y\u2082"}, {"tactic": "simp only [map_add, Submonoid.coe_mul, map_mul]", "annotated_tactic": ["simp only [<a>map_add</a>, <a>Submonoid.coe_mul</a>, <a>map_mul</a>]", [{"full_name": "map_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [307, 3], "def_end_pos": [307, 14]}, {"full_name": "Submonoid.coe_mul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [635, 9], "def_end_pos": [635, 16]}, {"full_name": "map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [308, 9], "def_end_pos": [308, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nx\u2081 x\u2082 : R\ny\u2081 y\u2082 : \u21a5M\n\u22a2 (algebraMap R S) (\u2191y\u2081 * \u2191(y\u2081 * y\u2082) * x\u2082) + (algebraMap R S) (\u2191(y\u2081 * y\u2082) * x\u2081) * (algebraMap R S) \u2191y\u2082 =\n    (algebraMap R S) (x\u2081 * \u2191y\u2082 + x\u2082 * \u2191y\u2081) * (algebraMap R S) \u2191y\u2081 * (algebraMap R S) \u2191y\u2082", "state_after": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nx\u2081 x\u2082 : R\ny\u2081 y\u2082 : \u21a5M\n\u22a2 (algebraMap R S) \u2191y\u2081 * ((algebraMap R S) \u2191y\u2081 * (algebraMap R S) \u2191y\u2082) * (algebraMap R S) x\u2082 +\n      (algebraMap R S) \u2191y\u2081 * (algebraMap R S) \u2191y\u2082 * (algebraMap R S) x\u2081 * (algebraMap R S) \u2191y\u2082 =\n    ((algebraMap R S) x\u2081 * (algebraMap R S) \u2191y\u2082 + (algebraMap R S) x\u2082 * (algebraMap R S) \u2191y\u2081) * (algebraMap R S) \u2191y\u2081 *\n      (algebraMap R S) \u2191y\u2082"}, {"tactic": "ring", "annotated_tactic": ["ring", []], "state_before": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b3 : CommSemiring S\ninst\u271d\u00b2 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9 : CommSemiring P\ninst\u271d : IsLocalization M S\nx\u2081 x\u2082 : R\ny\u2081 y\u2082 : \u21a5M\n\u22a2 (algebraMap R S) \u2191y\u2081 * ((algebraMap R S) \u2191y\u2081 * (algebraMap R S) \u2191y\u2082) * (algebraMap R S) x\u2082 +\n      (algebraMap R S) \u2191y\u2081 * (algebraMap R S) \u2191y\u2082 * (algebraMap R S) x\u2081 * (algebraMap R S) \u2191y\u2082 =\n    ((algebraMap R S) x\u2081 * (algebraMap R S) \u2191y\u2082 + (algebraMap R S) x\u2082 * (algebraMap R S) \u2191y\u2081) * (algebraMap R S) \u2191y\u2081 *\n      (algebraMap R S) \u2191y\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometryEquiv.coe_prodAssoc", "start": [1158, 1], "end": [1160, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ZMod/Basic.lean", "full_name": "ZMod.inv_eq_of_mul_eq_one", "start": [825, 11], "end": [826, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/ZModChar.lean", "full_name": "ZMod.\u03c7\u2088_nat_eq_if_mod_eight", "start": [169, 1], "end": [171, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Sublists.lean", "full_name": "List.sublists_cons_perm_append", "start": [427, 1], "end": [431, 99], "traced_tactics": [{"tactic": "rw [sublists'_cons]", "annotated_tactic": ["rw [<a>sublists'_cons</a>]", [{"full_name": "List.sublists'_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sublists.lean", "def_pos": [76, 9], "def_end_pos": [76, 23]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\nl : List \u03b1\n\u22a2 sublists' (a :: l) ~ sublists l ++ map (cons a) (sublists l)", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\nl : List \u03b1\n\u22a2 sublists' l ++ map (cons a) (sublists' l) ~ sublists l ++ map (cons a) (sublists l)"}, {"tactic": "exact Perm.append (sublists_perm_sublists' _).symm (Perm.map _ (sublists_perm_sublists' _).symm)", "annotated_tactic": ["exact <a>Perm.append</a> (<a>sublists_perm_sublists'</a> _).<a>symm</a> (<a>Perm.map</a> _ (<a>sublists_perm_sublists'</a> _).<a>symm</a>)", [{"full_name": "List.Perm.append", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [89, 9], "def_end_pos": [89, 20]}, {"full_name": "List.sublists_perm_sublists'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sublists.lean", "def_pos": [418, 9], "def_end_pos": [418, 32]}, {"full_name": "List.Perm.symm", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [37, 19], "def_end_pos": [37, 28]}, {"full_name": "List.Perm.map", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}, {"full_name": "List.sublists_perm_sublists'", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Sublists.lean", "def_pos": [418, 9], "def_end_pos": [418, 32]}, {"full_name": "List.Perm.symm", "def_path": ".lake/packages/std/Std/Data/List/Perm.lean", "def_pos": [37, 19], "def_end_pos": [37, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\nl : List \u03b1\n\u22a2 sublists' l ++ map (cons a) (sublists' l) ~ sublists l ++ map (cons a) (sublists l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Pi/Basic.lean", "full_name": "CategoryTheory.Functor.eqToHom_proj", "start": [226, 1], "end": [229, 6], "traced_tactics": [{"tactic": "subst h", "annotated_tactic": ["subst h", []], "state_before": "I : Type w\u2080\nJ : Type w\u2081\nC : I \u2192 Type u\u2081\ninst\u271d\u00b2 : (i : I) \u2192 Category.{v\u2081, u\u2081} (C i)\nD : I \u2192 Type u\u2082\ninst\u271d\u00b9 : (i : I) \u2192 Category.{v\u2082, u\u2082} (D i)\nA : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} A\nx x' : (i : I) \u2192 C i\nh : x = x'\ni : I\n\u22a2 eqToHom h i = eqToHom \u22ef", "state_after": "I : Type w\u2080\nJ : Type w\u2081\nC : I \u2192 Type u\u2081\ninst\u271d\u00b2 : (i : I) \u2192 Category.{v\u2081, u\u2081} (C i)\nD : I \u2192 Type u\u2082\ninst\u271d\u00b9 : (i : I) \u2192 Category.{v\u2082, u\u2082} (D i)\nA : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} A\nx : (i : I) \u2192 C i\ni : I\n\u22a2 eqToHom \u22ef i = eqToHom \u22ef"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "I : Type w\u2080\nJ : Type w\u2081\nC : I \u2192 Type u\u2081\ninst\u271d\u00b2 : (i : I) \u2192 Category.{v\u2081, u\u2081} (C i)\nD : I \u2192 Type u\u2082\ninst\u271d\u00b9 : (i : I) \u2192 Category.{v\u2082, u\u2082} (D i)\nA : Type u\u2083\ninst\u271d : Category.{v\u2083, u\u2083} A\nx : (i : I) \u2192 C i\ni : I\n\u22a2 eqToHom \u22ef i = eqToHom \u22ef", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.map_op_pow", "start": [574, 1], "end": [577, 72], "traced_tactics": [{"tactic": "rw [map_equiv_eq_comap_symm, map_equiv_eq_comap_symm, comap_unop_pow]", "annotated_tactic": ["rw [<a>map_equiv_eq_comap_symm</a>, <a>map_equiv_eq_comap_symm</a>, <a>comap_unop_pow</a>]", [{"full_name": "Submodule.map_equiv_eq_comap_symm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [551, 9], "def_end_pos": [551, 32]}, {"full_name": "Submodule.map_equiv_eq_comap_symm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [551, 9], "def_end_pos": [551, 32]}, {"full_name": "Submodule.comap_unop_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Operations.lean", "def_pos": [562, 9], "def_end_pos": [562, 23]}]], "state_before": "\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n\u271d : A\nn : \u2115\n\u22a2 map (\u2191(opLinearEquiv R)) (M ^ n) = map (\u2191(opLinearEquiv R)) M ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Block.lean", "full_name": "Matrix.det_toBlock", "start": [186, 1], "end": [197, 50], "traced_tactics": [{"tactic": "rw [\u2190 Matrix.det_reindex_self (Equiv.sumCompl p).symm M]", "annotated_tactic": ["rw [\u2190 <a>Matrix.det_reindex_self</a> (<a>Equiv.sumCompl</a> p).<a>symm</a> M]", [{"full_name": "Matrix.det_reindex_self", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [264, 9], "def_end_pos": [264, 25]}, {"full_name": "Equiv.sumCompl", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [574, 5], "def_end_pos": [574, 13]}, {"full_name": "Equiv.symm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [166, 15], "def_end_pos": [166, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 det M =\n    det\n      (fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n        (toBlock M (fun j => \u00acp j) fun j => \u00acp j))", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 det ((reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M) =\n    det\n      (fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n        (toBlock M (fun j => \u00acp j) fun j => \u00acp j))"}, {"tactic": "rw [det_apply', det_apply']", "annotated_tactic": ["rw [<a>det_apply'</a>, <a>det_apply'</a>]", [{"full_name": "Matrix.det_apply'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [74, 9], "def_end_pos": [74, 19]}, {"full_name": "Matrix.det_apply'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [74, 9], "def_end_pos": [74, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 det ((reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M) =\n    det\n      (fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n        (toBlock M (fun j => \u00acp j) fun j => \u00acp j))", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 \u2211 \u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a }),\n      \u2191\u2191(Equiv.Perm.sign \u03c3) *\n        \u220f i : { a // p a } \u2295 { a // \u00acp a }, (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 i) i =\n    \u2211 \u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a }),\n      \u2191\u2191(Equiv.Perm.sign \u03c3) *\n        \u220f i : { a // p a } \u2295 { a // \u00acp a },\n          fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n            (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 i) i"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 \u2211 \u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a }),\n      \u2191\u2191(Equiv.Perm.sign \u03c3) *\n        \u220f i : { a // p a } \u2295 { a // \u00acp a }, (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 i) i =\n    \u2211 \u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a }),\n      \u2191\u2191(Equiv.Perm.sign \u03c3) *\n        \u220f i : { a // p a } \u2295 { a // \u00acp a },\n          fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n            (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 i) i", "state_after": "case e_f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 (fun \u03c3 =>\n      \u2191\u2191(Equiv.Perm.sign \u03c3) *\n        \u220f i : { a // p a } \u2295 { a // \u00acp a }, (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 i) i) =\n    fun \u03c3 =>\n    \u2191\u2191(Equiv.Perm.sign \u03c3) *\n      \u220f i : { a // p a } \u2295 { a // \u00acp a },\n        fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n          (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 i) i"}, {"tactic": "ext \u03c3", "annotated_tactic": ["ext \u03c3", []], "state_before": "case e_f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 (fun \u03c3 =>\n      \u2191\u2191(Equiv.Perm.sign \u03c3) *\n        \u220f i : { a // p a } \u2295 { a // \u00acp a }, (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 i) i) =\n    fun \u03c3 =>\n    \u2191\u2191(Equiv.Perm.sign \u03c3) *\n      \u220f i : { a // p a } \u2295 { a // \u00acp a },\n        fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n          (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 i) i", "state_after": "case e_f.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a })\n\u22a2 \u2191\u2191(Equiv.Perm.sign \u03c3) *\n      \u220f i : { a // p a } \u2295 { a // \u00acp a }, (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 i) i =\n    \u2191\u2191(Equiv.Perm.sign \u03c3) *\n      \u220f i : { a // p a } \u2295 { a // \u00acp a },\n        fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n          (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 i) i"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case e_f.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a })\n\u22a2 \u2191\u2191(Equiv.Perm.sign \u03c3) *\n      \u220f i : { a // p a } \u2295 { a // \u00acp a }, (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 i) i =\n    \u2191\u2191(Equiv.Perm.sign \u03c3) *\n      \u220f i : { a // p a } \u2295 { a // \u00acp a },\n        fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n          (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 i) i", "state_after": "case e_f.h.e_a.e_f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a })\n\u22a2 (fun i => (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 i) i) = fun i =>\n    fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n      (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 i) i"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "case e_f.h.e_a.e_f\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a })\n\u22a2 (fun i => (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 i) i) = fun i =>\n    fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n      (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 i) i", "state_after": "case e_f.h.e_a.e_f.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a })\nx : { a // p a } \u2295 { a // \u00acp a }\n\u22a2 (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 x) x =\n    fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n      (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 x) x"}, {"tactic": "generalize hy : \u03c3 x = y", "annotated_tactic": ["generalize hy : \u03c3 x = y", []], "state_before": "case e_f.h.e_a.e_f.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a })\nx : { a // p a } \u2295 { a // \u00acp a }\n\u22a2 (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M (\u03c3 x) x =\n    fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n      (toBlock M (fun j => \u00acp j) fun j => \u00acp j) (\u03c3 x) x", "state_after": "case e_f.h.e_a.e_f.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a })\nx y : { a // p a } \u2295 { a // \u00acp a }\nhy : \u03c3 x = y\n\u22a2 (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M y x =\n    fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n      (toBlock M (fun j => \u00acp j) fun j => \u00acp j) y x"}, {"tactic": "cases x <;> cases y <;>\n  simp only [Matrix.reindex_apply, toBlock_apply, Equiv.symm_symm, Equiv.sumCompl_apply_inr,\n    Equiv.sumCompl_apply_inl, fromBlocks_apply\u2081\u2081, fromBlocks_apply\u2081\u2082, fromBlocks_apply\u2082\u2081,\n    fromBlocks_apply\u2082\u2082, Matrix.submatrix_apply]", "annotated_tactic": ["cases x <;> cases y <;>\n    simp only [<a>Matrix.reindex_apply</a>, <a>toBlock_apply</a>, <a>Equiv.symm_symm</a>, <a>Equiv.sumCompl_apply_inr</a>,\n      <a>Equiv.sumCompl_apply_inl</a>, <a>fromBlocks_apply\u2081\u2081</a>, <a>fromBlocks_apply\u2081\u2082</a>, <a>fromBlocks_apply\u2082\u2081</a>,\n      <a>fromBlocks_apply\u2082\u2082</a>, <a>Matrix.submatrix_apply</a>]", [{"full_name": "Matrix.reindex_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [2628, 9], "def_end_pos": [2628, 22]}, {"full_name": "Matrix.toBlock_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Block.lean", "def_pos": [192, 9], "def_end_pos": [192, 22]}, {"full_name": "Equiv.symm_symm", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [354, 17], "def_end_pos": [354, 26]}, {"full_name": "Equiv.sumCompl_apply_inr", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [594, 9], "def_end_pos": [594, 27]}, {"full_name": "Equiv.sumCompl_apply_inl", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [588, 9], "def_end_pos": [588, 27]}, {"full_name": "Matrix.fromBlocks_apply\u2081\u2081", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Block.lean", "def_pos": [50, 9], "def_end_pos": [50, 27]}, {"full_name": "Matrix.fromBlocks_apply\u2081\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Block.lean", "def_pos": [56, 9], "def_end_pos": [56, 27]}, {"full_name": "Matrix.fromBlocks_apply\u2082\u2081", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Block.lean", "def_pos": [62, 9], "def_end_pos": [62, 27]}, {"full_name": "Matrix.fromBlocks_apply\u2082\u2082", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Block.lean", "def_pos": [68, 9], "def_end_pos": [68, 27]}, {"full_name": "Matrix.submatrix_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [2459, 9], "def_end_pos": [2459, 24]}]], "state_before": "case e_f.h.e_a.e_f.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\no : Type u_5\nm' : \u03b1 \u2192 Type u_6\nn' : \u03b1 \u2192 Type u_7\nR : Type v\ninst\u271d\u2075 : CommRing R\nM\u271d N : Matrix m m R\nb : m \u2192 \u03b1\ninst\u271d\u2074 : DecidableEq m\ninst\u271d\u00b3 : Fintype m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Fintype n\nM : Matrix m m R\np : m \u2192 Prop\ninst\u271d : DecidablePred p\n\u03c3 : Equiv.Perm ({ a // p a } \u2295 { a // \u00acp a })\nx y : { a // p a } \u2295 { a // \u00acp a }\nhy : \u03c3 x = y\n\u22a2 (reindex (Equiv.sumCompl p).symm (Equiv.sumCompl p).symm) M y x =\n    fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p)\n      (toBlock M (fun j => \u00acp j) fun j => \u00acp j) y x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.compl_inter", "start": [1667, 1], "end": [1668, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompactlyGenerated/Intervals.lean", "full_name": "Set.Iic.isCompactElement", "start": [18, 1], "end": [24, 47], "traced_tactics": [{"tactic": "simp only [CompleteLattice.isCompactElement_iff, Finset.sup_eq_iSup] at h \u22a2", "annotated_tactic": ["simp only [<a>CompleteLattice.isCompactElement_iff</a>, <a>Finset.sup_eq_iSup</a>] at h \u22a2", [{"full_name": "CompleteLattice.isCompactElement_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompactlyGenerated/Basic.lean", "def_pos": [83, 9], "def_end_pos": [83, 29]}, {"full_name": "Finset.sup_eq_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [286, 9], "def_end_pos": [286, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : CompleteLattice.IsCompactElement \u2191b\n\u22a2 CompleteLattice.IsCompactElement b", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u03b1), \u2191b \u2264 iSup s \u2192 \u2203 t, \u2191b \u2264 \u2a06 a \u2208 t, s a\n\u22a2 \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u2191(Iic a)), b \u2264 iSup s \u2192 \u2203 t, b \u2264 \u2a06 a_2 \u2208 t, s a_2"}, {"tactic": "intro \u03b9 s hb", "annotated_tactic": ["intro \u03b9 s hb", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u03b1), \u2191b \u2264 iSup s \u2192 \u2203 t, \u2191b \u2264 \u2a06 a \u2208 t, s a\n\u22a2 \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u2191(Iic a)), b \u2264 iSup s \u2192 \u2203 t, b \u2264 \u2a06 a_2 \u2208 t, s a_2", "state_after": "\u03b9\u271d : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u03b1), \u2191b \u2264 iSup s \u2192 \u2203 t, \u2191b \u2264 \u2a06 a \u2208 t, s a\n\u03b9 : Type u_2\ns : \u03b9 \u2192 \u2191(Iic a)\nhb : b \u2264 iSup s\n\u22a2 \u2203 t, b \u2264 \u2a06 a_1 \u2208 t, s a_1"}, {"tactic": "replace hb : (b : \u03b1) \u2264 iSup ((\u2191) \u2218 s) := le_trans hb <| (coe_iSup s) \u25b8 le_refl _", "annotated_tactic": ["replace hb : (b : \u03b1) \u2264 <a>iSup</a> ((\u2191) \u2218 s) := <a>le_trans</a> hb <| (<a>coe_iSup</a> s) \u25b8 <a>le_refl</a> _", [{"full_name": "iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [64, 5], "def_end_pos": [64, 9]}, {"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "Set.Iic.coe_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLatticeIntervals.lean", "def_pos": [263, 17], "def_end_pos": [263, 25]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "\u03b9\u271d : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u03b1), \u2191b \u2264 iSup s \u2192 \u2203 t, \u2191b \u2264 \u2a06 a \u2208 t, s a\n\u03b9 : Type u_2\ns : \u03b9 \u2192 \u2191(Iic a)\nhb : b \u2264 iSup s\n\u22a2 \u2203 t, b \u2264 \u2a06 a_1 \u2208 t, s a_1", "state_after": "\u03b9\u271d : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u03b1), \u2191b \u2264 iSup s \u2192 \u2203 t, \u2191b \u2264 \u2a06 a \u2208 t, s a\n\u03b9 : Type u_2\ns : \u03b9 \u2192 \u2191(Iic a)\nhb : \u2191b \u2264 iSup (Subtype.val \u2218 s)\n\u22a2 \u2203 t, b \u2264 \u2a06 a_1 \u2208 t, s a_1"}, {"tactic": "obtain \u27e8t, ht\u27e9 := h \u03b9 ((\u2191) \u2218 s) hb", "annotated_tactic": ["obtain \u27e8t, ht\u27e9 := h \u03b9 ((\u2191) \u2218 s) hb", []], "state_before": "\u03b9\u271d : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u03b1), \u2191b \u2264 iSup s \u2192 \u2203 t, \u2191b \u2264 \u2a06 a \u2208 t, s a\n\u03b9 : Type u_2\ns : \u03b9 \u2192 \u2191(Iic a)\nhb : \u2191b \u2264 iSup (Subtype.val \u2218 s)\n\u22a2 \u2203 t, b \u2264 \u2a06 a_1 \u2208 t, s a_1", "state_after": "case intro\n\u03b9\u271d : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u03b1), \u2191b \u2264 iSup s \u2192 \u2203 t, \u2191b \u2264 \u2a06 a \u2208 t, s a\n\u03b9 : Type u_2\ns : \u03b9 \u2192 \u2191(Iic a)\nhb : \u2191b \u2264 iSup (Subtype.val \u2218 s)\nt : Finset \u03b9\nht : \u2191b \u2264 \u2a06 a_1 \u2208 t, (Subtype.val \u2218 s) a_1\n\u22a2 \u2203 t, b \u2264 \u2a06 a_1 \u2208 t, s a_1"}, {"tactic": "exact \u27e8t, (by simpa using ht : (b : \u03b1) \u2264 _)\u27e9", "annotated_tactic": ["exact \u27e8t, (by simpa using ht : (b : \u03b1) \u2264 _)\u27e9", []], "state_before": "case intro\n\u03b9\u271d : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u03b1), \u2191b \u2264 iSup s \u2192 \u2203 t, \u2191b \u2264 \u2a06 a \u2208 t, s a\n\u03b9 : Type u_2\ns : \u03b9 \u2192 \u2191(Iic a)\nhb : \u2191b \u2264 iSup (Subtype.val \u2218 s)\nt : Finset \u03b9\nht : \u2191b \u2264 \u2a06 a_1 \u2208 t, (Subtype.val \u2218 s) a_1\n\u22a2 \u2203 t, b \u2264 \u2a06 a_1 \u2208 t, s a_1", "state_after": "no goals"}, {"tactic": "simpa using ht", "annotated_tactic": ["simpa using ht", []], "state_before": "\u03b9\u271d : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CompleteLattice \u03b1\na : \u03b1\nb : \u2191(Iic a)\nh : \u2200 (\u03b9 : Type u_2) (s : \u03b9 \u2192 \u03b1), \u2191b \u2264 iSup s \u2192 \u2203 t, \u2191b \u2264 \u2a06 a \u2208 t, s a\n\u03b9 : Type u_2\ns : \u03b9 \u2192 \u2191(Iic a)\nhb : \u2191b \u2264 iSup (Subtype.val \u2218 s)\nt : Finset \u03b9\nht : \u2191b \u2264 \u2a06 a_1 \u2208 t, (Subtype.val \u2218 s) a_1\n\u22a2 \u2191b \u2264 (fun a_1 => \u2191a_1) (\u2a06 a_1 \u2208 t, s a_1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.symmDiff_subset_union", "start": [2097, 1], "end": [2098, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "full_name": "star_isometry", "start": [67, 1], "end": [69, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/CompactOpen.lean", "full_name": "ContinuousMap.curry_apply", "start": [338, 1], "end": [339, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Centralizer.lean", "full_name": "Submonoid.coe_centralizer", "start": [41, 1], "end": [42, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Principal.lean", "full_name": "Ordinal.unbounded_principal", "start": [108, 1], "end": [110, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENat/Basic.lean", "full_name": "ENat.one_le_iff_ne_zero", "start": [244, 1], "end": [245, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Prod.lean", "full_name": "NonUnitalRingHom.prodMap_def", "start": [173, 1], "end": [174, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.eq_none_iff", "start": [178, 1], "end": [179, 60], "traced_tactics": [{"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\no : Part \u03b1\nh : \u2200 (a : \u03b1), a \u2209 o\n\u22a2 \u2200 (a : \u03b1), a \u2208 o \u2194 a \u2208 none", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean", "full_name": "UniformOnFun.toFun_ofFun", "start": [192, 1], "end": [192, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.div_wf_lemma", "start": [91, 1], "end": [102, 84], "traced_tactics": [{"tactic": "rw [\u2190 degree_eq_natDegree h.2, \u2190 degree_eq_natDegree hq0]", "annotated_tactic": ["rw [\u2190 <a>degree_eq_natDegree</a> h.2, \u2190 <a>degree_eq_natDegree</a> hq0]", [{"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\nh : degree q \u2264 degree p \u2227 p \u2260 0\nhq : Monic q\nhp : leadingCoeff p \u2260 0\nhq0 : q \u2260 0\n\u22a2 \u2191(natDegree q) \u2264 \u2191(natDegree p)", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\nh : degree q \u2264 degree p \u2227 p \u2260 0\nhq : Monic q\nhp : leadingCoeff p \u2260 0\nhq0 : q \u2260 0\n\u22a2 degree q \u2264 degree p\n\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\n\u22a2 degree q \u2264 degree p \u2227 p \u2260 0 \u2192 Monic q \u2192 leadingCoeff p \u2260 0 \u2192 q \u2260 0 \u2192 PartialOrder (WithBot \u2115)\n\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\n\u22a2 degree q \u2264 degree p \u2227 p \u2260 0 \u2192 Monic q \u2192 leadingCoeff p \u2260 0 \u2192 q \u2260 0 \u2192 PartialOrder (WithBot \u2115)"}, {"tactic": "exact h.1", "annotated_tactic": ["exact h.1", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\nh : degree q \u2264 degree p \u2227 p \u2260 0\nhq : Monic q\nhp : leadingCoeff p \u2260 0\nhq0 : q \u2260 0\n\u22a2 degree q \u2264 degree p\n\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\n\u22a2 degree q \u2264 degree p \u2227 p \u2260 0 \u2192 Monic q \u2192 leadingCoeff p \u2260 0 \u2192 q \u2260 0 \u2192 PartialOrder (WithBot \u2115)\n\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\n\u22a2 degree q \u2264 degree p \u2227 p \u2260 0 \u2192 Monic q \u2192 leadingCoeff p \u2260 0 \u2192 q \u2260 0 \u2192 PartialOrder (WithBot \u2115)", "state_after": "no goals"}, {"tactic": "rw [hq.degree_mul_comm, hq.degree_mul, degree_C_mul_X_pow _ hp, degree_eq_natDegree h.2,\n  degree_eq_natDegree hq0, \u2190 Nat.cast_add, tsub_add_cancel_of_le hlt]", "annotated_tactic": ["rw [hq.degree_mul_comm, hq.degree_mul, <a>degree_C_mul_X_pow</a> _ hp, <a>degree_eq_natDegree</a> h.2,\n        <a>degree_eq_natDegree</a> hq0, \u2190 <a>Nat.cast_add</a>, <a>tsub_add_cancel_of_le</a> hlt]", [{"full_name": "Polynomial.degree_C_mul_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [293, 9], "def_end_pos": [293, 27]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}, {"full_name": "Nat.cast_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [155, 9], "def_end_pos": [155, 17]}, {"full_name": "tsub_add_cancel_of_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [30, 9], "def_end_pos": [30, 30]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\nh : degree q \u2264 degree p \u2227 p \u2260 0\nhq : Monic q\nhp : leadingCoeff p \u2260 0\nhq0 : q \u2260 0\nhlt : natDegree q \u2264 natDegree p\n\u22a2 degree p = degree (q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)))", "state_after": "no goals"}, {"tactic": "rw [leadingCoeff_monic_mul hq, leadingCoeff_mul_X_pow, leadingCoeff_C]", "annotated_tactic": ["rw [<a>leadingCoeff_monic_mul</a> hq, <a>leadingCoeff_mul_X_pow</a>, <a>leadingCoeff_C</a>]", [{"full_name": "Polynomial.leadingCoeff_monic_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1057, 9], "def_end_pos": [1057, 31]}, {"full_name": "Polynomial.leadingCoeff_mul_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1077, 9], "def_end_pos": [1077, 31]}, {"full_name": "Polynomial.leadingCoeff_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [865, 9], "def_end_pos": [865, 23]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np q : R[X]\nh : degree q \u2264 degree p \u2227 p \u2260 0\nhq : Monic q\nhp : leadingCoeff p \u2260 0\nhq0 : q \u2260 0\nhlt : natDegree q \u2264 natDegree p\n\u22a2 leadingCoeff p = leadingCoeff (q * (C (leadingCoeff p) * X ^ (natDegree p - natDegree q)))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Units.lean", "full_name": "Int.units_eq_one_or", "start": [30, 1], "end": [31, 61], "traced_tactics": [{"tactic": "simpa only [Units.ext_iff, units_natAbs] using natAbs_eq u", "annotated_tactic": ["simpa only [<a>Units.ext_iff</a>, <a>units_natAbs</a>] using <a>natAbs_eq</a> u", [{"full_name": "Units.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [157, 9], "def_end_pos": [157, 16]}, {"full_name": "Int.units_natAbs", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Units.lean", "def_pos": [23, 9], "def_end_pos": [23, 21]}, {"full_name": "Int.natAbs_eq", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean", "def_pos": [424, 9], "def_end_pos": [424, 18]}]], "state_before": "u : \u2124\u02e3\n\u22a2 u = 1 \u2228 u = -1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Matrix/Block.lean", "full_name": "Matrix.blockDiagonal_mul", "start": [473, 1], "end": [478, 32], "traced_tactics": [{"tactic": "ext \u27e8i, k\u27e9 \u27e8j, k'\u27e9", "annotated_tactic": ["ext \u27e8i, k\u27e9 \u27e8j, k'\u27e9", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\np' : o \u2192 Type u_9\nR : Type u_10\nS : Type u_11\n\u03b1 : Type u_12\n\u03b2 : Type u_13\ninst\u271d\u00b3 : DecidableEq o\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype o\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nM : o \u2192 Matrix m n \u03b1\nN : o \u2192 Matrix n p \u03b1\n\u22a2 (blockDiagonal fun k => M k * N k) = blockDiagonal M * blockDiagonal N", "state_after": "case a.mk.h.mk\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\np' : o \u2192 Type u_9\nR : Type u_10\nS : Type u_11\n\u03b1 : Type u_12\n\u03b2 : Type u_13\ninst\u271d\u00b3 : DecidableEq o\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype o\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nM : o \u2192 Matrix m n \u03b1\nN : o \u2192 Matrix n p \u03b1\ni : m\nk : o\nj : p\nk' : o\n\u22a2 blockDiagonal (fun k => M k * N k) (i, k) (j, k') = (blockDiagonal M * blockDiagonal N) (i, k) (j, k')"}, {"tactic": "simp only [blockDiagonal_apply, mul_apply, \u2190 Finset.univ_product_univ, Finset.sum_product]", "annotated_tactic": ["simp only [<a>blockDiagonal_apply</a>, <a>mul_apply</a>, \u2190 <a>Finset.univ_product_univ</a>, <a>Finset.sum_product</a>]", [{"full_name": "Matrix.blockDiagonal_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Block.lean", "def_pos": [372, 9], "def_end_pos": [372, 28]}, {"full_name": "Matrix.mul_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [968, 9], "def_end_pos": [968, 18]}, {"full_name": "Finset.univ_product_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Prod.lean", "def_pos": [50, 15], "def_end_pos": [50, 32]}, {"full_name": "Finset.sum_product", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [835, 3], "def_end_pos": [835, 14]}]], "state_before": "case a.mk.h.mk\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\np' : o \u2192 Type u_9\nR : Type u_10\nS : Type u_11\n\u03b1 : Type u_12\n\u03b2 : Type u_13\ninst\u271d\u00b3 : DecidableEq o\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype o\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nM : o \u2192 Matrix m n \u03b1\nN : o \u2192 Matrix n p \u03b1\ni : m\nk : o\nj : p\nk' : o\n\u22a2 blockDiagonal (fun k => M k * N k) (i, k) (j, k') = (blockDiagonal M * blockDiagonal N) (i, k) (j, k')", "state_after": "case a.mk.h.mk\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\np' : o \u2192 Type u_9\nR : Type u_10\nS : Type u_11\n\u03b1 : Type u_12\n\u03b2 : Type u_13\ninst\u271d\u00b3 : DecidableEq o\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype o\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nM : o \u2192 Matrix m n \u03b1\nN : o \u2192 Matrix n p \u03b1\ni : m\nk : o\nj : p\nk' : o\n\u22a2 (if k = k' then \u2211 j_1 : n, M k i j_1 * N k j_1 j else 0) =\n    \u2211 x : n, \u2211 x_1 : o, (if k = x_1 then M k i x else 0) * if x_1 = k' then N x_1 x j else 0"}, {"tactic": "split_ifs with h <;> simp [h]", "annotated_tactic": ["split_ifs with h <;> simp [h]", []], "state_before": "case a.mk.h.mk\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\np' : o \u2192 Type u_9\nR : Type u_10\nS : Type u_11\n\u03b1 : Type u_12\n\u03b2 : Type u_13\ninst\u271d\u00b3 : DecidableEq o\ninst\u271d\u00b2 : Fintype n\ninst\u271d\u00b9 : Fintype o\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\nM : o \u2192 Matrix m n \u03b1\nN : o \u2192 Matrix n p \u03b1\ni : m\nk : o\nj : p\nk' : o\n\u22a2 (if k = k' then \u2211 j_1 : n, M k i j_1 * N k j_1 j else 0) =\n    \u2211 x : n, \u2211 x_1 : o, (if k = x_1 then M k i x else 0) * if x_1 = k' then N x_1 x j else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "full_name": "AffineMap.lineMap_vsub", "start": [631, 1], "end": [633, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean", "full_name": "Nat.lt_factorial_self", "start": [148, 1], "end": [154, 54], "traced_tactics": [{"tactic": "have : 0 < n := (zero_lt_two (\u03b1 := \u2115)).trans (succ_le_iff.mp hi)", "annotated_tactic": ["have : 0 < n := (<a>zero_lt_two</a> (\u03b1 := \u2115)).<a>trans</a> (succ_le_iff.mp hi)", [{"full_name": "zero_lt_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [71, 15], "def_end_pos": [71, 26]}, {"full_name": "LT.lt.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [141, 7], "def_end_pos": [141, 18]}]], "state_before": "m n\u271d n : \u2115\nhi : 3 \u2264 n\n\u22a2 n < n !", "state_after": "m n\u271d n : \u2115\nhi : 3 \u2264 n\nthis : 0 < n\n\u22a2 n < n !"}, {"tactic": "have : 1 < pred n := le_pred_of_lt (succ_le_iff.mp hi)", "annotated_tactic": ["have : 1 < <a>pred</a> n := <a>le_pred_of_lt</a> (succ_le_iff.mp hi)", [{"full_name": "Nat.pred", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1685, 5], "def_end_pos": [1685, 13]}, {"full_name": "Nat.le_pred_of_lt", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [142, 9], "def_end_pos": [142, 22]}]], "state_before": "m n\u271d n : \u2115\nhi : 3 \u2264 n\nthis : 0 < n\n\u22a2 n < n !", "state_after": "m n\u271d n : \u2115\nhi : 3 \u2264 n\nthis\u271d : 0 < n\nthis : 1 < pred n\n\u22a2 n < n !"}, {"tactic": "rw [\u2190 succ_pred_eq_of_pos \u20390 < n\u203a, factorial_succ]", "annotated_tactic": ["rw [\u2190 <a>succ_pred_eq_of_pos</a> \u20390 < n\u203a, <a>factorial_succ</a>]", [{"full_name": "Nat.succ_pred_eq_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [573, 9], "def_end_pos": [573, 28]}, {"full_name": "Nat.factorial_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [46, 9], "def_end_pos": [46, 23]}]], "state_before": "m n\u271d n : \u2115\nhi : 3 \u2264 n\nthis\u271d : 0 < n\nthis : 1 < pred n\n\u22a2 n < n !", "state_after": "m n\u271d n : \u2115\nhi : 3 \u2264 n\nthis\u271d : 0 < n\nthis : 1 < pred n\n\u22a2 succ (pred n) < (pred n + 1) * (pred n)!"}, {"tactic": "exact\n  lt_mul_of_one_lt_right (pred n).succ_pos\n    ((\u20391 < pred n\u203a).trans_le (self_le_factorial _))", "annotated_tactic": ["exact\n    <a>lt_mul_of_one_lt_right</a> (<a>pred</a> n).<a>succ_pos</a>\n      ((\u20391 < pred n\u203a).<a>trans_le</a> (<a>self_le_factorial</a> _))", [{"full_name": "lt_mul_of_one_lt_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [752, 9], "def_end_pos": [752, 31]}, {"full_name": "Nat.pred", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1685, 5], "def_end_pos": [1685, 13]}, {"full_name": "Nat.succ_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1674, 9], "def_end_pos": [1674, 21]}, {"full_name": "LT.lt.trans_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [145, 7], "def_end_pos": [145, 21]}, {"full_name": "Nat.self_le_factorial", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [143, 9], "def_end_pos": [143, 26]}]], "state_before": "m n\u271d n : \u2115\nhi : 3 \u2264 n\nthis\u271d : 0 < n\nthis : 1 < pred n\n\u22a2 succ (pred n) < (pred n + 1) * (pred n)!", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.isUnit_coe", "start": [1145, 1], "end": [1146, 57], "traced_tactics": [{"tactic": "simp_rw [isUnit_iff, Set.isUnit_iff, coe_eq_singleton]", "annotated_tactic": ["simp_rw [<a>isUnit_iff</a>, <a>Set.isUnit_iff</a>, <a>coe_eq_singleton</a>]", [{"full_name": "Finset.isUnit_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Pointwise.lean", "def_pos": [1132, 9], "def_end_pos": [1132, 19]}, {"full_name": "Set.isUnit_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [1077, 9], "def_end_pos": [1077, 19]}, {"full_name": "Finset.coe_eq_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 25]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : DivisionMonoid \u03b1\ns t : Finset \u03b1\n\u22a2 IsUnit \u2191s \u2194 IsUnit s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Fin.lean", "full_name": "Fin.prod_univ_eight", "start": [160, 1], "end": [163, 6], "traced_tactics": [{"tactic": "rw [prod_univ_castSucc, prod_univ_seven]", "annotated_tactic": ["rw [<a>prod_univ_castSucc</a>, <a>prod_univ_seven</a>]", [{"full_name": "Fin.prod_univ_castSucc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [92, 9], "def_end_pos": [92, 27]}, {"full_name": "Fin.prod_univ_seven", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [152, 9], "def_end_pos": [152, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 8 \u2192 \u03b2\n\u22a2 \u220f i : Fin 8, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 * f 7", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 8 \u2192 \u03b2\n\u22a2 f (castSucc 0) * f (castSucc 1) * f (castSucc 2) * f (castSucc 3) * f (castSucc 4) * f (castSucc 5) * f (castSucc 6) *\n      f (last 7) =\n    f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 * f 7"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 8 \u2192 \u03b2\n\u22a2 f (castSucc 0) * f (castSucc 1) * f (castSucc 2) * f (castSucc 3) * f (castSucc 4) * f (castSucc 5) * f (castSucc 6) *\n      f (last 7) =\n    f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 * f 7", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.cospan_map_id", "start": [249, 1], "end": [250, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.sum_add", "start": [1032, 1], "end": [1034, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "ContDiff.mul", "start": [1498, 1], "end": [1500, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.SurjOn.leftInvOn_of_rightInvOn", "start": [1198, 1], "end": [1201, 21], "traced_tactics": [{"tactic": "let \u27e8x, hx, heq\u27e9 := hf hy", "annotated_tactic": ["let \u27e8x, hx, heq\u27e9 := hf hy", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhf : SurjOn f s t\nhf' : RightInvOn f f' s\ny : \u03b2\nhy : y \u2208 t\n\u22a2 f (f' y) = y", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhf : SurjOn f s t\nhf' : RightInvOn f f' s\ny : \u03b2\nhy : y \u2208 t\nx : \u03b1\nhx : x \u2208 s\nheq : f x = y\n\u22a2 f (f' y) = y"}, {"tactic": "rw [\u2190 heq, hf' hx]", "annotated_tactic": ["rw [\u2190 heq, hf' hx]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nhf : SurjOn f s t\nhf' : RightInvOn f f' s\ny : \u03b2\nhy : y \u2208 t\nx : \u03b1\nhx : x \u2208 s\nheq : f x = y\n\u22a2 f (f' y) = y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "lt_mul_of_one_lt_of_lt_of_nonneg", "start": [963, 1], "end": [965, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "sdiff_lt_sdiff_right", "start": [335, 1], "end": [337, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.mapDomain_apply'", "start": [550, 1], "end": [562, 59], "traced_tactics": [{"tactic": "rw [mapDomain, sum_apply, sum]", "annotated_tactic": ["rw [<a>mapDomain</a>, <a>sum_apply</a>, <a>sum</a>]", [{"full_name": "Finsupp.mapDomain", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [452, 5], "def_end_pos": [452, 14]}, {"full_name": "Finsupp.sum_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [327, 9], "def_end_pos": [327, 18]}, {"full_name": "Finsupp.sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [47, 3], "def_end_pos": [47, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\n\u22a2 (mapDomain f x) (f a) = x a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\n\u22a2 \u2211 a_1 in x.support, (single (f a_1) (x a_1)) (f a) = x a"}, {"tactic": "simp_rw [single_apply]", "annotated_tactic": ["simp_rw [<a>single_apply</a>]", [{"full_name": "Finsupp.single_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [304, 9], "def_end_pos": [304, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\n\u22a2 \u2211 a_1 in x.support, (single (f a_1) (x a_1)) (f a) = x a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\n\u22a2 (\u2211 x_1 in x.support, if f x_1 = f a then x x_1 else 0) = x a"}, {"tactic": "by_cases hax : a \u2208 x.support", "annotated_tactic": ["by_cases hax : a \u2208 x.support", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\n\u22a2 (\u2211 x_1 in x.support, if f x_1 = f a then x x_1 else 0) = x a", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2208 x.support\n\u22a2 (\u2211 x_1 in x.support, if f x_1 = f a then x x_1 else 0) = x a\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2209 x.support\n\u22a2 (\u2211 x_1 in x.support, if f x_1 = f a then x x_1 else 0) = x a"}, {"tactic": "rw [\u2190 Finset.add_sum_erase _ _ hax, if_pos rfl]", "annotated_tactic": ["rw [\u2190 <a>Finset.add_sum_erase</a> _ _ hax, <a>if_pos</a> <a>rfl</a>]", [{"full_name": "Finset.add_sum_erase", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1885, 3], "def_end_pos": [1885, 14]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "rfl", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [294, 22], "def_end_pos": [294, 25]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2208 x.support\n\u22a2 (\u2211 x_1 in x.support, if f x_1 = f a then x x_1 else 0) = x a", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2208 x.support\n\u22a2 (x a + \u2211 x_1 in Finset.erase x.support a, if f x_1 = f a then x x_1 else 0) = x a"}, {"tactic": "convert add_zero (x a)", "annotated_tactic": ["convert <a>add_zero</a> (x a)", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2208 x.support\n\u22a2 (x a + \u2211 x_1 in Finset.erase x.support a, if f x_1 = f a then x x_1 else 0) = x a", "state_after": "case h.e'_2.h.e'_6\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2208 x.support\n\u22a2 (\u2211 x_1 in Finset.erase x.support a, if f x_1 = f a then x x_1 else 0) = 0"}, {"tactic": "refine' Finset.sum_eq_zero fun i hi => if_neg _", "annotated_tactic": ["refine' <a>Finset.sum_eq_zero</a> fun i hi => <a>if_neg</a> _", [{"full_name": "Finset.sum_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [387, 3], "def_end_pos": [387, 14]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}]], "state_before": "case h.e'_2.h.e'_6\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2208 x.support\n\u22a2 (\u2211 x_1 in Finset.erase x.support a, if f x_1 = f a then x x_1 else 0) = 0", "state_after": "case h.e'_2.h.e'_6\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2208 x.support\ni : \u03b1\nhi : i \u2208 Finset.erase x.support a\n\u22a2 \u00acf i = f a"}, {"tactic": "exact (hf.mono hS).ne (Finset.mem_of_mem_erase hi) hax (Finset.ne_of_mem_erase hi)", "annotated_tactic": ["exact (hf.mono hS).<a>ne</a> (<a>Finset.mem_of_mem_erase</a> hi) hax (<a>Finset.ne_of_mem_erase</a> hi)", [{"full_name": "Set.InjOn.ne", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [621, 11], "def_end_pos": [621, 19]}, {"full_name": "Finset.mem_of_mem_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1954, 9], "def_end_pos": [1954, 25]}, {"full_name": "Finset.ne_of_mem_erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1951, 9], "def_end_pos": [1951, 24]}]], "state_before": "case h.e'_2.h.e'_6\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2208 x.support\ni : \u03b1\nhi : i \u2208 Finset.erase x.support a\n\u22a2 \u00acf i = f a", "state_after": "no goals"}, {"tactic": "rw [not_mem_support_iff.1 hax]", "annotated_tactic": ["rw [<a>not_mem_support_iff</a>.1 hax]", [{"full_name": "Finsupp.not_mem_support_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [194, 9], "def_end_pos": [194, 28]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2209 x.support\n\u22a2 (\u2211 x_1 in x.support, if f x_1 = f a then x x_1 else 0) = x a", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2209 x.support\n\u22a2 (\u2211 x_1 in x.support, if f x_1 = f a then x x_1 else 0) = 0"}, {"tactic": "refine' Finset.sum_eq_zero fun i hi => if_neg _", "annotated_tactic": ["refine' <a>Finset.sum_eq_zero</a> fun i hi => <a>if_neg</a> _", [{"full_name": "Finset.sum_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [387, 3], "def_end_pos": [387, 14]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2209 x.support\n\u22a2 (\u2211 x_1 in x.support, if f x_1 = f a then x x_1 else 0) = 0", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2209 x.support\ni : \u03b1\nhi : i \u2208 x.support\n\u22a2 \u00acf i = f a"}, {"tactic": "exact hf.ne (hS hi) ha (ne_of_mem_of_not_mem hi hax)", "annotated_tactic": ["exact hf.ne (hS hi) ha (<a>ne_of_mem_of_not_mem</a> hi hax)", [{"full_name": "ne_of_mem_of_not_mem", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [122, 9], "def_end_pos": [122, 29]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS\u271d : Type u_12\ninst\u271d : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\nS : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1 \u2192\u2080 M\nhS : \u2191x.support \u2286 S\nhf : Set.InjOn f S\na : \u03b1\nha : a \u2208 S\nhax : a \u2209 x.support\ni : \u03b1\nhi : i \u2208 x.support\n\u22a2 \u00acf i = f a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "getElem?_neg", "start": [28, 1], "end": [29, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Support.lean", "full_name": "HasCompactMulSupport.mono'", "start": [225, 1], "end": [227, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/Basic.lean", "full_name": "Submodule.isClosed_or_dense_of_isCoatom", "start": [212, 1], "end": [215, 37], "traced_tactics": [{"tactic": "refine (hs.le_iff.mp s.le_topologicalClosure).symm.imp ?_ dense_iff_topologicalClosure_eq_top.mpr", "annotated_tactic": ["refine (hs.le_iff.mp s.le_topologicalClosure).symm.imp ?_ dense_iff_topologicalClosure_eq_top.mpr", []], "state_before": "R R' : Type u\nM M' : Type v\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : Ring R'\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : TopologicalSpace M'\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : ContinuousConstSMul R M\ninst\u271d\u00b2 : Module R' M'\ninst\u271d\u00b9 : ContinuousConstSMul R' M'\ninst\u271d : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n\u22a2 IsClosed \u2191s \u2228 Dense \u2191s", "state_after": "R R' : Type u\nM M' : Type v\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : Ring R'\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : TopologicalSpace M'\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : ContinuousConstSMul R M\ninst\u271d\u00b2 : Module R' M'\ninst\u271d\u00b9 : ContinuousConstSMul R' M'\ninst\u271d : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n\u22a2 topologicalClosure s = s \u2192 IsClosed \u2191s"}, {"tactic": "exact fun h \u21a6 h \u25b8 isClosed_closure", "annotated_tactic": ["exact fun h \u21a6 h \u25b8 <a>isClosed_closure</a>", [{"full_name": "isClosed_closure", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [392, 9], "def_end_pos": [392, 25]}]], "state_before": "R R' : Type u\nM M' : Type v\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : Ring R'\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : TopologicalSpace M'\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : ContinuousConstSMul R M\ninst\u271d\u00b2 : Module R' M'\ninst\u271d\u00b9 : ContinuousConstSMul R' M'\ninst\u271d : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n\u22a2 topologicalClosure s = s \u2192 IsClosed \u2191s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsRelPrime.add_mul_right_left_iff", "start": [470, 1], "end": [471, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.range_succ", "start": [2225, 1], "end": [2226, 61], "traced_tactics": [{"tactic": "simp only [range_eq_range', range'_1_concat, Nat.zero_add]", "annotated_tactic": ["simp only [<a>range_eq_range'</a>, <a>range'_1_concat</a>, <a>Nat.zero_add</a>]", [{"full_name": "List.range_eq_range'", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2192, 9], "def_end_pos": [2192, 24]}, {"full_name": "List.range'_1_concat", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2185, 9], "def_end_pos": [2185, 24]}, {"full_name": "Nat.zero_add", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [114, 27], "def_end_pos": [114, 35]}]], "state_before": "n : Nat\n\u22a2 range (succ n) = range n ++ [n]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "NormedCommGroup.tendsto_nhds_one", "start": [822, 1], "end": [824, 61], "traced_tactics": [{"tactic": "simp only [dist_one_right]", "annotated_tactic": ["simp only [<a>dist_one_right</a>]", [{"full_name": "dist_one_right", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [424, 9], "def_end_pos": [424, 23]}]], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b2 : SeminormedGroup E\ninst\u271d\u00b9 : SeminormedGroup F\ninst\u271d : SeminormedGroup G\ns : Set E\na a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\nf : \u03b1 \u2192 E\nl : Filter \u03b1\n\u22a2 (\u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b1) in l, dist (f x) 1 < \u03b5) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (x : \u03b1) in l, \u2016f x\u2016 < \u03b5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/PartialHomeomorph.lean", "full_name": "PartialHomeomorph.restr_toPartialEquiv'", "start": [755, 1], "end": [757, 46], "traced_tactics": [{"tactic": "rw [e.restr_toPartialEquiv, hs.interior_eq]", "annotated_tactic": ["rw [e.restr_toPartialEquiv, hs.interior_eq]", []], "state_before": "X : Type u_1\nX' : Type u_2\nY : Type u_3\nY' : Type u_4\nZ : Type u_5\nZ' : Type u_6\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace X'\ninst\u271d\u00b3 : TopologicalSpace Y\ninst\u271d\u00b2 : TopologicalSpace Y'\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace Z'\ne : PartialHomeomorph X Y\ns : Set X\nhs : IsOpen s\n\u22a2 (PartialHomeomorph.restr e s).toPartialEquiv = PartialEquiv.restr e.toPartialEquiv s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Basic.lean", "full_name": "Equiv.Perm.mul_symm", "start": [172, 1], "end": [173, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Ring.lean", "full_name": "Units.sq_eq_sq_iff_eq_or_eq_neg", "start": [241, 11], "end": [242, 82], "traced_tactics": [{"tactic": "simp_rw [ext_iff, val_pow_eq_pow_val, sq_eq_sq_iff_eq_or_eq_neg, Units.val_neg]", "annotated_tactic": ["simp_rw [<a>ext_iff</a>, <a>val_pow_eq_pow_val</a>, <a>sq_eq_sq_iff_eq_or_eq_neg</a>, <a>Units.val_neg</a>]", [{"full_name": "Units.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [157, 9], "def_end_pos": [157, 16]}, {"full_name": "Units.val_pow_eq_pow_val", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [408, 7], "def_end_pos": [408, 25]}, {"full_name": "sq_eq_sq_iff_eq_or_eq_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [230, 9], "def_end_pos": [230, 34]}, {"full_name": "Units.val_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Units.lean", "def_pos": [37, 19], "def_end_pos": [37, 26]}]], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : CommRing R\ninst\u271d : NoZeroDivisors R\na\u271d b\u271d : R\na b : R\u02e3\n\u22a2 a ^ 2 = b ^ 2 \u2194 a = b \u2228 a = -b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "ENNReal.tendsto_tsum_compl_atTop_zero", "start": [986, 1], "end": [991, 97], "traced_tactics": [{"tactic": "lift f to \u03b1 \u2192 \u211d\u22650 using ENNReal.ne_top_of_tsum_ne_top hf", "annotated_tactic": ["lift f to \u03b1 \u2192 \u211d\u22650 using <a>ENNReal.ne_top_of_tsum_ne_top</a> hf", [{"full_name": "ENNReal.ne_top_of_tsum_ne_top", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [917, 19], "def_end_pos": [917, 40]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nf\u271d g : \u03b1\u271d \u2192 \u211d\u22650\u221e\n\u03b1 : Type u_4\nf : \u03b1 \u2192 \u211d\u22650\u221e\nhf : \u2211' (x : \u03b1), f x \u2260 \u22a4\n\u22a2 Tendsto (fun s => \u2211' (b : { x // x \u2209 s }), f \u2191b) atTop (\ud835\udcdd 0)", "state_after": "case intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nf\u271d g : \u03b1\u271d \u2192 \u211d\u22650\u221e\n\u03b1 : Type u_4\nf : \u03b1 \u2192 \u211d\u22650\nhf : \u2211' (x : \u03b1), (fun i => \u2191(f i)) x \u2260 \u22a4\n\u22a2 Tendsto (fun s => \u2211' (b : { x // x \u2209 s }), (fun i => \u2191(f i)) \u2191b) atTop (\ud835\udcdd 0)"}, {"tactic": "convert ENNReal.tendsto_coe.2 (NNReal.tendsto_tsum_compl_atTop_zero f)", "annotated_tactic": ["convert <a>ENNReal.tendsto_coe</a>.2 (<a>NNReal.tendsto_tsum_compl_atTop_zero</a> f)", [{"full_name": "ENNReal.tendsto_coe", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [75, 9], "def_end_pos": [75, 20]}, {"full_name": "NNReal.tendsto_tsum_compl_atTop_zero", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/NNReal.lean", "def_pos": [255, 16], "def_end_pos": [255, 45]}]], "state_before": "case intro\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nf\u271d g : \u03b1\u271d \u2192 \u211d\u22650\u221e\n\u03b1 : Type u_4\nf : \u03b1 \u2192 \u211d\u22650\nhf : \u2211' (x : \u03b1), (fun i => \u2191(f i)) x \u2260 \u22a4\n\u22a2 Tendsto (fun s => \u2211' (b : { x // x \u2209 s }), (fun i => \u2191(f i)) \u2191b) atTop (\ud835\udcdd 0)", "state_after": "case h.e'_3.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nf\u271d g : \u03b1\u271d \u2192 \u211d\u22650\u221e\n\u03b1 : Type u_4\nf : \u03b1 \u2192 \u211d\u22650\nhf : \u2211' (x : \u03b1), (fun i => \u2191(f i)) x \u2260 \u22a4\nx\u271d : Finset \u03b1\n\u22a2 \u2211' (b : { x // x \u2209 x\u271d }), (fun i => \u2191(f i)) \u2191b = \u2191(\u2211' (b : { x // x \u2209 x\u271d }), f \u2191b)"}, {"tactic": "rw [ENNReal.coe_tsum]", "annotated_tactic": ["rw [<a>ENNReal.coe_tsum</a>]", [{"full_name": "ENNReal.coe_tsum", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [792, 19], "def_end_pos": [792, 27]}]], "state_before": "case h.e'_3.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nf\u271d g : \u03b1\u271d \u2192 \u211d\u22650\u221e\n\u03b1 : Type u_4\nf : \u03b1 \u2192 \u211d\u22650\nhf : \u2211' (x : \u03b1), (fun i => \u2191(f i)) x \u2260 \u22a4\nx\u271d : Finset \u03b1\n\u22a2 \u2211' (b : { x // x \u2209 x\u271d }), (fun i => \u2191(f i)) \u2191b = \u2191(\u2211' (b : { x // x \u2209 x\u271d }), f \u2191b)", "state_after": "case h.e'_3.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nf\u271d g : \u03b1\u271d \u2192 \u211d\u22650\u221e\n\u03b1 : Type u_4\nf : \u03b1 \u2192 \u211d\u22650\nhf : \u2211' (x : \u03b1), (fun i => \u2191(f i)) x \u2260 \u22a4\nx\u271d : Finset \u03b1\n\u22a2 Summable fun b => f \u2191b"}, {"tactic": "exact NNReal.summable_comp_injective (tsum_coe_ne_top_iff_summable.1 hf) Subtype.coe_injective", "annotated_tactic": ["exact <a>NNReal.summable_comp_injective</a> (<a>tsum_coe_ne_top_iff_summable</a>.1 hf) <a>Subtype.coe_injective</a>", [{"full_name": "NNReal.summable_comp_injective", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/NNReal.lean", "def_pos": [209, 9], "def_end_pos": [209, 32]}, {"full_name": "ENNReal.tsum_coe_ne_top_iff_summable", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [805, 9], "def_end_pos": [805, 37]}, {"full_name": "Subtype.coe_injective", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [119, 9], "def_end_pos": [119, 22]}]], "state_before": "case h.e'_3.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx y z \u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e\ns : Set \u211d\u22650\u221e\nf\u271d g : \u03b1\u271d \u2192 \u211d\u22650\u221e\n\u03b1 : Type u_4\nf : \u03b1 \u2192 \u211d\u22650\nhf : \u2211' (x : \u03b1), (fun i => \u2191(f i)) x \u2260 \u22a4\nx\u271d : Finset \u03b1\n\u22a2 Summable fun b => f \u2191b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Basic.lean", "full_name": "AddMonoidHom.toRatLinearMap_injective", "start": [783, 1], "end": [787, 32], "traced_tactics": [{"tactic": "intro f g h", "annotated_tactic": ["intro f g h", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module \u211a M\ninst\u271d\u00b9 : AddCommGroup M\u2082\ninst\u271d : Module \u211a M\u2082\n\u22a2 Injective toRatLinearMap", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module \u211a M\ninst\u271d\u00b9 : AddCommGroup M\u2082\ninst\u271d : Module \u211a M\u2082\nf g : M \u2192+ M\u2082\nh : toRatLinearMap f = toRatLinearMap g\n\u22a2 f = g"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module \u211a M\ninst\u271d\u00b9 : AddCommGroup M\u2082\ninst\u271d : Module \u211a M\u2082\nf g : M \u2192+ M\u2082\nh : toRatLinearMap f = toRatLinearMap g\n\u22a2 f = g", "state_after": "case h\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module \u211a M\ninst\u271d\u00b9 : AddCommGroup M\u2082\ninst\u271d : Module \u211a M\u2082\nf g : M \u2192+ M\u2082\nh : toRatLinearMap f = toRatLinearMap g\nx : M\n\u22a2 f x = g x"}, {"tactic": "exact LinearMap.congr_fun h x", "annotated_tactic": ["exact <a>LinearMap.congr_fun</a> h x", [{"full_name": "LinearMap.congr_fun", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [323, 19], "def_end_pos": [323, 28]}]], "state_before": "case h\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module \u211a M\ninst\u271d\u00b9 : AddCommGroup M\u2082\ninst\u271d : Module \u211a M\u2082\nf g : M \u2192+ M\u2082\nh : toRatLinearMap f = toRatLinearMap g\nx : M\n\u22a2 f x = g x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "Codisjoint.himp_inf_cancel_right", "start": [388, 1], "end": [389, 63], "traced_tactics": [{"tactic": "rw [himp_inf_distrib, himp_self, top_inf_eq, h.himp_eq_left]", "annotated_tactic": ["rw [<a>himp_inf_distrib</a>, <a>himp_self</a>, <a>top_inf_eq</a>, h.himp_eq_left]", [{"full_name": "himp_inf_distrib", "def_path": ".lake/packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [347, 9], "def_end_pos": [347, 25]}, {"full_name": "himp_self", "def_path": ".lake/packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [283, 9], "def_end_pos": [283, 18]}, {"full_name": "top_inf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [442, 7], "def_end_pos": [442, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c d : \u03b1\nh : Codisjoint a b\n\u22a2 a \u21e8 a \u2293 b = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "full_name": "CategoryTheory.Limits.PushoutCocone.flip_inl", "start": [965, 1], "end": [965, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "inf_le_left'", "start": [364, 1], "end": [365, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.reduceOption_append", "start": [3397, 1], "end": [3399, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "eq_iff_eq_of_mul_eq_mul", "start": [297, 1], "end": [297, 93], "traced_tactics": [{"tactic": "aesop", "annotated_tactic": ["aesop", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : CancelCommMonoid \u03b1\na b c d : \u03b1\nh : a * b = c * d\n\u22a2 a = c \u2194 b = d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Exponential.lean", "full_name": "Complex.ofReal_cos_ofReal_re", "start": [635, 1], "end": [636, 54], "traced_tactics": [{"tactic": "rw [\u2190 cos_conj, conj_ofReal]", "annotated_tactic": ["rw [\u2190 <a>cos_conj</a>, <a>conj_ofReal</a>]", [{"full_name": "Complex.cos_conj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Exponential.lean", "def_pos": [630, 9], "def_end_pos": [630, 17]}, {"full_name": "Complex.conj_ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [549, 9], "def_end_pos": [549, 20]}]], "state_before": "x\u271d y : \u2102\nx : \u211d\n\u22a2 (starRingEnd \u2102) (cos \u2191x) = cos \u2191x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "pow_bit1_pos_iff", "start": [485, 1], "end": [486, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Instances/ENNReal.lean", "full_name": "continuous_of_le_add_edist", "start": [1467, 1], "end": [1475, 69], "traced_tactics": [{"tactic": "refine continuous_iff_continuousAt.2 fun x => ENNReal.tendsto_nhds_of_Icc fun \u03b5 \u03b50 => ?_", "annotated_tactic": ["refine <a>continuous_iff_continuousAt</a>.2 fun x => <a>ENNReal.tendsto_nhds_of_Icc</a> fun \u03b5 \u03b50 => ?_", [{"full_name": "continuous_iff_continuousAt", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Basic.lean", "def_pos": [1635, 9], "def_end_pos": [1635, 36]}, {"full_name": "ENNReal.tendsto_nhds_of_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Instances/ENNReal.lean", "def_pos": [277, 19], "def_end_pos": [277, 38]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\n\u22a2 Continuous f", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u22a2 \u2200\u1da0 (x_1 : \u03b1) in \ud835\udcdd x, f x_1 \u2208 Icc (f x - \u03b5) (f x + \u03b5)"}, {"tactic": "rcases ENNReal.exists_nnreal_pos_mul_lt hC \u03b50.ne' with \u27e8\u03b4, \u03b40, h\u03b4\u27e9", "annotated_tactic": ["rcases <a>ENNReal.exists_nnreal_pos_mul_lt</a> hC \u03b50.ne' with \u27e8\u03b4, \u03b40, h\u03b4\u27e9", [{"full_name": "ENNReal.exists_nnreal_pos_mul_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Inv.lean", "def_pos": [570, 9], "def_end_pos": [570, 33]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u22a2 \u2200\u1da0 (x_1 : \u03b1) in \ud835\udcdd x, f x_1 \u2208 Icc (f x - \u03b5) (f x + \u03b5)", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : \u2191\u03b4 * C < \u03b5\n\u22a2 \u2200\u1da0 (x_1 : \u03b1) in \ud835\udcdd x, f x_1 \u2208 Icc (f x - \u03b5) (f x + \u03b5)"}, {"tactic": "rw [mul_comm] at h\u03b4", "annotated_tactic": ["rw [<a>mul_comm</a>] at h\u03b4", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : \u2191\u03b4 * C < \u03b5\n\u22a2 \u2200\u1da0 (x_1 : \u03b1) in \ud835\udcdd x, f x_1 \u2208 Icc (f x - \u03b5) (f x + \u03b5)", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\n\u22a2 \u2200\u1da0 (x_1 : \u03b1) in \ud835\udcdd x, f x_1 \u2208 Icc (f x - \u03b5) (f x + \u03b5)"}, {"tactic": "filter_upwards [EMetric.closedBall_mem_nhds x (ENNReal.coe_pos.2 \u03b40)] with y hy", "annotated_tactic": ["filter_upwards [<a>EMetric.closedBall_mem_nhds</a> x (<a>ENNReal.coe_pos</a>.2 \u03b40)] with y hy", [{"full_name": "EMetric.closedBall_mem_nhds", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean", "def_pos": [708, 9], "def_end_pos": [708, 28]}, {"full_name": "ENNReal.coe_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [407, 28], "def_end_pos": [407, 35]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\n\u22a2 \u2200\u1da0 (x_1 : \u03b1) in \ud835\udcdd x, f x_1 \u2208 Icc (f x - \u03b5) (f x + \u03b5)", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\ny : \u03b1\nhy : y \u2208 EMetric.closedBall x \u2191\u03b4\n\u22a2 f y \u2208 Icc (f x - \u03b5) (f x + \u03b5)"}, {"tactic": "refine \u27e8tsub_le_iff_right.2 <| (h x y).trans ?_, (h y x).trans ?_\u27e9 <;>\n  refine add_le_add_left (le_trans (mul_le_mul_left' ?_ _) h\u03b4.le) _", "annotated_tactic": ["refine \u27e8<a>tsub_le_iff_right</a>.2 <| (h x y).<a>trans</a> ?_, (h y x).<a>trans</a> ?_\u27e9 <;>\n    refine <a>add_le_add_left</a> (<a>le_trans</a> (<a>mul_le_mul_left'</a> ?_ _) h\u03b4.le) _", [{"full_name": "tsub_le_iff_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [63, 9], "def_end_pos": [63, 26]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "add_le_add_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [49, 32], "def_end_pos": [49, 47]}, {"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "mul_le_mul_left'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [50, 9], "def_end_pos": [50, 25]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\ny : \u03b1\nhy : y \u2208 EMetric.closedBall x \u2191\u03b4\n\u22a2 f y \u2208 Icc (f x - \u03b5) (f x + \u03b5)", "state_after": "case h.refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\ny : \u03b1\nhy : y \u2208 EMetric.closedBall x \u2191\u03b4\n\u22a2 edist x y \u2264 \u2191\u03b4\n\ncase h.refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\ny : \u03b1\nhy : y \u2208 EMetric.closedBall x \u2191\u03b4\n\u22a2 edist y x \u2264 \u2191\u03b4"}, {"tactic": "exacts [EMetric.mem_closedBall'.1 hy, EMetric.mem_closedBall.1 hy]", "annotated_tactic": ["exacts [<a>EMetric.mem_closedBall'</a>.1 hy, <a>EMetric.mem_closedBall</a>.1 hy]", [{"full_name": "EMetric.mem_closedBall'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean", "def_pos": [549, 9], "def_end_pos": [549, 24]}, {"full_name": "EMetric.mem_closedBall", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean", "def_pos": [546, 17], "def_end_pos": [546, 31]}]], "state_before": "case h.refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\ny : \u03b1\nhy : y \u2208 EMetric.closedBall x \u2191\u03b4\n\u22a2 edist x y \u2264 \u2191\u03b4\n\ncase h.refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\nC : \u211d\u22650\u221e\nhC : C \u2260 \u22a4\nh : \u2200 (x y : \u03b1), f x \u2264 f y + C * edist x y\nx : \u03b1\n\u03b5 : \u211d\u22650\u221e\n\u03b50 : \u03b5 > 0\n\u03b4 : \u211d\u22650\n\u03b40 : \u03b4 > 0\nh\u03b4 : C * \u2191\u03b4 < \u03b5\ny : \u03b1\nhy : y \u2208 EMetric.closedBall x \u2191\u03b4\n\u22a2 edist y x \u2264 \u2191\u03b4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Circular.lean", "full_name": "sbtw_trans_right", "start": [240, 1], "end": [241, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Convex/Strict.lean", "full_name": "StrictConvex.neg", "start": [385, 1], "end": [386, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "ContinuousOn.norm'", "start": [1372, 1], "end": [1373, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Basic.lean", "full_name": "ENNReal.toReal_eq_zero_iff", "start": [302, 1], "end": [303, 46], "traced_tactics": [{"tactic": "simp [ENNReal.toReal, toNNReal_eq_zero_iff]", "annotated_tactic": ["simp [<a>ENNReal.toReal</a>, <a>toNNReal_eq_zero_iff</a>]", [{"full_name": "ENNReal.toReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [194, 25], "def_end_pos": [194, 31]}, {"full_name": "ENNReal.toNNReal_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [298, 9], "def_end_pos": [298, 29]}]], "state_before": "\u03b1 : Type u_1\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nx : \u211d\u22650\u221e\n\u22a2 x.toReal = 0 \u2194 x = 0 \u2228 x = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean", "full_name": "Nat.pow_sub_le_descFactorial", "start": [436, 1], "end": [442, 38], "traced_tactics": [{"tactic": "rw [descFactorial_zero, pow_zero]", "annotated_tactic": ["rw [<a>descFactorial_zero</a>, <a>pow_zero</a>]", [{"full_name": "Nat.descFactorial_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [353, 9], "def_end_pos": [353, 27]}, {"full_name": "pow_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [650, 9], "def_end_pos": [650, 17]}]], "state_before": "n : \u2115\n\u22a2 (n + 1 - 0) ^ 0 \u2264 descFactorial n 0", "state_after": "no goals"}, {"tactic": "rw [descFactorial_succ, Nat.pow_succ, succ_sub_succ, mul_comm]", "annotated_tactic": ["rw [<a>descFactorial_succ</a>, <a>Nat.pow_succ</a>, <a>succ_sub_succ</a>, <a>mul_comm</a>]", [{"full_name": "Nat.descFactorial_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [358, 9], "def_end_pos": [358, 27]}, {"full_name": "Nat.pow_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [506, 19], "def_end_pos": [506, 27]}, {"full_name": "Nat.succ_sub_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [250, 9], "def_end_pos": [250, 22]}, {"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}]], "state_before": "n k : \u2115\n\u22a2 (n + 1 - (k + 1)) ^ (k + 1) \u2264 descFactorial n (k + 1)", "state_after": "n k : \u2115\n\u22a2 (n - k) * (n - k) ^ k \u2264 (n - k) * descFactorial n k"}, {"tactic": "apply Nat.mul_le_mul_left", "annotated_tactic": ["apply <a>Nat.mul_le_mul_left</a>", [{"full_name": "Nat.mul_le_mul_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [470, 9], "def_end_pos": [470, 24]}]], "state_before": "n k : \u2115\n\u22a2 (n - k) * (n - k) ^ k \u2264 (n - k) * descFactorial n k", "state_after": "case h\nn k : \u2115\n\u22a2 (n - k) ^ k \u2264 descFactorial n k"}, {"tactic": "exact (le_trans (Nat.pow_le_pow_left (tsub_le_tsub_right (le_succ _) _) k)\n  (pow_sub_le_descFactorial n k))", "annotated_tactic": ["exact (<a>le_trans</a> (<a>Nat.pow_le_pow_left</a> (<a>tsub_le_tsub_right</a> (<a>le_succ</a> _) _) k)\n      (pow_sub_le_descFactorial n k))", [{"full_name": "le_trans", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 17]}, {"full_name": "Nat.pow_le_pow_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [790, 18], "def_end_pos": [790, 33]}, {"full_name": "tsub_le_tsub_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [107, 19], "def_end_pos": [107, 37]}, {"full_name": "Nat.le_succ", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1665, 9], "def_end_pos": [1665, 20]}]], "state_before": "case h\nn k : \u2115\n\u22a2 (n - k) ^ k \u2264 descFactorial n k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/NormalClosure.lean", "full_name": "normalClosure.restrictScalars_eq", "start": [190, 1], "end": [192, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Adjoin/Field.lean", "full_name": "Subalgebra.adjoin_rank_le", "start": [112, 1], "end": [121, 53], "traced_tactics": [{"tactic": "rw [\u2190 rank_toSubmodule, Module.Free.rank_eq_card_chooseBasisIndex F L,\n  L.adjoin_eq_span_basis E (Module.Free.chooseBasis F L)]", "annotated_tactic": ["rw [\u2190 <a>rank_toSubmodule</a>, <a>Module.Free.rank_eq_card_chooseBasisIndex</a> F L,\n    L.adjoin_eq_span_basis E (<a>Module.Free.chooseBasis</a> F L)]", [{"full_name": "Subalgebra.rank_toSubmodule", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "def_pos": [517, 9], "def_end_pos": [517, 36]}, {"full_name": "Module.Free.rank_eq_card_chooseBasisIndex", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Free.lean", "def_pos": [83, 9], "def_end_pos": [83, 38]}, {"full_name": "Module.Free.chooseBasis", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FreeModule/Basic.lean", "def_pos": [85, 19], "def_end_pos": [85, 30]}]], "state_before": "R : Type u_1\nK\u271d : Type u_2\nL\u271d : Type u_3\nM : Type u_4\ninst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : Field K\u271d\ninst\u271d\u00b9\u2076 : Field L\u271d\ninst\u271d\u00b9\u2075 : CommRing M\ninst\u271d\u00b9\u2074 : Algebra R K\u271d\ninst\u271d\u00b9\u00b3 : Algebra R L\u271d\ninst\u271d\u00b9\u00b2 : Algebra R M\nx\u271d : L\u271d\nint\u271d : IsIntegral R x\u271d\nh : Splits (algebraMap R K\u271d) (minpoly R x\u271d)\ninst\u271d\u00b9\u00b9 : Algebra K\u271d M\ninst\u271d\u00b9\u2070 : IsScalarTower R K\u271d M\nx : M\nint : IsIntegral R x\nF : Type u_5\nE : Type u_6\nK : Type u_7\ninst\u271d\u2079 : CommRing F\ninst\u271d\u2078 : StrongRankCondition F\ninst\u271d\u2077 : CommRing E\ninst\u271d\u2076 : StrongRankCondition E\ninst\u271d\u2075 : Ring K\ninst\u271d\u2074 : SMul F E\ninst\u271d\u00b3 : Algebra E K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : IsScalarTower F E K\nL : Subalgebra F K\ninst\u271d : Module.Free F \u21a5L\n\u22a2 Module.rank E \u21a5(Algebra.adjoin E \u2191L) \u2264 Module.rank F \u21a5L", "state_after": "R : Type u_1\nK\u271d : Type u_2\nL\u271d : Type u_3\nM : Type u_4\ninst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : Field K\u271d\ninst\u271d\u00b9\u2076 : Field L\u271d\ninst\u271d\u00b9\u2075 : CommRing M\ninst\u271d\u00b9\u2074 : Algebra R K\u271d\ninst\u271d\u00b9\u00b3 : Algebra R L\u271d\ninst\u271d\u00b9\u00b2 : Algebra R M\nx\u271d : L\u271d\nint\u271d : IsIntegral R x\u271d\nh : Splits (algebraMap R K\u271d) (minpoly R x\u271d)\ninst\u271d\u00b9\u00b9 : Algebra K\u271d M\ninst\u271d\u00b9\u2070 : IsScalarTower R K\u271d M\nx : M\nint : IsIntegral R x\nF : Type u_5\nE : Type u_6\nK : Type u_7\ninst\u271d\u2079 : CommRing F\ninst\u271d\u2078 : StrongRankCondition F\ninst\u271d\u2077 : CommRing E\ninst\u271d\u2076 : StrongRankCondition E\ninst\u271d\u2075 : Ring K\ninst\u271d\u2074 : SMul F E\ninst\u271d\u00b3 : Algebra E K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : IsScalarTower F E K\nL : Subalgebra F K\ninst\u271d : Module.Free F \u21a5L\n\u22a2 Module.rank E \u21a5(Submodule.span E (Set.range fun i => \u2191((Module.Free.chooseBasis F \u21a5L) i))) \u2264\n    Cardinal.mk (Module.Free.ChooseBasisIndex F \u21a5L)"}, {"tactic": "exact rank_span_le _ |>.trans Cardinal.mk_range_le", "annotated_tactic": ["exact <a>rank_span_le</a> _ |>.<a>trans</a> <a>Cardinal.mk_range_le</a>", [{"full_name": "rank_span_le", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Dimension/Constructions.lean", "def_pos": [429, 9], "def_end_pos": [429, 21]}, {"full_name": "LE.le.trans", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [117, 7], "def_end_pos": [117, 18]}, {"full_name": "Cardinal.mk_range_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1942, 9], "def_end_pos": [1942, 20]}]], "state_before": "R : Type u_1\nK\u271d : Type u_2\nL\u271d : Type u_3\nM : Type u_4\ninst\u271d\u00b9\u2078 : CommRing R\ninst\u271d\u00b9\u2077 : Field K\u271d\ninst\u271d\u00b9\u2076 : Field L\u271d\ninst\u271d\u00b9\u2075 : CommRing M\ninst\u271d\u00b9\u2074 : Algebra R K\u271d\ninst\u271d\u00b9\u00b3 : Algebra R L\u271d\ninst\u271d\u00b9\u00b2 : Algebra R M\nx\u271d : L\u271d\nint\u271d : IsIntegral R x\u271d\nh : Splits (algebraMap R K\u271d) (minpoly R x\u271d)\ninst\u271d\u00b9\u00b9 : Algebra K\u271d M\ninst\u271d\u00b9\u2070 : IsScalarTower R K\u271d M\nx : M\nint : IsIntegral R x\nF : Type u_5\nE : Type u_6\nK : Type u_7\ninst\u271d\u2079 : CommRing F\ninst\u271d\u2078 : StrongRankCondition F\ninst\u271d\u2077 : CommRing E\ninst\u271d\u2076 : StrongRankCondition E\ninst\u271d\u2075 : Ring K\ninst\u271d\u2074 : SMul F E\ninst\u271d\u00b3 : Algebra E K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : IsScalarTower F E K\nL : Subalgebra F K\ninst\u271d : Module.Free F \u21a5L\n\u22a2 Module.rank E \u21a5(Submodule.span E (Set.range fun i => \u2191((Module.Free.chooseBasis F \u21a5L) i))) \u2264\n    Cardinal.mk (Module.Free.ChooseBasisIndex F \u21a5L)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "full_name": "ContinuousOn.strictMonoOn_of_injOn_Icc'", "start": [731, 1], "end": [736, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Group/Abs.lean", "full_name": "mabs_le_mabs_of_one_le", "start": [110, 1], "end": [111, 57], "traced_tactics": [{"tactic": "rwa [mabs_of_one_le ha, mabs_of_one_le (ha.trans hab)]", "annotated_tactic": ["rwa [<a>mabs_of_one_le</a> ha, <a>mabs_of_one_le</a> (ha.trans hab)]", [{"full_name": "mabs_of_one_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [94, 22], "def_end_pos": [94, 36]}, {"full_name": "mabs_of_one_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [94, 22], "def_end_pos": [94, 36]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : Group \u03b1\na b : \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nha : 1 \u2264 a\nhab : a \u2264 b\n\u22a2 mabs a \u2264 mabs b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Group/Abs.lean", "full_name": "mabs_mul_eq_mul_mabs_iff", "start": [358, 1], "end": [362, 69], "traced_tactics": [{"tactic": "obtain ab | ab := le_total a b", "annotated_tactic": ["obtain ab | ab := <a>le_total</a> a b", [{"full_name": "le_total", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [289, 9], "def_end_pos": [289, 17]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1", "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\nab : a \u2264 b\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1\n\ncase inr\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\nab : b \u2264 a\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1"}, {"tactic": "exact mabs_mul_eq_mul_mabs_le ab", "annotated_tactic": ["exact <a>mabs_mul_eq_mul_mabs_le</a> ab", [{"full_name": "_private.\u00ab.lake\u00bb.packages.mathlib.Mathlib.Algebra.Order.Group.Abs.0.mabs_mul_eq_mul_mabs_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [340, 30], "def_end_pos": [340, 53]}]], "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\nab : a \u2264 b\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1", "state_after": "no goals"}, {"tactic": "simpa only [mul_comm, and_comm] using mabs_mul_eq_mul_mabs_le ab", "annotated_tactic": ["simpa only [<a>mul_comm</a>, <a>and_comm</a>] using <a>mabs_mul_eq_mul_mabs_le</a> ab", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}, {"full_name": "_private.\u00ab.lake\u00bb.packages.mathlib.Mathlib.Algebra.Order.Group.Abs.0.mabs_mul_eq_mul_mabs_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [340, 30], "def_end_pos": [340, 53]}]], "state_before": "case inr\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\nab : b \u2264 a\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Aut.lean", "full_name": "AddAut.inv_def", "start": [212, 1], "end": [213, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean", "full_name": "MvPolynomial.isNoetherianRing_fin", "start": [1144, 1], "end": [1150, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Adjunction/Basic.lean", "full_name": "CategoryTheory.Adjunction.left_triangle", "start": [177, 1], "end": [180, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX' X : C\nY Y' : D\n\u22a2 whiskerRight adj.unit F \u226b whiskerLeft F adj.counit = \ud835\udfd9 (\ud835\udfed C \u22d9 F)", "state_after": "case w.h\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX' X : C\nY Y' : D\nx\u271d : C\n\u22a2 (whiskerRight adj.unit F \u226b whiskerLeft F adj.counit).app x\u271d = (\ud835\udfd9 (\ud835\udfed C \u22d9 F)).app x\u271d"}, {"tactic": "dsimp", "annotated_tactic": ["dsimp", []], "state_before": "case w.h\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX' X : C\nY Y' : D\nx\u271d : C\n\u22a2 (whiskerRight adj.unit F \u226b whiskerLeft F adj.counit).app x\u271d = (\ud835\udfd9 (\ud835\udfed C \u22d9 F)).app x\u271d", "state_after": "case w.h\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX' X : C\nY Y' : D\nx\u271d : C\n\u22a2 F.map (adj.unit.app x\u271d) \u226b adj.counit.app (F.obj x\u271d) = \ud835\udfd9 (F.obj x\u271d)"}, {"tactic": "erw [\u2190 adj.homEquiv_counit, Equiv.symm_apply_eq, adj.homEquiv_unit]", "annotated_tactic": ["erw [\u2190 adj.homEquiv_counit, <a>Equiv.symm_apply_eq</a>, adj.homEquiv_unit]", [{"full_name": "Equiv.symm_apply_eq", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [346, 9], "def_end_pos": [346, 22]}]], "state_before": "case w.h\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX' X : C\nY Y' : D\nx\u271d : C\n\u22a2 F.map (adj.unit.app x\u271d) \u226b adj.counit.app (F.obj x\u271d) = \ud835\udfd9 (F.obj x\u271d)", "state_after": "case w.h\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX' X : C\nY Y' : D\nx\u271d : C\n\u22a2 adj.unit.app x\u271d = adj.unit.app x\u271d \u226b G.map (\ud835\udfd9 (F.obj x\u271d))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case w.h\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nG : D \u2964 C\nadj : F \u22a3 G\nX' X : C\nY Y' : D\nx\u271d : C\n\u22a2 adj.unit.app x\u271d = adj.unit.app x\u271d \u226b G.map (\ud835\udfd9 (F.obj x\u271d))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/EventuallyConst.lean", "full_name": "Filter.EventuallyConst.mulIndicator_const", "start": [136, 1], "end": [138, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Real.rpow_sub_int'", "start": [424, 1], "end": [425, 37], "traced_tactics": [{"tactic": "rw [rpow_sub' hx h, rpow_int_cast]", "annotated_tactic": ["rw [<a>rpow_sub'</a> hx h, <a>rpow_int_cast</a>]", [{"full_name": "Real.rpow_sub'", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [251, 9], "def_end_pos": [251, 18]}, {"full_name": "Real.rpow_int_cast", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [64, 9], "def_end_pos": [64, 22]}]], "state_before": "x y z : \u211d\nn\u271d : \u2115\nhx : 0 \u2264 x\nn : \u2124\nh : y - \u2191n \u2260 0\n\u22a2 x ^ (y - \u2191n) = x ^ y / x ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Equiv.lean", "full_name": "LinearEquiv.symm_trans_apply", "start": [378, 1], "end": [380, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Support.lean", "full_name": "subset_mulTSupport", "start": [51, 1], "end": [52, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.sum_fin", "start": [414, 1], "end": [421, 56], "traced_tactics": [{"tactic": "by_cases hp : p = 0", "annotated_tactic": ["by_cases hp : p = 0", []], "state_before": "R : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : AddCommMonoid S\nf : \u2115 \u2192 R \u2192 S\nhf : \u2200 (i : \u2115), f i 0 = 0\nn : \u2115\np : R[X]\nhn : degree p < \u2191n\n\u22a2 \u2211 i : Fin n, f (\u2191i) (coeff p \u2191i) = sum p f", "state_after": "case pos\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : AddCommMonoid S\nf : \u2115 \u2192 R \u2192 S\nhf : \u2200 (i : \u2115), f i 0 = 0\nn : \u2115\np : R[X]\nhn : degree p < \u2191n\nhp : p = 0\n\u22a2 \u2211 i : Fin n, f (\u2191i) (coeff p \u2191i) = sum p f\n\ncase neg\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : AddCommMonoid S\nf : \u2115 \u2192 R \u2192 S\nhf : \u2200 (i : \u2115), f i 0 = 0\nn : \u2115\np : R[X]\nhn : degree p < \u2191n\nhp : \u00acp = 0\n\u22a2 \u2211 i : Fin n, f (\u2191i) (coeff p \u2191i) = sum p f"}, {"tactic": "rw [sum_over_range' _ hf n ((natDegree_lt_iff_degree_lt hp).mpr hn),\n  Fin.sum_univ_eq_sum_range fun i => f i (p.coeff i)]", "annotated_tactic": ["rw [<a>sum_over_range'</a> _ hf n ((<a>natDegree_lt_iff_degree_lt</a> hp).<a>mpr</a> hn),\n    <a>Fin.sum_univ_eq_sum_range</a> fun i => f i (p.coeff i)]", [{"full_name": "Polynomial.sum_over_range'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [398, 9], "def_end_pos": [398, 24]}, {"full_name": "Polynomial.natDegree_lt_iff_degree_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [227, 9], "def_end_pos": [227, 35]}, {"full_name": "Iff.mpr", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [120, 3], "def_end_pos": [120, 6]}, {"full_name": "Fin.sum_univ_eq_sum_range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/BigOperators.lean", "def_pos": [157, 3], "def_end_pos": [157, 14]}]], "state_before": "case neg\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : AddCommMonoid S\nf : \u2115 \u2192 R \u2192 S\nhf : \u2200 (i : \u2115), f i 0 = 0\nn : \u2115\np : R[X]\nhn : degree p < \u2191n\nhp : \u00acp = 0\n\u22a2 \u2211 i : Fin n, f (\u2191i) (coeff p \u2191i) = sum p f", "state_after": "no goals"}, {"tactic": "rw [hp, sum_zero_index, Finset.sum_eq_zero]", "annotated_tactic": ["rw [hp, <a>sum_zero_index</a>, <a>Finset.sum_eq_zero</a>]", [{"full_name": "Polynomial.sum_zero_index", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [998, 9], "def_end_pos": [998, 23]}, {"full_name": "Finset.sum_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [387, 3], "def_end_pos": [387, 14]}]], "state_before": "case pos\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : AddCommMonoid S\nf : \u2115 \u2192 R \u2192 S\nhf : \u2200 (i : \u2115), f i 0 = 0\nn : \u2115\np : R[X]\nhn : degree p < \u2191n\nhp : p = 0\n\u22a2 \u2211 i : Fin n, f (\u2191i) (coeff p \u2191i) = sum p f", "state_after": "case pos\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : AddCommMonoid S\nf : \u2115 \u2192 R \u2192 S\nhf : \u2200 (i : \u2115), f i 0 = 0\nn : \u2115\np : R[X]\nhn : degree p < \u2191n\nhp : p = 0\n\u22a2 \u2200 x \u2208 univ, f (\u2191x) (coeff 0 \u2191x) = 0"}, {"tactic": "intro i _", "annotated_tactic": ["intro i _", []], "state_before": "case pos\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : AddCommMonoid S\nf : \u2115 \u2192 R \u2192 S\nhf : \u2200 (i : \u2115), f i 0 = 0\nn : \u2115\np : R[X]\nhn : degree p < \u2191n\nhp : p = 0\n\u22a2 \u2200 x \u2208 univ, f (\u2191x) (coeff 0 \u2191x) = 0", "state_after": "case pos\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : AddCommMonoid S\nf : \u2115 \u2192 R \u2192 S\nhf : \u2200 (i : \u2115), f i 0 = 0\nn : \u2115\np : R[X]\nhn : degree p < \u2191n\nhp : p = 0\ni : Fin n\na\u271d : i \u2208 univ\n\u22a2 f (\u2191i) (coeff 0 \u2191i) = 0"}, {"tactic": "exact hf i", "annotated_tactic": ["exact hf i", []], "state_before": "case pos\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : AddCommMonoid S\nf : \u2115 \u2192 R \u2192 S\nhf : \u2200 (i : \u2115), f i 0 = 0\nn : \u2115\np : R[X]\nhn : degree p < \u2191n\nhp : p = 0\ni : Fin n\na\u271d : i \u2208 univ\n\u22a2 f (\u2191i) (coeff 0 \u2191i) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/Count.lean", "full_name": "MeasureTheory.Measure.count_ne_zero", "start": [148, 1], "end": [150, 21], "traced_tactics": [{"tactic": "rw [Ne.def, count_eq_zero_iff]", "annotated_tactic": ["rw [<a>Ne.def</a>, <a>count_eq_zero_iff</a>]", [{"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "MeasureTheory.Measure.count_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Measure/Count.lean", "def_pos": [139, 9], "def_end_pos": [139, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type ?u.21872\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ns : Set \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nhs' : Set.Nonempty s\n\u22a2 \u2191\u2191count s \u2260 0", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type ?u.21872\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ns : Set \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nhs' : Set.Nonempty s\n\u22a2 \u00acs = \u2205"}, {"tactic": "exact hs'.ne_empty", "annotated_tactic": ["exact hs'.ne_empty", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type ?u.21872\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ns : Set \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nhs' : Set.Nonempty s\n\u22a2 \u00acs = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Test.lean", "full_name": "induction_1pxpownlt1pnx", "start": [920, 1], "end": [925, 41], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "x : \u211d\nn : \u2115\nh\u2080 : -1 < x\nh\u2081 : 0 < n\n\u22a2 1 + \u2191n * x \u2264 (1 + x) ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.card_support_ne_one", "start": [595, 1], "end": [598, 53], "traced_tactics": [{"tactic": "by_cases h : f = 1", "annotated_tactic": ["by_cases h : f = 1", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\n\u22a2 (support f).card \u2260 1", "state_after": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\nh : f = 1\n\u22a2 (support f).card \u2260 1\n\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\nh : \u00acf = 1\n\u22a2 (support f).card \u2260 1"}, {"tactic": "exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one", "annotated_tactic": ["exact <a>ne_of_eq_of_ne</a> (card_support_eq_zero.mpr h) <a>zero_ne_one</a>", [{"full_name": "ne_of_eq_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [532, 7], "def_end_pos": [532, 21]}, {"full_name": "zero_ne_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [55, 15], "def_end_pos": [55, 26]}]], "state_before": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\nh : f = 1\n\u22a2 (support f).card \u2260 1", "state_after": "no goals"}, {"tactic": "exact ne_of_gt (one_lt_card_support_of_ne_one h)", "annotated_tactic": ["exact <a>ne_of_gt</a> (<a>one_lt_card_support_of_ne_one</a> h)", [{"full_name": "ne_of_gt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [98, 9], "def_end_pos": [98, 17]}, {"full_name": "Equiv.Perm.one_lt_card_support_of_ne_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [587, 9], "def_end_pos": [587, 38]}]], "state_before": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\nh : \u00acf = 1\n\u22a2 (support f).card \u2260 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "full_name": "Real.logb_le_iff_le_rpow_of_base_lt_one", "start": [313, 1], "end": [314, 101], "traced_tactics": [{"tactic": "rw [\u2190 rpow_le_rpow_left_iff_of_base_lt_one b_pos b_lt_one, rpow_logb b_pos (b_ne_one b_lt_one) hx]", "annotated_tactic": ["rw [\u2190 <a>rpow_le_rpow_left_iff_of_base_lt_one</a> b_pos b_lt_one, <a>rpow_logb</a> b_pos (<a>b_ne_one</a> b_lt_one) hx]", [{"full_name": "Real.rpow_le_rpow_left_iff_of_base_lt_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "def_pos": [664, 9], "def_end_pos": [664, 45]}, {"full_name": "Real.rpow_logb", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "def_pos": [141, 9], "def_end_pos": [141, 18]}, {"full_name": "_private.\u00ab.lake\u00bb.packages.mathlib.Mathlib.Analysis.SpecialFunctions.Log.Base.0.Real.b_ne_one", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "def_pos": [294, 17], "def_end_pos": [294, 25]}]], "state_before": "b x y : \u211d\nb_pos : 0 < b\nb_lt_one : b < 1\nhx : 0 < x\n\u22a2 logb b x \u2264 y \u2194 b ^ y \u2264 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Classes/SatisfiesM.lean", "full_name": "SatisfiesM.seqLeft", "start": [109, 11], "end": [112, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Normed/Group/Basic.lean", "full_name": "AntilipschitzWith.le_mul_norm_div", "start": [2040, 1], "end": [2041, 82], "traced_tactics": [{"tactic": "simp [\u2190 dist_eq_norm_div, hf.le_mul_dist x y]", "annotated_tactic": ["simp [\u2190 <a>dist_eq_norm_div</a>, hf.le_mul_dist x y]", [{"full_name": "dist_eq_norm_div", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [401, 9], "def_end_pos": [401, 25]}]], "state_before": "\ud835\udcd5 : Type u_1\n\ud835\udd5c : Type u_2\n\u03b1 : Type u_3\n\u03b9 : Type u_4\n\u03ba : Type u_5\nE : Type u_6\nF : Type u_7\nG : Type u_8\ninst\u271d\u00b2 : SeminormedCommGroup E\ninst\u271d\u00b9 : SeminormedCommGroup F\na a\u2081 a\u2082 b b\u2081 b\u2082 : E\nr r\u2081 r\u2082 : \u211d\ninst\u271d : PseudoEMetricSpace \u03b1\nK Kf Kg : \u211d\u22650\nf\u271d g : \u03b1 \u2192 E\nf : E \u2192 F\nhf : AntilipschitzWith K f\nx y : E\n\u22a2 \u2016x / y\u2016 \u2264 \u2191K * \u2016f x / f y\u2016", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "mul_lt_of_lt_of_le_one_of_nonneg", "start": [772, 1], "end": [774, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "full_name": "SeminormFamily.basisSets_add", "start": [121, 1], "end": [127, 33], "traced_tactics": [{"tactic": "rcases p.basisSets_iff.mp hU with \u27e8s, r, hr, hU\u27e9", "annotated_tactic": ["rcases p.basisSets_iff.mp hU with \u27e8s, r, hr, hU\u27e9", []], "state_before": "\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nU : Set E\nhU : U \u2208 basisSets p\n\u22a2 \u2203 V \u2208 basisSets p, V + V \u2286 U", "state_after": "case intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nU : Set E\nhU\u271d : U \u2208 basisSets p\ns : Finset \u03b9\nr : \u211d\nhr : 0 < r\nhU : U = ball (Finset.sup s p) 0 r\n\u22a2 \u2203 V \u2208 basisSets p, V + V \u2286 U"}, {"tactic": "use (s.sup p).ball 0 (r / 2)", "annotated_tactic": ["use (s.sup p).<a>ball</a> 0 (r / 2)", [{"full_name": "Seminorm.ball", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [662, 5], "def_end_pos": [662, 9]}]], "state_before": "case intro.intro.intro\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nU : Set E\nhU\u271d : U \u2208 basisSets p\ns : Finset \u03b9\nr : \u211d\nhr : 0 < r\nhU : U = ball (Finset.sup s p) 0 r\n\u22a2 \u2203 V \u2208 basisSets p, V + V \u2286 U", "state_after": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nU : Set E\nhU\u271d : U \u2208 basisSets p\ns : Finset \u03b9\nr : \u211d\nhr : 0 < r\nhU : U = ball (Finset.sup s p) 0 r\n\u22a2 ball (Finset.sup s p) 0 (r / 2) \u2208 basisSets p \u2227 ball (Finset.sup s p) 0 (r / 2) + ball (Finset.sup s p) 0 (r / 2) \u2286 U"}, {"tactic": "refine' \u27e8p.basisSets_mem s (div_pos hr zero_lt_two), _\u27e9", "annotated_tactic": ["refine' \u27e8p.basisSets_mem s (<a>div_pos</a> hr <a>zero_lt_two</a>), _\u27e9", [{"full_name": "div_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [90, 9], "def_end_pos": [90, 16]}, {"full_name": "zero_lt_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [71, 15], "def_end_pos": [71, 26]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nU : Set E\nhU\u271d : U \u2208 basisSets p\ns : Finset \u03b9\nr : \u211d\nhr : 0 < r\nhU : U = ball (Finset.sup s p) 0 r\n\u22a2 ball (Finset.sup s p) 0 (r / 2) \u2208 basisSets p \u2227 ball (Finset.sup s p) 0 (r / 2) + ball (Finset.sup s p) 0 (r / 2) \u2286 U", "state_after": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nU : Set E\nhU\u271d : U \u2208 basisSets p\ns : Finset \u03b9\nr : \u211d\nhr : 0 < r\nhU : U = ball (Finset.sup s p) 0 r\n\u22a2 ball (Finset.sup s p) 0 (r / 2) + ball (Finset.sup s p) 0 (r / 2) \u2286 U"}, {"tactic": "refine' Set.Subset.trans (ball_add_ball_subset (s.sup p) (r / 2) (r / 2) 0 0) _", "annotated_tactic": ["refine' <a>Set.Subset.trans</a> (<a>ball_add_ball_subset</a> (s.sup p) (r / 2) (r / 2) 0 0) _", [{"full_name": "Set.Subset.trans", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [343, 9], "def_end_pos": [343, 21]}, {"full_name": "Seminorm.ball_add_ball_subset", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Seminorm.lean", "def_pos": [781, 9], "def_end_pos": [781, 29]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nU : Set E\nhU\u271d : U \u2208 basisSets p\ns : Finset \u03b9\nr : \u211d\nhr : 0 < r\nhU : U = ball (Finset.sup s p) 0 r\n\u22a2 ball (Finset.sup s p) 0 (r / 2) + ball (Finset.sup s p) 0 (r / 2) \u2286 U", "state_after": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nU : Set E\nhU\u271d : U \u2208 basisSets p\ns : Finset \u03b9\nr : \u211d\nhr : 0 < r\nhU : U = ball (Finset.sup s p) 0 r\n\u22a2 ball (Finset.sup s p) (0 + 0) (r / 2 + r / 2) \u2286 U"}, {"tactic": "rw [hU, add_zero, add_halves']", "annotated_tactic": ["rw [hU, <a>add_zero</a>, <a>add_halves'</a>]", [{"full_name": "add_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [479, 3], "def_end_pos": [479, 14]}, {"full_name": "add_halves'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharZero/Lemmas.lean", "def_pos": [176, 9], "def_end_pos": [176, 20]}]], "state_before": "case h\n\ud835\udd5c : Type u_1\n\ud835\udd5c\u2082 : Type u_2\n\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\nF : Type u_6\nG : Type u_7\n\u03b9 : Type u_8\n\u03b9' : Type u_9\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\nU : Set E\nhU\u271d : U \u2208 basisSets p\ns : Finset \u03b9\nr : \u211d\nhr : 0 < r\nhU : U = ball (Finset.sup s p) 0 r\n\u22a2 ball (Finset.sup s p) (0 + 0) (r / 2 + r / 2) \u2286 U", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Sub/Defs.lean", "full_name": "AddLECancellable.le_add_tsub_swap", "start": [201, 11], "end": [202, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Polynomial/Content.lean", "full_name": "Polynomial.content_eq_zero_iff", "start": [158, 1], "end": [168, 13], "traced_tactics": [{"tactic": "rw [content, Finset.gcd_eq_zero_iff]", "annotated_tactic": ["rw [<a>content</a>, <a>Finset.gcd_eq_zero_iff</a>]", [{"full_name": "Polynomial.content", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [79, 5], "def_end_pos": [79, 12]}, {"full_name": "Finset.gcd_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GCDMonoid/Finset.lean", "def_pos": [210, 9], "def_end_pos": [210, 24]}]], "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\n\u22a2 content p = 0 \u2194 p = 0", "state_after": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\n\u22a2 (\u2200 x \u2208 support p, coeff p x = 0) \u2194 p = 0"}, {"tactic": "constructor <;> intro h", "annotated_tactic": ["constructor <;> intro h", []], "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\n\u22a2 (\u2200 x \u2208 support p, coeff p x = 0) \u2194 p = 0", "state_after": "case mp\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\n\u22a2 p = 0\n\ncase mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : p = 0\n\u22a2 \u2200 x \u2208 support p, coeff p x = 0"}, {"tactic": "ext n", "annotated_tactic": ["ext n", []], "state_before": "case mp\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\n\u22a2 p = 0", "state_after": "case mp.a\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\n\u22a2 coeff p n = coeff 0 n"}, {"tactic": "by_cases h0 : n \u2208 p.support", "annotated_tactic": ["by_cases h0 : n \u2208 p.support", []], "state_before": "case mp.a\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\n\u22a2 coeff p n = coeff 0 n", "state_after": "case pos\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\nh0 : n \u2208 support p\n\u22a2 coeff p n = coeff 0 n\n\ncase neg\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\nh0 : n \u2209 support p\n\u22a2 coeff p n = coeff 0 n"}, {"tactic": "rw [h n h0, coeff_zero]", "annotated_tactic": ["rw [h n h0, <a>coeff_zero</a>]", [{"full_name": "Polynomial.coeff_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [696, 9], "def_end_pos": [696, 19]}]], "state_before": "case pos\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\nh0 : n \u2208 support p\n\u22a2 coeff p n = coeff 0 n", "state_after": "no goals"}, {"tactic": "rw [mem_support_iff] at h0", "annotated_tactic": ["rw [<a>mem_support_iff</a>] at h0", [{"full_name": "Polynomial.mem_support_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [733, 9], "def_end_pos": [733, 24]}]], "state_before": "case neg\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\nh0 : n \u2209 support p\n\u22a2 coeff p n = coeff 0 n", "state_after": "case neg\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\nh0 : \u00accoeff p n \u2260 0\n\u22a2 coeff p n = coeff 0 n"}, {"tactic": "push_neg at h0", "annotated_tactic": ["push_neg at h0", []], "state_before": "case neg\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\nh0 : \u00accoeff p n \u2260 0\n\u22a2 coeff p n = coeff 0 n", "state_after": "case neg\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\nh0 : coeff p n = 0\n\u22a2 coeff p n = coeff 0 n"}, {"tactic": "simp [h0]", "annotated_tactic": ["simp [h0]", []], "state_before": "case neg\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u2200 x \u2208 support p, coeff p x = 0\nn : \u2115\nh0 : coeff p n = 0\n\u22a2 coeff p n = coeff 0 n", "state_after": "no goals"}, {"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : p = 0\n\u22a2 \u2200 x \u2208 support p, coeff p x = 0", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : p = 0\nx : \u2115\n\u22a2 x \u2208 support p \u2192 coeff p x = 0"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : p = 0\nx : \u2115\n\u22a2 x \u2208 support p \u2192 coeff p x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "AddMonoidHom.coe_addMonoidHom_mkRingHomOfMulSelfOfTwoNeZero", "start": [756, 1], "end": [759, 6], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : IsDomain \u03b1\ninst\u271d : CommRing \u03b2\nf : \u03b2 \u2192+ \u03b1\nh : \u2200 (x : \u03b2), f (x * x) = f x * f x\nh_two : 2 \u2260 0\nh_one : f 1 = 1\n\u22a2 \u2191(mkRingHomOfMulSelfOfTwoNeZero f h h_two h_one) = f", "state_after": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : IsDomain \u03b1\ninst\u271d : CommRing \u03b2\nf : \u03b2 \u2192+ \u03b1\nh : \u2200 (x : \u03b2), f (x * x) = f x * f x\nh_two : 2 \u2260 0\nh_one : f 1 = 1\nx\u271d : \u03b2\n\u22a2 \u2191(mkRingHomOfMulSelfOfTwoNeZero f h h_two h_one) x\u271d = f x\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : CommRing \u03b1\ninst\u271d\u00b9 : IsDomain \u03b1\ninst\u271d : CommRing \u03b2\nf : \u03b2 \u2192+ \u03b1\nh : \u2200 (x : \u03b2), f (x * x) = f x * f x\nh_two : 2 \u2260 0\nh_one : f 1 = 1\nx\u271d : \u03b2\n\u22a2 \u2191(mkRingHomOfMulSelfOfTwoNeZero f h h_two h_one) x\u271d = f x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "vadd_left_mem_affineSpan_pair", "start": [1355, 1], "end": [1358, 29], "traced_tactics": [{"tactic": "rw [vadd_mem_iff_mem_direction _ (left_mem_affineSpan_pair _ _ _), direction_affineSpan,\n  mem_vectorSpan_pair_rev]", "annotated_tactic": ["rw [<a>vadd_mem_iff_mem_direction</a> _ (<a>left_mem_affineSpan_pair</a> _ _ _), <a>direction_affineSpan</a>,\n    <a>mem_vectorSpan_pair_rev</a>]", [{"full_name": "AffineSubspace.vadd_mem_iff_mem_direction", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [267, 9], "def_end_pos": [267, 35]}, {"full_name": "left_mem_affineSpan_pair", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [1315, 9], "def_end_pos": [1315, 33]}, {"full_name": "direction_affineSpan", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [560, 9], "def_end_pos": [560, 29]}, {"full_name": "mem_vectorSpan_pair_rev", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "def_pos": [1303, 9], "def_end_pos": [1303, 32]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b3 : Ring k\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module k V\ninst\u271d : AffineSpace V P\n\u03b9 : Type u_4\np\u2081 p\u2082 : P\nv : V\n\u22a2 v +\u1d65 p\u2081 \u2208 affineSpan k {p\u2081, p\u2082} \u2194 \u2203 r, r \u2022 (p\u2082 -\u1d65 p\u2081) = v", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/Separation.lean", "full_name": "SeparationQuotient.map_mk", "start": [323, 1], "end": [324, 56], "traced_tactics": [{"tactic": "rw [map, lift'_mk (uniformContinuous_mk.comp h)]", "annotated_tactic": ["rw [<a>map</a>, <a>lift'_mk</a> (uniformContinuous_mk.comp h)]", [{"full_name": "SeparationQuotient.map", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Separation.lean", "def_pos": [320, 5], "def_end_pos": [320, 8]}, {"full_name": "SeparationQuotient.lift'_mk", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Separation.lean", "def_pos": [308, 9], "def_end_pos": [308, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b2\nh : UniformContinuous f\na : \u03b1\n\u22a2 map f (mk a) = mk (f a)", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b2\nh : UniformContinuous f\na : \u03b1\n\u22a2 (mk \u2218 f) a = mk (f a)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b2\ninst\u271d : UniformSpace \u03b3\nf : \u03b1 \u2192 \u03b2\nh : UniformContinuous f\na : \u03b1\n\u22a2 (mk \u2218 f) a = mk (f a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Pi.lean", "full_name": "Fintype.piFinset_univ", "start": [115, 1], "end": [119, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Order.lean", "full_name": "Fintype.prod_eq_one_iff_of_le_one", "start": [775, 1], "end": [777, 92], "traced_tactics": [{"tactic": "simp [Function.funext_iff]", "annotated_tactic": ["simp [<a>Function.funext_iff</a>]", [{"full_name": "Function.funext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nM : Type u_4\nN : Type u_5\nG : Type u_6\nk : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : OrderedCommMonoid M\nf : \u03b9 \u2192 M\nhf : f \u2264 1\n\u22a2 (\u2200 i \u2208 Finset.univ, f i = 1) \u2194 f = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Opposite.lean", "full_name": "Opposite.equivToOpposite_coe", "start": [97, 1], "end": [98, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.union_smul_inter_subset_union", "start": [1528, 1], "end": [1529, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Chain.lean", "full_name": "List.Chain'.cons_of_le", "start": [446, 1], "end": [469, 28], "traced_tactics": [{"tactic": "simp only [List.chain'_singleton]", "annotated_tactic": ["simp only [<a>List.chain'_singleton</a>]", [{"full_name": "List.chain'_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Chain.lean", "def_pos": [197, 9], "def_end_pos": [197, 25]}]], "state_before": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b : \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\nas : List \u03b1\nha : Chain' (fun x x_1 => x > x_1) (a :: as)\nhm : Chain' (fun x x_1 => x > x_1) []\nhmas : [] \u2264 as\n\u22a2 Chain' (fun x x_1 => x > x_1) [a]", "state_after": "no goals"}, {"tactic": "apply hm.cons", "annotated_tactic": ["apply hm.cons", []], "state_before": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\nas : List \u03b1\nha : Chain' (fun x x_1 => x > x_1) (a :: as)\nb : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\nhmas : b :: bs \u2264 as\n\u22a2 Chain' (fun x x_1 => x > x_1) (a :: b :: bs)", "state_after": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\nas : List \u03b1\nha : Chain' (fun x x_1 => x > x_1) (a :: as)\nb : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\nhmas : b :: bs \u2264 as\n\u22a2 a > b"}, {"tactic": "simp only [le_iff_lt_or_eq, or_false] at hmas", "annotated_tactic": ["simp only [<a>le_iff_lt_or_eq</a>, <a>or_false</a>] at hmas", [{"full_name": "le_iff_lt_or_eq", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [226, 9], "def_end_pos": [226, 24]}, {"full_name": "or_false", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [113, 17], "def_end_pos": [113, 25]}]], "state_before": "case cons.nil\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\nha : Chain' (fun x x_1 => x > x_1) [a]\nhmas : b :: bs \u2264 []\n\u22a2 a > b", "state_after": "case cons.nil\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\nha : Chain' (fun x x_1 => x > x_1) [a]\nhmas : b :: bs < []\n\u22a2 a > b"}, {"tactic": "rw [List.chain'_cons] at ha", "annotated_tactic": ["rw [<a>List.chain'_cons</a>] at ha", [{"full_name": "List.chain'_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Chain.lean", "def_pos": [202, 9], "def_end_pos": [202, 20]}]], "state_before": "case cons.cons\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : Chain' (fun x x_1 => x > x_1) (a :: a' :: as)\nhmas : b :: bs \u2264 a' :: as\n\u22a2 a > b", "state_after": "case cons.cons\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs \u2264 a' :: as\n\u22a2 a > b"}, {"tactic": "refine gt_of_gt_of_ge ha.1 ?_", "annotated_tactic": ["refine <a>gt_of_gt_of_ge</a> ha.1 ?_", [{"full_name": "gt_of_gt_of_ge", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [123, 9], "def_end_pos": [123, 23]}]], "state_before": "case cons.cons\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs \u2264 a' :: as\n\u22a2 a > b", "state_after": "case cons.cons\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs \u2264 a' :: as\n\u22a2 a' \u2265 b"}, {"tactic": "rw [le_iff_lt_or_eq] at hmas", "annotated_tactic": ["rw [<a>le_iff_lt_or_eq</a>] at hmas", [{"full_name": "le_iff_lt_or_eq", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [226, 9], "def_end_pos": [226, 24]}]], "state_before": "case cons.cons\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs \u2264 a' :: as\n\u22a2 a' \u2265 b", "state_after": "case cons.cons\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs < a' :: as \u2228 b :: bs = a' :: as\n\u22a2 a' \u2265 b"}, {"tactic": "cases' hmas with hmas hmas", "annotated_tactic": ["cases' hmas with hmas hmas", []], "state_before": "case cons.cons\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs < a' :: as \u2228 b :: bs = a' :: as\n\u22a2 a' \u2265 b", "state_after": "case cons.cons.inl\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs < a' :: as\n\u22a2 a' \u2265 b\n\ncase cons.cons.inr\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs = a' :: as\n\u22a2 a' \u2265 b"}, {"tactic": "by_contra! hh", "annotated_tactic": ["by_contra! hh", []], "state_before": "case cons.cons.inl\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs < a' :: as\n\u22a2 a' \u2265 b", "state_after": "case cons.cons.inl\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs < a' :: as\nhh : a' < b\n\u22a2 False"}, {"tactic": "rw [\u2190 not_le] at hmas", "annotated_tactic": ["rw [\u2190 <a>not_le</a>] at hmas", [{"full_name": "not_le", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [367, 9], "def_end_pos": [367, 15]}]], "state_before": "case cons.cons.inl\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs < a' :: as\nhh : a' < b\n\u22a2 False", "state_after": "case cons.cons.inl\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : \u00aca' :: as \u2264 b :: bs\nhh : a' < b\n\u22a2 False"}, {"tactic": "apply hmas", "annotated_tactic": ["apply hmas", []], "state_before": "case cons.cons.inl\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : \u00aca' :: as \u2264 b :: bs\nhh : a' < b\n\u22a2 False", "state_after": "case cons.cons.inl\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : \u00aca' :: as \u2264 b :: bs\nhh : a' < b\n\u22a2 a' :: as \u2264 b :: bs"}, {"tactic": "apply le_of_lt", "annotated_tactic": ["apply <a>le_of_lt</a>", [{"full_name": "le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 17]}]], "state_before": "case cons.cons.inl\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : \u00aca' :: as \u2264 b :: bs\nhh : a' < b\n\u22a2 a' :: as \u2264 b :: bs", "state_after": "case cons.cons.inl.a\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : \u00aca' :: as \u2264 b :: bs\nhh : a' < b\n\u22a2 a' :: as < b :: bs"}, {"tactic": "exact (List.lt_iff_lex_lt _ _).mp (List.lt.head _ _ hh)", "annotated_tactic": ["exact (<a>List.lt_iff_lex_lt</a> _ _).<a>mp</a> (<a>List.lt.head</a> _ _ hh)", [{"full_name": "List.lt_iff_lex_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Lex.lean", "def_pos": [201, 9], "def_end_pos": [201, 22]}, {"full_name": "Iff.mp", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [118, 3], "def_end_pos": [118, 5]}, {"full_name": "List.lt.head", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [723, 5], "def_end_pos": [723, 9]}]], "state_before": "case cons.cons.inl.a\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : \u00aca' :: as \u2264 b :: bs\nhh : a' < b\n\u22a2 a' :: as < b :: bs", "state_after": "no goals"}, {"tactic": "simp only [List.cons.injEq] at hmas", "annotated_tactic": ["simp only [List.cons.injEq] at hmas", []], "state_before": "case cons.cons.inr\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b :: bs = a' :: as\n\u22a2 a' \u2265 b", "state_after": "case cons.cons.inr\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b = a' \u2227 bs = as\n\u22a2 a' \u2265 b"}, {"tactic": "rw [ge_iff_le, le_iff_lt_or_eq]", "annotated_tactic": ["rw [<a>ge_iff_le</a>, <a>le_iff_lt_or_eq</a>]", [{"full_name": "ge_iff_le", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1935, 17], "def_end_pos": [1935, 26]}, {"full_name": "le_iff_lt_or_eq", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [226, 9], "def_end_pos": [226, 24]}]], "state_before": "case cons.cons.inr\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b = a' \u2227 bs = as\n\u22a2 a' \u2265 b", "state_after": "case cons.cons.inr\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b = a' \u2227 bs = as\n\u22a2 b < a' \u2228 b = a'"}, {"tactic": "exact Or.inr hmas.1", "annotated_tactic": ["exact <a>Or.inr</a> hmas.1", [{"full_name": "Or.inr", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [532, 5], "def_end_pos": [532, 8]}]], "state_before": "case cons.cons.inr\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na\u271d b\u271d : \u03b1\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nbs : List \u03b1\nhm : Chain' (fun x x_1 => x > x_1) (b :: bs)\na' : \u03b1\nas : List \u03b1\nha : a > a' \u2227 Chain' (fun x x_1 => x > x_1) (a' :: as)\nhmas : b = a' \u2227 bs = as\n\u22a2 b < a' \u2228 b = a'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.coe_trans", "start": [907, 1], "end": [908, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.range_total", "start": [725, 1], "end": [739, 14], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\n\u22a2 LinearMap.range (Finsupp.total \u03b1 M R v) = span R (Set.range v)", "state_after": "case h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\n\u22a2 x \u2208 LinearMap.range (Finsupp.total \u03b1 M R v) \u2194 x \u2208 span R (Set.range v)"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\n\u22a2 x \u2208 LinearMap.range (Finsupp.total \u03b1 M R v) \u2194 x \u2208 span R (Set.range v)", "state_after": "case h.mp\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\n\u22a2 x \u2208 LinearMap.range (Finsupp.total \u03b1 M R v) \u2192 x \u2208 span R (Set.range v)\n\ncase h.mpr\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\n\u22a2 x \u2208 span R (Set.range v) \u2192 x \u2208 LinearMap.range (Finsupp.total \u03b1 M R v)"}, {"tactic": "intro hx", "annotated_tactic": ["intro hx", []], "state_before": "case h.mp\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\n\u22a2 x \u2208 LinearMap.range (Finsupp.total \u03b1 M R v) \u2192 x \u2208 span R (Set.range v)", "state_after": "case h.mp\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nhx : x \u2208 LinearMap.range (Finsupp.total \u03b1 M R v)\n\u22a2 x \u2208 span R (Set.range v)"}, {"tactic": "rw [LinearMap.mem_range] at hx", "annotated_tactic": ["rw [<a>LinearMap.mem_range</a>] at hx", [{"full_name": "LinearMap.mem_range", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [146, 9], "def_end_pos": [146, 18]}]], "state_before": "case h.mp\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nhx : x \u2208 LinearMap.range (Finsupp.total \u03b1 M R v)\n\u22a2 x \u2208 span R (Set.range v)", "state_after": "case h.mp\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nhx : \u2203 y, (Finsupp.total \u03b1 M R v) y = x\n\u22a2 x \u2208 span R (Set.range v)"}, {"tactic": "rcases hx with \u27e8l, hl\u27e9", "annotated_tactic": ["rcases hx with \u27e8l, hl\u27e9", []], "state_before": "case h.mp\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nhx : \u2203 y, (Finsupp.total \u03b1 M R v) y = x\n\u22a2 x \u2208 span R (Set.range v)", "state_after": "case h.mp.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nl : \u03b1 \u2192\u2080 R\nhl : (Finsupp.total \u03b1 M R v) l = x\n\u22a2 x \u2208 span R (Set.range v)"}, {"tactic": "rw [\u2190 hl]", "annotated_tactic": ["rw [\u2190 hl]", []], "state_before": "case h.mp.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nl : \u03b1 \u2192\u2080 R\nhl : (Finsupp.total \u03b1 M R v) l = x\n\u22a2 x \u2208 span R (Set.range v)", "state_after": "case h.mp.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nl : \u03b1 \u2192\u2080 R\nhl : (Finsupp.total \u03b1 M R v) l = x\n\u22a2 (Finsupp.total \u03b1 M R v) l \u2208 span R (Set.range v)"}, {"tactic": "rw [Finsupp.total_apply]", "annotated_tactic": ["rw [<a>Finsupp.total_apply</a>]", [{"full_name": "Finsupp.total_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [666, 9], "def_end_pos": [666, 20]}]], "state_before": "case h.mp.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nl : \u03b1 \u2192\u2080 R\nhl : (Finsupp.total \u03b1 M R v) l = x\n\u22a2 (Finsupp.total \u03b1 M R v) l \u2208 span R (Set.range v)", "state_after": "case h.mp.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nl : \u03b1 \u2192\u2080 R\nhl : (Finsupp.total \u03b1 M R v) l = x\n\u22a2 (sum l fun i a => a \u2022 v i) \u2208 span R (Set.range v)"}, {"tactic": "exact sum_mem fun i _ => Submodule.smul_mem _ _ (subset_span (mem_range_self i))", "annotated_tactic": ["exact <a>sum_mem</a> fun i _ => <a>Submodule.smul_mem</a> _ _ (<a>subset_span</a> (<a>mem_range_self</a> i))", [{"full_name": "sum_mem", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [95, 3], "def_end_pos": [95, 14]}, {"full_name": "Submodule.smul_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [226, 9], "def_end_pos": [226, 17]}, {"full_name": "Submodule.subset_span", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [76, 9], "def_end_pos": [76, 20]}, {"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "case h.mp.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\nl : \u03b1 \u2192\u2080 R\nhl : (Finsupp.total \u03b1 M R v) l = x\n\u22a2 (sum l fun i a => a \u2022 v i) \u2208 span R (Set.range v)", "state_after": "no goals"}, {"tactic": "apply span_le.2", "annotated_tactic": ["apply <a>span_le</a>.2", [{"full_name": "Submodule.span_le", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [79, 9], "def_end_pos": [79, 16]}]], "state_before": "case h.mpr\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\n\u22a2 x \u2208 span R (Set.range v) \u2192 x \u2208 LinearMap.range (Finsupp.total \u03b1 M R v)", "state_after": "case h.mpr.a\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\n\u22a2 Set.range v \u2286 \u2191(LinearMap.range (Finsupp.total \u03b1 M R v))"}, {"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "case h.mpr.a\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx : M\n\u22a2 Set.range v \u2286 \u2191(LinearMap.range (Finsupp.total \u03b1 M R v))", "state_after": "case h.mpr.a\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx\u271d x : M\nhx : x \u2208 Set.range v\n\u22a2 x \u2208 \u2191(LinearMap.range (Finsupp.total \u03b1 M R v))"}, {"tactic": "rcases hx with \u27e8i, hi\u27e9", "annotated_tactic": ["rcases hx with \u27e8i, hi\u27e9", []], "state_before": "case h.mpr.a\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx\u271d x : M\nhx : x \u2208 Set.range v\n\u22a2 x \u2208 \u2191(LinearMap.range (Finsupp.total \u03b1 M R v))", "state_after": "case h.mpr.a.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx\u271d x : M\ni : \u03b1\nhi : v i = x\n\u22a2 x \u2208 \u2191(LinearMap.range (Finsupp.total \u03b1 M R v))"}, {"tactic": "rw [SetLike.mem_coe, LinearMap.mem_range]", "annotated_tactic": ["rw [<a>SetLike.mem_coe</a>, <a>LinearMap.mem_range</a>]", [{"full_name": "SetLike.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [180, 9], "def_end_pos": [180, 16]}, {"full_name": "LinearMap.mem_range", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [146, 9], "def_end_pos": [146, 18]}]], "state_before": "case h.mpr.a.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx\u271d x : M\ni : \u03b1\nhi : v i = x\n\u22a2 x \u2208 \u2191(LinearMap.range (Finsupp.total \u03b1 M R v))", "state_after": "case h.mpr.a.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx\u271d x : M\ni : \u03b1\nhi : v i = x\n\u22a2 \u2203 y, (Finsupp.total \u03b1 M R v) y = x"}, {"tactic": "use Finsupp.single i 1", "annotated_tactic": ["use <a>Finsupp.single</a> i 1", [{"full_name": "Finsupp.single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [286, 5], "def_end_pos": [286, 11]}]], "state_before": "case h.mpr.a.intro\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx\u271d x : M\ni : \u03b1\nhi : v i = x\n\u22a2 \u2203 y, (Finsupp.total \u03b1 M R v) y = x", "state_after": "case h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx\u271d x : M\ni : \u03b1\nhi : v i = x\n\u22a2 (Finsupp.total \u03b1 M R v) (single i 1) = x"}, {"tactic": "simp [hi]", "annotated_tactic": ["simp [hi]", []], "state_before": "case h\n\u03b1 : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring S\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : AddCommMonoid N\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R P\n\u03b1' : Type u_7\nM' : Type u_8\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nv : \u03b1 \u2192 M\nv' : \u03b1' \u2192 M'\nx\u271d x : M\ni : \u03b1\nhi : v i = x\n\u22a2 (Finsupp.total \u03b1 M R v) (single i 1) = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "measurableSet_le'", "start": [595, 1], "end": [596, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.insert_diff_of_not_mem", "start": [1970, 1], "end": [1979, 19], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\n\u22a2 insert a s \\ t = insert a (s \\ t)", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\n\u22a2 x \u2208 insert a s \\ t \u2194 x \u2208 insert a (s \\ t)"}, {"tactic": "by_cases h' : x \u2208 t", "annotated_tactic": ["by_cases h' : x \u2208 t", []], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\n\u22a2 x \u2208 insert a s \\ t \u2194 x \u2208 insert a (s \\ t)", "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : x \u2208 t\n\u22a2 x \u2208 insert a s \\ t \u2194 x \u2208 insert a (s \\ t)\n\ncase neg\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : x \u2209 t\n\u22a2 x \u2208 insert a s \\ t \u2194 x \u2208 insert a (s \\ t)"}, {"tactic": "have : x \u2260 a := by\n  intro H\n  rw [H] at h'\n  exact h h'", "annotated_tactic": ["have : x \u2260 a := by\n        intro H\n        rw [H] at h'\n        exact h h'", []], "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : x \u2208 t\n\u22a2 x \u2208 insert a s \\ t \u2194 x \u2208 insert a (s \\ t)", "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : x \u2208 t\nthis : x \u2260 a\n\u22a2 x \u2208 insert a s \\ t \u2194 x \u2208 insert a (s \\ t)"}, {"tactic": "simp [h, h', this]", "annotated_tactic": ["simp [h, h', this]", []], "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : x \u2208 t\nthis : x \u2260 a\n\u22a2 x \u2208 insert a s \\ t \u2194 x \u2208 insert a (s \\ t)", "state_after": "no goals"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : x \u2208 t\n\u22a2 x \u2260 a", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : x \u2208 t\nH : x = a\n\u22a2 False"}, {"tactic": "rw [H] at h'", "annotated_tactic": ["rw [H] at h'", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : x \u2208 t\nH : x = a\n\u22a2 False", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : a \u2208 t\nH : x = a\n\u22a2 False"}, {"tactic": "exact h h'", "annotated_tactic": ["exact h h'", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : a \u2208 t\nH : x = a\n\u22a2 False", "state_after": "no goals"}, {"tactic": "simp [h, h']", "annotated_tactic": ["simp [h, h']", []], "state_before": "case neg\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s : Set \u03b1\nh : a \u2209 t\nx : \u03b1\nh' : x \u2209 t\n\u22a2 x \u2208 insert a s \\ t \u2194 x \u2208 insert a (s \\ t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.diff_singleton_subset_iff", "start": [1931, 1], "end": [1933, 24], "traced_tactics": [{"tactic": "rw [\u2190 union_singleton, union_comm]", "annotated_tactic": ["rw [\u2190 <a>union_singleton</a>, <a>union_comm</a>]", [{"full_name": "Set.union_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1317, 9], "def_end_pos": [1317, 24]}, {"full_name": "Set.union_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [756, 9], "def_end_pos": [756, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u : Set \u03b1\nx : \u03b1\ns t : Set \u03b1\n\u22a2 s \\ {x} \u2286 t \u2194 s \u2286 insert x t", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u : Set \u03b1\nx : \u03b1\ns t : Set \u03b1\n\u22a2 s \\ {x} \u2286 t \u2194 s \u2286 {x} \u222a t"}, {"tactic": "apply diff_subset_iff", "annotated_tactic": ["apply <a>diff_subset_iff</a>", [{"full_name": "Set.diff_subset_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1918, 9], "def_end_pos": [1918, 24]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u : Set \u03b1\nx : \u03b1\ns t : Set \u03b1\n\u22a2 s \\ {x} \u2286 t \u2194 s \u2286 {x} \u222a t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "full_name": "Metric.ball_infDist_subset_compl", "start": [557, 1], "end": [558, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Dynamics/FixedPoints/Basic.lean", "full_name": "Function.bijOn_fixedPoints_comp", "start": [180, 1], "end": [182, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Rat/Order.lean", "full_name": "Rat.nonneg_total", "start": [82, 11], "end": [83, 74], "traced_tactics": [{"tactic": "cases' a with n", "annotated_tactic": ["cases' a with n", []], "state_before": "a b c : \u211a\n\u22a2 Rat.Nonneg a \u2228 Rat.Nonneg (-a)", "state_after": "case mk'\nb c : \u211a\nn : \u2124\nden\u271d : \u2115\nden_nz\u271d : den\u271d \u2260 0\nreduced\u271d : Nat.Coprime (Int.natAbs n) den\u271d\n\u22a2 Rat.Nonneg { num := n, den := den\u271d, den_nz := den_nz\u271d, reduced := reduced\u271d } \u2228\n    Rat.Nonneg (-{ num := n, den := den\u271d, den_nz := den_nz\u271d, reduced := reduced\u271d })"}, {"tactic": "exact Or.imp_right neg_nonneg_of_nonpos (le_total 0 n)", "annotated_tactic": ["exact <a>Or.imp_right</a> <a>neg_nonneg_of_nonpos</a> (<a>le_total</a> 0 n)", [{"full_name": "Or.imp_right", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [161, 9], "def_end_pos": [161, 21]}, {"full_name": "neg_nonneg_of_nonpos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [1224, 15], "def_end_pos": [1224, 35]}, {"full_name": "le_total", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [289, 9], "def_end_pos": [289, 17]}]], "state_before": "case mk'\nb c : \u211a\nn : \u2124\nden\u271d : \u2115\nden_nz\u271d : den\u271d \u2260 0\nreduced\u271d : Nat.Coprime (Int.natAbs n) den\u271d\n\u22a2 Rat.Nonneg { num := n, den := den\u271d, den_nz := den_nz\u271d, reduced := reduced\u271d } \u2228\n    Rat.Nonneg (-{ num := n, den := den\u271d, den_nz := den_nz\u271d, reduced := reduced\u271d })", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finsupp/Order.lean", "full_name": "Finsupp.add_eq_zero_iff", "start": [199, 1], "end": [200, 38], "traced_tactics": [{"tactic": "simp [DFunLike.ext_iff, forall_and]", "annotated_tactic": ["simp [<a>DFunLike.ext_iff</a>, <a>forall_and</a>]", [{"full_name": "DFunLike.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/FunLike/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 16]}, {"full_name": "forall_and", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [189, 9], "def_end_pos": [189, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : CanonicallyOrderedAddCommMonoid \u03b1\nf\u271d g\u271d f g : \u03b9 \u2192\u2080 \u03b1\n\u22a2 f + g = 0 \u2194 f = 0 \u2227 g = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Connected/PathConnected.lean", "full_name": "Path.coe_toContinuousMap", "start": [140, 1], "end": [141, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/TypeTags.lean", "full_name": "toMul_sub", "start": [379, 1], "end": [380, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Finite/Basic.lean", "full_name": "FiniteField.pow_card", "start": [229, 1], "end": [232, 42], "traced_tactics": [{"tactic": "by_cases h : a = 0", "annotated_tactic": ["by_cases h : a = 0", []], "state_before": "K : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\n\u22a2 a ^ q = a", "state_after": "case pos\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\nh : a = 0\n\u22a2 a ^ q = a\n\ncase neg\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\nh : \u00aca = 0\n\u22a2 a ^ q = a"}, {"tactic": "rw [\u2190 Nat.succ_pred_eq_of_pos Fintype.card_pos, pow_succ, Nat.pred_eq_sub_one,\n  pow_card_sub_one_eq_one a h, mul_one]", "annotated_tactic": ["rw [\u2190 <a>Nat.succ_pred_eq_of_pos</a> <a>Fintype.card_pos</a>, <a>pow_succ</a>, <a>Nat.pred_eq_sub_one</a>,\n    <a>pow_card_sub_one_eq_one</a> a h, <a>mul_one</a>]", [{"full_name": "Nat.succ_pred_eq_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [573, 9], "def_end_pos": [573, 28]}, {"full_name": "Fintype.card_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [563, 9], "def_end_pos": [563, 17]}, {"full_name": "pow_succ", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [656, 9], "def_end_pos": [656, 17]}, {"full_name": "Nat.pred_eq_sub_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Defs.lean", "def_pos": [139, 7], "def_end_pos": [139, 22]}, {"full_name": "FiniteField.pow_card_sub_one_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Finite/Basic.lean", "def_pos": [219, 9], "def_end_pos": [219, 32]}, {"full_name": "mul_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [480, 9], "def_end_pos": [480, 16]}]], "state_before": "case neg\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\nh : \u00aca = 0\n\u22a2 a ^ q = a", "state_after": "no goals"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "case pos\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\nh : a = 0\n\u22a2 a ^ q = a", "state_after": "case pos\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\nh : a = 0\n\u22a2 0 ^ q = 0"}, {"tactic": "apply zero_pow Fintype.card_ne_zero", "annotated_tactic": ["apply <a>zero_pow</a> <a>Fintype.card_ne_zero</a>", [{"full_name": "zero_pow", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [159, 15], "def_end_pos": [159, 23]}, {"full_name": "Fintype.card_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [568, 9], "def_end_pos": [568, 21]}]], "state_before": "case pos\nK : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : GroupWithZero K\ninst\u271d : Fintype K\na : K\nh : a = 0\n\u22a2 0 ^ q = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "Irreducible.coprime_iff_not_dvd", "start": [455, 1], "end": [456, 92], "traced_tactics": [{"tactic": "rw [\u2190 isRelPrime_iff_isCoprime, hp.isRelPrime_iff_not_dvd]", "annotated_tactic": ["rw [\u2190 <a>isRelPrime_iff_isCoprime</a>, hp.isRelPrime_iff_not_dvd]", [{"full_name": "isRelPrime_iff_isCoprime", "def_path": ".lake/packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean", "def_pos": [210, 9], "def_end_pos": [210, 40]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : IsBezout R\np n : R\nhp : Irreducible p\n\u22a2 IsCoprime p n \u2194 \u00acp \u2223 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Defs.lean", "full_name": "ContDiffOn.differentiableOn_iteratedFDerivWithin", "start": [1087, 1], "end": [1090, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Prod.lean", "full_name": "Filter.map_const_principal_coprod_map_id_principal", "start": [548, 1], "end": [552, 40], "traced_tactics": [{"tactic": "simp only [map_principal, Filter.coprod, comap_principal, sup_principal, image_singleton,\n  image_id, prod_univ, univ_prod, id]", "annotated_tactic": ["simp only [<a>map_principal</a>, <a>Filter.coprod</a>, <a>comap_principal</a>, <a>sup_principal</a>, <a>image_singleton</a>,\n    <a>image_id</a>, <a>prod_univ</a>, <a>univ_prod</a>, <a>id</a>]", [{"full_name": "Filter.map_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1929, 9], "def_end_pos": [1929, 22]}, {"full_name": "Filter.coprod", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [479, 15], "def_end_pos": [479, 21]}, {"full_name": "Filter.comap_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2302, 9], "def_end_pos": [2302, 24]}, {"full_name": "Filter.sup_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [998, 9], "def_end_pos": [998, 22]}, {"full_name": "Set.image_singleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [335, 9], "def_end_pos": [335, 24]}, {"full_name": "Set.image_id", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [376, 9], "def_end_pos": [376, 17]}, {"full_name": "Set.prod_univ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [101, 9], "def_end_pos": [101, 18]}, {"full_name": "Set.univ_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [98, 9], "def_end_pos": [98, 18]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9\u271d : Sort u_5\nf : Filter \u03b1\u271d\ng : Filter \u03b2\u271d\n\u03b1 : Type u_6\n\u03b2 : Type u_7\n\u03b9 : Type u_8\na : \u03b1\nb : \u03b2\ni : \u03b9\n\u22a2 Filter.coprod (map (fun x => b) (\ud835\udcdf {a})) (map id (\ud835\udcdf {i})) = \ud835\udcdf ({b} \u00d7\u02e2 univ \u222a univ \u00d7\u02e2 {i})", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "full_name": "FreeMonoid.ofList_smul", "start": [295, 1], "end": [297, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/FreeRing.lean", "full_name": "FreeRing.lift_of", "start": [84, 1], "end": [85, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "full_name": "FreeMonoid.of_injective", "start": [149, 1], "end": [149, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteBooleanAlgebra.lean", "full_name": "iSup_inf_iSup", "start": [226, 1], "end": [228, 48], "traced_tactics": [{"tactic": "simp_rw [iSup_inf_eq, inf_iSup_eq, iSup_prod]", "annotated_tactic": ["simp_rw [<a>iSup_inf_eq</a>, <a>inf_iSup_eq</a>, <a>iSup_prod</a>]", [{"full_name": "iSup_inf_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteBooleanAlgebra.lean", "def_pos": [203, 9], "def_end_pos": [203, 20]}, {"full_name": "inf_iSup_eq", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteBooleanAlgebra.lean", "def_pos": [207, 9], "def_end_pos": [207, 20]}, {"full_name": "iSup_prod", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1527, 9], "def_end_pos": [1527, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03ba : \u03b9\u271d \u2192 Sort w'\ninst\u271d : Frame \u03b1\ns t : Set \u03b1\na b : \u03b1\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nf : \u03b9 \u2192 \u03b1\ng : \u03b9' \u2192 \u03b1\n\u22a2 (\u2a06 i, f i) \u2293 \u2a06 j, g j = \u2a06 i, f i.1 \u2293 g i.2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "div_mul_eq_mul_div", "start": [627, 1], "end": [627, 62], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivisionCommMonoid \u03b1\na b c d : \u03b1\n\u22a2 a / b * c = a * c / b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "full_name": "Ordinal.blsub_eq_blsub", "start": [1785, 1], "end": [1788, 38], "traced_tactics": [{"tactic": "rw [blsub_eq_lsub', blsub_eq_lsub']", "annotated_tactic": ["rw [<a>blsub_eq_lsub'</a>, <a>blsub_eq_lsub'</a>]", [{"full_name": "Ordinal.blsub_eq_lsub'", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1780, 9], "def_end_pos": [1780, 23]}, {"full_name": "Ordinal.blsub_eq_lsub'", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Ordinal/Arithmetic.lean", "def_pos": [1780, 9], "def_end_pos": [1780, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\n\u03b9 : Type u\nr r' : \u03b9 \u2192 \u03b9 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b9 r\ninst\u271d : IsWellOrder \u03b9 r'\nf : \u03b9 \u2192 Ordinal.{max u v}\n\u22a2 blsub (type r) (bfamilyOfFamily' r f) = blsub (type r') (bfamilyOfFamily' r' f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Cover.lean", "full_name": "CovBy.Ioc_eq", "start": [418, 1], "end": [419, 53], "traced_tactics": [{"tactic": "rw [\u2190 Ioo_union_right h.lt, h.Ioo_eq, empty_union]", "annotated_tactic": ["rw [\u2190 <a>Ioo_union_right</a> h.lt, h.Ioo_eq, <a>empty_union</a>]", [{"full_name": "Set.Ioo_union_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [874, 9], "def_end_pos": [874, 24]}, {"full_name": "Set.empty_union", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [752, 9], "def_end_pos": [752, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na b c : \u03b1\nh : a \u22d6 b\n\u22a2 Ioc a b = {b}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.takeD_eq_take", "start": [2362, 1], "end": [2364, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subsemigroup/Membership.lean", "full_name": "Subsemigroup.mem_sSup_of_directed_on", "start": [65, 1], "end": [68, 17], "traced_tactics": [{"tactic": "simp only [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk,\n  exists_prop]", "annotated_tactic": ["simp only [<a>sSup_eq_iSup'</a>, <a>mem_iSup_of_directed</a> hS.directed_val, <a>SetCoe.exists</a>, <a>Subtype.coe_mk</a>,\n    <a>exists_prop</a>]", [{"full_name": "sSup_eq_iSup'", "def_path": ".lake/packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [569, 9], "def_end_pos": [569, 22]}, {"full_name": "Subsemigroup.mem_iSup_of_directed", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Membership.lean", "def_pos": [45, 9], "def_end_pos": [45, 29]}, {"full_name": "SetCoe.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [171, 9], "def_end_pos": [171, 22]}, {"full_name": "Subtype.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [99, 9], "def_end_pos": [99, 15]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}]], "state_before": "\u03b9 : Sort u_1\nM : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d : Mul M\nS : Set (Subsemigroup M)\nhS : DirectedOn (fun x x_1 => x \u2264 x_1) S\nx : M\n\u22a2 x \u2208 sSup S \u2194 \u2203 s \u2208 S, x \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Set.pairwiseDisjoint_filter", "start": [2936, 1], "end": [2941, 16], "traced_tactics": [{"tactic": "rintro i - j - h u hi hj x hx", "annotated_tactic": ["rintro i - j - h u hi hj x hx", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\n\u22a2 Set.PairwiseDisjoint s fun x => filter (fun x_1 => f x_1 = x) t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\ni j : \u03b2\nh : i \u2260 j\nu : Finset \u03b1\nhi : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) i\nhj : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) j\nx : \u03b1\nhx : x \u2208 u\n\u22a2 x \u2208 \u22a5"}, {"tactic": "obtain \u27e8-, rfl\u27e9 : x \u2208 t \u2227 f x = i := by simpa using hi hx", "annotated_tactic": ["obtain \u27e8-, rfl\u27e9 : x \u2208 t \u2227 f x = i := by simpa using hi hx", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\ni j : \u03b2\nh : i \u2260 j\nu : Finset \u03b1\nhi : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) i\nhj : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) j\nx : \u03b1\nhx : x \u2208 u\n\u22a2 x \u2208 \u22a5", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\nj : \u03b2\nu : Finset \u03b1\nhj : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) j\nx : \u03b1\nhx : x \u2208 u\nh : f x \u2260 j\nhi : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) (f x)\n\u22a2 x \u2208 \u22a5"}, {"tactic": "obtain \u27e8-, rfl\u27e9 : x \u2208 t \u2227 f x = j := by simpa using hj hx", "annotated_tactic": ["obtain \u27e8-, rfl\u27e9 : x \u2208 t \u2227 f x = j := by simpa using hj hx", []], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\nj : \u03b2\nu : Finset \u03b1\nhj : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) j\nx : \u03b1\nhx : x \u2208 u\nh : f x \u2260 j\nhi : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) (f x)\n\u22a2 x \u2208 \u22a5", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt u : Finset \u03b1\nx : \u03b1\nhx : x \u2208 u\nhi hj : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) (f x)\nh : f x \u2260 f x\n\u22a2 x \u2208 \u22a5"}, {"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt u : Finset \u03b1\nx : \u03b1\nhx : x \u2208 u\nhi hj : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) (f x)\nh : f x \u2260 f x\n\u22a2 x \u2208 \u22a5", "state_after": "no goals"}, {"tactic": "simpa using hi hx", "annotated_tactic": ["simpa using hi hx", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\ni j : \u03b2\nh : i \u2260 j\nu : Finset \u03b1\nhi : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) i\nhj : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) j\nx : \u03b1\nhx : x \u2208 u\n\u22a2 x \u2208 t \u2227 f x = i", "state_after": "no goals"}, {"tactic": "simpa using hj hx", "annotated_tactic": ["simpa using hj hx", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\ninst\u271d\u00b9 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Finset \u03b1\nj : \u03b2\nu : Finset \u03b1\nhj : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) j\nx : \u03b1\nhx : x \u2208 u\nh : f x \u2260 j\nhi : u \u2264 (fun x => filter (fun x_1 => f x_1 = x) t) (f x)\n\u22a2 x \u2208 t \u2227 f x = j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "full_name": "Matrix.SpecialLinearGroup.coe_mul", "start": [158, 1], "end": [159, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/LocalExtr.lean", "full_name": "IsLocalMin.comp_antitone", "start": [229, 8], "end": [231, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.lt_of_ceil_lt", "start": [344, 1], "end": [345, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/LinearMap/Basic.lean", "full_name": "AddMonoidHom.coe_toRatLinearMap", "start": [791, 1], "end": [793, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Sets/Opens.lean", "full_name": "TopologicalSpace.Opens.forall", "start": [81, 1], "end": [82, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/LocalExtr/Rolle.lean", "full_name": "exists_hasDerivAt_eq_zero", "start": [50, 1], "end": [53, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Lattice.lean", "full_name": "Multiset.inf_le", "start": [147, 1], "end": [148, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/SuccPred/Limit.lean", "full_name": "Order.isSuccLimit_toDual_iff", "start": [256, 1], "end": [257, 34], "traced_tactics": [{"tactic": "simp [IsSuccLimit, IsPredLimit]", "annotated_tactic": ["simp [<a>IsSuccLimit</a>, <a>IsPredLimit</a>]", [{"full_name": "Order.IsSuccLimit", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Limit.lean", "def_pos": [42, 5], "def_end_pos": [42, 16]}, {"full_name": "Order.IsPredLimit", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Limit.lean", "def_pos": [244, 5], "def_end_pos": [244, 16]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LT \u03b1\na : \u03b1\n\u22a2 IsSuccLimit (toDual a) \u2194 IsPredLimit a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Pairwise.lean", "full_name": "List.pwFilter_nil", "start": [256, 9], "end": [256, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Fintype.coe_finsetOrderIsoSet", "start": [1107, 1], "end": [1108, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Adjoin.lean", "full_name": "IntermediateField.adjoin_adjoin_comm", "start": [446, 1], "end": [448, 62], "traced_tactics": [{"tactic": "rw [adjoin_adjoin_left, adjoin_adjoin_left, Set.union_comm]", "annotated_tactic": ["rw [<a>adjoin_adjoin_left</a>, <a>adjoin_adjoin_left</a>, <a>Set.union_comm</a>]", [{"full_name": "IntermediateField.adjoin_adjoin_left", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [411, 9], "def_end_pos": [411, 27]}, {"full_name": "IntermediateField.adjoin_adjoin_left", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Adjoin.lean", "def_pos": [411, 9], "def_end_pos": [411, 27]}, {"full_name": "Set.union_comm", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [756, 9], "def_end_pos": [756, 19]}]], "state_before": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS T : Set E\n\u22a2 restrictScalars F (adjoin (\u21a5(adjoin F S)) T) = restrictScalars F (adjoin (\u21a5(adjoin F T)) S)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Separable.lean", "full_name": "Polynomial.Separable.squarefree", "start": [204, 1], "end": [206, 99], "traced_tactics": [{"tactic": "rw [multiplicity.squarefree_iff_multiplicity_le_one p]", "annotated_tactic": ["rw [<a>multiplicity.squarefree_iff_multiplicity_le_one</a> p]", [{"full_name": "multiplicity.squarefree_iff_multiplicity_le_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Squarefree/Basic.lean", "def_pos": [119, 9], "def_end_pos": [119, 43]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\np\u271d q : \u2115\np : R[X]\nhsep : Separable p\n\u22a2 Squarefree p", "state_after": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\np\u271d q : \u2115\np : R[X]\nhsep : Separable p\n\u22a2 \u2200 (x : R[X]), multiplicity x p \u2264 1 \u2228 IsUnit x"}, {"tactic": "exact fun f => or_iff_not_imp_right.mpr fun hunit => multiplicity_le_one_of_separable hunit hsep", "annotated_tactic": ["exact fun f => or_iff_not_imp_right.mpr fun hunit => <a>multiplicity_le_one_of_separable</a> hunit hsep", [{"full_name": "Polynomial.multiplicity_le_one_of_separable", "def_path": ".lake/packages/mathlib/Mathlib/FieldTheory/Separable.lean", "def_pos": [189, 9], "def_end_pos": [189, 41]}]], "state_before": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\np\u271d q : \u2115\np : R[X]\nhsep : Separable p\n\u22a2 \u2200 (x : R[X]), multiplicity x p \u2264 1 \u2228 IsUnit x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "StrictMono.mul'", "start": [1453, 1], "end": [1456, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/NullMeasurable.lean", "full_name": "MeasureTheory.NullMeasurableSet.exists_measurable_subset_ae_eq", "start": [245, 1], "end": [248, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.eq_of_mem_replicate", "start": [463, 1], "end": [463, 99], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "full_name": "Continuous.measurable2", "start": [1066, 1], "end": [1069, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/Nat/Gcd.lean", "full_name": "Nat.lcm_dvd", "start": [185, 1], "end": [191, 75], "traced_tactics": [{"tactic": "match eq_zero_or_pos k with\n| .inl h => rw [h]; exact Nat.dvd_zero _\n| .inr kpos =>\n  apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))\n  rw [gcd_mul_lcm, \u2190 gcd_mul_right, Nat.mul_comm n k]\n  exact dvd_gcd (Nat.mul_dvd_mul_left _ H2) (Nat.mul_dvd_mul_right H1 _)", "annotated_tactic": ["match <a>eq_zero_or_pos</a> k with\n  | .inl h => rw [h]; exact <a>Nat.dvd_zero</a> _\n  | .inr kpos =>\n    apply <a>Nat.dvd_of_mul_dvd_mul_left</a> (<a>gcd_pos_of_pos_left</a> n (<a>pos_of_dvd_of_pos</a> H1 kpos))\n    rw [<a>gcd_mul_lcm</a>, \u2190 <a>gcd_mul_right</a>, <a>Nat.mul_comm</a> n k]\n    exact <a>dvd_gcd</a> (<a>Nat.mul_dvd_mul_left</a> _ H2) (<a>Nat.mul_dvd_mul_right</a> H1 _)", [{"full_name": "Nat.eq_zero_or_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [294, 9], "def_end_pos": [294, 23]}, {"full_name": "Nat.dvd_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean", "def_pos": [20, 19], "def_end_pos": [20, 27]}, {"full_name": "Nat.dvd_of_mul_dvd_mul_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [909, 19], "def_end_pos": [909, 42]}, {"full_name": "Nat.gcd_pos_of_pos_left", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [57, 9], "def_end_pos": [57, 28]}, {"full_name": "Nat.pos_of_dvd_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean", "def_pos": [68, 9], "def_end_pos": [68, 26]}, {"full_name": "Nat.gcd_mul_lcm", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Nat.gcd_mul_right", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [54, 9], "def_end_pos": [54, 22]}, {"full_name": "Nat.mul_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [181, 19], "def_end_pos": [181, 27]}, {"full_name": "Nat.dvd_gcd", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [67, 9], "def_end_pos": [67, 16]}, {"full_name": "Nat.mul_dvd_mul_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [893, 19], "def_end_pos": [893, 35]}, {"full_name": "Nat.mul_dvd_mul_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [896, 19], "def_end_pos": [896, 36]}]], "state_before": "m n k : Nat\nH1 : m \u2223 k\nH2 : n \u2223 k\n\u22a2 lcm m n \u2223 k", "state_after": "no goals"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "m n k : Nat\nH1 : m \u2223 k\nH2 : n \u2223 k\nh : k = 0\n\u22a2 lcm m n \u2223 k", "state_after": "m n k : Nat\nH1 : m \u2223 k\nH2 : n \u2223 k\nh : k = 0\n\u22a2 lcm m n \u2223 0"}, {"tactic": "exact Nat.dvd_zero _", "annotated_tactic": ["exact <a>Nat.dvd_zero</a> _", [{"full_name": "Nat.dvd_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean", "def_pos": [20, 19], "def_end_pos": [20, 27]}]], "state_before": "m n k : Nat\nH1 : m \u2223 k\nH2 : n \u2223 k\nh : k = 0\n\u22a2 lcm m n \u2223 0", "state_after": "no goals"}, {"tactic": "apply Nat.dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos))", "annotated_tactic": ["apply <a>Nat.dvd_of_mul_dvd_mul_left</a> (<a>gcd_pos_of_pos_left</a> n (<a>pos_of_dvd_of_pos</a> H1 kpos))", [{"full_name": "Nat.dvd_of_mul_dvd_mul_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [909, 19], "def_end_pos": [909, 42]}, {"full_name": "Nat.gcd_pos_of_pos_left", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [57, 9], "def_end_pos": [57, 28]}, {"full_name": "Nat.pos_of_dvd_of_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean", "def_pos": [68, 9], "def_end_pos": [68, 26]}]], "state_before": "m n k : Nat\nH1 : m \u2223 k\nH2 : n \u2223 k\nkpos : k > 0\n\u22a2 lcm m n \u2223 k", "state_after": "m n k : Nat\nH1 : m \u2223 k\nH2 : n \u2223 k\nkpos : k > 0\n\u22a2 gcd m n * lcm m n \u2223 gcd m n * k"}, {"tactic": "rw [gcd_mul_lcm, \u2190 gcd_mul_right, Nat.mul_comm n k]", "annotated_tactic": ["rw [<a>gcd_mul_lcm</a>, \u2190 <a>gcd_mul_right</a>, <a>Nat.mul_comm</a> n k]", [{"full_name": "Nat.gcd_mul_lcm", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Nat.gcd_mul_right", "def_path": ".lake/packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [54, 9], "def_end_pos": [54, 22]}, {"full_name": "Nat.mul_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [181, 19], "def_end_pos": [181, 27]}]], "state_before": "m n k : Nat\nH1 : m \u2223 k\nH2 : n \u2223 k\nkpos : k > 0\n\u22a2 gcd m n * lcm m n \u2223 gcd m n * k", "state_after": "m n k : Nat\nH1 : m \u2223 k\nH2 : n \u2223 k\nkpos : k > 0\n\u22a2 m * n \u2223 gcd (m * k) (k * n)"}, {"tactic": "exact dvd_gcd (Nat.mul_dvd_mul_left _ H2) (Nat.mul_dvd_mul_right H1 _)", "annotated_tactic": ["exact <a>dvd_gcd</a> (<a>Nat.mul_dvd_mul_left</a> _ H2) (<a>Nat.mul_dvd_mul_right</a> H1 _)", [{"full_name": "Nat.dvd_gcd", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "def_pos": [67, 9], "def_end_pos": [67, 16]}, {"full_name": "Nat.mul_dvd_mul_left", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [893, 19], "def_end_pos": [893, 35]}, {"full_name": "Nat.mul_dvd_mul_right", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [896, 19], "def_end_pos": [896, 36]}]], "state_before": "m n k : Nat\nH1 : m \u2223 k\nH2 : n \u2223 k\nkpos : k > 0\n\u22a2 m * n \u2223 gcd (m * k) (k * n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "full_name": "CategoryTheory.Limits.prod.comp_diag", "start": [713, 1], "end": [714, 10], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\nX\u271d Y\u271d X Y : C\ninst\u271d : HasBinaryProduct Y Y\nf : X \u27f6 Y\n\u22a2 f \u226b diag Y = lift f f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/ContinuousOn.lean", "full_name": "nhdsWithin_subtype", "start": [488, 1], "end": [490, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Order/LinearOrder.lean", "full_name": "min_le_right", "start": [40, 1], "end": [44, 41], "traced_tactics": [{"tactic": "if h : a \u2264 b\nthen simp [min_def, if_pos h]; exact h\nelse simp [min_def, if_neg h, le_refl]", "annotated_tactic": ["if h : a \u2264 b\n  then simp [<a>min_def</a>, <a>if_pos</a> h]; exact h\n  else simp [<a>min_def</a>, <a>if_neg</a> h, <a>le_refl</a>]", [{"full_name": "min_def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [25, 9], "def_end_pos": [25, 16]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}, {"full_name": "min_def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [25, 9], "def_end_pos": [25, 16]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 min a b \u2264 b", "state_after": "no goals"}, {"tactic": "simp [min_def, if_pos h]", "annotated_tactic": ["simp [<a>min_def</a>, <a>if_pos</a> h]", [{"full_name": "min_def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [25, 9], "def_end_pos": [25, 16]}, {"full_name": "if_pos", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [927, 9], "def_end_pos": [927, 15]}]], "state_before": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 min a b \u2264 b", "state_after": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 a \u2264 b"}, {"tactic": "exact h", "annotated_tactic": ["exact h", []], "state_before": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 a \u2264 b", "state_after": "no goals"}, {"tactic": "simp [min_def, if_neg h, le_refl]", "annotated_tactic": ["simp [<a>min_def</a>, <a>if_neg</a> h, <a>le_refl</a>]", [{"full_name": "min_def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [25, 9], "def_end_pos": [25, 16]}, {"full_name": "if_neg", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [932, 9], "def_end_pos": [932, 15]}, {"full_name": "le_refl", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}]], "state_before": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : \u00aca \u2264 b\n\u22a2 min a b \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/BigOperators/Finsupp.lean", "full_name": "Finsupp.prod_embDomain", "start": [544, 1], "end": [547, 28], "traced_tactics": [{"tactic": "rw [prod, prod, support_embDomain, Finset.prod_map]", "annotated_tactic": ["rw [<a>prod</a>, <a>prod</a>, <a>support_embDomain</a>, <a>Finset.prod_map</a>]", [{"full_name": "Finsupp.prod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [48, 5], "def_end_pos": [48, 9]}, {"full_name": "Finsupp.prod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [48, 5], "def_end_pos": [48, 9]}, {"full_name": "Finsupp.support_embDomain", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [883, 9], "def_end_pos": [883, 26]}, {"full_name": "Finset.prod_map", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [369, 9], "def_end_pos": [369, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b3 : Type u_3\nA : Type u_4\nB : Type u_5\nC : Type u_6\ninst\u271d\u2074 : AddCommMonoid A\ninst\u271d\u00b3 : AddCommMonoid B\ninst\u271d\u00b2 : AddCommMonoid C\nt : \u03b9 \u2192 A \u2192 C\nh0 : \u2200 (i : \u03b9), t i 0 = 0\nh1 : \u2200 (i : \u03b9) (x y : A), t i (x + y) = t i x + t i y\ns : Finset \u03b1\nf\u271d : \u03b1 \u2192 \u03b9 \u2192\u2080 A\ni : \u03b9\ng\u271d : \u03b9 \u2192\u2080 A\nk : \u03b9 \u2192 A \u2192 \u03b3 \u2192 B\nx : \u03b3\n\u03b2 : Type u_7\nM : Type u_8\nM' : Type u_9\nN : Type u_10\nP : Type u_11\nG : Type u_12\nH : Type u_13\nR : Type u_14\nS : Type u_15\ninst\u271d\u00b9 : Zero M\ninst\u271d : CommMonoid N\nv : \u03b1 \u2192\u2080 M\nf : \u03b1 \u21aa \u03b2\ng : \u03b2 \u2192 M \u2192 N\n\u22a2 prod (embDomain f v) g = prod v fun a b => g (f a) b", "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b3 : Type u_3\nA : Type u_4\nB : Type u_5\nC : Type u_6\ninst\u271d\u2074 : AddCommMonoid A\ninst\u271d\u00b3 : AddCommMonoid B\ninst\u271d\u00b2 : AddCommMonoid C\nt : \u03b9 \u2192 A \u2192 C\nh0 : \u2200 (i : \u03b9), t i 0 = 0\nh1 : \u2200 (i : \u03b9) (x y : A), t i (x + y) = t i x + t i y\ns : Finset \u03b1\nf\u271d : \u03b1 \u2192 \u03b9 \u2192\u2080 A\ni : \u03b9\ng\u271d : \u03b9 \u2192\u2080 A\nk : \u03b9 \u2192 A \u2192 \u03b3 \u2192 B\nx : \u03b3\n\u03b2 : Type u_7\nM : Type u_8\nM' : Type u_9\nN : Type u_10\nP : Type u_11\nG : Type u_12\nH : Type u_13\nR : Type u_14\nS : Type u_15\ninst\u271d\u00b9 : Zero M\ninst\u271d : CommMonoid N\nv : \u03b1 \u2192\u2080 M\nf : \u03b1 \u21aa \u03b2\ng : \u03b2 \u2192 M \u2192 N\n\u22a2 \u220f x in v.support, g (f x) ((embDomain f v) (f x)) = \u220f a in v.support, g (f a) (v a)"}, {"tactic": "simp_rw [embDomain_apply]", "annotated_tactic": ["simp_rw [<a>embDomain_apply</a>]", [{"full_name": "Finsupp.embDomain_apply", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [893, 9], "def_end_pos": [893, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b3 : Type u_3\nA : Type u_4\nB : Type u_5\nC : Type u_6\ninst\u271d\u2074 : AddCommMonoid A\ninst\u271d\u00b3 : AddCommMonoid B\ninst\u271d\u00b2 : AddCommMonoid C\nt : \u03b9 \u2192 A \u2192 C\nh0 : \u2200 (i : \u03b9), t i 0 = 0\nh1 : \u2200 (i : \u03b9) (x y : A), t i (x + y) = t i x + t i y\ns : Finset \u03b1\nf\u271d : \u03b1 \u2192 \u03b9 \u2192\u2080 A\ni : \u03b9\ng\u271d : \u03b9 \u2192\u2080 A\nk : \u03b9 \u2192 A \u2192 \u03b3 \u2192 B\nx : \u03b3\n\u03b2 : Type u_7\nM : Type u_8\nM' : Type u_9\nN : Type u_10\nP : Type u_11\nG : Type u_12\nH : Type u_13\nR : Type u_14\nS : Type u_15\ninst\u271d\u00b9 : Zero M\ninst\u271d : CommMonoid N\nv : \u03b1 \u2192\u2080 M\nf : \u03b1 \u21aa \u03b2\ng : \u03b2 \u2192 M \u2192 N\n\u22a2 \u220f x in v.support, g (f x) ((embDomain f v) (f x)) = \u220f a in v.support, g (f a) (v a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Cofinite.lean", "full_name": "Filter.disjoint_cofinite_left", "start": [134, 1], "end": [135, 41], "traced_tactics": [{"tactic": "simp [l.basis_sets.disjoint_iff_right]", "annotated_tactic": ["simp [l.basis_sets.disjoint_iff_right]", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\n\u22a2 Disjoint cofinite l \u2194 \u2203 s \u2208 l, Set.Finite s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "full_name": "MeasureTheory.MeasurePreserving.set_lintegral_comp_preimage", "start": [1476, 1], "end": [1479, 58], "traced_tactics": [{"tactic": "rw [\u2190 hg.map_eq, set_lintegral_map hs hf hg.measurable]", "annotated_tactic": ["rw [\u2190 hg.map_eq, <a>set_lintegral_map</a> hs hf hg.measurable]", [{"full_name": "MeasureTheory.set_lintegral_map", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/Integral/Lebesgue.lean", "def_pos": [1424, 9], "def_end_pos": [1424, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd\u271d : Measure \u03b1\nmb : MeasurableSpace \u03b2\n\u03bd : Measure \u03b2\ng : \u03b1 \u2192 \u03b2\nhg : MeasurePreserving g \u03bc \u03bd\ns : Set \u03b2\nhs : MeasurableSet s\nf : \u03b2 \u2192 \u211d\u22650\u221e\nhf : Measurable f\n\u22a2 \u222b\u207b (a : \u03b1) in g \u207b\u00b9' s, f (g a) \u2202\u03bc = \u222b\u207b (b : \u03b2) in s, f b \u2202\u03bd", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Zip.lean", "full_name": "List.map_prod_left_eq_zip", "start": [151, 1], "end": [155, 17], "traced_tactics": [{"tactic": "rw [\u2190 zip_map']", "annotated_tactic": ["rw [\u2190 <a>zip_map'</a>]", [{"full_name": "List.zip_map'", "def_path": ".lake/packages/std/Std/Data/List/Lemmas.lean", "def_pos": [325, 9], "def_end_pos": [325, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => (x, f x)) l = zip l (map f l)", "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 zip (map (fun x => x) l) (map (fun x => f x) l) = zip l (map f l)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 zip (map (fun x => x) l) (map (fun x => f x) l) = zip l (map f l)", "state_after": "case e_a\n\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => x) l = l"}, {"tactic": "exact map_id _", "annotated_tactic": ["exact <a>map_id</a> _", [{"full_name": "List.map_id", "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean", "def_pos": [123, 17], "def_end_pos": [123, 23]}]], "state_before": "case e_a\n\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => x) l = l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Ray.lean", "full_name": "sameRay_smul_left_iff_of_ne", "start": [551, 1], "end": [553, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "full_name": "MulChar.coe_equivToUnitHom", "start": [229, 1], "end": [230, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "full_name": "Asymptotics.IsBigOWith.prod_left_fst", "start": [1025, 1], "end": [1027, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Ray.lean", "full_name": "SameRay.map", "start": [164, 1], "end": [167, 64], "traced_tactics": [{"tactic": "rw [hx, map_zero]", "annotated_tactic": ["rw [hx, <a>map_zero</a>]", [{"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2070 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\nN : Type u_3\ninst\u271d\u2077 : AddCommMonoid N\ninst\u271d\u2076 : Module R N\n\u03b9 : Type u_4\ninst\u271d\u2075 : DecidableEq \u03b9\nx y z : M\nS : Type u_5\ninst\u271d\u2074 : OrderedCommSemiring S\ninst\u271d\u00b3 : Algebra S R\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : SMulPosMono S R\ninst\u271d : IsScalarTower S R M\na : S\nf : M \u2192\u2097[R] N\nh : SameRay R x y\nhx : x = 0\n\u22a2 f x = 0", "state_after": "no goals"}, {"tactic": "rw [hy, map_zero]", "annotated_tactic": ["rw [hy, <a>map_zero</a>]", [{"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2070 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\nN : Type u_3\ninst\u271d\u2077 : AddCommMonoid N\ninst\u271d\u2076 : Module R N\n\u03b9 : Type u_4\ninst\u271d\u2075 : DecidableEq \u03b9\nx y z : M\nS : Type u_5\ninst\u271d\u2074 : OrderedCommSemiring S\ninst\u271d\u00b3 : Algebra S R\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : SMulPosMono S R\ninst\u271d : IsScalarTower S R M\na : S\nf : M \u2192\u2097[R] N\nh : SameRay R x y\nhy : y = 0\n\u22a2 f y = 0", "state_after": "no goals"}, {"tactic": "rw [\u2190 f.map_smul, \u2190 f.map_smul, h]", "annotated_tactic": ["rw [\u2190 f.map_smul, \u2190 f.map_smul, h]", []], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2070 : StrictOrderedCommSemiring R\nM : Type u_2\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\nN : Type u_3\ninst\u271d\u2077 : AddCommMonoid N\ninst\u271d\u2076 : Module R N\n\u03b9 : Type u_4\ninst\u271d\u2075 : DecidableEq \u03b9\nx y z : M\nS : Type u_5\ninst\u271d\u2074 : OrderedCommSemiring S\ninst\u271d\u00b3 : Algebra S R\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : SMulPosMono S R\ninst\u271d : IsScalarTower S R M\na : S\nf : M \u2192\u2097[R] N\nh\u271d : SameRay R x y\nx\u271d : \u2203 r\u2081 r\u2082, 0 < r\u2081 \u2227 0 < r\u2082 \u2227 r\u2081 \u2022 x = r\u2082 \u2022 y\nr\u2081 r\u2082 : R\nhr\u2081 : 0 < r\u2081\nhr\u2082 : 0 < r\u2082\nh : r\u2081 \u2022 x = r\u2082 \u2022 y\n\u22a2 r\u2081 \u2022 f x = r\u2082 \u2022 f y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sym/Sym2.lean", "full_name": "Sym2.out_fst_mem", "start": [355, 1], "end": [356, 39], "traced_tactics": [{"tactic": "rw [Sym2.mk, e.out_eq]", "annotated_tactic": ["rw [<a>Sym2.mk</a>, e.out_eq]", [{"full_name": "Sym2.mk", "def_path": ".lake/packages/mathlib/Mathlib/Data/Sym/Sym2.lean", "def_pos": [106, 18], "def_end_pos": [106, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\n\u22a2 e = s((Quot.out e).1, (Quot.out e).2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/NNReal.lean", "full_name": "NNReal.mul_iSup", "start": [1067, 1], "end": [1069, 56], "traced_tactics": [{"tactic": "rw [\u2190 coe_inj, NNReal.coe_mul, NNReal.coe_iSup, NNReal.coe_iSup]", "annotated_tactic": ["rw [\u2190 <a>coe_inj</a>, <a>NNReal.coe_mul</a>, <a>NNReal.coe_iSup</a>, <a>NNReal.coe_iSup</a>]", [{"full_name": "NNReal.coe_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [165, 26], "def_end_pos": [165, 33]}, {"full_name": "NNReal.coe_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [184, 19], "def_end_pos": [184, 26]}, {"full_name": "NNReal.coe_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [520, 9], "def_end_pos": [520, 17]}, {"full_name": "NNReal.coe_iSup", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [520, 9], "def_end_pos": [520, 17]}]], "state_before": "\u03b9 : Sort u_1\nf\u271d f : \u03b9 \u2192 \u211d\u22650\na : \u211d\u22650\n\u22a2 a * \u2a06 i, f i = \u2a06 i, a * f i", "state_after": "\u03b9 : Sort u_1\nf\u271d f : \u03b9 \u2192 \u211d\u22650\na : \u211d\u22650\n\u22a2 \u2191a * \u2a06 i, \u2191(f i) = \u2a06 i, \u2191(a * f i)"}, {"tactic": "exact Real.mul_iSup_of_nonneg (NNReal.coe_nonneg _) _", "annotated_tactic": ["exact <a>Real.mul_iSup_of_nonneg</a> (<a>NNReal.coe_nonneg</a> _) _", [{"full_name": "Real.mul_iSup_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Pointwise.lean", "def_pos": [120, 9], "def_end_pos": [120, 32]}, {"full_name": "NNReal.coe_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [134, 9], "def_end_pos": [134, 19]}]], "state_before": "\u03b9 : Sort u_1\nf\u271d f : \u03b9 \u2192 \u211d\u22650\na : \u211d\u22650\n\u22a2 \u2191a * \u2a06 i, \u2191(f i) = \u2a06 i, \u2191(a * f i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "IsUnit.unit_spec", "start": [819, 1], "end": [820, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.total_range", "start": [714, 1], "end": [715, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "full_name": "measurable_updateFinset", "start": [944, 1], "end": [948, 55], "traced_tactics": [{"tactic": "simp (config := { unfoldPartialApp := true }) only [updateFinset, measurable_pi_iff]", "annotated_tactic": ["simp (config := { unfoldPartialApp := <a>true</a> }) only [<a>updateFinset</a>, <a>measurable_pi_iff</a>]", [{"full_name": "Bool.true", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [567, 5], "def_end_pos": [567, 9]}, {"full_name": "Function.updateFinset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Update.lean", "def_pos": [23, 5], "def_end_pos": [23, 17]}, {"full_name": "measurable_pi_iff", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [906, 9], "def_end_pos": [906, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\n\u03c0 : \u03b4 \u2192 Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : (a : \u03b4) \u2192 MeasurableSpace (\u03c0 a)\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : DecidableEq \u03b4\ns : Finset \u03b4\nx : (i : \u03b4) \u2192 \u03c0 i\n\u22a2 Measurable (updateFinset x s)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\n\u03c0 : \u03b4 \u2192 Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : (a : \u03b4) \u2192 MeasurableSpace (\u03c0 a)\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : DecidableEq \u03b4\ns : Finset \u03b4\nx : (i : \u03b4) \u2192 \u03c0 i\n\u22a2 \u2200 (a : \u03b4), Measurable fun x_1 => if hi : a \u2208 s then x_1 { val := a, property := hi } else x a"}, {"tactic": "intro i", "annotated_tactic": ["intro i", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\n\u03c0 : \u03b4 \u2192 Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : (a : \u03b4) \u2192 MeasurableSpace (\u03c0 a)\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : DecidableEq \u03b4\ns : Finset \u03b4\nx : (i : \u03b4) \u2192 \u03c0 i\n\u22a2 \u2200 (a : \u03b4), Measurable fun x_1 => if hi : a \u2208 s then x_1 { val := a, property := hi } else x a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\n\u03c0 : \u03b4 \u2192 Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : (a : \u03b4) \u2192 MeasurableSpace (\u03c0 a)\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : DecidableEq \u03b4\ns : Finset \u03b4\nx : (i : \u03b4) \u2192 \u03c0 i\ni : \u03b4\n\u22a2 Measurable fun x_1 => if hi : i \u2208 s then x_1 { val := i, property := hi } else x i"}, {"tactic": "by_cases h : i \u2208 s <;> simp [h, measurable_pi_apply]", "annotated_tactic": ["by_cases h : i \u2208 s <;> simp [h, <a>measurable_pi_apply</a>]", [{"full_name": "measurable_pi_apply", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "def_pos": [912, 9], "def_end_pos": [912, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u\u03b9\ns\u271d t u : Set \u03b1\n\u03c0 : \u03b4 \u2192 Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : (a : \u03b4) \u2192 MeasurableSpace (\u03c0 a)\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : DecidableEq \u03b4\ns : Finset \u03b4\nx : (i : \u03b4) \u2192 \u03c0 i\ni : \u03b4\n\u22a2 Measurable fun x_1 => if hi : i \u2208 s then x_1 { val := i, property := hi } else x i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "Nat.rel_of_forall_rel_succ_of_le_of_le", "start": [1009, 1], "end": [1012, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/InitialSeg.lean", "full_name": "InitialSeg.leLT_apply", "start": [516, 1], "end": [520, 65], "traced_tactics": [{"tactic": "delta InitialSeg.leLT", "annotated_tactic": ["delta <a>InitialSeg.leLT</a>", [{"full_name": "InitialSeg.leLT", "def_path": ".lake/packages/mathlib/Mathlib/Order/InitialSeg.lean", "def_pos": [508, 19], "def_end_pos": [508, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b2 s\ninst\u271d : IsTrans \u03b3 t\nf : r \u227ci s\ng : s \u227ai t\na : \u03b1\n\u22a2 (leLT f g).toRelEmbedding a = g.toRelEmbedding (f a)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b2 s\ninst\u271d : IsTrans \u03b3 t\nf : r \u227ci s\ng : s \u227ai t\na : \u03b1\n\u22a2 (match ltOrEq f with\n        | Sum.inl f' => PrincipalSeg.trans f' g\n        | Sum.inr f' => PrincipalSeg.equivLT f' g).toRelEmbedding\n      a =\n    g.toRelEmbedding (f a)"}, {"tactic": "cases' f.ltOrEq with f' f'", "annotated_tactic": ["cases' f.ltOrEq with f' f'", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b2 s\ninst\u271d : IsTrans \u03b3 t\nf : r \u227ci s\ng : s \u227ai t\na : \u03b1\n\u22a2 (match ltOrEq f with\n        | Sum.inl f' => PrincipalSeg.trans f' g\n        | Sum.inr f' => PrincipalSeg.equivLT f' g).toRelEmbedding\n      a =\n    g.toRelEmbedding (f a)", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b2 s\ninst\u271d : IsTrans \u03b3 t\nf : r \u227ci s\ng : s \u227ai t\na : \u03b1\nf' : r \u227ai s\n\u22a2 (match Sum.inl f' with\n        | Sum.inl f' => PrincipalSeg.trans f' g\n        | Sum.inr f' => PrincipalSeg.equivLT f' g).toRelEmbedding\n      a =\n    g.toRelEmbedding (f a)\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b2 s\ninst\u271d : IsTrans \u03b3 t\nf : r \u227ci s\ng : s \u227ai t\na : \u03b1\nf' : r \u2243r s\n\u22a2 (match Sum.inr f' with\n        | Sum.inl f' => PrincipalSeg.trans f' g\n        | Sum.inr f' => PrincipalSeg.equivLT f' g).toRelEmbedding\n      a =\n    g.toRelEmbedding (f a)"}, {"tactic": "simp only [PrincipalSeg.trans_apply, f.ltOrEq_apply_left]", "annotated_tactic": ["simp only [<a>PrincipalSeg.trans_apply</a>, f.ltOrEq_apply_left]", [{"full_name": "PrincipalSeg.trans_apply", "def_path": ".lake/packages/mathlib/Mathlib/Order/InitialSeg.lean", "def_pos": [323, 9], "def_end_pos": [323, 20]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b2 s\ninst\u271d : IsTrans \u03b3 t\nf : r \u227ci s\ng : s \u227ai t\na : \u03b1\nf' : r \u227ai s\n\u22a2 (match Sum.inl f' with\n        | Sum.inl f' => PrincipalSeg.trans f' g\n        | Sum.inr f' => PrincipalSeg.equivLT f' g).toRelEmbedding\n      a =\n    g.toRelEmbedding (f a)", "state_after": "no goals"}, {"tactic": "simp only [PrincipalSeg.equivLT_apply, f.ltOrEq_apply_right]", "annotated_tactic": ["simp only [<a>PrincipalSeg.equivLT_apply</a>, f.ltOrEq_apply_right]", [{"full_name": "PrincipalSeg.equivLT_apply", "def_path": ".lake/packages/mathlib/Mathlib/Order/InitialSeg.lean", "def_pos": [350, 9], "def_end_pos": [350, 22]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : \u03b3 \u2192 \u03b3 \u2192 Prop\ninst\u271d\u00b9 : IsWellOrder \u03b2 s\ninst\u271d : IsTrans \u03b3 t\nf : r \u227ci s\ng : s \u227ai t\na : \u03b1\nf' : r \u2243r s\n\u22a2 (match Sum.inr f' with\n        | Sum.inl f' => PrincipalSeg.trans f' g\n        | Sum.inr f' => PrincipalSeg.equivLT f' g).toRelEmbedding\n      a =\n    g.toRelEmbedding (f a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "full_name": "Matrix.cramer_one", "start": [126, 1], "end": [132, 49], "traced_tactics": [{"tactic": "refine LinearMap.pi_ext' (fun (i : n) => LinearMap.ext_ring (funext (fun (j : n) => ?_)))", "annotated_tactic": ["refine <a>LinearMap.pi_ext'</a> (fun (i : n) => <a>LinearMap.ext_ring</a> (<a>funext</a> (fun (j : n) => ?_)))", [{"full_name": "LinearMap.pi_ext'", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Pi.lean", "def_pos": [193, 9], "def_end_pos": [193, 16]}, {"full_name": "LinearMap.ext_ring", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [478, 9], "def_end_pos": [478, 17]}, {"full_name": "funext", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1805, 9], "def_end_pos": [1805, 15]}]], "state_before": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\n\u22a2 cramer 1 = 1", "state_after": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni j : n\n\u22a2 (cramer 1 \u2218\u2097 LinearMap.single i) 1 j = (1 \u2218\u2097 LinearMap.single i) 1 j"}, {"tactic": "convert congr_fun (cramer_row_self (1 : Matrix n n \u03b1) (Pi.single i 1) i _) j", "annotated_tactic": ["convert <a>congr_fun</a> (<a>cramer_row_self</a> (1 : <a>Matrix</a> n n \u03b1) (<a>Pi.single</a> i 1) i _) j", [{"full_name": "congr_fun", "def_path": ".lake/packages/std/Std/Logic.lean", "def_pos": [74, 7], "def_end_pos": [74, 16]}, {"full_name": "Matrix.cramer_row_self", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "def_pos": [119, 9], "def_end_pos": [119, 24]}, {"full_name": "Matrix", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [60, 5], "def_end_pos": [60, 11]}, {"full_name": "Pi.single", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [357, 3], "def_end_pos": [357, 14]}]], "state_before": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni j : n\n\u22a2 (cramer 1 \u2218\u2097 LinearMap.single i) 1 j = (1 \u2218\u2097 LinearMap.single i) 1 j", "state_after": "case h.e'_3.h.e'_1\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni j : n\n\u22a2 1 = det 1\n\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni j : n\n\u22a2 \u2200 (j : n), Pi.single i 1 j = 1 j i"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.e'_3.h.e'_1\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni j : n\n\u22a2 1 = det 1", "state_after": "no goals"}, {"tactic": "intro j", "annotated_tactic": ["intro j", []], "state_before": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni j : n\n\u22a2 \u2200 (j : n), Pi.single i 1 j = 1 j i", "state_after": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni j\u271d j : n\n\u22a2 Pi.single i 1 j = 1 j i"}, {"tactic": "rw [Matrix.one_eq_pi_single, Pi.single_comm]", "annotated_tactic": ["rw [<a>Matrix.one_eq_pi_single</a>, <a>Pi.single_comm</a>]", [{"full_name": "Matrix.one_eq_pi_single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [581, 9], "def_end_pos": [581, 25]}, {"full_name": "Pi.single_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Pi/Basic.lean", "def_pos": [403, 3], "def_end_pos": [403, 14]}]], "state_before": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\ninst\u271d : CommRing \u03b1\nA : Matrix n n \u03b1\nb : n \u2192 \u03b1\ni j\u271d j : n\n\u22a2 Pi.single i 1 j = 1 j i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "div_eq_div_iff_mul_eq_mul", "start": [1082, 1], "end": [1084, 32], "traced_tactics": [{"tactic": "rw [div_eq_iff_eq_mul, div_mul_eq_mul_div, eq_comm, div_eq_iff_eq_mul']", "annotated_tactic": ["rw [<a>div_eq_iff_eq_mul</a>, <a>div_mul_eq_mul_div</a>, <a>eq_comm</a>, <a>div_eq_iff_eq_mul'</a>]", [{"full_name": "div_eq_iff_eq_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [909, 9], "def_end_pos": [909, 26]}, {"full_name": "div_mul_eq_mul_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [627, 9], "def_end_pos": [627, 27]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "div_eq_iff_eq_mul'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [1022, 9], "def_end_pos": [1022, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : CommGroup G\na b c d : G\n\u22a2 a / b = c / d \u2194 a * d = c * b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : CommGroup G\na b c d : G\n\u22a2 c * b = d * a \u2194 a * d = c * b"}, {"tactic": "simp only [mul_comm, eq_comm]", "annotated_tactic": ["simp only [<a>mul_comm</a>, <a>eq_comm</a>]", [{"full_name": "mul_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 17]}, {"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : CommGroup G\na b c d : G\n\u22a2 c * b = d * a \u2194 a * d = c * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/Pointwise.lean", "full_name": "AddSubmonoid.mem_one", "start": [504, 1], "end": [505, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.pi_congr", "start": [734, 1], "end": [735, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "lcm_same", "start": [821, 1], "end": [822, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.monic_X_pow", "start": [880, 1], "end": [881, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "full_name": "affineIndependent_def", "start": [57, 1], "end": [61, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Function/SimpleFunc.lean", "full_name": "MeasureTheory.SimpleFunc.monotone_approx", "start": [845, 1], "end": [846, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "full_name": "Cardinal.beth_pos", "start": [477, 1], "end": [478, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/CauSeq/Basic.lean", "full_name": "CauSeq.limZero_congr", "start": [499, 1], "end": [500, 99], "traced_tactics": [{"tactic": "simpa using add_limZero (Setoid.symm h) l", "annotated_tactic": ["simpa using <a>add_limZero</a> (<a>Setoid.symm</a> h) l", [{"full_name": "CauSeq.add_limZero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/Basic.lean", "def_pos": [423, 9], "def_end_pos": [423, 20]}, {"full_name": "Setoid.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [1242, 9], "def_end_pos": [1242, 13]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nh : f \u2248 g\nl : LimZero f\n\u22a2 LimZero g", "state_after": "no goals"}, {"tactic": "simpa using add_limZero h l", "annotated_tactic": ["simpa using <a>add_limZero</a> h l", [{"full_name": "CauSeq.add_limZero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/CauSeq/Basic.lean", "def_pos": [423, 9], "def_end_pos": [423, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nh : f \u2248 g\nl : LimZero g\n\u22a2 LimZero f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.card_ofSubsingleton", "start": [216, 1], "end": [217, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/TensorProduct/Tower.lean", "full_name": "TensorProduct.AlgebraTensorModule.map_add_right", "start": [222, 1], "end": [226, 25], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\nP' : Type uP'\nQ' : Type uQ'\ninst\u271d\u00b3\u00b9 : CommSemiring R\ninst\u271d\u00b3\u2070 : Semiring A\ninst\u271d\u00b2\u2079 : Semiring B\ninst\u271d\u00b2\u2078 : Algebra R A\ninst\u271d\u00b2\u2077 : Algebra R B\ninst\u271d\u00b2\u2076 : AddCommMonoid M\ninst\u271d\u00b2\u2075 : Module R M\ninst\u271d\u00b2\u2074 : Module A M\ninst\u271d\u00b2\u00b3 : Module B M\ninst\u271d\u00b2\u00b2 : IsScalarTower R A M\ninst\u271d\u00b2\u00b9 : IsScalarTower R B M\ninst\u271d\u00b2\u2070 : SMulCommClass A B M\ninst\u271d\u00b9\u2079 : AddCommMonoid N\ninst\u271d\u00b9\u2078 : Module R N\ninst\u271d\u00b9\u2077 : AddCommMonoid P\ninst\u271d\u00b9\u2076 : Module R P\ninst\u271d\u00b9\u2075 : Module A P\ninst\u271d\u00b9\u2074 : Module B P\ninst\u271d\u00b9\u00b3 : IsScalarTower R A P\ninst\u271d\u00b9\u00b2 : IsScalarTower R B P\ninst\u271d\u00b9\u00b9 : SMulCommClass A B P\ninst\u271d\u00b9\u2070 : AddCommMonoid Q\ninst\u271d\u2079 : Module R Q\ninst\u271d\u2078 : AddCommMonoid P'\ninst\u271d\u2077 : Module R P'\ninst\u271d\u2076 : Module A P'\ninst\u271d\u2075 : Module B P'\ninst\u271d\u2074 : IsScalarTower R A P'\ninst\u271d\u00b3 : IsScalarTower R B P'\ninst\u271d\u00b2 : SMulCommClass A B P'\ninst\u271d\u00b9 : AddCommMonoid Q'\ninst\u271d : Module R Q'\nf : M \u2192\u2097[A] P\ng\u2081 g\u2082 : N \u2192\u2097[R] Q\n\u22a2 map f (g\u2081 + g\u2082) = map f g\u2081 + map f g\u2082", "state_after": "case a.h.h\nR : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\nP' : Type uP'\nQ' : Type uQ'\ninst\u271d\u00b3\u00b9 : CommSemiring R\ninst\u271d\u00b3\u2070 : Semiring A\ninst\u271d\u00b2\u2079 : Semiring B\ninst\u271d\u00b2\u2078 : Algebra R A\ninst\u271d\u00b2\u2077 : Algebra R B\ninst\u271d\u00b2\u2076 : AddCommMonoid M\ninst\u271d\u00b2\u2075 : Module R M\ninst\u271d\u00b2\u2074 : Module A M\ninst\u271d\u00b2\u00b3 : Module B M\ninst\u271d\u00b2\u00b2 : IsScalarTower R A M\ninst\u271d\u00b2\u00b9 : IsScalarTower R B M\ninst\u271d\u00b2\u2070 : SMulCommClass A B M\ninst\u271d\u00b9\u2079 : AddCommMonoid N\ninst\u271d\u00b9\u2078 : Module R N\ninst\u271d\u00b9\u2077 : AddCommMonoid P\ninst\u271d\u00b9\u2076 : Module R P\ninst\u271d\u00b9\u2075 : Module A P\ninst\u271d\u00b9\u2074 : Module B P\ninst\u271d\u00b9\u00b3 : IsScalarTower R A P\ninst\u271d\u00b9\u00b2 : IsScalarTower R B P\ninst\u271d\u00b9\u00b9 : SMulCommClass A B P\ninst\u271d\u00b9\u2070 : AddCommMonoid Q\ninst\u271d\u2079 : Module R Q\ninst\u271d\u2078 : AddCommMonoid P'\ninst\u271d\u2077 : Module R P'\ninst\u271d\u2076 : Module A P'\ninst\u271d\u2075 : Module B P'\ninst\u271d\u2074 : IsScalarTower R A P'\ninst\u271d\u00b3 : IsScalarTower R B P'\ninst\u271d\u00b2 : SMulCommClass A B P'\ninst\u271d\u00b9 : AddCommMonoid Q'\ninst\u271d : Module R Q'\nf : M \u2192\u2097[A] P\ng\u2081 g\u2082 : N \u2192\u2097[R] Q\nx\u271d\u00b9 : M\nx\u271d : N\n\u22a2 ((curry (map f (g\u2081 + g\u2082))) x\u271d\u00b9) x\u271d = ((curry (map f g\u2081 + map f g\u2082)) x\u271d\u00b9) x\u271d"}, {"tactic": "simp_rw [curry_apply, TensorProduct.curry_apply, restrictScalars_apply, add_apply, map_tmul,\n  add_apply, tmul_add]", "annotated_tactic": ["simp_rw [<a>curry_apply</a>, <a>TensorProduct.curry_apply</a>, <a>restrictScalars_apply</a>, <a>add_apply</a>, <a>map_tmul</a>,\n    <a>add_apply</a>, <a>tmul_add</a>]", [{"full_name": "TensorProduct.AlgebraTensorModule.curry_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/TensorProduct/Tower.lean", "def_pos": [83, 3], "def_end_pos": [83, 8]}, {"full_name": "TensorProduct.curry_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/TensorProduct/Basic.lean", "def_pos": [659, 9], "def_end_pos": [659, 20]}, {"full_name": "LinearMap.restrictScalars_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [454, 9], "def_end_pos": [454, 30]}, {"full_name": "LinearMap.add_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [911, 9], "def_end_pos": [911, 18]}, {"full_name": "TensorProduct.AlgebraTensorModule.map_tmul", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/TensorProduct/Tower.lean", "def_pos": [198, 17], "def_end_pos": [198, 25]}, {"full_name": "LinearMap.add_apply", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/LinearMap/Basic.lean", "def_pos": [911, 9], "def_end_pos": [911, 18]}, {"full_name": "TensorProduct.tmul_add", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/TensorProduct/Basic.lean", "def_pos": [203, 9], "def_end_pos": [203, 17]}]], "state_before": "case a.h.h\nR : Type uR\nA : Type uA\nB : Type uB\nM : Type uM\nN : Type uN\nP : Type uP\nQ : Type uQ\nP' : Type uP'\nQ' : Type uQ'\ninst\u271d\u00b3\u00b9 : CommSemiring R\ninst\u271d\u00b3\u2070 : Semiring A\ninst\u271d\u00b2\u2079 : Semiring B\ninst\u271d\u00b2\u2078 : Algebra R A\ninst\u271d\u00b2\u2077 : Algebra R B\ninst\u271d\u00b2\u2076 : AddCommMonoid M\ninst\u271d\u00b2\u2075 : Module R M\ninst\u271d\u00b2\u2074 : Module A M\ninst\u271d\u00b2\u00b3 : Module B M\ninst\u271d\u00b2\u00b2 : IsScalarTower R A M\ninst\u271d\u00b2\u00b9 : IsScalarTower R B M\ninst\u271d\u00b2\u2070 : SMulCommClass A B M\ninst\u271d\u00b9\u2079 : AddCommMonoid N\ninst\u271d\u00b9\u2078 : Module R N\ninst\u271d\u00b9\u2077 : AddCommMonoid P\ninst\u271d\u00b9\u2076 : Module R P\ninst\u271d\u00b9\u2075 : Module A P\ninst\u271d\u00b9\u2074 : Module B P\ninst\u271d\u00b9\u00b3 : IsScalarTower R A P\ninst\u271d\u00b9\u00b2 : IsScalarTower R B P\ninst\u271d\u00b9\u00b9 : SMulCommClass A B P\ninst\u271d\u00b9\u2070 : AddCommMonoid Q\ninst\u271d\u2079 : Module R Q\ninst\u271d\u2078 : AddCommMonoid P'\ninst\u271d\u2077 : Module R P'\ninst\u271d\u2076 : Module A P'\ninst\u271d\u2075 : Module B P'\ninst\u271d\u2074 : IsScalarTower R A P'\ninst\u271d\u00b3 : IsScalarTower R B P'\ninst\u271d\u00b2 : SMulCommClass A B P'\ninst\u271d\u00b9 : AddCommMonoid Q'\ninst\u271d : Module R Q'\nf : M \u2192\u2097[A] P\ng\u2081 g\u2082 : N \u2192\u2097[R] Q\nx\u271d\u00b9 : M\nx\u271d : N\n\u22a2 ((curry (map f (g\u2081 + g\u2082))) x\u271d\u00b9) x\u271d = ((curry (map f g\u2081 + map f g\u2082)) x\u271d\u00b9) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Lifts.lean", "full_name": "Polynomial.lifts_and_degree_eq_and_monic", "start": [211, 1], "end": [230, 93], "traced_tactics": [{"tactic": "cases' subsingleton_or_nontrivial R with hR hR", "annotated_tactic": ["cases' <a>subsingleton_or_nontrivial</a> R with hR hR", [{"full_name": "subsingleton_or_nontrivial", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [99, 9], "def_end_pos": [99, 35]}]], "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "case inl\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Subsingleton R\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q\n\ncase inr\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q"}, {"tactic": "have H : erase p.natDegree p + X ^ p.natDegree = p := by\n  simpa only [hp.leadingCoeff, C_1, one_mul, eraseLead] using eraseLead_add_C_mul_X_pow p", "annotated_tactic": ["have H : <a>erase</a> p.natDegree p + <a>X</a> ^ p.natDegree = p := by\n    simpa only [hp.leadingCoeff, <a>C_1</a>, <a>one_mul</a>, <a>eraseLead</a>] using <a>eraseLead_add_C_mul_X_pow</a> p", [{"full_name": "Polynomial.erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1052, 17], "def_end_pos": [1052, 22]}, {"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.C_1", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [519, 9], "def_end_pos": [519, 12]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "Polynomial.eraseLead", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/EraseLead.lean", "def_pos": [36, 5], "def_end_pos": [36, 14]}, {"full_name": "Polynomial.eraseLead_add_C_mul_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/EraseLead.lean", "def_pos": [69, 9], "def_end_pos": [69, 34]}]], "state_before": "case inr\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "case inr\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q"}, {"tactic": "by_cases h0 : erase p.natDegree p = 0", "annotated_tactic": ["by_cases h0 : <a>erase</a> p.natDegree p = 0", [{"full_name": "Polynomial.erase", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1052, 17], "def_end_pos": [1052, 22]}]], "state_before": "case inr\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "case pos\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : erase (natDegree p) p = 0\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q\n\ncase neg\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q"}, {"tactic": "obtain \u27e8q, hq\u27e9 := mem_lifts_and_degree_eq (erase_mem_lifts p.natDegree hlifts)", "annotated_tactic": ["obtain \u27e8q, hq\u27e9 := <a>mem_lifts_and_degree_eq</a> (<a>erase_mem_lifts</a> p.natDegree hlifts)", [{"full_name": "Polynomial.mem_lifts_and_degree_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Lifts.lean", "def_pos": [166, 9], "def_end_pos": [166, 32]}, {"full_name": "Polynomial.erase_mem_lifts", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Lifts.lean", "def_pos": [128, 9], "def_end_pos": [128, 24]}]], "state_before": "case neg\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "case neg.intro\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q"}, {"tactic": "have p_neq_0 : p \u2260 0 := by intro hp; apply h0; rw [hp]; simp only [natDegree_zero, erase_zero]", "annotated_tactic": ["have p_neq_0 : p \u2260 0 := by intro hp; apply h0; rw [hp]; simp only [<a>natDegree_zero</a>, <a>erase_zero</a>]", [{"full_name": "Polynomial.natDegree_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [110, 9], "def_end_pos": [110, 23]}, {"full_name": "Polynomial.erase_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1091, 9], "def_end_pos": [1091, 19]}]], "state_before": "case neg.intro\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "case neg.intro\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q"}, {"tactic": "have hdeg : q.degree < (X ^ p.natDegree).degree := by\n  rw [@degree_X_pow R, hq.2, \u2190 degree_eq_natDegree p_neq_0]\n  exact degree_erase_lt p_neq_0", "annotated_tactic": ["have hdeg : q.degree < (<a>X</a> ^ p.natDegree).<a>degree</a> := by\n    rw [@<a>degree_X_pow</a> R, hq.2, \u2190 <a>degree_eq_natDegree</a> p_neq_0]\n    exact <a>degree_erase_lt</a> p_neq_0", [{"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.degree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [54, 5], "def_end_pos": [54, 11]}, {"full_name": "Polynomial.degree_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1338, 9], "def_end_pos": [1338, 21]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}, {"full_name": "Polynomial.degree_erase_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [796, 9], "def_end_pos": [796, 24]}]], "state_before": "case neg.intro\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "case neg.intro\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\nhdeg : degree q < degree (X ^ natDegree p)\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q"}, {"tactic": "refine' \u27e8q + X ^ p.natDegree, _, _, (monic_X_pow _).add_of_right hdeg\u27e9", "annotated_tactic": ["refine' \u27e8q + <a>X</a> ^ p.natDegree, _, _, (<a>monic_X_pow</a> _).<a>add_of_right</a> hdeg\u27e9", [{"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.monic_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [880, 9], "def_end_pos": [880, 20]}, {"full_name": "Polynomial.Monic.add_of_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [139, 9], "def_end_pos": [139, 27]}]], "state_before": "case neg.intro\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\nhdeg : degree q < degree (X ^ natDegree p)\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "case neg.intro.refine'_1\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\nhdeg : degree q < degree (X ^ natDegree p)\n\u22a2 map f (q + X ^ natDegree p) = p\n\ncase neg.intro.refine'_2\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\nhdeg : degree q < degree (X ^ natDegree p)\n\u22a2 degree (q + X ^ natDegree p) = degree p"}, {"tactic": "obtain \u27e8q, hq\u27e9 := mem_lifts_and_degree_eq hlifts", "annotated_tactic": ["obtain \u27e8q, hq\u27e9 := <a>mem_lifts_and_degree_eq</a> hlifts", [{"full_name": "Polynomial.mem_lifts_and_degree_eq", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Lifts.lean", "def_pos": [166, 9], "def_end_pos": [166, 32]}]], "state_before": "case inl\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Subsingleton R\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "case inl.intro\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Subsingleton R\nq : R[X]\nhq : map f q = p \u2227 degree q = degree p\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q"}, {"tactic": "exact \u27e8q, hq.1, hq.2, monic_of_subsingleton _\u27e9", "annotated_tactic": ["exact \u27e8q, hq.1, hq.2, <a>monic_of_subsingleton</a> _\u27e9", [{"full_name": "Polynomial.monic_of_subsingleton", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [84, 9], "def_end_pos": [84, 30]}]], "state_before": "case inl.intro\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Subsingleton R\nq : R[X]\nhq : map f q = p \u2227 degree q = degree p\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "no goals"}, {"tactic": "simpa only [hp.leadingCoeff, C_1, one_mul, eraseLead] using eraseLead_add_C_mul_X_pow p", "annotated_tactic": ["simpa only [hp.leadingCoeff, <a>C_1</a>, <a>one_mul</a>, <a>eraseLead</a>] using <a>eraseLead_add_C_mul_X_pow</a> p", [{"full_name": "Polynomial.C_1", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [519, 9], "def_end_pos": [519, 12]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}, {"full_name": "Polynomial.eraseLead", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/EraseLead.lean", "def_pos": [36, 5], "def_end_pos": [36, 14]}, {"full_name": "Polynomial.eraseLead_add_C_mul_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/EraseLead.lean", "def_pos": [69, 9], "def_end_pos": [69, 34]}]], "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\n\u22a2 erase (natDegree p) p + X ^ natDegree p = p", "state_after": "no goals"}, {"tactic": "rw [\u2190 H, h0, zero_add]", "annotated_tactic": ["rw [\u2190 H, h0, <a>zero_add</a>]", [{"full_name": "zero_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [473, 3], "def_end_pos": [473, 14]}]], "state_before": "case pos\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : erase (natDegree p) p = 0\n\u22a2 \u2203 q, map f q = p \u2227 degree q = degree p \u2227 Monic q", "state_after": "case pos\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : erase (natDegree p) p = 0\n\u22a2 \u2203 q, map f q = X ^ natDegree p \u2227 degree q = degree (X ^ natDegree p) \u2227 Monic q"}, {"tactic": "refine' \u27e8X ^ p.natDegree, _, _, monic_X_pow p.natDegree\u27e9", "annotated_tactic": ["refine' \u27e8<a>X</a> ^ p.natDegree, _, _, <a>monic_X_pow</a> p.natDegree\u27e9", [{"full_name": "Polynomial.X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [567, 5], "def_end_pos": [567, 6]}, {"full_name": "Polynomial.monic_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [880, 9], "def_end_pos": [880, 20]}]], "state_before": "case pos\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : erase (natDegree p) p = 0\n\u22a2 \u2203 q, map f q = X ^ natDegree p \u2227 degree q = degree (X ^ natDegree p) \u2227 Monic q", "state_after": "case pos.refine'_1\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : erase (natDegree p) p = 0\n\u22a2 map f (X ^ natDegree p) = X ^ natDegree p\n\ncase pos.refine'_2\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : erase (natDegree p) p = 0\n\u22a2 degree (X ^ natDegree p) = degree (X ^ natDegree p)"}, {"tactic": "rw [Polynomial.map_pow, map_X]", "annotated_tactic": ["rw [<a>Polynomial.map_pow</a>, <a>map_X</a>]", [{"full_name": "Polynomial.map_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [942, 19], "def_end_pos": [942, 26]}, {"full_name": "Polynomial.map_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [720, 9], "def_end_pos": [720, 14]}]], "state_before": "case pos.refine'_1\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : erase (natDegree p) p = 0\n\u22a2 map f (X ^ natDegree p) = X ^ natDegree p", "state_after": "no goals"}, {"tactic": "rw [degree_X_pow, degree_X_pow]", "annotated_tactic": ["rw [<a>degree_X_pow</a>, <a>degree_X_pow</a>]", [{"full_name": "Polynomial.degree_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1338, 9], "def_end_pos": [1338, 21]}, {"full_name": "Polynomial.degree_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1338, 9], "def_end_pos": [1338, 21]}]], "state_before": "case pos.refine'_2\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : erase (natDegree p) p = 0\n\u22a2 degree (X ^ natDegree p) = degree (X ^ natDegree p)", "state_after": "no goals"}, {"tactic": "intro hp", "annotated_tactic": ["intro hp", []], "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\n\u22a2 p \u2260 0", "state_after": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp\u271d : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\nhp : p = 0\n\u22a2 False"}, {"tactic": "apply h0", "annotated_tactic": ["apply h0", []], "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp\u271d : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\nhp : p = 0\n\u22a2 False", "state_after": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp\u271d : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\nhp : p = 0\n\u22a2 erase (natDegree p) p = 0"}, {"tactic": "rw [hp]", "annotated_tactic": ["rw [hp]", []], "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp\u271d : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\nhp : p = 0\n\u22a2 erase (natDegree p) p = 0", "state_after": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp\u271d : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\nhp : p = 0\n\u22a2 erase (natDegree 0) 0 = 0"}, {"tactic": "simp only [natDegree_zero, erase_zero]", "annotated_tactic": ["simp only [<a>natDegree_zero</a>, <a>erase_zero</a>]", [{"full_name": "Polynomial.natDegree_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [110, 9], "def_end_pos": [110, 23]}, {"full_name": "Polynomial.erase_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1091, 9], "def_end_pos": [1091, 19]}]], "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp\u271d : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\nhp : p = 0\n\u22a2 erase (natDegree 0) 0 = 0", "state_after": "no goals"}, {"tactic": "rw [@degree_X_pow R, hq.2, \u2190 degree_eq_natDegree p_neq_0]", "annotated_tactic": ["rw [@<a>degree_X_pow</a> R, hq.2, \u2190 <a>degree_eq_natDegree</a> p_neq_0]", [{"full_name": "Polynomial.degree_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1338, 9], "def_end_pos": [1338, 21]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}]], "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\n\u22a2 degree q < degree (X ^ natDegree p)", "state_after": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\n\u22a2 degree (erase (natDegree p) p) < degree p"}, {"tactic": "exact degree_erase_lt p_neq_0", "annotated_tactic": ["exact <a>degree_erase_lt</a> p_neq_0", [{"full_name": "Polynomial.degree_erase_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [796, 9], "def_end_pos": [796, 24]}]], "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\n\u22a2 degree (erase (natDegree p) p) < degree p", "state_after": "no goals"}, {"tactic": "rw [Polynomial.map_add, hq.1, Polynomial.map_pow, map_X, H]", "annotated_tactic": ["rw [<a>Polynomial.map_add</a>, hq.1, <a>Polynomial.map_pow</a>, <a>map_X</a>, H]", [{"full_name": "Polynomial.map_add", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [736, 19], "def_end_pos": [736, 26]}, {"full_name": "Polynomial.map_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [942, 19], "def_end_pos": [942, 26]}, {"full_name": "Polynomial.map_X", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [720, 9], "def_end_pos": [720, 14]}]], "state_before": "case neg.intro.refine'_1\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\nhdeg : degree q < degree (X ^ natDegree p)\n\u22a2 map f (q + X ^ natDegree p) = p", "state_after": "no goals"}, {"tactic": "rw [degree_add_eq_right_of_degree_lt hdeg, degree_X_pow, degree_eq_natDegree hp.ne_zero]", "annotated_tactic": ["rw [<a>degree_add_eq_right_of_degree_lt</a> hdeg, <a>degree_X_pow</a>, <a>degree_eq_natDegree</a> hp.ne_zero]", [{"full_name": "Polynomial.degree_add_eq_right_of_degree_lt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [721, 9], "def_end_pos": [721, 41]}, {"full_name": "Polynomial.degree_X_pow", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1338, 9], "def_end_pos": [1338, 21]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [134, 9], "def_end_pos": [134, 28]}]], "state_before": "case neg.intro.refine'_2\nR : Type u\ninst\u271d\u00b2 : Semiring R\nS : Type v\ninst\u271d\u00b9 : Semiring S\nf : R \u2192+* S\ninst\u271d : Nontrivial S\np : S[X]\nhlifts : p \u2208 lifts f\nhp : Monic p\nhR : Nontrivial R\nH : erase (natDegree p) p + X ^ natDegree p = p\nh0 : \u00acerase (natDegree p) p = 0\nq : R[X]\nhq : map f q = erase (natDegree p) p \u2227 degree q = degree (erase (natDegree p) p)\np_neq_0 : p \u2260 0\nhdeg : degree q < degree (X ^ natDegree p)\n\u22a2 degree (q + X ^ natDegree p) = degree p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Module/Equiv.lean", "full_name": "LinearEquiv.coe_injective", "start": [193, 1], "end": [194, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.commute_of_normal_of_disjoint", "start": [3704, 1], "end": [3718, 28], "traced_tactics": [{"tactic": "apply hdis.le_bot", "annotated_tactic": ["apply hdis.le_bot", []], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 = 1", "state_after": "case a\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 H\u2081 \u2293 H\u2082"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case a\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 H\u2081 \u2293 H\u2082", "state_after": "case a.left\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 \u2191H\u2081.toSubmonoid\n\ncase a.right\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 \u2191H\u2082.toSubmonoid"}, {"tactic": "show x * y = y * x", "annotated_tactic": ["show x * y = y * x", []], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\nthis : x * y * x\u207b\u00b9 * y\u207b\u00b9 = 1\n\u22a2 Commute x y", "state_after": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\nthis : x * y * x\u207b\u00b9 * y\u207b\u00b9 = 1\n\u22a2 x * y = y * x"}, {"tactic": "rw [mul_assoc, mul_eq_one_iff_eq_inv] at this", "annotated_tactic": ["rw [<a>mul_assoc</a>, <a>mul_eq_one_iff_eq_inv</a>] at this", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}, {"full_name": "mul_eq_one_iff_eq_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [730, 9], "def_end_pos": [730, 30]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\nthis : x * y * x\u207b\u00b9 * y\u207b\u00b9 = 1\n\u22a2 x * y = y * x", "state_after": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\nthis : x * y = (x\u207b\u00b9 * y\u207b\u00b9)\u207b\u00b9\n\u22a2 x * y = y * x"}, {"tactic": "simp only [this, mul_inv_rev, inv_inv]", "annotated_tactic": ["simp only [this, <a>mul_inv_rev</a>, <a>inv_inv</a>]", [{"full_name": "mul_inv_rev", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1070, 9], "def_end_pos": [1070, 20]}, {"full_name": "inv_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 16]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\nthis : x * y = (x\u207b\u00b9 * y\u207b\u00b9)\u207b\u00b9\n\u22a2 x * y = y * x", "state_after": "no goals"}, {"tactic": "suffices x * (y * x\u207b\u00b9 * y\u207b\u00b9) \u2208 H\u2081 by simpa [mul_assoc]", "annotated_tactic": ["suffices x * (y * x\u207b\u00b9 * y\u207b\u00b9) \u2208 H\u2081 by simpa [<a>mul_assoc</a>]", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "case a.left\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 \u2191H\u2081.toSubmonoid", "state_after": "case a.left\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * (y * x\u207b\u00b9 * y\u207b\u00b9) \u2208 H\u2081"}, {"tactic": "exact H\u2081.mul_mem hx (hH\u2081.conj_mem _ (H\u2081.inv_mem hx) _)", "annotated_tactic": ["exact H\u2081.mul_mem hx (hH\u2081.conj_mem _ (H\u2081.inv_mem hx) _)", []], "state_before": "case a.left\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * (y * x\u207b\u00b9 * y\u207b\u00b9) \u2208 H\u2081", "state_after": "no goals"}, {"tactic": "simpa [mul_assoc]", "annotated_tactic": ["simpa [<a>mul_assoc</a>]", [{"full_name": "mul_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [286, 9], "def_end_pos": [286, 18]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\nthis : x * (y * x\u207b\u00b9 * y\u207b\u00b9) \u2208 H\u2081\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 \u2191H\u2081.toSubmonoid", "state_after": "no goals"}, {"tactic": "show x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 H\u2082", "annotated_tactic": ["show x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 H\u2082", []], "state_before": "case a.right\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 \u2191H\u2082.toSubmonoid", "state_after": "case a.right\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 H\u2082"}, {"tactic": "apply H\u2082.mul_mem _ (H\u2082.inv_mem hy)", "annotated_tactic": ["apply H\u2082.mul_mem _ (H\u2082.inv_mem hy)", []], "state_before": "case a.right\nG : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 H\u2082", "state_after": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 \u2208 H\u2082"}, {"tactic": "apply hH\u2082.conj_mem _ hy", "annotated_tactic": ["apply hH\u2082.conj_mem _ hy", []], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nH\u2081 H\u2082 : Subgroup G\nhH\u2081 : Normal H\u2081\nhH\u2082 : Normal H\u2082\nhdis : Disjoint H\u2081 H\u2082\nx y : G\nhx : x \u2208 H\u2081\nhy : y \u2208 H\u2082\n\u22a2 x * y * x\u207b\u00b9 \u2208 H\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/PseudoMetric.lean", "full_name": "UniformContinuous.dist", "start": [1695, 11], "end": [1697, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Bilinear.lean", "full_name": "LinearMap.map_mul_iff", "start": [163, 1], "end": [166, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.iInf_eq_zero_iff", "start": [809, 1], "end": [811, 32], "traced_tactics": [{"tactic": "simp [iInf, sInf_eq_zero_iff]", "annotated_tactic": ["simp [<a>iInf</a>, <a>sInf_eq_zero_iff</a>]", [{"full_name": "iInf", "def_path": ".lake/packages/mathlib/Mathlib/Order/SetNotation.lean", "def_pos": [69, 5], "def_end_pos": [69, 9]}, {"full_name": "Cardinal.sInf_eq_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [800, 7], "def_end_pos": [800, 23]}]], "state_before": "\u03b1 \u03b2 : Type u\n\u03b9 : Sort u_1\nf : \u03b9 \u2192 Cardinal.{u_2}\n\u22a2 \u2a05 i, f i = 0 \u2194 IsEmpty \u03b9 \u2228 \u2203 i, f i = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "Subtype.coe_sup", "start": [1381, 1], "end": [1384, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.constantCoeff_comp_C", "start": [926, 1], "end": [928, 28], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\n\u22a2 RingHom.comp constantCoeff C = RingHom.id R", "state_after": "case a\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nx : R\n\u22a2 (RingHom.comp constantCoeff C) x = (RingHom.id R) x"}, {"tactic": "exact constantCoeff_C \u03c3 x", "annotated_tactic": ["exact <a>constantCoeff_C</a> \u03c3 x", [{"full_name": "MvPolynomial.constantCoeff_C", "def_path": ".lake/packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [897, 9], "def_end_pos": [897, 24]}]], "state_before": "case a\nR : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nx : R\n\u22a2 (RingHom.comp constantCoeff C) x = (RingHom.id R) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/GroupWithZero/Defs.lean", "full_name": "mul_self_eq_zero", "start": [266, 1], "end": [266, 56], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "G\u2080 : Type u\nM\u2080 : Type u_1\nM\u2080' : Type u_2\nG\u2080' : Type u_3\ninst\u271d\u00b9 : MulZeroClass M\u2080\ninst\u271d : NoZeroDivisors M\u2080\na b : M\u2080\n\u22a2 a * a = 0 \u2194 a = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Real.rpow_lt_rpow_iff", "start": [557, 1], "end": [558, 99], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/Laurent.lean", "full_name": "Polynomial.toLaurent_comp_C", "start": [235, 1], "end": [236, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.mem_bind'", "start": [2915, 1], "end": [2917, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "map_nhds_subtype_val", "start": [1134, 1], "end": [1135, 59], "traced_tactics": [{"tactic": "rw [inducing_subtype_val.map_nhds_eq, Subtype.range_val]", "annotated_tactic": ["rw [inducing_subtype_val.map_nhds_eq, <a>Subtype.range_val</a>]", [{"full_name": "Subtype.range_val", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1377, 9], "def_end_pos": [1377, 18]}]], "state_before": "X : Type u\nY : Type v\nZ : Type u_1\nW : Type u_2\n\u03b5 : Type u_3\n\u03b6 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\np : X \u2192 Prop\ns : Set X\nx : \u2191s\n\u22a2 map Subtype.val (\ud835\udcdd x) = \ud835\udcdd[s] \u2191x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Module/StrongTopology.lean", "full_name": "ContinuousLinearMap.strongTopology.continuousConstSMul", "start": [179, 1], "end": [188, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.roots_smul_nonzero", "start": [834, 1], "end": [835, 39], "traced_tactics": [{"tactic": "rw [smul_eq_C_mul, roots_C_mul _ ha]", "annotated_tactic": ["rw [<a>smul_eq_C_mul</a>, <a>roots_C_mul</a> _ ha]", [{"full_name": "Polynomial.smul_eq_C_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [381, 9], "def_end_pos": [381, 22]}, {"full_name": "Polynomial.roots_C_mul", "def_path": ".lake/packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [826, 9], "def_end_pos": [826, 20]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q p : R[X]\nha : a \u2260 0\n\u22a2 roots (a \u2022 p) = roots p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/SetTheory/Cardinal/ENat.lean", "full_name": "Cardinal.ofENat_lt_lift", "start": [133, 1], "end": [134, 37], "traced_tactics": [{"tactic": "rw [\u2190 lift_ofENat.{u, v}, lift_lt]", "annotated_tactic": ["rw [\u2190 <a>lift_ofENat</a>.{u, v}, <a>lift_lt</a>]", [{"full_name": "Cardinal.lift_ofENat", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/ENat.lean", "def_pos": [120, 26], "def_end_pos": [120, 37]}, {"full_name": "Cardinal.lift_lt", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [363, 9], "def_end_pos": [363, 16]}]], "state_before": "x : Cardinal.{v}\nm : \u2115\u221e\n\u22a2 \u2191m < lift.{u, v} x \u2194 \u2191m < x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean", "full_name": "DifferentiableOn.exp", "start": [313, 1], "end": [314, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/NormedSpace.lean", "full_name": "ContinuousLinearEquiv.subsingleton_or_nnnorm_symm_pos", "start": [343, 1], "end": [345, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "full_name": "cauchySeq_of_edist_le_of_summable", "start": [24, 1], "end": [40, 22], "traced_tactics": [{"tactic": "refine EMetric.cauchySeq_iff_NNReal.2 fun \u03b5 \u03b5pos \u21a6 ?_", "annotated_tactic": ["refine <a>EMetric.cauchySeq_iff_NNReal</a>.2 fun \u03b5 \u03b5pos \u21a6 ?_", [{"full_name": "EMetric.cauchySeq_iff_NNReal", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean", "def_pos": [758, 9], "def_end_pos": [758, 29]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\nhd : Summable d\n\u22a2 CauchySeq f", "state_after": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\nhd : Summable d\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\n\u22a2 \u2203 N, \u2200 (n : \u2115), N \u2264 n \u2192 edist (f n) (f N) < \u2191\u03b5"}, {"tactic": "replace hd : CauchySeq fun n : \u2115 \u21a6 \u2211 x in range n, d x :=\n  let \u27e8_, H\u27e9 := hd\n  H.tendsto_sum_nat.cauchySeq", "annotated_tactic": ["replace hd : <a>CauchySeq</a> fun n : \u2115 \u21a6 \u2211 x in <a>range</a> n, d x :=\n    let \u27e8_, H\u27e9 := hd\n    H.tendsto_sum_nat.cauchySeq", [{"full_name": "CauchySeq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/UniformSpace/Cauchy.lean", "def_pos": [198, 5], "def_end_pos": [198, 14]}, {"full_name": "Finset.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3117, 5], "def_end_pos": [3117, 10]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\nhd : Summable d\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\n\u22a2 \u2203 N, \u2200 (n : \u2115), N \u2264 n \u2192 edist (f n) (f N) < \u2191\u03b5", "state_after": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\n\u22a2 \u2203 N, \u2200 (n : \u2115), N \u2264 n \u2192 edist (f n) (f N) < \u2191\u03b5"}, {"tactic": "refine (Metric.cauchySeq_iff'.1 hd \u03b5 (NNReal.coe_pos.2 \u03b5pos)).imp fun N hN n hn \u21a6 ?_", "annotated_tactic": ["refine (<a>Metric.cauchySeq_iff'</a>.1 hd \u03b5 (<a>NNReal.coe_pos</a>.2 \u03b5pos)).<a>imp</a> fun N hN n hn \u21a6 ?_", [{"full_name": "Metric.cauchySeq_iff'", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/Cauchy.lean", "def_pos": [63, 9], "def_end_pos": [63, 30]}, {"full_name": "NNReal.coe_pos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [377, 26], "def_end_pos": [377, 33]}, {"full_name": "Exists.imp", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [126, 9], "def_end_pos": [126, 19]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\n\u22a2 \u2203 N, \u2200 (n : \u2115), N \u2264 n \u2192 edist (f n) (f N) < \u2191\u03b5", "state_after": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN : \u2115\nhN : \u2200 n \u2265 N, dist (\u2211 x in range n, d x) (\u2211 x in range N, d x) < \u2191\u03b5\nn : \u2115\nhn : N \u2264 n\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"tactic": "specialize hN n hn", "annotated_tactic": ["specialize hN n hn", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN : \u2115\nhN : \u2200 n \u2265 N, dist (\u2211 x in range n, d x) (\u2211 x in range N, d x) < \u2191\u03b5\nn : \u2115\nhn : N \u2264 n\n\u22a2 edist (f n) (f N) < \u2191\u03b5", "state_after": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : dist (\u2211 x in range n, d x) (\u2211 x in range N, d x) < \u2191\u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"tactic": "rw [dist_nndist, NNReal.nndist_eq, \u2190 sum_range_add_sum_Ico _ hn, add_tsub_cancel_left,\n  NNReal.coe_lt_coe, max_lt_iff] at hN", "annotated_tactic": ["rw [<a>dist_nndist</a>, <a>NNReal.nndist_eq</a>, \u2190 <a>sum_range_add_sum_Ico</a> _ hn, <a>add_tsub_cancel_left</a>,\n    <a>NNReal.coe_lt_coe</a>, <a>max_lt_iff</a>] at hN", [{"full_name": "dist_nndist", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [300, 9], "def_end_pos": [300, 20]}, {"full_name": "NNReal.nndist_eq", "def_path": ".lake/packages/mathlib/Mathlib/Topology/MetricSpace/PseudoMetric.lean", "def_pos": [1570, 9], "def_end_pos": [1570, 25]}, {"full_name": "Finset.sum_range_add_sum_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Intervals.lean", "def_pos": [133, 3], "def_end_pos": [133, 14]}, {"full_name": "add_tsub_cancel_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 29]}, {"full_name": "NNReal.coe_lt_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [374, 26], "def_end_pos": [374, 36]}, {"full_name": "max_lt_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/MinMax.lean", "def_pos": [68, 9], "def_end_pos": [68, 19]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : dist (\u2211 x in range n, d x) (\u2211 x in range N, d x) < \u2191\u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5", "state_after": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : \u2211 k in Ico N n, d k < \u03b5 \u2227 \u2211 x in range N, d x - (\u2211 k in range N, d k + \u2211 k in Ico N n, d k) < \u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5"}, {"tactic": "rw [edist_comm]", "annotated_tactic": ["rw [<a>edist_comm</a>]", [{"full_name": "PseudoEMetricSpace.edist_comm", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean", "def_pos": [82, 3], "def_end_pos": [82, 13]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : \u2211 k in Ico N n, d k < \u03b5 \u2227 \u2211 x in range N, d x - (\u2211 k in range N, d k + \u2211 k in Ico N n, d k) < \u03b5\n\u22a2 edist (f n) (f N) < \u2191\u03b5", "state_after": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : \u2211 k in Ico N n, d k < \u03b5 \u2227 \u2211 x in range N, d x - (\u2211 k in range N, d k + \u2211 k in Ico N n, d k) < \u03b5\n\u22a2 edist (f N) (f n) < \u2191\u03b5"}, {"tactic": "refine lt_of_le_of_lt (edist_le_Ico_sum_of_edist_le hn fun _ _ \u21a6 hf _) ?_", "annotated_tactic": ["refine <a>lt_of_le_of_lt</a> (<a>edist_le_Ico_sum_of_edist_le</a> hn fun _ _ \u21a6 hf _) ?_", [{"full_name": "lt_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}, {"full_name": "edist_le_Ico_sum_of_edist_le", "def_path": ".lake/packages/mathlib/Mathlib/Topology/EMetricSpace/Basic.lean", "def_pos": [153, 9], "def_end_pos": [153, 37]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : \u2211 k in Ico N n, d k < \u03b5 \u2227 \u2211 x in range N, d x - (\u2211 k in range N, d k + \u2211 k in Ico N n, d k) < \u03b5\n\u22a2 edist (f N) (f n) < \u2191\u03b5", "state_after": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : \u2211 k in Ico N n, d k < \u03b5 \u2227 \u2211 x in range N, d x - (\u2211 k in range N, d k + \u2211 k in Ico N n, d k) < \u03b5\n\u22a2 \u2211 i in Ico N n, \u2191(d i) < \u2191\u03b5"}, {"tactic": "exact mod_cast hN.1", "annotated_tactic": ["exact mod_cast hN.1", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : PseudoEMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\u22650\nhf : \u2200 (n : \u2115), edist (f n) (f (Nat.succ n)) \u2264 \u2191(d n)\n\u03b5 : \u211d\u22650\n\u03b5pos : 0 < \u03b5\nhd : CauchySeq fun n => \u2211 x in range n, d x\nN n : \u2115\nhn : N \u2264 n\nhN : \u2211 k in Ico N n, d k < \u03b5 \u2227 \u2211 x in range N, d x - (\u2211 k in range N, d k + \u2211 k in Ico N n, d k) < \u03b5\n\u22a2 \u2211 i in Ico N n, \u2191(d i) < \u2191\u03b5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/AffineIsometry.lean", "full_name": "AffineIsometry.coe_id", "start": [215, 1], "end": [216, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/TensorProduct/Basic.lean", "full_name": "LinearMap.baseChange_mul", "start": [113, 1], "end": [115, 12], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : Algebra R A\ninst\u271d\u2077 : Semiring B\ninst\u271d\u2076 : Algebra R B\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\ninst\u271d : Module R P\nr : R\nf\u271d g\u271d : M \u2192\u2097[R] N\nf g : Module.End R M\n\u22a2 baseChange A (f * g) = baseChange A f * baseChange A g", "state_after": "case a.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : Algebra R A\ninst\u271d\u2077 : Semiring B\ninst\u271d\u2076 : Algebra R B\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\ninst\u271d : Module R P\nr : R\nf\u271d g\u271d : M \u2192\u2097[R] N\nf g : Module.End R M\nx\u271d : M\n\u22a2 ((AlgebraTensorModule.curry (baseChange A (f * g))) 1) x\u271d =\n    ((AlgebraTensorModule.curry (baseChange A f * baseChange A g)) 1) x\u271d"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : Algebra R A\ninst\u271d\u2077 : Semiring B\ninst\u271d\u2076 : Algebra R B\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\ninst\u271d : Module R P\nr : R\nf\u271d g\u271d : M \u2192\u2097[R] N\nf g : Module.End R M\nx\u271d : M\n\u22a2 ((AlgebraTensorModule.curry (baseChange A (f * g))) 1) x\u271d =\n    ((AlgebraTensorModule.curry (baseChange A f * baseChange A g)) 1) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.rightInverse_symm", "start": [382, 1], "end": [382, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean", "full_name": "quadraticChar_card_card", "start": [97, 1], "end": [115, 46], "traced_tactics": [{"tactic": "let \u03c7 := (quadraticChar F).ringHomComp (algebraMap \u2124 F')", "annotated_tactic": ["let \u03c7 := (<a>quadraticChar</a> F).<a>ringHomComp</a> (<a>algebraMap</a> \u2124 F')", [{"full_name": "quadraticChar", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [129, 5], "def_end_pos": [129, 18]}, {"full_name": "MulChar.ringHomComp", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "def_pos": [467, 5], "def_end_pos": [467, 16]}, {"full_name": "algebraMap", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [120, 5], "def_end_pos": [120, 15]}]], "state_before": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))", "state_after": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))"}, {"tactic": "have h\u03c7\u2081 : \u03c7.IsNontrivial := by\n  obtain \u27e8a, ha\u27e9 := quadraticChar_exists_neg_one hF\n  have hu : IsUnit a := by\n    contrapose ha\n    exact ne_of_eq_of_ne (map_nonunit (quadraticChar F) ha) (mt zero_eq_neg.mp one_ne_zero)\n  use hu.unit\n  simp only [\u03c7, IsUnit.unit_spec, ringHomComp_apply, eq_intCast, Ne.def, ha]\n  rw [Int.cast_neg, Int.cast_one]\n  exact Ring.neg_one_ne_one_of_char_ne_two hF'", "annotated_tactic": ["have h\u03c7\u2081 : \u03c7.IsNontrivial := by\n    obtain \u27e8a, ha\u27e9 := <a>quadraticChar_exists_neg_one</a> hF\n    have hu : <a>IsUnit</a> a := by\n      contrapose ha\n      exact <a>ne_of_eq_of_ne</a> (<a>map_nonunit</a> (<a>quadraticChar</a> F) ha) (<a>mt</a> zero_eq_neg.mp <a>one_ne_zero</a>)\n    use hu.unit\n    simp only [\u03c7, <a>IsUnit.unit_spec</a>, <a>ringHomComp_apply</a>, <a>eq_intCast</a>, <a>Ne.def</a>, ha]\n    rw [<a>Int.cast_neg</a>, <a>Int.cast_one</a>]\n    exact <a>Ring.neg_one_ne_one_of_char_ne_two</a> hF'", [{"full_name": "quadraticChar_exists_neg_one", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [191, 9], "def_end_pos": [191, 37]}, {"full_name": "IsUnit", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [637, 5], "def_end_pos": [637, 11]}, {"full_name": "ne_of_eq_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [532, 7], "def_end_pos": [532, 21]}, {"full_name": "MulChar.map_nonunit", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}, {"full_name": "quadraticChar", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [129, 5], "def_end_pos": [129, 18]}, {"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "one_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}, {"full_name": "IsUnit.unit_spec", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [819, 9], "def_end_pos": [819, 18]}, {"full_name": "MulChar.ringHomComp_apply", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "def_pos": [466, 3], "def_end_pos": [466, 8]}, {"full_name": "eq_intCast", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [478, 9], "def_end_pos": [478, 19]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Int.cast_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [84, 9], "def_end_pos": [84, 17]}, {"full_name": "Int.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [78, 9], "def_end_pos": [78, 17]}, {"full_name": "Ring.neg_one_ne_one_of_char_ne_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharP/Basic.lean", "def_pos": [523, 9], "def_end_pos": [523, 43]}]], "state_before": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))", "state_after": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\nh\u03c7\u2081 : IsNontrivial \u03c7\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))"}, {"tactic": "have h\u03c7\u2082 : \u03c7.IsQuadratic := IsQuadratic.comp (quadraticChar_isQuadratic F) _", "annotated_tactic": ["have h\u03c7\u2082 : \u03c7.IsQuadratic := <a>IsQuadratic.comp</a> (<a>quadraticChar_isQuadratic</a> F) _", [{"full_name": "MulChar.IsQuadratic.comp", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "def_pos": [483, 9], "def_end_pos": [483, 25]}, {"full_name": "quadraticChar_isQuadratic", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [224, 9], "def_end_pos": [224, 34]}]], "state_before": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\nh\u03c7\u2081 : IsNontrivial \u03c7\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))", "state_after": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\nh\u03c7\u2081 : IsNontrivial \u03c7\nh\u03c7\u2082 : IsQuadratic \u03c7\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))"}, {"tactic": "have h := Char.card_pow_card h\u03c7\u2081 h\u03c7\u2082 h hF'", "annotated_tactic": ["have h := <a>Char.card_pow_card</a> h\u03c7\u2081 h\u03c7\u2082 h hF'", [{"full_name": "Char.card_pow_card", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/GaussSum.lean", "def_pos": [213, 9], "def_end_pos": [213, 27]}]], "state_before": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\nh\u03c7\u2081 : IsNontrivial \u03c7\nh\u03c7\u2082 : IsQuadratic \u03c7\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))", "state_after": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh\u271d : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\nh\u03c7\u2081 : IsNontrivial \u03c7\nh\u03c7\u2082 : IsQuadratic \u03c7\nh : (\u03c7 (-1) * \u2191(Fintype.card F)) ^ (Fintype.card F' / 2) = \u03c7 \u2191(Fintype.card F')\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))"}, {"tactic": "rw [\u2190 quadraticChar_eq_pow_of_char_ne_two' hF'] at h", "annotated_tactic": ["rw [\u2190 <a>quadraticChar_eq_pow_of_char_ne_two'</a> hF'] at h", [{"full_name": "quadraticChar_eq_pow_of_char_ne_two'", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 45]}]], "state_before": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh\u271d : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\nh\u03c7\u2081 : IsNontrivial \u03c7\nh\u03c7\u2082 : IsQuadratic \u03c7\nh : (\u03c7 (-1) * \u2191(Fintype.card F)) ^ (Fintype.card F' / 2) = \u03c7 \u2191(Fintype.card F')\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))", "state_after": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh\u271d : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\nh\u03c7\u2081 : IsNontrivial \u03c7\nh\u03c7\u2082 : IsQuadratic \u03c7\nh : \u2191((quadraticChar F') (\u03c7 (-1) * \u2191(Fintype.card F))) = \u03c7 \u2191(Fintype.card F')\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))"}, {"tactic": "exact (IsQuadratic.eq_of_eq_coe (quadraticChar_isQuadratic F')\n  (quadraticChar_isQuadratic F) hF' h).symm", "annotated_tactic": ["exact (<a>IsQuadratic.eq_of_eq_coe</a> (<a>quadraticChar_isQuadratic</a> F')\n    (<a>quadraticChar_isQuadratic</a> F) hF' h).<a>symm</a>", [{"full_name": "MulChar.IsQuadratic.eq_of_eq_coe", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "def_pos": [459, 9], "def_end_pos": [459, 33]}, {"full_name": "quadraticChar_isQuadratic", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [224, 9], "def_end_pos": [224, 34]}, {"full_name": "quadraticChar_isQuadratic", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [224, 9], "def_end_pos": [224, 34]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh\u271d : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\nh\u03c7\u2081 : IsNontrivial \u03c7\nh\u03c7\u2082 : IsQuadratic \u03c7\nh : \u2191((quadraticChar F') (\u03c7 (-1) * \u2191(Fintype.card F))) = \u03c7 \u2191(Fintype.card F')\n\u22a2 (quadraticChar F) \u2191(Fintype.card F') = (quadraticChar F') (\u2191((quadraticChar F) (-1)) * \u2191(Fintype.card F))", "state_after": "no goals"}, {"tactic": "obtain \u27e8a, ha\u27e9 := quadraticChar_exists_neg_one hF", "annotated_tactic": ["obtain \u27e8a, ha\u27e9 := <a>quadraticChar_exists_neg_one</a> hF", [{"full_name": "quadraticChar_exists_neg_one", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [191, 9], "def_end_pos": [191, 37]}]], "state_before": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\n\u22a2 IsNontrivial \u03c7", "state_after": "case intro\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\n\u22a2 IsNontrivial \u03c7"}, {"tactic": "have hu : IsUnit a := by\n  contrapose ha\n  exact ne_of_eq_of_ne (map_nonunit (quadraticChar F) ha) (mt zero_eq_neg.mp one_ne_zero)", "annotated_tactic": ["have hu : <a>IsUnit</a> a := by\n      contrapose ha\n      exact <a>ne_of_eq_of_ne</a> (<a>map_nonunit</a> (<a>quadraticChar</a> F) ha) (<a>mt</a> zero_eq_neg.mp <a>one_ne_zero</a>)", [{"full_name": "IsUnit", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [637, 5], "def_end_pos": [637, 11]}, {"full_name": "ne_of_eq_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [532, 7], "def_end_pos": [532, 21]}, {"full_name": "MulChar.map_nonunit", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}, {"full_name": "quadraticChar", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [129, 5], "def_end_pos": [129, 18]}, {"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "one_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}]], "state_before": "case intro\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\n\u22a2 IsNontrivial \u03c7", "state_after": "case intro\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\nhu : IsUnit a\n\u22a2 IsNontrivial \u03c7"}, {"tactic": "use hu.unit", "annotated_tactic": ["use hu.unit", []], "state_before": "case intro\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\nhu : IsUnit a\n\u22a2 IsNontrivial \u03c7", "state_after": "case h\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\nhu : IsUnit a\n\u22a2 \u03c7 \u2191(IsUnit.unit hu) \u2260 1"}, {"tactic": "simp only [\u03c7, IsUnit.unit_spec, ringHomComp_apply, eq_intCast, Ne.def, ha]", "annotated_tactic": ["simp only [\u03c7, <a>IsUnit.unit_spec</a>, <a>ringHomComp_apply</a>, <a>eq_intCast</a>, <a>Ne.def</a>, ha]", [{"full_name": "IsUnit.unit_spec", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [819, 9], "def_end_pos": [819, 18]}, {"full_name": "MulChar.ringHomComp_apply", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "def_pos": [466, 3], "def_end_pos": [466, 8]}, {"full_name": "eq_intCast", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Lemmas.lean", "def_pos": [478, 9], "def_end_pos": [478, 19]}, {"full_name": "Ne.def", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}]], "state_before": "case h\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\nhu : IsUnit a\n\u22a2 \u03c7 \u2191(IsUnit.unit hu) \u2260 1", "state_after": "case h\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\nhu : IsUnit a\n\u22a2 \u00ac\u2191(-1) = 1"}, {"tactic": "rw [Int.cast_neg, Int.cast_one]", "annotated_tactic": ["rw [<a>Int.cast_neg</a>, <a>Int.cast_one</a>]", [{"full_name": "Int.cast_neg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [84, 9], "def_end_pos": [84, 17]}, {"full_name": "Int.cast_one", "def_path": ".lake/packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [78, 9], "def_end_pos": [78, 17]}]], "state_before": "case h\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\nhu : IsUnit a\n\u22a2 \u00ac\u2191(-1) = 1", "state_after": "case h\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\nhu : IsUnit a\n\u22a2 \u00ac-1 = 1"}, {"tactic": "exact Ring.neg_one_ne_one_of_char_ne_two hF'", "annotated_tactic": ["exact <a>Ring.neg_one_ne_one_of_char_ne_two</a> hF'", [{"full_name": "Ring.neg_one_ne_one_of_char_ne_two", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/CharP/Basic.lean", "def_pos": [523, 9], "def_end_pos": [523, 43]}]], "state_before": "case h\nF : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\nhu : IsUnit a\n\u22a2 \u00ac-1 = 1", "state_after": "no goals"}, {"tactic": "contrapose ha", "annotated_tactic": ["contrapose ha", []], "state_before": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : (quadraticChar F) a = -1\n\u22a2 IsUnit a", "state_after": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : \u00acIsUnit a\n\u22a2 \u00ac(quadraticChar F) a = -1"}, {"tactic": "exact ne_of_eq_of_ne (map_nonunit (quadraticChar F) ha) (mt zero_eq_neg.mp one_ne_zero)", "annotated_tactic": ["exact <a>ne_of_eq_of_ne</a> (<a>map_nonunit</a> (<a>quadraticChar</a> F) ha) (<a>mt</a> zero_eq_neg.mp <a>one_ne_zero</a>)", [{"full_name": "ne_of_eq_of_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [532, 7], "def_end_pos": [532, 21]}, {"full_name": "MulChar.map_nonunit", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/MulCharacter.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}, {"full_name": "quadraticChar", "def_path": ".lake/packages/mathlib/Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean", "def_pos": [129, 5], "def_end_pos": [129, 18]}, {"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "one_ne_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}]], "state_before": "F : Type u_1\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Fintype F\ninst\u271d\u00b3 : DecidableEq F\nhF : ringChar F \u2260 2\nF' : Type u_2\ninst\u271d\u00b2 : Field F'\ninst\u271d\u00b9 : Fintype F'\ninst\u271d : DecidableEq F'\nhF' : ringChar F' \u2260 2\nh : ringChar F' \u2260 ringChar F\n\u03c7 : MulChar F F' := ringHomComp (quadraticChar F) (algebraMap \u2124 F')\na : F\nha : \u00acIsUnit a\n\u22a2 \u00ac(quadraticChar F) a = -1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.coe_coeEmb", "start": [471, 1], "end": [472, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/ENNReal/Real.lean", "full_name": "ENNReal.ofReal_prod_of_nonneg", "start": [503, 1], "end": [506, 40], "traced_tactics": [{"tactic": "simp_rw [ENNReal.ofReal, \u2190 coe_finset_prod, coe_inj]", "annotated_tactic": ["simp_rw [<a>ENNReal.ofReal</a>, \u2190 <a>coe_finset_prod</a>, <a>coe_inj</a>]", [{"full_name": "ENNReal.ofReal", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [198, 29], "def_end_pos": [198, 35]}, {"full_name": "ENNReal.coe_finset_prod", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Operations.lean", "def_pos": [296, 9], "def_end_pos": [296, 24]}, {"full_name": "ENNReal.coe_inj", "def_path": ".lake/packages/mathlib/Mathlib/Data/ENNReal/Basic.lean", "def_pos": [181, 26], "def_end_pos": [181, 33]}]], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u03b1 : Type u_1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 i \u2208 s, 0 \u2264 f i\n\u22a2 ENNReal.ofReal (\u220f i in s, f i) = \u220f i in s, ENNReal.ofReal (f i)", "state_after": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u03b1 : Type u_1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 i \u2208 s, 0 \u2264 f i\n\u22a2 Real.toNNReal (\u220f i in s, f i) = \u220f a in s, Real.toNNReal (f a)"}, {"tactic": "exact Real.toNNReal_prod_of_nonneg hf", "annotated_tactic": ["exact <a>Real.toNNReal_prod_of_nonneg</a> hf", [{"full_name": "Real.toNNReal_prod_of_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [347, 9], "def_end_pos": [347, 44]}]], "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\n\u03b1 : Type u_1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 i \u2208 s, 0 \u2264 f i\n\u22a2 Real.toNNReal (\u220f i in s, f i) = \u220f a in s, Real.toNNReal (f a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.mem_cyclicPermutations_self", "start": [608, 1], "end": [613, 9], "traced_tactics": [{"tactic": "cases' l with x l", "annotated_tactic": ["cases' l with x l", []], "state_before": "\u03b1 : Type u\nl\u271d l' l : List \u03b1\n\u22a2 l \u2208 cyclicPermutations l", "state_after": "case nil\n\u03b1 : Type u\nl l' : List \u03b1\n\u22a2 [] \u2208 cyclicPermutations []\n\ncase cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nx : \u03b1\nl : List \u03b1\n\u22a2 x :: l \u2208 cyclicPermutations (x :: l)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil\n\u03b1 : Type u\nl l' : List \u03b1\n\u22a2 [] \u2208 cyclicPermutations []", "state_after": "no goals"}, {"tactic": "rw [mem_iff_nthLe]", "annotated_tactic": ["rw [<a>mem_iff_nthLe</a>]", [{"full_name": "List.mem_iff_nthLe", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1224, 9], "def_end_pos": [1224, 22]}]], "state_before": "case cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nx : \u03b1\nl : List \u03b1\n\u22a2 x :: l \u2208 cyclicPermutations (x :: l)", "state_after": "case cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nx : \u03b1\nl : List \u03b1\n\u22a2 \u2203 n, \u2203 (h : n < length (cyclicPermutations (x :: l))), nthLe (cyclicPermutations (x :: l)) n h = x :: l"}, {"tactic": "refine' \u27e80, by simp, _\u27e9", "annotated_tactic": ["refine' \u27e80, by simp, _\u27e9", []], "state_before": "case cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nx : \u03b1\nl : List \u03b1\n\u22a2 \u2203 n, \u2203 (h : n < length (cyclicPermutations (x :: l))), nthLe (cyclicPermutations (x :: l)) n h = x :: l", "state_after": "case cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nx : \u03b1\nl : List \u03b1\n\u22a2 nthLe (cyclicPermutations (x :: l)) 0 \u22ef = x :: l"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case cons\n\u03b1 : Type u\nl\u271d l' : List \u03b1\nx : \u03b1\nl : List \u03b1\n\u22a2 nthLe (cyclicPermutations (x :: l)) 0 \u22ef = x :: l", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\nl\u271d l' : List \u03b1\nx : \u03b1\nl : List \u03b1\n\u22a2 0 < length (cyclicPermutations (x :: l))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "toIcoDiv_apply_right", "start": [214, 1], "end": [215, 54], "traced_tactics": [{"tactic": "simp [hp]", "annotated_tactic": ["simp [hp]", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b c : \u03b1\nn : \u2124\na : \u03b1\n\u22a2 a + p - 1 \u2022 p \u2208 Set.Ico a (a + p)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "exists_unique_eq", "start": [757, 9], "end": [758, 70], "traced_tactics": [{"tactic": "simp only [eq_comm, ExistsUnique, and_self, forall_eq', exists_eq']", "annotated_tactic": ["simp only [<a>eq_comm</a>, <a>ExistsUnique</a>, <a>and_self</a>, <a>forall_eq'</a>, <a>exists_eq'</a>]", [{"full_name": "eq_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [806, 9], "def_end_pos": [806, 16]}, {"full_name": "ExistsUnique", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [214, 5], "def_end_pos": [214, 17]}, {"full_name": "and_self", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [105, 17], "def_end_pos": [105, 25]}, {"full_name": "forall_eq'", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [209, 17], "def_end_pos": [209, 27]}, {"full_name": "exists_eq'", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [213, 17], "def_end_pos": [213, 27]}]], "state_before": "\u03b9 : Sort ?u.13187\n\u03b1 : Sort u_2\n\u03ba : \u03b9 \u2192 Sort u_1\np q : \u03b1 \u2192 Prop\na' : \u03b1\n\u22a2 \u2203! a, a = a'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Sign.lean", "full_name": "SignType.coe_mul", "start": [305, 1], "end": [307, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Zorn.lean", "full_name": "zorn_nonempty_partialOrder\u2080", "start": [177, 1], "end": [181, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Group/Basic.lean", "full_name": "tendsto_inv_nhdsWithin_Iic_inv", "start": [603, 1], "end": [604, 69], "traced_tactics": [{"tactic": "simpa only [inv_inv] using @tendsto_inv_nhdsWithin_Iic _ _ _ _ a\u207b\u00b9", "annotated_tactic": ["simpa only [<a>inv_inv</a>] using @<a>tendsto_inv_nhdsWithin_Iic</a> _ _ _ _ a\u207b\u00b9", [{"full_name": "inv_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [811, 9], "def_end_pos": [811, 16]}, {"full_name": "tendsto_inv_nhdsWithin_Iic", "def_path": ".lake/packages/mathlib/Mathlib/Topology/Algebra/Group/Basic.lean", "def_pos": [591, 9], "def_end_pos": [591, 35]}]], "state_before": "G : Type w\nH : Type x\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : TopologicalGroup G\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nf : \u03b1 \u2192 G\ns : Set \u03b1\nx : \u03b1\ninst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : OrderedCommGroup H\ninst\u271d : ContinuousInv H\na : H\n\u22a2 Tendsto Inv.inv (\ud835\udcdd[\u2264] a\u207b\u00b9) (\ud835\udcdd[\u2265] a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean", "full_name": "InnerProductSpace.Core.inner_mul_inner_self_le", "start": [327, 1], "end": [333, 28], "traced_tactics": [{"tactic": "rcases eq_or_ne x 0 with (rfl | hx)", "annotated_tactic": ["rcases <a>eq_or_ne</a> x 0 with (rfl | hx)", [{"full_name": "eq_or_ne", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : IsROrC \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : Core \ud835\udd5c F\nx y : F\n\u22a2 \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eay, x\u27eb_\ud835\udd5c\u2016 \u2264 re \u27eax, x\u27eb_\ud835\udd5c * re \u27eay, y\u27eb_\ud835\udd5c", "state_after": "case inl\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : IsROrC \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : Core \ud835\udd5c F\ny : F\n\u22a2 \u2016\u27ea0, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eay, 0\u27eb_\ud835\udd5c\u2016 \u2264 re \u27ea0, 0\u27eb_\ud835\udd5c * re \u27eay, y\u27eb_\ud835\udd5c\n\ncase inr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : IsROrC \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : Core \ud835\udd5c F\nx y : F\nhx : x \u2260 0\n\u22a2 \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eay, x\u27eb_\ud835\udd5c\u2016 \u2264 re \u27eax, x\u27eb_\ud835\udd5c * re \u27eay, y\u27eb_\ud835\udd5c"}, {"tactic": "simpa only [inner_zero_left, map_zero, zero_mul, norm_zero] using le_rfl", "annotated_tactic": ["simpa only [<a>inner_zero_left</a>, <a>map_zero</a>, <a>zero_mul</a>, <a>norm_zero</a>] using <a>le_rfl</a>", [{"full_name": "InnerProductSpace.Core.inner_zero_left", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [244, 9], "def_end_pos": [244, 24]}, {"full_name": "map_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 3], "def_end_pos": [202, 14]}, {"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}, {"full_name": "norm_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [589, 30], "def_end_pos": [589, 39]}, {"full_name": "le_rfl", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}]], "state_before": "case inl\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : IsROrC \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : Core \ud835\udd5c F\ny : F\n\u22a2 \u2016\u27ea0, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eay, 0\u27eb_\ud835\udd5c\u2016 \u2264 re \u27ea0, 0\u27eb_\ud835\udd5c * re \u27eay, y\u27eb_\ud835\udd5c", "state_after": "no goals"}, {"tactic": "have hx' : 0 < normSqF x := inner_self_nonneg.lt_of_ne' (mt normSq_eq_zero.1 hx)", "annotated_tactic": ["have hx' : 0 < normSqF x := inner_self_nonneg.lt_of_ne' (<a>mt</a> <a>normSq_eq_zero</a>.1 hx)", [{"full_name": "mt", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [645, 9], "def_end_pos": [645, 11]}, {"full_name": "InnerProductSpace.Core.normSq_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [259, 9], "def_end_pos": [259, 23]}]], "state_before": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : IsROrC \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : Core \ud835\udd5c F\nx y : F\nhx : x \u2260 0\n\u22a2 \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eay, x\u27eb_\ud835\udd5c\u2016 \u2264 re \u27eax, x\u27eb_\ud835\udd5c * re \u27eay, y\u27eb_\ud835\udd5c", "state_after": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : IsROrC \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : Core \ud835\udd5c F\nx y : F\nhx : x \u2260 0\nhx' : 0 < normSq x\n\u22a2 \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eay, x\u27eb_\ud835\udd5c\u2016 \u2264 re \u27eax, x\u27eb_\ud835\udd5c * re \u27eay, y\u27eb_\ud835\udd5c"}, {"tactic": "rw [\u2190 sub_nonneg, \u2190 mul_nonneg_iff_right_nonneg_of_pos hx', \u2190 normSq, \u2190 normSq,\n  norm_inner_symm y, \u2190 sq, \u2190 cauchy_schwarz_aux]", "annotated_tactic": ["rw [\u2190 <a>sub_nonneg</a>, \u2190 <a>mul_nonneg_iff_right_nonneg_of_pos</a> hx', \u2190 <a>normSq</a>, \u2190 <a>normSq</a>,\n      <a>norm_inner_symm</a> y, \u2190 <a>sq</a>, \u2190 <a>cauchy_schwarz_aux</a>]", [{"full_name": "sub_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [720, 30], "def_end_pos": [720, 40]}, {"full_name": "mul_nonneg_iff_right_nonneg_of_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [989, 9], "def_end_pos": [989, 43]}, {"full_name": "InnerProductSpace.Core.normSq", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [197, 5], "def_end_pos": [197, 11]}, {"full_name": "InnerProductSpace.Core.normSq", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [197, 5], "def_end_pos": [197, 11]}, {"full_name": "InnerProductSpace.Core.norm_inner_symm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [274, 9], "def_end_pos": [274, 24]}, {"full_name": "sq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [91, 41], "def_end_pos": [91, 43]}, {"full_name": "InnerProductSpace.Core.cauchy_schwarz_aux", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 27]}]], "state_before": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : IsROrC \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : Core \ud835\udd5c F\nx y : F\nhx : x \u2260 0\nhx' : 0 < normSq x\n\u22a2 \u2016\u27eax, y\u27eb_\ud835\udd5c\u2016 * \u2016\u27eay, x\u27eb_\ud835\udd5c\u2016 \u2264 re \u27eax, x\u27eb_\ud835\udd5c * re \u27eay, y\u27eb_\ud835\udd5c", "state_after": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : IsROrC \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : Core \ud835\udd5c F\nx y : F\nhx : x \u2260 0\nhx' : 0 < normSq x\n\u22a2 0 \u2264 normSq (\u27eax, y\u27eb_\ud835\udd5c \u2022 x - \u27eax, x\u27eb_\ud835\udd5c \u2022 y)"}, {"tactic": "exact inner_self_nonneg", "annotated_tactic": ["exact <a>inner_self_nonneg</a>", [{"full_name": "InnerProductSpace.Core.inner_self_nonneg", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/InnerProductSpace/Basic.lean", "def_pos": [207, 9], "def_end_pos": [207, 26]}]], "state_before": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : IsROrC \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module \ud835\udd5c F\nc : Core \ud835\udd5c F\nx y : F\nhx : x \u2260 0\nhx' : 0 < normSq x\n\u22a2 0 \u2264 normSq (\u27eax, y\u27eb_\ud835\udd5c \u2022 x - \u27eax, x\u27eb_\ud835\udd5c \u2022 y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "full_name": "Submodule.mem_toAffineSubspace", "start": [516, 1], "end": [518, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Submonoid/MulOpposite.lean", "full_name": "Submonoid.unop_sInf", "start": [116, 1], "end": [117, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Lattice.lean", "full_name": "Set.biUnion_le_succ'", "start": [245, 1], "end": [246, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/GroupAction/Hom.lean", "full_name": "MulActionHom.ext", "start": [135, 1], "end": [136, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Algebra/Order/Compact.lean", "full_name": "cocompact_eq_atTop", "start": [257, 1], "end": [259, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "full_name": "Finset.eq_affineCombination_subset_iff_eq_affineCombination_subtype", "start": [616, 1], "end": [623, 73], "traced_tactics": [{"tactic": "simp_rw [affineCombination_apply, eq_vadd_iff_vsub_eq]", "annotated_tactic": ["simp_rw [<a>affineCombination_apply</a>, <a>eq_vadd_iff_vsub_eq</a>]", [{"full_name": "Finset.affineCombination_apply", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [392, 9], "def_end_pos": [392, 32]}, {"full_name": "eq_vadd_iff_vsub_eq", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/AddTorsor.lean", "def_pos": [178, 9], "def_end_pos": [178, 28]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\n\u03b9 : Type u_4\ns\u271d : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\np0 : P\ns : Set \u03b9\np : \u03b9 \u2192 P\n\u22a2 (\u2203 fs, \u2191fs \u2286 s \u2227 \u2203 w, \u2211 i in fs, w i = 1 \u2227 p0 = (affineCombination k fs p) w) \u2194\n    \u2203 fs w, \u2211 i in fs, w i = 1 \u2227 p0 = (affineCombination k fs fun i => p \u2191i) w", "state_after": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\n\u03b9 : Type u_4\ns\u271d : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\np0 : P\ns : Set \u03b9\np : \u03b9 \u2192 P\n\u22a2 (\u2203 fs,\n      \u2191fs \u2286 s \u2227\n        \u2203 w, \u2211 i in fs, w i = 1 \u2227 p0 -\u1d65 Classical.choice \u22ef = (weightedVSubOfPoint fs p (Classical.choice \u22ef)) w) \u2194\n    \u2203 fs w,\n      \u2211 i in fs, w i = 1 \u2227 p0 -\u1d65 Classical.choice \u22ef = (weightedVSubOfPoint fs (fun i => p \u2191i) (Classical.choice \u22ef)) w"}, {"tactic": "exact eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype", "annotated_tactic": ["exact <a>eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype</a>", [{"full_name": "Finset.eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "def_pos": [573, 9], "def_end_pos": [573, 73]}]], "state_before": "k : Type u_1\nV : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Ring k\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module k V\nS : AffineSpace V P\n\u03b9 : Type u_4\ns\u271d : Finset \u03b9\n\u03b9\u2082 : Type u_5\ns\u2082 : Finset \u03b9\u2082\np0 : P\ns : Set \u03b9\np : \u03b9 \u2192 P\n\u22a2 (\u2203 fs,\n      \u2191fs \u2286 s \u2227\n        \u2203 w, \u2211 i in fs, w i = 1 \u2227 p0 -\u1d65 Classical.choice \u22ef = (weightedVSubOfPoint fs p (Classical.choice \u22ef)) w) \u2194\n    \u2203 fs w,\n      \u2211 i in fs, w i = 1 \u2227 p0 -\u1d65 Classical.choice \u22ef = (weightedVSubOfPoint fs (fun i => p \u2191i) (Classical.choice \u22ef)) w", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/LocallyFinite/Basic.lean", "full_name": "Finset.Icc_ssubset_Icc_left", "start": [275, 1], "end": [278, 42], "traced_tactics": [{"tactic": "rw [\u2190 coe_ssubset, coe_Icc, coe_Icc]", "annotated_tactic": ["rw [\u2190 <a>coe_ssubset</a>, <a>coe_Icc</a>, <a>coe_Icc</a>]", [{"full_name": "Finset.coe_ssubset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [416, 9], "def_end_pos": [416, 20]}, {"full_name": "Finset.coe_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [347, 9], "def_end_pos": [347, 16]}, {"full_name": "Finset.coe_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [347, 9], "def_end_pos": [347, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nhI : a\u2082 \u2264 b\u2082\nha : a\u2082 < a\u2081\nhb : b\u2081 \u2264 b\u2082\n\u22a2 Icc a\u2081 b\u2081 \u2282 Icc a\u2082 b\u2082", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nhI : a\u2082 \u2264 b\u2082\nha : a\u2082 < a\u2081\nhb : b\u2081 \u2264 b\u2082\n\u22a2 Set.Icc a\u2081 b\u2081 \u2282 Set.Icc a\u2082 b\u2082"}, {"tactic": "exact Set.Icc_ssubset_Icc_left hI ha hb", "annotated_tactic": ["exact <a>Set.Icc_ssubset_Icc_left</a> hI ha hb", [{"full_name": "Set.Icc_ssubset_Icc_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [585, 9], "def_end_pos": [585, 29]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nhI : a\u2082 \u2264 b\u2082\nha : a\u2082 < a\u2081\nhb : b\u2081 \u2264 b\u2082\n\u22a2 Set.Icc a\u2081 b\u2081 \u2282 Set.Icc a\u2082 b\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "Units.inv_pos", "start": [1006, 1], "end": [1009, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Matrix/Transvection.lean", "full_name": "Matrix.TransvectionStruct.toMatrix_mk", "start": [172, 1], "end": [174, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.le_piecewise_of_le_of_le", "start": [2681, 1], "end": [2683, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Module/Defs.lean", "full_name": "lt_inv_smul_iff_of_pos", "start": [752, 1], "end": [753, 100], "traced_tactics": [{"tactic": "rw [\u2190 smul_lt_smul_iff_of_pos_left ha, smul_inv_smul\u2080 ha.ne']", "annotated_tactic": ["rw [\u2190 <a>smul_lt_smul_iff_of_pos_left</a> ha, <a>smul_inv_smul\u2080</a> ha.ne']", [{"full_name": "smul_lt_smul_iff_of_pos_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Module/Defs.lean", "def_pos": [285, 7], "def_end_pos": [285, 35]}, {"full_name": "smul_inv_smul\u2080", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [219, 9], "def_end_pos": [219, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na a\u2081 a\u2082 : \u03b1\nb b\u2081 b\u2082 : \u03b2\ninst\u271d\u2075 : GroupWithZero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Preorder \u03b2\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : PosSMulStrictMono \u03b1 \u03b2\ninst\u271d : PosSMulReflectLT \u03b1 \u03b2\nha : 0 < a\n\u22a2 b\u2081 < a\u207b\u00b9 \u2022 b\u2082 \u2194 a \u2022 b\u2081 < b\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.univ_pi_eq_empty_iff", "start": [764, 1], "end": [765, 59], "traced_tactics": [{"tactic": "simp [\u2190 not_nonempty_iff_eq_empty, univ_pi_nonempty_iff]", "annotated_tactic": ["simp [\u2190 <a>not_nonempty_iff_eq_empty</a>, <a>univ_pi_nonempty_iff</a>]", [{"full_name": "Set.not_nonempty_iff_eq_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [579, 9], "def_end_pos": [579, 34]}, {"full_name": "Set.univ_pi_nonempty_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [752, 9], "def_end_pos": [752, 29]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\n\u22a2 pi univ t = \u2205 \u2194 \u2203 i, t i = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Sum.lean", "full_name": "Finset.val_disjSum", "start": [35, 1], "end": [36, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Finset.map_cons", "start": [268, 1], "end": [270, 43], "traced_tactics": [{"tactic": "simpa using ha", "annotated_tactic": ["simpa using ha", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf\u271d : \u03b1 \u21aa \u03b2\ns\u271d : Finset \u03b1\nf : \u03b1 \u21aa \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\n\u22a2 f a \u2209 map f s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "isGreatest_union_iff", "start": [392, 1], "end": [395, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Int/Cast/Lemmas.lean", "full_name": "Int.coe_nat_succ_pos", "start": [44, 1], "end": [45, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/CompleteBooleanAlgebra.lean", "full_name": "PUnit.sSup_eq", "start": [617, 1], "end": [618, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Archimedean.lean", "full_name": "Real.sInf_le_sSup", "start": [295, 1], "end": [298, 35], "traced_tactics": [{"tactic": "rcases s.eq_empty_or_nonempty with (rfl | hne)", "annotated_tactic": ["rcases s.eq_empty_or_nonempty with (rfl | hne)", []], "state_before": "s : Set \u211d\nh\u2081 : BddBelow s\nh\u2082 : BddAbove s\n\u22a2 sInf s \u2264 sSup s", "state_after": "case inl\nh\u2081 : BddBelow \u2205\nh\u2082 : BddAbove \u2205\n\u22a2 sInf \u2205 \u2264 sSup \u2205\n\ncase inr\ns : Set \u211d\nh\u2081 : BddBelow s\nh\u2082 : BddAbove s\nhne : Set.Nonempty s\n\u22a2 sInf s \u2264 sSup s"}, {"tactic": "rw [sInf_empty, sSup_empty]", "annotated_tactic": ["rw [<a>sInf_empty</a>, <a>sSup_empty</a>]", [{"full_name": "Real.sInf_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Archimedean.lean", "def_pos": [208, 9], "def_end_pos": [208, 19]}, {"full_name": "Real.sSup_empty", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Archimedean.lean", "def_pos": [177, 9], "def_end_pos": [177, 19]}]], "state_before": "case inl\nh\u2081 : BddBelow \u2205\nh\u2082 : BddAbove \u2205\n\u22a2 sInf \u2205 \u2264 sSup \u2205", "state_after": "no goals"}, {"tactic": "exact csInf_le_csSup h\u2081 h\u2082 hne", "annotated_tactic": ["exact <a>csInf_le_csSup</a> h\u2081 h\u2082 hne", [{"full_name": "csInf_le_csSup", "def_path": ".lake/packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [689, 9], "def_end_pos": [689, 23]}]], "state_before": "case inr\ns : Set \u211d\nh\u2081 : BddBelow s\nh\u2082 : BddAbove s\nhne : Set.Nonempty s\n\u22a2 sInf s \u2264 sSup s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Function/Conjugate.lean", "full_name": "Function.Semiconj\u2082.comp", "start": [190, 1], "end": [191, 83], "traced_tactics": [{"tactic": "simp only [hf'.eq, hf.eq, comp_apply]", "annotated_tactic": ["simp only [hf'.eq, hf.eq, <a>comp_apply</a>]", [{"full_name": "Function.comp_apply", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [35, 17], "def_end_pos": [35, 36]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nga : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ngb : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nf' : \u03b2 \u2192 \u03b3\ngc : \u03b3 \u2192 \u03b3 \u2192 \u03b3\nhf' : Semiconj\u2082 f' gb gc\nhf : Semiconj\u2082 f ga gb\nx y : \u03b1\n\u22a2 (f' \u2218 f) (ga x y) = gc ((f' \u2218 f) x) ((f' \u2218 f) y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Digits.lean", "full_name": "Nat.ofDigits_one", "start": [287, 1], "end": [290, 39], "traced_tactics": [{"tactic": "induction' L with _ _ ih", "annotated_tactic": ["induction' L with _ _ ih", []], "state_before": "n : \u2115\nL : List \u2115\n\u22a2 ofDigits 1 L = List.sum L", "state_after": "case nil\nn : \u2115\n\u22a2 ofDigits 1 [] = List.sum []\n\ncase cons\nn head\u271d : \u2115\ntail\u271d : List \u2115\nih : ofDigits 1 tail\u271d = List.sum tail\u271d\n\u22a2 ofDigits 1 (head\u271d :: tail\u271d) = List.sum (head\u271d :: tail\u271d)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case nil\nn : \u2115\n\u22a2 ofDigits 1 [] = List.sum []", "state_after": "no goals"}, {"tactic": "simp [ofDigits, List.sum_cons, ih]", "annotated_tactic": ["simp [<a>ofDigits</a>, <a>List.sum_cons</a>, ih]", [{"full_name": "Nat.ofDigits", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [165, 5], "def_end_pos": [165, 13]}, {"full_name": "List.sum_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [42, 3], "def_end_pos": [42, 14]}]], "state_before": "case cons\nn head\u271d : \u2115\ntail\u271d : List \u2115\nih : ofDigits 1 tail\u271d = List.sum tail\u271d\n\u22a2 ofDigits 1 (head\u271d :: tail\u271d) = List.sum (head\u271d :: tail\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "full_name": "MeasurableSet.biUnion", "start": [131, 11], "end": [135, 48], "traced_tactics": [{"tactic": "rw [biUnion_eq_iUnion]", "annotated_tactic": ["rw [<a>biUnion_eq_iUnion</a>]", [{"full_name": "Set.biUnion_eq_iUnion", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [874, 9], "def_end_pos": [874, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\nf : \u03b2 \u2192 Set \u03b1\ns : Set \u03b2\nhs : Set.Countable s\nh : \u2200 b \u2208 s, MeasurableSet (f b)\n\u22a2 MeasurableSet (\u22c3 b \u2208 s, f b)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\nf : \u03b2 \u2192 Set \u03b1\ns : Set \u03b2\nhs : Set.Countable s\nh : \u2200 b \u2208 s, MeasurableSet (f b)\n\u22a2 MeasurableSet (\u22c3 x, f \u2191x)"}, {"tactic": "have := hs.to_subtype", "annotated_tactic": ["have := hs.to_subtype", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\nf : \u03b2 \u2192 Set \u03b1\ns : Set \u03b2\nhs : Set.Countable s\nh : \u2200 b \u2208 s, MeasurableSet (f b)\n\u22a2 MeasurableSet (\u22c3 x, f \u2191x)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\nf : \u03b2 \u2192 Set \u03b1\ns : Set \u03b2\nhs : Set.Countable s\nh : \u2200 b \u2208 s, MeasurableSet (f b)\nthis : Countable \u2191s\n\u22a2 MeasurableSet (\u22c3 x, f \u2191x)"}, {"tactic": "exact MeasurableSet.iUnion (by simpa using h)", "annotated_tactic": ["exact <a>MeasurableSet.iUnion</a> (by simpa using h)", [{"full_name": "MeasurableSet.iUnion", "def_path": ".lake/packages/mathlib/Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "def_pos": [116, 19], "def_end_pos": [116, 39]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\nf : \u03b2 \u2192 Set \u03b1\ns : Set \u03b2\nhs : Set.Countable s\nh : \u2200 b \u2208 s, MeasurableSet (f b)\nthis : Countable \u2191s\n\u22a2 MeasurableSet (\u22c3 x, f \u2191x)", "state_after": "no goals"}, {"tactic": "simpa using h", "annotated_tactic": ["simpa using h", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b4' : Type u_5\n\u03b9 : Sort u_6\ns\u271d t u : Set \u03b1\nm : MeasurableSpace \u03b1\nf : \u03b2 \u2192 Set \u03b1\ns : Set \u03b2\nhs : Set.Countable s\nh : \u2200 b \u2208 s, MeasurableSet (f b)\nthis : Countable \u2191s\n\u22a2 \u2200 (b : \u2191s), MeasurableSet (f \u2191b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.two_lt_card", "start": [682, 1], "end": [683, 45], "traced_tactics": [{"tactic": "simp_rw [two_lt_card_iff, exists_and_left]", "annotated_tactic": ["simp_rw [<a>two_lt_card_iff</a>, <a>exists_and_left</a>]", [{"full_name": "Finset.two_lt_card_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [667, 9], "def_end_pos": [667, 24]}, {"full_name": "exists_and_left", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [221, 17], "def_end_pos": [221, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 2 < s.card \u2194 \u2203 a \u2208 s, \u2203 b \u2208 s, \u2203 c \u2208 s, a \u2260 b \u2227 a \u2260 c \u2227 b \u2260 c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Compactness/Compact.lean", "full_name": "Finset.isCompact_biUnion", "start": [461, 1], "end": [463, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "bit1_pos", "start": [315, 1], "end": [316, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/Interval.lean", "full_name": "Set.preimage_mul_const_Ioi_of_neg", "start": [645, 1], "end": [647, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.filter_singleton", "start": [3468, 1], "end": [3469, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Powerset.lean", "full_name": "Finset.card_powerset", "start": [89, 1], "end": [90, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Data/Int/Basic.lean", "full_name": "Int.neg_eq_neg", "start": [76, 11], "end": [76, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/NNReal.lean", "full_name": "NNReal.lt_div_iff'", "start": [950, 1], "end": [951, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Intervals/Instances.lean", "full_name": "Set.Icc.coe_eq_zero", "start": [79, 1], "end": [81, 24], "traced_tactics": [{"tactic": "symm", "annotated_tactic": ["symm", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\nx : \u2191(Icc 0 1)\n\u22a2 \u2191x = 0 \u2194 x = 0", "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\nx : \u2191(Icc 0 1)\n\u22a2 x = 0 \u2194 \u2191x = 0"}, {"tactic": "exact Subtype.ext_iff", "annotated_tactic": ["exact <a>Subtype.ext_iff</a>", [{"full_name": "Subtype.ext_iff", "def_path": ".lake/packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [69, 9], "def_end_pos": [69, 16]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\nx : \u2191(Icc 0 1)\n\u22a2 x = 0 \u2194 \u2191x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "full_name": "CategoryTheory.Limits.WidePullback.hom_ext", "start": [391, 1], "end": [397, 13], "traced_tactics": [{"tactic": "intro h1 h2", "annotated_tactic": ["intro h1 h2", []], "state_before": "J : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nX : D\nf : X \u27f6 B\nfs : (j : J) \u2192 X \u27f6 objs j\nw : \u2200 (j : J), fs j \u226b arrows j = f\ng1 g2 : X \u27f6 widePullback B (fun j => objs j) arrows\n\u22a2 (\u2200 (j : J), g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j) \u2192 g1 \u226b base arrows = g2 \u226b base arrows \u2192 g1 = g2", "state_after": "J : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nX : D\nf : X \u27f6 B\nfs : (j : J) \u2192 X \u27f6 objs j\nw : \u2200 (j : J), fs j \u226b arrows j = f\ng1 g2 : X \u27f6 widePullback B (fun j => objs j) arrows\nh1 : \u2200 (j : J), g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j\nh2 : g1 \u226b base arrows = g2 \u226b base arrows\n\u22a2 g1 = g2"}, {"tactic": "apply limit.hom_ext", "annotated_tactic": ["apply <a>limit.hom_ext</a>", [{"full_name": "CategoryTheory.Limits.limit.hom_ext", "def_path": ".lake/packages/mathlib/Mathlib/CategoryTheory/Limits/HasLimits.lean", "def_pos": [266, 9], "def_end_pos": [266, 22]}]], "state_before": "J : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nX : D\nf : X \u27f6 B\nfs : (j : J) \u2192 X \u27f6 objs j\nw : \u2200 (j : J), fs j \u226b arrows j = f\ng1 g2 : X \u27f6 widePullback B (fun j => objs j) arrows\nh1 : \u2200 (j : J), g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j\nh2 : g1 \u226b base arrows = g2 \u226b base arrows\n\u22a2 g1 = g2", "state_after": "case w\nJ : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nX : D\nf : X \u27f6 B\nfs : (j : J) \u2192 X \u27f6 objs j\nw : \u2200 (j : J), fs j \u226b arrows j = f\ng1 g2 : X \u27f6 widePullback B (fun j => objs j) arrows\nh1 : \u2200 (j : J), g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j\nh2 : g1 \u226b base arrows = g2 \u226b base arrows\n\u22a2 \u2200 (j : WidePullbackShape J),\n    g1 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) j =\n      g2 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) j"}, {"tactic": "rintro (_ | _)", "annotated_tactic": ["rintro (_ | _)", []], "state_before": "case w\nJ : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nX : D\nf : X \u27f6 B\nfs : (j : J) \u2192 X \u27f6 objs j\nw : \u2200 (j : J), fs j \u226b arrows j = f\ng1 g2 : X \u27f6 widePullback B (fun j => objs j) arrows\nh1 : \u2200 (j : J), g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j\nh2 : g1 \u226b base arrows = g2 \u226b base arrows\n\u22a2 \u2200 (j : WidePullbackShape J),\n    g1 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) j =\n      g2 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) j", "state_after": "case w.none\nJ : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nX : D\nf : X \u27f6 B\nfs : (j : J) \u2192 X \u27f6 objs j\nw : \u2200 (j : J), fs j \u226b arrows j = f\ng1 g2 : X \u27f6 widePullback B (fun j => objs j) arrows\nh1 : \u2200 (j : J), g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j\nh2 : g1 \u226b base arrows = g2 \u226b base arrows\n\u22a2 g1 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) none =\n    g2 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) none\n\ncase w.some\nJ : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nX : D\nf : X \u27f6 B\nfs : (j : J) \u2192 X \u27f6 objs j\nw : \u2200 (j : J), fs j \u226b arrows j = f\ng1 g2 : X \u27f6 widePullback B (fun j => objs j) arrows\nh1 : \u2200 (j : J), g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j\nh2 : g1 \u226b base arrows = g2 \u226b base arrows\nval\u271d : J\n\u22a2 g1 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) (some val\u271d) =\n    g2 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) (some val\u271d)"}, {"tactic": "apply h2", "annotated_tactic": ["apply h2", []], "state_before": "case w.none\nJ : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nX : D\nf : X \u27f6 B\nfs : (j : J) \u2192 X \u27f6 objs j\nw : \u2200 (j : J), fs j \u226b arrows j = f\ng1 g2 : X \u27f6 widePullback B (fun j => objs j) arrows\nh1 : \u2200 (j : J), g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j\nh2 : g1 \u226b base arrows = g2 \u226b base arrows\n\u22a2 g1 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) none =\n    g2 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) none", "state_after": "no goals"}, {"tactic": "apply h1", "annotated_tactic": ["apply h1", []], "state_before": "case w.some\nJ : Type w\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\nD : Type u_1\ninst\u271d\u00b9 : Category.{v\u2082, u_1} D\nB : D\nobjs : J \u2192 D\narrows : (j : J) \u2192 objs j \u27f6 B\ninst\u271d : HasWidePullback B objs arrows\nX : D\nf : X \u27f6 B\nfs : (j : J) \u2192 X \u27f6 objs j\nw : \u2200 (j : J), fs j \u226b arrows j = f\ng1 g2 : X \u27f6 widePullback B (fun j => objs j) arrows\nh1 : \u2200 (j : J), g1 \u226b \u03c0 arrows j = g2 \u226b \u03c0 arrows j\nh2 : g1 \u226b base arrows = g2 \u226b base arrows\nval\u271d : J\n\u22a2 g1 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) (some val\u271d) =\n    g2 \u226b limit.\u03c0 (WidePullbackShape.wideCospan B (fun j => objs j) arrows) (some val\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/MonoidAlgebra/Support.lean", "full_name": "MonoidAlgebra.support_single_mul_subset", "start": [32, 1], "end": [35, 38], "traced_tactics": [{"tactic": "rw [Finset.image\u2082_singleton_left]", "annotated_tactic": ["rw [<a>Finset.image\u2082_singleton_left</a>]", [{"full_name": "Finset.image\u2082_singleton_left", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [151, 9], "def_end_pos": [151, 30]}]], "state_before": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u00b2 : Semiring k\ninst\u271d\u00b9 : DecidableEq G\ninst\u271d : Mul G\nf : MonoidAlgebra k G\nr : k\na : G\n\u22a2 image\u2082 (fun x x_1 => x * x_1) {a} f.support \u2286 image (fun x => a * x) f.support", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subsemigroup/Membership.lean", "full_name": "Subsemigroup.iSup_induction", "start": [121, 1], "end": [126, 18], "traced_tactics": [{"tactic": "rw [iSup_eq_closure] at hx\u2081", "annotated_tactic": ["rw [<a>iSup_eq_closure</a>] at hx\u2081", [{"full_name": "Subsemigroup.iSup_eq_closure", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Basic.lean", "def_pos": [458, 9], "def_end_pos": [458, 24]}]], "state_before": "\u03b9 : Sort u_1\nM : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d : Mul M\nS : \u03b9 \u2192 Subsemigroup M\nC : M \u2192 Prop\nx\u2081 : M\nhx\u2081 : x\u2081 \u2208 \u2a06 i, S i\nhp : \u2200 (i : \u03b9), \u2200 x\u2082 \u2208 S i, C x\u2082\nhmul : \u2200 (x y : M), C x \u2192 C y \u2192 C (x * y)\n\u22a2 C x\u2081", "state_after": "\u03b9 : Sort u_1\nM : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d : Mul M\nS : \u03b9 \u2192 Subsemigroup M\nC : M \u2192 Prop\nx\u2081 : M\nhx\u2081 : x\u2081 \u2208 closure (\u22c3 i, \u2191(S i))\nhp : \u2200 (i : \u03b9), \u2200 x\u2082 \u2208 S i, C x\u2082\nhmul : \u2200 (x y : M), C x \u2192 C y \u2192 C (x * y)\n\u22a2 C x\u2081"}, {"tactic": "refine' closure_induction hx\u2081 (fun x\u2082 hx\u2082 => _) hmul", "annotated_tactic": ["refine' <a>closure_induction</a> hx\u2081 (fun x\u2082 hx\u2082 => _) hmul", [{"full_name": "Subsemigroup.closure_induction", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Basic.lean", "def_pos": [356, 9], "def_end_pos": [356, 26]}]], "state_before": "\u03b9 : Sort u_1\nM : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d : Mul M\nS : \u03b9 \u2192 Subsemigroup M\nC : M \u2192 Prop\nx\u2081 : M\nhx\u2081 : x\u2081 \u2208 closure (\u22c3 i, \u2191(S i))\nhp : \u2200 (i : \u03b9), \u2200 x\u2082 \u2208 S i, C x\u2082\nhmul : \u2200 (x y : M), C x \u2192 C y \u2192 C (x * y)\n\u22a2 C x\u2081", "state_after": "\u03b9 : Sort u_1\nM : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d : Mul M\nS : \u03b9 \u2192 Subsemigroup M\nC : M \u2192 Prop\nx\u2081 : M\nhx\u2081 : x\u2081 \u2208 closure (\u22c3 i, \u2191(S i))\nhp : \u2200 (i : \u03b9), \u2200 x\u2082 \u2208 S i, C x\u2082\nhmul : \u2200 (x y : M), C x \u2192 C y \u2192 C (x * y)\nx\u2082 : M\nhx\u2082 : x\u2082 \u2208 \u22c3 i, \u2191(S i)\n\u22a2 C x\u2082"}, {"tactic": "obtain \u27e8i, hi\u27e9 := Set.mem_iUnion.mp hx\u2082", "annotated_tactic": ["obtain \u27e8i, hi\u27e9 := Set.mem_iUnion.mp hx\u2082", []], "state_before": "\u03b9 : Sort u_1\nM : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d : Mul M\nS : \u03b9 \u2192 Subsemigroup M\nC : M \u2192 Prop\nx\u2081 : M\nhx\u2081 : x\u2081 \u2208 closure (\u22c3 i, \u2191(S i))\nhp : \u2200 (i : \u03b9), \u2200 x\u2082 \u2208 S i, C x\u2082\nhmul : \u2200 (x y : M), C x \u2192 C y \u2192 C (x * y)\nx\u2082 : M\nhx\u2082 : x\u2082 \u2208 \u22c3 i, \u2191(S i)\n\u22a2 C x\u2082", "state_after": "case intro\n\u03b9 : Sort u_1\nM : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d : Mul M\nS : \u03b9 \u2192 Subsemigroup M\nC : M \u2192 Prop\nx\u2081 : M\nhx\u2081 : x\u2081 \u2208 closure (\u22c3 i, \u2191(S i))\nhp : \u2200 (i : \u03b9), \u2200 x\u2082 \u2208 S i, C x\u2082\nhmul : \u2200 (x y : M), C x \u2192 C y \u2192 C (x * y)\nx\u2082 : M\nhx\u2082 : x\u2082 \u2208 \u22c3 i, \u2191(S i)\ni : \u03b9\nhi : x\u2082 \u2208 \u2191(S i)\n\u22a2 C x\u2082"}, {"tactic": "exact hp _ _ hi", "annotated_tactic": ["exact hp _ _ hi", []], "state_before": "case intro\n\u03b9 : Sort u_1\nM : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d : Mul M\nS : \u03b9 \u2192 Subsemigroup M\nC : M \u2192 Prop\nx\u2081 : M\nhx\u2081 : x\u2081 \u2208 closure (\u22c3 i, \u2191(S i))\nhp : \u2200 (i : \u03b9), \u2200 x\u2082 \u2208 S i, C x\u2082\nhmul : \u2200 (x y : M), C x \u2192 C y \u2192 C (x * y)\nx\u2082 : M\nhx\u2082 : x\u2082 \u2208 \u22c3 i, \u2191(S i)\ni : \u03b9\nhi : x\u2082 \u2208 \u2191(S i)\n\u22a2 C x\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Sigma.lean", "full_name": "Set.fst_image_sigma", "start": [268, 1], "end": [271, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Divisibility/Basic.lean", "full_name": "dvd_add_right", "start": [122, 1], "end": [122, 96], "traced_tactics": [{"tactic": "rw [add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [328, 3], "def_end_pos": [328, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalRing \u03b1\na b c : \u03b1\nh : a \u2223 b\n\u22a2 a \u2223 b + c \u2194 a \u2223 c", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalRing \u03b1\na b c : \u03b1\nh : a \u2223 b\n\u22a2 a \u2223 c + b \u2194 a \u2223 c"}, {"tactic": "exact dvd_add_left h", "annotated_tactic": ["exact <a>dvd_add_left</a> h", [{"full_name": "dvd_add_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Divisibility/Basic.lean", "def_pos": [116, 9], "def_end_pos": [116, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalRing \u03b1\na b c : \u03b1\nh : a \u2223 b\n\u22a2 a \u2223 c + b \u2194 a \u2223 c", "state_after": "no goals"}]}, {"url": "https://github.com/yangky11/miniF2F-lean4", "commit": "9e445f5435407f014b88b44a98436d50dd7abd00", "file_path": "MiniF2F/Valid.lean", "full_name": "mathd_numbertheory_35", "start": [338, 1], "end": [340, 8], "traced_tactics": [{"tactic": "sorry", "annotated_tactic": ["sorry", []], "state_before": "S : Finset \u2115\nh\u2080 : \u2200 (n : \u2115), n \u2223 Nat.sqrt 196\n\u22a2 \u2211 k in S, k = 24", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "full_name": "MeasureTheory.MeasurePreserving.comp_left_iff", "start": [116, 11], "end": [120, 42], "traced_tactics": [{"tactic": "refine' \u27e8fun hg => _, fun hg => h.comp hg\u27e9", "annotated_tactic": ["refine' \u27e8fun hg => _, fun hg => h.comp hg\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\n\u03bca : Measure \u03b1\n\u03bcb : Measure \u03b2\n\u03bcc : Measure \u03b3\n\u03bcd : Measure \u03b4\ng : \u03b1 \u2192 \u03b2\ne : \u03b2 \u2243\u1d50 \u03b3\nh : MeasurePreserving (\u21d1e) \u03bcb \u03bcc\n\u22a2 MeasurePreserving (\u21d1e \u2218 g) \u03bca \u03bcc \u2194 MeasurePreserving g \u03bca \u03bcb", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\n\u03bca : Measure \u03b1\n\u03bcb : Measure \u03b2\n\u03bcc : Measure \u03b3\n\u03bcd : Measure \u03b4\ng : \u03b1 \u2192 \u03b2\ne : \u03b2 \u2243\u1d50 \u03b3\nh : MeasurePreserving (\u21d1e) \u03bcb \u03bcc\nhg : MeasurePreserving (\u21d1e \u2218 g) \u03bca \u03bcc\n\u22a2 MeasurePreserving g \u03bca \u03bcb"}, {"tactic": "convert (MeasurePreserving.symm e h).comp hg", "annotated_tactic": ["convert (<a>MeasurePreserving.symm</a> e h).<a>comp</a> hg", [{"full_name": "MeasureTheory.MeasurePreserving.symm", "def_path": ".lake/packages/mathlib/Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "def_pos": [71, 9], "def_end_pos": [71, 13]}, {"full_name": "MeasureTheory.MeasurePreserving.comp", "def_path": ".lake/packages/mathlib/Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "def_pos": [103, 19], "def_end_pos": [103, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\n\u03bca : Measure \u03b1\n\u03bcb : Measure \u03b2\n\u03bcc : Measure \u03b3\n\u03bcd : Measure \u03b4\ng : \u03b1 \u2192 \u03b2\ne : \u03b2 \u2243\u1d50 \u03b3\nh : MeasurePreserving (\u21d1e) \u03bcb \u03bcc\nhg : MeasurePreserving (\u21d1e \u2218 g) \u03bca \u03bcc\n\u22a2 MeasurePreserving g \u03bca \u03bcb", "state_after": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\n\u03bca : Measure \u03b1\n\u03bcb : Measure \u03b2\n\u03bcc : Measure \u03b3\n\u03bcd : Measure \u03b4\ng : \u03b1 \u2192 \u03b2\ne : \u03b2 \u2243\u1d50 \u03b3\nh : MeasurePreserving (\u21d1e) \u03bcb \u03bcc\nhg : MeasurePreserving (\u21d1e \u2218 g) \u03bca \u03bcc\n\u22a2 g = \u21d1e.symm \u2218 \u21d1e \u2218 g"}, {"tactic": "simp [\u2190 Function.comp.assoc e.symm e g]", "annotated_tactic": ["simp [\u2190 <a>Function.comp.assoc</a> e.symm e g]", [{"full_name": "Function.comp.assoc", "def_path": ".lake/packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [103, 9], "def_end_pos": [103, 19]}]], "state_before": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : MeasurableSpace \u03b4\n\u03bca : Measure \u03b1\n\u03bcb : Measure \u03b2\n\u03bcc : Measure \u03b3\n\u03bcd : Measure \u03b4\ng : \u03b1 \u2192 \u03b2\ne : \u03b2 \u2243\u1d50 \u03b3\nh : MeasurePreserving (\u21d1e) \u03bcb \u03bcc\nhg : MeasurePreserving (\u21d1e \u2218 g) \u03bca \u03bcc\n\u22a2 g = \u21d1e.symm \u2218 \u21d1e \u2218 g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/FieldTheory/Finite/Basic.lean", "full_name": "FiniteField.odd_card_of_char_ne_two", "start": [606, 1], "end": [607, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/MeasureTheory/Measure/NullMeasurable.lean", "full_name": "MeasureTheory.nullMeasurableSet_univ", "start": [113, 1], "end": [114, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.inv_smul_set_distrib", "start": [1025, 1], "end": [1027, 44], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t A B : Set \u03b2\na\u271d : \u03b1\nx : \u03b2\na : \u03b1\ns : Set \u03b1\n\u22a2 (a \u2022 s)\u207b\u00b9 = op a\u207b\u00b9 \u2022 s\u207b\u00b9", "state_after": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t A B : Set \u03b2\na\u271d : \u03b1\nx : \u03b2\na : \u03b1\ns : Set \u03b1\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 (a \u2022 s)\u207b\u00b9 \u2194 x\u271d \u2208 op a\u207b\u00b9 \u2022 s\u207b\u00b9"}, {"tactic": "simp [mem_smul_set_iff_inv_smul_mem]", "annotated_tactic": ["simp [<a>mem_smul_set_iff_inv_smul_mem</a>]", [{"full_name": "Set.mem_smul_set_iff_inv_smul_mem", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [899, 9], "def_end_pos": [899, 38]}]], "state_before": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns\u271d t A B : Set \u03b2\na\u271d : \u03b1\nx : \u03b2\na : \u03b1\ns : Set \u03b1\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 (a \u2022 s)\u207b\u00b9 \u2194 x\u271d \u2208 op a\u207b\u00b9 \u2022 s\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.filter_union", "start": [2108, 1], "end": [2109, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/DirectSum/Module.lean", "full_name": "DirectSum.of_smul", "start": [85, 1], "end": [86, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/IsROrC/Basic.lean", "full_name": "IsROrC.bit0_im", "start": [196, 1], "end": [197, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "full_name": "LinearIsometryEquiv.trans_apply", "start": [815, 1], "end": [817, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/List/NodupEquivFin.lean", "full_name": "List.Sorted.get_strictMono", "start": [85, 1], "end": [85, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/OperatorNorm/Basic.lean", "full_name": "ContinuousLinearMap.le_opNorm", "start": [236, 1], "end": [236, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "full_name": "Real.rpow_left_inj", "start": [756, 1], "end": [757, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Init/Control/Lawful.lean", "full_name": "OptionT.run_map", "start": [213, 1], "end": [219, 54], "traced_tactics": [{"tactic": "rw [\u2190 bind_pure_comp _ x.run]", "annotated_tactic": ["rw [\u2190 <a>bind_pure_comp</a> _ x.run]", [{"full_name": "LawfulMonad.bind_pure_comp", "def_path": ".lake/packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [47, 3], "def_end_pos": [47, 17]}]], "state_before": "\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type v\nx : OptionT m \u03b1\ninst\u271d\u00b9 : Monad m\nf : \u03b1 \u2192 \u03b2\ninst\u271d : LawfulMonad m\n\u22a2 run (f <$> x) = Option.map f <$> run x", "state_after": "\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type v\nx : OptionT m \u03b1\ninst\u271d\u00b9 : Monad m\nf : \u03b1 \u2192 \u03b2\ninst\u271d : LawfulMonad m\n\u22a2 run (f <$> x) = do\n    let a \u2190 run x\n    pure (Option.map f a)"}, {"tactic": "change x.run >>= (fun\n                   | some a => OptionT.run (pure (f a))\n                   | none   => pure none) = _", "annotated_tactic": ["change x.run >>= (fun\n                     | <a>some</a> a => <a>OptionT.run</a> (<a>pure</a> (f a))\n                     | <a>none</a>   => <a>pure</a> <a>none</a>) = _", [{"full_name": "Option.some", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2226, 5], "def_end_pos": [2226, 9]}, {"full_name": "OptionT.run", "def_path": ".lake/packages/lean4/src/lean/Init/Control/Option.lean", "def_pos": [19, 5], "def_end_pos": [19, 16]}, {"full_name": "Pure.pure", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2763, 3], "def_end_pos": [2763, 7]}, {"full_name": "Option.none", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2224, 5], "def_end_pos": [2224, 9]}, {"full_name": "Pure.pure", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2763, 3], "def_end_pos": [2763, 7]}, {"full_name": "Option.none", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2224, 5], "def_end_pos": [2224, 9]}]], "state_before": "\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type v\nx : OptionT m \u03b1\ninst\u271d\u00b9 : Monad m\nf : \u03b1 \u2192 \u03b2\ninst\u271d : LawfulMonad m\n\u22a2 run (f <$> x) = do\n    let a \u2190 run x\n    pure (Option.map f a)", "state_after": "\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type v\nx : OptionT m \u03b1\ninst\u271d\u00b9 : Monad m\nf : \u03b1 \u2192 \u03b2\ninst\u271d : LawfulMonad m\n\u22a2 (do\n      let x \u2190 run x\n      match x with\n        | some a => run (pure (f a))\n        | none => pure none) =\n    do\n    let a \u2190 run x\n    pure (Option.map f a)"}, {"tactic": "apply bind_congr", "annotated_tactic": ["apply <a>bind_congr</a>", [{"full_name": "bind_congr", "def_path": ".lake/packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [68, 9], "def_end_pos": [68, 19]}]], "state_before": "\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type v\nx : OptionT m \u03b1\ninst\u271d\u00b9 : Monad m\nf : \u03b1 \u2192 \u03b2\ninst\u271d : LawfulMonad m\n\u22a2 (do\n      let x \u2190 run x\n      match x with\n        | some a => run (pure (f a))\n        | none => pure none) =\n    do\n    let a \u2190 run x\n    pure (Option.map f a)", "state_after": "case h\n\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type v\nx : OptionT m \u03b1\ninst\u271d\u00b9 : Monad m\nf : \u03b1 \u2192 \u03b2\ninst\u271d : LawfulMonad m\n\u22a2 \u2200 (a : Option \u03b1),\n    (match a with\n      | some a => run (pure (f a))\n      | none => pure none) =\n      pure (Option.map f a)"}, {"tactic": "intro a", "annotated_tactic": ["intro a", []], "state_before": "case h\n\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type v\nx : OptionT m \u03b1\ninst\u271d\u00b9 : Monad m\nf : \u03b1 \u2192 \u03b2\ninst\u271d : LawfulMonad m\n\u22a2 \u2200 (a : Option \u03b1),\n    (match a with\n      | some a => run (pure (f a))\n      | none => pure none) =\n      pure (Option.map f a)", "state_after": "case h\n\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type v\nx : OptionT m \u03b1\ninst\u271d\u00b9 : Monad m\nf : \u03b1 \u2192 \u03b2\ninst\u271d : LawfulMonad m\na : Option \u03b1\n\u22a2 (match a with\n    | some a => run (pure (f a))\n    | none => pure none) =\n    pure (Option.map f a)"}, {"tactic": "cases a <;> simp [Option.map, Option.bind]", "annotated_tactic": ["cases a <;> simp [<a>Option.map</a>, <a>Option.bind</a>]", [{"full_name": "Option.map", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2251, 25], "def_end_pos": [2251, 35]}, {"full_name": "Option.bind", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Basic.lean", "def_pos": [36, 25], "def_end_pos": [36, 29]}]], "state_before": "case h\n\u03b1 \u03b2 : Type u\nm : Type u \u2192 Type v\nx : OptionT m \u03b1\ninst\u271d\u00b9 : Monad m\nf : \u03b1 \u2192 \u03b2\ninst\u271d : LawfulMonad m\na : Option \u03b1\n\u22a2 (match a with\n    | some a => run (pure (f a))\n    | none => pure none) =\n    pure (Option.map f a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "full_name": "NonUnitalSubring.comap_equiv_eq_map_symm", "start": [901, 1], "end": [903, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.toSubMulAction_one", "start": [105, 1], "end": [106, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "div_lt_one_of_neg", "start": [891, 1], "end": [891, 100], "traced_tactics": [{"tactic": "rw [div_lt_iff_of_neg hb, one_mul]", "annotated_tactic": ["rw [<a>div_lt_iff_of_neg</a> hb, <a>one_mul</a>]", [{"full_name": "div_lt_iff_of_neg", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [764, 9], "def_end_pos": [764, 26]}, {"full_name": "one_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [474, 9], "def_end_pos": [474, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nhb : b < 0\n\u22a2 a / b < 1 \u2194 b < a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/NormedSpace/Real.lean", "full_name": "inv_norm_smul_mem_closed_unit_ball", "start": [40, 1], "end": [43, 21], "traced_tactics": [{"tactic": "simp only [mem_closedBall_zero_iff, norm_smul, norm_inv, norm_norm, \u2190 div_eq_inv_mul,\n  div_self_le_one]", "annotated_tactic": ["simp only [<a>mem_closedBall_zero_iff</a>, <a>norm_smul</a>, <a>norm_inv</a>, <a>norm_norm</a>, \u2190 <a>div_eq_inv_mul</a>,\n    <a>div_self_le_one</a>]", [{"full_name": "mem_closedBall_zero_iff", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Group/Basic.lean", "def_pos": [713, 3], "def_end_pos": [713, 14]}, {"full_name": "norm_smul", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/MulAction.lean", "def_pos": [90, 9], "def_end_pos": [90, 18]}, {"full_name": "norm_inv", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Field/Basic.lean", "def_pos": [740, 9], "def_end_pos": [740, 17]}, {"full_name": "norm_norm", "def_path": ".lake/packages/mathlib/Mathlib/Analysis/Normed/Field/Basic.lean", "def_pos": [1079, 9], "def_end_pos": [1079, 18]}, {"full_name": "div_eq_inv_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [567, 9], "def_end_pos": [567, 23]}, {"full_name": "div_self_le_one", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [191, 9], "def_end_pos": [191, 24]}]], "state_before": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\n\u22a2 \u2016x\u2016\u207b\u00b9 \u2022 x \u2208 closedBall 0 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Subsingleton.lean", "full_name": "Filter.subsingleton_bot", "start": [47, 1], "end": [48, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "f3447c3732c9d6e8df3bdad78e5ecf7e8b353bbc", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.headD_eq_head?", "start": [561, 9], "end": [561, 96], "traced_tactics": [{"tactic": "cases l <;> rfl", "annotated_tactic": ["cases l <;> rfl", []], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\na : \u03b1\n\u22a2 headD l a = Option.getD (head? l) a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/MetricSpace/Isometry.lean", "full_name": "IsometryEquiv.continuous", "start": [359, 11], "end": [360, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "toIocMod_le_toIcoMod_add", "start": [707, 1], "end": [710, 49], "traced_tactics": [{"tactic": "rw [toIcoMod, toIocMod, sub_add, sub_le_sub_iff_left, sub_le_iff_le_add, \u2190 add_one_zsmul,\n  (zsmul_strictMono_left hp).le_iff_le]", "annotated_tactic": ["rw [<a>toIcoMod</a>, <a>toIocMod</a>, <a>sub_add</a>, <a>sub_le_sub_iff_left</a>, <a>sub_le_iff_le_add</a>, \u2190 <a>add_one_zsmul</a>,\n    (<a>zsmul_strictMono_left</a> hp).<a>le_iff_le</a>]", [{"full_name": "toIcoMod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [74, 5], "def_end_pos": [74, 13]}, {"full_name": "toIocMod", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [79, 5], "def_end_pos": [79, 13]}, {"full_name": "sub_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [606, 3], "def_end_pos": [606, 14]}, {"full_name": "sub_le_sub_iff_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [775, 3], "def_end_pos": [775, 14]}, {"full_name": "sub_le_iff_le_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [750, 3], "def_end_pos": [750, 14]}, {"full_name": "add_one_zsmul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [426, 15], "def_end_pos": [426, 28]}, {"full_name": "zsmul_strictMono_left", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [34, 15], "def_end_pos": [34, 36]}, {"full_name": "StrictMono.le_iff_le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [841, 9], "def_end_pos": [841, 29]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b\u271d c : \u03b1\nn : \u2124\na b : \u03b1\n\u22a2 toIocMod hp a b \u2264 toIcoMod hp a b + p", "state_after": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b\u271d c : \u03b1\nn : \u2124\na b : \u03b1\n\u22a2 toIcoDiv hp a b \u2264 toIocDiv hp a b + 1"}, {"tactic": "apply (toIocDiv_wcovBy_toIcoDiv _ _ _).le_succ", "annotated_tactic": ["apply (<a>toIocDiv_wcovBy_toIcoDiv</a> _ _ _).<a>le_succ</a>", [{"full_name": "toIocDiv_wcovBy_toIcoDiv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [694, 9], "def_end_pos": [694, 33]}, {"full_name": "WCovBy.le_succ", "def_path": ".lake/packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [434, 9], "def_end_pos": [434, 30]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b\u271d c : \u03b1\nn : \u2124\na b : \u03b1\n\u22a2 toIcoDiv hp a b \u2264 toIocDiv hp a b + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.inv_nonempty_iff", "start": [257, 1], "end": [257, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/NumberTheory/ArithmeticFunction.lean", "full_name": "ArithmeticFunction.natCoe_mul", "start": [302, 1], "end": [305, 7], "traced_tactics": [{"tactic": "ext n", "annotated_tactic": ["ext n", []], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf g : ArithmeticFunction \u2115\n\u22a2 \u2191(f * g) = \u2191f * \u2191g", "state_after": "case h\nR : Type u_1\ninst\u271d : Semiring R\nf g : ArithmeticFunction \u2115\nn : \u2115\n\u22a2 \u2191(f * g) n = (\u2191f * \u2191g) n"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\nR : Type u_1\ninst\u271d : Semiring R\nf g : ArithmeticFunction \u2115\nn : \u2115\n\u22a2 \u2191(f * g) n = (\u2191f * \u2191g) n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "full_name": "NonUnitalSubalgebra.toSubmodule_inj", "start": [118, 1], "end": [119, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Analysis/Calculus/ContDiff/Basic.lean", "full_name": "contDiff_const_smul", "start": [1634, 1], "end": [1635, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/Cardinality.lean", "full_name": "Cardinal.mk_Ioi_real", "start": [224, 1], "end": [242, 39], "traced_tactics": [{"tactic": "refine' le_antisymm (mk_real \u25b8 mk_set_le _) _", "annotated_tactic": ["refine' <a>le_antisymm</a> (<a>mk_real</a> \u25b8 <a>mk_set_le</a> _) _", [{"full_name": "le_antisymm", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [182, 9], "def_end_pos": [182, 20]}, {"full_name": "Cardinal.mk_real", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Cardinality.lean", "def_pos": [200, 9], "def_end_pos": [200, 16]}, {"full_name": "Cardinal.mk_set_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [291, 9], "def_end_pos": [291, 18]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\n\u22a2 #\u2191(Ioi a) = \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioi a)"}, {"tactic": "rw [\u2190 not_lt]", "annotated_tactic": ["rw [\u2190 <a>not_lt</a>]", [{"full_name": "not_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [362, 9], "def_end_pos": [362, 15]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\n\u22a2 \ud835\udd20 \u2264 #\u2191(Ioi a)", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\n\u22a2 \u00ac#\u2191(Ioi a) < \ud835\udd20"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\n\u22a2 \u00ac#\u2191(Ioi a) < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\n\u22a2 False"}, {"tactic": "refine' _root_.ne_of_lt _ mk_univ_real", "annotated_tactic": ["refine' <a>_root_.ne_of_lt</a> _ <a>mk_univ_real</a>", [{"full_name": "ne_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [95, 9], "def_end_pos": [95, 17]}, {"full_name": "Cardinal.mk_univ_real", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/Cardinality.lean", "def_pos": [214, 9], "def_end_pos": [214, 21]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\n\u22a2 False", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\n\u22a2 #\u2191Set.univ < \ud835\udd20"}, {"tactic": "have hu : Iio a \u222a {a} \u222a Ioi a = Set.univ := by\n  convert @Iic_union_Ioi \u211d _ _\n  exact Iio_union_right", "annotated_tactic": ["have hu : <a>Iio</a> a \u222a {a} \u222a <a>Ioi</a> a = <a>Set.univ</a> := by\n    convert @<a>Iic_union_Ioi</a> \u211d _ _\n    exact <a>Iio_union_right</a>", [{"full_name": "Set.Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [54, 5], "def_end_pos": [54, 8]}, {"full_name": "Set.Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [79, 5], "def_end_pos": [79, 8]}, {"full_name": "Set.univ", "def_path": ".lake/packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [153, 5], "def_end_pos": [153, 9]}, {"full_name": "Set.Iic_union_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1254, 9], "def_end_pos": [1254, 22]}, {"full_name": "Set.Iio_union_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [865, 9], "def_end_pos": [865, 24]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\n\u22a2 #\u2191Set.univ < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 #\u2191Set.univ < \ud835\udd20"}, {"tactic": "rw [\u2190 hu]", "annotated_tactic": ["rw [\u2190 hu]", []], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 #\u2191Set.univ < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 #\u2191(Iio a \u222a {a} \u222a Ioi a) < \ud835\udd20"}, {"tactic": "refine' lt_of_le_of_lt (mk_union_le _ _) _", "annotated_tactic": ["refine' <a>lt_of_le_of_lt</a> (<a>mk_union_le</a> _ _) _", [{"full_name": "lt_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}, {"full_name": "Cardinal.mk_union_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2077, 9], "def_end_pos": [2077, 20]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 #\u2191(Iio a \u222a {a} \u222a Ioi a) < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 #\u2191(Iio a \u222a {a}) + #\u2191(Ioi a) < \ud835\udd20"}, {"tactic": "refine' lt_of_le_of_lt (add_le_add_right (mk_union_le _ _) _) _", "annotated_tactic": ["refine' <a>lt_of_le_of_lt</a> (<a>add_le_add_right</a> (<a>mk_union_le</a> _ _) _) _", [{"full_name": "lt_of_le_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [116, 9], "def_end_pos": [116, 23]}, {"full_name": "add_le_add_right", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [66, 32], "def_end_pos": [66, 48]}, {"full_name": "Cardinal.mk_union_le", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2077, 9], "def_end_pos": [2077, 20]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 #\u2191(Iio a \u222a {a}) + #\u2191(Ioi a) < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 #\u2191(Iio a) + #\u2191{a} + #\u2191(Ioi a) < \ud835\udd20"}, {"tactic": "have h2 : (fun x => a + a - x) '' Ioi a = Iio a := by\n  convert @image_const_sub_Ioi \u211d _ _ _\n  simp", "annotated_tactic": ["have h2 : (fun x => a + a - x) '' <a>Ioi</a> a = <a>Iio</a> a := by\n    convert @<a>image_const_sub_Ioi</a> \u211d _ _ _\n    simp", [{"full_name": "Set.Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [79, 5], "def_end_pos": [79, 8]}, {"full_name": "Set.Iio", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [54, 5], "def_end_pos": [54, 8]}, {"full_name": "Set.image_const_sub_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Interval.lean", "def_pos": [417, 9], "def_end_pos": [417, 28]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 #\u2191(Iio a) + #\u2191{a} + #\u2191(Ioi a) < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 #\u2191(Iio a) + #\u2191{a} + #\u2191(Ioi a) < \ud835\udd20"}, {"tactic": "rw [\u2190 h2]", "annotated_tactic": ["rw [\u2190 h2]", []], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 #\u2191(Iio a) + #\u2191{a} + #\u2191(Ioi a) < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 #\u2191((fun x => a + a - x) '' Ioi a) + #\u2191{a} + #\u2191(Ioi a) < \ud835\udd20"}, {"tactic": "refine' add_lt_of_lt (cantor _).le _ h", "annotated_tactic": ["refine' <a>add_lt_of_lt</a> (<a>cantor</a> _).<a>le</a> _ h", [{"full_name": "Cardinal.add_lt_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [760, 9], "def_end_pos": [760, 21]}, {"full_name": "Cardinal.cantor", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [736, 9], "def_end_pos": [736, 15]}, {"full_name": "LT.lt.le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [139, 7], "def_end_pos": [139, 15]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 #\u2191((fun x => a + a - x) '' Ioi a) + #\u2191{a} + #\u2191(Ioi a) < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 #\u2191((fun x => a + a - x) '' Ioi a) + #\u2191{a} < \ud835\udd20"}, {"tactic": "refine' add_lt_of_lt (cantor _).le (mk_image_le.trans_lt h) _", "annotated_tactic": ["refine' <a>add_lt_of_lt</a> (<a>cantor</a> _).<a>le</a> (mk_image_le.trans_lt h) _", [{"full_name": "Cardinal.add_lt_of_lt", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Ordinal.lean", "def_pos": [760, 9], "def_end_pos": [760, 21]}, {"full_name": "Cardinal.cantor", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [736, 9], "def_end_pos": [736, 15]}, {"full_name": "LT.lt.le", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [139, 7], "def_end_pos": [139, 15]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 #\u2191((fun x => a + a - x) '' Ioi a) + #\u2191{a} < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 #\u2191{a} < \ud835\udd20"}, {"tactic": "rw [mk_singleton]", "annotated_tactic": ["rw [<a>mk_singleton</a>]", [{"full_name": "Cardinal.mk_singleton", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1873, 9], "def_end_pos": [1873, 21]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 #\u2191{a} < \ud835\udd20", "state_after": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 1 < \ud835\udd20"}, {"tactic": "exact one_lt_aleph0.trans (cantor _)", "annotated_tactic": ["exact one_lt_aleph0.trans (<a>cantor</a> _)", [{"full_name": "Cardinal.cantor", "def_path": ".lake/packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [736, 9], "def_end_pos": [736, 15]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 1 < \ud835\udd20", "state_after": "no goals"}, {"tactic": "convert @Iic_union_Ioi \u211d _ _", "annotated_tactic": ["convert @<a>Iic_union_Ioi</a> \u211d _ _", [{"full_name": "Set.Iic_union_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1254, 9], "def_end_pos": [1254, 22]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\n\u22a2 Iio a \u222a {a} \u222a Ioi a = Set.univ", "state_after": "case h.e'_2.h.e'_3\nc : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\n\u22a2 Iio a \u222a {a} = Iic a"}, {"tactic": "exact Iio_union_right", "annotated_tactic": ["exact <a>Iio_union_right</a>", [{"full_name": "Set.Iio_union_right", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [865, 9], "def_end_pos": [865, 24]}]], "state_before": "case h.e'_2.h.e'_3\nc : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\n\u22a2 Iio a \u222a {a} = Iic a", "state_after": "no goals"}, {"tactic": "convert @image_const_sub_Ioi \u211d _ _ _", "annotated_tactic": ["convert @<a>image_const_sub_Ioi</a> \u211d _ _ _", [{"full_name": "Set.image_const_sub_Ioi", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Pointwise/Interval.lean", "def_pos": [417, 9], "def_end_pos": [417, 28]}]], "state_before": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 (fun x => a + a - x) '' Ioi a = Iio a", "state_after": "case h.e'_3.h.e'_3\nc : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 a = a + a - a"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.e'_3.h.e'_3\nc : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\na : \u211d\nh : #\u2191(Ioi a) < \ud835\udd20\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 a = a + a - a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean", "full_name": "Nat.descFactorial_eq_zero_iff_lt", "start": [390, 1], "end": [395, 23], "traced_tactics": [{"tactic": "simp only [descFactorial_zero, Nat.one_ne_zero, Nat.not_lt_zero]", "annotated_tactic": ["simp only [<a>descFactorial_zero</a>, <a>Nat.one_ne_zero</a>, <a>Nat.not_lt_zero</a>]", [{"full_name": "Nat.descFactorial_zero", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [353, 9], "def_end_pos": [353, 27]}, {"full_name": "Nat.one_ne_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [459, 19], "def_end_pos": [459, 30]}, {"full_name": "Nat.not_lt_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1641, 9], "def_end_pos": [1641, 24]}]], "state_before": "n : \u2115\n\u22a2 descFactorial n 0 = 0 \u2194 n < 0", "state_after": "no goals"}, {"tactic": "rw [descFactorial_succ, mul_eq_zero, descFactorial_eq_zero_iff_lt, Nat.lt_succ_iff,\n  tsub_eq_zero_iff_le, lt_iff_le_and_ne, or_iff_left_iff_imp, and_imp]", "annotated_tactic": ["rw [<a>descFactorial_succ</a>, <a>mul_eq_zero</a>, descFactorial_eq_zero_iff_lt, <a>Nat.lt_succ_iff</a>,\n      <a>tsub_eq_zero_iff_le</a>, <a>lt_iff_le_and_ne</a>, <a>or_iff_left_iff_imp</a>, <a>and_imp</a>]", [{"full_name": "Nat.descFactorial_succ", "def_path": ".lake/packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [358, 9], "def_end_pos": [358, 27]}, {"full_name": "Nat.mul_eq_zero", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [525, 9], "def_end_pos": [525, 20]}, {"full_name": "Nat.lt_succ_iff", "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean", "def_pos": [52, 19], "def_end_pos": [52, 30]}, {"full_name": "tsub_eq_zero_iff_le", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [332, 9], "def_end_pos": [332, 28]}, {"full_name": "lt_iff_le_and_ne", "def_path": ".lake/packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [368, 9], "def_end_pos": [368, 25]}, {"full_name": "or_iff_left_iff_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [173, 17], "def_end_pos": [173, 36]}, {"full_name": "and_imp", "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [108, 17], "def_end_pos": [108, 24]}]], "state_before": "n k : \u2115\n\u22a2 descFactorial n (succ k) = 0 \u2194 n < succ k", "state_after": "n k : \u2115\n\u22a2 n \u2264 k \u2192 n \u2260 k \u2192 n \u2264 k"}, {"tactic": "exact fun h _ => h", "annotated_tactic": ["exact fun h _ => h", []], "state_before": "n k : \u2115\n\u22a2 n \u2264 k \u2192 n \u2260 k \u2192 n \u2264 k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "full_name": "UniformCauchySeqOn.prod'", "start": [536, 1], "end": [540, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.mapDomain_mul", "start": [486, 1], "end": [497, 19], "traced_tactics": [{"tactic": "simp_rw [mul_def, mapDomain_sum, mapDomain_single, map_mul]", "annotated_tactic": ["simp_rw [<a>mul_def</a>, <a>mapDomain_sum</a>, <a>mapDomain_single</a>, <a>map_mul</a>]", [{"full_name": "MonoidAlgebra.mul_def", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [171, 9], "def_end_pos": [171, 16]}, {"full_name": "MonoidAlgebra.mapDomain_sum", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [137, 9], "def_end_pos": [137, 22]}, {"full_name": "Finsupp.mapDomain_single", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [488, 9], "def_end_pos": [488, 25]}, {"full_name": "map_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [308, 9], "def_end_pos": [308, 16]}]], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 mapDomain (\u21d1f) (x * y) = mapDomain (\u21d1f) x * mapDomain (\u21d1f) y", "state_after": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 (sum x fun a b => sum y fun a_1 b_1 => Finsupp.single (f a * f a_1) (b * b_1)) =\n    sum (mapDomain (\u21d1f) x) fun a\u2081 b\u2081 => sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (a\u2081 * a\u2082) (b\u2081 * b\u2082)"}, {"tactic": "rw [Finsupp.sum_mapDomain_index]", "annotated_tactic": ["rw [<a>Finsupp.sum_mapDomain_index</a>]", [{"full_name": "Finsupp.sum_mapDomain_index", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [584, 3], "def_end_pos": [584, 14]}]], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 (sum x fun a b => sum y fun a_1 b_1 => Finsupp.single (f a * f a_1) (b * b_1)) =\n    sum (mapDomain (\u21d1f) x) fun a\u2081 b\u2081 => sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (a\u2081 * a\u2082) (b\u2081 * b\u2082)", "state_after": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 (sum x fun a b => sum y fun a_1 b_1 => Finsupp.single (f a * f a_1) (b * b_1)) =\n    sum x fun a m => sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (f a * a\u2082) (m * b\u2082)\n\ncase h_zero\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 \u2200 (b : \u03b1\u2082), (sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (b * a\u2082) (0 * b\u2082)) = 0\n\ncase h_add\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 \u2200 (b : \u03b1\u2082) (m\u2081 m\u2082 : \u03b2),\n    (sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (b * a\u2082) ((m\u2081 + m\u2082) * b\u2082)) =\n      (sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (b * a\u2082) (m\u2081 * b\u2082)) +\n        sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (b * a\u2082) (m\u2082 * b\u2082)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 (sum x fun a b => sum y fun a_1 b_1 => Finsupp.single (f a * f a_1) (b * b_1)) =\n    sum x fun a m => sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (f a * a\u2082) (m * b\u2082)", "state_after": "case e_g\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 (fun a b => sum y fun a_1 b_1 => Finsupp.single (f a * f a_1) (b * b_1)) = fun a m =>\n    sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (f a * a\u2082) (m * b\u2082)"}, {"tactic": "ext a b", "annotated_tactic": ["ext a b", []], "state_before": "case e_g\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 (fun a b => sum y fun a_1 b_1 => Finsupp.single (f a * f a_1) (b * b_1)) = fun a m =>\n    sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (f a * a\u2082) (m * b\u2082)", "state_after": "case e_g.h.h\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\na : \u03b1\nb : \u03b2\n\u22a2 (sum y fun a_1 b_1 => Finsupp.single (f a * f a_1) (b * b_1)) =\n    sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (f a * a\u2082) (b * b\u2082)"}, {"tactic": "rw [Finsupp.sum_mapDomain_index]", "annotated_tactic": ["rw [<a>Finsupp.sum_mapDomain_index</a>]", [{"full_name": "Finsupp.sum_mapDomain_index", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [584, 3], "def_end_pos": [584, 14]}]], "state_before": "case e_g.h.h\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\na : \u03b1\nb : \u03b2\n\u22a2 (sum y fun a_1 b_1 => Finsupp.single (f a * f a_1) (b * b_1)) =\n    sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (f a * a\u2082) (b * b\u2082)", "state_after": "case e_g.h.h.h_zero\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\na : \u03b1\nb : \u03b2\n\u22a2 \u2200 (b_1 : \u03b1\u2082), single (f a * b_1) (b * 0) = 0\n\ncase e_g.h.h.h_add\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\na : \u03b1\nb : \u03b2\n\u22a2 \u2200 (b_1 : \u03b1\u2082) (m\u2081 m\u2082 : \u03b2),\n    single (f a * b_1) (b * (m\u2081 + m\u2082)) = single (f a * b_1) (b * m\u2081) + single (f a * b_1) (b * m\u2082)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case e_g.h.h.h_zero\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\na : \u03b1\nb : \u03b2\n\u22a2 \u2200 (b_1 : \u03b1\u2082), single (f a * b_1) (b * 0) = 0", "state_after": "no goals"}, {"tactic": "simp [mul_add]", "annotated_tactic": ["simp [<a>mul_add</a>]", [{"full_name": "mul_add", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}]], "state_before": "case e_g.h.h.h_add\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\na : \u03b1\nb : \u03b2\n\u22a2 \u2200 (b_1 : \u03b1\u2082) (m\u2081 m\u2082 : \u03b2),\n    single (f a * b_1) (b * (m\u2081 + m\u2082)) = single (f a * b_1) (b * m\u2081) + single (f a * b_1) (b * m\u2082)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h_zero\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 \u2200 (b : \u03b1\u2082), (sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (b * a\u2082) (0 * b\u2082)) = 0", "state_after": "no goals"}, {"tactic": "simp [add_mul]", "annotated_tactic": ["simp [<a>add_mul</a>]", [{"full_name": "add_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}]], "state_before": "case h_add\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2075 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Mul \u03b1\u2082\nF : Type u_6\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b1\u2082\ninst\u271d : MulHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : MonoidAlgebra \u03b2 \u03b1\n\u22a2 \u2200 (b : \u03b1\u2082) (m\u2081 m\u2082 : \u03b2),\n    (sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (b * a\u2082) ((m\u2081 + m\u2082) * b\u2082)) =\n      (sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (b * a\u2082) (m\u2081 * b\u2082)) +\n        sum (mapDomain (\u21d1f) y) fun a\u2082 b\u2082 => single (b * a\u2082) (m\u2082 * b\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Constructions.lean", "full_name": "embedding_inl", "start": [973, 1], "end": [974, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/Equiv/Fin.lean", "full_name": "finSuccEquiv_zero", "start": [196, 1], "end": [197, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "List.toFinset_cons", "start": [3451, 1], "end": [3452, 98], "traced_tactics": [{"tactic": "by_cases h : a \u2208 l <;> simp [Finset.insert_val', Multiset.dedup_cons, h]", "annotated_tactic": ["by_cases h : a \u2208 l <;> simp [<a>Finset.insert_val'</a>, <a>Multiset.dedup_cons</a>, h]", [{"full_name": "Finset.insert_val'", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1107, 9], "def_end_pos": [1107, 20]}, {"full_name": "Multiset.dedup_cons", "def_path": ".lake/packages/mathlib/Mathlib/Data/Multiset/FinsetOps.lean", "def_pos": [83, 9], "def_end_pos": [83, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\nl l' : List \u03b1\na : \u03b1\n\u22a2 (toFinset (a :: l)).val = (insert a (toFinset l)).val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "full_name": "iUnion_Ico_add_zsmul", "start": [1058, 1], "end": [1063, 48], "traced_tactics": [{"tactic": "refine' eq_univ_iff_forall.mpr fun b => mem_iUnion.mpr _", "annotated_tactic": ["refine' eq_univ_iff_forall.mpr fun b => mem_iUnion.mpr _", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na : \u03b1\n\u22a2 \u22c3 n, Ico (a + n \u2022 p) (a + (n + 1) \u2022 p) = univ", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\n\u22a2 \u2203 i, b \u2208 Ico (a + i \u2022 p) (a + (i + 1) \u2022 p)"}, {"tactic": "rcases sub_toIcoDiv_zsmul_mem_Ico hp a b with \u27e8hl, hr\u27e9", "annotated_tactic": ["rcases <a>sub_toIcoDiv_zsmul_mem_Ico</a> hp a b with \u27e8hl, hr\u27e9", [{"full_name": "sub_toIcoDiv_zsmul_mem_Ico", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [49, 9], "def_end_pos": [49, 35]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\n\u22a2 \u2203 i, b \u2208 Ico (a + i \u2022 p) (a + (i + 1) \u2022 p)", "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a \u2264 b - toIcoDiv hp a b \u2022 p\nhr : b - toIcoDiv hp a b \u2022 p < a + p\n\u22a2 \u2203 i, b \u2208 Ico (a + i \u2022 p) (a + (i + 1) \u2022 p)"}, {"tactic": "refine' \u27e8toIcoDiv hp a b, \u27e8le_sub_iff_add_le.mp hl, _\u27e9\u27e9", "annotated_tactic": ["refine' \u27e8<a>toIcoDiv</a> hp a b, \u27e8le_sub_iff_add_le.mp hl, _\u27e9\u27e9", [{"full_name": "toIcoDiv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/ToIntervalMod.lean", "def_pos": [45, 5], "def_end_pos": [45, 13]}]], "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a \u2264 b - toIcoDiv hp a b \u2022 p\nhr : b - toIcoDiv hp a b \u2022 p < a + p\n\u22a2 \u2203 i, b \u2208 Ico (a + i \u2022 p) (a + (i + 1) \u2022 p)", "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a \u2264 b - toIcoDiv hp a b \u2022 p\nhr : b - toIcoDiv hp a b \u2022 p < a + p\n\u22a2 b < a + (toIcoDiv hp a b + 1) \u2022 p"}, {"tactic": "rw [add_smul, one_smul, \u2190 add_assoc]", "annotated_tactic": ["rw [<a>add_smul</a>, <a>one_smul</a>, \u2190 <a>add_assoc</a>]", [{"full_name": "add_smul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [92, 9], "def_end_pos": [92, 17]}, {"full_name": "one_smul", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [481, 9], "def_end_pos": [481, 17]}, {"full_name": "add_assoc", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [285, 3], "def_end_pos": [285, 14]}]], "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a \u2264 b - toIcoDiv hp a b \u2022 p\nhr : b - toIcoDiv hp a b \u2022 p < a + p\n\u22a2 b < a + (toIcoDiv hp a b + 1) \u2022 p", "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a \u2264 b - toIcoDiv hp a b \u2022 p\nhr : b - toIcoDiv hp a b \u2022 p < a + p\n\u22a2 b < a + toIcoDiv hp a b \u2022 p + p"}, {"tactic": "convert sub_lt_iff_lt_add.mp hr using 1", "annotated_tactic": ["convert sub_lt_iff_lt_add.mp hr using 1", []], "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a \u2264 b - toIcoDiv hp a b \u2022 p\nhr : b - toIcoDiv hp a b \u2022 p < a + p\n\u22a2 b < a + toIcoDiv hp a b \u2022 p + p", "state_after": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a \u2264 b - toIcoDiv hp a b \u2022 p\nhr : b - toIcoDiv hp a b \u2022 p < a + p\n\u22a2 a + toIcoDiv hp a b \u2022 p + p = a + p + toIcoDiv hp a b \u2022 p"}, {"tactic": "abel", "annotated_tactic": ["abel", []], "state_before": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na b : \u03b1\nhl : a \u2264 b - toIcoDiv hp a b \u2022 p\nhr : b - toIcoDiv hp a b \u2022 p < a + p\n\u22a2 a + toIcoDiv hp a b \u2022 p + p = a + p + toIcoDiv hp a b \u2022 p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "IsUnit.div_mul_left", "start": [1080, 1], "end": [1083, 67], "traced_tactics": [{"tactic": "rw [div_eq_mul_inv, mul_inv_rev, h.mul_inv_cancel_left, one_div]", "annotated_tactic": ["rw [<a>div_eq_mul_inv</a>, <a>mul_inv_rev</a>, h.mul_inv_cancel_left, <a>one_div</a>]", [{"full_name": "div_eq_mul_inv", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [997, 9], "def_end_pos": [997, 23]}, {"full_name": "mul_inv_rev", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1070, 9], "def_end_pos": [1070, 20]}, {"full_name": "one_div", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [386, 9], "def_end_pos": [386, 16]}]], "state_before": "\u03b1 : Type u\nM : Type u_1\nN : Type u_2\ninst\u271d : DivisionMonoid \u03b1\na b c : \u03b1\nh : IsUnit b\n\u22a2 b / (a * b) = 1 / a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Exponent.lean", "full_name": "Monoid.exponent_ne_zero_iff_range_orderOf_finite", "start": [343, 1], "end": [363, 31], "traced_tactics": [{"tactic": "refine' \u27e8fun he => _, fun he => _\u27e9", "annotated_tactic": ["refine' \u27e8fun he => _, fun he => _\u27e9", []], "state_before": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\n\u22a2 exponent G \u2260 0 \u2194 Set.Finite (Set.range orderOf)", "state_after": "case refine'_1\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nhe : exponent G \u2260 0\n\u22a2 Set.Finite (Set.range orderOf)\n\ncase refine'_2\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nhe : Set.Finite (Set.range orderOf)\n\u22a2 exponent G \u2260 0"}, {"tactic": "by_contra h", "annotated_tactic": ["by_contra h", []], "state_before": "case refine'_1\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nhe : exponent G \u2260 0\n\u22a2 Set.Finite (Set.range orderOf)", "state_after": "case refine'_1\nG : Type u\ninst\u271d : Monoid G\nh\u271d : \u2200 (g : G), 0 < orderOf g\nhe : exponent G \u2260 0\nh : \u00acSet.Finite (Set.range orderOf)\n\u22a2 False"}, {"tactic": "obtain \u27e8m, \u27e8t, rfl\u27e9, het\u27e9 := Set.Infinite.exists_gt h (exponent G)", "annotated_tactic": ["obtain \u27e8m, \u27e8t, rfl\u27e9, het\u27e9 := <a>Set.Infinite.exists_gt</a> h (<a>exponent</a> G)", [{"full_name": "Set.Infinite.exists_gt", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/LocallyFinite/Basic.lean", "def_pos": [872, 9], "def_end_pos": [872, 38]}, {"full_name": "Monoid.exponent", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Exponent.lean", "def_pos": [76, 19], "def_end_pos": [76, 27]}]], "state_before": "case refine'_1\nG : Type u\ninst\u271d : Monoid G\nh\u271d : \u2200 (g : G), 0 < orderOf g\nhe : exponent G \u2260 0\nh : \u00acSet.Finite (Set.range orderOf)\n\u22a2 False", "state_after": "case refine'_1.intro.intro.intro\nG : Type u\ninst\u271d : Monoid G\nh\u271d : \u2200 (g : G), 0 < orderOf g\nhe : exponent G \u2260 0\nh : \u00acSet.Finite (Set.range orderOf)\nt : G\nhet : exponent G < orderOf t\n\u22a2 False"}, {"tactic": "exact pow_ne_one_of_lt_orderOf' he het (pow_exponent_eq_one t)", "annotated_tactic": ["exact <a>pow_ne_one_of_lt_orderOf'</a> he het (<a>pow_exponent_eq_one</a> t)", [{"full_name": "pow_ne_one_of_lt_orderOf'", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [233, 9], "def_end_pos": [233, 34]}, {"full_name": "Monoid.pow_exponent_eq_one", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Exponent.lean", "def_pos": [150, 9], "def_end_pos": [150, 28]}]], "state_before": "case refine'_1.intro.intro.intro\nG : Type u\ninst\u271d : Monoid G\nh\u271d : \u2200 (g : G), 0 < orderOf g\nhe : exponent G \u2260 0\nh : \u00acSet.Finite (Set.range orderOf)\nt : G\nhet : exponent G < orderOf t\n\u22a2 False", "state_after": "no goals"}, {"tactic": "lift Set.range (orderOf (G := G)) to Finset \u2115 using he with t ht", "annotated_tactic": ["lift <a>Set.range</a> (<a>orderOf</a> (G := G)) to <a>Finset</a> \u2115 using he with t ht", [{"full_name": "Set.range", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [157, 5], "def_end_pos": [157, 10]}, {"full_name": "orderOf", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [154, 19], "def_end_pos": [154, 26]}, {"full_name": "Finset", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [140, 11], "def_end_pos": [140, 17]}]], "state_before": "case refine'_2\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nhe : Set.Finite (Set.range orderOf)\n\u22a2 exponent G \u2260 0", "state_after": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\n\u22a2 exponent G \u2260 0"}, {"tactic": "have htpos : 0 < t.prod id := by\n  refine' Finset.prod_pos fun a ha => _\n  rw [\u2190 Finset.mem_coe, ht] at ha\n  obtain \u27e8k, rfl\u27e9 := ha\n  exact h k", "annotated_tactic": ["have htpos : 0 < t.prod <a>id</a> := by\n      refine' <a>Finset.prod_pos</a> fun a ha => _\n      rw [\u2190 <a>Finset.mem_coe</a>, ht] at ha\n      obtain \u27e8k, rfl\u27e9 := ha\n      exact h k", [{"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "Finset.prod_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Order.lean", "def_pos": [648, 9], "def_end_pos": [648, 17]}, {"full_name": "Finset.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}]], "state_before": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\n\u22a2 exponent G \u2260 0", "state_after": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\n\u22a2 exponent G \u2260 0"}, {"tactic": "suffices exponent G \u2223 t.prod id by\n  intro h\n  rw [h, zero_dvd_iff] at this\n  exact htpos.ne' this", "annotated_tactic": ["suffices <a>exponent</a> G \u2223 t.prod <a>id</a> by\n      intro h\n      rw [h, <a>zero_dvd_iff</a>] at this\n      exact htpos.ne' this", [{"full_name": "Monoid.exponent", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Exponent.lean", "def_pos": [76, 19], "def_end_pos": [76, 27]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "zero_dvd_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean", "def_pos": [33, 9], "def_end_pos": [33, 21]}]], "state_before": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\n\u22a2 exponent G \u2260 0", "state_after": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\n\u22a2 exponent G \u2223 Finset.prod t id"}, {"tactic": "rw [exponent_dvd]", "annotated_tactic": ["rw [<a>exponent_dvd</a>]", [{"full_name": "Monoid.exponent_dvd", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/Exponent.lean", "def_pos": [241, 9], "def_end_pos": [241, 21]}]], "state_before": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\n\u22a2 exponent G \u2223 Finset.prod t id", "state_after": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\n\u22a2 \u2200 (g : G), orderOf g \u2223 Finset.prod t id"}, {"tactic": "intro g", "annotated_tactic": ["intro g", []], "state_before": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\n\u22a2 \u2200 (g : G), orderOf g \u2223 Finset.prod t id", "state_after": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\ng : G\n\u22a2 orderOf g \u2223 Finset.prod t id"}, {"tactic": "apply Finset.dvd_prod_of_mem id (?_ : orderOf g \u2208 _)", "annotated_tactic": ["apply <a>Finset.dvd_prod_of_mem</a> <a>id</a> (?_ : <a>orderOf</a> g \u2208 _)", [{"full_name": "Finset.dvd_prod_of_mem", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1814, 9], "def_end_pos": [1814, 24]}, {"full_name": "id", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "orderOf", "def_path": ".lake/packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [154, 19], "def_end_pos": [154, 26]}]], "state_before": "case refine'_2.intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\ng : G\n\u22a2 orderOf g \u2223 Finset.prod t id", "state_after": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\ng : G\n\u22a2 orderOf g \u2208 t"}, {"tactic": "rw [\u2190 Finset.mem_coe, ht]", "annotated_tactic": ["rw [\u2190 <a>Finset.mem_coe</a>, ht]", [{"full_name": "Finset.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}]], "state_before": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\ng : G\n\u22a2 orderOf g \u2208 t", "state_after": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\ng : G\n\u22a2 orderOf g \u2208 Set.range orderOf"}, {"tactic": "exact Set.mem_range_self g", "annotated_tactic": ["exact <a>Set.mem_range_self</a> g", [{"full_name": "Set.mem_range_self", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Defs.lean", "def_pos": [163, 23], "def_end_pos": [163, 37]}]], "state_before": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\ng : G\n\u22a2 orderOf g \u2208 Set.range orderOf", "state_after": "no goals"}, {"tactic": "refine' Finset.prod_pos fun a ha => _", "annotated_tactic": ["refine' <a>Finset.prod_pos</a> fun a ha => _", [{"full_name": "Finset.prod_pos", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/BigOperators/Order.lean", "def_pos": [648, 9], "def_end_pos": [648, 17]}]], "state_before": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\n\u22a2 0 < Finset.prod t id", "state_after": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\na : \u2115\nha : a \u2208 t\n\u22a2 0 < id a"}, {"tactic": "rw [\u2190 Finset.mem_coe, ht] at ha", "annotated_tactic": ["rw [\u2190 <a>Finset.mem_coe</a>, ht] at ha", [{"full_name": "Finset.mem_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}]], "state_before": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\na : \u2115\nha : a \u2208 t\n\u22a2 0 < id a", "state_after": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\na : \u2115\nha : a \u2208 Set.range orderOf\n\u22a2 0 < id a"}, {"tactic": "obtain \u27e8k, rfl\u27e9 := ha", "annotated_tactic": ["obtain \u27e8k, rfl\u27e9 := ha", []], "state_before": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\na : \u2115\nha : a \u2208 Set.range orderOf\n\u22a2 0 < id a", "state_after": "case intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nk : G\n\u22a2 0 < id (orderOf k)"}, {"tactic": "exact h k", "annotated_tactic": ["exact h k", []], "state_before": "case intro\nG : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nk : G\n\u22a2 0 < id (orderOf k)", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "G : Type u\ninst\u271d : Monoid G\nh : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\nthis : exponent G \u2223 Finset.prod t id\n\u22a2 exponent G \u2260 0", "state_after": "G : Type u\ninst\u271d : Monoid G\nh\u271d : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\nthis : exponent G \u2223 Finset.prod t id\nh : exponent G = 0\n\u22a2 False"}, {"tactic": "rw [h, zero_dvd_iff] at this", "annotated_tactic": ["rw [h, <a>zero_dvd_iff</a>] at this", [{"full_name": "zero_dvd_iff", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean", "def_pos": [33, 9], "def_end_pos": [33, 21]}]], "state_before": "G : Type u\ninst\u271d : Monoid G\nh\u271d : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\nthis : exponent G \u2223 Finset.prod t id\nh : exponent G = 0\n\u22a2 False", "state_after": "G : Type u\ninst\u271d : Monoid G\nh\u271d : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\nthis : Finset.prod t id = 0\nh : exponent G = 0\n\u22a2 False"}, {"tactic": "exact htpos.ne' this", "annotated_tactic": ["exact htpos.ne' this", []], "state_before": "G : Type u\ninst\u271d : Monoid G\nh\u271d : \u2200 (g : G), 0 < orderOf g\nt : Finset \u2115\nht : \u2191t = Set.range orderOf\nexponent_ne_zero_iff_range_orderOf_finite\u271d exponent_ne_zero_iff_range_orderOf_finite :\n  (\u2200 (g : G), 0 < orderOf g) \u2192 (exponent G \u2260 0 \u2194 Set.Finite \u2191t)\nhtpos : 0 < Finset.prod t id\nthis : Finset.prod t id = 0\nh : exponent G = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.pow_mem", "start": [379, 11], "end": [380, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/FiniteDimensional.lean", "full_name": "coe_finsetBasisOfLinearIndependentOfCardEqFinrank", "start": [979, 1], "end": [984, 25], "traced_tactics": [{"tactic": "rw [finsetBasisOfLinearIndependentOfCardEqFinrank]", "annotated_tactic": ["rw [<a>finsetBasisOfLinearIndependentOfCardEqFinrank</a>]", [{"full_name": "finsetBasisOfLinearIndependentOfCardEqFinrank", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/FiniteDimensional.lean", "def_pos": [972, 19], "def_end_pos": [972, 64]}]], "state_before": "K : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Finset V\nhs : s.Nonempty\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : s.card = finrank K V\n\u22a2 \u21d1(finsetBasisOfLinearIndependentOfCardEqFinrank hs lin_ind card_eq) = Subtype.val", "state_after": "K : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Finset V\nhs : s.Nonempty\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : s.card = finrank K V\n\u22a2 \u21d1(basisOfLinearIndependentOfCardEqFinrank lin_ind \u22ef) = Subtype.val"}, {"tactic": "exact Basis.coe_mk _ _", "annotated_tactic": ["exact <a>Basis.coe_mk</a> _ _", [{"full_name": "Basis.coe_mk", "def_path": ".lake/packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [1123, 9], "def_end_pos": [1123, 15]}]], "state_before": "K : Type u\nV : Type v\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\ns : Finset V\nhs : s.Nonempty\nlin_ind : LinearIndependent K Subtype.val\ncard_eq : s.card = finrank K V\n\u22a2 \u21d1(basisOfLinearIndependentOfCardEqFinrank lin_ind \u22ef) = Subtype.val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Real/NNReal.lean", "full_name": "Set.OrdConnected.image_real_toNNReal", "start": [1136, 1], "end": [1143, 79], "traced_tactics": [{"tactic": "refine' \u27e8forall_mem_image.2 fun x hx => forall_mem_image.2 fun y hy z hz => _\u27e9", "annotated_tactic": ["refine' \u27e8<a>forall_mem_image</a>.2 fun x hx => <a>forall_mem_image</a>.2 fun y hy z hz => _\u27e9", [{"full_name": "Set.forall_mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [224, 9], "def_end_pos": [224, 25]}, {"full_name": "Set.forall_mem_image", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [224, 9], "def_end_pos": [224, 25]}]], "state_before": "s : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\n\u22a2 OrdConnected (toNNReal '' s)", "state_after": "s : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\ny : \u211d\nhy : y \u2208 s\nz : \u211d\u22650\nhz : z \u2208 Icc (toNNReal x) (toNNReal y)\n\u22a2 z \u2208 toNNReal '' s"}, {"tactic": "rcases le_total y 0 with hy\u2080 | hy\u2080", "annotated_tactic": ["rcases <a>le_total</a> y 0 with hy\u2080 | hy\u2080", [{"full_name": "le_total", "def_path": ".lake/packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [289, 9], "def_end_pos": [289, 17]}]], "state_before": "s : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\ny : \u211d\nhy : y \u2208 s\nz : \u211d\u22650\nhz : z \u2208 Icc (toNNReal x) (toNNReal y)\n\u22a2 z \u2208 toNNReal '' s", "state_after": "case inl\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\ny : \u211d\nhy : y \u2208 s\nz : \u211d\u22650\nhz : z \u2208 Icc (toNNReal x) (toNNReal y)\nhy\u2080 : y \u2264 0\n\u22a2 z \u2208 toNNReal '' s\n\ncase inr\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\ny : \u211d\nhy : y \u2208 s\nz : \u211d\u22650\nhz : z \u2208 Icc (toNNReal x) (toNNReal y)\nhy\u2080 : 0 \u2264 y\n\u22a2 z \u2208 toNNReal '' s"}, {"tactic": "rw [mem_Icc, Real.toNNReal_of_nonpos hy\u2080, nonpos_iff_eq_zero] at hz", "annotated_tactic": ["rw [<a>mem_Icc</a>, <a>Real.toNNReal_of_nonpos</a> hy\u2080, <a>nonpos_iff_eq_zero</a>] at hz", [{"full_name": "Set.mem_Icc", "def_path": ".lake/packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [131, 9], "def_end_pos": [131, 16]}, {"full_name": "Real.toNNReal_of_nonpos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [657, 9], "def_end_pos": [657, 27]}, {"full_name": "nonpos_iff_eq_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [224, 3], "def_end_pos": [224, 14]}]], "state_before": "case inl\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\ny : \u211d\nhy : y \u2208 s\nz : \u211d\u22650\nhz : z \u2208 Icc (toNNReal x) (toNNReal y)\nhy\u2080 : y \u2264 0\n\u22a2 z \u2208 toNNReal '' s", "state_after": "case inl\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\ny : \u211d\nhy : y \u2208 s\nz : \u211d\u22650\nhz : toNNReal x \u2264 z \u2227 z = 0\nhy\u2080 : y \u2264 0\n\u22a2 z \u2208 toNNReal '' s"}, {"tactic": "exact \u27e8y, hy, (toNNReal_of_nonpos hy\u2080).trans hz.2.symm\u27e9", "annotated_tactic": ["exact \u27e8y, hy, (<a>toNNReal_of_nonpos</a> hy\u2080).<a>trans</a> hz.2.<a>symm</a>\u27e9", [{"full_name": "Real.toNNReal_of_nonpos", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [657, 9], "def_end_pos": [657, 27]}, {"full_name": "Eq.trans", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [335, 9], "def_end_pos": [335, 17]}, {"full_name": "Eq.symm", "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [323, 9], "def_end_pos": [323, 16]}]], "state_before": "case inl\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\ny : \u211d\nhy : y \u2208 s\nz : \u211d\u22650\nhz : toNNReal x \u2264 z \u2227 z = 0\nhy\u2080 : y \u2264 0\n\u22a2 z \u2208 toNNReal '' s", "state_after": "no goals"}, {"tactic": "lift y to \u211d\u22650 using hy\u2080", "annotated_tactic": ["lift y to \u211d\u22650 using hy\u2080", []], "state_before": "case inr\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\ny : \u211d\nhy : y \u2208 s\nz : \u211d\u22650\nhz : z \u2208 Icc (toNNReal x) (toNNReal y)\nhy\u2080 : 0 \u2264 y\n\u22a2 z \u2208 toNNReal '' s", "state_after": "case inr.intro\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\nz y : \u211d\u22650\nhy : \u2191y \u2208 s\nhz : z \u2208 Icc (toNNReal x) (toNNReal \u2191y)\n\u22a2 z \u2208 toNNReal '' s"}, {"tactic": "rw [toNNReal_coe] at hz", "annotated_tactic": ["rw [<a>toNNReal_coe</a>] at hz", [{"full_name": "Real.toNNReal_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [396, 9], "def_end_pos": [396, 33]}]], "state_before": "case inr.intro\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\nz y : \u211d\u22650\nhy : \u2191y \u2208 s\nhz : z \u2208 Icc (toNNReal x) (toNNReal \u2191y)\n\u22a2 z \u2208 toNNReal '' s", "state_after": "case inr.intro\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\nz y : \u211d\u22650\nhy : \u2191y \u2208 s\nhz : z \u2208 Icc (toNNReal x) y\n\u22a2 z \u2208 toNNReal '' s"}, {"tactic": "exact \u27e8z, h.out hx hy \u27e8toNNReal_le_iff_le_coe.1 hz.1, hz.2\u27e9, toNNReal_coe\u27e9", "annotated_tactic": ["exact \u27e8z, h.out hx hy \u27e8<a>toNNReal_le_iff_le_coe</a>.1 hz.1, hz.2\u27e9, <a>toNNReal_coe</a>\u27e9", [{"full_name": "Real.toNNReal_le_iff_le_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [782, 9], "def_end_pos": [782, 31]}, {"full_name": "Real.toNNReal_coe", "def_path": ".lake/packages/mathlib/Mathlib/Data/Real/NNReal.lean", "def_pos": [396, 9], "def_end_pos": [396, 33]}]], "state_before": "case inr.intro\ns : Set \u211d\nt : Set \u211d\u22650\nh : OrdConnected s\nx : \u211d\nhx : x \u2208 s\nz y : \u211d\u22650\nhy : \u2191y \u2208 s\nhz : z \u2208 Icc (toNNReal x) y\n\u22a2 z \u2208 toNNReal '' s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.map_comap_le", "start": [3064, 1], "end": [3065, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Data/Complex/Basic.lean", "full_name": "Complex.I_zpow_bit1", "start": [865, 1], "end": [865, 91], "traced_tactics": [{"tactic": "rw [zpow_bit1', I_mul_I]", "annotated_tactic": ["rw [<a>zpow_bit1'</a>, <a>I_mul_I</a>]", [{"full_name": "zpow_bit1'", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Bitwise.lean", "def_pos": [33, 9], "def_end_pos": [33, 19]}, {"full_name": "Complex.I_mul_I", "def_path": ".lake/packages/mathlib/Mathlib/Data/Complex/Basic.lean", "def_pos": [317, 9], "def_end_pos": [317, 16]}]], "state_before": "n : \u2124\n\u22a2 I ^ bit1 n = (-1) ^ n * I", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Algebra/Ring/Defs.lean", "full_name": "ite_zero_mul_ite_zero", "start": [237, 1], "end": [238, 72], "traced_tactics": [{"tactic": "simp only [\u2190 ite_and, ite_mul, mul_ite, mul_zero, zero_mul, and_comm]", "annotated_tactic": ["simp only [\u2190 <a>ite_and</a>, <a>ite_mul</a>, <a>mul_ite</a>, <a>mul_zero</a>, <a>zero_mul</a>, <a>and_comm</a>]", [{"full_name": "ite_and", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [1240, 9], "def_end_pos": [1240, 16]}, {"full_name": "ite_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [203, 9], "def_end_pos": [203, 16]}, {"full_name": "mul_ite", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [197, 9], "def_end_pos": [197, 16]}, {"full_name": "MulZeroClass.mul_zero", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [37, 3], "def_end_pos": [37, 11]}, {"full_name": "MulZeroClass.zero_mul", "def_path": ".lake/packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [35, 3], "def_end_pos": [35, 11]}, {"full_name": "and_comm", "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean", "def_pos": [814, 9], "def_end_pos": [814, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nR : Type x\ninst\u271d\u00b2 : MulZeroClass \u03b1\nP Q : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Decidable Q\na b : \u03b1\n\u22a2 ((if P then a else 0) * if Q then b else 0) = if P \u2227 Q then a * b else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.HasBasis.sup_principal", "start": [621, 1], "end": [625, 26], "traced_tactics": [{"tactic": "simp only [(hl.sup' (hasBasis_principal t)).mem_iff, PProd.exists, exists_prop, and_true_iff,\n  Unique.exists_iff]", "annotated_tactic": ["simp only [(hl.sup' (<a>hasBasis_principal</a> t)).<a>mem_iff</a>, <a>PProd.exists</a>, <a>exists_prop</a>, <a>and_true_iff</a>,\n      <a>Unique.exists_iff</a>]", [{"full_name": "Filter.hasBasis_principal", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [589, 9], "def_end_pos": [589, 27]}, {"full_name": "Filter.HasBasis.mem_iff", "def_path": ".lake/packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [264, 9], "def_end_pos": [264, 25]}, {"full_name": "PProd.exists", "def_path": ".lake/packages/mathlib/Mathlib/Data/Prod/PProd.lean", "def_pos": [32, 9], "def_end_pos": [32, 17]}, {"full_name": "exists_prop", "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean", "def_pos": [240, 17], "def_end_pos": [240, 28]}, {"full_name": "and_true_iff", "def_path": ".lake/packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [138, 9], "def_end_pos": [138, 21]}, {"full_name": "Unique.exists_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Unique.lean", "def_pos": [140, 9], "def_end_pos": [140, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nhl : HasBasis l p s\nt u : Set \u03b1\n\u22a2 u \u2208 l \u2294 \ud835\udcdf t \u2194 \u2203 i, p i \u2227 s i \u222a t \u2286 u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Topology/Order/OrderClosed.lean", "full_name": "Ioc_mem_nhdsWithin_Ici", "start": [588, 1], "end": [589, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.lift_apply", "start": [524, 1], "end": [525, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "f8b56ceb773dd90e0ab046ade6983f11b01f2e80", "file_path": "Mathlib/Logic/IsEmpty.lean", "full_name": "isEmpty_pi", "start": [152, 1], "end": [153, 68], "traced_tactics": [{"tactic": "simp only [\u2190 not_nonempty_iff, Classical.nonempty_pi, not_forall]", "annotated_tactic": ["simp only [\u2190 <a>not_nonempty_iff</a>, <a>Classical.nonempty_pi</a>, <a>not_forall</a>]", [{"full_name": "not_nonempty_iff", "def_path": ".lake/packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [137, 9], "def_end_pos": [137, 25]}, {"full_name": "Classical.nonempty_pi", "def_path": ".lake/packages/mathlib/Mathlib/Logic/Nonempty.lean", "def_pos": [168, 9], "def_end_pos": [168, 30]}, {"full_name": "Classical.not_forall", "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean", "def_pos": [130, 17], "def_end_pos": [130, 27]}]], "state_before": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03c0 : \u03b1 \u2192 Sort u_4\n\u22a2 IsEmpty ((a : \u03b1) \u2192 \u03c0 a) \u2194 \u2203 a, IsEmpty (\u03c0 a)", "state_after": "no goals"}]}]